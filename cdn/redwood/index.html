<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"708d4408b65bf40d74ad160d2d75bdf4066f0f14e15e951bf184c46b9b710b90124169d168e7b0bee18d84a3e602740e0f62165acfad3a7fe45dc8a64b2fd946215d585d5d862f1daf9c48293f9252588d7c3b972a8c493564e3b93acada7993af3def3af372fb7e508431e63b222cc702ac2d98efc7e11a3a81b9ebda6af4c2d024ff6cc9998c539eeaecd37ea89eb7f43f8f63f02e61668cb2a2566e4e93275ecb8dcf907cecdde36c0ed0326d808436948871b0127f71fd555f0f313f91c94732b3531473417f11b3293906f1ba7b8f32ba86d9053a5af4e1e79c94d0f657a237de2d22687b6688a3c94250aa2ed753e6dae68269019bd181e02cb220061e562fe2696cfa786535d6dc942e8fb9a47e28e9055061674dd13c2e204363f40a24892d336aa5bd5209060cc19e5c38842da0b467ffcbd8e1bc533215ea31cdaedd91b02cc03b12160bd37fc8e3e04487288c831bdba18f547cc22c2b9d62d9f02804cd8ad3d0a1265463c6811cb43266b47d5467c93d2a790b2b321e88437d171aaf1ded72f6537277a1857c468429b3e61605a454064df476db3a9c7c05f5b92716c4b97cef3274cab47b9b4415d2876bc492b5554ed4502b30563479a746cead813f5e00ffff148f1952e535f4a102cbb9485dd0c923a2ee403ad45499daa09cff93f3249bbb944036d026b57accfd794b98d1b6c67db05ecbed571eef6bfa437a5aa567af27c3bac029a4fb5ae24b127c1fdcfb2add7019b758d486db559d8fe5e93b60bceb51e954dec31d7c005f7d4bba8560a382e23472621779964a2c4a691d1b28fd165337ce02d7a43adb37587c90a55cb4e239992a6084947ee304e6c815b47443e86dcdbcb3557d31b5ec6b30ba0739e76589c11962f195c4b4629e177340c28279a4138cc628bf351c9acd77117c736301c5f90a9dbce00e1db013c6bf6b3cdb3e209821067f8f2bbbbfda56610ff58058d73ccc9e802a9bc8c8e83fecb66203cfc22b56d9b5aa312878de58717b5638630e1623d0810a74a87b03cabe96e1ee02dccac2da44df40267d171fb4e14266662468a6ce8e36f122b096b9d19ef964015c4696eba593bc02414686ec58ccc938bf6adbd1a16f167e1c5812b725c5f6855748de5d8b52e3e6618d25ba4cc8b896133ffd314fc125146fa2cd42d1c17f981ff7da966c794522b0d519f1e7d1a9cbcd53c9deb2806a40ee6dca1dfa167a487ad4e6feb903e3386d4b0489beed5a0c971b023b8d02cd9be51d2e601ffba8edf40f14da9d5aa77c14326e10a1d554c028a71d9e9ea06dd9ee4f01e34b4c9fa850674d63ef9c4a9bcc95393b7b2d4d754718c5a823eded274901ff345acf19e7fd5f57c5969629c5d167b76a1a45862b33cfce11995f459a91e3141278334c03bce72cba3e79bdc76db68771374fd76c127446d4ad2157548007f1d21741b9b9f4da233264c028c9b30b0da44440e3830258a8738282dcb3e3f54dbea19bd679a29896f06f2e33cafbbf5b918cc1a0fbba0e38802f9e0ceb3394544e9b19529540864d70fc2c14e2ede8e9b67fee34312a11e4ac7ffd82c34494d2c814203b69f950bb11a43af9a0235309995ed8ff82d256d0c6eb6f53142d56e789bc046f80ed0aa6c4118d37f94b604200d7e36936ff76158dd6be899ccced136325985085d61121a555bb1963426ce52d0fef752a8a42709d08ce1fb0b88fc88206962d8db6af9bbbd8a6c0e80c81c99cd10121d119af52fa1aeb8e870fd0c06429648db55808138f46bf5a9dff0acfd28e1a33a1729dc8e7af94c28c091f29f94e3c2a11bd7f9ffb6853c44832caac3f050870e32c6c6ba1742ee18cec1c6c18e2c0e5e119ff05af41da03b0957ddab7e196426ba5c4ac5e0218e985a9ddb705b082697d28d7226762be7ff25fe6e4df1bcb3e3dc91e5f5be9ea810d2e6a32e68f13fb9997f35550ca39223d44a86678407f25eee60b3c8fdd3b63b89a4eb058c7b690ee66b1fc4a44e98e4bdcdaee5e68cea22955fcaa8c11e7bc8ee8676e21dcbb63c4f4331d29317c39998301ca8ed41685c53f156738d2d94ad8e62573bef68b5816147139d69fab58d5c40186496d05a587683ef426b57d56ca72dad59ebf84c6d9e00441dc7c375565de04e516a706b067bffeafae51783556d8fb91c210843d790875642fd08df3f7ff5f5cc8c96aeaa7d8eaedd5623ce9f332638e081b934be1534c0fdcc7e3a3b1ad59ef859925c8d83c4635b51004bd33b16d2842390689ae47f9b439da044b939f58d40475b67630b2e666463a9310b13ebbae412d1b6c071353b7c0e33f4244bf2a4d3cb2f755c07f997af26a55c5eb2640cea07cc83001f43c22ac32f504bd2d60acd223c5336f178fdcc3fa3bc9e9d56810ddaf4aed3c468e58060bff461abe7ca7e4fbff14ae87810b15a8f5407c6d1efa9c57e3eb8d16ae0dd22f86f69cba16bc14b9da95dd5a740f5ef35f22cabe81addb09b51a24c921cf776dfefa5ffa7e914d97c396201a0b93170263e9c7ab3d357edb4e8319214219e52cc4f92d7637f135f257cec9b6400f6834532504686597788e600d9f16eaefa57aa6bd434db0682c2baf21546d7b41e81877af58b406e4f738fd4c1dd0c35da339e13c4174342c7c6c87e509d6bfc2f4ab4de097c0777ca5fa872d5b95321373aac408d5ef29a8e14cc44c32ed421f83e522eaecc156b60d4949215d2a2b5cc10c31a1ff3cc34b935ea4019845bf75746e6d8d0e2007822039da951b6ef5149f54985a3d4e69fa333919d7569dbcbf57aa3460b5019c81f422c7ca0feff8cf6e04f76df2c33b2ac2a455e848e073f04dfaf824f22c58ab75781700208bdd83d72ac289951e6ddc9970c5dcf73c0b948d80b081efd4b3b6e72be44ee83a18c95428cfc9c4c7d1f91d645887689b021f874e28add8b2ff75c9b5fae635d76a48f62329eb64df3c6c28e0c9888592f3e6a46476993dbc09a352d8d8fa2b0ee2eedf87bdfb79bc2852857581542ec47227645c3e1cda45077b8f34193b023fd28291fea905e02cd9d6deb885cade6063548c53624f55d1c55403c5a7108040104ff7b1e2cc2c1034d3fa5d05ecf3e774b0bac72a238cd7d668c9135d3a15a884cee30195f8067a251de80df8e280b406cc149e1a4cacf80dfe202d652f0db19671f775764c8abe930920ac11dfaf20f4068546ec2a581c2297232deb54823c9f634cc0cba0b164c210834fdf003f3132ee825ed798f270e2eaa5b1e568f3df180aad7ab20c1f5dc98f65333a188d8e323a1ea488f4c88648156325ee42b8e81951e2ab39719d266ea6a44e706f8f8eb947b068c01efefd270620717f3e0982f000ddb86f7ac08ae1183fc499d6f93523cb27eec3e148660fcd0b8dedf70aa77426af2370a65fa41e30eee23c8ed446d57ff44468d3a78cd0ba48dd979e67748f282f13de068c2e5f8c3e2b2af683489425a42407aa5ed5f157d6ae9077142f1c9eec05850031a3804dec950998d4d1540429d5cc77d4bdfc2e3ab1f580cdf0d4c202e3262360b2c163975ea41faa14b6ac278b19a29686558cceda7ca85f0714eaef7e73201d95d25f8f9f8cd9d07579b06df51575eb4d836a7e1aae9ae85d71cf5bc0c43143c2a44b9cd4ea0cc6e13cbd980735993d24d197233c8fd29de77702db4b7ebf3e7b94f471efb631f5f390f2be5e7ecb063a6c702ee8a828bb40484d88977551f91f8f5d08db4c54f026a85eebf1e5287a1abac6b62eb2b779cf2732002f18bc7a80e37e1877695c95b6ee7142af012f64574b787a7b62c7aa50a906759fb949cf02afa34477a6b023a52798645e201a7864ee65ec5fc2585ae3a198c8bcb832bbb6552ad3701a940719813f8ab0dba5c6435802485afe8f5602712a81a0060c95e48c5f4c58c546465bda5d50633a13fefe5de62c10bd3bf2042c6d8e56fabc7476aee4a2b9cd7a5f120667a7bc31734114072f2d5c707d9df815fe98a2871ee3aef9eea54b52f39ccf47202b45277ecc5f22eb494d432f7f27ae5982445528cc7f6ff874e4c656b0dde86369e01bc0be9861eac596a56041c1effd68cbffb4b03a965226dff60ffb5fbb879bcb463a515c78d8ff1761f9cac11888d32acc9ccffb7e26b54ae1f7b6cc541be27f93610dc2098ca6ca250321b928bb22fa0a0201a37aa54c4370f01776e086e7bb2bbd2563cf47dc00229f61acb387543d84eca62665fba6b25a80f6f1a510a5f75d8ca4d962b62c494ad5ba8df0a2dec88c1556c16d51b5ec7a99a67e18d435237241c2770e04911d1bcd9c7344ac91dd27175c0f85c8276dd6131c1e0fe6ef5d99a110828f1290a4cd34927b86bacf055048b367f94309602c9ab5335bd552fe01099bfb58f3b0235778f859e9c6e90361261fe9deb4abfe6a141e86948fa4ef1d0dc2461c164720d0e71cdac028ec50b710217fbdf50c175543c649973bdc367590062922e28d62810a875f603c050b4d3d35c044b77cfe99d4927e7d4462436d240502537cd27abd300a7ca73f29ac2f01aa22a66dff9f6f23886ed5734af86640852fe149627681f382b47c8395acdff40c9c08a4fca7004455fcbdd5ea8f773b24c9790fd5003c0472c75001d6c9ae71a67beb1adb41f1b5e3a1a675d5d1c680819eed5f2d994b08923b78644ddbb1f83f5b802e4b8701be90950f17d918a23829cdbbc917b9fa467f9bda7bd2eadfde4d7a860dbcfdfa8d5e378fd4f36d1b13a33532d03423209e6a54aee0426c1f36eebdce7611bca7709ff4418f6e3318e42b267716af63447a3647d787289ccf8de377ecd2e4ef955095c3f879e2cff48760bc134b2ed06c1b82a12f331609db7c282f638fc652b64fd61468bb0b5bd5a75b8c0a5bc7210ab40a2e78a51d869141647028bd29c274d308caa088ca1a9d71811c1687f512d05eedb6e709e76370df7e6b6dda7bb49cc2671e510b9a718f172bc04ad498d29354b7752360fb8dc0d74848a563d03b4bc292299dce0076f850fe39743457c504de1012cae9fbf55227fbb38d4552264becf04489b915f90ef34ae7102450f125803b329c9c46a5e40cfdef8febf68a3a7873ff7a21d1695dad05564c1e328d1fcb4f1f569cf06ef64c51993b19a61e6100ea9797fb7dda3c2485a0eb6208503bce1d7dedff4d5b8f28ce42750e30ab77d910b930610fa6e2180aa5b6d41040b2f0e21be7aef59a28fb0b749c91bf7e3eb4e8bf7915092097b57e632d0a22dc6e54699e01aae24853210a7a6585afc3eadf80c88353c44179a7b6a4c0afe6729f69dafbb15ed2387dedbd9ea94ff29470f1f237da1953ed3944b5a78dcd77929bf14ed0320113c99a7a8d0579a4bedf4cdb05c85f5350048589f2cf35b73110bc5c360d0d27efb0cf18195304e879a421ae15f20f1e8c4c7c0a60bbc1ab567d0ac288e10193ab529a743e3810cd26c838654ba35f679f625335bca08465ceb323c55cafc2ebb90044c47cf3368b5c613b970b4f81010621a06ab1d7b54dbc5aa033aa33686abe6dfe3038247b5fb6d7a91a3c07857346358afbe2a11238f87d63cb8edc8da5d1518a45b7c34ca049af124bbcac98739fb1710b1626b5ead857b8252b67e55476a14a25af5e09be0d838e1aeaf5c5fcd1a721a1c34fe2342eabfea220cee98eb9769664f4d391c84e7f1a7f97314963fef23d3777fd5a08afa583e2f53da01f9d8142c8fde6ea70a5dda2c31adf7e5f5ce61c739108ae3e390ac32088dcd1668ca7fb9aa3434aee9a79f02880f5bbd9e269a4bc7e676fc45ff9d9a4942b88c9a52f2e06b859714982da724505d246c6e26fcc16db62a4b5ab0afbcef64be767e5cda57e560cc4776f2b1eefefcffdf71e232c79601437a343cd24017fdb62454eec570d0c1dc288b72948c67656b91169e8457a641a905cb2205ec03a3e1dea7fc02458729a577f36a99d81e52bd9a055e030f97c1b28f9226aba610b4a32381c675bcdb5f3aa52659602fcfe717426219dc6c4857d1db01157bf47abe3f70a62a4f450bdbae6c0d0042374226cf265aaf9f42b49fc2b8b72e14fd7cda9234ccc4c3b609482a21ff097c5f930d346810779f0bdb3b052e79db6eb11151a1d73c8e51f4ec0292c78776b6a670fb425a4025c61ac4c4843604ced6712cfc3664d7761a78c31c1c6ebae7dea7ca99df09acdb65126aba2ae784f370736460ee9884388e7599bf5777d6cba05c8a270909eb2affb14f0c67f1ee2c01418f9f7307caab8f600a2f5ca37e23b1d0c7dc6ae98d178e85550c2629b8e1e97caa6f0a2d7b694e0f7460db61573fce2e867b385f7c37a7de3d044eb7813d713c9fc760fcdef9deb431f8dbbdc9e364b75fb6040c1a1f9ac5f83c79e74529f23fc68b34731e71f970c62ca3a0308ca46abc3588a72ef3cc385810458a073221c6baa409ad337ad75353bafec0c476dae7c3b15aa66492b33ff4e30a85cedc016ffddc290ecdfb5573aa70bdca035dbe54bcacbd9f03ad82aeb83986bb21aca71cf926c85ea413024fe2a630adf64ab18f6b6962e7280dd878a811a9c3492f0f325aaf448cc6f74b17328af46291b2ffec4bf39d44666c8e9f492025a5ac1467c864605eac6429cd1089c1c96ad72b28bd6826c6e576d586e70560f55513431669ecf34d58d5117de9b68646882200c654274d6c3c82268c7a02ed156fa9a2a8f32eea4ac9a0c4266f09230a0bb1bd1d70577c71af5015adf2806fa8bb5557aee61c471b0a45080cd6f4d78ffba2f810c6dde22ffe071578b6c42377879bc274b5e27255820cff8d4f6c378085d10b10781b4ed49362d17967c77e0d4f24dbdce0626d96f108135dc5e622d4cab086968e9861ae7d87ba471bf9ca0240a488e83446accfa3ba99d1cb8ed2ffdcb1afcadf9ddaee530a6652646f92680c267580a37653c9aa6c19b683f7d5cc1f3c27e42ed7694cf3a221cafb00ab8b9c749f6f9accbd49287dab2e6c1f48ef2385a36482d8d6363b6330ed747c7a974c76a5b69f13139d46b1a3c80bcd1e1e1c1901dcd111dd4fb447418ef64fe6ba2be2226eca318547bf83a7295984e30448b81c62fb082a948494949501137f2022eb75dfceeea7316eb15cf15f563b82840fda4afd3e661b13138801093931eb832fb9376f60a44d5ce943235eabca00a698d780db95d8ec465f61fba053e5d70af2f21df806a938362398c82652ded3fac7cbbdad4ad3aefc2d58d969d2000d9b95a44f2dd8f20b003befbcfa5aec79b53deb636b3482d60c3be6a4c9e3118b068ad87ac0728dda249e58ba0288f3877a6313b2c72f04f28ad5e874a4ac51a4f299fcd7de33f3b183c41d732ef0c7ad4752c543937d2762056c71dc65e4eeb7e935503faffeda4890878119933840cd624d10b83c87edd7a56b891e358897d961920634a1a2b758533db7975e0c341421d319196c7433ff570d303cff562c949cfc3c220136c60e061746719372333f349f0ec008b793d4b60965dfc7d1b5f3579f4c29d0bfadfc46cc5ca6812b6467dc0fda57140a0a98cdfcbcef765aa22fd1a9336db5c119b5d46f1616cf2edb721afee26641e45c1720c605f24a67a826a873ce85e46afbfa278c32337fa4f8ae8b64a242a4120a0eb69c3038556e03b7b3c4aaf2786878caac93df3a29a66b1ae966a5865e46cbec0dbb1eff9f1356338093273eeb53918c45a6a928c03ee4a24913b9fba46bcce582e0a857c3fa6b0e3706eb8598de78d4d29744efe8c8cba909b1d7d72e9a4483986e15b1f883702a25587e456c5c61013b97aefb99ac542762eab4c35f67c3d12ded0f5f6ac15ae2326b29e5c2526eb17fd20cf30857aab9b2951cbca9f5edaebc644f584ee05bab909bf065f09dd59507e2d243156299e3401cd7e1d12c79c0e36d1e167a1ec8c6f711ea5afef4eff8e5c27b5c3fd2748a4b8bff6bd173046a56a357c13f300a1740a6c6b800536807c279ead2d380713689ef736b9d26c3169a9708b8c0a6a9000ae9eef226c36b5fb4dc1c3d62ba9fffb7b22392b370a038de505b45e3dfc8adf897473215c9854e4859ea38e9bd4f026d3d972c6d09007b47f42411fcdc0521a2f564290463dc6d78628294e219fdf70e1a76a96863df69f8d436dcd019b5671863359fed2ee22ca5c31455f396d87c696f471419a0f43651b499a067b1f452f512b0d1c6264548acb8b5d03e731cc587d2d57b479842a4e64af856a8c455c64732144971209d78e9f5fc93487085dc6cd381dd498cbb833849123fa8efd37f829fb03a599805747f8925c8346efe6842d1c9b6a0e2fd87eb77ab90fc5c148093b7ded48a6ce7e06582fe90f15bf521cb066f1d357ee043c18607fb43fbba6474f86ea00f07d06842889fcce516302c1572d456bc6ccd17e147d02cb5349c338ceb57c9b4794afd4a8f6f8468adb79a7f3fdbb09ab2cbd67942a308a0c074b13d53f215705df5212f95eda272049c224a66a56668e92bb69af6551b8b421e97e8bb50258cf7f85f5df09d6985d01745820e2b0042746c89fecabbab1aec97f000e2b42bbbf46f6dacd810cdb790a013234c8da2c3b82681a76c7e14535f53250d1366dcbc44eb2a0aa6b5a38d3861bb035d7d3529b07bc383b9a2c217e3db8599c9144614da1028ed56c351e18470218f4e5344a0ad20de9712bf6f9f43e2610c20eebd2b781bc4c85d0f0f674eddb92be6e5640723b9b4c4f1593c8c2baea9b6edec918e9834bdd580cb201cabafc6e791044289e47e521fa8cdae23c611bc763b98679a0aa248b1a0a8bc3f63660ab5844e3d21a82b9266d5b8f0afb86f37123c11e8924eb238ae2b82b52a1b3a504f07ccad961b0614c8d540df9e552172f61d30821fa1fc99de7c9720fa2b51d4b4d0e5888ac79b48add0819da76a5c6c685c83eb40500fd7ba5defdd90662a5f7abbeb940ab99c7ff6817d1cc734b076805bd8b1d814d1f47e7a50cf1a641b02979e582f70ce75b5f078a9cff2862c11b73d453d2ec2711ab5ccd5efe5dc2b60cd13da547f621501a7051e630cc6b578ebce78060ff9a4211fa00fe353c18c3a93bfb98465c117ee67c6d9eced75915bafee29c65858b4bf7e8133b0b89f2de97fe5f1cf0ebd5608d0a99505177da520ea03ea8e4844658ee9728e93265ea7dfa1a98a0ef337b89582ca9be0c60874af21a149726f481634a01946385f18694c3c5c2afe7b8b467d773b6f55c20ccfa6907dab97a6aec477c6f515938fa7041b73fec4c38541f5b009758a8f0d3ba60eafa769408f18047646bba1375d738f68981740dc9f916911e08df79f7a8e530a5902d6e6cb1d7ad7af7a1f4e77dc199188cd380ca5b3eb62c67c8e5e342264ef6fb0198a6b34d799a5b2df668ea3952fe049517ea81aab5a9d961bd7640c4f486c04ec242cd55068473a4db6d45f994739468e91efb51c05f533e59897645e52eb140f02141303fe3b5dc1a268732aa5667c8c8c5cb2168019d2cd1d184dbef15fb13b8d98f914604f08f9521f680bf690191ecbfecb7c223db10ef5652414ccb4004a7f4f4aee332a544e6ee1411b2ef4f9e6d6e6fe4bdf4ff0f50fd87f60d6ab4ac59b64383a556e6eed9c45b71d4c8ee92a2e26bb3fa07489721973243382519fea0d8ea164b867c39f7df29a0fe90f136936bd76eec0aa24bb67eb08cbe91a2595c03e8386bad43cb1ff44134d0018ee9ec70e6a1151c9ff506f8cbf8e94c236470b0e7d1945d1aa951f4a94c8316bba69fa11b7525a39db427841f474cabc02d8e3d69bc87c8b04700dcf651ebd77789666b25c3b342969c1e0586531f0536d5d9c8780245aaeed01592a35d50a6a2ebd4114adfcb5c40993895bab91559d84143ed620fedd5f1eec7660cdcb91a0f9a0f049e48c5fb5d16c269053241dcc87d88734f1066cfe11bc44c7bd18de20d861877a35def19b21736ef467dae52ba5269c034b83fcb11efa0196f605ebc90cab6da86eef4bfc625ff697f9c88360e5d46e7084521fd1c73486ac4f9fdcfb28022ef42a3f8efb8d46c91aad1222fbdf68bc991d4e23450dd9a5058dd70764a341392409d255bbff4bd874aa562dd069d1213091d9af323489e5f41a2e5dbf73915b52870c055c189ac12a692589234d83243ce7e113ebc5bf84ca5d853eb51535c1d8664ec18b4c00fcddc2cdf1f0516ddfd7cf09320b10d88ca69b576e02bb1aad2a36125a99cd161759958f9a5b46b86c2dc0c71d2f0cb4ed6271405afb875b4bf86e699291f324aadbc124fe665d191180690133381c4668894172d1ee6bcf93340274689a2688bdfcdf79f0dc5a3d874558fb1d4957222527f0ebd77c4e93f022df39784e95e3ef339d5fb9d7f51e01d5d3db82e46fdd5ea4f72ed8217c6a5edf85a6c0f1ff90d439f19783dc8e550f1e990eaf574fb34ac0060a50bcc55f1cbf4f6d743cf477b81e0a54eb9b5629187dc5db63fa598e16c3ad79c7a22734efec05d42115458cc4286783c2b8f0ac6df00a08d622e7bd0a39e5a07b5428b58976cd456d5081aa1779366a5e0fb52689be21d221aa09a6d0aa30390aba92f1fcc9f2a7f34e8afcd9343671282fd430f05e5ab3036d12f6303f7afed4343c1c3a072c8b6b99369cf1309abea1521c29291ab424914ed6c389e27dc86f7ff45d3efd481db0733c2e7459cb2308b6127e15fcdc9ebaece06d7d99fcd7b5c342f72ed9ac1bae1ccc94e032cd2a4cd82f5987b0b028c3e12d1ffacb8163d4d076d2f30023bc7b77300d7e08c43b950d9b79fb0cc20865d78e7ee4f58e4ee60a9d5247803d2a4a553d0b4ff95c01e3ea3906b070f2c7044f95442688ffb6bf3b261194a97943053defc165a85cf0c5a097b6809d5d19da620dad36dff115b42fff8197cb0a21725ac0d227ac52ebd011da81328a66895e7557d6fe167d0a44be8009231e59435c075def4145cedc0ddd6a6347bc890e748141efdeb1c2b2a450a941e4b2bedb48ed8dbea6c91ff5a6289e4f025a9d8f1b60518586a2bfce0175abb51cd331d50f82b18ae986df123402384a3948e8f98b693f25716337b20e571ea62140632ff4a5c585a0ec731523a328427aa309f37066d7865dfc085a8477f9bfca745531bb9f77c7b89d12a9026ecffbe4fca7a32772c2c436e30a67c701fffc8a26a47f108e2ea71537f79585a25fe64cf978127064438e265288ea4fab1d974338bb23b91585d5891839a019da619211d026431d974be4c79a66b92dbb1415b5a82644b53af341ae0e2fbbb66571d584be3df262ee1a3cc60ebec7790ddf8bcb1fb7247d946f73bb47c98cdd07172e495386aba145ff02814dcb6863c58e33c35b141bf271d842d1c92e86ff772600327960bd6f37b5877d33efec721cbee91a42005829276270fd03278c9198f3326b459063526be422483743ee398db9c94feb299d89bb453c22125a83003c8026aee1635ca40e0222208bf4a152ae8087a5213d53863128b12a90b96d50b43cca0095016ed2bdf178dd038a06915fa403b4af1302f092527e1ff046f642a0f1b8293ccde9514bedfb7a6f7341da76f80a0bbc8a7da8571660a97d8b28d9953b28272e05cd85d1e8fdc7beaf8630203832ff8be5cc0b4185e05ef19ec2ef2d10d0be1cca7e1235a0a01272546fddeaf367e7fd820b92175bb047de0ab00351cd1f82494cef61a6b14d51065b96f7ea4f36e67e72e4eb6c5fb43a83b958735d807a19b17ea295ddfbb68e0f6aea267e402940530ef460a49c0d67a4bdea9568f1121963a95edcb6bf1106375d1a4a83021af1dba52d025776d0bab52e253a2043b9351fa326956f78cfc8299503e8a8519b18de3b13ba07beb1464ce070525a0b776f5cd9adffa12c402984a84f6dd500735460768fd3d78f2e70e716358332f880fcba30a4d8d9db74ebd5222b3ec8fb8832481fd0d722b4190f2bc317af1a54e7e4ae4019820a9006363ab5c17056cfec21fbff0261ea8e3febe248669c2287161451f0ee2813227fb55b5e85f93734b6ccaccaa4842362d4021f59669431ed6b1de4622fbc93019911ff2d4d7676acefa84ee5558999d8ee78823bb295bac5cd0e692fbbb90d0ab49e9f58ac58a34c18863aaacf82bacd9623c32ab5d13eb42a7f124b1ebda3284b70815bd5c7680c228caaf27f067b239523b83b239cb02b22d0d9ba457dcad175d95a171697be830747cf3aac1585cd69a25a3c0311dfd891a1cf0e937fcc3515fc9115953cbcb7c3d0d0497733584cb832ca24e95f0c7d52ffbf88d2c8ffafe50768c41fb20fc88780d72be4161230a9f0752f9b2f7285cc76099ffa2bdf3d3ceb5d0ac12c0fedb3e9346ac222362efceef5afd5dd08a37c908b497513d56183d61ae12e913acfef06ded393aa9c828883b382f4bd0bc4c0e504ccb4d6530baacd231f71ea2eda2b9bf6ea7d2bf0ce7b536a2b5f42f140b0cb314732347ef0cc2916f45ac93bdb6efb5aa9359c32e0408cae85d8bb4bf443223641ded3571afd0099a38f178f539619b91e67afb3d280bcc87275a1092a5dd5dd2adc7c61e14055a1a22cf3b1d393d3f3a40fe75629743d21b2cb6fc0251f5bc3499a59d5d53f7ffd09ccc43b6751dd4bbdb4bab21554134247e77de81ebc609a972eb278b10e7b369e9600b2da621274d33b52d776867883d5a9cd707e1655d2366243c4dfdfbe2c4ef07d0a7faea8936088ae0299ae2f9de14ec1cb4bc4d6ac8b44853cc569ff8ea7f4766aba8c80e32dd22744d636b344734dfca63006fdc42ff460c8b5f4030123fef501687a6928c85a4de413af6544e419644c8a806b27bf3f9e4ead9bcc88f88e78b43f667010fc430f26ec03aff8f2801da48a077cedc453b46d85fe262a59ae957cba4d5ba12ad7bdc96e7285c2ac9fe93d92b6a3f8a4bfd6db5fa953c6d5ae548aa0cf48e1b3fb1c6722a9fa145ad5903ffad55efe376f0f649ab20910bbb094dc8001664dd227d804f19d3316c8d73db67e513420d082f02ea2278e8a4906f7797bbe205bf549c8847df460d409a8c47aeefbceebb63e098696b0c5b228924098cc4c72138691bc416500546091d9bb98c936ed75d0521ef9b6ca0d6c12181d52cdb9a2e46d576ccf4bb7d893d64a7fd3c9c50b54382f4cc59ad24f9dfbdf6e3d603facb0b7fca43d00fa0033d03d6f775d2c12afa76c3848bc74a5d4241f3b23877a271c3850aafe489a0234a482b2779fee9deac59df47aa9b8b55b81bb8520c04ecadaf5cb643aee00f40b4c79aa4d264f2c2f815c034bae70923b43c2393de14ad62ead1dc3013478be33f0d8b4cdb644af818fab104d8736cabb57c40f4b8c241fbfa1f6e969622789ba1b25fe1ffdfe4acc187ac3a03075bd3e88d1739e5f72e22c5a8665121f773da9d36a9100c8cef57f38e5bf583f204997aa747ace6d8e49ce604667c712986076b82b8350d879164646ec1f828c97e3269b5cda6033e3c9bc341b7818a9dad100cf0fb1a501dbb3ebb3f327367ea69829afc2768ba842b931de4985e0fff8fb9ac8fd61686a36b60d36415388677512186212f03c675f1cc67de1a11025fef2321ef19f84acc76ddbc84b1a7b4765a662b75c631afba1db37f11bae6db20e8ac861fb97774ae6d232811a516ec0bb88ad05eca7aff1491c9fa8418e8da958991f10601caf3e3ef404d7c7bd10c8a7b844f8d323bfd79a2fd5c83914e704be09c2da74030795958b88866e885bd0a53f5bcc535c747fe3a6e0cc07ef8fe0acdabb2fd5eec0d540374197a1b9388bbf76ebe3c7a99837a83e97cc36e494eb864251848ee465e1f48010e61c612fddadeefda5230d4f0ba6fcba07cda24faccee0c00511528df208e792e7594322fbc83a72bd31843d69be14f19390bddc5214f2f38590bda1a10f6d1ac3f31fd2eaf0f44d626216d64e149ca2dc1ef9c505c799201b701390f3df564f50044ae537c028c40beaa283c63a7f536daa340f795674715ab2f684c5d3de5668788a23c32576deb9516e5e151007e7f16f8a4238b4bffb3689a8008cd4adff21d313b4e331c5ba397a0cf412193b17082755693be8f9a3698ff6f2a4cab08602f5f0070c616461c128e05d32926e2053869341dbecdb5a9f3582238f6ac98b3800d93542007d9bde0cabc6e5dec439c2a528e09a287552195988c488c258d90e25ddcc2a342de143d6fe4f7bff9751b923fe50efa014dee7386826dc1fcd6a34c576a0afa5ed7f3dade4a758f91e0d7aaa1d1f490cee2e5b5eade3e1e55dac28edb8dbafa1710cad375c6561f63a15de6e1bc0e589c60a5a225296140db1764f0f714170e4a6cbaaa32d7819f9314bb023960ce72803e2aaf4df33ab1bcadc98e388416c199172a35aa97fa707ae276bea60154c86178f927f7a0ac6c3a2e7fcf1baac29ace88fac94598853f02acad254d5b09e347957a52a94623dd633f84b1144314ad1622e38b0432ebba928d3b3cd02c32ebb93391ec81be40e87f63392498452e95c444ebbf9720989eb2ac31db5e8b2594d79c4f57c8d57258608bde2109ab3b074b6c48ce072c388dad1b963a4d7b028cad69d64051c77655df70bd5aeb95c4ae735d7cc6791d8afecb0532570f41e1955b89f3bb8630c85496b5994125b1d0b8f871b9bbf17a0a6c6e13bfce792f61920cab2b6ff82e1eca8b94b985e9d4d8d3f1dd41bee66ea56f0c1f96d5dd0361dd6505683c3fd4d84593765d6e09612ac4fdbfd653321370630d03f88644769c5b0748a339209d767ac6e5990ea15802d48b094bd526be08b4c418fa17d8f9192e261dc75e4f41cb5a19bf20e05bd2daaf93d7685551e26f7c2814cd4b1b146de7e56b9ffa82767fbd9080b8ba25673ebe92e7df744c6ce349321cfa8e1b6b8c8be52021ced3dcaa9b631fa1c8fce479a7143b6e8b7559940b574c797b362ef26377692ab25a20896bcb539f5e3cfdf27d5d1ae07faf868d5fd616f8108dff43916da54020d8523b72343391dac8eb125837feeae8f063c6abac7301692f051378f27c50cc66cda36044b4da10fcb5dfed64d124229a9fe4795843aae3e470df9537294f70dd4bfad494c77205f75d6c7180fdce0299ab011a580c38492ff450f57f41989e25974c7dc22637af0cb412368601f55bfae938234e928b9d6eb4dca53c51c38b695bec53a8d945f237a3a0f89ba8f78fda48d42fe90310cb80e0981b902d0e28dd9dd5f20473100e9b2e593164c2c269e434d0a66e74ff2f44710c72b0881d4064b51802b0c74d0764b3153c8f34661eaabdefbb34dce014fdae1e4cae1f74b4f158496e235ebf0506fcc8d2d4c529945ddc0ffbefd5a1162326a637ded58351cb8e1291489292d03a58785c7f37e9d328f18af485bc06f33a877212615bec07e4a833eab1ec858623bc9ab4fcdc831f293fc279b4d8db4b014728565ede6fc8ea207cdad27879ed22fbc68e133646e9c944df4c5a63a71d5b1681ae2c3d2fba0ebc664f2d83314599675a47c15443e1df69932b2f767e3894204082725db9fb5b329f244fa27d9e05d6a71395e656239cfd87f38738a929438ba466e63acf185850a27b70161825f06fe7875acc29210c9d9ddac190e795a85c0899f74b3fe966ef06317276178de485104c27812246b711107887292e3187ec3d10e5d9b02285be288dfc0ef3f9873a886a8033837f1069013a4cea8f51e9a232f2b1a29f2b3d489c554fc77767195e845f7a99f839cda7e43c24eba88f8aff484f6e542512d430c082acdb68cf6b42431468686225f2826a08c4365b1a944dfcd947e2f09f613e59f6cd89e63b242505558d20f1bf0d52dc67b9230a012868816b55805ac25c51a0027a19a5038c4c1854b92f815fb4cbab06ed4566bcf4d9f094caff4b95c3d32062aa878459c28070d99ef0ae9f7e3e9befefd6a3a2f7e80f94d5cdb0e72d79f0a2a9ddb60b0f25985da4774ca3e73ef730ca87c3c495944dce41d2d567c1b5e2d4f34ae19013c13a5538c5868b8d047626db3f1f8472fd3f913e235774050fdf1c4f3a607c57292083a1733bcb1a2fe6bcae40dd63c041159ff90e057b7249af96cbb2a03892998aa7bb1d3c6ff4aabb6f43cc649ddb020187d2a87e09d394e03f6f0e758f5bfe75ae8215216b94da2584e9681ad9015180c8b9391c3fcf2f26996fd9028add20ba52593b0017a3cd52b4f9fd7f9c179ecfc5f5718bcb3c36f79c699b74b5a73d50164f7c74d817a51dc491319ac09d4a63107ec38ea704e65a4bf383052c5af7467da580110f710555c2cc0ac7b27f2a51b6732328804e9c65ba0a2ef943f60a97e193264733fbe8e9aa435c33c0bdda11622763965edd3908460bdbb1b0b8189ea9575c0e5be8887152240967a3d6041601d848e7fa487647c20f987abf66b949d0025b1eaf9362062398535af05c7fa3f26c9b2bbaf4a4ac7b6a851f16c34566ea9b1a16cb40bc0b36d0bab286c70d304769f4611d1081dcb19b568c8ffcba3b17d9aca2fea4e6529c0b650d678cc8f8ff51b69bc2814d17f480761e06ac36bea9d0c6f3c430b2ad6198f5f2b32677783844f5d12cb53139fab7e9c5521e1940e147b2abd47a193be53a68b2a0ceb3e90b7297d41f7138edd2fdcb6be5b5774fab43a1db3cd92125439e110d832eec491080668871b802f705f27653bfe23450af87a9a085f07a95ac66abec6b37941e2ab91ec41cddfff58fcffe1ff997f401cece028e9b4fcf8936cb8bae1017d384ee398845bc28aa947acb8bda735513e3bd55553397a26ce316727465fdd3488311b796d85eda12021b4b4e9e34c7ff9d7811d4b80fd8ac2fe06da4ca9b27e9ce8eeae8d44cfaf16806155a2705d77067e50d4411b6cd5e3f8db21f31b99e0f212ab8c712baa0a79604c05dfa28f53ce69c3e54287b7aae09082152320cdf4278a8fdb2708ba3ebd8fa2de852c0fb88c4c4a962fcdd501c51315469d639ed2040880cdaae746852d431461d3ae89746333b166d9f6088484a6daaae73be411be10785263e3ca2b10245571ab395c205ccd3b30bb8ede78111ba6c721dd02b262113f0d3fd7b23086dbb5dd4a100b3d767957f3495c18a1d35ce3a9a9efbb4888343232d25a9a24907c281c8f530a444abe7c4774bba802121fb6b339058c014f10d5edb71d5883a1c8d9b94f26c4c5888a53aa98815eb9266825953503506e54833788eec94bc4f55bf91ac2f76f32c3b5edc971329c200dc224e6c87abc5965e2bc23e9658fa2c4c38329fac61ee21a8f4f299c22d89fef2402d4ba6775f9fbd48d7802317c08caf8cc90984be425e5784059a21799b459f9aa0397601ade557807c464db48dad6d2aad48ce796ada55ad6e019eaca17c09bb0d824f76b44480122fab2f876d2993c66cf66e3764e551a8293f57b410b2c0ddf773cc17752342b2aefed7e09a4707267abe2fc3b00d819b469ebdfb172a8228528f19df5ecf86c13b6497a4d41b71c6ca4e8db1f343a9f7cca4a021c64fede471a70845740a17b6aa8b4d1691eb7eb2084e484d1250c093bcff435d50f5435a161496ec8ce8e5be95c814f68745c41ca91752aa02957f0ae86ed8175cb4c493a1aee292c035846979e225cb936afa1e8285eef00f64d0343c6881bd73e683598517279f7fbbf68b7735cf34b6fb4304dddfb21e9a016575c254569e9578caed996f60108c3390b880aa09a5568ecc6102508a5bed41edad4ec38fc798f1f46944553918f3967fb600aee3926b11c660890422bfb309a805af90e9146224db83449b0bc452247d46b59623661c88e64441c6460fae1474eff89cf16c984a55e17c594f518af936d533bb589c2d06b2550c7aa85d3869e3974f844542e863473a92205b827ed273be9adba664edf098a6f65c9bd55dca5b0268cd3245e0f38adb7b96ee84516e105a9c433798b8045a605a6c8ff87a1be169fa6d4eb54a720d8f8325d482b822c16d1356db2065cb5319bdd07e7a314ded9cf4394e4d2060d8e42f78b5eed49081dc74bd6a7ce9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
