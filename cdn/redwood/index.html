<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83ef85e4995301e26b0f137652ac0efe1de433b138d7ae0ba2b241a99c2baa132a400420da0e5de8ad5221694b5870ac2f1493ff46d81d2fc1f2c043ad5cdad377bc3db5f145972013f84e7d9032e59496e51f6e45b442747233f5770517068817201f95880739bbe13910a7281e8a6fc9ca55ba0ec8f50fb32b4be9c02a6cf323a4584f835e0b02cdefbe7bbbad3a3e4df8f0de96a3832429aa2bd5748db3cd436036b1055f7f7bc06a01f0d244aa3e1e7507f13547024b7e361c903991383e05cf57c899c9c7c31a027bfc1b20c8efd0eb111a51407065d75a3a72debdefbc8c9d801e3c39c4633d94907dbcc52cc165256098d527ddc9c3adfaf32c52e8691ea4adea189f293ca4e8f58ced3927808e391fd1405eef3a691df43915733d460d031bbbffbf8f00a5f6025c4ea77dc6f21280999370bfaac688ea821e7b73bb5784970fc5c5a1b6df43bbe8b3add2a3fd77dfb74e4b4b7ae891b38f2316082178ae1bc28e8c7f82bde6a07bc622ad47269dddcfd8805c11420b035ec107c1887101f96772f87bf3b4d4b4ef1ea2f5a5333f31078577797e186716f47ad4a64b556c43679710fe50980f55ee6feeb490e2b3e959428efe3161596c7379c38d070631fb160d904cf86f3573b74290b91843deb477faeedf42cdbce410f478c3c19c3ccce65a530d568bee0ee3631e00300de819a57bce51320d0eb5ee6cb6bcc8c3b370401408b7860350a5f369b8f0dacf37e37c1737f659845cac7d996d44530535d95945274122a409fbf2ccfd73cd79313623d99404f3bb866b8080561da53a6b2e3e1baef6b59432109434cc60a1774a5fc42d3c21954e4aa228f1e627f5ec949fe3f02fda9b25d32ba23eee6226c54399833a84f869db69d7c6c6cb3fd54b455d65b5c7acbe5910874b72fa3b66733d5f59b0e943c3b5d6041c60cc270377befb8cd5f99daacdb7f8da3f23bc22f435bbd8f225280d8cfcc63ee29ec72b78460054c73b7136960f54679f60d95cb9f5cbe060a943502d3be410346afb46319343225b5c595be4670b6acde5474a658f386a4b2ba32d6a7b63c32aa73d08bce2e5775d4295588332fa77e9202c19c54f05c9a6c548bce805b3a84d4e08e64396bb6d4dccecc1f395fbe62a7f4cc7b8e7165c91a0769ec623a4d016439f4761c5fee84299db6e1ccec4d5033370e57c8a8f4d88448f52217519c31ec471fc8ca852d563286ca56ff9a51db8a9a1e85745933c1291e5a939e08dd1808d89b997a9781b477f9984a24e2ccc9d38d64da6947c00474a2017a49a20bbb149fcd395e61fdd77b44aedb78041d7b3866f15cecab3484350d30eb2cc0757dbd0fca93c7dae1ef6cbf5dc0f48425912dd36bca8480c0af67a516ae7fb902c31f120438d9f90b32203b2fe05d3adc915682a2aa468fa3722cc9831860c85a3b18a9973de4562eace2a8f0908628348b181eb5c8c82807d1f4a5a69143155ce4291e6e554d6960d94df3d3ec4da1cceb43ad6b454560bec1c75625e16187858e08b9600ca83ffbd9c2295279046167d2d901b92acc0f9177b18e9bcfbbfc7541fa8e557e04aff3e3c815c8c592e8c781c4a1c6013bb43819612ce80d5f79e3e3e5f13c85ec128db5ed8dc82157b7fcf4c1f29793d418ed5457e054136059856da24a2f49f630dce95d91a2d489762330c298a51cfb75cf0d6560ab34f4f66b89f2b555c67723508387f124882da4dd14240a14f96f8d6dd9cc9cf2c64c3991fd3fc2150a3e2afe1b8cf52e89dc14c8f40d4b53a0312b3f11fe51e2791858d954fd6aec1b5d045d86619c0fad9a06d4087b6e9ded8b84fd6686c14708dac01c3338b56f53ec5a8b801460069ac982fcf3c802bc231700c42a33acc418d58f6d66a148788e58b2bd6ac66be9c5ecc6e5d1c593614ddd527843b95100f2ee6d0536f0317ee36c3478d03ef0873913fccb183638a600cec59fe8342ca87f8bf6aeeb5d7c552628a9d52af61f775eb189013fdbf46aee435874a30295a908a074d78c8ff46639a272cff46cf7e885461d29f823089064631fd00a4eaaf4abe69df77b198155f36b7561abaf9498258aea1abc18236d9685f73418d7322484cc362bd13f434107fb492992af991c0ace2b1f6b4a37c9272971b33b0281d9ec1cfb50e504cbb982bde5280107686c8de126ec547909cedd41db55681703f38313d20adeb12fd2976de0eee49d54d59f3fbeebce3a428f00d1403ee89b04d1ea2b503b54165c305a4644c04324a2305914a31e788c6bbbf1bb45546a7a7ffa36aee20ac3325ba00e61a286500ca3d015653802040058fc58ade11056ce7a7596d3241a1f300b28802b08f4fc1c07ee8b2eef6701925468264a79c1f037814e45607ddf8bf7a019c05aa57abec25c52493691103f90e7c54ef940a53c577ac3b0fab55e11a049b6abcd96370878a7df7296e9a2fb5f3221401c24e11855c0185424dff43420d8c1cfff5dc1eb2031e9f42785bc4652cf85715b1ee444aa1232285d7b7fd096e8e65e237663d7ba80355b610379e220061ae95b54a9cf413c69a4ab0bb66992b342a40e3f0cc715457a267bf95020f5afb0dd08985ade4ccf9056fbef6bc5b305060412c4a9c1b05b6d3fde944d8f5b95ae00fc57e3dac6df9d49110f6925609af1fdb27152d811ad6f5991d95cf387b047de63a9b93297b2b53df1570d75db95e01f53c153ba6aa8363ba8c670ce792f2f2afbc0183b2cb93200c9501f8dc55a84e6a40f10e55489840a9746a6bb45416acaec2260554ac3668c85ea6b00f72eb7899a8234416255325b6b1f49ed5394a1e3937300c0009700d2ccde64a5dc9397f8e2cce8d5bc8986253166b167b78efaadbcd9b03491d4b15c9708133a54b140414d7d6f961a0e49c3c1d5a4cc702f310c8f4c8e1ab33baf86e4ec21a182b8acdcbe6fd1caaffcbdf2c99e36f488898db7a60061fa410f76c407a66b8ef318d50b20cf5b491c31971e6cb0bf4291249065bec711fa5a865f625705fc85faa841047f76480db126591323f8454aa8b1a822e9218fc02193fb85df6dd5ccbb610d47f006b348735a8ba8187202024d250087201ed5e7cfe2ed116a2ffa2e631901277fcf560ea7c4b7ce26ef1bad14e9e2db18b26dac7e2f0539bf45e2c8b3c3b49510ab12990ad0baaff2c92d59b7f939d1d0382712bf1ca0f3100b0461ae6a04c47b08b223338553130c3fe59dda6b2b753d18eabe871544264b7943aec77bd1fac7c562c38ac53487e3c7fa8d064dea3aadca24a0e15b1a35d6cce25415819f590b45b35ec9039e1059112dd68a8b8b592d55fb80f48f7218a7ba3a980bacddb8398002539bb93e6292cd75d59015b721efe216cbb47577f01d3955b81e47eeed27588036bce5f3d33e6f4ae6126062ccb8c2cbee89d15660dc17a6e63cd26398a8620f4f7a1f7dd9e99240eecab5276f241cb404ba7fec41ababacc59bcea9c2e93b2cc954106b61edf9d978a7f9af9b84817a978c7d563b72421283a10e6e55d4e1d28d9c4feb522e7ea418846ef09d7e84c80c0135e926a2eeee7c31e918ff472e317b1d9d3fd955aa08c2afb8452e4ec9299596c420a9e9d8f484797958254d1a4747b4377c18b45ff563392acfb7177aece35d3f5407a88917236daff305cfb9ed3da2fb524a3b537c96aee9633b472aaf0227f7f224e05e8542004995da40ca7f96b92e67e26e568cc5b37010ac9cf7666b981918712fcb283e545a50cf02aa73ab88f0de51e0a4a030e596c2b8bd20145f4b1e8197c389760f5814d82f9795edc80fc7f6c8821939dfb87fc20a191d3592c192f3ca0b1a5cffb46988a4143811b97d4ad50bd29adebef541f24d3f1e0adde2adeea9ca020ba7a7b0661c5cd620d637af234070510b199b095721bfa409ae20e8c7bd0e536307f8672a499034137b9e90beaad850e3a727c12be230d519da6f7719a1549051940cea508eb9bd6141b03a237760c22a418df5a70bbb09389c8be262fa56c895ca9a68bb1341167ae13b20711ab8a6ee15689d8f40c9bc19b47a2b54f33a7d05616a87eb58c089cd0e4da1c4a5fe4a32a6dd34f492eb4b68156276d03a58fdab4cbe86a43da3215b0bbe110d171b46993c8321c53f6878d6f48459bd638579814bdbe8017baf743c4430d9b24895767ef3fc3272f3fc73109c115715bc5d04d3cb54b07b8ab2a13f238dfef96c31dd8228600e5f3aa1423040fc126790dab29ec3231d19f9641db3001aed03e4d2fecce5b052ea8c1470fb2045d080429674816c16871a4c376bdb1ca5c72a682088b1a1100be444884663adf106ef26598dc8963cf9fe7d8cd252e713c01644ae77cdda349a867dec2ddcfccbe0ab81f6fb272c4309d706df242c5cd65f41e5e4a24a69036689f044de90c0ee59dd5bbe322bab78fb46e1dc6d80bb72bac47a1f73f863fe7b66689ab4afe8e2642e69c627b486b37606b473da2b79925ae183e01140ac8626dab617e23fe6e266f61adfe4fe406f4836c51767b8927a0c0259b1c5e075219319ab71808f7f90d9f00423d4b76fb5958e96dc696fa0223c9e8b80f304e79939b287ab9de4e4d15a3109ed94cdd2498c48679535276cd806413cd51ceb4bb19595adbc3f7d1b0ff9b30a2f1d893ae1281764a88493f511a23293ae4bffeef6fbf06dd73ce5e90ae981f39d5225dfa612751615573dbba632bb8cda9e9025d3ead5478f08bed3528c97c7ed116bc1b2d17bf087a0da54cd4687c6823915e24f27d8a50e90cea44173b2de782d20b104f47c6b46e8bd242a066a5d2ab6c38fa45c713768c8d1dde09dedefa9954415c9c9be6bbd3f198aa0c73bd2e4d87d46c453fe19b5dd4a90fd4713f3f6a24c078d97f2e5a770eb175198443b6e5526268f0e60dacaa2d502833691e27056266bbe069c3858b32e4fbb83e4fd6c52c369fe2c4953fd77c48c4eeb8b4234d0a990428df4770da9f7249cfcdec6775801520bd59240895ecd654fb501a3526b0151b7623b83dc5105f25cf1b68982bde087434fb167f94298497825559c1ac6e230f719b5b28fe7c204e40b1abbc3c6999a539c4ef85e699b5edcd2b2725fb478a0ba1a41d3e8d691b03939f0f363e0bdd981948bd043b527fe0cf6e4e857156ae28bc43ff74bd69e37d89ff6e5a1d250d1be29d3c8a8eb53e806a1d0120366baecf6efcc71afd1ebb86094197c3638bc5b319c3cdff986739251c2fb6c3afeb4bee33960be6731e479dcbd2fe8017b7e60a944e602c910052edf77803715a61785f772fbc7a80a64a9686cfba9830264d6772fd318b1a28fddfa8f1c29549e3f1119935c763bfe40ae7f77adbd6974e55b17dd323944cda8e657e3176e8def8d28f107ed3abadbd0cfdd6fc8938299135a9e8bcb2aa92020e016cb2ac68b7a677b28161044c15cc636d4a2cd4b9231e12a01a438db761ad3493aaba3e6acc72fa5d66acc52edb317f149a0a70eb3f44a75fdb1bcf3d171d42939d554907651e6d35e1c23e0fe8e556202900e963a97e9719009f379d8d62ae2390e5d685ca06183f1a2e40df1562e2eff200a4ee1f4ae212a706c30673f08a830a770d6677205fab0e2788c8cbb50ca16b871c2b0ecaa9fb618014205fbe96b5c5336104c61b81e33381eefb97513bf98d275aea8c551420ebf1d9bbf28b330f605e87aaea9dfe522d6b43f69373cbd7373e33864ca6ecf40ad01e9be0daff882fdc6e92b5a4a5d2f3efd66c94e5c39fe69a8fa1e72c1cc5a9073d2d3122663cde02e7014b3de4d198dd5db51ba60aafa19f07304c8d6b8c61317e1d6642ba6f79993cd4891a7df7129c7dac618376f08eb7afff6bf819adb3bcc3b15b64cd3758d8000a49347b6b1e60f6f0af205a322c0232e93f19662cc4582e34afec8d4212bf3f167584401fbdaf0563781ac4dd9e28ec67e65f894b6e152e736c6c141ea791139f7897ac9ce324f014941df4e0f46c9b5c796a1b332224c9bff859b4c516e4487505de0aba78fd2fdca2d165bba93ea0dc0b080181cc1f1af2ea261d23857a68c4bcc03bd459fcb536f35429903a36db313b381dd5b0b6804326ff2d81baf6aab58d4f108f456f4f0cbc13e51ad0aeecd4a36fe14016a10c24ffac31dc0e9560aacc3b7cf1c7ff2b80733d454cd1cbea26a6e5f8f2e24ceec3224c3ea0ac9b8c08a8676a96a63dd30afc9e47f69494717a192c47c39c855c91e7888686758705f79fd015432df34b8b6bd06d2920bfba98ee74d8eb797d0af8cec7e6086d73a027000f01b4b7deebe8628e8246819457fd683b82951efd1a181579e188f399600a0a2d6639296b48bdf30d88bb6bdb34dcd1580b1b5ff8965e54a74b0132ae9f3f07e745ebf1498c3f308b046c17d16bd9513686020516a9995e840452ea3ba3afd782878cfa08ae2102abf22c6037a94b2118ce1b5d00aef0d44b875a7b75e0c3100cc07bbf4d6731a20eb3f671bb31cbf9926fa03a03200263aec17c64e5f051a0ef42746b1e11a0e864fd3653038e1909d1e15a711a920d61e85fa72f95bffe3370071fdcfec1b1e36f0d5c833e91ab6f3e3715894b0ec1f7bda8292e2f5c5c7df231c1fbe79b1d2a342a4f0d18c471d082f351b7b91dbb84471a12efddd3e8b1396ee57593cfcc0bd9b8810e39c10d5fd56e555746cc7835cddcb5b3c21bf521370e8060024658dc52af974f9b028b3982cb25f4ea2c8e80db3d960d61a89369fbed0ca8e024d1336af5f210f147f9df3ac1426389909a56f0619587e2accbb3d062324e77040f9586216ea8addc9be10b216d44af5a134932eeb41304fda092d43422e414a8f3b05b03adf0dd4d2aa0a2532b7b2fb79ce8b43890cc9a170b1a6b77b2625d970ca2255a6528a31c2076039599e8b7cadbcbe73172267f8cea43006db503fe9bbd2fc2b02cd647755f558762788f89614cd19b6f56df4f1fbb28dae67f407f4195f520e363b105f41affa41bbf8cf3cbf61debbf8216ec337ae0409eb804507818f6ec19695b03303f7057fcfce3c8e82b9c7d5f9b95fc8e35e7dabaac13fcdb0b6026674c5aa88ce72bdb247129a5a9e83e1ed938b9c808b1c653627314931c99afd1d1991b14d3b94c73a7ba5ebb732da5671c09733eec43744d8d2f7db8fbdd31f0f2b6f6407872671be989eedd9209030198dc9c1143ac5dfe09707be0c1163bc1a222ed1b055e0e31d5de8b7ddc2a0330dc0275baff6bdf29b27cc5a7f4310ff522766a550966e8aaa6acdb9ef004e534fa8efca630fc7c5c6b45d82f3a46fb27efafcd2ef46572cd7cfc59afffb3ba7d8758d22679a713586ed0c91d75fd4afa8ec480f313eae01a0029e5850c910270d4967b8b70d9323d0a55f929fa29bf5d2ea80757ea44ee09d1f6f3f8555c11f4e65e035828d5545bf8d99013390108530c2d1b76397b8db1f8ff16ac5c3c46c144c1bd424d6fe866111b9e507ff729ac1426aad6d5b90fff64c9939129a15b790c1d26d5716c99ac567cbe68c31ec67f13ccb8a4109270239fffbf2591eb6013032785e440435a0aa0c969d024c5b2b021029a5ff20845678a3dade3fe6a3960beb1a850085ca257153872828855f7b3ab247929b649362f2ea45aea758a3e03d806f508562216feb911d30ee97ced7142cc1b4e2012f3192465e9ff3523cf5e4fb7fce5f03028d689b9cebcfd6e221cdeb762c3dc59c9fb6bf2a0572851fcaedeca0f0b1d26ea84d6621a3f8e56f4b5f0d10126cb54f95b5436a98a23243be4aa3592f49c5d06435e4cb5dca070810f1c36c9555557a434e4facb7177398b8d6992165ac343fca5fba8c318da78b986e31854183e6c125ac87f611dc060aedc8d7d8cb8aecf1539bc24c63b38267f74e3059e687d844fa2a5b3262be6bd705a7658e7132ff5ea2e19bc1ee71a4479df0ea4cbfb298f449b261c0456bd9c1abad73f326f4bd6e05b94c009312ef4e3bec516fb8132ff6268b49b2a6d5d5f63ea703d60617b0fd987244a05223e6cb81957225a2811fc698496cefac7674cc601063fe3787249532bd5d39fd4368f79828b854b9a57d98dac316a085af7d1af3a2f025eeb7ae7a2e452909aa08f404351acb6babd86ab658efe2a1e299955ecc9af5e9325bde374bbb0b1c4c2201f8e81a7349a40417330567bbea895904684c5c46ad3d5a0d3cdc7ad57f9c5393e310482022ec6b9d9e02617706f1b4c9aba940908885de53433cd255c9f15b72670c83a72e3f8c00af67a398586546b6d8279891a7282cbc77922ac09dad9ff7b212b5e99aed4f4b0e0026e36014cce64518e2570cad23121da02be9f3bacf98ddfdcb98917c71f23a31804f9a1626bf8b0f7578982e1c5b8047a046645bf837cb79ade2774e982c0b16525dc1ea5735841d8d636bef4ec4b37d8ad9e34d574e83eb5e7abf4307c7183b66044c75f8219c86c402c220692cd9945556828cb650cbdeec90d5360f3b0278d28ee051f4776b2c119cc6ed28cdf0e7924984a3895fa0ae06840ec31c67ffa7a2ef25dd6eaa2df0d5769cd00bcfe00bf251d8e966384addd062879efd114e1b7449efcf5049c2ce627e44b46fac768546cb7933ef3092a24139874562ce6d5da3e78862ec54a1a66672c3c6dbf9adabb1dc20c8aabdaf907497ac87aa16319bce857c13496fb5af7d09ed6256d2b2878320fe9ad5c3bebb6c11225c5f421e8e1b78ba0e0133715b0685e5b7a0fd040c33d98b627873187441629f435e47772cd07ea7d6a23ee89800d8973dd5a0db87e1551f866a2bf65a8321b7b17a3b5fbc09a6971816807988a5632ecf1dd8bc70dd09864def8c0c779c43e1a4b9a323cbc3710dc1d1f6047a133b73078080800489b38b90eb02adbf449489b60b73722c9d71c53bf921d10aa6aabc2c962409c90c3629f6bb3226ef296be356c1ff4e92efe0aeddf4adf4011bb5e1795fe0ed7ef3ceefe22d852f970e9e2d8d57b5f96b5ab3c554334c2549a9d9308e76b2fe13976ea732d36c931a1a72eef2ea9c4e2cf668111e4ebe0426aaf793eae1dd56609db34701464dd62d83d0a98bd8db5f4cf85cf1756c8c0f37754a24787d1df524fc2ae3cc6382b59980cdfab8e512fc76a74849e71cb3f76586b01e2d0dfd88f9768a4aa0b46535c8d5bb3bbf41eeb2153af6217f725a7d5cef17ca085c4cf83658864c3fc63c462f41aa2c763dd83ef5c920d553f58e875d9d49bc7ffba663398778457ce17cc5725b478d3f3216c62d31912ec059932c372a531e0529bf9aa07e1f6cb489919b84b11dc2ba4951729a03482e0854573293485775e397ee3aef8a09fc91a36824f486a76f9064d56b9724ac9378f10a9dad4d4c091e684ca5b9a9b6e08b15251b31214d89cfe193efc6d0352bfc5fec8ae74f266e9a4ef948ebd91f318b5afb6cab14f1ec2591e780673d97f1ffd4e3fb7fd6f7bd92d5a1cc544b316df96a1332e6301595b028a57da6ce896845590440378e84276fd9d862b11363459f2cf1b9748ac4e95c10206f19341453ee7e192f0c62cd2b2a41865dd046b30ca84a9ad37bea2d3f411b81b026422581e6986dcfef94a237c77a417fb68fe393841d086a8eb9f45f6e082fdd12fbbf2c7236053861c9dae055e5f924202509f24dadc43af3845b4640054a8e7e043494095d06b1549e3eff8b64c41e359a8ac37e17e469a17dd754d38fa681e76743d2587d23de84f49043920759e62627aab0df4d62bf17840b6f23bc9fd11bc054b4a6b836b142ef218f2305fc63d151a7c756e376078ef93e8d6d7ec0f2cdb473f11e116dad2e89cc88081175fc08543e8a33a50ee0fb25958b2001f657236abaf0a6a72042b9685c7fdc288d028bced27d805f2c12cf129e648fc77e740094f19b67472babff814a041cc480908068e328f2e1852800741259ed8aa95adebac69e429a00ee4b19897eece4e013001acdbdf4c82d0196341589db77a9618aaa60c02def3666840c0c2897ddff74e5d5f93cc325d8712949566b5b6f6cd90b5c9c6d05d368342d8962d614470537e719b31892ddba771100c072fb5feb248ebedaafcb42d2f210c8c68976a33125453677f3378673bc25a2487bb62cb989e07351368afc69bbff27b7256e00e33b110d2bc11b4d32af11971ff68d1e7a2b81314cd309440742789c11b3281cf8121e651906f6c6574d4c97e34615f35264c306441870d58c204907785f82c6fa3cc936fe65cf2e481dfc23591f69f11b4e5b29677feb666c4ed0f34c479527dcffdb06331b28ba72cbb05ef4d0ad8b2c775166314066667ea1d7cbc252dc3f9564e2790f6eb8d6f4c8783b9f156f908848fe25ea7f92cdf27b6cddd59ba7e8c8d3cececae1c57040b0ed5404f6c01cb83bec5a050162a62d26df1f155f0ac56f3bf11bcded4090f537f9fdb666dab0e0bbb6416ab14e1df5a007a69104ea43a31e22875f5950fe2df98156cda54a0bb7cd039caf7fbfd130074319e73d66e9acaf2d92e0629b5a3738411140fafe8cd470b5741a9cda28dcebe8ea75e02a40308d524061a69df09683b70443922a05c2bd4991916ebc66a74051cc14f03cf178b7f883cdc9385817e32c596028a0a3bc535c86931e614f69bcc08bdb18dcf1d320313bb937b311befbfb592957905c2948f62dbbd00e82991e4e9f980e04e96ec8668ab0d053a18980b67dc8c9582ce7d0554c53637e307443c786d20deba23c00845d5b67e3e30f9a288ef0d551e5402091cf1ea8309451b6a14d6e321ebad5f4ff5d45ae67ace0edf2e54fd0ae376682f6cb6b4dc8d75a7240bc97382e2dd0ae298182edfde7b29002cb87b8963eb70b4fb0c6aa0d5155bb7658894fb0524ecd17e0d2819098eda363ef37a21d5670b54f21f1afdf854390d7c119c671554022af6bd8563552398662b0e62a3811aabebb67fe16349fb8c8364ce764f3670f9098ebfadd4a820a7299759b2284319a9afc765d314930180741688d1e9a43b703cdd932ae2be86fad9f4535f42064d4129b4b71a697c4f5a2231f74c4647063c80919f5c72a0f11cbbd368d8f6c8687632dcbe97a5e47cb33f5a59846c724ba75cd7fef2c8d694431a53165af295122f87ec9acf9c01dc7f6f1c71b211301ff661020301d56b502e9a65d7b9d52d4f15b0f1e390bc771d25542fbb3b63284674494ff313a9016fe19ed78c8ded5b868eb6d7f152ee348f8faa3d059b1d4fcf08bb9af2b0903534208467e246b43154e3aa625b0883984bd3d9aa169b99510342a1ffbfb37f620d1e11ec84e3242b3c5fce157bb64b33ed7138fdd7a2ff28d22734c230fb88060cbdf58999f398d2539efee42e1c4b7d75cdcbbf9eff3dbc0264c448e30cc8724541599fd5caf9b9851a3e744e24fbab3d761da949212d6ef1fdc4df7ab7a747f59b1ca131a6d4cc73dbc2b843790aa423cb349884837e1f35986d5f0ec2163ff59b915f5718f09891ddb6124400575ffc5db21f9ae4c39ce402aee4ddc3a105386cee13b75bc3f048cc3a1fc412d56a00c88fa5d85437b38738df095145acd27401ff71633f880096e10df51370f9ee53580f329cc61fdd5fcdf56b82027d0ac40353b896f273c29dc3f74fa114f047ffa5d445375ad7b4763385a0c10b71846416fe7318c194b35f3880038d5fc260ae5ab0732d27c61afd31cc33ecb86f2510f03dd7a991cc62150820eca889afcfb008a804ddec60f582592aab6ba1f629d5288e991e4ffae126d14c13bab95ac672b66183412f65956f871e706fe5f63e8445d8f1f6d52887fee17f121ab3a8d7529884eda65edb45cb6149da51647d679fe113c987d1b5cb38cb9c8fbfb1401b3344cbec56694a2b94d0b3d8a48a4766a38b1365610f50590d08c1643689583df5cabfad00accab7073df7f804f221bebdf2fc7d3c237823c3b7ed17528fcb664be34caa14a767401937dd7df09c50c9d2cc3045a3cd5b212a21d1b2423051540e3b73522273d015f1f3c7ffb52400756b974ad6d50712157b3c0108fd53c4698ad3c946343c9d02f2bf3669aa0b8818cfa862c7e07441bc06bf6641de54cfc2f970dc584463ad686831b11c73ad15a74569ef127c3457fb3e863ad1665e5c22938160b997232a78b76601e5e233fb1916bad6b1f5a367658016f6b97bc405e96e932f0b8a95e2c4224c19993b23332f6fb2ab139882a424e9308e8aeb85aa5d7c3cf56d026ce6b6afb401eee6d82175cb72858bddceaff8aa583bd169d305b7d6964646ec69d7bb9639b9f839d3b1c74b79ac9b1799e8606c1c441983798aef3ec1bbd42cb70a568e9575ae7cf3d1c50b5e8c14b934bdf4cce484a7e53f5912fe4beb1b9ed2ea03b96320db9b3101cd3651633c3aa8838ae03f583f1ea2d8827accfd6530d53aaf5a8c84f56e507d9c315f95e11e6b293fa6651e0cdc45974eef12967da91691098fff4cc83b87cd142ac3ee1db727b9a11ee5ed39bd9b047240ae153a5e8c9a6e64d94c66e8f8549d208480174c6417d933ea35dc2400df301392fb1503a1b7f8ea333662d6a82f9c32f7baf6f44cdb0e0d07f03c24b6ca4f262df4faac531851812f907562ff9579a328fc4069242d71ab50f8580aa4325698e95aa6cd6fd122f273c4ad9244196297b65dc63dda2238fb2c6498d9ff2eaf3e1d8327176dc0c956393b470cb1ad14201ce8c1935ba4ccab31c7560d8d699990999207106643c895344ef8ca12df16edc0ecd56761b2f96fd975b7d8ef2d13695ebd7d8db39a95b54f66c60fb489fca270ddcc72e256dd47868c14a3920ac37c5da6c00fc96c770fc9eaf3b92c107a4f53a7eec6f2f8aeb7440fa1d8184d8fb0e795c70b80136c73551c619cfad04995d922f0bfaf7ffbc1eca48075bdd3e421a3b480ca679fc827d0121c2b7ac1a9130abe5ebf7f5e0856d7b2bfdc5fc6fd36c94cd40a2aac797f16e8423e879f3ef298dc94eb0c64f91635e1160ab3bb4bf734aa842ca8881817b21cd15e2fcfc8bd309314feee1d95b06919a4ccc42ef3039df262805f8afe92d39aa0575a65fb384f4bb3caaeeee329e0c53cbd42b36aa4b594580767823708c37ad5bc8b7bb5d9d7d80ede67b0aaec3c0085c3357630e57bb7a0d787cf52e49283c2b1582e75c7ce56485abc0b629e5053bf0d506d239fb3a86b137212ee19b42e3979c994a6dbaa21266eae0688b42c6386a4241535e45c9a96524299d54433c6b99d7acc7146fdfbfb55cdf1b86d271b86ba58546610739ec49867028427f0972581fb0f70431c7500fe61ab83d9b05ddb22a7c458468c77530869d4c61d40c401eb16511a7013ee2f6bbd869546d9179bbe4dc3de7baaa3261575ab789fc7e2689ab4633f845c4e333bca559937196222a0391d13fd3363021b7e4039941dab2ce9d1f96504446e7c454ed0615bb83cc3a2693e119a660d4c28a06259d737efd395442bb59127176a2e7f54be7a3545d094d130c3557196e1ecadbeeec9508e79661424752a2728e2e0fc014c0683710aabd29f300c7e67910317df3384f5f2843f9b6dd0a57ca926836d515960b3f65041e0eff73c90b686fd073c7ec1c3cd38b1145f71adb53eb627aa133a978a8639dd0cf928b585ae5ed79c80d77387b94aa83a79d6fabb5ae3da8bf983d52c80698b896bbe3ed684f486ae6e2bf904b703a826aa4fb0722da7b724b7ca6f49c122227f81b7429297daafebc9b6027c391768ed7c092aa2597ad98436ac6677f12806b1256e1445bbde4f8e77fddb90297f74a0fac944935f6062a39bebd10aba641790e2770cfc1dcf0811e66702ad31ca6fdd90108a54a0e80ec9e356a8b59e14f8841e3673f4610eccf1888e5579a42c2d9b0513f3274014a489b0b5c1fe1190571c56a6eb44905ad1a0535430d0453af5b8799367684fa40f55005f49e275560dd18c271b311594dc0a70e437bcc718f83da353a17ab8ebe876c23ac20285c3b3df631c4342fbccf9f011b2f475b097f579ee67282de31ae7dc11efaada3c380b2ebc8018fde3a61f7a9aa21f1530642473d5302d8e81c118176ba9a98249aa20c449f38d76e84c760983b11a56de9d50631ac22be652264710696981c41436cca70d61f351cc95c2ec47e994f571e2c490540ddeabbe988cf54ada4464b8f24de7b5281c5984fb11ce2ba22f3f7d754359b53102cd23a428df0779271ccb30b30aeec52ea5db932b9aebab160a8547741a5dcb9d3eb84007bfc74375411595e29d102700c75584298a45f7939b0ba9d7371ea2c8d0cc4031d9a58a0e6e1ca17706532fe0d4d166e136cdf4b26361b5e5a43924b9c43df4084052bf5649e1a83dc3b61d8a396e1d694921c9a052f48774bf912c0557dd936468f445f4bb62277d9405476432d3036bfecb9206f6ed4493f126bba230d365713e7176b42f7a30c264f394c7b268132aafbe1fa4789433bce50d83fe7a600c8bd768eb3b1db76cbdad78f8cc6dd5d41e712bf5bbba1e37996941388ed2eab92d7bb60f76f525a848a1ac5b7c2d3ca7b67cc093941f390a0414f6a235945048577daf87ce764900aac71e096f84364bc922d52be2e5fe4f8c5a0c73525a74261df757e01125965e47c8130094c273ced5fbd21fa02acdf6270d4bf018f7d19339723dc814a387cd0a7697657c09651a196db544bd35c6850ee58e614b6721c092d4b2e618c4720c2665cbf97f71d50c0bd5cac0f5fc47de247cd198a10257e2ac7b300a48fe34b3813caf3f87416e284fbc2b9b18f6b3b9064e0c9598ec89efd7071c3b43fe43920c3ed5a2104abe75b8c4f4a395742f659018758bb49357cdc14b912cd254b3e743c1020e2e1d1bd17d104a9931d5827c30b95bd9d6efc6f15b3a2e18eb554a95a707db56a9d7f2a6d3141624181ecf31951f0594fbab4a55ecc8eb564ea1845d8a9664a9ab93668958dab139a3bfdb7b0c74bf2c4ec330f53c98d9d9a54059c6015c371651430f401a08849a6c9f135f54952baaf535eeda7dbdbe118fcc2f2d95d9647f5f8384f46b278b7831c7b5d278bb0442b724a324b6f2b646c37be7625621648a73bc3cf12508d3b5b27f0414a92e4beecd985417a36a5ae5ef264ad213fdffffb209fee509bf12a552c50d8a739d88f352","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
