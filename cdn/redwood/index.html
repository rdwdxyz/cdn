<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f522a44c299b7ef70cfb5dc93f481f4262005089cc32cc3ad5e7e5a1f3d93515a4f85532ba5376e37de7a4ffc4fe5e242fa24c829f3689a98fcebade3cc6196a7003632c91662930177c8698c9152682fb0253eac177de3b13aa6266482a24fc4ea782ccb9a2eda570795c7fd37114838b3c7e8df9d63336de2eb3e034a94596761a919d8e22db572214a004024ff42a12ff4ef12df61a875885edcfdbcb032b78adc979051f52b103b2d3a4535f4b8b2f66d937fef92781b98388dff4c228bf896cef42642b60cf0283c4fd76a656484e52fe8ff35b6fba260a590384b3c36daf116ba8da114ba41ab8857380af3a7ae60d909496c54390610963d9f59b15a7f48fd86b5945d219fded08832547bcde0a079ec4c28549b179b355d04610a1c70a65f2e4a881d47b592051fae12ad4bca676d01a415f766b579ea0688ed2a0cfa58df7947012d2ccb1af935d047f65940a11d5cc506655fae56e47c19228e9b374c8af43ec2fd85ec4048c0b6d1d08ff80b2f122ed3c84becc4e47c3684f75240a711daf4f7d37bdb146a1253be0f10785ef9cbf3c5c10c6c49aa8130bd8440889ce3e8afd21241be35484c2870e44568e1ddb3f8152a4f6d273fe90240e66f87e3d7f38c86d20ab69ccbb84930194d5a3c49b0edbbe3606c10c723144dfe2d5139ae38db4404f5e7a60e312f6887912f7683957d43adaffcbbf443b33fea56c623cd2746ff62a3974b784ef87af614535d7ac7275e1df37a773505b8df0171d963b4693d4f4cba504ed0f1a90c5cfd1b519face835750c58057a2422ca22bd29b3bd8f2ce41c56b854a42358363495a0d48ac3bfc49b64f6c4ed93f6749eeeb8f3a3f5528cae977f4467868e6a5c8c10741428e3ba78d551d4e3aed70b2c624b083bec50d9b021bf89d44a1e27930ff41f11e3ba3dbf5e539f515b98e2a7565e3973381d41daee92385dab2ea5e0781bcf4699a1639198a4e27a811cb0425edc6b95c438221d565a2436a7e33bbd011b7946f2870841d69b22f52a012382e1dc855ac394f120ed699e40f723e98cdb564ca4d5099ba65ff36258f2ba81d43db2c307ae9b1e074625dc32c74e0eea3b019068436cc4908b2f8074578602e61440febd92f1d7061c969345e90cd65609ef9c57a3401c0396587b239447f65767112758236b2a5a31d25141a42b85c8bf8bdbe0770a14698e18dbd80acb2fa2161fac4e45f59074d507e3c64a68dbcf4996c45a31d85f427ce96c89e484ba34161d1c9e89ded4e026cecfa7807baf27c24ccfb2ab2b3eaa7bb863720e713f76249d106c9348f0caecdce16671f468d4874e28a673b68057f2e9e2cd962628c2ce57df2a51418ed45089aacf672ddf6fea0ce6074277fdb5cc7b40159a86c748f2462addf3295b633f1a382150c35343901132911897cd67dcdcee72086418a17f4bf1843d73c46e0b713ab680525970f45f72573129c145ea6d9ad133d34e88f3b51a64b1a16c26890c9bed3b2c300be608b13312860b8897e03d926eb188bd1cc6dc2a690050195140f0508819c0a63f113568d301d8f9be59fc4deb88f8d2bad06a74af768939878e170a983f11f33842f435c21b46a87f42af82592ac62ab2589f3ac01d7e709b559d5b9bb1f441ff93326b7d94da59be6646401bbc30035dbd4bd7e012830451551cba21eac632d8e573e6ad733aeb537b2f0f0324024256ad505855317a623a117d444cab83479811e300baef1b077880b4a0ab5831d871e798b17e7900b618d9268d484448da3be6db16cbe3fdf79a91ad640afce3c2ae61020a8053fa7a547e47a2bcd94df98d42ab9339968ae5d90febdf0ea04d88b4f299d931083061bf3550e4b46361326f9fd00f17109847884d8101b867ab4dc53b2f58fcdd10cc80a2e6495547e3e78bee0465aec8d4304fc6f5cce6dcd6049d4261d683e4612988ccc32c095174336ab8be8f081ab5e51ccfbfbec4bf64d7e060bd7f0b523570af83fb0bb422e402889e93d30deaccb16a4b644d0e51b292cd59046dbc2345b8cd16f302b62d9ab3a12376d6e46d1a4ba38b73d291fafd93350ae71c802de6a12bc1147833fe65d04e2f989b42bc70a2dfdc3661c75baa6187d82a2da7eb8fcd0f3ed9779fbe8fb6de746f802bb8181f7092a88f162762b992d6326210d4c5b3f65b658c4072a0d5d15be61b08d3a049f63e2dfde6c44d8e800a62529ea39d724d1101ef26e7d6bd9555cde93ef467b52cc1924e45124e2eed30e0ecaa1e349aa0704e4dc9e4c942b6ebdba09893a075f6cef6f2334308c9bcec25f7bc94489f5e95e3a798b8641473269414c38bba8fdae0b672f1d65f265aeab25033520d23f5d39abeacd67a362470d9240d163f9b351ce4658dbe2490c1a406b990653ee8316ad7bcf3716aa3710efd57d62072f0921090ac0c727fae1dae956d4b5c065047ef577f73202896e7178251cce31d20fb4f38ba981741a2e5923e104a43d1eaabe8f0ee175d00274a80a90feab1996fc34d120fafaebedc3e67bb6f5b2e3a9b4f36275ba9d8711ccaad56c4bdbe38730248bd937eeaec8fd43265cdd4416c3b3732e0f5d7519d02c6bafcd01f92b438f6a935e42f01d249e67bef9e65a47f2b686b24439f0eb0fb28d92ae5d9b31581f9d36328b18e66f9500964a402cc083de73048a8c9ccaa0520b1e41a2520f27bf3416d0790e54cec3055e5ae412ae79b95b86b468c223e8249910689b7fb46e30fd9ccc287b88063e2d4aaf7c9ceb7c9cae3a1eb89869378b8ad505434271f09a78e401e3898644ae9c6d38c956e092244c0dd280f3387ee225d6fb305e2e56e7f9b936bdbbff81112557aebbcc6a4167adac8f025e02b20a3671f1c61e1af61fed839d215a06577d647adef97a14800bb54594857c9ad9709b5327d6de814415aeea0816c15180b729c2d54a224859cf0d42f898e942c4acdbb4e46fcbae28068fec6183376eebecd60b46dc04edba00edf315ad80bed5f2d5cf81c6c4f21098166fcb3257722972ae228753f3c329985b44491a9caa87347a064899b811fb8bc69416807e2a22fbc1f8651f5f44eaf243fa253fe122bd2db83cb845e5caca59251b1edd728a210010630ac15abb1d32a8c1a42af4e65860ffbb4234f54323b5e100cc9411e39d87368c3faff7e57d7367e12e978f081eb3ac78a37b01ad852100d6bbeeed2d3542ea9492ef4aa0a7c248c63fdaaaf27f1d9afddcebd5bb6ae459191acc06f829de9e746659168e01ac7a0fa0f02d57e828b21c72c8cf0d044e4ddf446ea84ea40290c3a0a3d1845daed42c26bcafa525718f35c6bbefe738eef684625bb5171a36ddc6051b039452894992ebb2517d1afcaaafbf9afab6a3dfd21ca9e27aab34b35d7ca1e53de61fb5a166c20ccc32bbe669f18f6e3bf0c0a16167cee39d12f89cf3ca477044fba8388da4b3264e4640c1e869e2da4f81f3998375321df0a0457b9319e4aea97eb7aa840a4867cca12f49209080dff9725f5a9d3f75d819dcb56c6497616d03576cc1f7108d7a77ea9579022accdd75f64ba1e6b2b122389f555f9e3de166cc2302238ed40c84e4ef79349a5a7d75000385d9d6291283875e1bda66ba82f813b9b25c8bba77e21bcec81efc037737c52c821d27a2af7fa9baf6247cda5fe070d23f8643a02dfcb5115ccc5eef89d18d060b93e1277e2e255192520c0570ef16c85de31d8374d2d380d8aa99211e9a58f78feb145e4089cb342c8110a7a4984dde5bb698de18d4bc2625f703fd528948387ea65009a12a031f763d785c2322563b68973afa663f5107d92b50a792fef0e52b87ef8119434c9258a7933b6e6fa59b77eab66c93c3ab64f9f1124e94b4ee8137955ce3241ec2da0aeab11ec9b350b867ce8a02de9566990e8738ab2281c3a3cdcb5ff26c1b80246f55ddf27c242a2677371b82cdb45135b7bd4c7bff9ead4fd7f6ed7cb6186f596620312485eb2c613edbfdebcf398acb210931e6800b8951a2142d12c9120019e46f7b721c363a89377e8ee0d9316f6d91776fbeec80945a8edbe8ecdea72b1267c61e8e3b16a8885bd58cc162d83f3fb802caf6a8d6bb99ad964e2c520cd2b3532a0dca609139991c27972c6b9372e05b47afe2ee65aa31173e80fe6e56abbe6772c66d5c9ba6c70e53474056dc0139c0ec36a891de8b92d2bd52051510da3d076618f20e010187c15375338870854abdf6ebcef2c3822d5066ce980c017d4900cdf983411f3578519081eb556d6bdf0aa85b55a306c00797976f5814d08b3e0df802bbfa68a200f0c35d41017b98fa07073b32b6244b1dd1be38b7ed67976c2d509d0ade906aa906a4b6b0881715a363a2c179c56b9eae5deebc9c065f4c738df931b91cc76b951c916bfafc48aefdbfd832efd16578971ff3941fb060d610d299d5cdba61ddbf3e35f85db5e756dc29411fd1c44fef18dd62e1fb84bfcbd55797b38a5fedc829c74cbcbc240609022e51351ed459d1c5118f16f44fe8e1ef336735105cde655872e3e8d40a6c4410fca52a1ea01417b7e94ff251fdf1bd3777943692cb8464ea7c78181ab7b571813d0b27bbef505795b7a063c50cf817b695a844a7e4b4318eda11c3a4f3df3961fbe40c3e160386098194f6d5ec66cb55a5355d069289eeb2cc1d8d03aead050aff61d524233c3e12792067c8d85048dfb6894509a701da8965cbdc904e083f3613d1320cd115aea2cee0bb58e1b2c9fb7d43e3e60d6b2157bc69f2ff433847776c28b50d7d4846db8efd950171992898991fe7bc85fadb176c05901eeb2aeb65b3de0e51fe04a236f94b8ed59b539f3bf673044c0fde3c5072dc36ea8803de5330d229425205ffbf33f66fa86616fb03f5a78f2753850b632c8effab0c55adfd159560e5f1ef5c25a9521052c20cb99e679b9b02f6ca44c2b802e945d0c641ab7341b5acaaf069f55872a30c1d520c4ef36b65d7204e2ded69e08ad126870b2634f6103f541de9af940401ec5f36587a38170e3144283bed513bde34e391bea988c316dca855fb83ea9ca6af9e9ddad66e2ec7a406d956333b9bae35518bbac47dfa81ae0a7763d2eb666456c95519bb6ad700d8c6ab54939900886fc9621ccd6fd7075604e9a52ca5ad6471372686ba239185986f4ed0fb3a367c4530c3ee862f065cd3f92116728ba3e6887c7083600b3dfb033ad82f56a632a9cb7eaf610b944bfd5639d07c95ef8e6a1e7d34ed453a6cfb364470f6cf7d4cfe818c6124312decfdd6ded08f763f3f4bdc83f616f817c01a0a8de76d125af7d2483fe2ca9836488da21d53471ebf4d4095980b0483608017d6dd4d5e599923afc5240607b8d035a5c56135a9b9f8afaa9194c092f35e3f6f0220d3dbc5334bd7f43c37ed92f1807a2c496ce0df8b6e8ca678862b15ac6cfbc7674556cf6857d6f845312c14d943288b0248f2ada27624be880c53f30ca1c0721976efdb95d0620cfe9121d1af5804b8810a4395682528b4d463b987228103ffd32611e699b82dfbd4abd8d00e27ccd4dcefcd6c1bcd06b4a742facebb0d5c1cea82331caae796ba7cd98983cf991802476e807e7d3d57ee18e660184e1359a2eeac163240ecbcecf0337c00de4ab60487e6e2aceeafd0d2bcaaad955e8d85f444d8a0a2af5c7153e56c919e5d11cb03125f3f14f7b691e45d388a655599ed7c2e548f63509ae2b2162f190db14b7ae368324884039ddf856601c5c0fa19018354a5e898f562c30244790145ed2f29695dcfff03dd35b91bff6d9f99f82c53e3e6f077b5b429fced205fa63036bf21f165a059d93402485017b46529278c233f07e166e2c78e011698d3580b78c9e1a58b0383aef7be9968c5aebf2671bbce14ff721eec04a92502390fd7ea67c40ea52e9998eaa8f4a1f18f3eae044ecd103eb271559ef531b6582f68bd9c27a60711f43445b7a8656efe45011eccc43c620c89b61800acb8b9175ef3db02bf1aff15af3fc25a13cde124bf0d0406b536b027e647f70df25f14c1c2b283488b3b4e48772cae0d32ea3465a87fc34a6b17ec9ce93e42438451801cfdb03405dcaa2277a49094ea9529a8e8ed8a08521ad2c0737aa8f713531795d02c5eb1fad5d73c5c8ea29d46e49b8738207d0c5c1915c32cc343cc25054a6d23a79b455f52d352bb9ee1ece6d99f3fabfc191d1ffd721ac7922eb4cd6804c378867958d3bd1514844407497936f0c2c032fcd374e2d36984ca26c0f109baad7e73ee38adc95fc5e8f1577065a070f877386f7b17c7986e064912d8cbef7d914c18ca2dc31bcda4bdff2d2e05bbefeb41525f560e4f559e7d354a7f6c9c80686de1d0a08af018242ef8830d626d21f60f21a3be88b181e103b1f5cba2d33459c3e94e4fb9b12aa19d2ed9e66015ff3789ad592669d8c963f0b975632b0332ca1be6a7901c4e4a90bc4c789eae963eef4188ea5af2cd916d9049ce9b06f6fe65a40fb6fb83d267775c04c375bacd60a8ce3de70b4208da2f5ef99c794a8762f25a9f9409f3a611fbd9f8c2c935e20b7cba2289bc2077e761bf4d0afe5f87f6f92c2894f3fc6ae81c7b4503d11ae6977e599d85ddac95a52dcdae33f302c34cfc8973fb26feb14f00a3a9fd7f96b49f5758b52e6e2268d3ea20066e8df4e9d37c86bd5202e078e1018888d21ba574e157f44b6865528fafa01cf11e8c9a956e952c11abe974e44843b211059a1c18d8c85b8d2c9f9387007bff00b2496a0f1da01c4d77cd5f1e1e82a49dd2d318a1424c137ac4c5646b8b944e44e8477123f6ad11754a57152aafba39d9234eff13c21139ae40d919da9c149023e200e3a6a2801ca09d0d459d40c575cda563b262abb73490b5261922ba88ff2edf27b5a5a749b221098c7a06ecc97d9d3848acc4e8835ffbd54a5c40f38f03673a628f6b9f2179d23686cb569c67b68facc02fcc8ae73708a8170af8d26d3dc8c5ca635778d32967f28f0af017681b5224f69279d8ad13929e7b53a3aaaa7f5096d7d9915654b4ef2a55969312e9e698aa70f0645eae3b339efef6819eb4fcb64aad1508ad6b59c2b81ab15c273388c309e3feafce574fcaf20a4129a0d8403eaa84235427862f65c7bd87b1ebb4bccf8cf75a22396bde967c6e32ed381428a79da68e760e5ee6b69b77183d8aedbfda586d943c863514ea6baad8c18cfbbb92c10d9634461821a2d29af9124564f057b1349694d10b4915130273b10d1882ccd7f12876aa3c75f89bd1525d79e8c0f5b70dc130ae1e09eaa2f56f8121fa8d02d6929a732bc7fcf2458927367c394d29dfdebcb1347fe338277a5588ac13f811fcaeceb3b3fab29636b88ffcb7cf006a2ce69f6f37e1d6e34057f6e8ccb2e8c273b8d4f7f166fd5308e90809affc94d01af99341453dd822f463031cb621371daa8592daa04cd4a9673e48637d90dee3d524e6fe3e4498071602771fc53fa43ae48b176e908f2733c458f6eb84fe3ef6664f7a2cf18ff8c9cefa69371fd1d64e64ea5d243977f14de01a20e2265f4d60d11d9e7859ea90c403b91374211d872bd810735fafa63abef1e97cafe5d97538c84b826325a206679b081c1f3fe56b256486c6c2286005ef3c96f3eb7b00370eacc3851c41bf408aa79be46bd2e95477cffe291aed0fcd15ca318e5b087a3fd46901e98819e3357cd426a478233e4584af35fdbc6b628be9716409f0e0cf85143833f53236212822f0817d8217db7d4a075be70423237fa47c50b72546a36427e7b6ff8ea612af2653a196e337215deb0e56f74e5ae252161b11bb91451c8d92730459daec4e03ad599cf3cd901bfb3c668ea6ce8ce0d20ef8e578d8b65b65c8b6c2c22aaf0bf27ebc3c2930f7e36845ea5500765605b075e248611a972566a08127690f04e03cbe8868253a288726c5c14d87891625f5f47975f2ea9e79b17c0641885fce2597992f8e8c6e74ee7989eb25966dceb7f0c0727a09f3551f63de20a9474b98b492f19b387feaed68fcd1e8f3da965111c2922dbcee75326d0aca2d795efd28ddaf4b0eddfc1830ab8a45a50f442364d110666d07deb07aa6cb6bd7d9205135f6100239e3fb2add4caacb74dd2778442a8b83bd6d89e080af3e0c1337af24106c6ec9786b79a38749a9c0d6b8f50c0eb5abdf8b1627bddbfdd37a406b2b9cada1fbef0a30c2e29036c35c09712b8751505c593a1dbb004d953e959623314eba7256034b5ae4ce512c09065780e1de645b9cb24f5fd779077b2cbb91ce8f6bcc5e93aed03cc7f9cc8b98f2d5ffd0ce2870b8d539e5c0a806c0f74c40d1a2c45905a6b10fe0a266cd09fac0f257e981f3b63eb5cd1c971b6ac00b59352cfd83ee7769ae37003f97123467880fae4d6682c735552670e33db9a113d544a999f53ab4d1fee350d12dcd9734e19d806c495634ec998131f3c818d5d20ea8a7f69746b4d43193ca67b9483aeea947e3d1163e04ec6033f64ea2c362829ed248e1b4eacb5e0e66d57e8c8569bfd306b0f58050854e1740e3cce7ca62435d28f08d37fd9c3c564e43e7e16ae6e547acea5fdfb515fc5e6e74dfc957729741e633126e007bedfd23250fd33244a6c2e86d439452a34f7fc138fa477055ff420c12cca8c5a12533fdc612e2f0227ca9c381e491a3b98b3029501fe3b62d48faff44e7456437c6bc4fb4627810ef11cfc662a2ad35271bc3be1881f259993c1a375f507f4b675414e58f24200519818f3caba3a5e65c74f04ae7b5dc85a270f57db65ae9f341e627badefb6414b6c9798a02580a52481cf88fae855a030869b71d061fe16cee10a8c502d8ae2f89e1022915b680d96fc1e575f83042e590a30d4c2d66b2da0b63367900968fafcde6f299f2b347d303c831b8b9bfd8bff8147f41b1ba755551ff8d15c36f4714485405acd4d25e18f2f4b5c314cbc76cc5adbd8ad81ca97cf0539f4157741d7fadf17bf4989d09c5c752a84fe3d2598a76a5fd38c66d2e2cee3bf8f7cf9c31bf8e2926f8273d96bde605f1f28f1644277ae20d7e96397e933290a2c5a55921deb7dde652ab006b583ceef52c7ca20bf2e356095e15ca2ace2e97c27707d69799d1eb3fbf86a9cb2f7b42bbc0aa5e75162a8c7ee99bce979498b12285a565f1507467a16d41debd41ba9986edee040f8bbb90df775c9028104faf62110df3abe23f97a0c25c9e4f73b075117b120cffc62f05a0e734b681d7a740d61c3d7eacf60bce83550659c449ef5edcd0a898859d8666f0c04b70cd1dba9d8547653bf299ad083a9d662f7abf96f298657f174b05637f4994e4bfe340223306d8b8859777c0617993a9067423121bdb542d852bded90879f5f9817729e1639b249b98e36a39b46d71ea6464cee5f5a410bb46fad761330c590556fae751fe0cf95b5d56625ccc7659018137f9567c3f047000a99a7ba46f79b8e78d4c165481329b72cab1b9c1444cce199883be390195aedf18d502b98ca6cbbdcc7b5446766f9c602b9feefa1cec9eb3c7004d084c79e4efc488d947461d05911a2cc02ad79bf007f2165166098ad08cafcbf208eab4df066d960855e319233a3644a8375bb9091738a3ad383c72bf8a4d7447f9a2863e3241c265c6c6706faff688ee4cc4ab0e414ac5c641e1cbe13ae2c3eb063d08071379d366069c35a48e7e7a2027f1ba63cbfbbd632b37409dd673f4f4a716157369cf526c3b4a34282ae1ea847ba9833c38af89763de2b002b603526922e1252aeac3a14301be24c4d19cf6cb687a090deb30969f6551562f034a8058d113029691bd651d5ada9032b10b0d8cacaa94f1a39b2db22509aac944cdd865b8804ddf8a7999b472e5a3d32a34dd0d2645397bce949e0596d157cb4ebb7cfe001308870322b12cc2d2802c82fade059197f79141f10479e08416976dcce9a23c9fcfcd8d2e9b0aeac89ff4c8233f1850ce0df10757cc71d4511e9b19a31c63126bfd806b187b8a109c6f6e474adfb0bf69b60ec24e512038c8ad31cd3620ccb8deb56695c4124dd217b2d61f8e472cd79466cbf2058352280c856d76afe159d76d065aad4ab3a544ccf60b48f62fc3346a9b884e6865bb81ebd0df5eb61fc274bbe8f0f596c757a8c8bbef043e3d935e4f3aac8a4eef18cecccace10b9571cf7d41d5ae4b871d65d2c97dad60f6ea874830316d3bcb555081d1d61510b5276b7b54fa7dda9c5cc3487eccabda63839b0cf9486128c29845703e0f09f95a6b8076189d0a3dedc07e8fb1499065372bc1c78683724665bacf40a60142f79a44ca543ca319a27fd519c0399e80815cab92bf040a0d59ce8455ba5b9aa7e8508669c785e2fe130f630520af03cb6db72b0e90ca96b37eba57bbee1fdf2b575f5fe212c58504effed33849f211fe611effdc8bfa9d2319a285b52f6c462c12cc09080734834893fa0b7fe988e463cc9664959588051cc821b516d4916eefe052d3db00f4d5d5893f4081eee60ae565e5cd2bc28dd2fb62b36f7e993caadad9de711610113edacca429f2315b587f5d12e7e1f78514fef537360cf134a6904e42c035a50f5b5bcb2f4e22efa6dbab359d486039aa78b9a641511ea5609326494841201a349848368830123393d1fcdbfaf3dc48bb61ce31fda775def93eac681d8a17a40961808a220287a78b1b3d35edaf02e3fd3fbb8362e9dd384501155caf70767a10a797a7efe45066b9f59b307fabcbb077a56c1ba26ae479f17da29e577be96ac95dff5d9819b499b072cc8a1e34aa64dd9f3087b1180198ca6e64fb19e8016a6cfad32c8e9ecd3737c0e1d4bc7db947ac9db7c2763b7412b612854b96e567c23079f31416d5498ba2f9b2ac8c60359d722b1673f821c92fded0aac4c5d9db2d4ea6582b9a9a343052888bae0be729a7732c45b5b3e1a52ad2d9134c2f8f03f79fc78b4330ceebf4cafe911bd3b9fb9abf9c14e540440e6ecabed80f9ac1e4c58e0d77b98b360a0117c48d36b36416cb52e0b3ec4053538df940730296943586549b78b41489dc84fb8f8f06708a67cc67d90ee4806dc616eeb5c5b4bafafc373e56c688732f849187b0735a19653754eb3e63e13e765c7d5e56b93eb97b0596add080ce44c71fecb4a58b37ed4b990021757a788d24fba0e8ccda4ae4f756ed7bd8977aa9c24d7bdcb7453af7a26c7d56a7c0c813286c4f732de4b1e2fe340aa0e701ccea87f53fbaacc97d28b2808f7b1e0625577a8d559419cd040636a31d1e9989fa271f2aec329372dc31195b42d80f51095a8f45127d611f3b5a952d6585168cea6944b84dba7bee4632a6ca39a4911d000fa9ec99ec166c2700d6b3894ed4a738e60bc3687430770a19ce637a10f93678262acb74fce3c0d7977723699577218b478ec399b813744434789c23f22785d7cfa960e39c0cfbd06649bf16d48a6c8daf894da73e0bf07bb6ca30499208936e615cbfe91797b6545a7dd26e8e191584b1bcaa56ddef67fa97b045f4132f485d9ef9da3fcb84e2f7b8f4b59e7d327c494310e7b2a4567dd128d1f80779480ddc823dba158b9e5e36bf28aa54809dc7f4a7ac923fb9953ad1b2ec5425c53a987d55cb3cd500160a08da90d8a7c72667e1813aa905c006d9d19106692cfa78078b15caa66eb4ab7f4b21cea9e912ec38615516ecff0487ab75845c73da589488a841437dcf1279db466885207008eeb1b6ebca4adca4fc39113fdfe143d79c930c852a84addeffe256a8a138e7c7c46100c4d6ef7bc280d6a3a75db3520e454945ce3e1a8d977709c7b1abc4a78ccfb7b615e56ffd51016633eac3a7e7af9d1aa565c595eb29c7662ba2f4b5bcf3f6789cc3bba57dba7ad86fac9e472e90451dacb58cc55b4dc033ed7aa89f724f345af87194344420f8ca4a472c736c2b8e53c07a68662e6069427023b85e3957d4a7e2d7643e588f7679dc2eca510dda0456a2b50631620d518e01979bb24bba0f9d99615f2a99a8dbbae42de1462e2889efaeb51641e68c30c60d1004fafa12102ac01167ad7d9a12f8e62e62d827853201a325422ff276a9dee18bd29ff0fa0d3017654db03bee946243eb5d8408185a2f90a62383d0474c9a6358c8d2222fc8974ea4bcc8fb7772b8334ccc1e2f94b0a70d3cc0df8528bba8863c6c900ac56198ad232438aee1c81c56fc7180d25442b3788f5db6b1214f80de0884d7d49624f25b3e321b165bca52ccb1f71bab4ad905fa7b10c85e92308e708eff43bdd344b83653a98e643d1543e7921fc366c6ee2ccdb0deef364d956f5e45eccbc191f262f63e2c4e28794f58c5447ee81c1f085e74253d059d3f1d3641ae2b8d78b5b7415b799621ba35b0e3856345555bf22841cb4b3479630ee91573eb8f5f13d4c0d447fba8a389f6248d00217e89b44b6ebfc4dfc1b2535ad1a6af28a45c9c236459deb6fe45276f899a39d4c65aad5399a7a7e39dd7b6ad5727c2c3a76b8b9c4978fb503fefe39a9d82f37850e23795ad3d360c7794f9db3c53cea926c82a03987176e3403aa8f8e23d25adcbf34918c614701f81cb30eb2c12211bcc8e5810ccaf35f14de3941ac7cbf08e99e577c3f4f425ec6a6f3808dbb8894a5dc4439d1f534e3e96b12ec44aad6ef647e63efbf3cbe165ebdb7dbd7d0f4558a2e96c03f80faeb2c3e4ed464df542bf53e9a4874019aa88b12e75adbeb93871765bd70526103fe0d6139dfe02b35f08b6db0f7be0ccfd2588ad81951d00aa164c1c094fb9ef8d03a48445043fae8a38cd0525201df773b34dcd97ba422ec7e8db6fc745342506b2ebee5a1c4db401dae43b0a2da00b988182c579a902e8b96ad38f10e2bf20c771c08aaf44c11f6d1ad1d80198dd5cc7c629e4a211e03ea6c8f8443e162ba024ad51c5f6491d513da707777f47e5a6c4bc19a9e4dd64cb63be4f56cfebe2a6f542fb81dc5973c987d7808b73afaad3201f4004d0a4c8c97ea93f97fb1c25656b5d6d97339a89eb6249cb318cb405c5434bf0b9e1475f17cff937609e48868dae7586970cd411ad57ff9d36cff575e0222c57bff2b322e749321b185fc44e8b7985750610140c96ae8897184333680ef1dbf8b69f4f0d77e53ba083b5d0c04ad057b94b3f45979aecb11959105029c1475ec72d60ac6de6ec0d7666bd5c8e5432fefb9bf31e8b659bc7c52bacb1150a7caa46043fd9c01c1a0ccdf3125f96095313818d9e4ae3ec40769267dccabeb55ab8bd86b5b6043deea5887458aa80c542102e49ba766904ac57640a4e0a11a430616fbe45f19bd154c70a6c594c003d521cdd1be842c4199bf6aa5f2a39f7d7d1abecdf955c34c78aa0837a6f0d7b3864013322bf288d4cf151de62ca84c3d81a91849b9b1af887fc44c5a96584cb7405a36ea7807df297d4a267905fb4f03eae92f2f0b49a22380c2d1f9f5ca13baff53e05bed2db5a0778614a323e67b22d5bfb3a50a93114229712d226d786c9ea018f30f23c1897d6aab26ff8d5987b776ef58095c9ff02a320a07a9efa509f1de61268c185bbeda590f8ca20a96fc7da5397b3d7da2b4eae05181a89a981a429a91e318d7e9e6db2831719379fa31b533727b695a711c71218980591797d66b41b76df08c2f419ebd0fcfa739e2a98d6c75658c6cd8a600a11c84a1b9908af669f37450460b83f6121e922b92d5c47e02e62079f9fec69ee3d5163313f7b0552557359e38a38f82e2cd2e76b4bfce6c88954c96fc7483046453b20bf22b1fb25e664c8af5f0b2f2fb55851f71c783071b118c1f273d82a86271786f8f88e0fcaf54d12b4e7d8e3e21fdb169138d3674d618c3e85e53d79844036a7169bab82b29d8050d4fa160c2b33fa1307ee9bd615884f252d6338e3b4af17bc8f220fbbacdcead4746b374a682553884ba4c2fa0cebc8601c5dd72a6912952fc6f5859f9f7fda93337064ee2c7029fb0152beef8c81d1c7e042907c6308676f7c4facb166498722c9d37264e272370fced9c47505ce52bb46774ab6c27af790d7a8f194fe00935f46037a703f80e1dea3044d50b12707ac9f658361839fb9a289d089edaae83b20ca2daf02c56843fdd986cb4d9efe35a5d0f3b6103212fd3dcc2b4c513a344d5bc505a9944183d7663cec470ff7cb0b8f042317403f193fb6609eb8282a6e46c4d209fbbb489d563cca443244d19235a3245e1c9963c8b0199680031d9e0338ce30c31c8bb10a98df3ede6d72405a76469d8426ab90f9f584eb4523b61c6c52c6ced9bdd29bdffba3fccff3a83f24e0705d40edeb861f9f2dbbb3dcc71b73968d9018848e3ddd4a78b71e1ccc255c84b77eeadf01e8b038c885c74b53cafc6887f5f3f68d69a7ebb0a6b609141193dfbae1dd5794d62d4410233d5c5ef34841816e042613d7f8a397648f4d2e3487cd58f50d8272338ee76e17359137dd0b05d9ba52c6f465eb513d049b7f2d1fca72bf8042137d3aaaf661010fb11e642c29a2bbcd74610a2f3df680786d9dd6aba7b14d166eb0dfeed7f61d2b5aa6d31930c8ec25f5095be9061c60742db4525f0e1206ad47b20936dcb616864aed56a0b829b6a26cfc6c94b4b37da5be89befa70658161ec25b4202bcc99f9b31cec1d5b100a3f8837c369fd82fca8e8db37c61eb21bbe6a5164fd9e6347e176ddab2bbdf31bd914c2b7062675b1d4f7fa6bb6f491744a2e293e46027aad1cc6c073266ba9bc1b145cb59dde4ab8f7f5ed6a587c633ba416d0c3452d9229f2d8ad97e4cebad36d60440e00b62d7692893f66e288b5554be3a69ab29b356a88bf027825361241b779b8be8708946bb3d9f7f0d4d122a38bac77b646080169b3489885cd37debd0e61e91d262804fe05f810f7bcca926650b9593c28bb490b18e275a93832bfcffa49f0ddf1a9f4c7676fa5d8606ae73e9dfb838e900c23d21e4bc2bae8e3381b9eea027842ac2725f50e237f41384df38733a84bd4945724d9ba70615032b46e29c349e06ed68727222789b0c05c6a8412103ce5908c05f657327de68ebe70b8a190726f684aa577f4350d589842ba7ba498e53a5b5771e66e63c9325c8ddc9525afa57fe778dbfeb0f4205dcff395982de2501cdc64f6b058f1a7920a02c4242badd4f6d4ab2d96e482f9fca9bd3260c9f8bf7160e51dfd1a54f3fec415ea9af5e61dcbc1a3211cb2f4e3b2b06749a6daa1d343aa944086b273da96b0d11d8c21923328fbe0f752505de6beb6784b576d7045dbaca1c2aead02efc6370af3f86c6910505345dc90699e54b599de0527767ceebb214ea15377974cfc35ab9b6ced48e4543a9f960fffb5ed4390848eabb5310307cca73b5fb87f0152319fa85e8b59bbbdea95c6a1dc9365aad1a946f0608fba1738a1aeddba5d6530d1afe8e01bcffe9f600ccbf7d9877bd40fd0356a1ebdaef64f9091466b22c8805a10757ca6f10d6cddc0d8a9da0907d1393595190b748b6851f38f67df57d733dc8f7d6cd527a5d67a99e32b4f12999813828bc85d91d6506333d26a1937ed33c52df425f6dd56e2d1d4b022ad19045702f5a2998915007127fa6d72bd6b9e101fe742397b6c9d7e7c1b5116b25a6a3d49d6279dc1bf61306aa0437d7d92373a9598478e4d7881afc8f87ad5d2aab6b41254e3f279bbf1b44af43c97e6ce793ac1f4da963bc66c7d086a585c9d7bbe2e2a68a53d6e0a10e3e59b8483d21ab3081ac38859333fce13417af6256d19f85271e2c1b166c1e26eeb9e98ae05103c0d27981c5a1fc660dc8541f3fc02dca7b7f25873b5812fd272ff50eb999cef584094d009ce459b7404fa82a3fd09adaa344a17a274a80d4e9aaef240725173d8129f74f38ae547c256cb663a62d2982f2085bedf0d8cf619866084b1d139c64e19b817f3da62164a61622773c73c46aad404f909937ff0b9491fff29f243442b0576006c024db321860c4319f8b43b0258f0bbc20504a5ca332c9f70827cf07646f1a1e24d704045c78505fe8940d7c2af1b365c620e2ae3c23162415e9913291495a20fc27906aff6323cf120e2f8056df2b44e382603726f0197a410a9760c2c07fc95f6527868e39725e925102fe45770341771570889fa8106ff3097e3c2b4fbbc7408eccd0700eea5556fef6a778cb72c4da2398b0a38c77d4411c93c430c1da7147ea9c56ffd204f78d5b528ef5f97c13d29becefed6de3baf076440c5850af00c26b9485ed96b08159f3637c4edf3f12f80af951b94da064f44e0087542a231090668ab7e12b085fac5327ee86bce02d6859848a9fc01f661ffd19d21b37ca40d897c585fe7d09396d5109ad2a7741dc037f29baad810277ee95e58b379aaff73088b1e2be4c34afb693bfc287f9aa5dbc8a721bbf565a05a6b753d61ac1665e5a0ade922aa8c9da4f1cf36d6245c3428f71428b8ccc94b1408d698d75391ceb38a4d99839ee83e9ff18855e60b3236fbbedcf22a8cbc080e938355b12b984277b89a14d50ef99f57d715a7ddb6f3239e16f816554cb04e9d1f97a3abc6b3d97359247e711fbba79ae7ed588e0428cd752669bc54f0cbb20101db931b9dc9e16f174d449c2f7064e40920ba6d6d4b326cf9bb1c6b324fb181ef592f8f38a14105e8b73edda35497ba91ba535534a31fb435b14aac1c0cd256c0c5150bee4431b7c7d1a806f563a26a275a5baead7848ee24c49defab870923dffd1ab15994dd3ffe7077f68d18e06672da27c5b8a0b06538fae0874e768f83d1338b1bd2d01de916883b70d58a6ed78c926940b3dc94ca8554c1aa8b9218845df9b1fd1454ede3cecad72d18370f5754a14a7f6418457039f210dc0369eb590e08b20fedec5f65b46b3bc1de2d1bd98e55feab26550822a942ffaba10df14ea51a80383d4659f8712c609f32643ea9c46bfbe79249d7b2e8b065d33c3813b66f11f2d11156d784bb7c0887b8ece6ed1f232491aaf94612f375f03b8beb268bddcb94b23b238a5f839beb0eb5a91feab4cdf866033117805ef70a03bd83b13f7e3724cf55ac79e2828c6becec820f4ea021101d18a8f1d9fd6fa3e2978b9926bb78095ef20ae2653ed2f8e71278ee4af14d17205a791e08b8fa2a61eadca23c5d8c163b4b7930db4f52f6cf221295b689913d10050f19e019e3d50007260594cf0fc49b4f1920a1167270254020a34d148aac41b906af2f040188fe6e3554f85ee71251bd4afff7997aa032c94c8d3a93c06fe9a0c4561cdec530517f696f4fc90f7aa3cf9aecb1377c5994ac47932da394c3c27f4cc2cb0c7eb862a4c601b65e230d2cd15314602371d3e022c624ef295fa25ecda85ddec0a401509add84b1ffc2754f5a812144cbb1b562f10c0dfb2096728ca69fe2c70d09fa9b6b81a748deacd8fa9dd65fe798b108c655e9b793f29d60b53c4f913fbcce074b01ad1c3a98361c590b00c236bc9f808ecb69ddddc41bf7428e24f50527da2c7df5fa5bccda4c5737abf4e0c6de598e939e67380f222a090386fe3bebd4a6d08789c275559dd47778cdb50b664604273bdc39a48587f3da31deeee12dd8df9b16bfcc84d9118095f5704aa67fd90460c1e6d53c80ecb343d80586ee140b51da65a4ffaf486d948cd623ceb31bc10f1eb1c2b79e18034672166a879ffe5baf4c053a816bb7730e4555e96bc4245c9d8838180d8930b3332b20d8e7cd9b811750e411d8869d1092668aa9171d6954f36d8f668a3a59be1332aac6ea4f4786b676b5e4f30cd8bedb12139ae3ff154453919ec84d76e78cb0499990c10fdab50919d6fd96c36fcf92b7b23027a1b058c0ea14de161995ac0b364d7f4c7c5d479f1579b0503b7bc4cb85e53d0bcf5d172370db2be941b598e8854c2b9f313c220c994808ca2de21b5c1cc2d6c4c004ba14d5783a37df6c6e00d05885019d47bf8891cb45d022471db79246499959dcaf275a38a7c907441616d4cfd08ffee49095207fe7ae4697906b5adfde8be0087e15154efa7c40f684a2e28c3744954ac083f9e3c7e9347decf4d147fd9fd629d714b88fd653e8396af811a93059359ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
