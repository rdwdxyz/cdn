<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6af2d17967c65c6e42079d07794d8547bcbc4881fbb1e3d46240cae4b4e0261b88bb644d9a6d373a592c5b52312db73122dbc617b19193057933b22512b2ab336c920a5fd2699a81a89fa219765db8844b804e297f889ecbafceec56f8ac3f87aa4d62902bff8bcd6d762f1e994796be932e790d7cc46d0e0a1e0a9e09a2ea64266432d5a3256ec7b1e90f73315f0a7f521af97e999f05ea1fdbe7a36fb6f5dfcf53d753f52a8f1b3d5dbd6b306639ce32c9f159ebb88af13dfaecf5c467c43b65b1256baf12a70871e1beaf6dd9182476f01f24a4591b8e6718f52f1cc0aa4c1daf43853ac5e9afe6a7ddef264f9e2e4c865da36e4ffbbce74e41560c2eb4eb85ab2cee5f4ab15de65e608230e725185d25c61637333e1361c331602dc525f8a458d8232f1549f6e4b7353354f40d2476fa7e424ba25f7c7e4b4079673639c7d61b7f14d1bd2ac9b105394bc5c95332f51650588d694e61aac20791e3e89715111448cd974ca2d9ddd6db1d037cbf3d56f259329ecb1dc37f2c92546db6ef8da862125dc0fb2449269c1ffb938d8b18f211c4596639f6cd0721244dc92c820a1856198cba1bc9910dd3431fa07db8c4c3e87eb8cee1b70a6c7cda0a41adae41a17e3341811caa62a6f3f42798aaa9c69aa09cd54537e6b8d06db358ae538357230b1c122b1f4dece7ff235288c3a32136e5d2a06c5f7afa7bd381ab9b86386b64b896090b473b0653f33c0cdef28761ee71ad60a85f60c1eb9365b1a702331d5f4bf09f1c60c3200ca509b88fd8028753543ccc656264bcf69a4051115ce5e4e7aa8d3321593183fa17fcb62972b10883bd4b75da9f70b7bd1704d9dbd4f2af4e45103ef4228455366dcdd63723d29c889f07ba25c6f1378503438fe6c2482871c4fbeae18abab08db14cf8f20ebd40dbb19e4af243ce8a455d884f1166d4573d22197f500396c556380f1a7e0a21b00d99d930e89f3c2f76f84dca70d8949c2a0f9fcd961bb294700ab3d93e470ca9eea8c86c0c718e43f354605673fb5e322fa792bd51964f3d02a6c7ddb01a2b445f64d2689462af64271416e203f8a4463efc04a91f05bc2f735510c61b80772acb96afa916cafb053b295f877caa2ddd175cc190e6829d67b46c012dfa42b368173d4a1db8c19c806add388c156fe6ebf0fb380754ab1f6c9e81cbac345e2beb140fb84954d1b3f1b3448cb73be6f588f763ef9f6ecdc9f3cb949098e2e3d42fed173ef558810517ed72feec859892657c6098b1c789ecad541095806d87765f73646e87992dfcfeb51f80da523e0cd555e311723d0a68cc0e89e2b460eaacf83bc4a4692c8328648687e362cf82583a86ad9a20fbe37991b459c5c641aaefecc05f7240b36b07efef933d02f85df0d33218e801e2b9463eefadd90120047fb9d978555934f523f1731aa243b5108ef5ff4a776ecf4ab6458d1f1468ed7a056a39927b0bed3b9793bde421b8b3b2ee918a3a9576c83821c7b7e1eb414a20a47ea0e01df587b78834b7f7640926fed46cb31a4f45d8eeca7dee94b5135e28a947a62dea0b24cb0ffeef9e2949d8b2523a4ed0727171c0f233cb8c92d608012a9b5b5f53275ea99c41978a6f5d0afdd516be7e3e35f9120a105fda95e818e9f2e48b6c3420a02c76f23706612fef33210b4d525f4c5428db9086369211db57bad9d59cca5a788be9cbf7aa1858719c1649e4579863e4cf36e5b80ffc9dff600887a92f1679e3ab83aec4f9cc0b7c21365181a5c6678a4e1e249fb73e58dcb2ebd68623352faa1780f7ae7318cbf6b92e982505a193bcfb7aff88593c0f07134cb8ce2e7ba98e098acc4745f49b55847bdcfd92a2bee2c6ab75e2517f0a7910f5f01b57cc69ef996c6ac2e2afff6465f5e265739fac9b1dbd434de013ab7aa9cdda5cba8b13f056635e89bb69e02bff5869f4baef15d7ddecc070e3fc10c2ea93fbf0657c044b8ab28beb09aac623d1a8cf0f73608952ffd9eed86f5b41a887c56028abfc7e9fddd32ea8192433d852739bf9efe7398caeb4e1146a28ca84ffcf135b0dbbf5cd02075bedd61bd76f9dfb99e1300ee376c4632b82468bb71ff15593831ec8bf704f67d840fe53df27b76cf892ee5381d0cfdf6ad96eac8e2e05491f400f3658284991a66d1c532a4aa3c795d9a42614c6ed01229ac3d8ab2e8f1b7f86a1c1a209d50c2f398621d212be2f5385acbfd3de67726d874be97a21f612365ba353af7b8c9415f361d95046eefe60f2d54b723e19811d9ffda024d9d1e58dde3a0a3a7e0ff6c6a9db124562c392c2a387df52953013252c9c4d1065d0f9f1af186d757de17d02082614a7a0ebb24a96dee0c8c2a3201f319e9321003946ed7467fa198c083b801cc29a160fe201f4bef97d6eeec4a3fe7738d47f4b1872a13874aee9539542270bd94e2e12f64ea29ec2fdd7d0e05e3cbc42370b457e9a33e501c4bb2c91f889807e8f9dfa3852c1d6cbae411deb8434454c9a522211f6f7082c9ce594da2ea53d9aa006398898694ba24128ae396343222163b1e47608d9e9834fb75a6b3cc7b490dcec83ff9d54ba84b99baf5e4799064474b17b2cd69dde8628a78dde2d0d960374bfeda5b336917e4b615c610d649e46f0e99a342344ffae7e6e2ec407eadd280396aac6ff3feda6a9d47bbae4939a019f82bbcd8d314935eb606131aa3543972778f227365b9f1ba3f590452bfd739dfc9a9277cf8e3b3ae3089ea38010e4460e0f4350363747c7103f6332e77e8bfa7ccf3b5ff15402a96f6d8d5bc347d8015cf4b60aa39cc10ea3a90f659188a05391604a2b3e5b2e8de9489e9bc391a6f0ad8f1323bc63552ade3686ee589ed46722378817643fa6e051682e6e4697589e36e7677d05aaac41a1f7dc16a0045b6719105542d3558024d9a1e63642fa3b2a1107dc7c396cdb4a788e4408a27b7b2d8ea095332e6ba455fe1bb812f16551a8a3fbdb999aefbca2dbeb3e5d26a751be75937266a8ff105313ef7939b4947e86e273379cc8cac4696aae53c4ef122656047b2b855c481c9f34a683b81554a25bde3bd8d6ef1cffc8c6a97283f7dc097ce99ffb8078b2812cfdb3566035d59774d31daebb7fb5a32f72ac061dd07db6768801e170dad1ddf307deff9603858b319a4611fc607be2f748db32655d2c06699b30719dcca6afa4701c9700fa8c00db9b3115c4db2881ae725fc27f4498471af10069c8781112ba27ecb97a0f1f92f6f4bd5996ddbf46fef838045897e457e9ce74b37cd4dd1c53b9571ae511c503082a3ac295b9c52ac750f04db05eed07dba5264046cf7f8142102c29d4a9d4a69085ec9e4580ccb049b27c38030785f25467c9b6e92916b21165fa4132e55c3133f10db584eaf046b59eb6b185a549eca1b3c2eb7d1f5f465235df2675763d10daad50d316eca425ec40a5e57b1cf7315fd6995539f49b2778dacc09b668be69e3e99f61ca91afbc8ba368ca6eb0250f9792f8ca1124303eca32d927665c97984f039d0fcdf7970db6fcdc992d0d49603be8db991d7bc582c22fb45948e7545f0ae36cd3843b4f7f4441bf965a9d8a5097afb1c2bbacade60bdef1d9ed29ece505925f561af9a4880fd8302c885ad6f593339542050710c5d3f8a6b45869c41255e76155b3ebf1e9f55dfdc51f6ae1d480f090717245f7afca10020ff768f5e57552abf002f59ba81d50f10dfe19025073dcce7e24c1c2cfc362fb83fdfb40e876b06396c651f99f0ae3620c8bf7477eb8f68a67c293466c4a18b5bde85347544b947d8d210def00bc72e74176df74c41ad1d2ebfbd6d1a1ed4630fdb90b799bb940f6c26b807e4b9fe00da2bf1404d6b6ee25d024f404efad0d6c525774c50b4c2478384321f025874e7a9a17e24386ad396bf46bfe03292c61bc5c59cb27a20bf76538a140165f1ef4031852913845f1e46a0a79beddda1c12b4914289747734ff3736282045cbf5507764c1e6ab92562f4c915797aeead57f1ddaedf321466bfe23f71c44ec4f565b0c2d40b63f45466713c13e6d8d6c3dbd1c21bbb4aba157f2f0e6df01d0eae963235571c096f731b55cfe77865d56ec143d6b69ac1f95dcbb5e31d2925c00162590e02375d6092b862c0bafcae5fe9dcc613c6858a4c040d70f71a2027185e82ed7dfdb21f24c92c1db2f4b341be580ff2e43332d2e4bd145ec35dd90671ccb11f16779d34cf219bee0c4b18a077542b221b64efe2526c0142238a42cea925f57fe42de650d4277cec7dd275d450dc8b5a852ec9fdb9338bf9c88782700ab9f61f70cbb410b2a701f63530ae9b16233703196c2d3cccdd8f7130ed3d599e47be87ee2458e5f0fc179557bdcca8f8bf7bbb56034812a87ee596e003586a7714960300c669e8d613f1e8ea48cf19a7244fa2521c033fdd7648cc82e068e35c49723db958a1809a389ed0f708c67a7676481ca1e21ec713a97cd1f89f874685cb9fcd9c022f32dfab2e6c80459a99f65c20dfe40f3bbacffe986cfe8ef68d5d1a61930c8957055524c59db7b170e01d0b77a23f50220783c6ebc8c3e774f8b7ef327e2e4c8f8022e8123ae8082bdeda39c86a409b9965c34854124ed590f6c1a71a34a8394f81f2da3486e085f6f8cd1ddeb0c2380c675ac3c87537508ded01bd4b30b79c1b772997abecbd4d34721ffa7a781caf657b564d08125f611882fd7705be1ca5d25dc9d27b507ec34444e01e099357056c94b22a4d838833cf241df8dda1f8f63cf47300deeb43daf9f684fd58d418448b4716ef7f61399482889093dc8d09f898813f4610a779c1b7f80386abbc2c5653efe7a5dc5efceb7ef3d31b4319f5bb7e2362db60c304092b5c988900253994733d35d5cc6d432dc194faa6f6996436b980c165101f94f7a2af9f07ececbf2067dbf0ba8e9fc6f2ef090e97e96c1211a5a7bad68907894e0dadb30286994c7e927eaddc2198a1464f0277c5ea20acb2761a00d6e054fa1c0b6f3dd6f19911ee094fef96f22f00ba78cbc79c9587842eae5864a80b014df7b8738624e40ed901b7c5eddbbe00638e164f9cc0ec9865eed07768d3affedf3f00c09e2d7dcc55c271325dbe3b3b83ea6b12a8759704f648511f0ae8bfc8a202c02458b5f949f1394b5670fb181ad53392108af1ef21142adb71dbeb746c88d0d43e289dbf5cc44e799dd95c3d3272fe954fd5bc06d0b4bed823745381d4790d35284d31a57740e726755d6ce552cebebfbac64f84f9a60ef1524c27b2a9a17707a8bbd600b23795a829c75adeb96ec5e8fbf6d9e409e4e6ef78364145b11088c561d7e56129a8ae4aa0574d8c1ab1ff682a3f35cbca6dbd7a796889ea9e950d8aab24de59b95084c64a7ab95a058c911c3695dbab2b417de7d7ab942f488173256fae95bb19f96c91069b43b2aac46c0ea58fd36f2adbe81342fa3d3d053b3ebd3bebb1893a67de96531d413b28f1ebe618f81ebe0180111ccc4c71f82bd22d7787a2eeceee30f91d070bd90580c711669b1c522d77896b78eb263192f3111ec9491e819b43ed4e7f38e4cbd13b821b1e769b76a300537f2bab7ef4a588483037852b5805697076f54708ce937324269b825d6964ac05946ff56d7b68e17ae40cb486c6d380ce88bc7bb0197932fe69f9fa54820270528a4a6485b618beea1888eb41be1f7ca720a0dfa51f7a22a7b420eec061c059a8c278ac23d52bc365bf5631b8ea020643a5fe59b85b592fbc5e7ce759b22fd5a3f54bd5766f1c4c52312399eeada9f5f0af33615a6bc55f230ff37e5aec68bdce5a9071d60f16d09ff9d87b5785ded22c77f571e7e4e48e3b05c3ce2337e48572435933aa281ac350d9a3fbbb49415e74b6385166db7cf8fb7b15eeff162628bb472148a3ae3a89e189a97644b7d9905b8664541e670f84779bb1eb8b26715c57f4d35fb37c487b6f3d91f23fb30798fd3335e19c1b9ca3bd7963e91822162b2c16ba8d23a4fafcdbf17c044efd00f8cef2a75d48a3efef2f3a350fe41845d9af979e952daf42e7c973cbd7d1215235b922e6222535cf024d3fa79f8015ef167c6c2428c047a1f442d084665dc6c5bc9267d4989dcfafcc3626589712fd3b3b404b782ea176025430cf4984d41c0ceb194119e456a4669d436fb88ee87a1a138eab8f787d58fc3e33513c1db14b089fd3cc7d3963edc03141d799395ad11c3cc66a4676ce8389e7c43198231149c85f9699886b94413eae64c05b5d5ed3d063682ae5183e1ce1bb68883e3493ec5dd93cebaca22eda46f50a01a7c954fe26b68cac1cf780c7181d53a589fad5bcb005e1c38418a4aaf0631786eccfa6b5d2630c8d424afde00756407de928b5764825fee05d78fc6fe4492b1eb1f2740189ad6c67d59ff0d4f7e0c69bfa8b56dbf51391e2653e86dd63495ad5583ac9585fe403cb8f9a6d48a3df7c59b15e0d1bc6e1f40b78a5600c4f1bfc6d0cce172736c17d5f7c74789f6b87a790286660029224171a1e711375ca5c6404325100a089d420f022a0df21191e1dde9824d533360af73a0d76f1d08b97a8bf06cc0cc9dd108539b1b5ae985ae93d17fded91463c28dbbe1f87cac2f7639fb963d162263bea256c249ede2f2287787338fdb445b1446ae352a9cf26d8d346d36e73dd9ffd4fa14b8252b497a6e5fb28edf507d448d0f71a4b52d7c27922f25efb4ac94587def028b718f7e288c84ce8c72c02978045e291b4fc93785b7a2fdb2d92c7e4c93b062be7d07c498fc19d05ed1c74a4b4710c41bf5bf955467d548f778a89a90f13825bfa5d93a30d7202238949d957d7528fc26f714b40f2230fcc4ae7d61f1ef0acf9c6538a1bc60badeda28a637774c8267ce325dac3ae248a87d5baa285fc87f4ffc0cd642ba04f2fc7c0eb62aa8cf2b6ac85e6ec1dfcc2ffa77fa6e4da60375b29ead0967796d4ff9843295b3c227e5b73abd270b0fa9d43b8dccab17578124fb7d870f8e5830a3af4e6bbadab14c41f992a6d03d4f6f26381b09c92568fdcf595b7ab3a0d3e8463a53598921887c6be9fbf52333a9bcdf7837860d69be4a8d9b50ada081e425a834a7b8c8909919523faca0798fc0efa0531111e0f72a70763fd7d5dd2f810e1093dd7402a9baf4d988bf6b5af42d5549b30f633fd7ba9388a15210b510717da0d6801e244167911c336236c4e5a70ee4b129e2fe33eb97af866bc1cbc693b1f98318e76f78d6b8517108c7038862e3e121b6b983a954c77693ff854c4b3ba3dfa061354e25acde644688b1025b03f63abc0446dcf48b53ca22d0d8a1d08f83f79a7c533a6ca6aea7a6feb6db7a49cdfde9b68a9b8d6a088198d4c9cae78c1612470661e5ae5813095cf2d98c2378f08e328407a11b27c05a2a9552f74bd64bfcd4fa7e2ea343315085224b94478ce7525cbcc1fb4135a1b4afc6e7d430b7fe12c7cb2654e1e5c85970843bb18d8acdadea487b88fff6b7f00c31e005b0c4a7516a41842e479e66ae5f512e53cbd72ae8091adbaafd484229702816885167be21c009a0db70b48bc047757b3d487adaca1beccf0c5282a8d67b637c8362a077ea0f9bd67a256afd4a897db2db64d7a70f916ce6a62b64bc3e468dfccfbc773a026b050b982c1e8776f3744f3a700fc2b316db4d14aaa1971bc0474c5bec71a16f5fac4cdda3834d72698991f1e5634c8c7c7da65cef3770fac587b391d5cf2342df9f600f0025eccd503c7e1115691e20742c2a4e4ecb5e93d6a812c97150cadb3a09553eb3372c33af2e55959933712e48df01cbd0688fc3ec616d28640adaadc3add05a7afa6f3ac2ee270516aae8c4d669a0ea4dc57de7b4644d42dd3fbfd7d58371e1f7936f29a19cbcad5abf914608ac82aa39853e0675fb6a764ef462a1e356ab6ca0014d47fe208ec8baf5bf40ee3a89116a4e06a36eed0882e3c8435969b8f1dca6815e3bb22170f6b128351129094bdd07f77ddc8dad20514fe13cd0618c06930265a1e5ede34aeb22820638010085604f9447b62540c60b8130c5dbd82d978ab323098a021ff970d428ae7b2bb905623f4d54dbcaf5f6b683d24cabcc3d5c50bfe384df1f7a38599e588532e1f9df167ad867b10f96265c61f641e037fb4c6719f5e17a1e43a2c38529f483378f97e64f3f32ee467b3a80d33bf62a0f7832d6cc59a0b4577efac1263bf4935b0396af9d9e3623569ca9394fff902dfa0edd592465cb53b233c77295ccf9815748d144c99ae4c1e9a0cc84e38b8dc264a3cae6adbe99ecac33d78afaa5741e11160670efd3c1429edcdc0afbc7feeb040763274f4f41609b9c197ec140e01c27bdf68ca6b3ef39d463ad57cd2a3dfb0bce8e950ee08ad38aef2f7afdc7cc236e8be50e01dacda49a1d67988be583f6c55db6702a8f074e8c05a9230dbb6ed6c1360d889a54e6f776736973d040f0ae92b2030a55c44a4d047d0a5cb60989a55039fa55e59dc43fb24a231491b16b673f5463c9944d3a4089b6acdefe4c6a6bf982ff2cbf747b6963a9f671717a9c628eb750b19a360988938652073eeb7c812b717abeaefada19eb021849e7f0f71a13257900ffbe2706b4cd17503bc935b8835e20beee0adbffcda05a473397e611a60eabe7ed0d52894560ba0821256882fedef6efde39382e6bb34982f70f4a2abb4ee1fc1f9317bf6e31de5d514920e989a747b4e51a99c7c09b0dbe7388cd86c80621ab888d23a8f1b5814aa36eff0e2617a84a61997962ec544ea6b9261b92f8352f3c54b107b24b0f7f89c817d2a47ca3714016571146b931d58a8348e77c5131e2ce85c4c2f66767b676f8841b5e4353fc7c1bc54f4f2a7f5635b749db020ec298558bc1036cb2144cb055cef98b868a2fa42dc4cbc6d523030d033dfbe05b0f1bd64899a2685bdb6cb2a3994f7655741f7e16e4e4a3839175edd0c6ee72b5f85f8a431e25fcbbef76c8cc4fe08159076c628126209eea05d6adf7da4166e294dd240695e918ed06bb74021b485e54bcd5f638c8bdb2e204fcdaaf5c2e2136e65dcd5603aaf34d4d564b8a16f0a8fdfa48768e56ff90e3df697bff3d6c7ddfd91b47b30d385e7cd3630b037a538077d97340303e8fb380d22a6d9ae1f60ba6fd7d68388544a49e162dc11ca5b56c741b1546e0ebfb2981d8b2be7b53bb883b66337ed7e8b62bbc3ffa533c646ffd6ab4d27e66f7d7fe9c8cb4784ddd0cd0822a9c701ba7b0c33668e19e6718d55f6f7b2d57b622085da6fde2bfe4d559d2a552601e4bbdc3bca4b48ac1f24137eb2a3f9d61bed95dccd38473e8cc280ea57dc8934f1d5ed91093b63dc990dce20f584fb109f5300c3c3576d1ac1452742d273df95b8f741c4d0ba9998df3dc2f62c33fe2d7ce6656a891eb9bacb54260e3e4cd2f6cf729086ad1cf508d4cca61506ff53ab5ca88c1ababa5a7858b2b4e35d61b60b79259551474ae715bcf2db9336f19c0e0cc39f861051e4aa565ee5ce922d2c0c06fa56a63ff796b2f131ef675eb9562a2f9f0b763337504b1effe93f25e3d8e226d0ae88dc750d44af1a9510226209cdd22e97c9cc5160b10b96f41d886f7d5e2305fd37b8f2a3143fbc8e921f72220925ef16d5c0cb1194f720abfd54ace67d18fbf5d3e784cfda50801c59617a466c71fb5da025ce42ce15e3e839b7adafeff36a33d24b51dc8254a30f25a1b8f460249a25db92eee3327f9cf3a9f3d645482e83e08182e188a5da750f383e39509eb114d9ee2e6750165dc53169775c7e631471fb999bf5af7f714621126f464d0072fbcf94b4614fb685fc455972a04bd2b75c739dd05de913e0ca44c1f8411b7c7479d6bd51cfa45525adc013ed64a94a2514c5b6d187cd926a93e1902c97f164f9126c52dc4fbb0eb31827195262f531f940c799a85118f89c4ca6c85d551f4332b022235167885e21f02e094ed1b5fd164abf25407fe73ef5147dd10ff1cab9285d27a9a38c659b0583bc98037c2249099b1e1eba726bde118b098440e5629339e1bf18753e33958a5ea4a8d90c73879122af64dce59ba1c07a7ffb3ddb624d5bf6cb4c24232acaf4949cc4e6a473805a4ebfeeeaf7b5c2f0566f7c88020c0afa74a22d0ee1c9f0b85bca6367a3f0ccc2db80afe4592b6246f64133e6190526594a8fd711ed4cc44db29b44e6c2fe1c0d0101e77c7028a14f23cf8b1e770407186f7fafa77c67f2e8999431ce75d2efad05dd1e017a733edec4b86050682022dbe3b22b91d7910ebf73446eebdb77bfc88ffe46120c4053fc42fe389f4c26fd4654a38985710a041691abdebfcff0bd19c517b76fcc7abc4e9851ee24ee568961704d8f193ff25bb73d0613d7c521a81c4ebf3711e7d741058c0134641473636b52dc85537224b7b948e112e38272a884eee53c9b59d4731984712cf7a975c3e3cfa1b55bb6127ece87453c68eb6a7e5d95899890b31ade508fb09f76007e84b03838dedf22b8282eca6f3a26d5db7940a519234e82a88c0c781379f1ba1c5cc5a5d7657203214bb9e688e6a10316251c5d6c4a0ae2aba99284ed84e4b87a96886291cbabad942b729aec0ed2dd3b037f27b94b8a58bb50b4ebec8030f99faf453ac787a1dd1927c28ea8791ce0bc0d5e9c9ac376984d46ba886dd29a5fa4abf2dad68a0f44ae1e2514b352da4c164313b97207bd17c337bd09df602afa247f36b2dc62f2916a05bcdcfde1fb4a87fc1d12b63c1a7ddf647fcb948e99db2011f6e034bd64c838b24396ccfb0791942435af0c5b4c9b182a4d8eeab7b287ebd3be9e01fd51297d6e4f6c3621fd4d263599f21d63dd55983979f3db923d255e24c9a39fe8804cdf469957410a7925808ea76bfd69da0a8107dc0165df97a10fa1db44e0f49f6153f70d7c5b4e28167ed173c9d8af96ad097274f07eedfc6852498d916820383ad0eb08ca7da7396ceea4d6656d658da2d8a90974ab3d8a1c2dd74f2cbb57998e4a11304774882ed186e973ff06ccd27c0d992b644a9ca13e090436dbe5e50392c46402f462b600a90ea2a69cb7280f7f8e4cfeab6dd140200f7870428fc607f5bcd781807a5dee5656f9319705a05f5d7b8f814f74e0fa1463de488c8cc80553870ee930604a24c3551a12313d5ea8179076bff3061559a53adf6b4de1289c8dea789f8b2dd39c3b47f67ab4b73e49db4c767988654950359a132c1ba8d2865264f7b72391a73f7e09524b2d24aebb6ae80e685209dd685b74d09ca09c8d251bce9371da5fa2e848301ac7119ae7ff426c1b2d5a3f617e5a278e6360c033484de0b84759e9a3bf672828a416cf9963e11da984ea52af8cb0a9a5076dfba235c72cb9684f2b63e1f78ee4568fb8e9f7e5aa01bc8b5923826d007d4891cf4e27471bd6057f70a9fa08bdbf0389e355780e7ed42b4fcd1a72043e8980f04ebe0ad9afbd7dd5ddfe0ff8cfbba3527bb6885ecca7be8f8db823f31a7c592da2af8511bf6e1d7bfd942cf188eb9c9466c29f9adf464cfa3378907db69a6a45676d18eff96cd93bfafe81acb07b08f238aba31964dfbdc56b3d2997b145be0ee4f3ce7358212d4f5063b50c4def77e95064548fe91448ada7983b4ebe12fb53cc96db859635fb5941f26dd7c68214157fafe3877cc25367909401f3e9d1651bf0fd8b0d08b40023574f108d5ad8b9debc6f4d19aa6b87755ae6a90464f02eb7e2836ff1eb9cbf9dafdc5a17d08a7fa7937cef3b341a4130b8725c3201779c6ab424a583750297e75680c3f48508e504e364e90f26f3e5c746afd6a301c7b561604496ec8658ce7598640205be3efe536284f69ef2ba7cf1f331b8a53c8536a38443e5e90cbc89239e5eb1fcd0a249c8de01cd1f7f1d4e0fc9376ae8ed12a6ab9069760b58ac35e8af060f7aefd62cb79e9b1cdeee20bd9e2b5c20cf80bfee435e1f342ff2584cbb71b5a88f5272e9fd52ffa9c692659ff5a9bc8f36ce4d5676d2a8b3205cf02a161befc3acced685f3e428fa538d6cc903d23335d9911006a7990891ec40daf816f65e35d66cbd5914e0ff4a518966ab21dcfd3ca9c0bd573e93fb6e8b794f6c784bedcd88248f612a738aaf1efceb7736b990f9e076dbda146ae1f3d3e98c4caf5509496afecaef1299f2ce739fd96afd86945fbd9ac24f07a4b8338b5c2c37142d0959ad2d5daec0297911a472e95eb632a545ecb777e42dbc2b303092a83f2c5bea507cc24a3a8db8a85f03836a09285cb452bdc1c97fea9a0591dc8176c50fc2e5f566e0ffc5ad58d4fdf23f09116a8b12c87e3fa54d7d20ce45ee98071b1de15911a4c8e1d5d15802176d18c6c7bb976698a08a4c2557a93aab36eb423e0ef1682f05f6e3df0fc3c43eadcf057f32ec24442cb63e844a4931af5a9f391cebb461000dec1f82f4b88144547cde299d5f88348b3624a145c62235890c5f3b4e89e170ec9a5fb16176cfe0e723fa9adf72f17cf24d891a442b3a5c792619ad6566bab58bddf68eedd827717cacc7a6fd23c59ecb7fcaef79c77fc9adbfcd7f960963a8f7bdac2fafef7f14c9bad7b60046da3627ea6a29efddf9d4cc4c97f9b78062c2bf34ba9fe1226cfd79d4c8f3f4a092fab1b7040bab6a84675841e874c90dc18af53138a422a6f87f2dae83f449d10774d4b646658543ea488121700cf7d5467bd7e4ffd80fa5d2a23624cc64b2c90177b46b58805155eb89d435695b08ca3233e6baec4c0ae43f126c0ed9e30380234050229faf268c76f9dc8abd24cf95ed756c07cdc2eb410e5ef2414e4ff90cb7ade3f96c498e2ff84585e002bf634399d5c6b41c0d5dd3675caf156590d6abc159b772ab94595d18193af9fc99c927c0a8c9c2e1d17f50efcbe220df9b0356e6f004baf085fb1aa0653d89a0270a8f1b4d64c94b7fd0fef90267c826da097f62564868f05cc9500b5b724e06cdd0ee2b521a5d355a74ef2aacb9d099e7606c990873f3dd712fd555aa8d3c23b44a7757d61b7180dff9236a7a83aada6a7770ef025881f81156a7da7c20eef6c3dd13dfc698fb9f58c5709fbe3617bc836fc57c705c20683621a256ea7918190695865d5e00e96bc23004b2cec65951283b1512cf6249b6d78cc6f4289e9cb6633fd6c2b9217743b84950a7177ea359d9e5446f804392860d877312deb45a3b000cdb30612519a67ace11c4e7b03d93b9424de0d52b20ae7d76433a578baf976c1002539fbf6f4bbac8b44d353650a98a92ce0f8b11d884d3b60c57a54c594a87e18f92de08269b1a8fd35423c6afb1523a33669ef16945ad2090e00a94ac0d77f815c807581b94a8bd0389e6e0138c695f64a8cb639afd18eed8e3e957dc1a258edd04ba8cd628fba4d652b3c9508c3aeabf93a7ac54b680fd7dc01e791885dfcd2fd03d581da6006b72c351a0293f857920d640dd9b4299c79669dfca6ede145ce28b260a59330235fbca9e894332c81842743cb29f39aa9948a4d05ecbeac436923bfb437445492db202a6cfc69c13a1451f5390d12d34f91e44f3eef89df7565738437f7be80c90e0e1f59169688404829db03d3a7b8e88058a6c35602a45d8c130bb84c4cae65b128f77bc820a9472b88ceb58cfcce01b3db184f9c21588ce08d55d22c88a0a0b7c3c66c9573aafa33555b73e73b6339b5f2d2d1f358fc72e4b1ebaed53a213d826c0b921abbad6d3831cbde5e2b4d1912f3152f6a7975cdd94cb8bfac8cff57134bb190c7d58aff16e9b5be26b7b4dabcb9ab98f25b0341cc8ad5863df7b1df582cbc2a597c793224fb56447aba60695db6ed09d0e2ecf5f71837970fc020a277b99c1481c6d1cb10ff599c0d8642c75a665a9d18dc4f8f101d5962691ddd251ee3a919a531750db2f76b6e1fd939b6753521c494b43ac51bdeb53611257f25750cb2b73fb98d248dc71231e2b040010908d2cd678a591c48b8e74887995ca6b7e0e3ce97bf6633060006acd5cb4be7bbaeb3e26540b4a4d5c52b1988444c2500300adf31f24058f1a949be243ba4539f0312137232dbd265fc0d650cfa2caca5fd87dd1153178e92c729cedb78dd54450d3c653943302dfad4218586dde265ceff0cfec0fc5f023e240437e91a20f17fbeca8489926a6c89c8c5ae6b2bc446b2b90c23a229f3523aa5a5571a738241687e5f0de73777b394681a67aa85f852ce5335c8b214b622434445914366adff918200769907600db2be00937e9a2fbf18aad19f36e7cb63beb39f75e45ac4d42d346ced5561756d9b9b782d3f9b380acc476a9239cdc39a2d623ec2f1625380c930ac668d010bfd34f260eced477383e06286d28d7f8421fdad9febded8007a666a68c2aa24e0b7f9bd40bdfe2057c4f6ad780f4e9a6a8fe8a1bcec7f8ac52660e7966461936dafde69e263bd750dd513498d95503b1ab3ce4377b035c3f40fa1d521c23e412029b99497d52cdf86ecd1f3f1e196a347d20bf91bd9692dbd9c2d867d4b2cb8c59b9cac19b456a6cb1b6c782e8748f32e09c68557f64bc87b8d753bd6365cbf85ced0567c4a205f3075df83a35740f79b09b7ec0797f9138b7a86ce1b8d5f446e0768f17d9da3b88aa388da26095667e9618b57fad09179bd2c9e3d48cca0575f737bce053da0b35b052362152945e093e3288dfa025a3e57ed2f4518fdf60e229ed92347cb8474fc2504d0eaf513e2dd4d7b4b47567e84095e69ed9f1d0b7d83095af8e3fe66ffc4a2793154dfa2a800f3c4b5fe2018a13f4cd7875fea9f23bcf321bbbe93f131198b6ba073087a9555b1b493891de5f8337a7aabd0805435b1a4d1b3b8c907571a3539c06ffee6bac32460f0722646c9a8c7e822b876ecc9bdaf64e78fb86abfe9f86ff7b0a0ae2d591c4307a89526f8524fb90ece3c946104b7cdcbcb71893c35a665215161712cab0c3d243a7588798cd132144b81d7c702de2ac48f490f21b694a5d531d1de17b331ecae2939f029c63af094f97943d2e5e6d3cbe30640d7cc1dc7e27459e92b8adaa150c9ed25eb96aa51dd310a5957904313bbb3d064400c3c7369c2cbb33b3ff42769abea35d15205fbb9efe8846b737466e7ec1feca9ad68da1ac83e91c7df6cf42793e6ff2331cdab73e3f66057cc9a141703c8c3ef0df5564922ecc92f8851d2ac41ef556ee9c505c5bbbb0eee6ffb975b130c20eb3007c6ef6cf8c9176157a979d87f00d1b9a7bcdb73995800eeaeeca30ebd10131975c601d729d903cb6394fb0c14f1065f6ef06c1d3e7a0306ac701f373252caf61d7dd0684381194284fae123a261ac82102138e12795662a99ac96de620d4b9e9835b0c79d3972ab38a1767d083e93e10cc7d3f704c19a82b9896724e1531f18f95bdaee10bdeda65db350f1b837b7756f5dcfe4d095c0fd0dd3cdfdac3a8828a2be6558eb01c4f4e483593c96553e599a0e9a34c5a29ef27081eacdedbd90fc8862351b06fc5698de43713ee6947c72a62e19c8faf790324bf58e7c8814a67ae6e69056e52774c9d7e38d1ba38d05591b359755f99ce78fe23806038ebaa3c5af9e4c5895a86558b4c91d96bbd05348e85c5dad3562d2b212c690d88fbdab3652ffbda9dbff97cecb9957ae1acf3e4252f26d42f585d73b9212b8255065303547a074085f54f7c85f9d39cacad55e3375e01fd358baa790a69cc1e303688870ce700e6be8ea6c897472a8597c13efeb72ac9f5a99dea6a755fa0f6871d76a599f85327092c48bc238dfdc7f4e1367cac91c694327738efa5f913a2845399130d8431aca0edf1bc5d132052a50166bc30393b9d66019257c58cad71b8894d2f4e223d3100f17eb38c27c47c9eed54e8d857720bcd3de260724ae4963fb4e1a3297e9b5c9e6b1d84d68cd39ee842e99db128a50d3a6c08a6276afdfbe05131d5dd085467431638110a3154331e0c1edc04292cdb2acb53423b5505bd27588720128f00f08f36e09a224a06dc0265c5635582253f9af3fa0c88d12668a9e84ba2b10dbdb9bc1555f1ecb58e43697935141219c25fd542777bffbcebf6b73d0dd760312d43ee23a9379c667a85108d41363194df33067493c41fbb44aa2bae22a84455244e1de26e2c1afeb5608a4bf7ae5b6b59d572c0cf68cc4298463156510dcf47f5f6cc0661c49985d555203da64dfb8e25651591be51b93cae47bd4c78678fbe3bc620da7c77ea67f0471a68615f93d1ae84023904eb62f3dc9f90fbdf697ea1d425a74df36bff3137d89a0c5158c72b7c0b2a0d092c0d323a09870398d9e4b6397c6efacfb8480e9445cc1bfbf57eb534a89832558c6a144921efdb19be8b0af9810c2bc83c916921567aa35831a6de8ddb8212ad127d77422388defd809ad42be985b4960c6cefc404dc79efc56d3122799d67bee42359faa25b31687f5d169a58e0359f93ee272cb3c9a9ab10c0605a57a9fd2d07cc6ada251af6f08427de8903758d7f40f2be061fd48935783224fe3e92b2cd4f981c9c28209647777d4a65d43e197026e25f1f663ac9661646187b89cfa5a74feb89483766bbcccd3ebc8cceac92e8fb2cddae33870e80599b5ed99094ebd9c28905445aa73b70914e7393c8e281a664067ac903aab53ddd3e3b623e729f0717a86ef8b6406eb59d4a738da8967c5025040cbf7e50d5fa1cca67edab8d8993c30454ab247f37d1ba7436c1d0e0008b0213ec2421439b0a2f0258a53ca8421886fa359a4730f9b677b1f4b7bbe149888f3d15dfcc9187fdffcc1d2b931ed7bcb570bf785d8da927f3a57454182afe65e56785aaba678aa9544951684018262b9995e12d867c93213352b8360be75e190c134575507661ba55371203c3de6fd8a48e1b8b3ff8682c5c5584b98f9af0ccdb9f61afafc9d5efb8b37172ad0c02f90a8d97b156968c3447c0014f24b36fa6f3e8e23b4f21a1061f4fab225a48b9fa4431811078e162d69746b6762581e76e8f77b7234dfe944570a4f3963e4ed81e8d894fb033f03578774c896adabbc1b7e74e61dc24802723b13aba7fc77e16b321c183af7ae0d80b15bfbc32d75a5a43d4e263ff8e9c1ba80caaada8261e33e9fd0f04d955ad0eb62fcafd48a1dcb547cfd3ef6724d777766de7d0faa7907923ae9d44d01b4dfc8ea3c176fa421c805eee4a2fe7f818b74e977562f20cbc627ee8c364d4bb751c4090f6ae30afec3b1d04eb416fc06a588f33be0c1baf5cec39876fc928192f75c36f73b8e68c63e51e1a572a3bdcca46810c298e589d1f744d411b043e98771492353d98d78dbcdce676bc32c3f169249f2a63811ca216171f3e48d83f2ba7e4b3f1930797f7fc9ffe0540d72eda86c090247ebce5356e1a8f45f7c778e9cd595373aa61c5a36ad48a4a3d9107a32b9b2489f1257a00d1778dd9248b126fea4340a17208381a0cdf1ec3a50ef8e84ecef035270b285a157ee4c29dd2e5c785387fc7e4a5309ee3fe18aef2f30b27f58fb965685377a1c21700e05cb2c9204aaf0e15aa8bc86ce55d172eeec99f726e3f44f214d41a4562b9cd6460c513e9e14e0862cd258dc0d495baeea703ceb99715c49b94c8bbdde5a98f597e16e7f562ab0df4031507482b2c6edfa1710e388b094943f1975a2b72f6007af8bb8d45a982a91c7c8ac82bc733eaa4f69d2b83510c5ed653549b104b7a659a21f6ae302a2268b44f5e66f675f1d0c7f60472071165cf058e0da47da9137e6c00936b716faaf623c81477e4245f3e0396215d301e1be9098cb740de009f6c63ff16d7355b8f95bbbd0f745999eaa50c752dc9ef2d1f05ed03558218943752a5400b888c07e8e21997fe039ff2a1233110f48cdc1b8924cc170639d187833916b161ad36e2f3074ed64a67c527e3c17ddf42615f0741cf23ca30e78b189e314979685c5b1976424064a2d812ccdac03e087f492b622f5edbb705aa08adffeae5f715f0a5354f6968e93009283f03776cbdcd541e3e84c1bb41b5891966d703cd502664391e61470bd56b1e4f4f8d4933b07f725bc8ab6e1196972e4d2713f04d21c3307e603bbe537184eba485c4090bb5f0619fb68ccdb22","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
