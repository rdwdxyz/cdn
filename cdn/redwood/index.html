<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf4153f8ad984b6d3eaef1b9da5b626c6266b96750970d518f01730e32666b3204772a9600d1282f30cdf97907ba0e78db08c92e944219226d8c6ae57c65d86ca5b3a8701954367470fc04f17e18f279df67d189ef26148d4c47c257e7775b51bcb0b2e6216c806a1f29666475cb150211246e55f04dc42491d5a31d77bfab34a07fab7197c32f9346ae629a50c6c4c88f4713168d99e7178fa18398170fab77d4dd32d6c44798b4ef3350200dfa2b6927763aad8f9ecf9ad22e2008e8b5a51d6c188a12a145b105018ec83673c3255c337f0474b5e050f7de7a8d2150002f325562a7c47e5391571453151f9a7b51bad11bcbd45f5804f1fa1cf92921e190884d1a6e024b82ebba4b56911e6e231871980abab4b7b60616266cbe2c062f9ae6ade791cddf78a865314a10c2023678f78f828aa62934370e8912092981f2f80cf5e1460c97657dadc1278ec7b1da801e0137a0255864c0a10d382e5be34efee71016be7eebae6c7f11549bee61d8d74c0104b229ca046ebd79fc14c29f4ff89ddccf447bd13747952967ffc17bbfeeb4e0c50c7e398c48d3bb08e67dd84a58dff4e63a255e1c49008b9325909574da4c00c11b977b0d129630e5a41088981b790a4d541ba08d2923b112afa6b8ff5a02717a94abad5c9d5703e78b0182db65d29da812f539cbbff2ef9253a95513cf6cc93f2dabd53f67609e7286a8783bb659f960694a43d842f15ffa334c16da123020d3f10bb41035abea8d175577aa99810d40c7303eab351c62d6bacb551f7c8b2044e09ee5597bae00ae3dfc470f031125263e61cb2daf855dca47912e7ac630bab41c238c3927372f8386aada6df55f1b57666561c21842d1d0fc124862e22c7abe6e5004954fff0c9c8989fe63c955645603e67656d7cdc9f89422a636c0a06133b27454ef21843ad34258dff996638144135dc296320b8929a2964fccf415f3c324717a572ccf95d447365e5b0e2f56791ac3a50188ee997c01d357bd7ae0e71d31b4d50aaeb2967353e0d73d0fdb36765c6edb3c3cc5b36a7e5562dc633d8834e42631efec2ae6593085c4d86a90abd985582a684071bd206c108f38a2212e2ab1b043ccdb91a15f0da7005a37c93f364f0eb088901a98e9527fa6afd805f3e8b54c9feca0f68ed1e3ba4289487df77c9a4b6e443240ae4afa44e69295a72e0254eff94ecbd6d879495fda264f925b7d5945bfd7cb79e9c98721f5d9f1b66fe1badc2b5d84a143f69789cbd21d31ec3a0ba6873f4b8c6e820a25866ef8df849de5a2cbbd98a2c12efbaebf82aa3763c3fe58ab50ffdcfcb7ede324255154fe35e748e6fa725b7e600a7bf97c94a66720e0ac66a991c5b4e1371d279a1947c1a47e1574a972ddce57258448d7b1fd57fa48ba1cc471aaf4963de5a6e1362fd261fd70015c3a7ce7466f9c54ae6474cecee7f2775d7ce34fa3fb27232730b3b3c4d13c9920ec8b8c176a725eae64b4d207d4d9b36ab4a6135209959800a3caa34491d516faf3808a7ae59d64378d2f7383edfaa843ccf6903e44e291e11b0b5d9cfcd0e442a66d3b9e17ebd4dcac004668a908e59ff8a2b464a936bed74c90ace4b6111a2ab182aa58b44617cf4bf6d1e52918f72e97c3b17e4401765141a8a492103942053f37fa733ee44bda69e30bab39c2b234139b46a1189a2b0c69af27bce278eb73e75efef977b45ec9ac4b0c609e10a1f047a84075b074fb2514f798f27b610c7536242ba5fc78a3889959c8296ca61c3517ceac3be1e39e6a9c7396acad06d990e4a8de72140db85c31f77c703ecc91e49451b7184e8b3286c8de1d5e6cb0aab80f1acbadf27baf97c0879693b4a53805e93126870016e1aac4575b6895a9c34607f26ee803710812563a929ea81a9581ac0ae8c808040a78bab0ec527352f822b72b50e3538d933df05c8357fc0a1650f9164b51cd0ff81737b2c9e6630cf94c11ccc504b29d0595d2460948877519579320585c22930c1fc963f310fd646e8e1de29a8c77779a4806fbe651f22ee19045b63ac828fc43db60faf536587c5ed5f4c11241361c0dc82855742f13080a36845034433d64356d30c2d6da6f8bfca878a976794bff9548c916175c8cd2562e62316df497c516e11fc8b7ad535d4dbbd62687ba998aff393297049a198d17023a2552f91a7874ee46d6c5442298cb6d6be410f9b6f86c5d4700dd7fd21693e224f7966c149bfc335c1fea5b6858129ae23df6a64007c4f010d6ec6c90814f631e7620b2a280eae3046fa81ba674821e8b6a88b1f53e1e4c67eb8849a83dcbd51f4b19d147b752eceec4917bdead5efa7de4254ffab22c71cc3504730b59d4934de72c24d6681ee246709498bcef528722e02471f5d2cb0b1e8bafe52c056cab806608dafa2e27838460d13d1d5d04781c6ef5914ef5d3d76e4fcf8e6651ea145a5133a45bac151ba886a85324b3f2a6891bc3c7c87678ef242a34757c22b5a1a199ccd6f6fe946ceb470a080a6bd5d8eee2a511452feb6f864fdf6a9844e23a90edfea205e77c7e56a7588495397f87066576b8aa99c949a0d47df8f35f0f80db4fd01ac8e0c2fecca53dae45f99e5024ecfcb8f6f6e905592e2ba85b9a5af4b76349d06d55f2cf0ab2c725b9c81dbd55d59bcbe388070296b8bca1d1149c018742f26eeb0c99dec10d88bc634f74d60c3108e5ab00f58baa63532dadd215444d92648a4254310f847dc54ef3571612b701848761148e4f4f9388542c8c1ac6fbacab86ca4ab34394cea7741b87260e280d3df8aefc6ce7052e8d0940bd32beba1884cc148f15a161743b6277375ad484ce2aa59f7dd1155437ded9b838daa720e6e054f7b61b631f8498619c41bff70a574a2d9bc91476ef495b92cb45777808db1b03d8e814e263602ff7630c3b6b06929e3c7bd91aebcccfeefa93645d5c9c2a5797ae4b68089b7950d0b0c3f08065703e0e764292b8a88f3906746dc1cf0bce8ab11c2361b71e8138595bb8d12a4d909a7fe1bcebfc8de548db9285fb5e0163044ff128879ab700c4bb8a657858cd6e076b63717bdadcfb164897ccbc5d1eb47637d402ae12a47d1bee01c0a9087e44e6166590946133b187c4f6922a3c2d29cb7869b8ff0fd277d67b2a0edf9e45c8597102fd631d3c947e76e8e492f96cff88989444591c6593bffbf7dd622b4171da80af5683635e04d6a0b1f468d04408d7461841fae714e6d868d6615d027884306d75b9e49e03d0dfb4c55f192f24fa84580cefec2b66181bdfc9020d64a3f8d6a3024fe3f1a5e9d69fe77de5f71c3dc6ac9d80a958260330aaf97468fd7244fb25f9a7131ce3417fc9ec0c19ccec2f92f1698895835d1195a19cab1771b15816d1ca7335b58a065a1ca495a7e2fefce1d0f2a2c1adfe27216c48553ec6c9725f5bebf16986af984e2564544444fa6a8bdfcded740cc568c0ed966d78328af00c5bd8ba3730e66f6a82375a79df24ce0a2ac6d65c582645b9071756d34d67ae3ca890bf7d3da92c218784a1ea885c6f74018c51706e4d74579c0cfcb5c5d18e95e5d6288637c02b3d2133f46e2d2160c898874bcff8d2595012f85ba6f0dbcc87e9f339dc24e94fb1a6e6fddb01b7417b50cd09f78d39ce85ca9f869193d1805f477fea6f29b317231df88fa0a723406afbe7e7f8d17e3a0b7af3c2706341f70ed16c53fb8bfb7713c00552087b7a6de470cafa29cf1a661f292c786a0981b9600cba0e750e0b523c92b1b21eae5dd1479887f3842d8ef19fe063a6b4a87b9dd491d0cb8e3aea65f9fda0f1b84bafc1e1dc0aed849a5dcb36c3fec2f83c97e1e1ed065361e9e74a10d6375153fffbb5fbbee1636d3020d1d3a384a0aecc6d2e7f934467f3e246b1c15d6d7b7cb57f83779c53349430e5ae8d8aa9553149d2103db45ae4564ac3076f663cef1e1c684b807ba16c34b70e1d59fb0763d301cabd071ce45668be5220b4989afeb7f3e1fd6fc75d01506510c5a863aa9f86ded82493486f7a883b16ba7813abca6fe232d2c58d71efc60a1e0f20fcc0a3744bb46e2548b4b5e694d7a929f7f31fcd7f8ab5124a7b88b8111d540c72bde5a625dd15d372a2f496a05acfeebf642fbbcf2e0358627e167c4fd8a92048d06be95d76548789138285f02d592ec424355fca60b37ddbf53259849968da53a94f0e8ae54a0ead983eb237596cac2e634d024c0408b5bd7604a52f1ec25c021a50fc746d31937bba0a588bf4d96f0d194357443c5bc77761cfde7edde8a5851968336b784d87963fb91d2614f2a514487c8bb4f21a9820e392952f9c9165858c234307042ef43ab2da93e3b61702f8832268921b22668a894e25adced99c25902008128ae69f88aedc7f926ae9bfa157ac4332211659d96b0eb3559b43300cd45dd75ea0acbb368ae4b647f0a97f7e97a012e8e13c522fef6a267a9742a577863eb5dbf39fc3dcddf9ea3d75d376be67d297a4ca3c92d28c0f2c3b9c68fd4590b62a8ac8c752a6486431d14ab1058e1cd8c54c272c50d9bcae52417943eaa25f19aecf9d97afcef0d9a3f684e88a18fcce045501317313edfc4172375ab2ddcb407b42062630f1275e0966fcd75fc82d9d4df224de0248047cab06df452deee03c13bff5d7c60310ce17f51b1868fb556b0f6f61b51fbb00d079aacee6de422918557900a43aa23dd65e756bfe887a52b6da14ab679b4e9318e28ceda7b31ce1915c7ff7bb1a4769bf7352172960dea56fa3bb20de4c9564075fb967297bde2a9d6f02f03a3a627de90946dbb7fa7999510342c812468b2808ea61969acc901bee00f43d8005eda5ee89b92f184129fc97c06fbd1e4d34404aeec7020ea705f85cef9483203dbe03dc6bd1efcfe274bd12086b9a5ced4cd00032b9f2fd6bd9910562ddb4a1416b0f70f8e6845d38377ad633656aa08dc1ad033f9da482bfb1b2ab7cf5789e010cf13936285678ec6aaed0a54e98f792409c63e83673f4c4e111520a3ee2578316216f6627296d14e1246f76718b7079b07d6952a233fa08aba8ee9b58d48076ed9d9d0ceb982aef269e2d72765b7d4c1e00557d128eb8828228daec880e03b39d30a24198939d8413361ae61da4b1e618eb0048e983bb3d349366e394f60cd19bc32d133bf05da3257c4bb74e9954bb22e05c25bb8cb34de7f2a7bea0fd0ec891ffc710522558aa565e9f678fbd7366b15231c3d204d6be3efe6b62a4c7ca6515f1a4280b83cb2429b8d9bbcf0c4eee58fc3209cc2d7847b321d3b49c5adc3f6c8690a1197fae44d7681942426d0af049e10a60eea6f861a401696e46997e7bafee1446389aa26be24106672af0e0b4fdbc75850d56343a2e2a022036cb3a639b3343b073fd706aa0e6b04f19f0b6ab1e6f45a90e3d89ba0a31fca1385879e0ecabfc4c6f8bcf2369c4cd0cc141272079eb8fd17a51d1e4e47590454f4237e2ecf6f89a1dc49b4c9747f1b5b014c1a05a83389070f06b827c0b255f19f6067143d0f8171e402ffbc6942268ee9f91217012aa77eb8fab5cd6be13cfa7b84b8322d85a7c19af5dab8916b9b0012798e3e9684ea7ff3c81ba4e2ca6373b2f71d51c0b59f3e94566ff195653ef0d70cc4d3e91bc59e68a38dcef186ef1991a0a7b88d788fb871c92c570043e0633ec2b261c46b109cdbbe1c6f3f1f69a7a417244a70c03a9cbb5bee0142d42c0992f6cffcb059425075ec2e743d5e71c4fe74ad1a3c6c815ca8954d9d244087384b0b6edd3ffd6e65ea961a3bdfdd605f46d2f41aa6cfda3cf0d0a753e7a6242699582f2be341b7d3595b7fa085afcb6bc0d58e3d0fc168d692a15cbb56c19d033c199aaf74d6d2d851f9404e96f5f93042775c2779196bf664edcbcb811f880e815d59141767d40d284304621c76bd0556b38aae98c2763318078866399a430e7543bb7ea9e1abaf4570249b2fad07d960e8c9eba3434a96803ece102aec74a95d145cfb25dbd524d03371549e81214af371a2dc1d7966ebc1c246155733a774427aea5feac01a69ac4b1808c80a94fd9bbc066e95c7da55b4741b1fb36b1b6469d240c328a62f4b300094995eeee1cecfba759a62a6baa4b47172c5296d574ca8b4bf4aa41a47734264e19145f6151f7a30f7706af245073ec657fd1ba7abed8024a341b489886f5c882666fa2153943758cdf10c137dae1ae4bb33144bb35f54d976cb36b9cf4491410dd6f8b128108d024cf663c90c47ae145f4acf8f12e479b63748c587e54b644117339db9a61909c9a49c19ccdbedaebbd8d00cbbcb8ce537867950b7fe4838241779097cb34920ea62c9bfc871a9dbaf0d691a916c1d9d8d1e35b5f32b5db1f1be69d1c48c1923a9a32b77c8392cc2faa42177ecf0b4069dfef33b567eb42d0acc027be536ec9ce3b4379c8c10fc1ac10eb9b53c4fadb4cd44cecbe2500ca395e3401130ab27758368ee704a079a0844790af6c0cedab1843161e74cbfb425e7b8d8232570d6ca353d55af59a29b0372141affe04924a1db66d89236fabaf992940cb84cd9182da953ae66f5f04ab2d554b6ae6943ec0829ecd326d2291fff7113647f30ff93573000e1d9c4b1ec1b745818d24883b529f907a3d0263e6d973a9b0f4c2b92093cb33eadb97ed5d63c709ac25142150e10aa7fc9a05917b9dd26a9bdf6a0d92ea96e8700848666c910a66d3b30cbc365da57389b81505f2140578c0613994280dde23e16b30ed8fa2ace0930d0a5c26c80d4442351aa2f17f960f73c8e2c3f8102c2a56c75abdf76817254b08b0604cfbff0ae06824a8515f6f9a0bb5b186f52ff1592a141a4ef92e87fb45ff732956575200c1d40fae6d0b2ecacb84af11320c60438c31de6ecba913e45303c3ee036a908740801c006cfa74f850faa2798eb5825170a88f26961b02df45affe1b3b7195e5243dc69018cbc121d50ca2221d53b00ab1670777ee9d8e628325fb0b568a012a17a0239dce4a49ccb3182fa9a7fe8dc4710b44ff825f6b2569fb2f8969fefab05a4459666343f81b29cc82faddbb25f9e12e0b09163c789019e25220e900c8e296e9883b10efa33082e8b993e178f0c00f525d766fd8b6d9b98ad834c686cd685466b5c5212335b1d2b871ebc6e95f344a53b7032c112e62cd1fbcedd2bd32dce8e36eceb2b0b4893bbbe88ab40891cdeb32815661d5365069d5c7e667637d69655a44a5921ce137ccbdc397c3c2b364ade29ced361640971d8c0888c40f60e10e3750ae1c0a1cb663840bb50e9519fe0c71ee4809fbc31e53ea41ade8ac422659b8c92c7680242316cdb351370df4a52fc1a16b4e2c74bff159a9912187520959fe11557a92673b3c52aec00627195b39021e58d2be57c2ac852d6e2ff18fc229fdc76796516a0e9b5f356af41ce7a1e18b607913332eea49a8a86af19ffd714e6a5f998240da4ce17cd38d9e0158b114673c48a137cc5014170361f27b789b6f761e788d4355b2c10d82643c70c8fda510fbc545e900da156cca1c72f0304944b77a03b15037813d8e8d358e3ea4b72cdc5542f25b0d1d959aa007ccb767f4119c685a6f5f5445cf6569866a04f247580ffee636bc14480d745dc76cdff64ff1199175bcb000c2d6892233671462b5d81df4cfd52a884bb4acb4f87ed59be85f700b363f819b733add5d31d7209ada71bc71937ce4b3aee492cb06a83edb4dd25edf32bd415d188e21f9e21b2a82f9375cfb375b816405d2684c662cef238637bba357c0ec2cd3dba5076b337fc9fc46d4abd2816ea740d29ce1815a3f2a8d72c4647044edbcd79db27f8f4a7bec199f4b91c961b53b56651adf8d1c703c499fc465992e9ae8cb9c80d53f4a34179130063399ca2ccf22a4efa2d2e411c7c00413299497ccaff0f82ff69acc63a1a32096fcc91a2856663068f0ae05391a0efd240cb2a3213ddcbf352f92dd816a7652040e6d254a798797b431f9d85ea7c5e7df3a78eeffc448938323eb6b3cd1ccd41bb74fdcca83e87e7bd496b6702b5b7971bbfcd18703723d5966e70efdab24d83b9be20f7c51322a5a9375b883ff9545105f009cb79aebdf1d4e839298bde7200f6b8a09c7b08c0f795ef9fe935632d8c01465e540dbcbe224b626ec43a5b14d40e80b8b719e8ab3b950c92235635649395c5ade95ed4f653fc82193ba384f4e4d567f7952f3abb4706d186af9b0b56c3e5217aa3c9f53c94e5bb7f5b19689a209d5e078b902fdac56cb6793c171cc5315551666ea43e0feb700a1359ace0c75ac5c8284b71c18d39e9a193694b726a3bf7bd463e2579b266b9d505cd44d5435228c4383d3ddbb88ec6fe236861df7b425bdafb40355c5c270f2a5e344a06cef06fa7780d0d5e5bcd5027d67a49a6a4cd2c1e0f39cfeada1592e24970b18093f00e704d1529a412189575797ce564eae8a8408d85c8a6214ff39533ce073f57bcaf987088e340254f1d83ab78018ec72fe90ba6c8a5feafc1b0dac5b2be1a13dcf9c9f581c9c85a8ad17ba23648fb55a6c6154af6ccfebf9c3e3bd2d9ccc94c4c178fc406777e26bc939a5947e6082574e78f82c8666e951f309012b1bcaa260d2f7a275b4b6d47c541b540c7599675fd0a6588bfbc827ba5f48e376e5a1136d534397528578b44d52bcde5b54b359727bbdaebfb8d3feccdfb4cb6f526cdd052d4ad2ff5e5e94a13c6f426c621b97e410908357061ea06f55e254b1188f1201b37e3535c8ff27d3f5a50fe5bdb521b345e7ccc2cfd5698c224f1e4789e7e3ec2ae0786c6ec5beba81d6f8db9b0e48c8756aec4a29f54c1f1ce0f003de23134ea0145671ed7abc44247d8f4631c76c822d120228829cd38654ebdfcf8b233d8f7b541f53d1165a4dfa0848f3b852976d69751266bd2c064713a85198335acf8a9e62fe840d6060dd3509f6ea48db0712677c006e20d6c9169937132250f23ca4555539c71bfd7220efa5bc61ce4abd98e543149dff4e80f05478f4f026aa5495bf770cf40be58ab5b2018079d7183536bdbf2dc8d0c6445859752d70f8d53c393e98b779206902dd504e4bffc4c54035715620c17314c1b457e69ac66a0a520049a583ad45984757141ec99c3f6bd33bb89ac633160f2b8afcfe900cce131326402b75c0c9c096bb635d0930c6588a949884c3e525790ddc574ee95d4267612611b0b0f8d9976da098f3d7e8cb20748bea03cb143eb5772132220ed309b21bc387972545aff5bb886fa24ddb03b7746244ac69c21f33b2a636728320d7c76d31d97ece4c0eda7eb940c1773896ff0876745f6ac6d8a9594e4596a31b88820c5d28805f317c6399583f60fa9d4f8f040c9ffc2abb1ada019293a7f6fcf5e920d1571a0926842c7296b5e7f559dbfdb69def29c1f8ef896062712511627231fcae4973858df387b6aab2a1784666be4cd8c24107f1ca5f8c2e7788cdb630db38c75c184c96f66e2adfc2e610e6d05f1357525e015d51250a6e89345b4590ffe6738ece379ffb49ac26b21b03b0fd26b2ba0991409ea66c1425a8389015c761c23c8c708e7ae6ce9ef62b811395a2f9af82160826b9b11073a3807c00bfff8dab164d9114f79753fec56488bd6eea742974c11d59e11159670d2e55a00af9bd22d84fddb08ad74f018edd1f14c302e61670855a81d0d945b0b7a036c7ab96c50a2175e98942ef5570cfeb3dc7929359be4b2bd7d9053c6afaf5e0d7cd9bf5d3110bd2d4c40128948a5f7860fd9b049f8b1f59c39a4ba0c8ee713aa342523b032b57df6e1a1b7f5c6047a2bbf5f9507800fa05d7ffeb17832ab9c8a464b5c2c72a366f0a90c2b964e709b2dd6908a40dbaa2d73ef49f72ca7a19325174e934b7af7a3c472f0a9f7a302eb6c00630cd9c57da8053bed9dc08308a38c6e6a4a511ebc3ac3c16284823f42281eb94a50272f9a05beb64839de80a69cc8a1892eef7f40f969a547dbbfb53b131e9e9fad535e94b462f8607ac8d9fe79e94eb36ce20dcaa26561694a67bcfb596ac34f874d92e8d9e29bd4b6d6269c9d1b4d9b56622fcc6787eaf82bd4213c7b8aba9b6fdf71edf3d5d03bee2e25c257fbc325f4088a3ca3feeaa74abbbd18ceac1a310ab32faa5786d35a76e4523d1cc83a80f19ba8e43acec09e22f0670912d0c2423889a1c1116a3c06c88af6ce8f0248b10a2d8f7ba953a8d53b7a3ab5270806f33837771ff8b022ceaa02e03ea8d07d30b08c87898c1a3c36698ef444c50754f502adea8bebd36a7e2b40508101cb769699365a25e505869e23d036907e657374ccc281e86db799bd69f4408693d081f1f0f34baead65e6825a1517bc41eb2b9048ce032e090c398689f22a91c7da1e964e2f0d58c8caaab4d672291b7ac7c2c58301ec426b2a24a7aeff221851b8c04b09748b066d58b1d4ebb6c61fc6528a4ea5dadaf16e71476a315f8b4fcdce02154fe66fbc19642498815d2d5db38cdc82a32a8aaa62504ece64ac39559d0c4d078ddb83d3c69e055d26bb4c1179da65606ca12568b0dc017c0b6c499ff30d4e5f9750d0091bb44d6baca7b0ef58bd1cff6cde8bb4e6f60c19359bcd96189ef616f7845267441c48168fed99ad9c58d1a875b98f84ab0d3f1e9de7ec8bfe87649d39723b07da8d6c3bbd131634d6e9a16fabf1f0253c9e98bb76bce57d4c6050e26e48c1262e82f65c45bf5253e4b42c077ff5d454021e9b4aab93c2a4bb8f21cd6e2ef0ae79e33a83998efbb21cb911b509f349dd1a9ec636034a14060b6385a717eff41f3c855756e0f781bcae3685779a684f6bcff4fd75192a0d82fc353d4a24ee0cab7f359fa80a8ba9fb0c60a6f1afb258e2e055619e91fa51e9aa0dbcc7fa7bc7e07473764dbd215b13f0aafe3c899b0ff38ef1d953779c968d12eaff616335b7b0cf434e4d9c9fa0652b2e917726b05ac60aa359d0d3ef479bb96b0e84df2a5521c34435827fc0bd295d71846c36e011da22207c89a8bf045892e94ed77723c7dc6dad4a64197fd64df34b6a3e9129d3b1408ff1eb4cfafc0354c081b6b6084e05bdda5a0ddfc55cd7aab68ba56a76fbe4827f414627866607466798afd95f2c2bf88dde38313be4355c8aef13234a99e6703c0e78ff73fdb59718c13fa8bc17c84bbeed1a3a284ad28826a1617ebf1be3ebe8d1f871884caf3e22840ad2cf136a68a26e80fc44ddee29cd10798bfd8c578533b075e68fa3209988c2b7f44f2cada85668053025f43f5c943c83fbeebb49bf98de0d6bc1bcad1bdfed50ef2e81e1e01cfd8bc97a53404322b73b3559d1ef29d076362d1be168de7f61a788e622093abb2f44c8ac0ad0e112f53185ef35332ca95abf154e7effb05ece7f6077199eeecb782ea4896e28a4a4025dbce073c8219ec2d78371d88a6b003d1c1c4ba64ae2390b5f3ee9bb31a2afac85aafb4399af1fe0b0f9de2ffead893d50d91e140f42a5ca936de3f441f0ec347ac76cb4409fe82bb8f42fc315b7b34a9ac744615d7ccffe71df1874214d5dd5f6a8b73c7ff00a1c1a66444ebab7009ffd39cdf5c6c97c1f7f1557cb10cafa93c0d8f996130da1738e3bf4548cb37d5431336b390de523d8950530c2a5df983e700c23ddf7cfbd2f7d2909eb5c71fc0e0058b56e43986124d9ee48e573d3a1a7f44e1db86fa0b180fe73d3baabdc9e2764a408c36939cc685e29232c90fc2c0f6dbca9537863cb88374508edc27f5dac5594b26186de5e8d3ddc46b61ca2826c1e3d0a3687f0b2ca2bb2c5a54a9adb1b46a4da03f0c9fe8b3410b07ca4f9cee8790bc6d6f67f2143a7af612944cd675170f2ad975fc422eab43bf4c283e01f7a28578063fed8dbb1b5a59dab4e6c61d1d73bfb86b8261314f151e87c0645da2df633106a6bf83d78538002d569e65f9672cc293ca90266b1eede724bdcf54124d000fcdb085e61cbb77dc9c17b0a3ca929b8ab43c5345ffb437bfd4e82a7acde00e4bebec43adbc895d454f1c97b7e5a0fca5d77cbd418b710a3a0ad1cbcf7da2b4ac3d206677076bbbda01e953e1c5219ad2ecdbd7da9a6042e457a711fd687ddbefe1dd89de58a8f435a199119c43e1461eb78cadefedb1df39386d4e884ff4671a22593be0659e1dcbae9cc1dcd7bab760f69eb05cc844ddf9dd921a74e13b611badf73c88688409d544e9a90890fec2d1bdd50c67931369a0e447e45116625addf98f4cd37a09041162b21b4caeef0e0dd764f70a67fec9ac294acfa5861596f786f06e5b94cab877d553c7a183d569b8b2c6d781bd7d67d0b6135379a66618365f781aa0201a19f352b55cb18173f4b2ce152acbde9adede15294b4d809dc61d85a1fc5a8d0024bca1c0f5011f8735567923f004596da2e5eca2d10bb9ac6a126c12f90264428f98ea2a1a33666d8818ef26c7caa9d2264e71f2d316f631b08ef5d6a27e4196fb93be669a094cc997555291e70a1be8e71b59f353e2bc5e6aeb91dee3006d513c374e183da68f8250aff009f5f674d7a105bc5d128a24d91fd05773e1ada8face1a296b3b5630f6591d50d757113c7683485876448c9d8290b64c25e7b209eca767971a47a62dc8105fba55825e20fa68c63dbabf0ab2c0099b3854acb3bdef7ebc1d85d9f830a59513fca910d6f5e8e7317bcd7b021dbab7bbead4b68f69b358109c7f73e8518bc18ebd0bf671d42c4f043244f664c0a4aba954b627454ab0232959c4e9ca9846ace9df72cc1154cf6a9869b52ecaed251a4021aa547e36cbd7884d92c5e2f30b7f104e7c0d015ded5c50d14b300f269b56723ba76d6073ec4cc19444cf4795367629804a2f017473a02cfe272d1466ff839eed22852ef3168cdc34f6ce274bfd06cf2b175e47630c8e7720720661fb3ac09cefc3dbbc012dc1f2a025c9489dab26032161f8d23d06af6c569dada81475da9e4c25ed6b3341ba1bbe3e372e07439c13e0cd76860114443b106e570cdc1bb8edcb36034721085c24904721d6fe8a707857ef19fc1e17a3660eb4e0f499556696a982868fe8409297f3aa50e11af391c9f4ec18b88ea2676c604c0589d047bed87eae96994c787076f99997e22eb93f9462bf9b54aee90448771a65a1e35f7a7e9ba739a5b68ba6bc490e5183eee2fe16a008baaf3f3e935e7ec6dac4fa855ee32f51af8ed57b3d673ad9a391180b778824a9767729a5f11c5629d201be9ce858d81d461eadbf08db51b3e7c9c02d050d93ddb977193529175a3adb6ccbb6ad0672f4c8548eb5a228dbd08ecdf6b894f8ab8b479243f28500d133b1b341abbcfe54aaad1b55b7203fdfb13df47d176553d8c305fc45b644203e48c1cbb8ed01a24a51bdec72fb152d785806afc55724b4d8672c89ef1cc1035640929f766e1c6811b28d0476499df3a686f920be8ca3ad3f6c6f3b42b6445db51353bd70670b6f34798d40d16bff51cef51eeaab6307570715db37583900421330540e4e6cea60366047aa8505052dd110c50e42ddbea27e37e055ef8443352c6e32ead83245452c2c3be2a1c800c91fc0dac97842becbff2e44f3e16ac035559d89a1607662d15010d725bc825329fea269d02b92612509f709892d87b93170366b16045d5f4173e6b87a54d1f168d7efce724a5fa3b9287b9b79ce47714834940bdd9deba3aea3a9136ef7b4a957bb71e2abf4d80ddb2938a8b60e010989e8f8dd2d6e21b74cf8c52cf9489c09e1a6280277107782b5b3c3f04201286ca3de1d7399e154dcd28392847a1cbdf7dff3627440cd1607b8d588a468c599a6b78cb3600644ddb4d8103424630c4c4669f6724f3e23886094504a8b032d6fb5b526749c163d7cc8cc9adbb8e6d971930362513efcc5570aaa0819074c35d6643107b337ecc6732da9fa0e308708692e36e45d3def4ffe4e53ab17e0ceaa83efc6f2d23316ebbd764d54ee4fe42dedc0c76e32c9cb6fed3cdc7c8143ebf7917f29f5af6e8e8d75d65393c4069422387404f75ddae65eace0b4201b9253e0cfb8bc612a211f154980440f11b73af4f58018a0f70dc9de9368adb97d1acba2ec3c5040ebc89273cf9ced71792078baf2a1bafc0c1d4e8e5dc1206fa112860e118820d19915d354f25c96401fe77f2881b7be08134995d91d4d35ab71b49d19e08d632065c01b48ae37a89b8f7dedc9284c1a365a25bfc6aca586787bce567112366bd63333407a02c4972fde7849a1aca667b7ff1a6f4fda91a09a672bc01edebf463ddff936bb9549a8af95262b9d99f6559db5d97ca0a5cd1ced89001a3a77f038967b002c62cd6ccca65acee44a8e12f37111f38876c5c332d65595f6fe5864dbc200a05d136f771708b259dabfafd9d14564c54b2e34b4043597a0bf3758d261519688a57fa639281c540394abcea61007a65fbef7bcf1144c14b41b2acdbb591ca5b53244cc7c963924f7a301d5fc71eb23b8181c896db6a4aa20fef5fa6945f14fb494b036226423d474d1264c72875d3314381f2b54cae77c446640cb4f3490fd087294a3bdd0202af8a514ba9fec8e5ca4665b930dc5daf5c7f5038d523bd78789af50688995b71f3bb344eeed0a5ed2a7c769cc0ca98343bd8a37f0d665e02f27cac7f937160fbc6c43ad12b1f9bef4427b693642ae2b0b2542d14cff65419612bbb245d3e20f8791a622fcbbfd314f77f70b52b9cd6e8f864b43c140bf2b08be087be12f97eb1302d28905f9edf3ee0d760dc890dcecb254e8521dbf4a6b564384b616e9abb5fdf7d7cf17e616dd4d2e16ec9b1e422e9bb401af3827fc913e3d967ccaca5024eaa6f68f9a0303cc9f41e8ef601438b58843fd80e01b779a790bc7b8478bccf0ef5e8580c803badc2d249cb6d4ea2db0642d23eadcc920011be4ea2bfe9dde37270dd38d0adef679c94414a07a2d451b3945a6d234846d23cfba7f9cd6ce4ac6bb13849b63dc13e3757cdf365ddf19f1322275070ad6af895e3809cd5654a6367f35d699c821887f086f1ca56349c6ee5688452c50ed6f3ed5839d4606f362a8816ee533beb5f3be186df42e99152c1132b91519a699a14f6581dacf815fa26dd7e8585e7a6607541d22abc2b12adc6fdc49ba14272a0645af559392c707613b7cb833ff8780ca8d642c917368ec237a336657e2772798331e99ddc9b053ac75faef16ae0fa6bfc451203a1cd6255e6e2fc946b1ac857cf0712a5e089632e174d6bd6d640173d1c515ffea15bace95cfc84031ae11d05bea0013a70eb5cdf736d4456c4182f31461edf7cf1cae4d177e0441aab93c08d17e765ed94877aac18f35e20e17d5b949977b3079da309ffcfd588681e4a5ce0ec3738e858cf234e730b63a1cfca62fa01bd22719889c209d3ca5f39631eb52e7ebb59b6b532348e071a313de95f6096ec41205ab69cf19157aeead5ebbc9d9096664a3d61ec83b4d2c2a79b12aedc5964169870c2758d1a09e08e5aa65b657181582424bb9dd97dc01e8d961900cd7e38cce4f519ba34d4288451d78fca65282051c309bdfe6c0774564c13da137f4fce9ee7cff4a549a7bf6e8b45d65cd929d35822d61a04b16493a5f64fd97fe5849fee13de6d8c13174c61c7dc17a110c401c90314e8e4fc83f2b3d89b9bb810303e4eccd24cb628468e18ec1046920354a6cd8292cfdc42d1d0d40bb9b2528bce2547cdd5cf9f93361c3e9c77326809eb3dca54bcc31902fd1476309524f187a832fcdb8f9c808edf1c8d843d0593fefc352ede8a8812bb219f2cdff128c486466e4a7dcd16a6dbf1a032e14560afc056403baeba4ade999a5d739349fa6687e830469b714d246405b0b0fc11431942efc0d5658a26b43013dfd9c5d7a3578fdd2973321033e859bbcc61daffbc819d4ad32ff954723a14d77b4e9ce163eb97ad806d40c4438d44d556ed60e9a45d407e84c7ade70818f561241b4884d5c5ca10a0c325e6d939212f7524a802e0aeef6446dd6b83e0e8eefd0eeb631f8341271cb931d61704638ce25d313fabf42ac4e889e2dfb0e38394c96bfadd30ff5e6cabc5ae4baa27f56972a1e7fe99000bd992de4f398d85e4e3c772fb1ddee3293b51774411b9a234e0c1e287f717e56335f19e85e4b9b2cccae8e280f94c5943b09a00a8fa3d752c1d1b0ed98c68610bcb430bb929103f18f3881a5bc96328e031bb6c4c94c5a1c19994a885b0dd0ca05e4f0bf47197ff509f3915aa08b8ed67e1f98beecc9cec4a21e340330e3c9f4dc99fd812cf5bfbf2e4904bd92f84d6665f9ede90ae530a57010835d7a90dfb687e83ad8dab87cdac7bb38fde2f734cfc95e0ae785f6a01e225eef689bfa9a248ea8796ffe5b12ec26987298bb658f76a21d7e387d4e8bd5553351021c52e9354ee31ce5d0824f3e9dbeff06cd2ba25570f00f07323c112541592ddadfd708460a38efc04566908073a3ba7771b718d6ed1bb2115486297b3adb7351bc380e93a44862d50624bab0822381da33403b1200d0cab010bd436fd994c8ab3feaa75f3415af61cb5abf485a2c6e91822ae2e76c34e87ed91104eed423cbce7d12eb1b6e6bb72a92c6d99330e58cc2977db78b572bcc9ea8de2da3711dad282706def266a7661589d0afbb5683c8bed8a4501210c4b196ad32bd04184ec31eca2cf2e06c689547b9155f737990d22f240e6766fc3797ace0dd5ce73ff3a5fb96467470e9754c7a121e8022a25ec3daafe0e24bae35544273e5fff2fd8bbd3901924648fd1073e37ac16e3634fdcf2921fdba81477cb8e1458f945f4cacd601a14e6b46bce483e5584db663fec9f7f7159ef8edc0b0727f73564b1e5eccb9a4525b9fcd30710d55c03c2e58b6c238ecab8eb7e60bfb78d0ffdc24a3f15851a3b15cefecd2b0a3711c33864cec567dee1130805029492206e933dd08136b28cf70cc225dda4ff9ac88d08a6ad579bc7c0715c78ff7f12e182b838e5fd2a64e14d24ffb1888c4a79931042821a96ddeb6fc1303d83d20697ea89fa8a9a3ec9176128c0b1d101857e47c9cc411be79d07737fc91fb6b30bdcfb5d91f7af78ff67d0ef9621399675aea108ac2a5ac7a91736d658dd98da10e008a8ea0718fb2d03d26d8bb3dcc47707b3bb1acee6f5bf8ab94e2ebc9b48cd70026665c80a5a37bee5572edcc08bd7cf58f4b9b5f574443e9b861c076fd87b9b0387d973c182cc29adb1245cfc2fe896122a9fedea8b935d56011b78c203868d2f12077a070d8a28f157329c93086086aa5ef7875b831e39e60412fc0b2c91c09416438d2dbdd8b57bbac48645d9f71b5f9c4f4236a9e448eca86eb7f83c1779527fa9d2a0d0ccf83d5d4439bfdf1885d31a08cb88b8edb6c89a3756c47f1453e45235b43f04c7ebc83540983ae1dc89c850a7fe807a30a048c95c8707e4ac2ad2c4f300658275e36f58a1a632d0f2dfc38986d47deaa360fc741a605a762e390e20a191726adda810fc385f2a4fd1e9e86ecd63388ddcdf682d59098eb417aca3ea2cb40a175ecb2cbc8abf445e6aebd5816ebc604200f89b932b1c3b4f55b886d78f28cf31789d84631337db1d4fc07d12f130323c4d667e21dfd60865ac472ea217332d59ca21e2f5f2357ec673b6354a3af87782213e1e569b4bc64dfa222b1bd9c27cb018776453e864a51396c252ecd51e6121e7f3ded3fc888c5f71bb68fc5c97560521a8cec3f1598577d5744c7482fe29b614109c407c2074f85352151100a44de3d4e312c46f0a2ba11dbe60335f6a34cddc427959b650ecd3691ab41948d4516b51db0037d42246acfb7bd8702a4b0ba417429ff475caead6c3d2152800e085d829e68d1952de9b9d1af9f6b22f45a43d185496eb9f9613770b04c44e33920b408edb8c78aff52acab9f4809f9259fe1a078047f20afd5c46324d6402bc34faf7da868d1027897feaf68a91cb3380108c298f75a41f039b0a52e32c8fdcbeeb8e6ec281b0c0911639c10a7bc90680213ddc3b6af42ea43fa0b58701344fe2ee2f96b2bcdff97b4725d786ced5036872ff909de17eb3b0d29e3ec82bfef0a1dc1143f412b5a95f4945306324b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
