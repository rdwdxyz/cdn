<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"88f64ae5b0c37922360de06b291b44fd72dc7041976f9d24c2c15b2f3440b61df61814e0bd89628f71615785b284fdf1ce9dde3264209ec9560e09020773f295a67ef5a9e1213b1ad7625d26b6450dcf2ccfef99d6006bd01675f9b4eb414a4dcc8e4b6a2ac31b82fc4b1f1dd1aecb3f8161f3a4ee291b8a731b2b6c730fb799af4047090dee0fbe8363264e35d9bddb683c528b550750d51c2a577da18dcff5879f937f9eed3172e4726025ac6a1acd2022b1d61f988fa7683ca3a4f770e8e5cf987a6b9ae2d6e4d5d8a175063352523aa4a0c0db37f6c3ac399c3549f656ec05684cc0b08f56897f190a8bdf6ad9dd7201c959994d84dc8f4b41b5470a5011f75d075621bb3f3e1e74a0ecf889ad6e67325f9461ee32c871e56dbcb758163abab41acdea17f75b8f01101dc2e6cdd081d0198a0765eab63ebc69c059dec455a27b857a593ba732f26133625bcbb5aa19f42ca86fad8c417dd7959f0d3e7c62a8a885b9e3d1367b3f15d96c121cca9d0a37951bbb786434e369ca0d9f559b695cc6e5948f885b138b06e1d3041ad9aeb2def6291bb15e9e1769f54bf86c9841cd4247625ea2c7f507339f9594e38d89f8828dacbca3c379c453cac2aa63fc441dc3617980c5a1244eb6b50c85b4de1401fc866c40e2ba2aef1b953ffe0bab3dfb2c936c44cae07440bd64d3450c0450f257a349c9aabf472b18cc3a55ceebc314deb262280d07e686d921381c60395818eb21e622259275d635f394e5fc40f8d3e034597cc9fa13002c81c4d2ae2eac419f8e81c03fcf950b8a16e4816eec890eba502d72736ff2818da8b6c6b222aadce4c6da3209ef5495e3d352dddb8fbae83d8c457bf524a2efa55db9fe369a531de91687bf41e858b20a4ebf751da79ebc3e40bf79e8894b90a964a6119f8cb2ace2fec6c54b06e041974bc61ee4904e4940767c8e30af916b73507440f525089097d65b1518f823dba6312d42bea57f0c1b3fb639b041976d1ee0ead15559a004889b483b12c132e930d6aab31bd2b2c5a8bdedaa62d2453144270edfd6a0927bbd47fd4760df7eb0fd944246d605e15c30a704ed950320878a39636eddd87f6dc64c3dd6c128d50657c136decd8b036e1a08b64ce435af173dcc96cef412a86f3852c835e16b8b70832abebe5d46b99fea9d523fb27a2a0ba2ab5ec0012a3d47d08922a994392ed25104b5095730affcdf4c00a25644859b9936d6265fa14ecc22b35df546ba931484c52296cff178b4e035858455d423d85b7d7ebb05a9e3beaa762de8b50605f2fb3f8ea64cd676a532c95bad1b08f07f2e806b0d8e2aa812758663d1a65c7d64e807e40e83022228fb61c34eca863b4b761aa04165251a7c09d934882f16b95ab0d0f9a160f00dbe0ac590b945236113f7135d3801ed605879d734a5b3e75fc9e2ce80ee14a93b426dfe6f422f69f7cdba71e7998b8a42f89e8663f651598117a9fae4603b782fbdbdb83f6255e9c2627f7f57777d751e3feb1c035500f33a8f4ede7e10740e7d1cc9c077fd4783a04cc4d7b3f4c9c5a94189d2c92becc59f113ad1a59d58ea41976cde8c6ad35d472c4cea2651949ecae2563393857c7ca09cc359d0fa70b99fc8f72d9141b872e3d1f7ae7e1e571449451071de8119b273edc3a3cf4f638e7c9a0debbb0e49572590c072203d1477f68567b7844dc063766fd1e1b18197d65374a65bf54483d7692918d05e81c1fe1f8cf1b22ef9246399891feef3dcf95a81619d712de9fde493f3362fe10de6dbb4a88c222f9db2026e0140b9f1e820596985b2608fa60b45cedb5b5f2fe9f6bcb0ae289d1e1a5bd4232a99c481a712e1345323825b432aea33a87fb29243a95450248afa34fabe6ddd5b76ac1d672f0466e2f34dcf2eb29263a47e5ba4c1cd0587f931c0cf4afe87dc3076a87549954f1f2a611829a5eb29e4deefba76305f96be8cbef2f6a029b51bf7c28ccd57443802c700cc6276f1da18cf713913ce29fa59ca114057b50f2396fac4cb3cb0a619b11cbf4f80154d8b0399c911502dbc48b3e4d8ade7bbfbff343ebdabcda44368285310c50ddd532c86b68218a241d17d69ed6bf5bd9fabcaacdbc2b87d70ac155a74b8375b0da4fc4570f8f1990a10fd488b16bfbe48c3e3e24a2e611aa22f555199ec634bf68eef08a3e9f44eece1b32ca62c6b77483ab79da5d9a24f5504eec1eaff3dfeba063464ac5b4df1635c01a0fd2c3c68d42655c379247909f1061d6ee8081b6790529c53455d8346eeb5c1b07236208952199a83b469092a4559640c73475d1f9a764b3fb71739134c33c33a2550c77443695234c2bd4bc67ef721cc83a66ddbb952bbc7ad8bc565ece1ac17f02e2641342651db0d3db65722dc3fedad4230c7cf9727eb9294f25cef9d84a491dfd5eca567f9a9365056d091b48b67ed04889ce792c85cbe24889586882e2393981200ad1f570b07416216ca1204d3b1dd87a21236819b8247c123130d6dba4e1d30292d1617dd805cceb86e3635f72419edde352c19e8e61f6fdf779e8a21dedaf49fe2542e4770aa5e0b2ed5982ecddb6be66b1ba8ad94328971fb6ef4b20997e9fe9569f806bd57d89354c4545d45e58c62c83c587faee4f7c4039a8d053f5315238a5fcee0b8871402299c3a3ff4b47c37fdb631a5a1c8c8e730527b52351e73ecd4f756da73a7249e82a7271995101ccb03d601def5505d99a3986eb2e205829f5e46ba62d7b5c1e718b7c58da918ea263082667f1e27705a8ae7e7bb45d8ae0c336061858b81cc5e80f8b07e92fae1963b48846bb0394adf005423104a7bba2e919a36222c87eaab17158ef63f4f19216d41461b67fceb75a900a0f7171103b4c9906c94a6f6e7590a1e4cd10a18bdc7f131602c8bbb642e9404729ae477598ba8dca5d068ae487b169efcb1e9a88b4037306344be98c0491a55281d27738e8e12417d655d35fcfc07ca0ef7778614fc672ed8899954622b5a83fe490ad308a2b8155f0c2dbf526fe17b8db7b18cf6c571ebb157645ac8bcf7019ba46d7a7dce63ebbcb2841689dc1038dea088a5e2689a99337f472f20279a2dc1d9f2681754870778ce3d4796c40db93b72e543982fa0fa88d7e68c81259aab72c6482c0c0e21766c084bcfa22870a4bc4d3a3d79771705509cd29aa370034eea7726a1d25950b2e687aee38ec2a5077bb0081d62add2dc1b26cd976d69fa3c794bcd1e219a5bc411d137ddc5592d2691314556d66b57e9716856da79d4d7a2aae2a4b5e960744db8db9576d8ea6f7ca236c4c4edcd998594083306a770b842ca384384f889dcb05f11ab9f86924c8a8ed540fd7d94af1619dcb65f73f2250f336261bc726900546baea92ab90bcb5077e12da0cca99ec10379680ba9e1e00809d6ec19320a778c67e99b3accf40a37352f86e48c1049d85c138a41528bf40fff14416e7c0a2c0e2fcd83d42b1a6396a3b2b76ce814e6f18037e8bbc23bc8bee4fc180c1092b563e31e2d9c57ab351118977c45e0167ab7a656051def6290ccf1125eb3d95551b77021485b5de776922eed90062476a86a9c25fb4cc1bf7ef60189cddafd6d8a9feca22905e2b366af8a5fed0b65307db03e279646c78fdb89de01d4be8f9d35cad6939fac58aabf69571bd5d4da20858acc448ae3db74a2e360c995aa3fbbd386f3615ce8afa7b220ed1b57bb4dffa92b0b2e3b018e3cbbc332b41979700db8e0582e76c74cf3d13c3e9a9960c5e70bbf7eec5dde9127efb982b57a89a36f31c585cb2847d36f36653f0f83bc554daf76c49461fd8f786521a902772ec533c7a4e84f3d2be18fad102f97003f03e7ffa3b4ac8ebec918c01f96cfc28fa88d57c5eba8cb0646eee1ce9519b1fff73325403b6cc77ac16496202bd22c999726db3014ba0a528e353d1d65913eda58c66d26414d09c5e842617c04e1672a866ed0f54bf3e99b5d3defddfc297bbb92b41572c398dc72640395dff5633831151f199c106301a7ca5c0fbc9a534df16bbf1b195c0585a82751e837ccd1af81d302726b68529164fe1114f9c102823263515c95674b6e56edcf4e372b88ed28360009fd4e9df66b3c9d1c79a1bd75408646c30e8b4821321a3d5a576f449a69f3a0d8309d951957b1b2ff0afb067d7d8f90c0d87379d92a41dc8bb8c487f764c987f68b8c69105d84de588f704e2e48ab998ea80074a3a25e404c7701ba22313d7a395d399b844fe162aded04561df136b7a13a14bacc06087825a214b395ec66106c0e9cb4e4e546d34a3e232a71775a3eb2ad8882ee29c80a6b5c75ae521978b1e54314c523f97c2e28c100418839f769552ac271ff60d1b4ca6bd657694504c7f5ba227342fd31d56c4ad23fe4c66588644afda6817a7115128f702f77bbcdd8a4565c5065babb10ffc5add5db0e6205f0767239648b1c6091fc70776b884e8095f32fe523c39186d97aba3c92a88bf57efb4f015b4b6d71407ce4c61663903a036dcaa3f42a097a6d98e2e28953ac81b734dcb64555011734bad9f41dd1e55d30366108f6ddeef31d1cf33e10c9d8bf30009caf93c052f0c26c5d264a3d4103739f088bdbc2ce36a15f2133ac61bdee462b2ffa07d237c084c4923446d4f5e177786d2a9efde31edb931dad61ed769ce0c4f9b0d6617aaacdce22f909adbeef10a3ba0f8fc5cdfd79370752f7562ede33ffc891a916b8d616f5c8a68fe56c96fb9f512c129a68915fa8a0e15d7764ec267ad923b3b57c53c8a44cff69647ba6691f6bca84d4b75f8282cc06b24c8131cd658987604cb0c74c66454ef9ca0a191e3818dbf1cd648fa68322893e237a5de9d91bc4217d2a8cb102208f164640e8d14d06ea67f044a816930efdfd9dc936eaf526139d4812246fd3abfa885246980c61e61693d164900c8c94bcb713c83ef93ea92800951c476c0280f4e39da1e399071041757c348d8ea2015b01aa235fc90dea65d5543fff4febb10a714250348f61ee167dfa35d8c3856e213a3d427c7db5094aac1eb06769c6eb913f3432bc2fcca301ab3fc252ddda4906f885eca13348ffcea5aab3afc1d12a5ae80df886077eabfa1626c3965fab4f1113645b7cb99eb0ce47f90699e0260ac056b1621a566ffa55ae43384649912d564b8dc77ea45dbab75318b0b5f1de4d8f281ec3f76411fce012fec17079a323a8db6539faad35ff29f92fc4ae8715f0049e7413089a6ecb0e70d60f57f3f631533b8d69076570978b784808bafab1853a67d7bec0292a09be43e6505eb7b4c54e97485b7504e62aa4bd768976bc49c659e8b04d99ab28c7e2a11cac095a06a76f9812cecfd591d197e91303e819fb9b32b01fabc04f602efdb7d0d0f30ff8c00ce916afb8c88ef5b2edd9690fa99818ab188174b4f9ce3b4b65a0ecc326df0c3758a72594daf802a0da462e6845c57fa7a3336b4de128704fd0328fcf8a69a8fe653e7029095073f740977d5e16e31d146d989416bf71c62d7d8183d72304ef5b380378b7635d071c3cd672e67e2a830638a037a3cc6c36d47960b26d71bcdfe2501fcbea36678fc07dffd6e279178a77c9ca18c2bc6ee2b521aa9914a70c3fb26882ff97fff31c61e964ca287d337185cd7c85f1f33701175b4bf85d0236990e31efb41268534e67564ec68b965f08a922c4881eb325df4beeaece47ad9db8fb478f68e944c54353056b54d1322fba8bc5ec1cb12952160bafd97b8cc9c20c2275bf4258fa2496a75c66bc77af55e62790f8b738a66b58beb297d1d5e07632953069680db463f014bc88ca82ab511a642689ae7c4703f4a784ef732443753130df825f2b5272fa622037b11a18eada64d561459cbc0184bb70ace1811801c8abfa9db3db7d9a12829ec6539170d08d32a812ef738c7f96339b197e70953a3ec64231b95c7ed1cb221cd211536c2989650c2b570ce17549f97ebbbb622e267bdd1c50d877df4d6771536df991ce7efb9adc2c3b4ce353b387c04d0e10cb6ab16f227bd6f863934d0d2b02076c67485f416838908435220023935ad6dd0297f510afb928f1001d25f32409f5972d1c7610763b9e8eece4260ebcc9f00af468ccc893b2a41694942d6d4ece69e655fee22410bb0241959113602272b0f54012f78f5661ebef6e556ae04818bad5219ce136c188b47e50d4b6f1f4e3de6400cdc782c3d66bddc1d20db81d994ff84fac1f653578ce5999a70833d3d6ebe5baac06379deca2cceb9ec61cb0f616cc64e77a7d16be5f52392db52cfca77451eb5469b0c23ed86a45f1eaab0bf9651761925d7e85371bd6fa504a67326825648e5efbe520d1a86240433b67a9f91b10a7236d5c376aeab3856d2aa005511d871a12c3df0d6ec10bb1c68f3c79f6268ea16808aed03aa479b7bafd959b4f94f7326732c344f5331c0c567348ece1561b201e9c9f4ce925d25d023941fb1139930f87aefd3259d7bf4813d7caf64ef595feb3402200330c5c8b0c4b56bab2f9df61fddcfe5e43736ff581dd81c134cee812c7ffc4604187ea6e7a8cc8a5666c861bd4ea4c059409a1b0a823baf1820b3a2a7e1e6400e95d01f51262abaad29968fbd0a1184fd83470c825209ac3b5478896fe0f3c73296b0619cdcf541f06ac4975708c696668d0d40d33d4b9e7571b5e32fe86e15bd61fd4832c67b74df01461e0625acdab8d260b5e674c5f17a9a4b6d7194adc143eda5bb5de683a1cdfcb490c216909540500552295f5cf7e8d7aa990bd89f2e1157c14ff09aaf98e7c934d02a4ee6e431594a4481251ad851c46960e805adda60220c489928f62f6d8e97b1d67ce94b19f2ca1a5445b5e70508e3251f427f9e7b395a251d562be320daeaa829ae7fe10c469aec59f22785c269ac0c35aade1b92f50092f802fe315884340938607f936be01f1e4416a04629f2ff07bb04756af75455f8e2ddcdfa32d0b7db7001e0710931174386537c3684b6d37d6b7cdd17d9e5dc2b29ea6351aa8dcdde4f30c99f0608a68e283c19943595fb14e8dd3f9520d621f2d232a88d6e035b105f9b2ef5e8d13559451b0d863ab382309f0a6797b7a45d537e2fe660bc18c355dcbdb724cd3557e227e96ac77cc3e4eeade98362ff0b0dc19f75ea318baee0110d3a5f7eb6d27d5590d500754b237d874b5add602f56494afec31b441425095f77d1d6b4f963b1e8178bcd20b2c2be3719d04d0206d4f9bc78384fdc49285dac481ced1d9d9880de370bd38c5e08e23ab84966da6d3dbb690ac76a0ef6f0e5da0d5b437e6e5d59b4d9b0c9ea843796f4c57faa472b42dc2bb84cb4e4b74ff53a387460374095b12a5c498b54bad81adf3fca8bf6b2c5504a63689bbf503d889179cb569034da5f8691d0f4fdaaa9427070b6ff6abf57e122ea4b2e330658d33a493d887fc839aba387aab6f7edad5a2d6a7810c7a1c54304a57b9501dcc945205d2ad0c3bc5d8982e7257eb0fcf441d630741cf96f5d999bdc097d77a3bb2732551c257521a19cf9a24ee84199516d6d108e7758f54cba8137dbbc511556aab770c70d14a2c397a0530413f2c8af067ada42435912fc9047ae758a2388e3fa8c48dd5c93383a57c34ea0f7a5326cb618240958fd74c8ea8fd5c4cac40a1dc71f5f03f7bb74054ad4a87f69c983e27ac28cbcf373ad5389944370087340679234685fcfd1ed88b8044effd3acfba943627378133a00b248be32d8d6c0d9aec11a2d952006d372139bcdb2ceda731a51c27cd2a165b9b93e6802dff3fc6e776107dce244556a50b1df66b24a4caf7fd32b4d39883055eea88ac30088f1fa93a6ffed0619147601dfbe00f211ae99f91530daf427e61176f0631312b0c1f621a60e2c30e204f51eb231b4d60bcfa3f4836ecaf5e4530593f2c1ab02cbdc36519d0352aa3f00220bb71d4d0ca7e03b1e689b276ceef5386d73d8c1b1320ab1f15fe0f6e64680e868af7c36be898bc1181bc024885e7a1ac2ef483fbc93547a1064b632b6e2f7d1e4a7d07f79021585f7616e6ffa79c0dadb67d4677b362da571d9dec8df1639ca4e9a0004156987f73ed38a9f0a83aa9bf6d67a436dc7f63b6dd85809be22e92f81b8f6a75b9fa38f9a053aafc6e377a8b5007867a4f37d52ae17a8bc15b2da8ea056287954c1c014071834e3f60dfe2afdf95dc10a31494155ff4ec1dca84819c5d3b5436e44ef3ca3fab3832f3a05ad3a6fdc43ff625761d19843917575960016d7b4fab1fad83c08f4534a4d0ee1ffbd7aa5872da7750710038ccb18440b9fc02e0a29dccc22389617d891557f2829eec0630a679d1cf57627b4ecb1a0e3624a67b3b9df8009a132902889a8af9ece22c150ff7ac8bfe5233ea292cacdac49e7c47f8d935b372fa7353a3215d8e05d996e6c2afa720b5359e960994475f39d9b5abd66a1868194a7c3c53986c62ec34d9d461aa2d7c4853cfeaeacf5ead51f332089f8e4757f290ed0e41d7bd4b9493b9adda82f7c53760659e6d18565529f13b9ef907a838593366058917e10d98a468455035fcb86dee6720d75465804c6237977080f9bd015293c285ea09409bfc683f5a30197ed94c5a9686e436529921e35979adb9e8f3519c4a0e85ba110dbca9de3749457ca6326d492d88df40e4f998bcdc99c9c238443ee467c0ead38c329fe5153d608d239c1f185ee006d2678f0750ae4a277a19ab420735004be5770569a062c1a7a32522dcb37fe45ea20eae4c9085ff37abe0fdc297bbc9304a6744bf8f31ff3f0d63413754db474097c415ead61973bf868268bfdc8d16340c8abfcd69628acf01cabcde6437cd41e2d0101d6c5db5b5cb3ff2caf99b23d1698efb1c366f94dd06f1ac8c296d5ba69b93a584459f63831612afbda89915eb6b668f8b77ec10e46752fbd20a76bd6eb4e776262a1fcf7b50064d187745105e282655fc2d39240303e9846ce2fa79370d71940d3d0b79f4f3ee8fcb4a40a497864355a2ed4e908f75656581a5c99b9a6e6cf30fddcd7657784e733d465906085604db4ad22bd498cad2617f828892d93c1adaee786bb226f16a0d2937ea912f16481c39002702204de8e4945368e6fccd4f204f5b8fcba6f540f177fadfb89f6b118acf641ad087617f4fa0aab50ee142747d8cf8b08db62c50b934660cf24c3f148d917cd6045dfe4b17cbb8cafac48daa647d0eeee7e8956e8c2444e821d075273f3e81a0a5bb47a16766b2a4a84ef5c560f3670c492e6cb09c0db816fb86b5df141903c06dc3b416a1677a75fc3afee6a73fff7e24b7865fc8663a2b6cd061c4fc4acb740f1570347da0a8eaa9a3d9b01c77557b0a927bc8927fec9a33a4e04a535018dcd3ca158ba546a47d5b61498cb160c4733ddb254ec86ff351c145f6373f5e2186c5198bd7cb433d1bb6b21151a2d56640e3cf255a720576d804ba6a4d3412ae5e437f01ed368f9004dab2ed2bda21c18ace3b917956a25f22654b461e4ee9cd24524d8fd3b6ec9bd4c9cc94bc57b4facfd690fc75c329f7142a6282ddfd673d604ef4f59388ae6f0c08e0dc892d3bed40fc2397e4aec7a6706efcfd81b6b11d1811a997584d535f8282353d4861de851775d673a8fb40423e94fc52273440f5c4e8245ef754598f3fe06304c93d05b7b361e087f5911524f4be3f38ff71c546e6b89ed9dd22a4028b78d5af20b4e632c600f59143b1537d4ed8fb8efba6375e43a68322130a907005aca90b5406d7f5723921accd289e95000526a17aa6e84fde94ace5f8c82cd4260df12cac283e2023f81b35449eb7f8debdb1d013a9bfcdde444293b2d8b66a8ff7b7e0b494a751cab897269e84f77e5047527192667ada1339e1aad4941856b5fef98039a58d056e16607f0f4811f8289309adbff29ea791726ccbac5d1e5941eb09560b172d3c212bdb011e92a0646b496a722bc212bf662f55cd1b4605076cb6db67efa6caa08fbb6558ace0afe3f629b42b3b838a13eeda13e2db73efb643edc0c29b69d93b27bbdf89d45064748a804c667f783c9578b656f4f9db503bb5a12487d25764b0f842262fd7c3c9c422608ba667b2be197c7b87670e817e69179ca2c0b46b1087c6baf127b95e5729ea1aaa2b8ffa3a9e0c85028ce2ee28bba9a4f6d0ec34c87509b989a3b7605f0b7755b295e7bb46dd2a7074c0e410ae44c18b6542cc1c3a0a814612f8700d06d2f5959ea4829286a16bd2e4eaec26ad78aa989b6d575de3993873c17c2bf890595d977ec958c213cfca594a220c0bc66e006a93e555e881e9e645a89ad21ddd8a36a30abb94e05aa615bd2cee1a3aa316e5d34d08dddb1c36a022bb4da70a6a3af41ed30408a152e01dc9385cfd4b830523759cd6a61f93c1fe15d17f7499dbfedb6d99d9bfe4554ab25a6a121b404baf9d16d0f2d4c0045fcaf6b986eb1dc44984caa68f521d7d7427b03640238528b266a62c39327705e1604f3333189d5d183d33980fceb35ecc759fa130377d9efd8f795adff0439d2fd40c994af6214f550a28581e6d06e7975613a0dd64167c23fa71312045164c22d71c9c0251d089126b2f3572425bf4c794ba737c867d38dccff905ef2724cf7cd3e60e8ea7fe96b52121e7d080068f0d2e12e6ddb12c0c7dd3a52fd87c1c967a606f9a1d547cc8c201513f01fede3517e1b1d43ed9bb072254afa41eb5267be66b0522359f1c729b6c8ed54cb2db852e25f1c72e28f30a154f3663652650f5a00458cd016e66c32b4868007805c93825eb58af7cf9ad64347dce6a9f571802deb6a7bdf2bba8127a36ed8acfc5efd14a0929953f47ca46adde4b29fdd5e24444d42b6f0ab82ede194d6b3e36713141efe9a16ea6e9c89faab443e5f23cd4ad7e9b5adaef6757cfb4cba5a7e05c8af1fc50caa90de784bddaa1a28bc77053776cdc07a65d72fa4b387c03d82bdba797fae839dc332aa4e289deda4b23473267df91b0424d16924b0e96595cff02b2ea9c246038e04016c97f0da4d4494e38179c69b1cbea4acb448fc64064bd97a9f664f22706143f6d9f200fa71c5a17ae0ac1aaedc0a228c75f12bce3bc445f76fcba6cd59fc1188b9f7a263046035c2e4a7b5a8212bebfcfdbd419119429ce26d3d066961e6e703ed506117544065f61d547f097ed4ddd3010c7411f867f3f4190364187ba966bd7bd25ad56eed38aa2109308e9d28795cfc1cbf0e19abffab9e76fe583f03f6850ebad5cc2fccfe33563330e90f4a9cc7e307362fc19dba2400badd50c98ccff1932d6c024781119f8d5204fe5fb48e688c82980d1ee39418c7e8c9da8336c43e37bd530de1c800fef0f26f94deb87f045571cc26bb77baef10c1dff166184ee24ee5d90b580caa36eee1f01a65b62c089e378c44d7d95c15615b397efbe8e8ddee26d104674d2d47389205e1a3d59a48f7f376a2513f47e254f73cc689826cfecbabbcb0165afbf4e972fb83a8a99d0d847b7c0338bf29d192dc090af8e65212ddbd7dd8fc310d7fdadb26e51af002f4a89e0b6bbe8da48877b90def931a031fceedcfb9f08defc7f3a9b4443dcf1ebd027ea4372c7df3734fb71ab467ad856f05a3b180b902139569c4bb5a7a3448d7d86176cdbe58092bc84c5dc88f3e219f06d997c5189a62fac7db70783387470a01e0b082ee2564b36c8910fdf09128beac0e4e8802f8d666f2d1a56332a60883d2afd5cadf26ee80cc99eef49e7b2349e363007439d5b7414c1c92e2f6e6cf34a4d6688f2da6ea7a6274b4c39d234a3c0e4f3da9fb91c642eaf7f8111249c494df780d8415c1a0b3856661e73dbaddc240cdac15e2ce1dcfb8055ff81f3d01d9e1a90d3c195cec2afef2f94f3e8e6620e78e8bc136e4a8e3fc9abc6406da181e5c7da887610defbf26cb34e1c95a15dc0da7b757b2e76f3743e9fa24ad93ff232558e0bc7761c79c366b8b155a115fa64ab91eb525567ded8bc235ac5811f82bf7e7e27387a72a82e447ade9449323c9f94c5fcadccdd2a4384b6f36a111702350c7fca3f98f75dacec66dcbe00780f46aa46f3a7509590ab23cae9efcadb32e61724afc82fa0f9fc059045f2ed53c3784c8678ae7e4583328b1e4ce2c4472a7907846c13faccb1451bd12dd8252e849cab570a1c582cbb80e1aacf3daaed05d93c58689a39507d80c8dbf8752b52b81889a04d50ff32cd49a957eac289ee73680396c6643f4c6a83bad0c18f6f6b0c0648af83c534466c3fccbab7c7125ec404e4bf2d44c29ef11948fda6036ccf9d042114402f973c3b2eddbd278c8c0b3d5ba26cf027c21d2cb30c30197cdc9e9a017d394d9ea9a324aa9012cee8b8378298fbb7143f932645de0cb4903183ac8c4d4b54d3a39418f5553c4296c66feab3d9cc021be355209d294466864b463a525397e48fa64c89e303159a19a18163d210c739fb59b8a55fb71432facfb73ad8e89042beea885966e2eb819be9f534348a8f98666476cc2313b018158134e7652c4aff5a76dfa26df2cce12a1b461c19181674e02c97d4ccc56f4ce098ed96b64eaffc777572628786795b19b797763fe0c8f2f8a6b27a9609cb04bf1e9fd760e3f8b13f04029e5dfaa639694703501920eeb34b08c493b4c1cf56ae7076caad7c56bf89408e65bb7abd3a3773137943deed418acf3c1c8b40357df2bb4911ee4414ebd16d12f138be8a6690529905d9a0866a49e37d7d34f08a88ead1dd9dbbd5d297eee9a0cbfaf33835690c469b2feb9a03bbfbaf9f5bc7866cad7958e73e096ecf89bdb1eb88b1e0798d20d0ea5bb7fee78a470a67ffab33f1f1a76133ec9de3d5f2d2ebd6359182ad5afccb0913bc676f904494b25aecbbecbb224ea1ae704090bedb161fab13e46a0274f9693dca8c05ccc7918d205cb5623999086303951e3ddbc59eba756bd798cc2e959d466b2477eafc41f80e41be727d8b45c2265289bce769f664758cb8bef100f393cfa39f92bc5b5dbb2bd7538e1c120635874776d9cb424341d5e5c78148b1683e7333deeff1278f73892a9f5a936392510daef462405593ed676fe0e55747f7436d9a5ac1b47d32ad2137d98a4e8443216e0b68277ff4dc2c5e9f0921012c027d54cbc6ceb498e8986fdb794e01fc09d54bd64757ada360fd703e763c3d2a48b4e659b783b5af472a6ca24a8a8be1149f80a2b70093335a3fcf3a1f2da439ef65c9e33fdc3602430ca248baf35dbe4bb478c675f0c2172634ff70140bfd1e30a74fbf0bf2adc949a9ca728c9b6bcb204a4872e17b22765b09de44ebc10098c8b0cd87e2784d994720a82040d8f46fd51932fb60d20c5ec28d1d2ba68883c0ab7d0455935f8c6285c970d9e9b46d12bcf232147aea06e60d72fbecde126b293fa23e56e4dd1ec2a44d0f2b558fda9265f3c51ecce15e947b0d9cc98d1ff3a190dddaae79487ad02ae5f1c89e75901a131a7ec31e359bdbd1c8c02b6efa47c5adbfd80fa79e5187b66e75242bbfd58b02cac32fbb97fb2e0936e85d17d10b7204c1f2ae8deb58606356df8c5ff33b34d5e0897441f787cba97eaf3be10f5aa88840c0a943ca1043cc817cf216f4822710cefb410a7b1505c8544503ec86eead3e1cf8f175fde916bad1bad0a487175a1ab574bda2c1c946fc195377eed8666a4d3c2445ae37a1570473b81822440b3e83f806c9a9778e21be7da9e69046da645112e47f200baed9b0b1515a43f2d9bba7fd909d9c8a72a0f679e2f714a6d25330b339919d670035ba732b2ab6b56c03030837512f9c463892d386d98cf1af05445dde180afe783057ba46b6e1979237e9c6ee8632ac3a30d8af133c98a972ebfabcbb2e8d05b0244be8c5d52aa724c2a2311f6963c4d18a471fd29a038b552aea82d7a4c6bacafcbc9a4c8df9ea64066af779551768c0fda8a6e1fda53af3897442aa00c9bd093dd09433599c0fcd9f08af14a6634f3a1afffb27759677dbdbf357d6a205f5f5aad2e9dcd9c2af3215b41e3982a4d3c582bc09fa1b9358b43aa4399eb479177aedf0d0d6e0ee03462a8fb9db25c6325fdee041ef918cfc895c9a06d2f99aa7ea468ec214ac9d1d92b13b99708951f23e3993e53ff4d4bd1c3a77b5b31543e2b1e9ebb78b163153e287d96cc4f29fc702e231396efa2f1baf202e666133ab77fe42a228ef9d50790fadde992a3e7441e719574f697ddca13f6fabd02697e091f05ad43c59d0a6387dc37335b6c2876f836cdf1687a84aeb21c3b2861eadbd927b6f69287c9fa0b23d914e3a022ff5f5e24edebb481e52b3e26e5cb4f2811341f6f3f63fa6a34edf649dfe27b54de36ffc88e9894e3e4a0788a0f30f6ec4d1ea25bde5c16be32d99fe63f3908c21b315c4ef435b0f2236c66d541b71912a11da906c52fc6a242f7576ac6507f17507af1b1999bfafb3cd331517d39a77c3a6a8d14776a482704f3d613b5f6ce1728e7260936e12058861c49ccb871f050f85d20b7ae8e69301a5aa10ab0c36d38414128203b45305fe05c995a618697ec017ef134d0008f37920926b7e680b25bb7d3006c3ccc982762a6db7811cf4ddf41d2a1b0fb9a6575d01d1dbc7066a8f053fe8f0eb9f5c259bb289151d7ed7ab095221ae13713ac1fbecaa180a859f49a6eb39dc349a1b1a4c3d9b6b6d63312ac6934f6b63cd7bdc5cad2a9c44f190d36cc7d025268203d7ae8bc0ac952b142e6052164123c2dceb0bd80dc8dbd1f6ef0783a92c45aee82b6cf2a5b4672ee86448b3df1242e5cd0a59f46ea49f354cdecab0db6d1e32bb5d5b71504c5df4ec371a120f4c192261097a9fa92305a0f246dec6ea47a27f0e826f87bb6166acf8d5225d042a07d7fd7582556b05f2f32ccda07ab6d9d21c9e5284e08d86e89f9624224e210afa37a09f95d65c2abba5ae804674b1943ae39c20723c9914d4b1ed11ef9013081c521dd6219d1a47f81046efd4d2e5caa3981fa8755d6500f275bafef030e58fc3b2bc3f3cf764e2576c9f9395cdc75a58b587b469fc64094fae4307ecad90e1ba411b70e19a1db74751c4b6a17a3c3dfe5987992d221bdf579856568dbdbf1681fb944709c231992378dde1fce5b6c768825ef4549c7d647900f08d6b3a78b1903413495da25487d8913a3bc8013b7eb8210da9eff0a56afef833b686a9a31c213e8b4025df0825fd812278b8500e159ebf99d95a64f0b71698c90ff6bdd480c06865e3ecaeb023e0b07bd1a58bda6058cc3ef39170f4d2fd88e4c742b7689d345b3d1bfd332f5ea924ecc3d05cd2fd68c6618f547ddbe091995ae3d96c4b6f0bbf55abbff6cda396f57a071d2db7860ae745017240dda38bfd69ffd6980c844fe885c795f2b0cada382f6fcac1820822034a8570cbba9f5c1596715111fa66411b71de9a47a9f0da193914e297c5638100158a453b23b797d68714a4080b1f2102c48e4135454cf740f7107de8c743a4068a8102662756d5511f7cbd2517e9a6cef78a9284c86d413850b71854aaed5497fb4aa362f29e9800eb676a7bffffd5dae2afad0a42788bb912c3fb6bc7640b582b0ff2420d7d6362deab4cb849a015117f5eb23c2786821f239f5f94e5d5ac45700d2740d870cdc0da653ca998dd8352e0611f718837c03d08f29b1c29b134e4e32324672b21b743f817b9d8e5221089b84076c0b76a461caa32570c4fcd8e3529f10a6de59b1b6eace02ff2a9e6cfad06656a866ee2b4f79a5b086520f4da01d7238897b8e980f3d7463a69646f0b76746f0330cbf716731cc8f531f7896806808dbbc81e3299be48d56fd2d8390557944dfaff5e1f6e067b872dfada85d22e28bdffe34d18164c51587822422dbafbfd0f98f685dfb18157e77d5d954f0c02864d4a60f05ea4ed5f8041903605f4b0f7453d4f364ca59385e245f661afe41cccd4bff2b378b040bacb4b5340ad4146ff66362248d9ad1f076a767e142e2ab69020dd257f25f9dbf8deea3484b824ff46d4ef15e9950c138acead361ae6ad678d7a9092ed8e01f02871bd4d43c2c183facf16627a904074e9dd8173d31880e2817d140ec3d5aa0551f6897df15820cc2d3b7f4a041aaed7442dae374152dbf6e97d414a6da3dff30a1be93a98ad7569f55c5bca5d411df06ea7938eebb74e611fa48b94df9a717c3478c7aad9c4bc128c2220198fecbe301c1cb06b7d85a4ff6ff199ee3dc1f2d825b30f880e4e098bff9451df3abacffe56248ea9f7ec7ffa021d3cc37ca6c64366a2e0a07a0eb43470c9b20d2ffff170c0c40f7a8636288b43e548034007a4b83d2d1c4f6c8d4fffb9800c6010fa4cf8e3d113a77c25cc10aa432b226daa2b1c350e45d4e2028f9585e69e688a0f9043868c1cda5ba2a51ccf5d902669e33f7b4bd87b35916fa45ecae6af11633c21788da74be749108357e81cfdb8985521a65716bef20d0e8d5ddd8033db48e48e2de79d9206e897ec01fdd26dff1b489cc415de35433528467d78d7020903b553c776e78c4541c9c7a44d51e400afa56c543475b5f4afcafa1e97d2655cbb8cdfbd4bb77754ebd82ba17b2861f11c50fa9aef58bad63ac04dc271f9da6d40b64856e9ff6807fb44d11cdbd3ba6d1d966519d011cb4c55dd81c5e6dc223822fe29eb490ffff36d3b20d954946e3456608f6d98981d154ca8e9984a804aa09bb6e8a78b483c20aa0788980df1e29ed8072c8533b835a44c896ce3037affaffdac361f4a5c52c8e1049625aa5df903941dde6502b771aa68786e19a63c4eef1af9d2db326c890f1b5e7382c0ee7422b819ed94f20f23e76a0733a94611754df3e38f66ead64a031fb8963e83d4b5138ddcc1a999373ba25ca1faf8e6961f60d9a1c7e6dbdf5b3ba9b46fe36720e7c67454ded5b92edd8d9c9ba2fe71e72843c40e30afffd38a6839ff5423dacc7bdd0ce61633937036c3589759cfc30114b22e721b3090b778e531ee4c3c42642f03f1d44e7aafda31fef9c23cfbd018821cc84f6689b977d3a559476db31b817c86506b954b954fc65ae85699125a3258b8469c5a71acbd93d3ef1e46497c7df83968355419a8e2373b4a7928b83f4f2602eb598c9072dbbb6b0701e6a34ec7c4a25a21e45de54410f34f00bbb7cfc11874aa196c7567b5f9536e9183530f15130c288edf7ba6b4141c531826b2513680c5424da6d96b8a7a876125720cd1fe83e56be08f1e92405a8378f7616abec4b8f088a3a34be39c2e86d6e2062a82b3746a932440d7e41c64f0509dba33a66e0433284efaec962ba85f2244d98288bbe1a151ac80ac1276652a18f1d4d70683d3cc1f1b0bba4661191ea9b6c86f095c279102bddecb2ee327436cd3c41224b7a5e846638c85900f795cb63468ac3295de04354bcb217f30c703a62d78369fafde9c9275399118d960f04437734c321dc1a07b295673222452e289befed696e156d908e7857498ba20df97ae40ce97561366ab51387640c906507a5d4ad17dcfe54829bd7d74e46228a1e18fe1e45b518b91eee2603ec38b1cf5d9434559c28ca808154f8242fbda2341a3958ecfb67f1af212bcdd2f0fd9289cc00a0ed5e765d919adc95998f34fa4bc8eda4dd44c2352feaa2be54f551b4005b3b83609b9960f68b8e8f0049182bd8e1a77797ce88fdef9c1929101a6396f4d943f8e885c51446a52fb50dd484d5792d58b7ddf80d26a3fd8737f918e75853ee1bcbb069d1beaea3612ef3fcd8429fda71924b266cb382ffca360fda2436cd5dfbf88b4741c60cd2ca7b11378190f6e7a2e346d7d32e18220f2978e30220e14e44b1deb9af1dfd0be05c72962cb36d9231466e11a978cc3e793cce1ef955a49e57fafbdb70c98cbfe378a8cd96f78dddb9e83e49d54ea6792e1ead832c42d72740dfbf40329816cb4553964ee4f0cfff15df2ca00d84a7740005f130da519d5d217b27e781a201d8a860dd85fb61deb1cd4a25da6b843768c269b8aa830eb542d614e88f553ed90c56beca5eee5a8183d11ed15fe8c4160eb4466020f36cf07b329035a039280020f6ebbc51d80ced730912bed27","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
