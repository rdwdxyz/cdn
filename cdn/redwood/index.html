<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"170413484c374c7f547dd0c3a7fdc8ea29bdcd79fbdb8e9f5e4b4111ad585b09e0caed14a2f3a1b2541624123bbea0752b12179cbaae95e0a14808783ee6cd1de4b647279307edf2c5d575193b941f9d4a49f5c19a4ec8f967bbb8436e2b408016a5a8aaa4486731bacc4ca85f73a3975803bbd5be5743362b1ecad2af6238fb0f8d0e9df92721ce472cf44bde7aec796379fecd78c3607d30dc6caa56316a77e910bda97ff0d0e0c2d73166a7a1a1ccd0c874e9ced70c49be62b8043f320a9e4e184b31de12e6a712e1adc5852bf6a71fb34874e31d53410dea5ba86da0db2632706db489523fd61dee81bf28a4dcf092c5536ab43efa71fad8efaf4ec15b0f3c2f642ef3641eae992cc95ecce987e72414336b110619af76f85e2e6c98bf60976838dfa49d7b552ef852e7c199e34933eeb6bcf27a148c793290a0dc14338823dcdcf3b6f6d2538f195006d15b7487ce95278f7fdcf6dea09533d01c4a3c20d2e9ebdc1dfdc5085424bf1efcfb78905cb5c0b2db04c5f94568ac8090e86844dcf03a9aed375359671ea31941af2463e426c7682254600f6007789f3191fed211ddb524af3a634500af860a48ce061111168dc93c7d8b91f2a23b5f4d17dec6683903eea284e00a91fef96857d3cd0cfce0ff768130a910fcc505c1f5a746240b7175769a729316bfbee75b4aff82f833eff10514a84254013581712c3e6a80baa3475dac908ccb15b8c1c8856ead2ea247b67deb81491bc2ee11d7f7501e0f079e6d47d1d758fe2754e65864be3ddab4978b82cfe8dec723ae4847d82db8d9f499686f192e3807162e4db9768495fb049bc371a5cb4b7dfd098211ca853acf0625ea1976a23f7512797e4795b34062b3a564bb593409558d97961319e893f261ac00a0b3fbe00585a12b19f5c04813f51bdb4f34272d9efbc3237e8477c58ae07b5e75b722c5738baad52274caa737b986f43985d1b63929578767f8b7f6abd90868dd674f89365b0caeb4bf89fb5d48f0cd5f96a77911e0350affe07428ae61b738b5a98aa323042e95bc489138a35a61bcc538d6081ac836576b68f4ca499d2120592df49f01e6a4d7b131e09e044db4fe7a0069fb1cf0b7ed17352a97e54fc74835298ccc2694fa17aac50f15bb2a6ebb6f5871444b7e8b3e9bff11146d5e47d58561ab028903cffca2ca7c11cb99f513076beac0ce384468257fbc57361346b4cbd3bf884b8808b2fd4fabe822d2dfd9461b31f1f1c3d89ce874ad35ee1cdc794fe2ec39df6de6ebee75c277c80f9942c3390b78caa1703e58a38dc2a604db880ae12f0169b2305464eb5c69dd9025ab10538dd5a29f2d015b6f33661ac8a849e645f3fb6468422a16b5b832aa687faf483bc70170e850f4f54a865c42c5f8ef1aa86ae09631feeb50c9fe29eca51748ed35377c82634a514900a99adf8266e5969f4395d3dc672e7703c8510c22b3ea761f7d5947374eb354883258908e3e70ed107664b351fc6d4010fc0108447a63c08b993a7e7b45d9d435e4a657851e86e3b64f59c30a993d21061101347cdee5ff6c8b8575150e0ccc53d63dbdeeb1627c77228fe5a5a8e6c541e667685ddc53b09e30f42403c2b98909787b983eb15b9665dde3601bb912034b0e793d9c31d8319df05a3f5b8c51da19f5e213cee77cb661a37bf4d114d47d0ce2ba7b66dd7c5c55f07c9bd707311d6baf64bb313195f7c1de4e3cb55ab5700f2cd6f17e374666d9d9d6fe4d115949d91b0ca743f25f6fde7c0d788ef2aa87decd7a632805f4b7a222843c564cb6a2b8bedd2488ff83b5bc2a91750c1769fb336d858c342f7da6a298338761f756196c5b9965039f5b4df1031e6e03dcdde57768033ad4d98fba4ac8bd7095c45be8161d5803822a4a76155135bb090c50433139ccd5a8b1b42f3f6939b3b35810161a9681e39087f9f58ecb7157b2762a960ed0dc844d3066ea728423d614dcc2d01dab744ab6057fbd6d7764489dee0a0569ee7ab2f6a2d92aa08dddaf640d0b5f8ab5ffcb65258223f45630f475e8f2f875a6e71d47bdb817be17c972b64e1929b4a245cd1ce1f1bcfe4ecce2eb7472a018967be199d2195376dc09e0bc373c9bc46ca50e2c520f85e8d25ef1136cebe38682ea7cbdec943ef4d91d062000b68d44d53e5b816d60d57f9b0324de10a578dd07894ce6e35761be6541f16e2c9af624869a94f4c47e95e8e8819fc069e5285f63f2139435108f74d8b5e5b3ae346d85690badd5917737f1a27ba1905858340fd7af7710cfb35c92ac97883c9343b70610472cefb74c85a3a9630a3fb85ed78eddbf43fa2d1a56f25a20180d2ddbfa14dfb130271e570913a67d8279919e9bcf3093b08664690c1612cdbb12d2c812f895eddf2da0b11ab613b9b33d331faf57ea972c863cd9bf1990c5d99109a06ece57169662a3bde250f14a1d12430b4176b95218446e7c330115a3dbc6ba8e0cf7f269ef3d142e54077a3e1d21d8eeedcc129f60ece8f5dc9248af40fe0bc538abea98f1847485486469b70ba4f65cba574e012cbda516bb068678e9693ad211c78b242c35c8a0b8fc735684f935fe3b3caf2ff1ee0f3470bd650df3b5042004be3fe5cfbafa0ab4369cdc36f1ee4cacf35c02b19fb4010345ed471d567d17a9dc840d97b384df37d4e006d1b7aa857930650e6fc2293c0f2e50a253546c8fd32aad4f506501e58f9ec239a7aafe6fb3b2a5204ba0925a481586a2b4f7c2bb6492bdb5c18eabd3f61bae836cc9d75e2cc20c617b75626dc1b951eb36a886de7418df4da2ac1127d5a994ae39fc086c6bcc6401c5be5b01f0b75df370cfa5e9ca4a50f61a250f28d4756ae1f7d8630f8e7840b703d23b7f32d6926bc9092953a3a75a5bd13c9282a521e3656b0567c3e1c6f25ffb79522f10d8437e368e9e9dcb53e69001fceb55b8765357a941105d66ee44ab253069624a665cd39371e3c1c996e2627b55a31265a6262fd18e5512ec312e57ca8e1fccbbd3599521a0bc86582a6862d4724e53abe2f1323738c4151c3484c6606ba061718c4af36718f4ffa2693a1d4c8ce8855ce01642786287ce18088e05deef67c1dd8969586e5d17f8704e404d0a7b6e2519e8e1b281fc29804fd6d1bd2c888ac5555b441525969ce9d666fefbe28c933d47a912c956c825ef242e96cf16d2c959d6b7c04b950cdc2d374b982ba4ac74c15c594f2c0d88845a67ce3c15d5276c3e841f4a9ef7b8f6ca9e589eb59e206aa67669c6f1517e2ae1189ac0b72bf493ff6ae91e820651d58414223a28a660f21d306008508976fc245ddf933d427f6da69ec64e45d7fc7e82e615c473e3496ba52befaebeaa543a168b089fceb9db5f3dd1acaa72cb3d208f0fde6365d8a533e73c0d6dba6a11032403af61f29a5ea06954ce1984e09cbbc4d603dba54fe59b1435eb6fd60591cda281018b63835c475f49d08e075eafd625529b77cee623457ebbbc196b6496ebbcf3494683c43754f3c777e698cede762a4f374548f562129eec1ecda708d2652d3baeb2da1ae774f11c0491e324a1c2b4ee0de0f0ccb60ec10aa911e8a65d5dde980202c90b22caac90c93ec7cab5a4f8e750750fab7d2ba6e434f602a5e1e7aaabbda01776ba74517ee298e4d7fbb43c01e9baad4603325c61b7e6c042b014e0e5e2fc406641b52d32b24da6e45e0dd8d510c5ef08f1763f2d1e7fef1be9dcbd72cd243e111c46c48608d025b6a1db55208c0bb25db57645764fc5bec61b588b53b7a94b3f424388a9de3dbc925ad5c6d6cb870fe493332dec84371c0a3aa8363f7b3b0429dbbc4c34f98b3ee84a62a3f7da07d237da8d29a0ae78f971f2197fe1fb4159f2633d44754f9b75e4eeb55d7ac08d2ede7725a3103739d42306175d55bef4fe5cc0cdedd137590d2260fbcdf258fbf8fded62e6ee50de8b0e211a81ef4ea9ca9071468693529afe6df3214a347483250a712dbcb26df80a2c05e56787e756e53cfabf67d0dec57f8f2c109b1bdd8297c6dfe2bd332475cc08be8f2d0af554054bf865e7016bfd866368884da648fd5b7ffae84c9d291190c4882c8a3215b072e5571a35d9a84885b933c18d4b300b1f7ebb0f120c6aad1fa4cf75e4f5762c6fe3c1da2f3b5d59efafc12caf119184b03fa206b8ab66369f34f690187b47633b2946e0efca78da240315936119e43fcb8f19dba2ff70ed4dd9c42d7fd09bd02cfb926e0cfb041acfce749982f0b8b6e5c315c8e5207a874f8592064a4e4d9f8aa02f24941e0c350e6ab8844f45e4ffd11389b444ef00b564f0392a341a44a819d7d9a7d361a043e2e84e7c74422601335c55e634eefbe0ecf874665f4fc40e29bb0fabf946a965d634f789f67f9533de128ed5664724969c14eeb3d9282403b1e8a90be0533160187c29ffa293e678eb8032a80c4fa51d79fac4d4c8a5b97faf775c56cadb0385fbec83ba1f0c98547cc7d4bf02622dcb9913266b91ad4ef59d25b59f9e94bbc255f50f0355c2b42c738aaf81b36accd4de34e580fe76c8dc501a4756f3c2aff2775bc6a12851bdcd38fcc21c5de06f4c33fa48cd24c4bd06a34f0538cad4614d9fc8db3015f52d5be88aefb796f6b137879a725b17a5f22a60a9b293eb1efa771e3e6b799534cf4c2b5910961625a797ca196b46f845af8952b2cdbd1d0b010028eaf570afcbf03d45a43dcb66c31ff29dece4406748c5862cb180a74b20ef0dde89a6207ffe1b61ad77f50e1c0db01e2a92af0539d299310833d73eb7249078e63a693d39f0f0e0b7da140eee2ca79a9cac013201ae7e5728f8fbdcf9640ec8a3879a37b1b46ad3ba8618ac05799d0c1cfd380e7c29a79c8d6db6e95e2d0970c767a74a826c54078f3cedf98d8f3a5f97ff13e0bf7f59f18619259ce0dba74635cf87b233bcbbfc11967a8c57a226395669b36524500c5bd233ff26be23bde4cfb56d5320b0c01f6f8040e79b9f7237b24aafee7668c87b46e33e9585ca6db0cd5fbaa51545bcfaf298015d69d42fbb868a3852ec2757aeb41659484705a2c2ce722c1ee8b457c345aef2d0d71e4162b5d4a18268049e7652a66186e3033bb018b6bd992ae5aca0824fe3badb7f82e3de0c040de8dfcfac998ec8b4da1992ba6dda928ee7acb774148f07b67a8099986c2bc7a4fb356ad4cf952d6af88a0002f4f0e2957057e2e5a9f7c685646df30eb517d8ce765a2501e8768b6b45ff7cb799fabfcbf9eaa7896a6023f008bca82ef48bbfead24bae1b720b59fa3130e458b712e3127d64e07276b79c49f753d191a1fd6377441e0bef33f43d47dbe19da0e0280fa4eca54a4da52a32ad9d825d13cdee3c3b62a305ead7d4b3bff5f0587afc9df70bca696e281853459b92819d2d48ccf08aeb5b24f53fb497a50572443e02760204c0363978eb47d5af12b6242f9e5b6c75410a684142b2e8f7bc6c20a55040d64695b6a099e60be2b47719e9071a41d0b5ca1340852f3c01cfe20655202a4bcaec3a2473e669c3411c22c780fc82623dd7d03840036d8364aa114787bb9e1bede172df495272f2087e017ed4d8d7edf9d97fea0db856ee0c8be9dde4eeb3137d1dc3427a1cb3e5263973ce1454bf16ef4a75f67df37a5a63b39e164cf5728b37db70808eb011d6807bafc16a7ec18e32feabebc3e1698653ceaca0479f9ea44ff0171930ce4a645897965140d52b71a1afd392c7c951a4191e44859680679670066e05a3cc07036247a1f0e82829adc64b9e759f741857d4c75d2715030bf7b4084d534a0257b7f12080355f2bbaa6d4bbed85877ef76ba3853cbae038c8c832f35fc4f8fc127086d2211455d63d2fc9da73f0989f40dfe65c40673b7a0320c8a969232168ef0e1a3dd2348d00f79fad10ee266b14924ebc4762e878f526edf4c0768592055875922f91ee8a43b978ae1f65c3cd473d0cded0ed5612f9ae576ea248e38d680d3a8310e99ccbdccdccea719ac67ab3bb9d3a5ed9861633d6a6ffa96316b4823ad94fad0924daa9812492b82803c4670750060dfa83ab6d0009fab9636d118637d2c62f6bc0479362a447b1c63852605093dc187750660e9d2d064d06a62f567dae1e955873010e77e4351194d0ce280cafaa3279c6a4cced1fca7cbad8f3620a063589fc4bdfd15fba90fc998dd9decedbef48e7b7a412b50347c3d2cc23b50462b8d75b7b7b3df3bc74d890ccf977984016cce7380d020717d1758e727867efab4e5b15bad8f751ff9aad0bfc1ae0f92f1b9ba7803fbc1d750b1092d11f9e125931dfd18a341c045aa2a97b50fe6818a682ae82463872d261e97e7ca42eea8928512c134f6e8cdf6c64e29605e5a649c9139e6502ab3a4662d66a64405bc6256cf7d4eaf671aa87bf4c0f90909b7fb186130b8af500bf540eb40fc369b9501251c9ae6dbe5f00cdfe97bfd33ee2c099d7fd7afe184f9dff4a001f23054e5a0350293eaaa8b5623ee9c61f429c35e133e771cd3f2ba6af414447bb8a243307028cf89e00c33454217d387219d24e528bcb9292afde8b2e002bbe4cf025159daf2b962b40340a0de6d4a4fbf15f1e574f3b07e7553c68f234685f37194bc9bda8ad3d28ec3222861a755591b2ac2d5142b56e84727597e9f1585a59e37f7d343a80e184ae6d29cb1e503968604377e6a7e7d13ba586b73e9f33f837132b7e56a366f98729faf2ca428bd476d8d594be6e2b551c78142cf0d7b718493166cbeb9c7157370c065662fcdd7e84b434fd0e764d9d0004990735c859c8e1859184e4a68f0ed20b6503467e209bb74b61d7d87ffd4376ca5aa82478307ba65f6dc3cc324fb46d4d1d3c61258b0e70a843f1c4aa803c4b1f640b9f0d1b853f0fb76d07c8df8062b05f84ec406095c021b7f9b698fe2c628d3be83ead1a58d444db458ff77194c1e5283c800cf24ff97b769f62fbc96c0af8ee7d9acfaa6a44c5468d95b7860ffef8623b7b1565b0693d830c17ec8e5b7f0a1c7cfafc9ded9aa0c75deba43727a792c9054d0891454b8c3c5ca13ffd5cee5f8e4da3916542665c35146167977a3987fb595de415c62b0bd447933d4fd72941a77dcb9e6a678138e97fe0ad8772ed42b278d1a3e9b1055a8a82982414fa3882783ffd9d49f8cf304225dec4ce3ebe916f8e96c4351d3d1abba15562f5e0948f4fde54eff5f4ba5a51ac6a5f3a74e542d5d00dc1646eb4858125095a0ee64048d3ee1489210ee05c81f51d6c02bba076b43b242da6322b5470d42893911bf1da7a7bbeef4b10d2c297ba654fe92bf2b597cd6ccd44096741c60722fd93c154bad1553daf1cfb964b5f976db1e0fc413d117d90fc644e618d05e44e92b9b0096db83897ab5ddd4ebc737491604c0973cfd011c84375847b8903e1398d1feae364571e71316d44eadaca30f8eb1fb5f8f02a8e1cbb84389076e0671a1325fab3bfc6f54531e090b797bb29fb09dd92129400ea8e43e6c365d4fa478df3e928c96b450673bec41bee5083e5d37d930ab0f061d6d1950187379f72f5879051ccd1dc95b3a708060631b567bfd710ecf922d1ef243f9d0ee480b25e34b23f03db8dad57d4549bbe0c8f8fd243ac9644562dfebb425a189b0da73b981bdc3ae92d69c5f8ea36b6cd2d3fefd51118caa845f46354cef04e0476c733967c1252be5ff1390217b512ee6cf9eccaf3ab81f69a9bba6f1333b5cc3b905bda3835cc0deaf838aa10103dedb01caab74fa6ccc90786790be5b1cb4c73dd0d467c573bbc8c66d7fb0bac9e5298a56f093539e2258ece9e929f6fab0fb0131160edf5b89170d30def5be74c5fb89ef03052b07a2cd8f8dab8707a33052e32c57452cb80380424bc35779601b669c743576ec27ae16fd0e20890f46abe5ff0c03aad03b16f6d36703ec6d5cba7f48f35f35c15226371ff31315c025ee2818b107d2ff8e9f0060e8f5ff4d143a242a21d8092440084df8f02fca654d3082e5ac88c9e8b336966856e186f2980f79c37c4c1b91ff3a9d76d43fca3a43c610e39e9923bb027100d695fd1815960ed59fc3856bb13586d1ef33adf389472d9be71a3cc2e494a30e22efa758cc2e76235c52d954f2053605bbce5df3f4da55efdaac23219936f0a1f98c8dea5b34858bb01a3018508b36323791f31212d7eecedb23a459169f72d5610863bc9147ed2f6eebc890d0a6637c872d725cf73dc4afaa501f42da2a87d1997a3850ac5f5852121cd6f44bf755359cb968a406c050f77647b6a5f6d488ee18f1a07bd858a359922b011d0f0180e131764c2392ad5d802c17025ed9cb7ec1fab80e84d91ae0dc157b8984a03e954dada390b4d77d71ebffb1d6e8fc3d1abed459c22386861e957ffbd43719dc6ad229bf9f1f04d473ca6ab40d2714d9d80de5e8de3cea9d06b617965c470d87f597a2827b8694741d5d42896d2728e24709c04c481f7d30fad08a374d3488dd45cc833c5ad784e8ed107325141c9e6b67b847daf3075efdd70595f144e6e12b33f76822f64604ca38c5596a5df5cc559fdce915219baa6a2be4752e031ae3d0eebef9c724f9942c3d9cf6af5cfcde9fcbf462c6b81512aa8422759492684f8632477902dd329cd8c215b4fcc676ccf661ddb0dd78382172cec0ad23f494cdfd8930794f9810764ba683f2350df133c9603dd60af09d11ada861a975317090aa25d2ac550438b54a439e41c237f034f5b9cccee07bca6a8158d4b6c583d8356f16b14f299c73d8c3a820c09d6701a0751a5b9e941ee9fd7226a9cce5d50ccb6db77c54f0087807081230fbdceb4ff0a61b8b2f5edc2da3c9e0eae9b733bd633e64e277c8b40ff8a7cdbed67a726ee199338a09099549a25028f05122e8ed2fc8efda431eae01daeb938846bcebf25e6fbd8a693d56515ac45ad9183ff9edb4d9284a98e41016357f5da9df15a72659e25a2a08471c8947f912432535fbe4461fc92b82c3237a572abf8cc9bcb1b906d48b4c368ea9fc201e7b9d3a54f85880ebf8640c3e4b35efcf23d4faa14ef6caf2151fc3f2b266d1244c696a5460f398b85a362eeca456426037f10f2c10181fd339deb2f11a626fbbb071221499bb5134ce420aafcd7d366f172bd129fe143455ba9023d4856d563390067275e2fbe8db749d9172f4800e04f4c26fc149987f95de881429700f08a2f5c94ae93f714f0fc2f627488f939cccf6c30598448ccb404f98162e40377693aa312ce349c0f1b9cbab43b65e613d66f3a7df47d0db6f794a8bfa4a1f46a283988f0561f64fbbdbeb1a0793fed8dd87c5d33727d615e5274cfd21438e830c1fd68d8cbde7a21ed2d0f9ea151587cb8e74ace970f178b22be18e0c6f4828db3ead1367eb6f5767460556ed2c7382fa7209e97a0bbbc70230bc69eb28bd49be4ded382ba5c56ac4c1b200e0fbffd013b1a931571c4e44141eb78f1e6c483acc720bd5639d9e68eca6e2453730a739be677908684ae2813f0ccad17a87a98e41d43310a9f316242db9afbc22d1813e16f5b65b3fa57090be4dfff438330278a5be35bf555d86b595b9c1f84703ceff57bf91c817163b560f54cbfe3b9f4c8b1685b2bb4907688e69e03ea32b2f1f7f7aad0e3398de5c17c0146f8f486935fe13697b0d1dd7c1012aa1d28f70ef213a7bc814ed31193cef515ea51fd52d65bccfa6640266476b9094b04794f1f2c622c530f74d6ecb09221bf76ed755f59482c2103a97f7ceaa2236ae8890cee7f8fe3416ec441c0ffe98b840d03db889af4f92dc373f50f4fe6e6ea71ee9ea324e4f3378db9a005a8e4ff64cbc7ad9afc3e59d0f702c5a0e895bb45a13b8c136887e878486a800c559b170440e6056c4d7c2aeaa420101f19c758f913adf931d47e5f94109d012a144ea2b9bc05238689e771f1d489e39c2b506231c7979c1be9e717519de517e063f88fb9398a6f8ac167dcf4cb251784ef9078f038143d1fd66eaa7fdef73125cc5f5b2fa106e275712e14a2eae52bd145c27f3574a8b5f8f3fab5d0130441e53c12f604793bee3e0369bd426942cbb9c03e035b31d910769b70d84c60a3c3f528236745cff22fa8d5cc8c64233d364a88444c07c345dd69cd7762327d773503b4ca8aa1ecc7a64e9d27e13dff858dc05ff5e619a1cceca07b225900decc03ef533d019296822f5f4484012d3d71d1d8b57920f12c129c405217b6cb1456bc46acd4991060b32489560d134030400d34f74fc0f70e6a08a2e441560254bead511a045cc5b8b2d15b7e2b8444c810cb82d81fd04f7bd78744e35e5ae648cc649f4465b1028c2030b2386c9fc3b0a76d077e28c28124e2de8ac305750984c779a6f27381e0f1ff7c94bac9e1b65bac6f0b63617b60b6b40e1c0a200ff8378cb77d09d9dd0bfd730a3cf19b3c4cc934d1b11a18e64d3ea0dcc91735958b49b73d1125c28edf3ff0a73fcb3c41d790f902906f5a22b56d40f0d83d1c4afda799f6fac09f8b6815fdd796e48ee719e7d3eaa36f27629edb90748969a3cc8e1eece73dc7038b1223add92f9845e2a31d5e84f15aedf24b252f3071e011080a2a41274e783d8cfd477c49d4353b8ef6d0b69efea8327534668e84b75ebf87480c8ee249df12172cb2b1ef82558b88a8594a95c2ae25c6bc85c64ac66070c7e20bacf7832636b427889aa51794366b6665cb25337269885215601f73398d240463bba2acac0cced1061a4f0e02f6fd63ee382720c2d3f43da3fc1fc093d953167058da8a4f9d776390ad836a8c69f95bc452b1e7188418797770136d8cbe08135505a5319a45a980177d207827ca5b2141e888813b33ddd9c0803fd80c34b568f76277c05aa6b1b7855098658a7ab0979fe6a098ba518a056df7daedf17f40d6dc5acd0185d12c5fa9449598cb114bc26363e21b08e46bb92d2823b75d7f55d70fbff50107a2a88c42534c71cedc4d9ed8e9be476c73b944f6275849cf03172fcf1580ae72854f9e26314cfaf44ec9babf761cfa5a0211196c79f258ae2c9dc6d8f95371ee99a919eaaedb86a0d0583298aff4d179373d763939dcb656135224fc0c4ab698eec1d06867280a33498e155d95f9f7d03d8b2506a4a7060d6a2a45beaeab8e683b9d35a2f1f0561b29ff984cce5f31587643552b0a1d2568020ee119997446212cad3f291831504480bd0311ff601395c36d7891e68875402eea038ccfbbd194359ec48225b537acd49c321fd2ea772600ecdff4c59514af34a2cb66c763efb35440e29c2e01eaa2e8c2f649b53f4a72da9fa00cb9108500d811f98e4a5ed00d5510c93046f8ee00b1c3a82ee5558932871910b19925de52f001b8d3fa4c582be6b1db3f729d1a0b2d83ead2c6d4ec5a831f2a0e73adae6197fcdbab3c0a43e8d55e859babd23fff0aa540acefa0b08404ed831ca81fd4750b769c418e13cfdfa13f7477f5c8305ebcdaa67a45961fe58644bee8d4a00835812193eb460eb6be40f4433ad509ba847ae398db49d4f8687ed18dc21998dabecebfc263324cc24a02e8f37ede89dea4776f83127c5c300a08933d1ed7ef6824700c11baed120cae46050ca67a6c597ace3be40acb1f825fe095301af99ddffd4fc02664e6c322eda9970fa88ff9cfa31e2241eb884ade8e76d983c02bdcfd2b04472f7038380b265b73fe11048e944b54be7243debcdc6cc8431dd2e013ecddfe250b95e95e4855fd394e144ce3363d585251752e62a3b5d05dc70f6017d632d1c8c464880162eb99dcf828b77143ca705fb69b6a0e6bbfbbeff06ecab445a3ddd888e1477191c3df0c1b462987875536dc667d95662b599cd7d98686301bd8657074fe9a9e7b0b97725c476a78a71f2e8b5da8233f35629364bf0c91e776d41c3967941400f087ed44ac239bc32a903bf17ac53347909bf19d2af027f08614fbe86f69c5b0d3efc48dfc1500688c10c412a77bd5c91fd3a0d03ffb9d7ff12893966973f0ae8e027fc9c05b0e701c2e35b2ed32d6d0e52df61db383126143a5afb026c90ce062770b1c707ebbbad7a760005a7f486bcf23ba1f084ffc6f477edc7baf0900a9f1f772f897e05d934fe13c232b0956cbd841384af1ab10e8c4edd2c1d23f2706fc4a57e0678d1e86607d913307b3afabe07a1c927fb0964a9f21a2c93bc8dc9208e138a535412e267ed811fb19f19835e532f8cef78197e1059e6271d3945e54d083ac6f338f8adf2f310165b71a27cf7c0fed6c3413ff597eb7813c9c9bad9589395e181229028eda79d0cf6ba4e4b4e8a31a8c80dcabf4ed88af5a207da7b320cb6252aefa120b002ebe3c56a62fab957987a2c056fa4e75dd36a85aaeab24e66a2376bc5d2d99f473dd7d857ac94c6990de65f7bda898b160d65a87ef31ab614f165074d757a440237e8128a3cf434de7c71d817b37f272a35d4198f6c2085537a82c5e595da9d6059f1e327bcc48a1e3afe05c91a7b991089516fad9d5c31e10e533605d6886c7eff4d06c2c3f1f4cb2f1002717f26b237fa540d595820570be5e558052a5693a98ab3b31c19e33e9e4b5c206e3a10398a50be296d8a1cd2d628b001219f43506ef56f4d9b9c9757cf09f900da5e316fd9429d9118c8076c9986c4f6f0152f0c15bda791943e95780dd33e6c6755b881a71dd12956d74f72c6043351d4b2ddb5de220d0eac767e76e3196381fc1852593c9619d9db9a483ae9e11ed5c386f1a6c48f765aa667e8d66526ac63bb900925bc8e5043bceb3ff11b157bd83fcc992b03b9dd291bb5ad7ce73440d04ca5535851f2c63072401edc61bee2f665c9dbb60157a353b9495f91849b45f53148fdcfa5346e4aa2a97393a06a767ff546cecca22057e83c8afebd8552bf03518adcfa49b94c091134314d921a6d49037949f3829480dfbc706c29e1b21a49e575be2297a8c6c50bc6cd3047140eb167cd1d7b6907455b40fd614516c74b815fc29d466a4f15ec4a70ebb07c81775a47d174c718123a6e6446c577c2e7a7bd2fb913e7340b76fdf7a98aec26a64da5db673ea20c996786cff48453798af5f3b3a2b89d68f96e53c15f54552f872b8abc2fe623f352931f11ef0799aa46bbdfa92304f0dbfd3875e489c8841c2d6cf1c6bea549a5c19d1385abe1d2d7b0946f0ea0991378b021f0a8c0efc29229d12d6a3c322e4e81efab48a78492f79e090fa8940025859fc7e85c162818793234643337a32e0eb2b35f8f89f6318884eef0494626f2d957e05c1b21d69c9a2b76823684fd123f85e6fdea49a90c10653a776b100353d4fa91b469c697c33719c2a13807f1ebc2f4e704d2e3b8c4706e69598d222adeca48e6cb58fab99530dd1ca71334936a33cdf2dd77b83b91ab1aed22a2a3af3cc74c22fd407fe55f2c78639a951a5d799352aa20f2055b987cc2b3cf3e64e7efcfa6cd5b9bdd3da0eece8cf02ad6eaceff53b7728dba26da94b070cc1c1bf4f987dbee31e62b6ecfd3bc58f566ce9953e39571cb354ac9971c081ac9972c11bdafb909dcee681882952897922876c039151b1e497c5fee878a52945b3b56f23156b81c603382110c4818bcf26559505e7a9ef29e3d5ae1f89795332b29040406e7e5ebaf74b30578cf2ac99dea313c97434750157b5d3a1dccca140602fcadbe9d32e46fa2bfa6a028ef3a8b70bfa7d3117eee1de19a8ed58751a20c999b38fa590b3831ae768a96376fd7ebc7551f9d45a1a905976fc6fa8367654b0715b04e5441837a6ce31301906d05844d6181645da57afb0a36aef285146b8b7c0c7d38aeb7f627912b69ace73f8d406a569b8e19838e9b8a6e05a618ff4c38472c9da236936f42699e2347bf6d0eb346dd911fc6cc59c67035a2fca430390d2fd3513363d27925af06443ac72eda6a3866d269a9426dacbe0eee6172e3ce42a2c0c74f5c4abc6986385975243a053c265f219bded0d9702512e814e697f39717ffa955aef6ebe4a499558b6b15dca959cdc10a9f1db8dd4baa812f30377224a255305982035a77ceae3ee2d1b46bf78dbfafbdb132215e6b68ee0015b21159cdf90f6bace51f8968d94281027013a6e9f06e7a7c6b94d959ba9c391be983b7304f6e4f82b7f4cf2fd0e927d15bc62974679767860e382b37e5fe8f147773da0356784bc15cb5a3effc4681401effdb974547e8279931c2324352341ce5a38a949bfd4d33ff71b982e2ba49be8169ac3ceb7577718234a736ec4dc0e2c27f57bd7f79f0478c1cd6adb131809fc7bea33ad4f937fe3e8bc622a8a15daef9651185f9a575c77d598e8386ea615648a5829cc6480e08469a8649e5cbf297e4b167502e3b7817ad3b0767e4e71338eb4ed9ae5b5afab36e23cd1f366b25e330b0d0a2d5ab05979b6d73528c4f797412d7c501d724e046f584374594bd62c9a1524cfefc0fd9fed7b1d9de422f143d4e1eea84360f010f33da4f61697ce6d2ef5133da7f0a3b9f3aaf92eac63e4fdc23bbeb914831dee5b1de3a6a4313c5a9a5e3ee35e155e4c052d2faa8b0078a9f9b81b200bc07280b7acfd172d72758a69b61651c53962232db4c85f3f95daeaccd1fde47aacc956517db2cfc2d277a7d1702b0db3516860a57d97b6f686d4a8395cf8099b7a84380a8170f1ff2ad69d00a25705fefefc06b5b94d5cdc0c2078d0e5142c62b071e64542038aed46a5d91f1c7018e7162621e8fb342ab2b1e3f7417b5004102b38405bd20f3e0d8480e723c51cd39f6bef617ae9210c5e0f75a1b1141e476ad4e7cbb56bb7c6703fd601642984104d8a933176458ac6b384ee2f5e5b139731c96de684b0b4e2397d1a8181ecd4eb788c1cd4fcbe28bec01fb152de486330388ece167029202037efc07c9f839286472f52fd75d431c53f0240e79e0ea51f7eff6f13c8ec97a03c11d70f1ab8e36fa8b029e84e0626f83300bde304e12009e4f416c0b268e2dd32b06dc2afbd495227b9db784960eb90d7ff347e554d6dd77346bf5f91631b94ec89b42c1033f2fbf2077b57b3b7d4974f8dccbc918d362e60644f4a9baaf65e2e43e5285636dd978d71bac9aee5373b382ce8e4592f67caa5694f68fb7a7a578c6b663dac86ced3168c5dd6100a3815ed65e190ddaf18a761c3a6662c86c5fcb0b7432475ae4dee50aa3e469431a3f630498d96785fd854f97343b57d80fda4af2ea6fde053a240019d472d7c700ffc68bc923227d5f78c7d21cd71230f0a89f85c1edcb9915f668aeebac9928d10b375f4cba3ccec6bfa587f400db9615c23160e3cfee270cda4e7ae3e40c39a5b58337cede45ea44ea3da24fbd598fee4da7bcdff86fa72687afc22415bcb995c78102018ddb5a72a18dde7f9012f7605061c31588363a21077836910e47492c89ae26c06d8c020e58d749483d0346eb13f153e21a56fdabfe825776a3c405780a0ff04e71ec97d661a7b18c82b71fc7be045f397a31b9d81834ceb3b62c8c6c82771c711f6eaf9acc5bf8f98cbdfc0b2912cbaa6c10f81c33619dba37497442ffb68ff06707a209320322fe167db86f24b50eecefaf2a5144fbe8c27c3b1c8ca6d792c313b7fe6b20aa72ce7fb6eb93fc6f947d0e8e870c2da0f89bce7624276974b4698a929d8fcc30989ab7016dd2686eaf1e8781fd4058627d806e52a9d0b1e6f93d4177c865fbcd93d4ba98008fd9ab2e8de3237bd52aa541bae5fd649172bb404b48c18591795169c2e3b08308d6a090a5a5fa17d4132454b39e5926c18b7d0c4ef8104fb72a1f0e2d7c0adefe1a1efe8d57876ec775198addf398e1b66d163aeb356c7d6ed514d28a9527a2414dc8d1f28549cf3877f02484f5e403f1cee67004a406177fea2909a608ba34f5f2db1613052aeec6ce612d9fe3a31121d214b0271ebb70c50b2ea8e8711677ab289b06e326d790c6a1d10266c75b9f5e8375035600083aad8373fbc6a591b25bb0cce7dc7308e46f609df369456d6501a07ff3229d387beef4cdf7d2924954f1555141e99276d15548066020897e7db2659c1414d10000da848254894d7272ae113765d4d8dc4054d3ad32d49312217dcdb832f436f7435e0d56a0d48be914ef956fe114453d877d45443c83dc419ed7e43b6e399ac5bf8aec29773f0b3f991c31275449b3a44ba0fff154b070ead1772b67459f189392d63e62a844ac84014e3bc220e2400e57a1581483bc8700709b915c9f7060ad9e334aa38bda2830a22e3f020d97bd6f1d47847efc5ba7673f2cb58df74e5923de998a1fe0f66eaff02a910440f170a309481dd0e75b566a81d65c48ace0c2c71c8af413f5cb0fb9015d4a193c5809cfe801c3f1bd74a31e8ddd1f3b585a38d02f0afacfe714ab077288cbd8a79f9e26391beb0dd6395563a06879b26ca9d6c8a59d989830fab8033f975243874bd5e772b32f34c7157f4075050797f163a54e1157ef576c668037ff0dffe514462217a73f0bde7bd2dd2bee19dc5e6b1a029887ad4abd43ffb8dcc2d76cb7f5e9df377915579ec3d7a49c6b16543d5b9ab990c96ec8c24392f0720af93a1f0ac56f21e6f6a4919d7dae578bc49a4cf017cc540f706a494085e5309df05fdd0f0af30bd28136f28e4166409236c8bc573030f97e28cd391b05dda8e949301678f03e049e036f8fd4d9555cf3bf7a75121494bc17b15fa5fbdbece408291c6b27717c458a4452735778b35c86e1ae335370398df8d64495e5c61382d9b766aec8541827d603d02d81986f63bfde4fe30988f76ac25478d9bf7389bfb51222cba8dbf745ceb70834d242e0abe22304a7da81ccec56e8eb93bbb7382aabc4ce2f5854d3ce966bc1f249ffe1a9b9ad31a1122d6bf0f7de2f98c23a07c5a8396d5ace93b8bbbde6d0e12d7763c6f34c5a1958218f6a731c3234ac7f45c0361f5d08bd9d0fc661474066c21a15b103b365bd2a03c0c6caf7ce37dae8b6f74fd6cbd367e74580ffc4f9d4015a48800bc9d997f12a3d5f5a99dc52b187449229c56422beea5dfba4d481c8fed554f3128eabca4ac7656c08049166e80a20b7e75bb92f455a42e3bde6643b6578b418de9b215c493067d469ebf614729d48f1f4c54e6ccc0c11a8469fd3480cb5f93db4a4736836dd417b5bb126a19b50bb991bd2ccf53f4e845532a007e45a63cd5dbbaaf07e914f159f133262d9b086af3ed4e659ded8bc7ea09d96ada603abada8c7cfaa1b8677e3efd1d5a70a2a408c5ee1decdfeef2ebcb09adc452b1be5148238afe2f2d0a39a08263e946f29bc869acf1466637d05bae5b93adbe7d690a1d9986ac0df64641d05d2ef922fb79892d9fa22c9d2e62eee506628b097c5bdaae1615dc48a5e71ad8f48d56073bc9af792d5d0c4c9ba1160f6cb0ac8a96a9167cbfe4ecf056fdb10f7801f88b0fafded486a0bdf3c8f9eb9e0b74f3d076398f56bce95d40ee412b39955ded54c3157de248befd0597608a061ff8e90448d875c598f487e7519be14fe295fd70ad96fe1673f79b9560643fc5e5499c2019c1ae162cb614f916b26818706af06893d5d1bf0035ab736bc5cf1cf663cee2a299147c5aaf509e29b0a6d8e837c51c629507f037860f3950476fa9635bb22eacf70ada1400c6dc6b1cb560779ed1aa2a049978bb849f40e6c7b3d575792d6d1313a7190809a9797b705fcf28335312a60654bfb712d24c14a02d35e5849ea1d61d61d78996b742947949e8b013ae040337cc46f8f16e1cc9256d6a236a8250e90bd2dd5e8882baadbe185215d3f038685db61f07d4d88eb7a4f80fa959323d7b3fc175e510eb3ffb8fe44f0517e617781a25e1d87ef1c7f70e6d4f5649d7d0743d9ff6fa247a25d3da71accfa66a83a7da35198c2623663f950cc6ea01f237e7b5a8642ec1d5fd4d54bcf6f0175b43f3e5efa2a51edd08c1604d2bd7a98e1b2715b0cfde5a38116ae40ef93c78a87e4e0be28a6c0e9e2f977c2a2e9552bcc4f133e5a219aaae7b0d590974e58a66ac3db4ff97ebb5f082975d3cc2a854339d065a187d8f65c370254d6dd016fd73daa06d18640f5049b831ef44c0ca50c197a6a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
