<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b2cb75d38090b17291c25b01f9de5f3a66626a3c20aff1a4b554e75ed357de5c51b8c7d67a60ff94bda55f8a57498be155fc61e384682d2862b9ba29cef73c19ec8204940d711fdb2a649dbe560db3b80e7fc14b8518046aaa5bff4f51f9cc4e470b71e12159ddd67456c99de22277a0e6b6d64e68734bc9b8cf6d916e17b25568b19165cc1d502ce54ed4c3d83aae0e557508a56fe270ab2a3e7757f7b6bc9002918ba611ac6987bfa6e2d36dbb8c4c6057e01ecd36923e88ae89d0206e6a062d75a6d7622515318fab01d8113787cf5b7207280007e3c96a64b4654be84463b7031ce37887bf7bb863b410ac71f3af1aa1038b0784991a1a65729c4565d7050ac7e0c50812dfd40aa2dc74f3bcc85a79ac4445aafcc36647031a66da71d46d695cc627f35a1204f1adac2d2f1232f99699e3867527243d72aa5cf67437e733c75c3003aafe0af7a5ac7c7207ba19dcf9a0643f1b4c6a282d7369e96aa3a90afcc1644bbc5e058e6906a3c9f739a1c5d86ac30c1f1cf48653f6259f347668ca0b209e263e5b2f1e7af1de77730e9a2640254625eb7bda89891fa700a0507a86ec77d565babbc531e1385842fa439788251ebee39fbb9c29f5332b5a7698486d590c5eb76b5edb86dca35b0fb0f699e60666050411e74f4ff07915d1700e47907e4247e8d5bfd5470679026b70050fa3d8b04b1de52012f505faaeb8b70ff517c7badda8e926b278a9e3788be38a4faf64f848e5e065e86cf6ca924d36c7e994748e84264afa4a5bb38b7f4981d94122a8b8c4cd6a6ad9f93b055570970c4eb3a77193b50e5b25949760e1fc8d0d0b4c0c01ca1ff256e6fe9c5a1abaab3396152029312f88f0ec2c3cc0745188fae5aa35e5306776972dad3beccdc72f4288160b55205e42b8355319dd0576b2e5f65ffccbfe93c4b790b0333ccb5bd21a61584b4c9f21e2006e9c9539cafd068d90afd6041832968c8f9192d71012531d9efd7376736d83d3dd13cf7cde07e6bf3f67e08fc7760473c1db42ba1cea67228b06f8aa3aef749a0ebda7c3cf198d6e0a9d54d3ae786478f31a59613df35d96212c14321fc2ffdef9b9ba4d243fec567d36ec9083b7a2aecf7a695c3a59333f4d181e1f23cb32718583abc57a64f00f4f958bd62261ee4fa0acad23a899bbe16f4004f3d4ea3b8417267c8f9f859c46c5d7cc538eb4f1506ad8efa2e83a64ae2a498d455d680a94feb799f6fd60faa7af7fc27372b0089300b2f676884c84fb97f3a463106411e052e0d9bcdd541d01d2fa54adc196316e3de07164bc6bbdd2b7a154df38998fbb9e5fcfa2faf335be263e6ce5012ef811c5c27265a74db3dcda33464045279c664f0eb71fa26921b5f805aba178ac0a58e287d28d1bd6f244303d0b1593789f630684939a0775f2f230b0d1722e55fb8ba99a0ed0dcb079f4070a32cd190123f65345d4c67317977411801f95b87dbbb3bbb05e127c03e2aa93cf53db9861811df38b05f9073fcc35d033d54df75f02b0d8246b4a3fd5a9e8e7b3b2ce7257e18f858efb6e16f422554a32b71cd56bc81cb8b930b33afd0b3b72d1a92e5b175a59b05753771c3fbd3d954619e6342ef60dbea97e5a17fe80f5f3270d4a3788aed05f4fad2d74adfc4402c19151f3516025c87fc2a014134c350db2a8acdc2cb1319dc8e0c371438ea695967edccc97db282972426ba884a8ae8c641b358cac295374a373555f3ecc0c319d061e423dffb5ad33082680905a6a26758a74a5d8eb2518bc04476904a4aeaa71aa14cc77ef2452ee735be5452444f7f2ad69598ba7c0bb88b6740722d83349279639c9765b47d353907ea0d853ab6d50fb5e0e17c4fbea3e61c57896de6cd77b28d44651a562a994b42179e88e109d8907050924f801d30500609267ed3ec69fcdee5160b67ffe115634d67de838531ea2c430850d893533ebb382151f02075ad7dc9d73ce99ccfc8594952686c08e50445545fd5bfaa4e75a523620310990357ad0623a7ac553468c95f6362b0d887297f95bc4335b8ff771e055d5c51dfe2fda3f32709cdda45bc7f1cae14d31e5390f4d69dfc1623b14f4339fe76d204d3655654c09ce9f40466d1c4b20ceb0a6df5c56db3319dece7e85d64b669384e37030288a788d452eb5a50a9e9130cb8110aef3901e86df1566609b92d679aa70d00b1987a57eaffe3c73fcdb326c16d554e5a5f4911354ea23f6cf3dcb42c46d24d527df147d9f3944d6afc3172e177d6686912c62019321baaf1bbe7d9f86b0cc47ba29ba0f9800363390812d47bb5b82eb83c604193d22956001edd967536f896c719dcb2eb043a5b7958a7d650fd1acd4d3bc6495ac741d2e069c9a52c46a3d76b6a9ce2b5701b63ea4419e52a1f31b3707bb0b49f6b56eb016af96250c181d78f917175c973084f6556c4d3e21756cbbaf416096648fd377d2f1b66ecf81020ca1a259546a98aaab7a376825bd3d787ded85bd939fba446d36acf8da6576d4df8339ab970bc81469b2c551b6c14475580a070800ac6c920ab042a9eeeafe19bead9ec44bd3d65f94f6ac1c2a6b1b42bbc3338ae2af7f36b3e442ed2dc16cc7255c12607248de6e005656b29ed492d632eeae9946649bd9225d7ad793903b00e391144db0780dc416dc2604ba784fe8b1b9d3a4c354fd8c674864298f676ab618fcf2438ae7ccf5258fd5a094e71d85fbe53adcdbab90be3fc53d382a91b44f641e84d3846d1354a234bc7d8897fd01485340241000cf44e384e93044f84edcdcb6e16f757d7c554d8a0493de1ea241769d7bf568fd97b0a4438be6afc70a467e24aa6dec4989901c1913587db155044ceb22a20cf6cb6e01bac6e579d0a8c5e93f40f891da7be6c789ecb393af13918caa53144b07d46a46febe0cbfce469372712cc746726e0083a22036f24e07377371a2ad192594cf00198a4222f159c0b8c2af8ac2b3b07ea25253533c3877dea0691547601d672e7ac220c800b427d2fa8216bb6ac89a582a81497f46e52881288bba095ae551562a2d66aeecaac60c8fb058295b3912390970d4c6aee1f8dc9b1d1297b184286fe6595f09602b3de0a3cefa4a04dbad2ef402369accd9257905bad35b35f8c37956170381ccb0b4853f0b848adbb5dc0ee19db1bf43e13720b4b299f0378e57300e6484e9ca8e3cbe3249333f97d67b23544edcf0fbb8d0a942167be4355d9453cf78e2e7876ae7475c84b7c79b3a3ed3bdae1a5579a2b885e2390aff8d995deccdd5def5631213e46f30a89b2a62e3d869e89d098e4a2f13292811e7fe57ebbd72cc093cdf43f9db3283064b86550e0e947b6e78f9cc1b142c7e09cb2693c65cf4def4b3fee98483a1c054c238bd6e96c0d7a898e9d95cccb386946e004c9b01d305147883d5c14dd4079b3859aecb62399813a5d2c0532c2e31f88d05d13aed7f9508fa4751a38458d6d315a547a26ccdccfec4c16ca608b36168873e737be49b7f8a43c0de9cfc3e65690fb50eac4827610c79e6b4b27e9f6befad22f3e29110afe54eeaeaad4eb75fdf6864f103bfbc4af4467fd13244776e877642a3b63ae450257c617160e71f60f905042cffce69e37a1b1a5dc9747a3a550a757071e074e0b344b6c962eac860c4d6dad7ce80b2734e0b00fbf6fdcea52fd2b96b82e57874ec14b04e6d99016d8b45c4f451d718a2dfeef8a60edf57868e4a5f69e5b57575ee58517ab3277baf055f9fc9804b2d50d216f931aeeffa7c68fe09544c1d0d46c413e79c9c1f7d462fd5851fe28a623ec0990729902c90667cdc24decafe9b4473aef7924aefdf6da0c338ea57589e8565a1fc89e1da443824973b51a9b68631c29914c9852efc69943c10fe0a2220011e15ac06b1429150a5d12c7543b4d495dfcab30b3dbbc68e2d7656d84ffc7a7ab75063bfe54f90b50e87064da414a0b5d5fa0e24b57de137f3f23520267be650120e34c6e7e13149ec7242a93756b58ccf1dc4b26ba7faef0b51f2a53935c67cca14877d92eefaabdcdf95b60f284461f5621d7d8f90174b40a133a5eeec87fd3c228c46ae54e856d0dcfa8ee159c75564b8a8a11902c999809b96cd72187407547266bfd60fee02edcab23d1b670c349ab285728351512c6305f3caa14f6367688d8df05f4a0aa3bda6568c0bd5aa424e212c61113556c97f30f12e0c9e9d203a7bb8f3ccdb663ca2a5181330f6ca9e3c6bcf1b7646e8b830717400b51de115cf92fe6a13dc3a0258630bded44b59031e4e51b073b4dd49856437480999e16f1164cb4011128a42d5ba62874b3e5d95a42a7538854872b1c1f3aa813ee9752a66173c3991ee656dcd355fad2c5523302cb6612b584ff59558347d382f36af095ddcc31d5154509e2dea8d5fcecec0c4db4dc760a8718747876d87ac45b7c43018a8e20c2d065479b703d7ad33ffa1f8c70d8658e2e411b74be913a7b06b919201fd77efb5ea2539ccc7fe4690d036b9597ebdd784bfb89b96f74f82f6580b2534825d6c3e7897940a8e36a62205f2f47a236fbeffe23e8aba77618d9afaf01c2ae956717d90c1abfa7c920f26f488ecb7e584f5a8b40262c4a1edd579a17a6fbec4f59e194384be734c3fe912040a41b73d46b6c84788c241a8c3278d572c941b634a88d17a57741c69cfd401239e81f650079ce085cb636be06a5698a3ddf9eb057f8f3cd39472d1c582b1ad3115cda9a7b4dd44ee0d72b5a96b808cc01b2f4d140a52bb44afcab2b4c1b1999df4059c0197572cbd073ce7a67918abcf3f0f57ef4d617dcefe65c0b443600e357e88fdbf2504cea464fba3331d120c24d0503e30d99cfc4ec72d8532edaf71c3d4e3b9132ee15e2427492e405f449428d5346b3fb2e4b17279bd95b2db474a5b71d9dcad8b5164cf68d7620cab652ae6a4b944b1e300bef9350bc526d871bf5c3ecfea2150d26059aea5a53c9a585f1acac963946431b52560e97ec205659bbd67d6cd0ceef33c8fa433d7eb45fe8f295b2d61b1ae5496b526370c6a85f8b6fc21979c3e0b2a83686a3409ad49e46c47ede0540e55daa690c88921361d705a29bc958f34e176b6451a104950a79436ecfd56a74ecbfcbebef232777146ef74d107b130d6dbb8b11a1f14a56d6965c9f8a64032d9605bcc90bc549716c1c333990c06e5a6b63a1e6222089f138ce26eb934c9c62f74f6acc946f1c0142c0df3b0298aeab155aa947a4b1148302475ce61e7bc8fcbe75d3d13708e98cc817a3cacc4bccdda1e10c2d36d84306874509e9273b8ea415a60806d5c1f312ff4d2e865c9a1c28858302d224fd9317373aedf6878dbcf5888195562423e653b7a00e5befdb3f1252075b688db6cd5e4850155273a5d834d9bf80ebc54dbe493281f453cb280a714b99aa93130f756016b873069a6261c8b25b33df6486e6109d592a4d794a0a527e51424255046476bb5237c0ea8f7e30809e757434575f4aca5234852633466373c3a9a7fa0158fd5a871a2e315120c3e7ac5fe7b6582d55e41110c6f86de345a7d71e09656532f1f9258016d4da503275e59b6884c119c1fcaab75aba1a16cb39fd4912f7952bddf5d94ed3c7c765c4a709abbf11869f7fad424dc35b43ef3383d2b2b214e49077804040aa3f63f3f93f4c00b749b248879b41df1e044d0382146bb561ead065d13ae3821102cde01bade7090d7c00daf915d26abe8312fa60fe40a8db55405e7bba2bd22e21751cc357b47e12a7060c563319fd0241f5c9dc9a032cb0b3269b736a963768edc6b3d0f02f6c8281cdc037d42e429a9dd38d51012167992ff786977626b3574c0754f710904e0a7174a5a08828e04dd578fad39b3d4113001c712ca2704894994c09dee6c60beed54a93ee16db1cf379de66be78de9e83db607bddc63c3154c15b2b37de4b9cc9a01b6f7bbb0a75d6f1290cf7256c3497daacc4109247f6197e4fb13fba2906e1d7ed45105cfcb46b40d3726de780c086df3ebcef81848654cc1cd20f36911c8c0566575099feeb5bbde2b649d4b463917d129ffe61e6330d6ce4c3f5eb7916eb404cdcbeafd8aba86012f688ae22ff302dffeacb96b9a93a968ad6ec40993537c8591173bba611f20caab066a37e604ff47b0742ddb65830ebb1c95e3cac266a685fd35b5392455e60358a3621019937343b9979c383675f5648c710aef52b6c5f85f65b037541df242dfe4b96750b4e91cd6bad4ffc2d0ada527fe8aa89f55e6149e14952fcd07f97c263085b50982e08db872541d3e9cb71c9587d312351c4b46c6a7db9f29c1948aae21af23935149818c0bf32f272556b4d929ac19d45785b0bee9e48bbdae2b0c8153518156293572531cdf81393b21ae15e6e2c803ec71683e8365ef1d5bbaca6995f303f53a50cb80b9e6f25792f969bc7988626c4cbf99722dfde49e99dec3aae7b4d6984e907d4c0df469cb993123dab1e2718766f4859b0154dbf26762ee007e4f11aff2f47cb773654a9294300a3e8d5335aee2fd618b169d414ef9ef7e1368f9ef734fd25e244941957977c0bce6ffefac8be03b40aa003845b4f3bf25723b75abd582151f59e92eb1388f8ff013892c183f7f643bdf422d5d4259fad953df29170019b6f0c1e880209d6ae6ee79272350cf6d5cb513288a76393a2f27549c0b3ac9c045319c9489e22ea5f3ff6187f1756ce5a9404f26040f5ed59451a43537e9533bba8d8ff4a20863fabb4f5e373db2db05f4883b45da245b260787697e2cdf8e48b8700e37e3b7bbd3331c506cabff5280f0efc679fbdd45640aeadb4bfa6ffbc5e12d8628ae9138bf7a7ca8572d1a6e06254b12e8cdb56d98a7dbb41fcabe7dc002c2d80c6174edb9d08e5b831fa76e6c57bb0ca71699117204124cd544882c280d1a7e1a42a900315a5845649e591a055de468539c52e621e188da4b86e89d80e8e1ff045051fa885e8f7a0329adb3c1192c46807934e69aa46568a88e4b10baa435e39b1f74e6fa8912c6925a32fff6dca3675be3d7f970958aef80c6397add115c4224b401350af1e9f6c6a5a8aa5a491c448235d802fff72427f356d54480940ec3db756c3d7b6b3497184a413bf727e741028056d9a0c1f8ab53812bf0dcdd02cce3dd27b2b293eb90f8172c89032f6a8cc44e52835a4b6dc6cf4c7cd6b64a2b46d1382a4ee6d06bfe5a01313e87276097d919ff74e488e5507b2be28f1c6be01e17e96b691c7b7320b8e75691518e8d5b3d45c15a6128e487bda41dadb5b06cf2eee2d957c1dbc3e2c7cc5c4464990c659faf86f62bfd809c3439c73e3fd45a3676e7cfa5df0943ba5b9fc997fcea0ebea6b2d17be8455ee4e592b92aca8db457d0263f771c522753acd7623ddb1742408ed359cb3c47f31b2eec74abb7a21dd311b2d9989c170da1d4264f1628833cc19dc1fde042d791537297ce30978b019fb8dbad7c8fdf307c52a82aa4dddee2a1d3c9237b9ff90daab5a3cf7be8751f0b743e0d6478654f882af6677cbe54087fca8e517ce5aa7c41f24e4ab260fc598689cefd71647b384663332d2190aebe4ba74865c84e0f113c0f3b0ba088422bb5573fc8593056a9df76a09fb05d7b81ae0920df9d462dabd9b8beddd70c78e3e7fa7b128f5a438904e07f640f890b02033de0fdb6cf75b69cc1c1516b765d597de1718f67a66f157ec156f7a141e44e72dd37cbbdf9f5cfce0fa3c26cd88a35dadb84b3f527a9791a24c26627c26ce76370042aa4f52175f5eea590c7b295d53842fbce74c2723809739003ec60b87db563f76fa9b2795e2260409da471d7a535c0976393ccfd17392c1f2b5ea3ad02f94013781601a62a837f3aa3271257adb211d266b173532d639107258fdf0a166be9b55ce2d2fa7057f37232754cc5d28f392d4e3e9c894bb5362da1b575986b759b993a88f0d61efd3e7b412b5b6a6a14234223c2db3ef434cc08856c548d7059458c992f62df188e0012f4022381232d129c00a36c80f51f0cdb9241a7c0940dae9a55df8c3b086b1d60bec55f677e8f0a5c898c69d29e81e1778af88825f9bddc21ae1013c9317ffc03b719fb4c9fb48603125ee443b49d4fa09a1886d066fb013c676ae798957441bbd1d20fe8c26c912b1ae99ca022c33e522defec071e3fd3a159fa5db3fe4e4a931263c3e1022d9f0ad9349322c978876f148bdd9d56ef267fd3973722345b0a74fe039f1959f20c8c9bf042bd4ec7118867b734a12c76694cf733e3112ed3264c54b346982d7e38d22baa8bde902d24352989f8e35c86a7f9ea0204973e2130fe427d9d9bc65a52cbe057534e82b8df8e4f28c94fe27f235d269d8f18065b6fdbec87438f6622ee093cb6e703b73bd61ec479c44954d53937fae91fc4adc470f7b58f6f53acc98ce8ac4b2ff35f1e92173550ad1fe0b22d3619b4106b40d259d79041c223fea2b21b4060068b2e6b63338cc3cc7c3ad995ed8eb68827c6ca3a268902ffe6860bdcc64c473d002ce537cea4aae6690da0daaf78534042d538ef74b71f0b2714e07a0741497bc13626a5a926605887aeff9d54856bb59044a2510f484a139f93550d7b69f2b097eea4570bb454f9a904144d3745b45ae17e97a1cab18fd75f6773b9f29f581ec949bf26e030b9f2c66af44fcddb9b1add46f3e5baa4f22e92c2b89689b754135ca7dd71f24017e9da4b540be6d8a9e0abb4649c1e6bda1dbb04d98e97c1ae7c9a967c5d26d2e9413c3c8ae413f4921e2adb96f9d25e0dfe52c662accfc00d1e28ea20ff50f2faa013961476d73e8873e082174add7b9984e216ea710d5e316439dbf857919166cc957c90bef56862b14ef1532052fed522d45134594915adbf7e3e5ca559a10e2326e691a423260119db3d18d9c31835d842b4a5ac9241d2fbd160a8f5245c058f9aa74b90fd6dff5055d2cbb2f7c8f9a564b761cf59428e9775e6e624db998e7fcf61c428c99b536c9fe2fbb7c761cd3b63cf3e271812518a47ed9ed9008c2a4896acfcb2976d1b2934126a3868285b01a4813c967356f5e736e9ee6787d545ce06e37ea0d09449f197760facfa18bfa605e3bfebe78ce59a36d1adcd98e34ba778057aad4b06fff3ff2c18bbb8da11f61eac1a9226c2a9b8ced958c9c654e5894f220f6edeb83bde7010d9bf27c83f4551e1860e93ef5dc92cb5458c162817ade1468aa09e9f958958cb447014bcd1b129cda343a610e2a1249e42acd43599072bec3aac0c503c7853d97043e9ccf6a84692d2803a7eef5b59900372a48ada5c52222ffc936b8af8d27abe0142f16ecafede93d51170b7e2ae58a8f5ac0d8bdc3b1b765d71751b98176e419361c0a0e45fa67773271f2d630142ebdbc5835a845b92d09b8d37e11c4c2d7f838792a0416aed61b4ab02f4b25950deb4e7a0f13e5ebcceeccb90c6f33c288837221f432b81f8ffa4c3cfc215fe42b89a353aa648995b93d20a036a01e66e48e2251347088fd48aa8ced4974c6283808d6f97560be35fd829829fd26194c0df261c76b2b5a91df48def175ac535be2da4a9ffb1143a060bc9eb51ed4a2d204774038c9c4eb227e2930e8e004e9a348eb0c85f53d7bf536d903759cc4096e68b23f2b11009e99ddbbda7e9b18dd25a845ec67969ea8ed95dbdb523148789d52ec759ead734de9b6ebd25caf3b09758817493ad4833d5b3f16a142e29c1c6d0ef9f3b967bade9f5a82f1643792540cb457e2b8b8ae5e6d8d76fab9ab8961e6252e9c514c587fe8f942eb2ad5a3876ca11768bfef78a6a23ad5ffd0a2380e2d184b65fa4dd9240df26d73cde40fc5c08384cceafd9fb1e173832d38e1c8de234dc207e5be4028f056bff273cc5391435d1b35b83f5e1b423adf28a66bc1744a4fa850f3188e6fbad5a4643abe5054db46f6014f29730449a9aae52d80891381903d9a5bb04441081c66f9bdd0f670803705365720900c94be1ee01900edb9f5baf2af0bd32fe8eec4b7a4b153ffe42367ca2831f59d7f3234ed2d72721b0a3e8a7edf24c6d7d18a1c90067c82ea43b609130b3b93843cb51a639a20de41180f104001e48ff8221862b9c3d4d6e1c220891f60fa12c1f3c1c035d962d90b3c5508b0919a84ba6acbeb5e1df8674fe53bd3db4a0ab1da738c43ba23fe83c73d1e90133be136604e511d194432c3cc49799951b7506ca3f6330a647e39cb23944faeb84ffa624451e97a409d42e82623a8a30f3b2fe3b9a4a3d3d4b2ea72d7a5df6bedc06e4ec450f58e35a8ebfb621f0a70d3f7d2343de3476a2f46504b20a273e6e31eff6b3e948dc908732964a5e1438f828015086d0b46ba6ab12fec791405a261121d6910ca5ac5cff6701800510290f1f7789a0e36fb6db9b098a653781e329eaf2fbd07d22fb6e6bb31f1bdb8bbe58017cfc04f57fa347418808d79aed73ab482269eb9bd457d27a08be54728d25c6bcfeda9ed8a2569537bcd9a7e177c4c494f3747bd3e075b9486e2d0fe9d5cb0fa26bcb9d31cbb3469c0fe5188ef1153c5751640ed5eb852f08e98f0a467ebdb2657d659ce833577ac50f09618b23b7e38f3260a235028d043d4dc03e29c36c06d22b317e07faf37881c917fbff5fc4ddfaa3888357d7edd1df84861c948bd7a736373f2c2376a9e3115d6ba37e065c7d4afacdda44f327246a14deb92069ba8267eee35d8a434cd7b633657ed4c693d5e1d30190526a32c0e1790c7a9422c734b079dff0e3872f00b69206f29c2f870865a6a19756ca4f52f425d6c00ea6a477176fa409d2129ea6c32231b4699affe1745eb84c4e65bc79752fb22ad983e8ce9ff60b1c4eaf77faa7ac42086f4fd895720a7e3f76c21fb4a97686144ba5f5ffa1f1789ee26add501fd1dc91faed1f98cd9f6b1dd3ecde849f361f7d5a5338e8288bb15f2adb71ebcc85c16de2d72e5df2c7003b87c624539cedde8ac97e4ec4374206f26a43b2638bf1458ee735fc3b6542f8da27653dbff275a0cfe05a621552428da32e79def4e449949d3aeed465ce1aafc0ae31b8080fc6546f6fa6cb1a3f8039ba422e963e2ad8c7cc57ccb7eb1052a50163edff953afcf12a1304470eff62fcf6833ac4c6b0b87e5c5d255f3fdd6148d20cf3357c025e3c8df1dc443bf533835264f69920ad62b8015d09efb37b8e0dfb2021fa368d9d099ba974b5f2e96fe4edcfb3bdc94c2911db1fc8d18d5a90d435caa04850e23501e79b6174af855e1c26d27fd1746343c2dabcdd0de6f5cb127edbe53832e35b03b14831053ac15833d90babbc5d93f1c886e4b09554a453d244f636d2ddc85827660d079bf778bf4fa3cd98441e6b60411ba74ece28eb5b4fd9d77fc846f436dcb15aabcfa1e45e49c3583b80ac4954a16f315aa13e97ce3ebdc5950aa3161a557ff4db5dd54833a539819b029e62634596a99c471677be834de3c2f8990736c2fe85c47ff57401d0632928464df6282b3f7d6ae514be62017ae3c7c73d3a1f9febf54a455b415c8f3af2e12d549fa401d9a36bce2495757ab1fa7c2cadfb8ea091e48f0cd90cbaa3bae96f960d1b1b1cae312f5e65f6fc9c2700f1bdd87a15c9a068e79c3ff60b2465981779ca0c71ea79ec12bf6663238f083ad0c63d514d16ebb29c4b47a02298dc11db107bd58634f07a4ccde566d040d08a5e8baf98450c5a9ad2bf994edd5ccf667e6d5725ada333a7de367621078ea615ba2cf276718dbc7899173a47b2fe1f23ecb9640cd7464889ff58cd4c81269e53382b99b76f26bafd5af511046b6d7ec944bd15d73503c9f55b7ecbf119ee4b5ed258ebc752e902d770668934f529a1ee0d6e967d215601d554ea6fb870195f30fceb87044ec5510f8ca65a380061d7d74948682a92310182e41f2b4c9e4c66f1bb3acb2476a42592c00e46b27967923af030e36f1f5e94296ff7f34ebacd7a013a8d3f03c8e3fa99a3ae63113f06a22ed91ad1ab0778d8cebdc3b803e1f5394e81987a8233a8f00a0cd07bfb521d1259e771e58475ffaa502e8da489796cb72f1fae07bc1af7f7adf89e33f4ed682a14f709e042d43ad8433ba6eed8a63c037b15842f5fe5f7dca387bd9b546ee976985935993a6a159454c04afbd59c305e17492e8808d86e799ff47255c8ccaa945cc8d1ec429a715eb0df2d292ac1e871a72f7edfcb55ea3b73848f94c7a585b50736eca72e99f18e5870481634a31d6f634334c1e63edd7c3b336550839e8e0280bf5b3b82714f74420cd9041f47957ed7f1d2b2d554459d814631b6c0504aa115c9ab9802ef070cb408c5810f51f90132f96ba1ba747744bc7541e01d8a3e18462657e0440dddb6c3cda7bf282cf81feaca98e94ecfe52969297cfe9ce078237fd64b6b9ed0f9f0ea9a3f68a9145033b4fa7daaef3daef54f4dd3287d8691da1e858cc4112290d074ee804967a8d1c5ccf913d03662f335856373045a2f74d4cb2041eebbefa1b07ba1b1b4adc303d3bb3a10c4fb4a5c47ca1e9b5df1e608d064b2991d3aabe0d57dccb94c8ea120d7be51211dd918bd7199e0701eb2d889aa1fa48a7d681fc1e1f0a3013c24b8ce5dffda26644be6e92cabac7b689b0bb42b19b998f9954041e15984d994979dc2182c3d97cc018ba4e032b0edaab1882251b721c8413f0e9cf4767c4ad2ba6e225a651de27715c84f02a7a1c49aaa3e7ceebc678bb9dd16e8439c165276e27ef630f9eb282401f3afd2022e6c612f2fd57801cc8d74d8909f6444dc3bf22c719d0435ee5536be1a90b14d9e0844c784232bab906a0122873d16e036375f9c56dcd8f6d949fa6fd1046c96b8b348db57d1b76053df06a26d1871eed8d56665dc51e923c94a9ce9a780ddff1c4cb6456efdeb8c227e820eb69969e03687e2188e2f8bbeb8da9a83eac04741cd7f2512657a959d109e928a21b2849b47159aa1dff66a33e14d40230f94bef3efd1f57205179b801c0cbbad7466c322bc9a3f34a5d3db3255a7d4141ec438673958bc5a7a84efac44a29660c2b690228490b8aa67328f178c864ba3211ac819a635343687df0856edc58a3066425dac0a8d170d8e9a355925bec6da68f3e219e1b8a0bfb19670e4da3c9962f4c48da3e8a745a9a10093f230202a6474106aa05bc3b3e73ea9b91b871cc64fdf78f29ea3f5036a84b645b16b051a1d56d986db4efafe1bd1e43c060b36d204e4a74492c1a46330bd8989221b1b63fe86b3377d8271cca44709457c92ae545e2c781794314864afe164ba08a2bd1bc3b80f15c22bc0ec5f816d873f0d94ba10cf3d2d6720fe02e86c75befb06a7f4dbcfc34a773ecd9eb5252bec80ad13ca3255e2d5d3b8a7877793be908d7efbb7b95c6542b5f2294b316cfd5d2a51ae45de52b0d3c5c0cf28ccfdc6c81ad612aee3875525fc415ab2a53962cdd3cb8baff9b08aac8715a4c4406c539755ce4b97cd4bd0e40942b0279e2940ddae10b3bf67299c0ab470ac9af706f8a08f564e59242beaef6079544ac695ca14a85ce471f8a80463eda9044025b5426f9b18dde7f00fdcd8734556ce6d650bde2c3792a9578ac6f396302746436aed5c316eb3ff8eaa7e3d9bf89e4517fa1ce4c77ebecb43f193153572c05fc3b6c87f0c8d1443e48430c2b1b9c2a2bf863763f3804dda86f1c4bfa4fc34c345464ba407f8290ec671522acc0c3a45eb2fc63e885cab63aa1e5205939cc78128ebf8130575805c391963efe2dcce900eb5cd41aeadfb3bb6fc5f4a3ddc1e3b84b59e982a259653460815c688ab2b04af2cdb0d1b40a675479e7321c9b57f1af715574f2e2c34ca98f7b5c9fc2699f4aeb029f27b86f530ed4c59d1299718d6e0af621cd7eb604b3a393a1a270929ea764b6fdda349bdcbf8204435338f1ff326501eb43812aafd9262baa6197873c6fd9f2747bd60959ccebdbde4e294846c23fd56f2be6eaec9defd301740d9f4a47210290c72dc561a7141a0fcfe07353902d616dbe9567a9992a4183343310f65ab394113aad14f19607088a0eb2dbdc1f3282c1c79df46761101f87362cd1852fe62e2b9b757500d6a8e0249ab2c03c375a2625c0b72283478218fba6f69b4f96fb947ed9e01b03d8ca7b153f10dba0a553c01529970cfa679cc8620d7b71ebcdc6f50b6d14380aca30af008bc930323eaa077fdfd4cb6aa4956b1d6c774ae6df219d1673b1fa28f0ff1678fb6da358fba4502cfa7a403dd1c29b93856f4b0273c718c5fa59b080494dbd1cdfb2c14f0d3ddc66029c94cf469d15f73689aa858ba3b8f29cc86596b35ff29e0cac0b9925247fe16cd58c96908a2f401d70217efe2d0695ba19e21214964c3cdab1a29d2bd5ddce21798ad1b0891bdf46b5205093349d4cd9d636e7cd4099e5c9b354431698c9ab3dc53e187f1fedc76c0b6f76dc4f347de3228defb0798d0b7113c9661e6e3db0a304e6e3c80d3f14c243a9fdb8c52fd5db6677e78a4dadd95b62a397763ae0ad4336bcc2e08b73d1d0e0a5da9e3deb93ec9a48c8cc5fd80bea0cca4a29a4410de6fc71366f356cd3954ef2b3be614ae2dda0d306d5ad8dbff7203400ff381ea4f6679604206a213ce3b831da5b9074c9b22d124258cfed381fbbcacd83ded6e19db43109bfb88d8debe986639d4b43e2c9a1bfa92dad04d568a79ffa6a7ab79e8340bf067694581173af04db913a04b59e1caf9eab7dd4f5921851ce821b0e83d78afdc63e25485dbb787d58970a7e9b62327e127aa94ed8652e0a1db7d064acb003539a30b62a9cafa25f8dc428ba6a3327e8fec8bfc46e6295c429861f38d8a97fe098934d9916f2b0d6bede83f46ffe7a7f3e15c63db82398b96c4096e7791dd52ac36294845f0556a261fe4a7c9d0e4d49dd5969960ac81e8b029793d2a5980ac79ed7c06cca6656eca756a4d73700a50f6f06b4b487e4fe36f2167759d380c9c9845a562299579f4eb62c3f496a683cc8362d9fa339e0888c59dfc68d10dbbb229dc51e40cb2377ecb13d3afe212879033f9eac1cb6f60ab0e255d7e5512de376da9012ed9cd1051bc19e9431fdf1fb4e23ba7fbb982a87e311d56d45097b539f0d9e80c5a0668032493b4ae333c5cb430fb0b9729c69299b6fef3bff712d93f8ef7315c2d08dcee85fb4a8e1df1ffa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
