<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c23c70639bd05c3ff56c6ae6a8e2cee3c04e520a58ac6c5c85b6470b1957408ed16b0707eff714a39119bafe53b95fc2d5b8275e3d8bd9e7348006d54b0f5f0e64b1e5821d85d63d137c3c630dd369e70e1a3b8b841a36bbad52194a75cacdc2e8ab8ce16775b3522444c8fbee53cf9c0fbd8d5ebaf7b50124c43d9049856f85cf28a482588b3a652d90e0e1d86aa4ef609a41be9130c69dfa993b7966ab28033088ee9840be62fe30734416362a0a34bbe52266a0ba3659d3059db7492e36431fb8508a68142a2b03abd2e228bd9f826d2b7c9d659c91a6199e0670b1988d2ccbdacdddde6cfd7efe29d91260bf0718a2b0c296cd3253412b82fa8a889e7c268d16838b2306c3a03df6dae364470daec832f9c2b03988acfde168bd9251620d370549e7739c13550811a2678598b547f67b09302269b9a344201e49ffe53c4dea7ee126e52196dd1e5c3ca701c5ef51f8a15b13aec0a8105c011f6242dc2aa93f5565997ddeeffa7b61abffe6e66974e173da40225f586422a79ac1d70e28c68077a498610cb8af28dc68a5379252bba860873dd9b6a2b34aa567352c0953bf9fe62578f431aaf39ed7b8b2529328a6d670e30b5f504d07543347475476f971a5c43f90b4fdd4942856f94950a3e4e020fcc073744e394e87a5919ef4c893bd920a3533327dcdb5d2570944d9973cac4fac2996f77e7e845098672f737d6c787d11c70b0ea1d03df77f5c6dc02d1c77626ba925055287fcfa6c1c324f5552c4c9ce76508dba302691786941d4351fd36a53909c099806f144ffea156d99a231d05f11007052d318695b02178741abfa4418469e10f675d5cc97d26788812a337395a740477de0249e3e581c1348d5d3e223773603e2350f1de7aab0210284ef64b72b88f4e76b551b15c245a3df3d72140bcbc2096157a1df79c6e3cb6299c247f0737fc11ec2d975015d7e4fd8bf69b629ef6c0d10eb137ba21048473cc1ab5c136a84d7f67a98b33c04461a5e604a98800eac40da06ab54bfa83609de40d78f07060304068ef788baf21dafd27581a6a8c4ca3ec8bc31397d128bc195a4d822a61cdc5379f39e8ea86ad0fef163d5ddeba87ca8c54e434ee580789d647004331cf293e6d6154dc92cb4e358fafc31122eddb4ecb70583bb63b67f648f52bbb80d23053d3459be8630f630337e2325ce02a73cd439ad404fb451c4299ca8c921e3bef3d09b3c2dfdae3218abc00922c58cbab42ccefe7d763edfe352cf82d9b8796e5cb38c6ce2a90f4cd7536dc032be26e4958c2b7e292b0de6a1f39fce1bc1d643db3d77cd96be182c3754241e71d7b145dcd3c352048e9ea7e86b94d2278f601f4c86b4e9cbe15bc6b64a727322d058e8978dfbbb8c6c0de1849581c85a0b2a40a7e2e35610ce838357d9a3276684a563c000cf090f7af9f187f2b4fae7640c76954b6376f4bacf9435aa0898d72a70acaf15948c33818a2e9d23e4d72db4cba0f34e1e1715706f3739c2cd2d1ec476ab4961de1251236567bd64bd8fe338202939868f8d2ac3fa6eec41661a2a5d23f46a9c42b282b84998e89ba62ba16bac6708bbe74998671a7e6e37d33f8c995f7ce685965f8032102bb0c35adecc13e3a2d4b13613c0537f5b7ab50e97d6b377be32858ec0a2220225367f3e3ab5833a29132e416500d00d0fca19dff626f58d5b756854e017280717d857c503ab2efe4f0f4452975209ff5be2d784736ee94b45d3e5ac288a33c07f57f905ada21aa60f2a4dc670d27a91544f9260f17905e2703acc48852a7e1689e13851e4795a3dd5aff9835488346f2e673d696e57362488d239db9b9a4a21ef23984df7141e4f0d55bd1d0a3b30326aba4f3242cb09f10348c04ed74d39852227e34fc11db456822b1691859efbbdcd58d902b0784fff65b0b82f408931be08a1b2e0dd61457309972f86089a86c23aea4f578cb009bc0aaafb590882920c7b4351df05dbcbd68615102f4b52fccc54ad848eafd126d13ae1790abb154b59f4ee25c2b1d67097690d2d37c2fefb2363d6437ef9200fc2c1236974f7da79c95a028d407a64ad438a571abe52a1668170268cac362df020a8e69b3ffc7dee65d165dbac64ce56f36a78e9206b0a6f1f119aaa7138e9704f7c76b990b95743624c62486549d0a2bf7afe5b6ca07b4d36de60ccfd50eb13ab3fe86097eb20d5c4dc95af260061038e46a7c0fe54f6639ded490a51e82c090737053f270af77482e0e22b6c7faf718908057e596a4939b8134a83d8a44177675c0c349a93c1c967197ed048da9c9e527be1511d564471b50e831b87f12c60dd4e68f57b3e89b9578689656c252c32edb39f9d11844d078d4b17420c50b2f1f95b2ae0943f5fe19a47b7b401a66a8ee1949ca7ea38e4c0c6427f6bed97df2a09f680bb05576130390dfb383f86f2774dd169e6102efcc72c104657feb0b6a237a96ed4ce732ce7362bbf31ba7357cfbf39a64e748f5f6709ecd75c1ace75af5f51f4135cd018d0b4067cb54cef838899a40998260fb56619ad57a01685e998231b5191dcacaba484c9a5e363cf1a3ab5c0e43ced430323390ed122439e01391310865bde44efb7239daa3de88bf26e948522606f8398637bdfa9cb145db4f3ac1f06a347ed0eccb3ea2b9e0c279d8d988da938787b2a0120af0a995510a4698f16dfca8ea3c22f1a03fb452cad7e66c6244a5cc21e8bb0db069b9028a9293f9d960ed08811994abda7700c6ee797fa72b5e268a82a512b40658580daf876621981f16ec5341bf6170740f89e81d8ada3ac646882d669089f04223e42347bc5b4570312dfd6b8143d6172677ae31f6c527f4148a41bec15f25857113a33345715724a8825069caba26f859972e8dd7d313228829712bd94c1ae8c3c55ed15ca20f3617352ea5a524adec37e83d51418754c7ff6affa9c6738f6b357c8847cb99807c0263d6fcfdf6a89b014d7786950d783efe3c8ebd1ac7b390e028f1309cd536e7cf1899b3b17d316ad5a110f1359f7917283cb809e2bdd2c72aa52e0ab9b990e88f436d757a804d0c06391f23d23302e26cb20353d7d690d5fe20dcb298f75ae22f6d1148faa7a5b65e65d38328df1a302bbe5b93295b770dd092e015c15a2470c965497d07b35142b40179c95ca55b703995e8cb2fd79103e1cff6e4c2afb9639521dcfd4762a28b2fdeec23adbcea7c00462c5b386266d83c4760f245efec1a698f9c05518fc927a150651aff3f864284212bf4d01fa082e1ea5064b8bc30e304ae7245307077894743dbbbaf162000e53603305efe98ec3df3365044aa54f5bd42c3494066214a23ef214f835df49d49ec4fe0df7807588e853ffd7e8fc861d2eb04e26635b91f13a97a5a61b3b00b76c9801d1bca8dd236015dc9c0185349418e3fd7978e0a8e700a6d83693af82dc333e2c889aa68c2beadc4b509c28893d774bb2b0732835eb4bf1a700980697bca087ddcaa24070fa41312b2bfcda7034a648c50bfa04f7f4755d9194cc31512fac00035d78f982b13254c8b6801a93dfbf64aae5b98f2e4834363e83f68b2461166686b240b78cd8f2861c7c84dcda417a0e2920990b7e51f8ac9f690440b74d6b2bcbe16205df2243eea2634283fca2cd692bb9f02a2a246d7c6a93cb9c73a4a65e4e27e1203a5656a66e7e04e48edd0387a9607c0606c758033c33c0ebb3eac767ac6f9027bc05204525525cd147e55929b87fe02546c8da9bf7fb37724b9f598a616885a25d28d3ca189629271ca734f0ba6f0835425b721b2a7db4ae0bb25356a5f7c6f6e50d48d534b67e4041d4e943da540332dea48286f5836b147ad100a8fe0215a8a6480ae1f67c5fb4850a7ec989223299bc628764172f433f6d7584b5f728a91edf0ad4d1717f347d02ddf2561dd5dc020f0332a3258e7ed2042eeb2328dd790668c7069b3494cc722e177f35deb86c9f91347aa9238ff3af59c9b24fe6187bc6529cb06fbb11370c76622d01f52f8e2694e06efe820e89addc79d73e57f201f029e484d9fe397393de0eca09791daf1a9add1a7dc438e5134322da009ca3a9b8db2b9049c073ccdbf2a461b115845bbce2b1ea4b15e11877fdcc3f79021348d36381e83385dd097829345136f7620959f627da65acc08ccb4d389279671562b185c51d88d2ea9c7f39e8e715b4c00711424054849c0a785f5a8f32bd6b017107288bd644d755fde41843ebd7948c154e114c16bc42390b6a82b5c8cc2af7180427828bc45971489791cf0fd267d69076b73735c063c51eafdbdd00b8a4cdccc7b4f560267771df3460bce44d099305ca20022531f3273a0d54d099a666606f9bbac2f8b8b2b3e95ecb924bfbaf629d8d97ed0d6059530be8f3fe3dc1e20b127e4724d8fee3a67eaae573b6ba72c55e05469873f99e564d53663a59bafa46b44b32e1e54979a31ad11f8d528109acfd803354a682f20cf85d2c21f22758712af5d6035129939d7dd3eabe2b552c572b7b9604449c8c09ea60b752a3cd6c641162fbe89dbc0e0775047ecf14383da181b07a464e30850fce0b83b06a39b50dd6acd4326c2596cc9354dfe14e057875842f015ac795388fe78bc6cac985e0cb98b4e4c6f2814e0b1cbb4cffa14205ae94ac5a3a9ca4c77d0dd8285d89d60ad1dcdbc879a5692e241d383b55fd6b4fad8df0d73b324978ef454643398277ee1f8a28ba3bb9dec397a6d10fdc74cb406b806e9645e6a5fae5d6961ca1d0f18586cc29fcaaf55ac1fde1b1b64b60a721ccd63a3d111bf24004cad8fd2110ff15fd4fd336b77b3841ab5e2dcbacf8bf1481d637a1a927f8e1082b982fd4116d7058110aa09bbbe1fd94b39288dfcb1c61482e8ea33ba57d0dfedbea50c39c9a7bcd931b1bf8416646ebf31cdb5e661890c0d7a29e19046f4f6aec8e641d22d363f9c30be958da839a12f79f6a8b149c178f126b60cadd3418296d4d1f90da980f1d71c4c09bfb88b59261ffc1fcfbb7b75271e8569192852f728c36aa91be111dccfca53ff5c1c62654f8a978b4e4fd22b12dbf372f08f92df2052824ae49e2eb4e101cfc5f64c3bf92c2ddbab00aed45f3346d90f1f6339f4e9849fedf12d378a1cc94bbb3da1214a8108c1054594fdc5bb061854c828255a3ddd9e7915b45e9d3d92bc9d1070b0177058589601121df44bf89d6bb5c9bb26d6148a0cc268effa08ef2133e1b84b14be1552346329799eb75affa93348aabb042f32441ff9d441e2fd8af6cd23d950afaa672c244d97ac3cbbae1ff16480c380cb5852b8157562757c5e5a924f46d7770e53fc05c24cd72ecb5fe8b217fe8c633cc951a9e6530cc2e6031808feb5fefb3e030653b9d3f32adc3c6c3c855e58d801d5ee725b51ac04999dcc17a38d81830220d6d3136b61ac1bf69621857a280976ea53fa8feaa9b710e72e2a425648c016e55c7a036d3934fa42c56af80bacff7834048af6a1ba65837c59ae2d4376ad56b1895ebfefa4b07f1e9161ac4194884aba8cd537a1512aff4791245b39f81fd10824405aa56ec62d016d5f67d1c957ea2cd33724fb6361aaed153d003c79c1dbaa071db5dcc2e51e5112260789f22599c3c8c4eed7b2a4b7730b45c97105dfa20e24137efb2abed877b4cb30309c9a430ec4f1da9c9d1bb65a403c40d5a3c2b647a07d223df7d79693272fcde0348d3b9e0b0eeb1744ec830a2665f1d653265c25a33a85280c88c74fae99273bb655b26435b7166428cc5e690c51d8632414e131202a27f40dca83792c0803faf59e0b1aadba84803ba478b236a63e99f5f39f3c552f19f4a43904cd4b18f00ce5706f7027adb8e8b57b0f751c5170264e5944d94f1ab24fad725cf25e7b326857f1fbf424362a6509b53e65a903025cde4d488b4df5f24894fd2ad2d4850d0633d27e9384bc0c6a7773210abf0884532b65188a67c1ea8c8022072a23f7038c0ed179e03b00ef202f5700708c2df38c99096ad7d9fc2929c7409e284e2a8df9262239a79cdb76d1f1f17edfd840e3d38972b5323295c679383f5fca78b4c4f3f1d0dc9096bdd067589d1ef94be5f41fbf3fee1ab4868b0559d8b483d6531a01ebc4dc31f982b9f887e33e3e13b8d56471fae58d35022a06015586c70f3c54078df31b6a5eb486dcec8197d710edb2f053eed2f69246aeb9f80988e09885349f8b728cbcda4148236f45eafa43df3a95253f1024c171e990db2f24c5c242ee49a55f02a73a70d11a8c46796fc19947f8b65c34ef7ee529e2fa8aec7ad68719cb03263f362ceb3e0e01906f3e26ef51c2741471afdf5aeba984781e6be5eda5cf587dc8bd61b877829e6319a7e3db145adadaa13a0eb79233f547190c0c0f15e4813bfc8aba0b01f91f122ae70e345510435aaec6feddffa44a1765e0432e847b510f5aacb8eaf1cd1765c3d9f166686ffe2217aa6c9d84944b453ed885df01764ca214219f8dd7d9682a0d568a49b3745ab849f7c78cc9f7f4d11a7ad69bc376835cbdc5e674f11b1a3e4fed72649111808c53758666dbdaa49685d653586c24d98c898490755921abb87fdc2c330b86e0794df09e2b43cc99525b54e6089d188fdd615a09b934c826d703a8c5b723e7d16ee9b029ff39dc68eceebd46dbd024ca2c4741d1f6a8a32e0752d5e8d47b15bd51ba9329dbd3b04375880eb2148fc4d966f68a1364a7348aabbd8ed282a0eaaf2fd8fe169e22a6c2e27f39c74a0c38d13512685dfc964a8ab1a1f8268e56823f0871513dc4c18088aa8bf1f8ebaa70e8c93cb7fb018374569dc51b51b2fbf06a5f28d4dfbc9e13de6702e7cb6d4750366fb0ba946eb2e3b9f22f3af256a5372c8384028ac360082f9c881befd593c9a179bae19e56106ec337f0e5c674c157d1803e9943f1f95d3039e8e88daf0e5c8711b13fcd7352c7156b78b4cc5eb62b3c8f6369f5e6fe8532cb664347ebefc2b1b8de915051e52389c96cbc3adc3e50501b6ffed8cff9ac5e3db2f641952c322fe868a3e4519c787be0f448e2d878c5801a5d12ceddba6806e9243e2194d628a7136f3f260e37bbfed631d4e108b7a20c09e9339c2446d22be10acdc8ffd94c0779db7564f4098d68cce82ff439c3293c972eb83412fdf84caf9893569ba72b2aed6033b08fc894ad205fcec1ac76e2f3d4946ddc8fe289cd43c154b424df92b001921b3103d9c69673cf1f4cfa06e57abb6c14606fa9f00c2a05c2fa94c7f69596ead9f913367df6efc1f9ca5db27a5d8b05145055c3d2aee66557d9a463cd44ed7459fba09c13c0989e198d20b2dd0eb7b02c5a21da350a77ad0c16da0411c6665fbf30229677441203c8de7586232cfa184134da256c32a8ac2bdeb201e233eca9b1c1e5285b1667b581204931d143087fda9420259b3ae9e098ec8a00942af5aa65b0d4684f78cb92ebbeb37d3d888bc9163f122b3769bd633bd04d18548abe170d77c29ad40150f9a1572fb493a42852f9ede29f8dd49810a05cc1fa6b8a8f400382d6ba001c9859de65158b69ab4459ed50bea37340e598ec9c3e64dad04adc150135dd8aa809d5b3a8d680919337f051831fda91a3d85c23198abec9a6dc48e1bcddb3c52f1b736ab60360f904f70adf9b549c2a64b92ecb43e00edc75e8ef4869aadc1991071a3a69281f2e83195f6700174479cebc0a6aa15b80fa09d0e42c87e429d513348cdb634c28fde15bd6d6bf0ae9c6805ed48bddc1b1748197d9a92ca4753f04ae216f3d99dc46c41a45880bb15d778bfda77e44c35ae23a800ffadb4436e0d57c100431faad53c78b95225f5812af1bc201fc421da55853f705235b483615969cac2b9953ea0bf203045551ce1f84c88c93e5e2fa5a35fd6156afcf212d768ff629e611ee4b038c2432758bdc5ac57228291ff2ce488a1f57c7bc563af3555c50e4f0b235c3eb040020005c28663fad3aaed74cc87369452f45f5520209ffab133abceff4d76e194e18e93ce8bcd3069a09018d5772105ea384eee780ad98d0b5fafd2084cf21411d13bd1416b42f82af24494b57b38c8522bd2ac443491cfa114b118fbebceb320c0c03fa15aad828e86d140f6d74191202bd17513f0bb236dadb3e7fb6a3cc2168bdfc48b48be19190700e3e8e864792ccc619cb00718b7d6eadb7fcf9792ad7989cf9b7524ea1be10d9986a4a13e8aa97a73f908718bcafd54c6b46f47f21657f08cb62a42a8979a4ea80b36f640dfbea807f296389f912cfbffa4354c9fe744735a09dd68925867fb65674d28ee79ab06061cc2e518fe9332fc5329e12662b3d4cd9d90d7153eae83ca653086e3b44fd3d49a17a5583b45222f752ed77693648aa5cd61ddb3a2fdc9393290081b64dcd6599070a4a31e2b6e1f2412536729d0923bc5541afd54017df7f75c2af53221c0bd5a92bdc1a863fc5c442bc1ddb7a0d2f55c43ef5aa54fad4cabcfa62817db3e6ac83ce7e2c8ea2d848baf3a4f7c08e61633ec76b987910cc2d340e4ffda931b34966f835fb8ed2c456ec7f56e5c2b62e3ff68798a29f7ccf5e33f9cb0f1573d7f43a1dcdbefd9162688370c193370e6c71fb72a6871108260ba6aa6b146a490017f9591d39c2d6599c4c309421aff8b9c37cc737621e7f7719b8fd0a5dcf7640e522d97d31bb5befd68f729706980497f0c175d759d6a3f7663436cb26e63c79970569e60dbb51cfdb4afbcc67b2c3f59abe3a2ed3a41de6a82c17766ba26e6b9326435ec9b56eb843ba6a91f634e5ef442ded44fce9cecdb68dddfc9fa76bb71cb89a9e54dd7b4551c25a45424762be0028bcb6a1fc8f49beb05b6dbd26b3db85599fdc92c022489b234b8435155c7973b87868e991b41ae31cf03e20021573dc57ca91ca3692ac8ebe5b29bd07d2bcc792fc51eec515ec125f2eefc085178dbcb125d00569be51ad76a6058f734eab506d6fd429ff08a9313ecff9f64b54fd1c8d83359e9a21f2acfd1b12385160df59191b3ba74cd2ceea9560995bd3ad8f9e33c7f5b26e6877e16f8a8a3db1da3842cd737f4e2c21256275ac4f1fb154d472336fcc655ba527ba63f50507db3474b65d1f5fbf0b0bcf5e08e3f4b3843209c58ebabe748cb388e2b33a142e2e6673b342175b355953a2cebf20579d766361e60393f815f2157d73be7a2a1bb8dcea445e5be2addc752c7fd2f343d37d2ae1d2cd5de0cb6448eb770977adb3e09ef96e2115f86fa68ca59b08ca7b00c3f34548a457a25be7f8ad41ddb5f7a5084092bc8847010c410fc8f997bed7d979a7dab6314e69c3021c42650e3addc7ae59834a2f0773acb094d68bd48c57b5c1ce597af5d2ad3c33dae812b15218201f255fd4d316343685b354c211395904bc480c53c4e2ae4ea1b876173709bbe162de700e6f811cd27758b0e2c0043da945870d4c9f884d24fa3ead7e8920ee567f3cc2e06bb8cc67a8a2610c3e7c12d8d49cf1a9e4783abfac13722a4d03b7e36a19b3b46d861e4c457415bfce52d48667e08c20275698dc25aaca6ccfb5d6d5c9f7024a6631e06c9c6213735dab15355e3d95a01d014311d4f49821bb1f489dc7be2572ecc91a74acf01ad7de89f6bc468bb33b3bdddb1a2475c8448f0c1642bb38ef22e002b2fd092712c521070c6aba339b792c0cffafc11d20092e1f03626dd4d577068936a5a04d85a249839e3304bb7553c47da91a6a6a9bbfccaf0f6fca13d5249d723a93baf1516e6be6146318f098f06ae692fc2f2112f0ef2cdd7f9da2758da129e8bcb34d7651680f795e926b51692f941018a897da438789c5022378ee305e8829f9149512c2c13b9e37db4c20b708cea4a32523f5ad6b91b36132c579460a5d539e4ec922fb07ccdf2ec4d72269663130064bc045acd944d8715230a56bea64cf879cb8e9097ac31625c809d70951415c7f27390e4bc9675d6916ea6da69005dc011163876d8a1d503da7ca7b721c822b366f6d3c971561e74c2b3920b3bef65cda3f5ece53f145e2207970cb6a90ef5174812c5dc83fca8cdefc972eeb19679e15fe18ab2793c030a107753f001536094ebb7dd61b712be02e64686dd2fd1fed909d0836de08beea593d29cb67cc90c7a2636283e0ff5a483708f150a2e223ea96689801604373db22ed592afe9f1986803dc1582c902eb3a6620e538c7a5c330d55ff27596620b8bda0c31f75b643bfa0f3c4c6cd3894d3f6ed6450520ae1ff3f268aaf5e8bb54ff6291662f549082d4901c99e5bdcc54e4c33248f663b4f473f83f3604dc05f17acda7609e612b90b414f503c6d1454a152edf64677385667e8e7bf266f2e862760b887d53d6cde5da2c4da9c892a23681641ea7f0d1f84e287f6ca9e763dbde6d63154b66062765533959bd29b94feab3e9c4da248e2338c5d098672634a514c686b09ea6f900ac0c10ea76b09434efbc6c85bb8b68bfb340d7e4041c551293126d79cd395511abfac050f4eee9329b27ae6f717d3cf5f4e06dbff7e0a0fe4f806fbaf5270a64109e7c340343184e0e59747b324f86b4f2ef65c35ef0229e7dc5b542a2779562c50be360e318c133d92d9f85bcc639bcac0d1be72d3e71cf46a95663a97bfff15aa2726a40d0cc5f8cca54576f0ba6c57550ac1494647140b89ecd2720485f6184f8dcbbef4c5fed9867871d23057ec169167179400b8a9ae1e00bc5dc8f5684e200ca75a1a03995ff65f89b7cc5b1941e958d4ea3f78e37c3d2a64e7db1e01df32246f99074552d1517aa8398899b007412f6b1cf6850f2d153e3764f3c47aca1390d0b34df863b708bc2c277a6d6778b76865daaa59eadabc7e4f210ea733dca4f8d8e3629c3927677ab9cfa5cde454a25ce2764763f601b127d3307a9111ea1aaaa7288873b0033430ca177276862e4b04654f8e3743cd91d7924a6d3c74e70e92a008ba4cb9d1fb0dc64e763e101d331e1f1f25778720b4e2db783af3fdd41d995232f2141f9b5a09d8972d4533ebdbf45038590e3ad9e90948a7748aca76318e1724f17536679fad9bd76c04120594a55d8581d9abbfb2f29aa4347b4bb92e3931b54a5144c0fbd7f694841fdc4e2781a89f7e2483caa19548170f210385b7c7d97acd981eaf596941dc0eb909ecd5259d1592fd308f67165dfa0b37ee1ac98f43ed7a07a0f19c9cbe186c8139b357995630da7f4b9c0c9a47f686cd134bb2903b77a4199bdb14f01c97192411f92a10a06ac00c9c288606d680c1aef20c6d9e28a653d7a80fca87804d0e3e37f8c69c956b0aaab04c7f53c5584c68e103b2fcf641bd9b704f346ea28bc2547ae481c42e8221d3aa60e8a20295d7e92799e46bc115aef4bcb783134fba41f4379afa9cd0b4020720d711eabf65cb09f552b3569bb3df805fa5e1a96087dae7763ed8ef7b6ee885de3e6a20e0918c801fff312678fad9903f6a7cdfec6ad0c9bfcea006cb79f7a0ddce78f4c8bd1ca47ef00f64ae8cd2174d4b050d36423db0993aacf0d77049d7db8370cc919e8e0f2dd698258fadd306db10aba2af72885800e5235180fdf2fb232bee255e15b36d8725a687d92b08c2155c211c33c316ef1147d2843fddbb22861ffefc0c3fb9cacea2989d8d83e831f188405017eee24e3d1487f2b9a6d296b824d3e8d842a839cf807eb40ac386a7fba8b58d8ccbb9a131a461a4d39a18bb712a7a267d06e878896c87c1cadc65217e92a37e01733f5d90142366264b79fe7d412abe2e475f10704bb1323f2db8a1c614b48a055d2b25793977e9cea048c84a3f3003926fb3b43d90aed908ceba7431ca70f91d67109d416c3a1e41250db045aa421d9fb02aaee2ceaef78a8c603b2e554ae56cba1b98fb6cd7c2df9338397e5ce8a2c59e6fc8d49195e07b159584755f117c4f69ebaf56452db4b7b241bc9093992d866197801adf21b147b5bff3792f03d4a26078e20b74db7f1b6a989f289623bd2575e521e80f74c46f4959e17e5e776193d6b96f87932f0e53a03de646affcdeb9513c8aa0e6197ebffc923e23bd79fb0d05f78249f9e89bfc9e58f3a48719fc8cbe0778fd9c4fdfbdd44d070554466cd028a29454ef3c5f4928f04d175d328f966e7317e544c90ee8dabb8689e6988c8e03da90d0eae6a28c23c17a7f117f8e02c66702b357b3ed2b229cb614f5ccc88b9a0c84a105cabc23deee51f38f78442b1d3c7614bf72e8a5c3ea281fb86682a23c8453f61c35704e0c489eeb88d3ed592e4f842889c71e08ddb2d0c06613e4ac9f5716714e509a3c05c0e0f46c05ffeb50338a6872404d8a8f9a977ba6e0448d63468a8e6068065ffbe33cebfbbd3ed63d5fe6b6725ab40c066e1f58046dd2691ce89a52c4fec6617e6dcd8351d0588fcf0c526ec7d8d1944c3544452065f0286497f4f4675fd6afd1d96d8d9de191047db83ce9aa76d18e0ce67a925e5c8f92fd3eab72d03af5208857971ddc8e0448a4893b08d97d3f0fbc4c29e4e583b55a618dc6b376c710f1b88b935741061768f844b4bf180319af1bdec8f53608513157cacc1af0ebde26cf489cea9a5edc8458566c4e27e0264be434b0c9c2888dc3e332af261ededfc5c85f0bced7af89748123ef535c15be26ba9cbbaf9531e2f96265e1221a99065200658a45360a5c07cb39782d58dc059d3295cb9fde45db27402658e9c8c47d8dbf5bb49e4d07fe24abdec11b680fa695f672d45f831461f841593e35a0c14a453fb6da65806a4f123f108223a7fc2c54b232f237aac5dfa061f2fdb6e658712d0a497f54a9bf52cfd647544d74759961faac00a411ea0acdeea5e03aec7a6c26e0731032b4e9162dbf60b97960329514e119a5ed7b24f706897583d3a0471b5f55edbf957f456f36c21eccbf1173e7429b4f526bea263c4abb07f6811f9d6287b06e89023bb3588f184038ed9592cd7d71e0692215f083cee212a1966a3eaa2a0fcae6a80e592867d017a829044181b1707eefd818908ada3cd66e0577ad75697925c3239cb564c4cb3045f88e615af4e8384c1805eacb162dfe6e1212a58f8ddd23c87739b80c682700ef3cccc81fb17998b6bad280ffd8276816b35e44f3aa97a4d5036fec5510f945dffb83e5537d18db7d7235dfecffe172e83f323bc5c4c28a8719e624eb3b7c96f32314c548fb86c5803bffebf65570daf0ce3defd400d0a7e20df3ac2f09d8aaf2c90b1b17628888904582c6106c46278c398abc538c452569e32aaa0d255dd375dc164f4d0159dbb2fd5f6feb35208b618412982021f36d6b3019336505a7c5904ea38167954389015eda1eb145b8a78e27b3af4d4bcdb711d471553988cf823c55e04ad2a85f9070960ac96a94e0c96ec139a6d3532f73139be917405536504e31bc1bbca965cccb2856e53146017e92f429c0139f1c488b9928081f1663b70eb1c05e074a082eb11bd48ecbcc67d774595565971492b79d21c64480b917473ad39ce02ba7f4508cc10278c5ee8f2e3a17dcf6a1764df95e6a0b1598f29e60f1223479fb8b123e7ff17c060923e3bcd1379cf27b6b93a14bd8d7e2f6cc37a7604a49f122e73b8f35f60f85012b103164b37bd93cdec4cfd27eb554bcbb0a66587c643774ea6cfd2578f75fb4eaf114e5a12ee06c98ebe7430f6f6a267197315e57098214b86c8e361490000564e58917d77ad4337d9ebe6fa2771be1d38b179cc334bc5aaa111bade7a798dde0591142c253068b35b40b8a7ceb5c9528fdaedd8de2e9a3403ca242a553b05e5356305ecb1e6190a512d74bcd7f5e0ff69e66986a6c2ad90180e9dc6f3629d893022fa7e1d1188753f094cf07fd111a0f51d422b5b24f4934dcafbac7c929fa19b1df1cf472ef5d3c3d39d5ab61a51bc9f4e33b3db01a245a7068e663168b3e58bdaee9f6d50051ed3781b35a92b3cb9d2a544f9d50370087f7e8859e868d34bdb415aadbe04990b6e7f2025b59d8e1d916011a1b410c9257a30c3720539056e5b741749e8183f14ee6763a4e6593035c1bba4da18231731d6d7a141d7925cdfb670f1cb77c7d61820abe2ebbcce7f02b462b2ee78c67d84d2e3e6ea2ab1fd498101761ba11abec566fc29662085f19af6819ea461188e5081504e822b94e28dfcfa41cc7d03012464299d1d06e31b97fb3a7ebda0416d2994d4e9e3dc8e0faba52864cbf9383d015f11bf40f77af19c08d6e9b3c38ceda63c1089eeaf0f72710a042d57f17d174c47471da55bb57b39565122ab3436d631abeca163b3a2da259806eb3ba53ff8f3fa1334824c367d5777eefd7868c715e9659e1a052bf00bc84d4cf864ee2c63a2c795af02030e87ab6113c5efca1caf24360a27387e591d1d5d58b342d402acfedcf6e49540058ce552cdc17f9c39c77a97e458b46d29bbaa72b626290af69ba3f8bf3d2a618d5f8e0488de287301d7aba401acf2805c3124a537379cdaa0dcb7e553c16bbc7ca60c7d82a0b0e90fd063de4107b83e9ae54323307c452404d69cba36068c967d199cb014c24c0cc529f0843eac61e0efdfe68c1258a98c5a1e7499b0d895f81031ab419f6ad49900e90128710198ec6b70c39bc94f29c079b17d6b77b25c328f279856ca74fbb1a64db3ac8d27c22685c5ddb4888a647944b66e31f7fddd2b0a0dd63fdda4d1ab123dccae26438755c9875bcf7bc3d9524d1e42d67ec9d487634c87fb6684099c4e07bdbea960bc8c671a3af022392fcf7cc4fdc53a1e6e516feb3b56417cd085024ec908ef5aecef60bd62a573a4227798caff86dfecec4b438915ad5d49dc5bce114eb09bac30ab5f74fa11718667e41c12334063be14e2e8e12bcc17bd17772b75511100fb2c9ef31840d7d81ae02bb6abae0e828aaa09fc84a2438aa40dcf37f92e19ddf291dddb35df3654a4520952ae834807a0125653a86af7e7c2b2816617baa4b73a2d24b6ef29eadc4aa8b049faa5a4b28fc9cdbd84c3ba502086368ef75dcca38bed13619c6cb34c131a4f510b7b66fd1270f3d8763f5ba01ed337b97d3d6e30cffbad5795137b6b609d1db8d06e98e7d4e7c7b30f8a9cceca34995819495d0ddfea49597a84769df5853706fe5a27f7477393e2fdcd1a986a4e0e398cff0733418c771a33c09","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
