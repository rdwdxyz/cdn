<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"208d83f63584a0f3630b16f4f09c25d32aba7eddd52e265da33f091964923f5af1bb5390d641968b7144dfe4be30ac4b9cd77396a16050daeaf95eb3f57ee9c9c937ecc70584b1fe407711751821b6c9e7151ee43b255942ac3256e0ed3e09e11b8d70ea8b1b3858a6cc5688a8f47663505c452a4e7443a948b468930c8b6d5300328aa4f67b7acc764403379352702b7f371812ce0adaf1a626972b34a632f8ec73a648d96c659353c915bca7dfed53412570ac352c33f86e3f57c5767cb591d608ee9724893beaec6f0e436ecb51caa859e3f52554a56cdbd50e5bc20135e8bd569ce564343845ec876687e49b5fbc0987bc529e56fe011c7d885aec0e508627d9115620237d1f287da47e86fcee671bef8c947b9c70b4e6fab48bcf297c030bab8da5661aad10dccc631799d0e1e96a2f8eb630df83e0ef48e1b53133185ec320b6cbd93b120961da65cf8b599a0874d89de1344310547785e54f17bd269761da1bd24b438a61fd1f0e0b61c111523e10fcd0eedd466585176dbf6bfc4a9b7560d7669d722f43639c4c86af5fcb59eed28e417aca0ef17bbbb258982f6bf60b6f0e85460de9f04e162f83877a00083972a4ad19990e4e9607e933c6c8b8addf79891e1e144bab2a1b506cfa437abf72a0b1fe4a0df78d6313cd0becba2b9ef247538bb838316c58e6e0f2431362b25a16ea00b28b836168bee63c13a7af9991295c86afd60ba0f8580f8e23121f8775cc81c54f1e9104b4dd9846f4103e3ef541a747490ec12985c22a3e4b89e81c83ad1f9edc61146096b6e9f35570eff441bc179010cc94ec2b5e9f4ce142183489e824ac6d31362d809bbf2063dee3b8d022487ccc12d4257ca322106e15fbef595530632266f7ffe7bcf609b374fc1ca68b8eb9f7f9b1be418ba43745f6b4087efd65606289c6befb7041100fcb060f01ca8cfec2dda53273ad44b101fb6e0de1b659b23af99e43895df73ab0efaef745d651c0343f8fff3e575f746a0776f318f3fd3dbc2796f3de245757f17d0fc4eb6de258c4dc88b3c4f443abb6a0ba86f83e6f6ef625779e0b623aef24107e0d049da00bab4333b9c269a1febf9ac1a5cf114a560ef79936aab80fd81a3a8855d4d6dd44f559d54176ab36670bd1909940c037fc96af3020947e18d8341c83149274f774b3e3ce35df0f9c1b55fed02255b874413ad04af968ac5eb865b39a2509705a448bc9e308076e7b6157fb1cbfd3824007a48727b06089cdd35d9f416c2ee608e18b57aa66871bf0051e175feac343c4699b4df8d73e6e289a01366bad36c6d44acc4076dde402444e2dc3641094fde5ca36b2ecc21f4c2edb0b4ad8f004f47a31609924a4b8ffe7b8aae417d778388d991afc8ddea179ef8d9d359d5d9b755bab236779b503552a967425c129731ca5196d89cc237b95c50711f470c38269cd1040cca0c010231834b93913326bbf9870b38ceb91be37f59efeef9bb6aba5cc5bfffcb5c6a9216859cd0d8d5cefe54faff88de35cea5faf689fd516b6db7cb53142acbacbdbf39a2afba43abd496bff49840e860fd4780df263f74c2b1daecfe3086d6e407e2c1911ad53e2fe87068c68ceeb8cc595fa48613a25aa7ef2efeb5f5f9378de787066a26aec4c36a45f85a23c5bc1a05014f1dd3ff8377f611c85c2d6c4838b27c1bf08117985be9a9eb207de60a372f41c624cf5f41a51df1630af6864aaa79280ba51f0cbf36234d12c2fcaa36c58b85559dbb1520b802a5a2816f644e80c749a17f9128de5965b84e11cb34d6ee0ff318e4656d2116ff07556ab4787d1183dfd8bbd77fce70fb4cfe6dca351f486309960702cf8a7bd0e735a350e77f2bfde3ad7419a1656f61ad1cbd63b945c2cd1260fa0c708df81c5c0236f043d0ea3608b4ce257e20d3cb62a116e56ff614ae0578b84b0a538f2bd19b1dc4963f3302a3a3a8dfb1544cdffb725b0defa556424772551b221bed7a123b244ad5efe5b5c59244f4a74d93a29c0f2db2daaa9682dc327919f424dda1e10e5f6b2fe6b87a61fc74f4de4f1989b9b593461447d38210bdd5459507cf78de09c9d6ab0c0aa20d1d4b40b0f2630c94062465be493796508f48a4f3538b0483cf723bcf2ebf4006a2e352620a71236be41266430b32f007aa11546a29b765d5085e0d6d88b94c9517e1f364b0076ca3414715e208e879f7b89ea722b6933acb1aee9fe31a19923804752c21237146b967d91589d564331b28cb6663b857ee23c4af55d08096a4de2c118406fa037140ff1e4b9c7958cd794196f3fcba86b23f58809e633b89a2b9fc71581b7f5a303210febd29e49d571276c3446835a31109f949c11ec95be57b8c7d30464934314a1dbf3a5d9062cf5e08fd522ab33579757dd19ec93db52ecb40be01c3b2a5ce3f8cd1993690a4538fd8ead5a4b4989250e139de7577bdf3cf194afdbe136a298c8a6430b5c97084426ff2ab272b92e5ee14ef88f33fdc85335a84e752ed4d25c7cdb24d90ee59a453d957551b9254179c2b5049788de44d7c2b190e75f39f23dc6ea837ec6b71c3bebdcdff507a785d90d7a9c98bfd571e08c9283cad95c2211ea0b3283b2a2bf5d9a4daac0b96af38827303a4a4047d49c81a1690f6f718ddda5d45b2fc758f9bbfcdd326398a5bd913f066956ffcb63db546df75554eddf660cd0547ca6ac39f79a4f1c46ed42244efb0d598a98ec41cae847c7fb6f5060a5ad70474bb995d5012aa691a5d7db87f244b95c586108f8e93db0a87bfd7e7514edc558f0f7a36a5989a00a123ff025c7aca550db6317337df1ca548f301c36da54bc1e1c1990710489c7d3d0657a077a9aa0a939589c5129564975d9d02192d9e267ecd1030c2e84430c4e3713044cfd04fe44934d033e9a6949dabd3b95549ea551f7da6b7535439faa6addb72bdc681555773e5f061fcf00a6dedd142d0f8dcbeb49b6d8f0fbef165fb07056f4358f1527987a5680ef178a8eb2770542860a1065de5e3be22b1058ba18d9fd8d4c6e9e18fce921d81f597bd5aabff7eddad8544bcf769b8dcaf836d1d5c5deda978e382a73bd4a82059d2864eddad68e6f0c6f1e8f85937d98890a5a7d4e44a79233ff5c44b305d59cea00c28bf2ddc78a1f86025fe2b718337cacbffd89c52c60df13ac8f4b503216b8163cf926be622c5b5a0d446d96d74a4cc621b14b9482587fe9fff338b647349871020301c12dea5c46f57a0acc453a0ca3dd2d7e7662f8c97a3ad53d400658e59659009b4373738b2897e5eaaf38ae3fcb307d8b0f76de7c46f65a57f6946c0f010b95e86cb227da505371ba32b48202cd9cf0e9c03317172319f9d3d25aa091751408261b50a509b054a841309da0a831660e6d14afc671f205be1896952b5cd10f169a85ae983589ff20ded2aa603b0ce86e33cbeb64f5194c149ec2888bbcf9f83a5ca932e18e7291f0308447f2ef80ef3d2067f04ea33e06869b9c9e4805675e0c610371880634beb41a30108f03cc64e488f521b87fc8a00691cae8e0d9cc918310f732c01ad6a755029704a3f105a95712e62dcc7fc25450aba972ce86f5f588d06897ca576248002c0625796ee06d2292f14e1b915155b95630db9c8669e37efe7ddf8d2e35b53fbd801dd695e68186f8e9566ed79f5558f556ddd88b55da3b5eb17fe8e796bea449d53aa62003f2206a501713f6f079566f927f95c282a52e5c5d271a31769f4b7c99790a4420a869a2379e260956038bd9a6f6d0d9cf68f625a6fa2a76f4821f65246abb4bea4df1a31e13fd457b1dbad2cb9637ce9dcad2d095e728d7f9343abaf7d8a50b62ad687361a470c6938daeaec7186ba5d7e0b70f6b56ed2131bfdf0004bc74fc884f6f33a201b8d7b36a76c191efdf335a51f58d0bdc04d04cef054a9a1ee3528590b5d838af7a3a435ec082d25802690642c1a4c787c4f31f18d5e1cffafbee92fbb9f4d1facbab9b5aed069b7f852c1d7c86795fbb00010ca14e8a333b3060a9c24f5f20b9099e9cd2188531c61a2e3ef1062bb565a14ca93a39a9dad31dd5707eaad71f79915ab6299978c621163a295e92de8884943adf0c07d81fccc6ad54dbdaeae327d073b60fb6b3504d11508f1b8e5bba9c3e21070349213103def67168304a75a90efd661f00dd6f0cf495db17e93b64e937912a3ecfbc192390f92c452b7cdf0c3f50c0cecad1353399b97251e609579c3d83deafc49f120634c568238b99ce66582d7191ab0ac9dfc09a5eb051f3fc45de644ac970b96c6d6359ea9c4a67996ee95fd900141ac73682467d5db998bf7e83d7ca03037bd8b746b1bb2f3f507364e6d5cc5596e3edcd1fff9be88055793c7cebe6cd6132cf2ef695b77150d371bd026ac23ff72ea5775db6ac51e338bfb6e1bf833ea5b162ae08edcfe8be4fcc1a160bef884b0a7f26221cbf176b9343e5022bdf533f5846d02f5ab2da788e66743eadfacebef98244b19c29b518c8c41c8702e5e71342c06a620183218a52c5bdca0686fee65e5b8b75d392133181e5bc493c943509054ea5107cb741cf60587d0d6ecd47c36a9e19a02b4dbec7d5fd4175b8612042316fe20f4aa1b3ed1adb562ce7eab0051c25d34088b1934a219094c57089ec5598f1a1d76cba582db96ffe5dc61a50a646896fcf4b4c815499e642fe94b713a30b9a933f057ac2e9b22cf62c3e73c569ba409e25070acf78ffcfc01696120a7b0f5990ce64e41220e26a672bdba2c62c30eaa425879fa2b3aad3cc0fd23ec23424f3caa55c091aa777d573c148c6c8d89dadd851358af41f6c5b4a8ddcf02716f6d8ab6615bbe8f0fdfaa4f1b2d6433c925ba58c9cc1c60137bad62dd9428f0ab94969148ddd255cf6648fba90112d1f2d1d3318d09a65a06fb97926640637ef2f50959fd2f64669066ee9e26d74ddeee201dadce752d8e6290318e5e4f25dd1da8581404011724f779ae0a6af1c97fbda227106338191ae1f5006168da84f5e3185cb1eee725fe5468d5abb4a3166fd3f05d4da02f66553c610da7abcf0d6e37b8bba0cf409c1f8d4f811b4ef676c58fec191206d6492b727d23c7abec2689580ebb4a48a0ec079bf82f4fdd7bfbcea8fc04275328a8460ca324c9b6c15fc15766454d47ca4bf7d4607ae6189f1360b9f27d5a5ba926b7ecd3f1d6677bd3d47b07808361b39aff80d3995fb694196c6ebadcb9fce1cc398bae472be6baf246ac28883eac81684fb75ba19e69da12bef2294cc3ee70f65db0a366c77cd6c79f3980c7bf2dbf146c86767b14b8f92a24de3b80ef71c64f816f53984dc7f17a9944332ffd3e8d46dd3f0210ec5e5adfc74c7f7f75a57bb010e79a1039163d484b6be67a1152fa9a5928535825a9ad1cb44153b2d1d75784e20e7db472ae5ccaadd7000743d97e895ce6571065a3446c4ad3f94e3fd60dc8b7f61bad758960fb856b0c20f5d6cdeb8ffc87cdbe6f7ae09719aebf70aaeaae6921d38c0ced6674e404762c24b7e610b90e92cb89b9aaf3b185657dcb014c50f62f7b410d822080c3e9439486d1553722b3aa17acd5cb818b0ddd5f7574c54f86d5aa981f9f419d718c495f19a5d75e506acd966c02faa41f58360534eb55de34e725f7298c4c5a004aed71bf41ef29656b5124082b5383e888518541c1613a080aa8a48badedd83ca4147cb0fa5dd5b60993aa0c7dfff8b35f1e687a9a8dbde617a6adaaa7a08b1987439262965d3b6ed1ddf170844ad8e1476524f62e10fb6b2cf35123be075b63dacc0bf526b94f1a9a119c712de8f89de79ff72e71a1e7748ed5fe2bf52fddaba442bfe193f6e28cc5f62436de51cd2b2737eb8b1f98db1b01fbc9c5729ffac6dd7df7a0d0fe5f1eaed69f19b139cffe50e4aaa185ad431edb718343d0891d2272e210ee19a192ab170096654873122a9b2f2c6fa00c0d0de18f8e11404e0c3ff8dd7def84c21fc9b60e8c954b0f549ec9603bcf8f372c59ddfc2599139d0b3c99f6ab43ac5fd7a077b114bb1c5de485791b022bd6c83b2e52d389322caa142b76926db918d1993fb62297a181f17c8251fd81780b076abbe43a3dd39eade1173dac4cae09db6299068d0feec35a7c06ff055505a221898d44dc108c2349b214a0844a7ebd8e3a02fa7f4ee1c0ac95e0e4d80133974abc147176185cefe131d3363c62bfadcb99df94b9e7dc333882648a0cf675e910fda3c62f29d093eaccddf56e431b10324be06359f4fcd59a14367f0a8f63964ddc7dd2e2e2d08693b6c17f7abbddff55b98158f01ade25ac377f2e73f97e53952c67380a1f1acff7fdf22e2e0bb38d8f25ea6d7ae31c023b07ce49c27397d3be8a72ce82e42f2072b6a5d115c166f8aecf2cd26a29a85497f83e688ed9864fed0d7244685d7e33683bc73b7db0fe202d339e018fbc797f9643a871edac78560259670b3cf71cbc2a8ae9545e44b1b40e24ae705af1369f1bb371e28fcc083c65363e2bba04aa12a2fb8c4b9e03697e30ee9402eb7a2bf7a8f13541f14e1dd1203920ecd9c753b4585b115b11e95e27f276265a82fb53b588326854005b2000dd56d2739326a4a97fa08b84b72e82f1f63e1869632e1b34384cdaf4e43c250456b22270ec533e8cd16d510029d4cbd275301df8872eabfb902b87cdfcd658c3229746bea69c0578a62cc773855c60c290436e9f5b0dd94fbb9163427a941cca0ffc037edf77ca5de81fc8d183ca70fef69b6147bf6cb0e2a30d7bd0ac7bce337b6ab34c5e7070a1c3dcbc5b16830d4de30a3b6defe8a85910e68799fcd123c351bea152849bbbb83d3885f3a2ab09c606a5a046cf2a0b39e71482db8ceea587dd206a53ced12be470035cda10403cb440a1029f22024e2d06b7f72a424154a0c9e183cf69abde5c6f332e681e9d286da9cf98846a5858c41970c05eb1e506240469454028cf3bfb0b3b7c38537e89f681d88763fd35754e69ed83db1b6e14e0259741db24230cf8f6bc25fa5d0112a717b5d5835efe4a20151e588e7be78d3ddf7c50ba93ebc88180b3c95aebb4c8c69e4eec7dc0e3ed8615908509acb69659b9c9333c3b5efb769c47cf39ec2cdd07bf83eaf676a75db69a7b8407f9eef85f5438411088ef6928f8cfde64d4ba99a694ea0b54d1579744efb9a98499ebd256811a1964eef20fefd2698a3a8278a70374a73a695ef7edec8434424968dbfd7d1d4c86b61ed7934fc0468c0b4eb21768b0fc4429791eff48752fb92a7b1c371e9f5897bd832c86c1872e4b77965b36a99778a47ee81a047e7b194bb4bc1f1370c0972664d66258a3f1c2446ec5d37b4525ab79e0b9d568361ceaf97829ebe6010e03cd40ab024a246f84b2667ce31b7ac34141635862030da777ff7fc2a57fb4519fa9b6e52f425849e63065b07ffcae89638dbb6670bf0f9adb0ce9f8b4887f82c851a6621f8f32f226ebfbe949dd3c3e224143b1382397a5c9286c17bdf3b9b3d36fbcd747ba226e4f244c696cc2899c1948bddb04e1f4ba618da25e4dca80270698e8bdbd5e07c23320c06820ecaea554d91c98cbef1d5abcc3fffc7686648cf2bf150e141309a432ba54c643598480be9e745942cae2d79a842d3d394b0dbc4be408347c4112ceb0e80cf69d9c7272b6a7ef14f587545bfb2b1252ecf423d1277ed6a4707f896b1d9e20bf86b5c06a7445e5c27146ed78e248de7c06c1c862ff0469ddebe7b7badae8f336712030a3d0c8f28b6356c61a49de83fce559e7e5fe2373ae0e27d122ed6cf08bac732cb0e6d6d29c030b0d0fa2a8b7c55a735fbd5057ec859bc65b72b24f21ac89e37427e6f32db6f3a7e59ca8c948a3d94e5f52e3b63106c9fc801ddd9f9e451fec7bfa2242bb48653f4a29894706f7497904b9760f6274162607e831d615554da8ddddb24666fdcffb3dbc253c246fd7c55c01f5ea684c0d67dd8bbd7652ce92561d5e193da3cb9ee99e367b9362078ab79ebe816482271a5a7e3202f7390714fb96f24b482e2fc2caa499a9f2ae4de4c6486bd59a76ccd1f4b489f298fedcbfaf777220d749213f4f1cbdfdbb9793883d9acad20d1b58374c5b829b8f35d57f290b97d619750c87d2d453645c1bf96600fb1557acf923dd515044bc52b3f030c1e5a0ea773e5bb8162c4609842c022c596993525474e40f7072c82bcf4d6b083f23f1f47831464d19c8ef960cf716fef88b6c272efaa7c413222a6919988405f412abd8619582d6bdc9f1119efc441c894c2bcdde69ff035bce6651f45bc758585b08daf6530abf889c7c78c3e224822ba92c0af909d3afab0d0e5ad1a619d384c45d03ee9b9b2083fc8e6da386d475561bc9cff8232983e36e764bf62ae4094f1aa2c6b12277e0d35b35636abd37870dbb53d67425e7e2765bf56cfe5cf6df61d6cbff3bd123c6a781ec0727ebf0e5df5da2772bd6d80a8cacd41e539a8ce237f7416aba08a3d69383e05e98bfb30e07d1b56f42dad4b0580a6df3459cb66cc1abab61942fdce5b74ec0a4e6c27062f943af46c3331242a5d74f2329f248ebce94a7c47288f972c51d9d40b089f3acbd921bba19d9d978d38a7da4e37e3d780a98b57f23980c3ea843208188701a6f346e8d52d059b071b7d505eb436f7b336894f06c61d2534bcdf7a44abdb7e7ecae89f3849792e9b348f406574ab0e47a53d42059ae1f07b89ebec46e2990aa3ec399096f4db48672758263b3814ac6e4ed9da0a73545d9713edfacf7e99527fcd798f7bc9390fc68cc05cf4a7ebabc3c1505881018ee9f142f633878d0aae04b921e6efeacbd462383760cce198def355f16cd7e1e66fb2fbec9a82d1db4a0facad99dad4d9affb4b5116ca7af23fdae9125c9ed78163b3a579a00e0f855167d9d21d1a04a00382e3d19abfc3814d62eb764831c4bb96178770062f576a8ad3efd021e72dac82d8232d1b3e4b4f7c113fb8b5b201bc6dbf2c8d9de0aa39f11de26d86960c8c993277fef53ce18958068bfaba39a25856699b2792ef7702e325c43b67c022f0a1379ada0d694a030e33108dcc2d92c09a2b870b680cdacdbaaa42533c0f2682e817cdae595fb7a9caa711512747dc3cc8275848508eec4abf0b11bdf85feb6b8c8bc1b6a2adde6e4dd39f5201102331c8b75e1ed68bd04de43ee7cb4863d824af1ed91fa80b8984e7c977feca740c04b4e2ea638f7751903059c66f356e0365fd1c659155b8180a721b3a47958fd03f1815fa7757659651687fa047b751949efc4c355da9b8945696d614255c3654adf30213563ef3deef5c7d72454b07b44c15fe21c4e539f936686f07435ecbc31d34f19f7a5b726baa3413d7ca3a05928b95b0dd4371084a5a51b6dc322ecaaebd1f2633108def05d91be3938ced54cd04bdfa780d1a2920061b3e42070d3d479606ac0a0afe390b963edae1a4d5686c61ca27322fa4c6b55591ee3fe9a8ef591c986a40c29b01f72a6c1ed6906a6266ea82c78b1b54e12cf647912c97822efcd0aab924ae6c5ddbe31c21a0cf0f8cf3a9e47e41a788909c13f653604c2316f2a7fc7a72ea0d6e8847f3c87b3a3817f46ffc932ebbb62dce84297277389316b9e942d85208c052d7e530503569cfe664c3c51346332485aa2cbd41f5f815a32fd13e62fe4dda1e468b43eb52b971a9ffb8124b9243f2d32b96d2e665efe9b38a5cb29907521ed5d908af601752c519f519702db2fbdcc7ef81883d5b9df80c379efd5b65cca096933c4784631762398ac6b912178135eb9a24b3341b791625cbf53410db1a46d299c6941267f1432a7bebe55413d8baa223e165091e6f96f135c46c4e01ae06c0c615fdb6e30363b8e2fbda887dca65cd53340c19a16468d303d615ed2fb7ed9da93c479297712036eab780a372a83c8e69226ad8f8ad8e2e294bcf57bda89c26c7a41550a15f0e3cd967af82349b20993f1abfa3982c7a0dc86f93296266547b558ba3cd971be53b99bb0fb7ac8513e6e4e0c15aaddf5ccf423de7b5ca57148766e345d37fe0a9a030b6e85628cd826007fa52ba2b599a7e4f001949bbf92f881f4bced947e382e82fb4463954216f40efd87fa6afb98fe91429aa69898dbbb25690a35671ba409ff2eab26bd509521ada0bbcd7de7fd9a1e4eb737c2dadc602fdbee5fc8d6a3e70d6d3f010941da1cc01975c55867dfd4147f0db3032d2326933a7964e1ee652814aa01fd2092df368ff2a44c057cfb146e57902e8915ca054c8e19c59595af08a926b55c59489f22672ce8dacdacab5bd051e83bd47eca7a8c27d0c478b2fd0e5ff0a1a627506926c3a7073bbae470ac112d5759552372acae2abf930e0298f3c4c4b056213f8d6e2a4ce85b4c985b2af0935c48285d50ef36282d9452a7cb7106024fe6ac059156c2e5d34bd6a8e9980fc61c8dcc6045fea9324f68bf4669c0636af87314489dee2fe4657e084f774013c75e8f1cbeff6780659083c3cb7f1b518901ebe85538a35f54da645feab5e385b59de18cb7d0f6f5771b4e38dfb890947efe37363bd1b487c0cae4e4176eaabbac1dc858a5d92db995c4d07399d2fede1f6d5740ccc27ee9a0e264afd9dfe69fd698f38ac061147fbc1cef71dd1f88570f3fa93903483f2ed8d7546ed24ad95b6c1b3a944b191bd76689b65eb30745da73a87745b9f247650f9a1720f5a22aa890f9b2684f0083ac1eaef66a71477bbd91bbb566e3c1ad25e1e12b2b96ac751c71b7c1e7f7181a7e88c17dbbbc9480e546dfcaa0fa5c991ef0497d2c02356199d0e407c1759dfbc3abc7189261b923894401a94d0f40f5b267b9580ed81215944815299e9b6a54c4b87d744860792e1f07c9dcf65143a09e8ebb7dc147f8eef46892e3d6fa7329ee42eca377ec162ff238cead9b04670a91284410d5b85e96ba2acb8c5dd73ebe37567367b819191870c61dd73531699d8e8bda617d5e3d8107d5010ceba1b2e3379ef6a0d9a8bce68744bfbb10569bca5576c38e6ed759d8d18e6b6cceb8634747ba5987c1c0193f1c70f04c59e064ced9c3d0726ced3457846e19be189683fabb378243798b1c7d13ce7e48da9c035ff9d87fad7e6648d58af24cef29663c5900fbb8641fa91f0ede0e0c70081472e64ddee7ef46f92cfb382c0e445888aee09da33a3b618a9764e79915ea436e822489f622c2520ac7dd2154899f0d682e57abb2f667681e356504edfac3b84192cff0e404cf85a3306ddb102da03652198c6e48e662010b0a4688a5045ff14204d21c27fb48c5a3ad574520c36d8b901ff09b31a8111643bfa44cfe7861af7222d099f7d4f971d87cad20820eb17da57788c117344042c1d43567300816e477f761f96041759b4235676c6bdae77b243e5753744950dad45bdf9f68be25bc6ef34e43069d042e7f98e3b0fd7262ed8561755d90333ca8aa13e37fc446d54a8fc44c98c099d159099f437b81996b16470c72e5da415267839e24f0da2fa86812a8f9743e79aebafe9a05ccdf7116dacf17cbde3c450c39a56df52ce6b1d0cf52e370555e0aafec7eb87f1aff93fb9ca8624d6775a6544825d78715d3e4d5bbb249a254b3275b97e25782757960c997ae5a46ab6e9431355eab997e08298153345102c47dc1d23142fcd70900a06fbd54dae249c1770639c9e2f8782955eb55610912b04814f995c824d4fa2e9c554ca6c959cf5163a87668351d175c261fb58f48282c4be28f430eb46dc7d83866d6e491ab5319e497ec467856f88f4e6f6a70e923b4d1c8ba10270a749da75e78d110da3e51de1429ee4209d9b3e7b5ccd8f1fa14ed8e9299039cb3cc5f7f721ceddbdcd43858819eec431d6500b17e1322aa7519d42f6a8db505c45830ebc54331726dcfb5616d1b250e9d6f369347e4965589de5a939ec3e598b00d9ac3855754221d5f337df01cdd23ebf9cd3a50b6f0c8781bae00211a596baccb865a81774d43938847064b65aacfd03c32aac6b764d9fab7ca059b820a93a7e301b4437d8cc723e4d3a1450299da3f78a8621166f871fb0e7a93a5e6bc3155b99809bc57b6a67669c21060094ec6d34682d727846eb0d7f5e789ec41cc5334179d7412f52cb06b99f23f44b6de2fd49ff1b385843e9a527d0e4ce3e5fd6f3a4b0e8e6445d55ecdcabb2a68bbc43e52b450d853873629c00a9f1b932c503fc95c42c16b13311533785d09fe13112dba2da43c5989999d64bb0bffa454c31ea8002196250bbc4c7e3eca16176b69421ae0ea4407afb9665fc8ac850fd8d0acc359fbfca60e4d409f53487a25ba3a4e025a99abd29bfc57ca0755e344b873b7bf7229100968826674d457c8b6e64936d4f47e2bda21c8ac64c710228b993f8c6459c6203fb8264d78fc6868e6f94466576bf3b7bdeea0e7854b2d1acc87fcfc9b8f3727fda39375ac6be1bcdb8230bbbdfbd15e791cfefb3992ea0334c2ac5e833d942f58156d86f44ffa31c34ebd2010d7b7ca2c54d235da801114eec2c218332a371d89e9fab830f24448e2df80dd95b319d1e0b6ad02396fc6161df4d187642e186f4cf4568d215d803e3479857538c1043ffe41ee69a9617fde5d75d8e9bc796b3b79d097dce1194dfef7c56ff4ab6e40a4344130394c9f9e0deafc43171984d03028750e7ee058970310d5a8e82dea0387c1e16cc22b709d1ffe521ee1ecddddcb6034d91c48a25c2a9682ebcf1b9c985d919eeca8268cd907400858d3dde1f6d25ce30c7bd87516982c28908a7bf1b854be394fc30f93177b8eb423240efefb45c9a1039e1564dee48d0346dfdecdd21d0d6d2c3857f83c3f6d46c58abd7389979cf5aefee65ea5ebbae182b3e1ba4f7766e9dbd108d76efca1c88d757853692ca4436650783014ee44bca5b6101f1f459470a92a00a1b65b0daae78fb414704950613a3f7b48c02df5d4245aee45163c7a8349866a2d7a96925b154ccaa93fde9e7a53aa3a85e6d849c27bc37e8c5243b5c5181953e41318003c11ee84627e73debf29931b69d2b27c5dfb251d60648d9591c9022e080d24b554f5f75377bacf48fc190051b30e5988ad266a4b1c594420335d4aa0530aac29b48900d3d8094bce1bb81674d27717523326a90c6e610369ce6b86b8a0d563ae3024dd793125f3a9e28616e88dd7e0a597e3459adb09648c5252b4bb90bc0aed261858c8f49744f18968d8fe26508fbf485039f263dece80e54e65b863a3379f59ea63c3824295f664d7541fa68a0cd19a2e99ea08eb53db79a183e77e5507b5d1ab8d6e5742701e9ce89f795ed3ad982e8c6cf97c1c9e2e26fdbd72eae2037a344431d748fdcfbf4079c62174ae6ccd43f22fedf34ac05bfc0c79bc28a850ee1740b008145570ee687b274aa465da55ab19224f4507adfe6c17b31933a44b8ac9e70b2ec0ad81805e1656910a21aec5b67f6a0849f2c740cc22c56d13f47f4300d370d17f9b2de4ca37d6eacc0545a3b1d99c0212e3623e233fe27b0590bd0441043c6002124e715f8891d348fd4c1ddc5a9da5d3d68fdc6e286b959483a210edf38c3d764f44232c0eb87744c0fd535e92a7588567441c2a4539ba00d2d3b65a77b81bce5bb3764eac6cbf236a06ee9ded0ed58e82adf5f6c59fffdb188a79b2153e9c8b294d51bd1307b412b73d64e00c40d873d14eba8b3deb4f5962ffc7a5b2afd2933ada57d82c0eaca88e7a3e12048efbb9bed884efe96f21d5f0784a72e60e430a6a0f36ab145953eb6d386d313ba4ea52320d0ce7c79e047558d017920d3d212172dc3c0126cfd2ee38615fadb4aa9ae2c2ec7615511d79801d1ae5c324be3ef6ed1d0e3aca55ea7e85ae018171a87161a80bfc17aecb500d3427683f55f014b9896772f0872f108cb29271dab94fa4f14615f64b646e9324c7c01c4b73c9e7123e4a371ab65805ae90c9f774c232c724c97fee0fd1489ca44ce56806a8877329a9bfef72f559cba1b5266f7860c9bd4ec8cd0207247ea23a6b62e06f4cbeb6eecef394531685d295858df57917c2b04a62d7bf53c3c7dbcc0e685b9df5a36daadcefcd429c703460b5f52a1d808c70b970cd0b8b609a49183e16987ddfde788ec0adb60fde463a5a4a8c3edda0e6953278aafc2edd3e6b9b5e526a2dc751a3180be362dbc49a0f0f3fc05ff28814ea8df97e81359b931df514d72a9ccbdb2017888d6e3bc5730c082742f5e22ffa8c6868dae738b12fe9390188ca5a9d79fafc65e3fd5289af2b31814c578703039e250560b555699565fe11d5bcd046a632894ccbc5abb89563f915aeb7c0ef1282a5560e20fffdb4ade78ad3b14c11fad9dc6c9b14767a4e7fa5e228001d642484ba3b6efbc1e9254cc7fb241ba9b0acac3c8a316026e1eb174c419f1de1ed29050aab392399725a8ae79c5a1af939200400ad58e3916c0800d94abc5e3a0bf8ec2d9e26a1d2526719861aa65a570b7d41a8d4c9e0d3d5452a895304e978cc1f8c1029ba3eb8dd7fcef12016f4d53395497fe144fcf4e2fc3488e9569ba9f2df2d162fed6e1f30ee9fe18aaea6048dbb8fae6b4831562c26e361997e9e5205200a24ccd3b340a5f0dd41b23a149361d15b294fe5cc016941b2918749f1b01f7e06342ce147b3aec31effe4f1e5576a4b778d7a36d7679914e053aa53284ab7bdbd12107d873266fc6efa5c6e7c536a13e1eb15a835bbd0465ccc7ab3bb21a6150a72647cf69d665b6912bfef0667811099741eb45863b7314366a4aac704b61f81ec26ae5c8780cd648c7e343a2d6f9c15e3aacbd828807fa451bb61c5ab624eb7c30b71e8c15b46783a6f3545b7dd07dc37f8fc092e31f81f38dcc7231a99eb1d73b97b155196cb4021e22bd93610d9f4e5ef4807c20ba9129dc1a37e9715d84022c60afbff23c582fdf4319f373efc108e5e3d3fbf8a8991c2f905df5555a673fcc687b83f116f5c21f785b7230dccef2609487be27fe60617472115656d954e5035ea1ee098e9cfdbd9590157f76b9df298328ee56e3a494227769e2efda9798fe9dda77f6eeafd611ed2cdc1f87da7396f71818ff35d62b1e0cd0e28ccb15192425d56966604e9941054479d572a1babc5a3bf5abbec865997ebdaefe14e9580dde748b555e6134c604065c9fce8796d6e38b02679f1375feb72c223c94dc8585cdf9a9c13f640adf5bffaf97ec8af02ace7ada206e8fe32836722000b67a06e787601d680e00e8aa95443045c20f21c701de2c79c905e6eb4c1e781fb9782896fc6b48fa76512a491874a567efe7df0c1a2d2e3548e3890788aeaf531ce776eed1354f4ab59e97557e8006f90d2bb932afb3ae61f91e1ed62396f23f9acaf8ad26dc3ea1e80a48d681d851667a2617c45f04c18e878ab709656c97f758f0e3bfdc86c75517a2eb4e7ae22c47440ed69518ce017fe3ce93b0d47177a05792aada51b6ad24b5d1c9866a8e5be18a804fff0ef15c6976e7d3e497d9b52d9865784fa7a7ba67ca67716c55bb9a8a4227c52d9fbc564d41d676f1d46726eb8889bb7710574f4e8f0fe8f06ffe4c6aa7ed565458a2831cb831b617c81191b44b4e511bd76f308357251b41bcbb21db0991ce7599eeb642cf55c86faeb53e7940e52851fb29d9a73c5154b2f7a0b949f636b1e1768d8fad7150c5b144ea34003a16a5d212052392792d07e578748c9cb70018abb1eecf930350fe1fda9f613db1af0d58bfe67fe6bc9401bdac9213cb2a27826cba74de69f476cb365df95724d1dacf735ce4a9302f9828f0cbebecf8fc2ab0c460a9a574e07a460436b34c1d7e8aafe9ed739a1280dc555d319dd61702d746325dd38b3e1da3be6bc3dbeef751a6bf70a58b1f1a096199ae4a819c71eac5a4329eeb58a7609327eb1d78e856c50f2650b424a2181ff95dc5e054f19cb3d3789e8c9be49842eccb9ec7a0e6f07d6ed2940240d414e1cafc97aed9e3807f6ca65a8d85b27506cd5155ae74a4e05453555f1238f7f871b16cec566485fa9965e2a68fba6b838766b895976c8619ce252790d979c0f05208d0f93864eeb4d4cee2ec2d59a536641e19dae07927caf1aa87410926f93c8dc6610cc999210a59bd76af1c18981fce844fa830a43ff67eb30aafdc7882be21c87696160cdeb11502935e9200eba85efd1b243d70095d6462de8df7a95526124c6f35a0959f04087dce51580d2a0b7388eed1cdaf2a1a0e8a3c4d1fc0241cdcfd4cb693546d5d39a57f6d5b7636b04c60f0a4f4cd0c34bb53fa89a016b9792f5aad012f663c764ae4be0520c2d7c51af496bacf6aa15580741c55efe92aef3e366ec3397620b640c36f4e3f365d72fe23c80c5a3731c6c31bd07bbf34ff4c3095a18d2f75250c943e4ac9009832fe6fa7dd454414c8c3a13be72ed0be3e4f8bc806cfeb593748169d47c32ef88ca01a8e73d1892602fcceebdaf84019c47171354dd2006f0e8949d805077091c9de9f65d914f17cb046817e9a86d0518cb4a32bee6b6ff58c0db54a524d32213a5dc9b26271cf60fea3c61ba4a3fcb7bb8372bc8e35087ddd5ca2ac2e98b273682c77dc9704b5405e6f66ae19a64ea530b293cca64e49b1b684706e4a198f88835a85db2e7cf764435c9a72d47ecf15277d8fe56517360df791f2357d46c5a0a0ccd1f697fc972e0832a0d45813952c01f880dc964b7625864790da73dbc0634d9ca1ca688a1550b3e7fd434f1f695c98b6ccbabc3658bdb474a8ff0e092602b8156aec355ce9b3fcd4a612d183b365770331a6a49665c339d86dbcc70ad4aa0c05b811978fb60324bd829447938b1417bdc8059183862f04596e5fee375a65056ee91ca2602c8c2a559f3d0158a48f27264ead29bf83f1033b71722b02b5f03ac81c2cee2795a5cc23b7dc661e146fa69348300e15c7ef5cf75e51e415d0172f4fd2fc3f7e7676726c7267e7c8a607c561e7e7d835d4d7f2d77edc2249cb8732cb6502ec097c6ec82d4ac99243e9f54584eb38a07ef0d805b3aee057b6c1bab8cf649df848187d8d2193a7986d96931eb070f41e430e6f0df69eadae1131af87ad0b8654b33dbdd44665dcb06cc87a9d34cc24d438cfdc16e130e36c5cabb36a3f463125aac3acd41df502198d336bbde542c4787ca734c7c5a899e315d7a5f27753c3f3c9be627f2556c1a804a0c6d62f8a3b08f62c831cefb7e5cd55dae0d51323fb8f56958c6d20bcc5df7a223ef9231e549a5b2961e923a564ec9d91dd43dc715489dbb0e461ed1741f525fec45d183bd3e047d62788041df4e173615463eaea35ff5541acdfe35ef14c697360aa21946749350fa10780dc6167a267fd741b92d0ab5c9419ca9dfba2655e7bda1cf3817269a32a8aeaca6645281c005236c54a4fdfad2fdf8d8ba1e6d06206957a595f572c9a282e270c803e6873bc3f720547ffa199dc8eb26a102e3ee5cd7b2fb227c310b6e310b8fad7bcba59915a5851d7ebaf7dff1f27315e7de961877aa443f7d88d6e4c602e5f85e9bbc94ce65247290c66e87043a7946beb782d5b43e95adf787d339425cad1369166eb856a61d4ae004a6ce885a7e03b0466b98c5b4b404b55658d8041122cb467d3bab24d400d18c7b2c5cdfb42b25d42997489786997b256619076dd7679ffcb1ccbafd8887827784e97b542d645e0c0e6ffedb73504f5dc78d6c3fe743a36f4c6f86ede0fb952ba4c9142eddfb7f5ec34760c3fb4a087c0df233cd83d8e1695142c7cb255b0696dd544065ff8f70e9071447a4fda9c76b0c46b9abb24a0e61ef3e597c9dd3e31141c9d2e1dd6f50eeca8554f11a0820efd80d46ed07eb5c57a16186c598570665176b1d732f441e1a857fb132f9e8a642c3a17dbcce7cde3ebe319a69b2305284352e9ceff6226604b3c58a9b927788f557f0ea3f9104c762137bd524db97561df06e9e6733cf732622f69ac41466a71e805024a360ba11fc6119f4db28f1c7864bfcdf3d2a034610079ff54592d70af47acc78122575c48ad33e406811cbf0541a378cdc183498d9d3b34749d7e677a522f6aa89be6746e7448998998fb3dd1ef","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
