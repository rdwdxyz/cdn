<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7667d9f03ef0411371c79f68a467a62cbdc22d04d931365d0c9ae03aacf08426ac9d9911dd6378584c044be790b14f8875401d1e634b21be6ed271768fbc4d2e4f39c772a7f1d06504fad7b56d691f271040326ee124fbe1d4f2d5eef591da34d2e13d956207f015d5466c002c7e94b0e78e50d5602d1d5e787b2172c6f1ba37bd8f1859ccc00b45af7f77e57d092111a85f6d7d006ce5499a05ea45b6609ab2c465aa4577cf2a4d33af19c26336ae359e66fe0ed5aa6f1dd25ba3c7e7859d9b8c30edb1899422cf90f5744e3f59f99000907d87dfb6f9becff94fd154fc1c6e98102fac272df8ac0e71fb0bd9dde955cd403a80784942e45ec25e032fd9c05f694550248507d3649a79611d348848553232a2a67d5a9f2497aee8aabdb8f9626516e6918e42c00a5d2fbd80647c6f384a1555cb5959748d4e181fe8083cfe484e215f3587f59ee6bef90143631409081634dc2adceaa030b29e361df85145e37cd3fb5a7911b77135139226191cd3635f7162b193ef87dc38c60f33a1e5e82c63e94a043110b53426bf66d8e6febbbe6723ee8dd256d131bc2d0530699375dfd8aab612f27c8ca006fd6eb8a6c32eac771231bb8cc10e55275e0d81ad200ac6a6e5159eedd1d99a873ac10c2d06be32b51f18e36797c8c8bd84529dd047249b5000ad0ba96a45d74c7f9541e3a690ea05e889b583c308375c60bb555352537961a6212379a65ffed316c56f52f45d7dd1c99544f5a065370df4370d3cd71ef9147a6956d6bd785424101b4ea424ab7548ac7b635db391a7882a44cd2f331d601839a68e0e39ae409c4f3edac3219c060fb7f81b646e650e72c6af8b571bf8fc5549696bd5a622433b3afb21553db23881a06e61a511d6bfd27d2c1e3438566872ca42fa9ef5524873e4e6d0a695e1be76422e7044c6b9b059a5ffd89428133a0886c9edb28cc3e71fc1f8ef617439dc8c9cecb661342304a88bc25f0233d7b7e0c2f01da613a74451a7e77248e15d130dfd35a2db40b26886d59b8c6089afdbeecd8e6646a7eb36d23bc34abe91d275b02d61bd5a2e69b08a92e14ba259c22a63a6c3bbe28f810e4fb9a7f36f6fecbae5136d43ee8a6a4a3e6d2dd9413436bf2a22b94a94c146c4419833658dba8505e12e4670c2a4a7fe971d3ab6faba1e35d2e308340ec190aaac222f91f613fff75e6c050aa6713563b1780005cf182ec659a88a16a6093faa1e2e0434a343fe4f079c80199e50cc3aa6d4baed75de0583c8d80c42ceb1bb07a9f66e809e24198ccdffa82ecd1af44397c2453dcb71dc89cf359dd472b16ab3756814f9b5a04661c9c71b7076662e247b55a72b6939b6f111dd852b41b5f3486d9e6f0b25f682d2587d0fe98cf13c0f5d0c3b88f2da57e1284538068186836feeeff64ea287970ae6dc9a060435faa154bcddfe6531c621becab063e3b7bb2b4e19133cfb1a9d3243bbfe959c8d2dc0ec0f135631f14ded4b8cd3a790749712ebe1a4238f86e048017caf6c0d858240df633c36a8a5d0e9e4f75f05ec1334a93d298bee7639fe9e7f0c80378c749f366558ccd3f9efc8e958eb5216e04ed38f06f75c94672ffb7b350a9d123d1e19db5a7901e172d56362b211b87b8502cc1afc152d73dabc3f5585eee3cca66724f62858cb51d793a8e7985364f3129f4f3ba4a437cc109efb27736c3cdafaecdf920944e829b0f5cdfa442b77c2d3b674fdd6756cdfaae11bb196c882cc03a779ce86382bc7f75b88d9b9d7a79961e3a130616fe32aff6f6a936f3b121a6ff73311b87798798b43052b183bfa8becc5c2297f369399b0b523870e102c6723a15a6dd085f29a6216956e01120020fe2d454f9a7bb1280f40431554d6ab9083cece93e7606a9073acf79c1434317057dc059a7dee8f39758cda75116f8cd9d87200daf7382f1194598d7ce969bc24839d84b88697cee9f9f1abf252e01462f1ddbbc3b653f826ffcae18db3054e2e38a90a46ef740d512e60c6b60713caccee565f5a3e3e33d9e27f247665d8fb8e11156488767d41e4fd40c25c1d498b47ec660409c707bfb1504b6f792a62c15bfbc5ea36b837ec85a1dd751f83597a8db0a858ab4492384cb638c68d76b3596a7c8d41e6a7a502702a340ce4a0647c3413ad84d43815ec3e71d174592958c3b761e22e17a5bf481bc64ddb3113347db280a4efe73d36a3d7131c1c9907a25eeb4d802ef857f8a867532cb3a34a2b072105371a0abfc36f82004100c09406a3c10471c0d5f0d731269e2583ec7a3112bc20557dd23720c9714848f6f0f7b403c044b1534766323e1bee5a312498944f7df5dd9f2850ca54e713c7f330caec987c9721b7cbcff43237b7648e28da67bf9e350e2e8e3feb5cd3c904ad868fa401ba11d678dd8159095d9301f8dae2b978084ade2ee416d97d0d6af5ecf20fec6148a0cbb4678526478f9483242bac59f2e67ae218ddf231b9b5460bc0deb3b119e7fe8b6228d012820638d715441fa6b2799a75d17a48e3797f1ea7f6be8b6aca6793ea381d2d16c05a6bd4cccb49a4f8e92b880e2b064effe114de495c45b0017f80be0ae1dca805c83514c5f9f7d0dc50a2e60f48dd97ffca53ca945f59e58890455c91d12883b9670a35d361a9aec2041d2a2d8d54f71c8ae0969fb7ccdbbffbb03f7cbd1a2de4d37b4980d4d038bdbfa713e606f86eb8edff670cc6f2aded6cf96e2c698ff565c42df5333c808bc9364b8e25e2a6fa43f9abb3f037e9e98b817bf88130c2bef61993d3437e3fde04af37a845285fe6ea6ca292445706d3aca2044af144c59e464c45c0aa89aef46c15dae7e9b8016773dabf3ccaaa44b40700351f34871fd8d32bd58c6c31acf356d3534f2138fbccd5c865b76142c53d98b0781cadae487daa9cfed2932be42664f76817538afa38cc9b61ae1436ed2f3072a3e1498a8aeec4bf9f193224f21d22289e546203adac9cc9e2a69875f19cd123d97a071e24ccf388a398d05057634e42ee5e0763012483bb11d77195bf73927edc22301635526bb4691ce28c1f0ac94ca02e33bf0d73a040816c043f57770633e16ff0d81e116ab20a8cdedc1f95364d6a598ef1321f7c5a7e58cb514eb3c77af497b1eb0e98eccbd37af8abbaf6c73a8648ec04d3c531c7d10ed9fd69315078baccfcd520e4fa9310266c378efa277e605c2d2fc23603f156e4693bfa1481390ddc49dd8011c0baea208fb5ce7d2f1693bb3cf6c03b79329d6f67ed982fd33c68dc23bc319f24306aaaaa5d8d3a2ea0f64faf476add11fe8640291ded5292bd4495fb6feb9796c93073c8ca8ac1c5e4083bc6bb9c140a9f89aa0e5ba5a7db07b314ce16df01f62bc70d1c7e70247205cfbc4f74d4d7e07b97614f3cd84a472a2f88fe9fe462c12b8fd622e1e0100e25b59397233ab3583d330551ab5bb2c36a74c2e919eb0d4ab73f05217a3dec76909c9dfd2855ce2c3a030636f7f6149977fb76dbb054b91b3a5ad70532b023040a30bc43b70e663b9d6efbb36f7f9f95fcf3e6040c0b3e6dbfdc06209fee2d5b89c7ae779d9fa1ff26420d2b52c86d6562757d9ca59ab2229d98b8fafa878733f5052fe132d2912b85ccdfbb349d7ee287fd8d9943b0edfef433b74dbe508e5927121698a3944b61138f49ae3085baa3ba9d4844a92758f355467458ba79649c7dd27318524c2e7efc81fc00981ef3fbd40762ad98f14abea2584f3b0b2dd68c356f25753ea047c98c0d53feffcee9ca637eba244bee84138d491e72d3b070a7312b103f76dcf82648e37a5b8ab60f0ee137115a35ae8c333fd29a4d590b1a95a108ce6635deb539c6f638017444806d4cbe3858921cace7b65c90b231c6bb50d750823853e2e18f8209b503c9ff22f056e3cd7d23aa8060476da9847b9d74aca36803a6b1cc8f3fb92d62337f0ab65a00cbbb059e0bbcb206b0d1a765f1ba78772b568bf030450fff8a2e15a0d3b52e98984eb01a1b8e80c7e51067d63a37c78d07f20b10335600ddc68f14decfcb954f1a66f8358bcb7c103b0807e4ce2ba167e8c5b431e006a61f92235cbce93e1e916bec2ccef5629b1939253c4e92350497eca86c0826adff45ce95f5f832789c857a4d423bf999026cf24e09352e823bd33790d28fab3bc995d2379c0591bca236dc4af4d063dd5e533d4b7586dc68c5ec19f0317e47654ba1c2bf9039bd2da2aa8c9289df12bc897cf33c8b69ea33d48c6c18940f392ca984ff0fa42f8b79502485ae8a899578519c543eebf3ed61bd5f20aca961f5d448843d5f62498dcbe6cfd0e6135de86cebe47c71216db2f8f13205becd526794b4d85e5b74a55c55341df3456c96fd8e49911d9837f3025eb749a2dd1178debf40a4a598b09737c50ef0bb9270e905e3ba83ecd3bd3594cc9130a9547be48f97b6534305de19886279884557a06884022813f87294424222ad814ff774f1c8c7782311350bd406561e87162c13de9a2982201bea2f03775d2d739cbe46dcfd171889aa8f563f4057f05b8b81b427143f6d76ae61037cbaab881b6a0be3a696c97e7238cf268fe1f97c85879b8e0198497bc73fc4b5536bbfffe8b4ce7a20636879d9e5a7b7c3af847a61f07261acd43d9cb9b193ecd06844008f622415406bba503f793957cf6a745dea7c11ed403d4dc97ae07b613e458bc89d6bfbe6bd0ee405befac99f584d450209be7c690812b931f7f6e7f5f3fdfd8b622f95c007f00e4a3b1e2ba1a4307f7e9d0c6846c4587f20f9cb558f3443bc08a3bc4e0b56dcacce57cd771d226b4edf925cfb266fa54402b9d713d01f9d22748aa31cd4caad57a45aa1166a86e9af4f1a9f9b8d425b1826df57df8bf4ed4a8d84ac1fbbe109d2b6401b5eef11ae4876510fb05e3981e96776c5ee2c6b07e16031784388faa5bc573a331ae099eee938495a49d2cd59c4e8403575a999254bec488a01f40a0b974e241115324a70b531f8f8bb2fa56c766ff697addbc52e8a2664247134e78b8a6a988abe890679dd3f9012db77c5c287818f47cd4d194cbb552e9f9bd6b0f92bf5f9f73194ded081e386003754753646180c7eb06e751e43115963e83befb2920103814e188c43ef78cf4c54fd5c2358c3a2aaab53801fcb60594a59c7c33bad1f02135cfb09fab5c5488f91a76b68d9f6d400928a103707dd04b946ca3100b73f6167e72a90e5b3db50d6edd9cbd0591dbeb3ec9daf2518decaa49ed1318c7fa33df9ef860415038b81aa70dfe587cc73ce7c01b70a489437c546b9f1234a1f1eb5ba0532f7864b4fcf246534628d4febf52ce8d6a3fbb0d5add139c4c2003d5eb7e4758d8bf888e6fe70d42069e36ed93c9578db1da65aa0e66720ceebefbadb3eda035b1e9637f4945de4e93c13bac0f1bfcc78d1f0a5a2185a635233235926bec701e9d94efa3e922b8117dad57f6618689c52e9b27726b1f646f1f099147999a91c27daa78b083edfaf24264134f10ab95600da54b8c89fcf168e299c2d9e356cff88e12777e3cf13b46ba95ef535f4b463a256c86703a47cd0a81687170caf94cd49638b1e17de4260fe44b96bf75ed52ec83fc607bc24b758e90df3fa75247429cbbde55fa03a89ab1b8232641d99e699a10fcf08c7a4dfed48bf8b99347ba756a040d49b9bfa6dc45a9055b09ebe65d50f65e850884b9f98ce59580849c67feed7edbf1f68477a86fdb2ae539644f1305bcbec69c90f4ac7a276bbd83c9723f991e855a5460ddbf57ac11ab244820285791a3ba2a7c09bed79149f5a94a2fbdea1cab9fced0c6fdfed42940e0f228fa60b6dfbba3f93deb7e04ad70a6b6baf28713b9ca798fac68f66d22d7a874a534122ee729ef286561bfb92ec872ae6e579c32fcb7d84c35a8b0c08cdace4982f36d89cb13df062de40631f6014c619da73c73070b0524679a0692b0e960458af3a323d16798504923cfd2b92804fed3addc090f2344e84c21c446ce2e70b9582e13a8ebb18a870eb58ce62de270e80bd2e5a9c5eea7d4c0b3f77d288e065349c86940051b7bc7485926d0cccc12f2b732fdd5e49a43e4c1de75527defbd8b24e3cdaebad6ee05f572214ac6b73096255b3918685a6aeea18c5770caf97b2ad876d313d290e4dbfe8b900e3d961c7651d8a80733abcdc8bd344d65c7dfbacecf29ee4bae16b914826a6008db78a2e9a6c15ed4a02584fc00f4c4f67c51fb79ee1d0a7fbcd66a52ecd46072e6dacab64d2829f66309a92f62c2228bbfc39e3bcc11e0b5fbeececf05c3f311dbd37e29fa865311ac56a8ac6a6adf1d257cd514a5328b6d90f1c38297a98f17cf110a9d82e75d5f93221236a8ea43ef1adfcaa58cb6edc56c9b80916c6543244e09b51bd974e7b5ee529b2279dd5383f51c3c275758402cd0ff03317ef556844ca9045b9b52788682f5ad8f60f3b9c21cafe3763a118f6f169aeb94f0f9097b7c34e1613d96fdbb974cc4eefcc17197584014ed4449b8970ef66de0fcc5c4a68b9c7ac582ff6f3a65b45dcb57f6e7e47b3721c5ffda075d27843ae05378f577870a2eaa8c62c32b103fdad2fb6ff87961d2638efca8c45a321c137484ac494743e4ed2b9cecef94f1e97eaba2c6ea347084738987b5675d48831296b527170a237931321b960e9c166a51a21fe632a23ad98855d5b98b9c0f6ebbf8509ee694165dd4db032dd1f74f1833aa6642b9a0d3476800fc6180e1381ffc225f3ac27961ecf893cf9a73ae6bd8b3f385072769c87ccc59c3ff5a221d8af88da350c85f72af8faa449f08bfff0c78e9bad20a7944c10599937c6d1e9729a97c82f8280ac4f5567186e1677d5ddb55a076d1fe2ce5a99db5509456d1ffe34bcac7ab294890c855c46e819f1e459b193f7de890d1a4e708da0bacf081289879b5959c33260dc27e59e4f555cef7eb9b5c1f0a6ec80f7c5b7a551d246fbde94b48f90c57b86c602e63d1f49edd5c496f1972d5ab15e012333b8157f4b7da676a2cde3ef099e0ba9bbc83a77894b7119447815b1accdd37e4a9ce0b04515f5445e55dd83f3415833af0b4e57271ef0a3da7e14a8228779a37b463a8acf26573797a0bc00de9a5712a24045d27f7bfa20bddaaf2964989a5cfc9df8ad1763c66e01305f0c6d0826bb2b839e1e47d80455e9d70159c40311ac80533e24f1982310b84d15a163d9f299b660faf266061d6efc22bb4222f5731190cf9d37d43ce53de6cc016a7e13eed376a2dd6873461edd878d76601c4051d87cf9befc3baed8e3005bd07a74f93c6e9ee25fbff71a328f45aef9614de484268316ddc876eab7f18d46326b992386711928da2862712c555dfb176a7ba7b214e0bb0554db89658416598b355734dd6277ada5eae16a3ba53386d7e1055fc965ec632699d9df4203200df46c09cd49d33c42f5cde6f6f9ba94eed0f836221d58b816f44441d306aff3c47671f5378e65cba46a5a70f1057749c0d466adcfaf96e6359af4c9fc94e2672c5398d54d64db3f6189ecd16d04f646d9647d962bea0aa0761ad65de6782c7f59ab8c4b0be56519db35e09a035d9cb9394264e335a69688a4b99a5a7634d4da137626fb55e3b6288492f7e522449a02c5773eb93537237825f777c26890b26108112add12b1b5245a28872ee9b1fe727269b5a10d7440d9a03924e86b8a7acbdee68b417d102d8dd5256978d4842a470d1f1be5a03beb55797bad9fdbeb8ab37540b9504cdb80afc0ea95abca88d34a014b69eb0e70f372695b64d954d5f2f571247eaa680103a58c36faaa6da87381ee90bd392f16cabdc83d365ad1702855c285d32ec9c02cfa301c80b01aa38832b862836e82a126d608b72e0f2773bb0ef069833c3f58ae8f32fdb8f9c2309d4122251d3690ac4b1b60cb0292aed0fb4a18818939e725b0086a60c1775137a1e04f2d29427983ae57fc900dca66a5c42de4f3dd32414d2ac94f63dffb397aac212e48f15522c6a30b4834fef74130c00785dade07dc19fad51245e339aa1111b46824346da78dac4dc3492dfea582e2eaef16a7e2c10052930c3112eab24df5c6681ef666e36b3bbe256272f7c8a8f7800a51ff943926d790b1722a3b685f1ebec0bb260477381f5e7cc8311d956b3c01622f76a926042805a8064ce57d1aa3c65b1f1e9de5124b247bd0744c20dfd4a27cdbfb0bb7a7589f88c8993ab326b39a50e343c626848d8f4db6f00c604a4f6850f686b58a42fd8c3e3ec4b962d1ba519f5b996741c217dad61c1b6710a741cd6ab2623947de4142942ec4b9186f7278aeb75d876d5d7328760a18ea104200afc59cc883e171166fd16edcaf13e9e141337aad693539db01cf7c4e21d724e1877209c44f3200f07ff995113af4ea69b02188d7d26d041ca080f806ff13f598326c529db7180b3bafabf2649c987796c0ded459facea63a1b2409d96cfa15f406e67f07dd9f3396495b59a88c9d4ac8109fedb20ae61ea4ed4384a3aa016c4773d2f09b7f8b73318e964d39b472bfaa02d1c8fb0806f552804781e397aadc5cf24bf9e9188bf1dea0e7b0494e82eb4e92db348cf28eee499fb9bcf40c6bb148b6eae4c84e0aee07201e601af17bca4ebbe06e9442dcaf2c3993d0ebf93edce7ee4ce4b3e1b0282668509d7c57517f804cb689f97986e88f0a3ce0605b35b0cff7a6122a4637158ad3c0bd99573764c965e87fe75fe06c0bfbe3fa7778eceb420de9ccefd3ad4d7632925622e938b61d154d8740bbd7b48225a35a86cf33440501be864277036d9af51cee91dc5271448ce008b59ab30c13699e218c5ab99ab7e28f6407b9120c3fce017fd60ff7024b022bb9ff35d6db80debf63542b4da6b1092c5c02576f4c9c60ca82ef3092e1501e35d30ea3c9271bce1554f63e5cf97b1f065e4afe81c020e2ad6a8030589f22419fd1dcd1bd0fa6edd5b0ae7d77595649489b1e9fb189be35ef8552b35e6d02d811653fce647299305dbf4db40f557cc0312b3c590da4475ad53a5417ba853b674c6ba348deac863bd20b6afbdbd57e7ad8a93562008f077c2de13540ee7dda58d7abde379409b25535fdaab4cb3c36c7e1e5931a790adbb74ed170af885a43527bc7ed2e4c8a1707c7dc63010d42fc443672cd081ca859a0e26c8be7c897d599e7f4923a2e4c3d29e3f3b79985fca533f3608f3ab0465841e948580a71fdfbd178e6e5a4afc5955acf4fe6e166d3abc5eae0058bd264c2641b0f73efb641be07cec52481ee5ad1967bb2a9fe8ae12a90f4d04ba73472315fdff357e5c67a53be6c3f27f72cb88257285896ed0408700bdfa3a9b02a58bb06dc70070d562d8a3362e7d88269ffa0e7ebbe46cfc00248ef25584c9c47e4d02720dfa75d439aebf331ea0d7501317ba736f7c96255269bc2867df21b7073915f3a0c4c41b53b8d3fdfc4c4bf8d4a21fbeadc23ad460f8625a7056ebef4a3bffef2fa0bad9f2e204e4ec1b9a58877d50bb43de0147f2b4683f78e090d9f80b6f9e3f03736a39f254806fa1afc6be36eecde12b4501e6456ad059966ff963e1f456d7d6e355b73c7eda0f38f24c833212ac96a38236239fc701c74fd399ac60f1b3a0efa975c5334255dc5bc7ec9f90656c6fb13c9bb6c9ec7133964bb3c97137c4a7e9d03eb0a17ebdfdcba1514d3ef327911ade718eb259cc1af92aeb40ce96c4eab2c866cb3c6be56f4f3cce9a7c0f6918b000b2b880b255da201a5b922fed97155b826369a54314a55883321f815f263b2ead9659af169e8268f3e550eee2d77008c21ed7cf6efee5b41e162014784ce1f095ca31a91d8b39d36b4a661866412f5d69131a7fc1e80062863cc588ea301414d1070ccc923cc146718a253e6dd551e1ecbf5cf489ac79d923b3ee01ab96ab57aab64c23f9900039b51613f162ddefcfb72fc45f5f4ba97ae0ec2d8e924d3e15603f50f61508b83d9326bfeed0087236ae7ced372891c4483376d641d4db58580ff78e875544728022f62b21d55c240e1b25f85648e089c7f56a65a15df0efff4397bee0d422bfe7a9c97167f32b10e0055d67905962435447f71a2a53eaaada166fc5164c447da0f9ef41cee1aef81b3773962193b18d5ce789d6af640d4b0d69ea0061871d7592b5f526935ca7d6b6dc556a755c48ac50b91cfda103e9741958e809f62134f036150c92f8e0704238f78bd324241feceb28ef0b920ed673a904806916619bc4831a156807c3fd7ac224b833e27bea5328846766130385c37d7a2a4c71440b064e6a55f79ea7d36fcaac35a5a4d56fbb96fb713c9068af9b6e12b0d6aaaeeb3dfc6b310b833f693b7de09966d9d759e463aa412ff292f8d73f39a159e2ca49c141966d6624d67364a572d1689ffa95fe80d49fe3cc9caeaff8ed69d938778be94adffa29025bf74d3bb162331ba9844fda392d970c9d92ef44fe083f13aab3fd600e87709a766787b75a139b07010c38b600f414fdd57e4c75641be5f1e29dea23d6df14c77669d3a40b391bbb0ef8fdfd6db61a45baec17eddea5de34ff31ec7a1f0e3f7b9f7c083f504d15774a5e0a8fed76c5898bc91d3a9c07fe35e31e38fb5e964522b1d916961ff186cdf3cb41be7bfcb462f62bfba9e01ed7ccd78b9d6fcde47f4073dc0a009d79793730fc8760cf702958b0b1b7ee591b5f44453d33dc348f8e2cf701f30b1c19557ee58764897b1718e509fee056ee46df20e06ef031371beb395d3620b785fee5625dd9485285c68e24ca3e479bf84d40c3a18f00bbe87d475a0e7adb1a124a7e1ac18491fa54a653005d1b9791e8ad7362587e334e490be2579fa11816f4e044ada8fb7325690459281df7713f8ad92a6f7708a8d6ddaad5942861cbd826486ae7cea9f21ced3fed305dff9d983c5e9e6d67ad118826cfc696117257795147c4dbfcd7bc5310a1d98daa25a97a695d1000a4028548f5c8db0d32250e3ae7193bf77e2964cb51b1dd0fa023a81e244c0cf6bf1e02e89a2e55183974e5a921077b5701c9556f1bcbdbf9cc77e1b4adf293a9f8d3dce2fd17e2a5bea62dfe7d5af82f31a389215efcc256f51fa4a8510c6b17269f546e2c1974e1e843895f573b6dacec5cc482293e66541346e310ec4d7969b52afd35b8f07a49e3491d50c1f3d9f3d28a03c46905eeb8dd9a679ccc9e6245da4d6d494a179fcf34d12adb451e5243b49a4bc956c8138f4e5e865b3a1d03b9afd2b29df413038bc693e2f3b43736602b4661aaa91da594500190b6f507c3fe72d8085ec4a3f903419786e6d46586fb1439e81fb39fc1fce9697cd3a5a4fba7a6f778dcafde0f493234991ad99f13855b33044cb9c74b2e358cca28b5aa469582d8ee1ca044e129fd5996e915b719f9ff373b6d0c055baf0333f99a3a16fe35184cbef5468ee3c6b3d8d88ca974ae204d75d42bf64ff22a444728bd25f2563007a6e6c8f1621a3c3ce5befb820f6953fc5bdffbd72335e9627e5d63ac82d15b41a810dd6683239772f16aed76d9b84b4aa14b11ca3c73da953a3d12ea9eb348d1ce4ac6e041f72a0388fc583d0b00f748fce642e2427f6d9699c8c5c8660a47cb7954e1ff685d168070d1fda791c5603a36de5d35be003eed83ee4287a07523a2dd86ed48c7fdf81e91ca1d601951c2467ad659f0b2e8f81703a0fc53f5c711c8e5c0ea7ee0cc383d19bc288c24f8785adcad35b2335fa1e8546e4bfee55fa17b8e8dbe1d9b294c8f214994231bdc8ce04b28770829ca1d33f8fc8dcbaa78e9642a54e8944291b31fb411e89b25fa9f1a533e3d38b01f9f73a7a5f3d384d1f22d5d282c229103cacfbb65542780aa226749496ef472263a507654f8f185d0d41adcbd356a12c4ae3c37179ef914df8ed112a2f04da13bc37acb3dd6554ee6767b77c1d5523930e997f612d6e5223bda83c648a6c7b671487cf356c897b408c9b9c7cc8f4f3ef375ba96b21a0ccd82b40936201518c575433113486539500f2243ee1ba220d7bc86ca519e3f2307249fdc78930fd6ab5da788e343a24bf3bd5671f3f45e2d801a1686a5f33c2936fd25e6d52f94d8f247cee5b053e36d243a541847471334b32b58cce7aad4a2eb6a607d4ef6118e1ea1890fc01fb8a3fa214f34a4ec5819e7a4842675351aa5122a0dd73763869a270b251f2ec5d117ea5de1b6f0bb91dff448d96046c1743455e80ae39c7dbff3547f1cea7665d2c439e87f58e2aa96c3f4cb15ae0c73b21d7c524cf21c016751dcc041ff005096e88fb41a9c8aa85512ddebdc9702f42ef016daa7d8b457c2a460734fe95af4b25c3911c1b2208b51be070a51379f84f3e2fe76257dc058ad9e1fcadd9008aa926afe111ae072627850bb50f5c1afaf9fd2a5ab0ab9c339c344fea01d7a56b6f6c12a42cd1ed3d6fe8fb9d1571114b48f6a7b097da82a2a7e98c325460d383a4cb67427e07a45ee84eefbdf98dd1b0420658d66cd1cbf94148c6089fd66826e1f7c884d81412a69ca07eb2452b497291621b9dccbaa24d5f114971daad159dbc2d6986fd40b343df7dabcddca92b2068ee13f286d98a4faaed03b5a2cdd064db9225bb8f0ca2b248444a3e748db3e9ce0d2827957e0de09a363ecfe35f8a89d5a6a5faef59e14244d1719df58a97044960989c05e82a91879c7a138737804747657e331e00c3cf944f4412b7b6787e61eca2e28838ca37583181d5ae0f1e433807ffa755b81ee4b6342256466b3e9d5906126424542969cfa72fb0cb882442537ba22ec47fe744920438bc07b6ea9b76aed7674b9aaa6f96e1d42186fb28408302d18a821781377306018591343ffa57fb44641bf6d000cbd4d67ccb805ffb5ab056d10be5413a69304846d7fb6e6e934150b07803078c0a8d9a819c07758ed6c906944d60681c1c9994be70f767fcbf55b6b202bffb99628a5bd8cd89816cae631b68c4495feba90d7471c7202712d8b29c1066209c75bd14efaaa9bcb4be70b2b6231fe0f21b97f8d60582adac6b497ea6ea26b33affc64a4b9a69ab14a997cbf35585043dfc0dc3d52062162ffdf744181671d54ea8f65ef87706c71c74e3b5196c713361d6b085d5c27c809f7061d09870ea0748d2a43e9574faf8a312e561269039110536d3f91a72efb65388772d54fff4b131f4794cf10cac1f7a65a58f68cd46cfb99839f6183dd35a118297dafaf7c56530abeb4fdb332efc4f3958d0a487640df931cf2d0f5b34b19a6fbea45daec3c953ae098f9890efb0628ecd343ab970064b2bce351ceeab710fcf0b0641c3729eef690824cb48ab22a10edfac9ef8c52f76b0e70dbbd6949711a7e23b189c3ba047fe55f82f1805caa4d0012c1b99ac0af54a8bfdae1c6e93210d30ea1c3f0423bad4f069f89f6443eeeec9c964ad6fdd7d7a2b5cb4c13f74a33de7e4679df51059acbacbac33aa587d37bb5e0fe568f59f89f888da2f4a3b9f81b6924467d4b62c3259a7f5e04674d011dcd60e6ca2bff74df123b6af8ba097a908dcb9e931c26bf57a2803bf63d79449ecf81732d75c00f961e24b391fd6d5d93d986d1789b1e3adb8585ee5410c3891208d3d759333708d9715f7b78e4fdf3280e203921f13d9b10691faedd0a449d56080028a7761aa38972cdaf89fbc83adf871aa21518d6481672260fbf7530d8af9f88c6c0297078c1a8e8657d031f4593f67164b07117ac9abf853f6a1f8abd86c6ca93e705aca2d2dd03f2de98d36027c213c0b8066a09748872fb0a76aca5bd206585b0b43a48ac7d156eb73a8c190b5ff43488948f2b0243b93627fe56ff1122e83072e356e5803e7dca5c9eb157213827a90876e70435ded88239c997a4a4e8b6f6f4b68c08457f4d27ac52b211e1f263c9f86353efae67e217fe9910d08c04b53ff9342efac719bb5b73e3ae432fc026585439e7145ddf5f5f235fc1ed5fc7933271356711934039c9f264ff566fc9c66eb079729559c027e530c83a1aec8ec051bc8b3c03cba7f62400ade41e3168768246586423f949ddb860a1630b4d8e042cc16186039903baaf3fd354187a24c376daf2815fbcc4795e62ec66648a30beaf2fe6f6cfb3114ec6805cb6db5939096985e9a9ca8ffc2bc304269441f40cedd423dcb522111a0de79e28b9af345a43ecb02bc9e539254c4d384b715335e38c09529b07e6b90f5202acff8cf48214b7fcde9de41acbd82381640e98fdc19c0d346ecf4fd5a9a3805cac5d91871140ffb7758c700f269a8a540bb98bed2f6d5c5bd37cbe01110528479bfb4e4c608c0ecbeeb84fd71223f185d4b8acdd2f884b254c8d68264fceb613ea2521084325a905e42b6d6ae244ed2414bc09cee31bf2e1fad0bc9e3327588b24956436d56d19395851b172ef7de6f26ef8ee9f1a13353f3ea6512827dd4794c7ffe87e71201826586640bfc9eeca806a971b9bd9a28348a60ec1204bfb5a9ebdbc288b5cae5599856b3e1729cfa25d0fb7e7e2d10a925c50e0d257783e8063cfb4ab29d3c2d62fc508b027b59df2cad1da31cca89cb8e36679c622aaffd92e01e409057287f3a11eba24b7764b18b0961fccf1595023b369869031a04579f79aaa761e99e8b5f191b1d6439a09c314548bfde15cafa1bb8b5df448f263ed3aabb79f1503889d324d85a13837e19bc6ee17048b7c6645a861fe9dc9b2ed30a4cc51ee208b0b348542e4d5726a764b198fe0d16af9962a07c17ca66494ba852a740467e34fc772374fd11ce0aeebb4aabe12383efec6b8e10f5101618fbd90edbe6cf1e31026d296e3e31a8b9eb6de0464670068e3c93ff50d09c9a037bfc606c9a73ebcfa62b8523964f00ad73f30131817eff3d9cf57af9e94ae93685bb76d88b96570096f2f9dbe453b1fd717a959d36363200457dade5dc1404193735819c41be79fa0b80dcfbe047db3e5d37b08f5179c84c3604824c6e0a7f6f8f12674f169f1dd223f2ab8da704f3c10eb2ff0271184c21a3b51934722f41275c2451a02241b55400809a1f2eba5944a5913e0139b8f91a21b1e61856a0ffc9dad7aa0696350dff67af17d5c8fd8896b4e96b57e3e2f8fc95a7d4568c94bfe0b4b6193bbb040c8018a2ffcbcd964d33377ceaa0493cbca0b39ef140","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
