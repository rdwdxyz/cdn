<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e6e5ae9bab3777241ac0a4e15b5a5b8697cb01895b2c726fe28fcd75690f9b179f51300bd54a2f97a41d278846f69a780b3f574f62788af911ab94fc80ef116909a7f21b77d62e056db2e82e5df752a91155c85619c6eddcb935722e9f8f365dca2a74296c93bf3d74055c3697073502aeba4c87b1e372d1eddb0290dd458d19250abb32633e19f5d13229d7702ad0b3a07e89b39d401b55d1e80238706eba4a95c29421420226bfcb81ce8d7046b58cc81eb3a333d6b5b12444a87fee171e1bc9f3d3da0d4247e5972f46343d9d0a89d9d84ea463e8c7fbe93018cc069d50e2f75f02b06d6fec33fab45e43f94aefeefe1dd7810a5c7215c87ac657d053cf76b4ebf2c5655f3eb5907b11399247e636677686df667e3e9dd5cfd5b26e048f407656101b0560cfd03c8fba2363535887e2c2ca66998b4a5f3136aeeb8f336e0dfda66846c8e472083e123d5424ca780c07e0303517e738900010d1f6b3cffa91137fd586d954a01e1b7141175221a447167e38282637520e1b662d5446042177b40bbe173c4ac0205561d5de08e9cac719e56b348d0a14be1590fb1926f413bbf5b3fe6772fe534d558a59b49a1088a30bc058cfa6a1801dc2496c4b11b292ecf172ae5350547c171c47f424ef2d4bf17a21f100a00acc1454ed557e6895e0485ddd1391ea701774ea74bddce3530fb7049daa30bab2c5c1984cbc7bd5affdda9ecbf5c02f0290b324021c9a609c7e6aa53e18447f711f0a997a06a5092a9389802b8e63f96ef59b90ce060ca160bdeb3d4720d168fcc482a05298534a4acc5ee6422e5dd90938b0377cac810fcff6d9a33ccdf0633666bcb449ca697375342d0c530bd4a5c0e06a781b142ea3e8f7205ae67d07922003893e03e4b2ffa924b5bfa79c53d5b6c51de2ea46921c3146feb6e47dedb41ca50895421f5ad279df3edfd9c37c1715e229a23034a09e2c4b18fa3001da2c68f0cf6f66ab05b8dfabea938a60fee52d3c9003a24f270e77f7135cc28c0ce0f695e04e33777189f567e0620f9fed1b66e0ad96500d1f87804a7f827a81a3c3a15d345bf685bc3db15e1964e01ecbbc54f17651f031a06cb1ac32c70a197537593212b48d01756ecf0ec802bb231f81c11185a83f37f572208b5eedc9c14209d201a09d4d1136c870830267a01b09f4af2ac6dc66ee828ff7d1b7998d81347723f2b39d4ebb50ce0a1027d41f99cab6ae47c4a03fa423e0187ba381bf0469d39045f7612a70133ec9df97604e2fbe8d19e2a02d7202554fb9d24be791a0e10044a12651b11cd93d545fd3af074ef346f63dccb57d788cd33400aa49af55435dc80f4a846cb0ded2844ce891f0ec20049a23d1cc289b8d44c0e4715aedcdc1f2a4dda4792a94fb00b98006028fdb9f1160f1003116c81007076b1e4a2316fbf120a89df9e1313959e483373c356cd77b282fe29201af3f3d0cc1d618b865ee67a9c651d99d2c26796306d7e781c5b3f66efb2668ef5521b160a8318ebf435358e7700c4fd9206e974191f17d426113ff603ed5c3e8f57b5e4c02b1c0b07052c9ad08447026f98d869e073f526f4d912277bb68623aebb12e25d95ccb8f4da43dfa7ccb3f33f656268ba35301fe82175c8718928299592362852f1a93b563b9d86243ec82002fd427df4e6964a125cab05e115d88e98959a7c2b3ef1f1005466a484a80e8e36222ff144b22c96c179d3503ab2e25b665438f38cc081c8ea577527df2787ab09226981ef0cc12198a414e7509fcec6f220760827ece68abc172405a9f789e16f26d4c0e577377207ba617ce8421268a24c4126e24ea01b2867c84870fe776266657843926714522f9287245054bc1330bb16f5f7daac9d7f47f6655c843b6aa7e172fe389fcba0b4b0f384110adb77d5e16d3bde046be7b883590bb716d3c3f27413425ba2ee0b4b3101b9f79caa383aec791482e17ea47d4a7e72db3ac090901742cb072e673dc8955a908bc7c497f2f35de3f319acce344f20aa240fc673581bf990ef4d5df994018bb271e560e7118ebeb4da6b2cc23d26864b5d80849489983b9b3ddcba5cd69df53df3baadfa745c57b4c3bed69b4d15c0b7a241e93a162a7f191043ad7ebbd3a4b0dbaba582fa967ceeb34ac6360b15ed145eb535bd51fe89584372afa6a9a64ba557452286413dd386d166fb5d033177e29a9c056bc117abe42501d179a88a6d99f07a88f159519300f18ed6147be90af0d79df5b64f5858f54ab04e2d081b2f3372ecb0b5a2c433c44576c07dcfb70428c4db33778dac3bf083fb6536bc8764f0fca7a2e43ee5236495e0845061e517dc6a31f0000807d69b5469de26b5c1e43ab66f47a8de22ef8effc1ff1ef14868ed6474be909754dbcbc3f2e521e3a6310c8bf1fccf43e7600e10a7fbc6e6643fa1f87c2c1a1ff935cf38a7b8ebe75a3d1ed96ead994c4ca72078cb4262c2264fda7e6c6ad807acfb3677149dff34c366d7dfa3ad4a1c29bce20f62af312847eeed5bb241df3e92a6c7a3e2bdd36c25a62aecac61cd3dd61e8a83fc87f729e1e2efd66fa719ed1bb0ed1e0c497c97dfaf73a4c456caf102186b36b53f806a6deb94b7d2bbe1e9976c1250d9008d8b23cc17b122e7d45119cf5e2e32e0eefae92d4bd18d44de33e42bf2d626ba10b5a7f656d91b96651aacdecb883d8d97b222a603ce5433e8954af08c5923432bd1b0993bcbf5798e0a56bf344716ca01e3d3c65bc1fb242743a8a2d5c7be84848132232ee36d0981217f316b62f923eee4ff3fa1846f42d25a4db2365427115a96c68a6ae66623863bec96531e8d10204aeabbc16a3b098934ade9fc4d98dbf951025f382d689c3ae9acf2226eb84702a719f3787a70ee6d31b0ce7984c33a902df3c0e563af1973bb497362fa79191cbc12a7d6becb542ce39ce053b2635db3d6e1db96c4f074e301726a863fa2ec21ee37d9376137fca0f52b9b5a178e8e68c9bb6ff03b0ece3f37924b681a96c2904bbb5848392d22d038c67886a76933ed7266bca3b5bad4311e375e343f8a8aa12c52f02c9bca65939c35e1b9c1559862c57bd67ece379d073c43331d7e69fe6f77304a469aaa0906df5e1cb4204859767b5d25393986c1c55eb37def4f994623377b48cd422f6546f85e883ffa45335440884b1e90a5f00490992f1ec5e9552046f5ccef5f14367dbd7ff7647c85b7e7da4cc46119002df406737debc80ba8c8727fd036d2aa639aae6625e6c0460ee05fc25d7048bef8aa22db450b03d55dd047dbe277e48426a037d109d379d33b775e7c98659c71e848a7d7b620d05dcc5c830d5280d50c5f76eee11048faa92000b2a81a4dde366edb014df50aff6a05f11e1570ee22adf5fd60c6d5402618f28594dde92cc8d9b8b28a1d20a96fe7dc1a6313e7a6862351343749ea700318face510ee01e55fca01f3e46d8de91e2fc44426684a623d2292120f59cc4978dba1e314893b570e8b3cf0979452112a780962b43a7e3c0d11f5c44b2728add00a16a827adadbf7b485f7205e2a6bd3489b6538fa6223bd64f09001704ef0d12e45b71592b55f6d705a2d9304dbd3307966a7da0cc16f95987ea3434943d2ab278f655dc34fd0f2eaa41ea7d4c3bd990e2ab49c1b50af4e1b31e96026874abc28faea2b024402669a6f679f0670d22a2569c694942399d8198a42fc7c8782a6929506a74a032247443a5ff053ba190fcfe332e28731f8b30595d2bf0decabad35fc41c003b642aaa77a8ec62dbf1ee8aec36813dfd12118056b690016df8dd10b5b3b1f5d6a57b68b6c2caef2b2f7652d9e97f6c523b1d370faee71bca2e1ebe15c62d31360f9bed7cfd8053d10297b44cb87ded945b73fab9843f1c65ec1e378d9cb8bf54b1df6f9f682d91a760b538ba95922e44ac0400f19a05d5dfe2d01da4b9a0f3d9b736fbfd06f25534bff8c08de64d1427615136ac652d24f8b61fdc9e44498270113645a4ebd874686f64196b2ef5f886970fc21568b27905c4b136dd2c2e7f60084d11affe486c91af519f0d2cd86e2f7cddaae381a8fab0cf6e982baa8d7789bbd4390769779415ca345d10ed4d82e2e832720a65792b827c1f333ef736800c65000c67da425bf4133dbaea4f33fa422417c8c91ddd39fdd21f77155208e9466c512b5881780c0c1c8775a3128b3b63f62997cce862e6fa4ec3a61d3f7f5e59f59f3c08509fd3cbc37945a8246c19c8df450f6edf729f6f8a147d491578ff0d64ad548a0f032bc0ebefa55eca0c89d76feafc044cd0ecee4b98dd85bb4efd0525ca7e3afaa0b063aa65ef6f708316feafbcf98de59c68e1402551fbaf518308d94f2c1754bf6777196c3dbd16261935eb48144c6720b43d672cf6e8ecfae9f5341b0357363724db3cd814e9f1ea6c5ad1c4535fe84c22083f940b143c138cbea1b95982abf2fbd0d4cfed3e6fa29bb9587904199560f9ed9669087d524f88116eb95e52008dca8ab62499e73e28ee5b3d50e42bbdef8c81e5aa158331ef0a97f9c80c0a3ebff2d91164f1e1843d3687f4f42a86296feb17cf726d2fa445b962b94b647984b8f460b38de5abce2d312ce54c5f8e0174214ade967db2a47b39a397c6567718e9f0535ffa1e27a1bd36191591691984abee1836d8538ad0223f77cacd7662a224c8de7596756c3946876f9daa93bc6c77cbec1622d689e08c98003104ab3f3a02b8da2f6de007dcde1b2dcc0f0f8b18219de90e5fc082d13916b7c924b1bc69bb246855ec239e542c1ec2abf2841a81c604dfdf7ccdd676bc2dc8e46d897f7fc637111ef5208be02d3c9f12d23a8ad1e17303c56b104eaa3d96889a786cbcea8002a1f7d82203d59f3cd0a0d70f1456991f52c8fd0fd0d73cfc2c51af422740f53563c6a359296ff5b0cde24a6d75545fb4bee3c0a87ae0aa9b4825aa8da165cf9ea93e9cbd1ce9231b15d06b28997911290dcea14e1ea8fb73c31e115cd8466e8a0f336137e9c67ed395804e03c95e6abbba0cd5672030f77c79b95eaeb666bde5392a90552d9994431c6bd2fe2392855d7f6a31af13782997d2e7dfc6efd6f0f1b7f1288cb5054f08a8304434d46a2d850feb671c5901f8521a4dd2a1ed8c80b765b6e4fd0c5a38ba32b0f9e48ebad6dd239c3f428be3c871d05ea258f9577b2e9736c30cbb1679fab06ec0378901f769d835d08bd60f3d68473412d9293f0e4b045d2f11d3beb04b685c15253ac31460965c4aab01f301e409a219864a59d67173b2f24c171100125de1d6546f54a49bde5a1e267856a4ba7108ba698a129dcc8bb7b0d95480f7364e15b337fe1e34db929b12a983752638cc044e94adc95794ac0c148202528d1cf78476665db1d423f8e194205342909423ba440e364b24627561f029591a16395f8fb3c35f651846e894e1b4513c2ac0ce1247861fc35392e04e9ce4c011ee4e9b9aea1525f4520b29d7b5b1b532a0cbb53e59a005cc876a433199e60ca50b1843dbfd14c372e845f9ac21a3d71fb288c6db587457a572f57bac97e73602342761cf663027350080cb809495306dce142b5770dfc64b146cc5d5221dd65083348595177b644e2a4f7f1eb6bf7388e6a3389ab72986071159ea8626acd9a6a6bb2683393c61af745df9a1bcbbc4fcd216c3f1b6230fe4df87e12b32d6762774b546150cff55aeec525105b9ff3db241869832af5e3b512ec965c5501819352d9c676f26e7dac8bcdbb962aba137a7e254c39c0d7c98c280c0fce401a2fca4b79919609984e8f20ccdaf11ef678c4dfcd8d247d6b824cb286928ac5080706fbdba70d75e9a79cc5baf5d86e33c776a832d4e8cbc1f4e12fda0bb156c629dbaf762e68b069432bb90e47daa204d33b0eb55b563056e8658c9ec333b3a65ef9703f2c1e2c0c53e49080873f13c2409b979fe9cce50107c417464304da07f072d23e9de60656fbe86375c5e63b6e89fc73c5788ed90c26e4639127c8be5d7d923c47bd7910015022418d1add040326204ef73ada33f3c9f8b4fe0dcaade0c3b4ff84beacb8f2d74216877588796e6a492fde31f4f4c48a3ebe4fd4a5ccfe76a2097d45f7d97a71cf12c5d9ce0e5ca684f16c044cd0122bba4b4cb78953af08b313aa61d48614e4f4d69a930ebe3a5c6b5c2739b1c3d7a82e43b1e9a723dbe8872f7c2de20aea5252510cc79d26da4842ce1f3e04225faf2c39875b30c3c6b5c31a9e2dcc75b2ac47f4b37b13f85e05fce40f9d670abeff26ade584e84127ac2052235eaa60541838cf785f32d6f7890ac8a4aebf7de8348ab06db653bf10b7dbb47ca52d2001938454509182b6e26b8d5b1bef01f3d9234ee96ba91240af11a087dd0b46c0432fa2ce886fa81ad1d4f3074f3ee1d8f1c89eeb669ef1061d2ac8025204d93a3d0c4ffd2a93143d22cf84be2290fa39d470dd064e71df475b4770c4c8124d551f25a537fb6a06e1666f0e02a481ff127fd6a58b15469c45dd81605d3bec7fe6fe4f3a9b4255885ab1e806ef8067c569b057dd5dd6683de777b2d3608c41407eba54e65ffba0c448eec1e16ec952cd80c50d5a667f80b331e0969d21fa908995a9bf9b840ef5935057f1461a58d31ec0d3617ce2645605818d5f5fff23d7fc88fafab3ea622b50b4c612b76b0736aa414b322a1fef2b626658315ccbac38b0d22bab4fd91d0a5e1eb1a6fce3a0e873defe6450bcfbde48d096bc66dc5b4630f59378484f88d31eb8d7a98972e4557be7e430099c8ed1d8e9ae40858fe219de3e4eaf776a93098dc22eaa9dcbbcb4e93cde2922a70ef81964a6a306cc498707b395d73463d9f320487974c9ff191db3c86b5aaf8ed503bbb820dcad77f38c08ea830e9c61ae4b6bd8fd6f58ac8a73487810e54b349d207b192ea5c5b758573528818e63de244cf949f27cdfb42d201248d9e1643e146379e4fc07ce059803ec74b6dc8958c6a4addb9de6bc4e6a455393e19285b70d3cd11959067ff2ab1ada8fa4d269d55f2085accc9dbff242d5e78b966c4b60697b2cd7498b521001a5697cbb24076047549b3f12611f1673cd3bd69ac0f3f055077a3bddb35f114e02cb8423c4205ecb73560ff1c4f6684f59fe6bc8b9b5c6bf9a31dd9b5ade3df1be6c03e42b1dec2f4c5e2fc5714325907f4a9a22040d2c34c020d404b64d3d335db235d5cb2185004e253df4e51e2218383275dd1478a9e0faef00b41e01da8f49b84eba96ff878a070d7780d6c90425125d27b9dc8f8fe2df2f3420f3678bab220663c9e010e4fbba13149ca474a8b5cee29794e717065f91c8aca3d0e3bdac0058f1021d792d802eb67301970fc0c945aeb5e21bb9c13b9f2359389a6bd539873d62d2909d7cfbc42e83a7dd421b817f38bf79c41d5ad6398fb910f58ab4052a4b3499e7db81d0531c8696cfd6f054a99fbe03410983afb4af4ff2ebdc84cb156775b41301c13dcc3a89cfe674c5c53399811a8a0942ce1d95ce94505b8dc436c66c3588c7da3a54b10473f699440b95bcdb2bfcc75e26cffbddc05b5aabe4a64a985b006b628f39c65b230b8f3c632451093486be7cea860c7f0bf199fc6b26182d69d44ec8dd237d532cab5809cca676215968eb75df9202e5048a843ca66aa06a7b6b7644e8a6e32ed042d72517d8603fa0760b42fbda2498f0021e68d5589cbfd10acc1b692a4cec77b07b664470146eb74d2d187f870252b96ad1f07430a1c21af2fdd48ee4cc3db52955550ec5d6fa655a3575e4171575c5b1ccd077cb24782ed8fbe92e7d679c763b1515670150c721f3b59b7af261fe3ff4dc9a0c6c355a32bf1397fe2f1cd652b6dd0333259002ef7e4f00fbbbef45cf54ef171d33ce6a5cfc0efd59d26b81d06423d76e67e89cb8dc7a604a81c6ea621bf37dd16703380a29f319489d40bdd673f11527552f7f15982c92344f042a9e25e9a6940f08e1f64bbfae5804cb66326148392f4bc77bec31b54a2891277c439a04daea87d51c27ea63de177d1cf707539c60124446f60b2b71f3679d9fc5716837776a59aa447a6b91dfe60ba3de4fd7f4295608004bd037588856928bfaac3f2a8522a76f89d95b83ed133e4eff361a0082e27f94ba26529f73e3f6654770057696410cc0be65046880e24f2b94184bc158769069f6038cd6b27ef94f51b215178bae0fa4889848934ca9739612c56c8f9446226574571f9e1cac6614b77fc8f35510acaa361408ab078e6a03d77d53f56b776461ee363f4ca004974633a9713f3593ee14975b403352c2adde4d9122599c4d0593ca0b019b4a18dd2d44e31a52977ca3682866d2aa08d3764070c2f7ca406c43615f744ffed4b0f14e0ff12f17a936d05ca3855c4e5f39fb406304c89c68f54641b8e3e9aecf79d1f5ba1245034e7069e3866cbfce6738a7e3d8c7ae8eacedeadf1e1d57b671380b61e16af4595b8116b4d2bc1124fac057e2eab09483039491187e15270e20392cba6fbe88419ff1b4a45bf83c52994e0aa19caf790561551a6e40204901a5f6efe255f01194f795a97b94401f2aade002f8e7f4e2aa64f6694cfc3a4da283620a6952396b9d152e9d431b9fc28401bac5e892649f225e32a0691c9be45741995659a88fa056e0b5db4b0738957518fa27b197a3b2a325bfcff25a6adcc1cc3b7d4c52cc5cd0885d10be5a5b1a3515a62f330a863e04a370048ac4144b72550503bbd555a9955d730c9b1ae65f5f03aa08057666bcf35a58cdaf6bc7099bac8c118db59e1cc7d365d580188b2463694f7bfff24b303741a349a80e74cad0f2ae19b34b374d108637123a09249e86ca7ba08301868acf53219840c4cabc2605070dd337b0cc93b12d1f2fa05b060c52fc9a1cd9db39125a0c53f3e6ba3f5108597ae11a49734daec8325d4b08f9559126245aa08e3551c779372ad4fac96bff5fef7336aed93d32c80779c630ae3b9594e8403896bd4f70730f3e2bc60bd7ccf0216946c7921912deddb4465a34cdc53ce74c72bf04afe7cfcd3880104687d2fa52e486df198b7077017af4af7737531aefc2f5d0c08d0dc7ccdf605f66e6f230b3f8f2be91a68f707997e3d383a1fb0e875a904ac0a315b14e58bc30cd972fc00a72c2ac83807aaf4ce592c9b191fd19f32092bd9c037c9f05ecf08ac0591dd27180fa8701bdb393da101604cec3a69bdf895284330b648bea5eb5866d4e6a9749ab7895778500c95d5e263cbe78459cf74f7235f374a4663084349d15ba3b38f5e0afa189304235c353fd117812c2aa589c1e212c1514d38328c8399c1f75178b57cd8cc17c3647c12f3b876947f52f4ebcf2889db0541433b777f7b35fc4e7533062c38dfe1fe6b813a3ceb733a6457ecc2d60b53dbe64fff9b7654d92ac316b52d1782d92e94647381a3e0203032205cdb1fa4e5685c381c6454fd8f573a9ba764c89611ae1ec495577b7268a0ab8cb7c6cebfe0165587646c6a8d08894cc14a7634bf08f3ce715cb4fcbe646638f66da43f966b6d2afc4cbe8eb2873a32d5a80d6e4c0c1fe14b6988cdc1763f73f796b8dac3469f2c42ad01a44b89e1537d9930ed891211b19d4d3fe60b88d8b51c343875bdfe4a48d8aac7ff50f4b4051837e0a496a47704dafe5a46b177446cdb1b2016da637ae4abda52e4f7992e0610c474066e33c19ccd00311f0722b7147a8725fa8092ad9c6522259fc2f3991c880cdc8c35e99672177872965abaf4f7349ce29074550caf1638a4fe7291b2add7308ee40de623702ef2542ea693b9176a9a1aff60db32b61e0ab20ae9b3e9ea924fa94dbf0f2ba4ba6ea0ab691fbd5059c9d125aafc833aed9b266e1fac17c4addb321fb908c7a1fa9412cfdbd7a237fe3cc06abc28430a6e7c2c120e2d60cf584a45399bbc271a7934da3c6fb64d5f95210ae7242ed9cb8c188b3a201cb0442c8e4d05ffb75d3c4a1550e36273f2ff72e58aa0e26a9aa76853e76f1485e11daae3b6780811707b02e484791de136486df3060061ebaf752baa0539dcc6a5c1a069c966d6a8f6863ce948acf4b0146d9254af9dbd199913d172bc81c59ffc40af24164acb388be626ffb1f4ee5c1a58377e0937bec005219f28a6971d100d0446ed57b406860112a4fca4a71662cf699e23d41d718d1ee65915d8c8853ea370196004257f1948d12489d1f2e701bb97618d05e464ee19cd6f535f149a04012213f2e0cc21b6d978fd4160ae4009415ef61d8c4839f66388314af78be033df73fb692a10914cd115e6c0caf1977d7cafc263c8ddb3b66fe2799f732d1fc37018f4f379a7dd71115b07420b8e375d366d17d755d8cfbc4a18d93ff6733bbb9c95f416fd4a82308563f1fe5e0fa7fcf5dec2f9f1884a05e79b0b91c20b23b5eccb28db6fd9d59c3bbc68ac49b0ab5acf55dce34187916e5234cc1f59a11a32463d8cf7bf8317dc2d2d82fa04094d63f2f8928a087e5b9dfa66b7eb73965079572876cc1feb3c023937cd206bc40a1c64b92df525dee23c5532bbcd846a5c0a20bb42eb1f9268baea92116634f54af4b6ff9b2dc1115e0ba2cac0632a32bd755827abb1b1736818c195f332f5e6aa25ea0ef992e1a98a305b2e4237f00604126c09b1c94c0db69660e7166a3127456ebc9bec3c7ddc5e191a5bd2b0d6b7259c22eafde608c4090f6673a52e313cf1e172842fcce62dc410b45f71384c7e67880054d7c7e3e98228a31e7ad5ee3903269a414ff75e33eeea714dff67ee719ee1d928f63d0aa4d13ba9a718b1f9e27135fac0f331f4cecdd461f4d02bdc72650b4cfd4fcb7f8896ca56b2112d4692d8c81d47237e494ae93f872ae0c9a64a1dfdbc554b349b97eb984b1341b99c2932b6420f99995edd5e61aab5f41c1094f855a098bea5a03af2672143a2c924867f044917d794f48f357ab67ec72e32908f826ad43ce51285dd386325b8bbd0ced745b2637edb59be6dd6149eb5e32b96fdf83acf40b8949adfbeac209bac5c111397e65cf96d58aa63435ff11a9eea61bdce3baf529adb0b1ac4637296c6d2c6b93fbf8feacbf51ca298381311491445d55e509bb1b35fdb3c8690b3fb51d071a9e93f7cfecd9d044cb66e1bd6fd7e3ff2f19d60f58549b69768c302e5c903b0c06c08ca0bb00437a5b80bda6f6ee461689249ae7096cd91a54d3166a5f4ee8ab088b4488fb020956cba1b44abff8fa7f28b96e336e817d418daa3ef52700227a266f03424b5c8856f51dca628aca1b6342420457c2b99fe8943fb0415d3435068953baa026e193423530ef97a55a792416ec64a35e9472a84c28c431d2e0fb3f38ceb184e47214f04d534c3ca2e6994bc7c3f96f90eabf366642f3d418e76aeece8515d5964224c2081658e6fb53d1b22f3d466c55d07a2398d8d89e442350b1fd8268094523c7f9eb0f1dad0cec0f8f66185f74ef569868b2b4479a50642bb518a2b3209718eb987835baea3e8aa5e4d660587aa2c629191dc0b0f6538c6ebe8ca8e7db2aa295cbea10b202f18ab61767f7e3dae4508e7832b975fff7fc5da33f35719a72c9823abd2c26e38b7a6a0a0ef9af276bd5b1a4b56857ac5438eb4fa45eb0147545c4c8c5884ae61332726e6edb7d8b6ed0fe8e82ea5b7c5417eb0fb4f27733722452e62525ed8ca0a747d6ae1f30dc90c9a812c940f99fad757e6b5d5e7a964894d1b587ddb8f40481d93b00e3decd4d9fe74343c70a0775a9dd152d56dc97dfaa3e4cb682f47367bc75548def12600a05d3bca0fe3b0236def49049d94749c5133b261f2730a0c74716e0dbf33c2c1fb676be42eaa2c548dad7aa1cc419d2583e49c619678ac635bd9cfcad8b0f72299af897834d10e7a868cb766c40fece1fb01666a5f36626db1163a4a7a67b366ab0c786966b717ff3064e625a2b31311f062b64f373a1e72d751de1d243a9f861ab52ff40648964660e722e5fb2ea4b739a8bdcee00650e91b19c63dc324e4501fcbc15839f9d8991588fb18a5394aa41e19d79f6313cb868c58bf38f9f3a2b89b398d2109b796ce5816538d252dfd42a338ac594bf84dde2670f545dfa2adc86a57657a9315e969a5123b767b02197b67b3572c182721fa198c839bf27f3884fa4e09dad57d6f945616277bddda5b75f2723f22388837ad28c1e69993584cecbcd74b538cf5543a3d6d7e4472f21a83efcb788bb4691083448607acfddcefee3cc3b2d65dddf5423a102825300b8e0c96b1282ece9475691a75351f435d58dafeea13ed5e3666eaa7c37fc0a30f89157538542cf8db5754163467d636fd028b2295385846417d0fce42a2e316e3d8d746021622369aea955f8c888b6cd8c4097d32ac656263a3e8f1c0574899e6e8bf2223629d047fbc653f07811290aa10c740b307f370104326d7b8b08f1f3370cdfc7b329e6a6722a03e6526ee43f3608bf9aaa7d9192c57e74ce0e68e1bcc998d2dd07af0cb7f9f55fa69c44781337fd445a56b360663b9af6791d363383aed64ab3f4f87cbad561d07f88d6d551b40fdec1361c44d04de5e8fafa99d82c4db5ca78a3d466c9c1d7249c9a7f1683032ead043b0f303de180797fb4144f894aa41964773ab0bd56900f97b31f1729889b815db056fdc0e580dff373db2a80180b7c59733d4b989641d401ff972e95c9b00ccd4d9369486101b6a8161c808d5df3283720226d252b8aacdc95e227ca95140a566c2a65c2bfeb150fa4749b3bfbb918eca12955109c4eba02e00a235db26f965d411dabdefc62af68cd3dcf8e2a5dead3b576711a638656d13de1df727eb98fa06c1e0547dbbb8d13d8870644c9e7c655daa52cffe3874ca7d5ee41426c6ed67b4a02e0b42d588436f7abf64e0fb4b02161e48ad00198ebdca9c9136524ddf1760e32785346ee6684d40221fed966a2b4a3f918e7d6289ad1d0f470fb228e361152776c40426618f47d32d18facbfec503e06ba2d924d535017cb0208f43561e5977ed310f13a5f1b30f312822c2bb5375a50986475bda36d419024642db04df999fb693337ba055f1635ceef6da146edd23447ee6002e6256276848006aa15928ea21e3555c704eba1d16c4b56f63d1099b4783dbf4960a946f29d6e8679d25fc41ae7464d8c30bdeb5ae65e515006474f1f54a5343cdce164b0942fc538cb3ed1363f4d734d61bba21cb10afb5fa5498b1d22caea79e9c907e3499cb3573f1f3add55760de1eba449f8fdff633b0b7a66eb044bb2a701ebea0ca852b4e3fb2fd549d0b25cd3a0a0ca6e84658a45894e4fb2b01ae27aa17fd7f5760d542f9de7bb71f692f538175963a9ea1321ac564cb56f7d2975330ea308d4e93069070d586f37c38c10a1862fe2bf5da3c70e41f30e2bdc590574339bf36afe1c10b0d4c9ecdd002489a0c672cb043d161f47b0ffcec7d6509986b23cba2d364b43bac80e5e27866620220c89d1b38fba5c771fbd83481f5efe69d27d5a9e19ee38678f64cd4a757fb49391391cef8f919ae0f612eb4ceef03deef350a76043cc05c1b0facf2931b43ac4fea4f692aa735ffa71e499704981ecd135fde7c29c9ae0f8fc0bcf1f9544f8e2088d06c9e73720b9a114e48cf64e32a619bb1ab15ade9b3c0c4f9a548065ee48661cb6f77739b66d295e28aae536e6361b90ee8c56a4621c40d157c607c4355b424e1e91f2ff69521498d9a4a2aa07da3fb73d80e427112a16edb67e5d44998b1b89fad9b32a5a1106af7fe9bfd4cb467529c091adf19faab98196e87aaae696e5d04e1d8d7ba5ca18be46f83e3773ee33b3a753d0f7058fdec76fd72a9d5d30a0c35ebc46effa209332cd2e90e6830fb40d86524fce757c871a379540a65f205e7b73a32832bcaea7c362ec0c8ac3a456a5647a3a08e03ce2114123618a215242369eeb453213130baab5507c986149638146bb40422d02e297f8059675de50509325c74933fec643146683e8b30858be20f7ecc3c9c5d3af0a8c64ecfc613b5d6b28403b1d3dc4f9a705c5576c9e6ee70cc591b43b6ed0091f2c7c82fe7583b4da9069eea08885b8d7f7a22c6a9d65b73e346fb0a2f335b6a2405994707215e4a5a9e37487a63114688eb2b98c61e9ef9a69b444f2b07f126d54e1ff48f9d168a074b889c9ef8769f80478ba2be5df8154215e64fd1235f4af52c13377120c3c815f6973139237d8969fac6936c200500af646ddb88f13ea844d214505c75b777f69fe5054022432f25fe90b66e2b657f5e4df45ac182c352384d46c973f94d5c1b29a4caa22c050ec3e97dc6af4e03af2e48031d527d3246163f9da4d21e0bba2552d08e637f17719b5bc2ad599ced102971ad9833652795d5a8b0be48b40f28fe50ca06c488fadae7ccdcaddd9dc3a7c35aa3b2397566c3673793d7047247e892b088dbf4da73f58e7b66d0b228ec8bb2ca717f3093e40af19c918ede43d2b135942651e6ef90367fd67ca42208890e7328ecb417335884b5851be0fde70bb8f905bcf5b43cec6789c1910926958270ce264dc050e8f04882c3cb28b89a8ecc61c0caddad769774726348ad06a9278c61be876edf8b875d5b513d4e24f7b8ea9d8a08c49af192853001e971b38a7055ef5dd314c797df4901b5e10fd6412a225fb950a175f962ad6d9672846f5909928c9822d698498ae28a0a524f1c10c126baab5af0b830754d26825e7dd322fe4406e869a19b3f4d573c1abf4f4f6d0bc7973874cd313a78ad8de7883f7b96645a7ebe86821cecd7c49ff7684963dd87452386b55d5a5ab337c7e123c95c1f134c184848ad7703242693cd7fac4fade62ff805245c1fa1f565925573c7bca8e2a951991cbe53b6aeab5e2ef161c181f77a9e699d626b4a03f9668ba6326643cb882cf6127a8eb9d5cb589022888c6fdabc9826b509549fc520af3393848ff230e1a9df8f24fd00fb3531e74825bde97509d1c404872f24581738d9a3a0a11319c6fbafacb7f8e7f0c63401ebf4e4def1174315c40643fae484f04d33c039568014a680e99eb6effa4e483c479e40a26b2f9f4a2ff3494b54761968da36434f0e91d0a0db284e5f7bbb2cf4cc03b5c8f72659dd9235b03711623a71f1bde00d9e40f597af2f7cc373c58fbb75337f13d385f4b17fe4bb1fd0083bebd06e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
