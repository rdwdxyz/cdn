<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a3ea93c8962d69e1ef1fae58a9e6ea8e1a8e66ac6b36a095166b76bcfe36a91ab934712dc4939ff7287e8ae874000e2680dd18a7948ad5a15c7a0bf84a0d9e88f5c01da6a7da0051749fb93bb3daa0bbddf50ce03d956ba6071464ac62d30891d1bc82b13c347b2846da077d98b6a9a3ac6e09897a05e2a94e76d82c73d04095c1d6049589b63dc51eab4f337938bef7263d4c6ffff93e0ee8ba76284236110daeadcfb245f1ae1211b9d12148f964d3e2180f75cce900a618234243e043a7600c799e578938822e8a4ab20bfb1d33c0b2838132808d14eb2ef15f854cc658f5edb6c54564a75d51c1380b016656afbb178e5abcedae5a16ad53c023c4f743465cb6060277da9f41bc060e15fe0160031ef771b125afa002540912492b8cf39605a8fe9ab8d6d0e04623e42aca380c01c668ac645c4e72d26b17df8f001c6cb37c0922df52943f4adfa3ffd46d87ea16b25732aa7b8bef9878436f9921300d06ba4a346c5f4ce2e1c9c9180d2c821d6a44c51638e134598d2bd57b6bcc970eec20c5e281a252368e86bd0445ecb278c78d8079ae64e1bac0358c9f73ca1a9045057dcc4a48067ea37dae1cf03957db417f222e6ef0c6bdfc022abc8ff806b2b9f548a36baba1b93fc213c315bfa04c27729ed4a1728ff4edcce4364a071c058e1400b0b9a33354a308429e237401e0284addd15e98e7e263f629e01a5c051d83f6a572f2a175498bc0713039bd8b6fe39ff1d86fa8aa56d52321500f548f5ab68bc200d39a15d72d5088870d85e728b4b69d5c6a5b4916e21d394b1a6fb273915a0cb3fb042e39713a3ebc89fbedc316265363932aec5295f78ec09d06142aa8f5250afc02ba247e4e5c1d061971453be5dcf0243caa8e14ebee0f86668b0194a9902c10f5a803eda412de0c4ac5166d49cb9919e2693a17c43c4b1a3e6d4bf5f26905a3fdfb7e88c5839c0d19625a34074f067f7c22c63296bf105a4cdabbaa05db69631812511b5b2829b9361a420993a51ced5dcf460a7f3915a154ea898356a75cb2755478445b765418598996f1112bdee813b9ecfd8620ba10994a22521b51080397b11a76af0ea3924a4dfe0e6e576acded42d87831aa37f3708421ac74de1ad9e2d430d5f1cba39a1c393c17993d051de2411979fafe0ba40bf2e975ec2732591092fbf0d171b527be63c1633c4639077075ff9d4ba1eaf55fc35192881b28c71a4055119d6e3d610b17bbe0b194033ed69bc9ec2ce187a4db0894fa10fc2f0bc1604442865adc56311a3ecd755ade706f6221868ef05bab7bc78e1401945261f78266dc10b06c0f5c1c9d33950b896631b4741bd012fbc0da1442097ebffaa254bdd4028aa503a9d13146b135796cd97e65986d9d76ec942a8f909a0d28372d7c087e892161d38b9274617c9c65170bb92bfa4467353b47d82b6db468f8f808e9dec2a5e15b9b099ade39e3e9ffe82cfdc91eb4a54094248d3547a27208348876953d823323e61f42e71b7b684ab56924230c127bcd8974d5820c0cad7806c14a972b197a72f9a80f533c155867051f76360016cab0d02332380de70574842993153851646aa6de218b91c89cbdc1aff64869edcd7ef26c15d83d9c6af10a95f426dcc7876d1d4ae53a9fb1d26e31463bf8dc17abd1de8e3e5f4aaf5ca3990476700bf19be53220bf486ac65661e2f11af0ab6b4375d58700111334f5863b28521da21550c8a70b08bedc941b12fd32e713339428079c9de62f809f19365689d28d93a793833f54b1564bf36fafdc8c2b74dbe528d6313d50484f077dcd2813be4a6526f04afe3da9f147fb8013bcb9e063b11ca40f786129280eda12f1052b267a3b9162842e3c0ab91089808999f124cc5f7a14f518d9d8a3faae29179a679b0d54cc695b83da6159b390efb651b232995dda46446960f4a42f204a547800fb79d9f06d559ed247bf31f707b3de0789323ea1045c8087c10c926fa3ddc85de83ed47146d821e9aeaf9984efc4c038d26ac565d1e094c3418fae81032dc919d402df8db3220a73637757ecc29cb7f766444be7c17a99faef20937e4b8b65a9ad4a7004d235bf66866ce4622655887b82c53ca48285e6fc5bf570e1a36e40a344745582b39e58dce5ca547304c6274289022d952dc6feb596f1a24cf7c7c2a177f91fd4bee50dc92006aa8746528e3aa3171c24032fa73586b17e4c05973350e939b2b4b8ba6fc3adce94d6903fbbaf6715e4731cb00606995672e103bd99fd736a0758dbcc4ece0085411391052b84972d7345da14e030709949220f084952d997bf1acb90948d88858f503672ce08701999792d248c2e7c6230cf2b9ce2467ecceb996394ea2235da837ea5997f644c39303376d7b0774a90fe9ee0561991358718057a099e41f62f9571a3f68e7b44d0b32c8a684e324d5fdf9197199f60b38a874a733edad39a3a39839e2267d7d6b0c12002ba8b0a4c48d9d1f986a8cd870ce49f5d894e5c10ff13b3c761d37280aaddec81b64955770be80d728da513d1daa0641fe4bdb145e9b2fade0c09f9989599a15202146b424742a92b561029ec4c89dead4aef8a70573f51658652b310da61b5726f557edd1fc58be73304d14442223474096024f580156485ff63dd4f7fb59caaba97de5015465e9918549f6940294b51142aa552acd4e7bcec32ffcb97d3096d32db0f71b73deee8764528570f834ef4a2e20050f20854dda6a9197f223cf21522702eb85ea123c8bd9306da0f6be73149bceba2eb7057bd34e36b471011ced00a699673fedcc017d204b312d7d476dbce0ddb80c855b277e596db8827cbbe88a1de2ef41520364a8d316d2406a7c9b92829bd001f1b16f20605117bb32a6a06802af82bcaf5a82ee2bf054a2a2d1c50b6046625709c2079610d7a975f6e50315872cb7f09d5dd247a8d640d3102138671c99c9e82abdf579dfb0812cc38f192fdba6f09bf419bf479b35eccae5c86c5f14041d5e4e6b52a1fd8deb2cfe0f5f543da6b2b7be151576076d302e3da735e7c9741c3becae85f030ebc12ad2fe421b4ccbc238aaa7172bff8f0e8ff132c0a810f312473d27b4d9202da7f5298909f090f3bd479f79d6afa2d34d303214087b553d4c0784f813eba72ac8acb801ba1aca68d71916ec81967b673c07ed2bd255497d5b3d42cb57bc40191a6dddb4cfdd9dfe99143a988911bf1e82ed7dd28afde588d0c57f55f296df38e6f691ba7e685320861cb86e908792ff3b443f512647c29eb7733255e777110db6b189fde32f9eb0cad53ac342f80b7d5226e1600ad0b39a0212fc702c7d45ea9b28abcf9ca467cfb189581fceac2e65413e38bcc088be374546f7e889598f13a74f76cfddd447c3002fc79932fcb1dc20f56da4eb8a3edc65c7ed17f436758714bf72f9c8ef67f870946de8d8e8d83121c6273beaca6e0b6c7447a16c311420b6e2ec9c190e0b0f68b1dbc50b7d6879b9b465f0aa5dec2e5244b3c832bf07f31f67c597958c446e6ddac6bd5a7d91faa6373f0dec61b92bf7ce8a353eb1c58c293ae9c3bf87757a64800a27111faa6473ae82d39bc4b1ca62475252d91c638a027bf5f9ad7707e11086a9f1fc80f86a43b4e7e067e0218e7a081b3cf3fd6a58f854f412dbb37c9370a899eb6ce16c7399c84582b0bd214bc477bfec04e44ac45fe66ec88431a62d270f814fffca59200184aebe0cad28b204e1fcbbdb58a5367eb4f178ba1b2a8337daa9bdece398d7b6f71d66837564fde25f0d9b7f41a2304ba18afc1f6bce86c4605b54133a5a602f60f94884ef6c83e5c957ce07e51caa40d6ce6447b736d3046ba73e8ab08bbec1b5fe460a7eb6f1fa1466e9d5418aa05d4ee282355bc5604a725e9d7d90ef9246464c8e26adb8e327fe68932c3758dfabf3e8bf7e031fb8065a39c12d65cbe054fda66fa75f6d754a3437f4bec55e450838026746cd125fce825aa3fd2d6b2a3f05122d66194676e4f1df718eac9bc432eb7613f17500fc3463e77058363d0dcbfbb4fcdcea5bfcecf25ac18c381f55b10ae8ac7d79115f7124e5f0c5bc9d7901f280155de4af3c87509834a87dffd2645903fd54094028b5fdf356cbd1bed864ece5bd026c10c571fabb5a93f92ab0197ae0a4427c27174b1173e8e27bd2ca1d6b46e2064897b1207defcb46396f94ed3b3c0257a74acbeacf4579951f71ba8b51f096e00a6e92dfc2bb74260e1c9866e7e80f0f67495f42ae892e178325a8e79f41e6a3c12eab78ea7bb6078e98adb58e712fbffb98a70ac77029e26afc9f8dbd62b09fd0ab41a80c9ab80912ba37269cfa48ca21f9721f1d7db9b7726cd4c3b00d6375eaa8100ab43a4c8cd3366379bdff9fc303c0e2dc09dde2994f68163d7086a58f57587a5c87ab19a81a948481a79f52547307859517bca6cf5a613a7983d8e8939941a253ff760a298a6b1a834f976605cb977c7bdeb1d1e07b768324283e0b17239a43ebc860967db76e3f6bc5605bd206237c2b21a549436944b73b87741c57cbcc7a396af501a21b1b8f9ec7e9cfb3c686f6029e3f179235371c3824d0ae4879bf1c689270739b56fb848d12a4ddac658d24a8d0fde8ca580215ba0711a13e92a6a4cbc2b29f90b38f2bb00b662995533a5c78d89c7c74abdb2ab6ac92d63e3a5b65affd457eede210a0ce466bc6acbe605cf0226ddcccd9eeb49bef148f9c96aa27e8932d35263a838c1dc483cee1a59baffe68c8cda499dc65213356702923bd353592768585557394d092827cd41254cbf4deb9303951a5ae66b46cfa2fe6e4364204160418d551925a483a70bf67480393eeb8a30a3715b080ea1c52559b04f484bdfc9201b2821df60da5568b6ce9ca0535da0ca9a7f8ab36078945c0fe39fbaf2d5ca26c785370ce03fe6910ca57da506856939b0e5b57cac25baa953cbaea8e7fb94055c7a66cae0d586057eaff9dc2115bffc08cb77237d2efe2c63a8d2127188ba2d59f95ffba6f7b86c94573f30eb6d4c566e19ba427598b67d99a8aacc19a861b3401d54a96743a4519c8977c13ef7ec6847b6a17377586b930c6bac8b44587f6a4c48a82e9e6a8320ba51db4d45c2447f129727d2f1c7ba127a8df00d3ceadc74ca7ed4830c093354e75917d0bff60d345d0e0a6fb487ca35ad4e47631745785381da07ae16aaceba178822cbec2aa6e8582c0bba49b047220b48592e879f2e635f242b1f9334c33964f6aa538f0712f136b15c20e974e03a82050966b1b3c7d9ef62d694ee28be098e2155039190a1046c1415664a34e4dfc6f9f8b73180f1fa204fdae7207ebe0c9808e8d19ad81dd5c4e5e0b9a530bb1082f320f327e4500d6a4d06007625c824adbdce6da2cfdb1ad30d5864b6ffb9dee994018d772ccc274142e3a8b5747e301931e3097a2a87732c1f4bbdf5433989e41af60f4804ae82e2a7ad53dd4c40b0ba17e906b593b33aea0b8d52c728fe0e9aba031b8b59ace14345334e3c2bf2d23fa8b49969cfcd96540f62d7e3417a2236ad0109ca3309719350131b9d6eb8f80c3346a87ebd49a30835d0d716f3bbacd85043127d6b1fc204cca84866ee911d99dc9792a169dbde8b590d45af2d3322b54a903e6ed174bb2de82a969245da3dc531b3ead1ac5129b6cf0925945c963a05010e466651cc72cb9e2c80c1ab54e0536414311d3bd5fc70f98a373c212b30104fbdc89ed8953a8ecd7da017e0d3c3cddda65a6544807eab638ed9deee14508d960d2afc527f15b3eb40827be67f43d2323f2d0e712443241aa79c6abaead59a34736d5e8935dbac1eb8902ce48e08e8c7af8d2bfbd3ef2114eb0d225c9646c477d29041a2a49cf17bec80fa6e8f818fd4b1645c1a4cdd1f180ae194baa0a0d24565b5cb5bb18d5736aca66423dd14c9262ac59614b53d1f1431c1005b0c7430f0614756c63b69efbce6ee51eae4df8c3579bdb30df0197521e569b822fbc7526d3c8999cf6bd5652aa98405b295cd9a8a6dddf935f5d6a0a3e25e5c2e5dfaf8808067fdca1c3f2fac47f4edf1e021bc976ec158531607ae61e834a7a96b15abd594124159a318e3ac404139ceb13fc88260c670e59d4468b8acf16c5f6b6c541c68cc98df761a69fbf015b0ac99a853901adf7f8b22c157bc29ed96784aaccaf6b7d17c8671ba62b43d1c2ff423b0bfe1ca3020c99d17a8affc9eb7554732d7fe6f8f1121d646458bacae4c8ca8ed9685ff2e3cc8fadf7601889006d6bc9068f95f40479a50077c02a351b8d6ad42af6b8062bf5f3f34451daecce73a5ab7b9a5a900fd02f9f4615401e286ba892f14691f443b8584b7a6b5a23107e26b12c284a755733db04fd2a3f6018fa56f240e93f9938dc91ff74b2747ad5777969ce62f61ca8b6896045cb35909ecc962cfa69bada617be5d1eb5385bc57a38af0a5643f4093dbe11c4e281c099e7136c64179e2a622978d09ab6b275970d03b629f8056014cfe3c3b51d64239e082034c33722208d8f22c93201912094db1f01b00815be51b97462c12fc9c3630c204fcf1107f7188c096ec5e4162116552d78683fcc6eafe32308bfd09f05f7c1667025ecec07c62fcee89d634e9d88408647927747ad1d37422a30e2bad95595cc2f9ed084260a84b320b50f5d1421bdf1d2b96a69966f37671ba5fe84dcfcded895ab2b3768ca2b35d192ea23c851547d0057a65a201a61c7ad7659fbf0a4539c13a126b6817d4f91380e0afa516c0444362b1ee873265288e857782fd660c126093eddc27b0c8d8ee6aca3ebe4c59582d40fec3cd18335e6764550998d363abf891eb6453a9d3487d717c1256388195cd1a2e40483c396eea2fb065e53b59b22fd529d23b7bbffd93f29128d351ea74967654fa6bef2e90b1ae6fc65dd972abc6bd7123d3e1dd25388dc828da9485706ec6fccb6d859a960fc7efd18efc6c3b6d94a36a944cd257f63e7c2469429cb08c9c9f36b4b195fc3dfce05da47cf3bcc2b539a72fe99399a4ac3dc8951dec38e3347b4c6915787928d351df556251da93018d5a1ec6a3eead6617199e0c28530d11690c29d128cda80a0c325bbe64fa31d60f6fcaee14412739db0941c6769bdf25b9a21470b6833d8993f5a3ad792d6ecb6c1804244179467887408ddc1bbe913e98bd4a61c6b27115266672590a2d9a26f4a65a158725cc106dab9e713cb563cb3b4126e66e3239fa9e0097c84f8490e499eee7af8cfcc7f898e4238376017aafeb21335f83409b5f8a73704f4fe53f76b2167cd3cd1b45d515d452a0cea7f677ae9d4cd70e0c1529f305f75bd779cf374f0e56ae89e601b0359584174464d7279312df53a0d0fefacb2a4baf7c25f96fc6c83240a6578da7f813c5eb3468e554751f3856b85ce44f6251cd7570e119ee366443d4c7d52bdbc52e5c7886930a4d0faa6cbdd32436d218f2f9cd30276126c05e51c724cf59225e3a9c3487c8731477ea5ae5e7bb8f6d43ea9be3d74f0fdc4a7d06ff6db3d55be8306c922a8aa6534cc017b4da11574a1b7ae4b0b1742224e028e11deb48a13568241ad83ed3bdd04d37414f19cdc636ba39abbacb261a0a904ce9c131ef674a932730bf6cdb694914c3e90242a2d54c411d32003f61fa1cc8251a47ea3717dfc22e491af8623fee9219e81f7b2a18924b42777d2af4f8443f854ad9071237d555929416c47a3d1808bff9e841e0d8abcdacc0fff2dd712cbebfe5a67f3c6541541982c13e6c8974358fbe1c6892288e5c8ca71fb837d80897aaff2387ebf7e820855629c6b093fa0cad9b65183222c384d011d03e8214519bf0be60e8a8358fe9fe42f88f8557acea4d76488c6443730f8b0e2e17ed95c8e285c57bcb6e57a1fdaa52ceaf82b7c4dcc5679f5ec1a60da03cea0d482b4b272251aeb8146108f7160488c2acdfb1c40934b45faa3f5d544382e5e11b5c124ca88025acd43a1f641a4aa6d5db4b9f92b5251996200d0e828f6eec3b602d23d93a8a683292ddaf31692b972f9adee72b7003a888b189e09c77401147a645469922ebbf8705fc26910f079a465b8d02f11b227da80b9bbb88ccc58fe17a954237bf7ac19a5b4f0b2c25e19b0e56b5e7c43471c98c6b0b44e8dc852a0662016f4eb43fcf7efa32020f331e5a9c8c38b87c74f2f34ab636a06cf18edfe4d7cac12470eb1d79ba9bcb44a172ef5153da2037aa61345aeceb288d57d610beacac1c6ec54f47b798fcd3ada568b1d00737a389704d06a8d229ba7d65a4e897007ed3d71e835e237619581fab31ccc0d9acfb000245ddefb87caa90b727bf91eb3112569692a46b0bab4b0754aead33a7e57cfe615622b0f7bea349dc445bb3bd787f1086792fb03feb8f6678fc6dc489323bda523da603f1acd6d07a0761b09257e9185e75b839a90f3e6f7a7eb726b9392eaf2f2722e77d878f29ee38854f6727522b6db2672ee14f372674d17757b4d7f950fa33b6a918d6865144571799e10cc58b05183b22f218ea0865cabef55bbed4fc29db8ccfdc8b21e86d84ea4391665b48e0f0ab5a37bd400dde385401c3c88b07ed5ad2ecec3ecf3cb254ca0a14291cc0a25ab80761f3d95434ca3025090a3778b69035032f4395bafcd06f5e10f63b8b4e661f545341d71ddf2a6cad5dd8c7438394aeb770fd474c8cc1cf7cfc199822e73d458331343a7e35e2bbe0b4fc7353dfec8736af88baf1f5dfc71627fb8e37f57d7c9ab403c469059e149880b7989f4c1bac7fe5e1dca8f599cc1918bda55825d46f47ea93303c82e7e09561fd8d980cd0490634401db2c64f203eb7ee1208f9755846c30baff4d02010758cc4ef84da37bc9b3114d337f6be805f365622d26af90632a2cb9abbfb19b232f43a88405f9512a3ce836b6415e90eabe702a9a389b4384cad2748d067bef77522a151c5bec7c6c6568d0c32a019a8bb878e13b32a395278ad47f4bac6976b06e80a801df3e22c2c7691cf005a2fbf57eb095b592095502ac60c237a282991bcbd1e713cb9edf10b3d6ffbefe279e12c29c22ae1268ee7ae4ff259f612567665e7c04543600f64671c5e6c12c7bd45187106bfa8a33da019f475c08d914e88877e80cec5f0c92e02ee3b541dea8d672aee67945b3b41d81adb732ec876f8a4b0d185951b901c7cb2805b139ce827fea4b1b07d893719a2120c512621555111c3d753da37ae5dad60749f474a85e2dbf2467e646a48584448a6ad061aa153aa840706502c02e056478ee61e1b3a4f53231d152f7f43abb8d7c388b8dfc63c2ccbcccb5b76fef6bd92fc522241161263a7c61e9266ee931c34e1bb6fd4573752853375842ee00f924b97901511d39b984961378e42b4a6feae9717f2bac697322af6c0259af56d9c2aaa53b0c3b08875d87db420a8115e41c51ccdeb3b7523a41f841fb5d17d55346cf84adb01371b16df243034616184660ca87058e40f78e6526018f433004ea6aae7c6f2bb7ca57ebe40f31663226ae05fc12a2d79432c1bcf4787649adac46bee5f87bb59b92126c1b9732b19752c6598d73526868d0ea52d5f6a5a5ae239285c688d0a6861fe64ab36a5c4c89b9b3664c512d1b431d61e4bfcc87120fcebbab64c6843451aed52eed9b3191a6a6c4ea37110b32f80f24e1d4d4398072d85b1e4aee58e49b7283bb48b35d4a62c8dea98d1911153a34115304b3f32650bf6690757ed3496d7fae7354fdcf3b7864440c52fef6fe337c73b25397ea90573adb0dbb8d7b6bc230e18fbae73bd165e637c645ff3df3f6d147fe3b56d070288eb60fe32d4bc5f0abd16ca7bc7877b9dcc43c748f8bb905e8ec0d9ded25af56c25cfd5e1913c74dd48cabd86bc1f8bf9284630a5b2989ec9b7e5d83e8890989114e655478b8bee692d68151e56667b825eceb306e7a66fec8efe992dab6735c4f98646a9bf6f577a4ad25d169bb8ce9dd4945cbe4ff4a268302f9ad1a531adae8e9f4c3887b23eca01197f2d456be802e7923f53e7ad79e491aec6344a4e0eacb8a365977b2c852b29367f43d1dba674906d7d901faa9d8f6ff0fb3da8c169b7dd4434d71ccbdae45868efa3efeb7e04fe0247f679cdeb956c47db8f8512a2e1f9eaab106a8b3886eca0720278f8f87dc6b7fad92aa315e1d58317134a5aa70177b4c80014a274b7eccf1b6d0ba81991a98db79f93d4b2d82f0006e60f7cc36b4dc9549a638d9edb2dddb8bafee6dd136eb5c1704e1509d126dcd70fe0fa97324b086b2d5e02e777e023be03d3918c9a1942702321c5dd51484d8f0b7d1cd7858186349c59930c275d57d653c53618d43bd2495949c8701790e05e713b08e3f646a77b62a85fdeae19a05e94d62e07367e8f0b5cd9bff701f0c1de7eff6de89ab3ace58d2440c698313990a1388b6920d381a865b8c3c61e7980dc46c7b984f0c5a90c96a98a945f1c44e28a41215b56e3a113c0227614dc1dfae0405b3161a31fd8d2b35d177e1f99b594cf5543757fa78f11b7dcf4572429e459faecc2096fe967382e6eb37ede2f3ae6a243d546994bee2ff92ca85278094f22710a3380658daa3fd50fbccbebfcbd4746537a5d197790f18603a38f429566d9924ce471e78dd7a15fe98abbb04f10806e8a123e09ca9f65ceeccf13f7e313c7c7402528b4947afe778ef1ce2843df3874edbdfabb8a061f213235427659d3e47f3ea4a11d1c027513a59e68f6f1eebdbeb77765bf683d514a3a8583cd585eb8afdc6cf73ec8f25fd59fc2ceb07ba9812aa82dd0ff0ae5c6ad9e1cd44f6aa010e1604d534aa1f748464e6963e0fa6f313d0f4f0cd14c6219c64e6ccb5a726d52b2676fcb3c56b8d8a2ec245ea2709d7ac1a56d78dd217911271ace038ea4e34032e0b1f0d87cfe06226b0c7f4cbd22d624d43b841a4ba13466e6035343d2666202d36e1c37932940ad21e162eefcc7e6b44c9fa2842b984332ae312f2c5f76ab45f3c0bebaaa562cf1ea54eecf5e31149906b19b9f6d94a1021f1b04a60bae761b7156a3e8091baacd2b7da6b6af4b31826e612806460a9dd451cce4523165cf9a4ef624b841efdf3110c11a92d997dd3c4019a7632c9cd434a479ec58bfe038cdc63c05d49de0b823f7649dc02d7ec75439f1bd422fb7f698177fcf062e214ab8c8b3b5f21fc9d158071e4d0b446b344ee51eb35a56a37fa03af5e0f4a18fb64c505589c6536f2aa58bec5b63b152566b5d47eb5fff6da056476c00ccb4985fe9d257288593d02627e6440e2a9addd32694653ed9a72c4807d20e30834007bb21e47017196cee6c5612dadd23c6d58387724827a84f10d3ca1c3447444160d9b281ee8ff40c47620e08b04a4a71b37ed7e1e4af505ac3e70cb213d5c14f9434f2a30452e3a446b464ac7d47a6baa9404b8207433934bd6e98c6083e3fd537837f2ecc7ab6bfc4f9252134529a45cf81a6724f506188b936f9019941a4f11a2599c3aa4dcc3ada2c9222e1625eb68023ec4af60818a4de77b0ff7495c3fc0328aff0717ede7d6ecf845ade95c5f569f876c7df815700a5dc7909415cfc3cc1d63b0f7cd87c56d36f42c0a46a7a3f4d1aa75ef3857844f8fe7c62c5411968b52ce653d89fb35a8700b64092a1d13811ca39bedf44be5b9d283e6787145207bdeff8461d2e7363b194b1aac1e97e911dd752a4544f1e7c8385e835818f6e64711efbe4b7f424e4232f31023a9efedcda6fe2ab0ae98e858bf0cb9934c05e8c1f2493a91062a06cc6b96f021d97c3a70f5afce00472727c21b0b9c3c064f6a44ebf000c6a3046c278d5ff1f29fa1b89ec003f1ae9df88a01f8413a93cf6ec879c44c4798edf96dad8d01a1060de0d5b126b7eb9d180d17b4f6a096a76f18e07b57e45a76eefc430790c51434a91402cbf210f3a0215a2216ed07580589ae93972705f70a02b9716e59f6f40c33fdfdedc03da6d1bbb4951e36ed5815807d3c1b67e1fde95cf5e69f3fbfa08af75ddce091fa5f6e7bd4681448c0a1f31552ebd6b3fc7038fd63cafef27cc6d8ffea59a9c8bebc7c9d59afbd196b407bfdd3a8a636be88eb686e9ad2b8e80cb973285f333bc3557dbd38b9d446fc301f29184f69414d310d1a7f92ac12bc84bbca62590a82c7717b6f09d9d192b654cca4f3c355dc8393e589913c081fcddb56c8311cddcbd5b7db8a866173d557f19feb9c9c6523f19f44f7ac70ad0c36e06496931bbf057e16883232d38055098a44999c1497c8761758e8da581349dc907339c778cfb98a8b514e08d74511b9f070cd253cff3aa22991cf055f94c4e5f67190fc939cf500b98293ce46975434a5895a9df17299e4c51a0b7ef785c6bd0b3f63a550d936f8463697d8f5ea7b6d0f15ed36848a822e2d30d84925c869737534d02b7d65b82f45d780820b51ce61b32d7cd03188623a3660dd1a022c8c8202ffe3225557073f2d02efb553159e90c26d268d5b3a29b2d4ad9c4452e69273a6124eb9b6a2ea443da7e9993f08c3c80520d0c808a8182f98c271bbcfbca43bbfb6da828714a57b3f87bfdea9f9c64fee579ec644a0786cc52d3ba7caf15c48966be9dd4cf9f24183c53b3e822eacc856507e0499bd970db4f1695f12b5e398400278942d0027bb876a24a56a545463a4f459d04ba08a29cadaaf531320d5821203361c027246c5598be3827b439e58da86edcdc1a8b067945ebfac245501ef30f9d95a93f4bc2a6c8786d2e6b79da7423cdf1370580bf89041a4c106601cd3eaeb40abe92783eeaf7299d16c339b81c689cf70edfa970b1a21e603bd6ed76589d44a89ec058262ef067ed0a4abfff966f87f22090cde533f6809f815cae003aa47ea183451b91fef3e3e793d9fb5cbcc17a5555594c46c7b7e179c43e3d7729a50f3688014493f8b6c6a45313aec85d370fe8885efbbaa11db91aad026f8afc3eedafe80b69a88f9dda7a2b73a4d9974abb3d31e8f721d1de710607763f871abd22840ff986cddc803ff604359ea1854f7bd1f2205760a1785466a72ff69d2d83ba080c48671da9daeb748253adca2ac87f05122847bbb8c23b27a3f7c5c63eb2d563bcaeff380db1c1399023aab121b92c7dc9040908a6824c81ea4a460c5526f95e740a25385bb0f850f40f9e4419656eb54c8ff85e8a08a1224dd20c1af5163ba8f47471fab484323283c473d6998de3c63d2a2f425934b5e3bd3ba65832e9e0bd2b1379872ca4caa605b23791c69bfe693b106d0c7a95e9d66c1877da1cd183aa3485d68cf92fa0cdcb70eb1de7c07639ee69464a6d0b51f4ee270563ebea2e4a5e7406c4ed4b0c3c36f10377c952b264047fe6afadd828fc02efdb7e4810736adabfeb6eb26d56ba82cd2f0c05ce2ca3e52ca6957e990b882a563fc4e4f39ed06dc98ee7f6c389b6363f27bfbe0be185c626a0b57a634a28f9d5451dfc3aa4ff46baf0571865d38e02718f74a447705feceb6e636cb02c26722d423dde710ec04fa38dc333d0ffe88f9aacead86da0fd4228df19b07db92619ad6e3d87724bf879bb652145464952d7a3f2615143b20edbc75eb7fa7644f547ac960f37f216117f2b7c56953f19efb9b23ce3c5c8d7fb0e5b5e46a1140e9c931ad28c72a878edf5a8ff2d789c6427eb9fa9fc54475637b0c9114cf3f8e3dc61ad672cf83e7e6d620e2a0c1a32a20ceda8f0dac7f5da3adc4f852236a60884a1f8fb33031307489ba437f2a2f5e5cda6c1c59bdb04dd39bd71dd171bfdc3485f97465610733ceeac47fa7b85517b365300c98d3f1b450021455e6bea8cd0ee4e43d5e895d6e6438f2bf81cc0a1090bb5925bc278390b3165324b436b21d475ee7890baf49a6b426bcfaf1248838a27d2ab332de50f57f9a3a723c9756d749b1a21cec39b97c6ae5a87773eabdba402adf3ddc79147d5903a238431002c431157ac40877131ea2e755708f13cf4d4f3bfbcc0fb6b646f275270d98f28ea2c40ab1d1a4df8f69fba9331e1018eb1e52b411d16a34889209fe217c46a9a799a2aafe70c30b9f4235c9f28775a0c80b9dd1eee7e391dc2d475286fa423ec8af9fd0069fd366a533b6b4a842c1146bef85f51bf7f44c5eac3864f742bfb60426ea582790c297d295c017b706b73e0dd7d3b14c32557a8d8bf55d6e3254c3bdf47cf0f18548e026996258f3f666081116a68e2518c23da7c4a7711d8df5dea21099a1ce38a4ade2aee5827b697abaa5a2b2e03cb6ff3bda52f753c8e98a028d0c831e0062b8620e3fa5e7ff4a5c7fb230004eee9e17bf47c8c32368543792ca92a1a775f3ee09e96de92cdfe4d0f6bb25c47e711dfe51a23e8c30210538eccc04821a388213502c7865268469d8163a03f8a49cb5592fd79bd40050160291214bc23ba2e8b0f84524a075faa91f49d4151e674b328df1f0365e7e950c8ebde6a29a40d787425abd5477189a204ee6a8cbd42f212a55d14e497d6e2529777045a4d85478bd0e442fb2890a987145761d88cf03b1b5e81e2504d803f6069d737b8fb53ac16641dd2ba20e40e3093a41c7ed18e2be38f015b97007f345200c2386f7ee2ff69384e5d1c4320ad5c636e6c96b2ea218bad4a8c6952a96173297afe79affd7540cc7b102921f44af9b2faf68d6593a5db48ebfb136e251331aad1d5f80947d11a402d84f94b244b1e68c10b569a15e305853031fffb3b5c87303a253c9aee15f32258b2e8312a3925254fab59da386776d8c526eb382c0797429eb9ea0c142a9847607f9f3c861a5d7f63f990385294c54616670cab0cd8c11c1ad5aceb91951bda4fe094134be8f194b8e2fba91b5c7c1b7ca0d4117dff45c2bcf7969191b8989e46a604fb34ba60cdc95fc9eef34ede71964022c2ac179173f69e58bb27e25ac606aaabca1998af2853cc36602b070deeb51c2ad0528210fdcc2097ab016a24594abc8fd12802e48bd99653fd8745db6315de56abb68b2b95537f4a203ce298f6c8bbc054a5f7e10c65014b9488423136dd35d5f492c10f6f770e237456c9fa46478f917016e86dbf0679a4e770cef194a5ba2ca6413f943b72eb36f86a7b8a71f96b8bdebf622e993e738ab389d2486f662ecd88f5fd0003ab3ae49512290a9ee53b19b2f05299fa0099ac9f24e98ae39a7ad0c0d353a3304e9c0105ce5d527584f9ef323a8eb02fb6b29b85d8667a21b3fcfdb29766e3d9f1f521c942650b0721ce6f4798215f1cfacd68b7fedabffcd7878ef904dd448a09ef2950b66a9b3c66a316a933ba2f4d6b3481262dd829bc413561cf29c6079fb8718aa28cb029db2e4b2208349ee0a72c52d8f1611cbf5ffdf30b6d2a6df3384c1ec083ce1551d5bcdf20248768a25cfb053e78b22a29107ee920e4a5c007a9b1fc09aae14af054949aecddfa33783f0ac55d4198f212eaed0349412a73ddcb1da55e83c3e7fab2c4a7c32a4bbe96f1114a14a9481cacb13165b8143a50ec0ecca86be3136e42f68fa96aff075f50e9c699c7b2163fe36347488e44156c5f415b7366a7a422f6f6c0866aa39b990b57eff39f86aa6f2147ff3096efaf38f9d94921d4dc8e36dcd3bf31049d21246c2f2e961dceba83695e8a62e2d13cce0e486cc9a8d93201417c56ea8f801e731e693e7f06ee9d2a0d722efc6a0e9cd52323ec03bca264c3e3a2deaf9f2dacf4f316e15b3995790b1e71058952bb7765415694cc3f7ea17a484d7b1085eda523b5a11e2980f62929ac478cc8fb20e162e352e7cc871891cc999b2668459f3ff1bc96e2657ab78f86ae690f799e73a150a8199a09638132c2164fc9aa7f1a7185b409546b8ee66544dc4df7ac9e7ece9eeb5649daca7fe206b5309f347f8b837c253e9426d054a4ef2f6da231556597e58922769b4dba31d0520fbdee5c7399b4ea165e3428f2ca108edadc7f130b2e646a43c6a576334365948565fa1a8a4d39edd6a646fdd6f794c44b442a47e33372289909be6351ba9f7888bc3c20b7715db7b98908af4b493a84bb22c04a7d808d95e4a51de14ab103bf87cea9b2006b2657c12c93efe6c3231a17fb6e039682fceb0f662edcece5cd23c2b57be6755fe814d614803a16ffe100260d43d205b1bef73e66e53827ca94342844e7a2202459f89a8d79fbb74f3d3ea484c866e07693bc81bbacd48d68a076ea91b54b6ff595678fc243ef577e65dff2491f27515325bc11bbbe6125a07023ab7c396879ebdcd1a1e33a95394b1a69257b33c2bee9c927980eb10dc994d580d27ce8f204ac6609ffc123f3488434b210cbf34df53a4be0d521a386c40ac6adc10ba6599fd34f5d11a09c35945d164c2ed4bc0c1dbcf6aa61879b12ac1afbc6dd09ba623776ab1a466cbea078331590e3436262796bae6430fb1e0364d48b851b26483f465b9f2f1912372472caf62d26ff44d8e35e163a3fb19b92480e22cca0ec70d2315a4af228e0dfcdc5620d42d0307730ef9b4ec7b9ed0ccba10a70ab10d475aebe8e3c9a730a035a786416f47d2c3cb851bdf54655afd639ef1c16c99487467015c89177eeb2f40933138547772783fb4b37d92e5992ee1e2a6a015e2aae959564a34549d25062965337f46050a9c010419c241b909f3ed0cd398d714761ea09b94f171d62cd90b91312669615d4f565dc701fc0000e577a972d78b86dd1ecf7badf7e4559fd5625797d0f7ba3d67a10ec15ca23ef4636c54c5f96c0685093568d9dca66a4b16e5a402050f36d0cefd2ef2b0fcd235aeb4786d33009f1d413f69c3896ea081d3b397d2bf3bc406420ecf33cfb9d4fd1326167e3de018d390f6c951c53dd884b1783d40f7c5a3aa70774993a87cbda0cd5f939a18773cdf0c7d14b0a7577468b283a9666c70fb0284833120054ade267c443b9b1aba211c60d23b4d0b35a7c797e6efa9d9405a9b8ddbe1e896084ae76a841995be7a6b373638c832913bbbe04cb245ca83080586f8001e5f04f088d94cf6fe8529121bb318db6f54fc740cbc94f2a5ca5467b99cce1b2fec9184c9ab9f616598189c757ca68230d8004c6f5e34aae5b4f6d474cc56d4f6be69b8a0a12a482d511ed7b6602d6c848907a1d1ba9fe4716c492b10f94c0037cd6c35c6212405e167549751bf12d33e9d43b815efa320621f46c6bb324a1104f91dfd868d85e6e784020a82ef971bd97afb4bd2f3aa62d5c7c7ad8c5a7ce4beecb85973357edda75de6ab78859534a8b957f8eb09d07875feb5e4301e3a53ff64091af576103c3863f5e6f2aeab4fb3a948a9584dd9509a778eb167ae93c059c6a10709af82745f3472d25e52f2796db29d0630c02759f228011590630c5b3992a618654d7ece68cc33d9ceea7a72149271d36657a9e72fe22171d08a64a13a372d81addbed8a4be18346964c12610023cd9b500ea78ebfd0e8e123e5032d6174fa50fc6af6dc18645b8d5c92712417f2098c45aac903278b4d087240dafe214d10f2813e0112cc74057b54874a4bd7e59be992441443c9c79455280ccb162efb0bf1e7f4c01640bcc27316c461b2324abb72ee96783a923276a5ced20cd4bbfaf46242d1234af8e4e5971dddd521f84d42dafd5636dd8e14c7cd93888bba3ae08ff19a3d5fba8aa9d69eefb8421ef81ec369df0c16840734e25e8c2bfa82e1fb9512121dfa9acf0611635d9932b48794b46613048f865697ae01a410b8abbbf635ba8fc5c9ba60756ce9f601779bab571f4000d40a5a17dc6fdd965908c59052fb8b87a9de29d966447ae3bc9cea93454a1755a9fdd8da97d412c29b753b8d9d1fe154d3f472620875336c0e7752c48ccdf975bd4faee26bacce4fde496936718b51193388efb473a6c93fd0870e2eadc1c6a79ec9d85a8e78fcefd17a3df89c9fabd0fc6e6ee71e3144f7879351178107d311d18d27bc824d7e902f621cd008e8ac43610dabe87cdcd59cc803b1bec9381336db91b58e39ec4d25ca2d24882d06339b4125c23b9a0045638e54920256048d39021835aad6b90e7454354e9951e92651a2988e8f142a98fcf7589dd9f4c36495409638dc74127153feb679c45cfe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
