<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd442ed58db706ae311108586a7733b8c69a7d6c8090ff605810d1cec1b73fb3da9a979b8caca95a005654ddccab07d83bd926d62ee4caa92803ba412fa9a74e3a12d43916f00a50506ba08a68117b337f43ce4db60f095c4a91e4aa58c0718b796b64b3d3b7cc150c85396ff230b9dbf251303657e45123a1ff836f95f422f047ebf14fb464a0fe2a1e9eb77fc3426c051d7af9feeeb09d5271d88d0c742faa2af395f7ab1ea8096caf450f8aa65acf38ee62c00aead1bfcffce3d28ff1f253e6b53cf16ce8bc06e51e0d1511486dfbd043b410731c0757a4d0e6784614b43d069be90e1ac518956d52cba1aa0e9bc483f40335fab0464d2b7abb1e0308101cc4b19849681de2bffa8f285485fc541d4fff79459e4ea1174cc28c2b5f5706a4fd842204161bee4f65b3b4a6120fd8eee757c2d07a8ad1271867ff0064041df47f49746334fb94ea91fc8449f8c6a122d56a58d70519be0a92c4200821237923bd26b548a8e4c9bbbd75e2676472f90e2fb167f6e1a672108d61422fc1c023aaef0206f2138f2612fe0c7de6789c1412c7f457c2f9ffd25b8bddf9905c94b61a9586bf5d355084d3d7ba7c241b021b5788272823eba281b63f57bb73c949080aec4af68ecaeca1aa83bd18369df92cbe1593984159ccc7fe2ac03eb1e3f231888f3e1d5f54384324997d8a45fe631cedfdef0301fbb2ebf77b67f15a6621ccddbaee26c13027d61b719db507624255c35d6bdac0f0dbc8920aa85fc8f0e7219719773d1aa91d03713391dc6f9fe0393d415a78e2f73ed83ad7b4dfbcfd1b6265d53c32ba14d7af49729c13e06e7ae0b5940e09d0a0b12167928c125f5d95e0341221a196e9cbc541e04a680f56a82940f454d627820b4432a6d3041b380d35cb93683559c73a2963719c6a64281b95b1631969446dac021ba236dbd9570f40845cf6af5ae008e960f9cd71aa58ea929d74974b8427bc58f0e7bd54e44f3c09429dadfffd8355b317216616d539bb7a5019d609dbf3fef149a1dfa63017d1cc6a532fc1ade0dfbab82c374b725be56ffa96c63c3fc93d63a25b80a2981d16c978a65c011c8e34f88ce6e92b49f52712503da433f28e4cb342f96258a883d840393c012d3f890ca5aeec9814f0eff1ba151d3075d3f60525c847c76bd00f9f92512fbdb7270a6a4a5ba749f02fe9360f6209b78080129e5b16c363b71ddf0a4199a8248213b3e90b98e0ff10bb31b79053786bbef6d203c5854440267d253d9638f3c4cb0460236c4bb4317f64c55c1cdf14381824a836d231ae9ab745d1e3cc1c9b3545652949c3e67a86a55becf3a2ce9a9494ce6f31c98c089bbec5b3f4a9b6cd3feee3a524fd4cbbb121dbf14cdb19ee08f28d331167f8506318202d5dab261cbf91a7883a5ec3c2fc93c0db76c9931c4ef154344a91aef9bba13d34f1b76ca033ed8b7c5953d939df7aae4566efc075af5b0fb7b6154140a23af73c68d98433f7e225fdad074748f260a3d9f227648e6d0caa401de03d5c93fbe813207f4fe0b4060cdc4187769a902ca930c753640fb757389d137d310f8c5a9661d770f6a4581bc91fb897229ca457764c8eaba25dd3963b67cf0c2a8b3bc1b52461c7c4d6396225921a454b63f589b1ba738d590ba5c07bae68137e99967136e6f34c1f0a6065e841c8e8d8125c96e06d77eb108dd9c25d5c9bdc38943cf71ee64c9b249c5cf3bedc79228240667ab2f24ded0d85f36b0d85272d42ad1708f4ab2ccccd14eaa37f78d8e13d3e7733b7ecb7d16674784169be15ea8b39968000fc92e4184da0fd55babc4540bd78483deed3877d0ec43a29d0dfd94ddc74052c9cb20ff5c26af779e646ba67cd4ef26c4c493aeb8cac47483a080ed056c96dd61e360dd8d922dee9f134060ed1c3e40e962be36d4e83fd4c04c2a838c916060ffab50209c0724ab3b21b99cd856753913a412b62b9b7f487f1ca1f5a44ab2a9e7cf8c878771352b006ec4f080ba0926c66ae9f42573ec84326a29c9c46a56d4c324deb1b5cf220daa6295e10df533294f61264887300d80dacb9e386633aa4e4f6c6a49cfb57f1615f0f1559d75c0194c8592d4ad90544f840d7214a3cc8851a55e9a92602c2d7055c41d52a55aa2ed581df309aadef07c3198b90e7f77a85a367c6592c5f49797e0d155e6026418e0f445f584add4b352370042b76606dde911dea420be7b9a4570776193cb15b4c084c8019c1dcdddadf9744e4d4608f3800cdf3b7d73c63afb0417c37b12f8c789a8af40c915db0a69da2be8e65199990acafecd9023cf4e37c652eca8a256edda3a93b8f4ee92dec015c4c3784ea15ec4e2f1d35c1b46d5efe9fd6d2a99bdda8223cb9d9f921f532a5a59fae44a4d914d23190bb385c01c907ca73ae85a736f877cc702540d3e85791fa4a4ee7e8bc80b4745ef199c9cdfeab573fccfca4c1694f2e30c8bdc41220c2ee1004036a3c158af13afe87bcff4fff058866974ed7284a8f66ed8e39cd8ef5ab2a2495d9fdca0bb077a59cf6b82176b2fb12f79e1c14e1333f7bd3c70c12483cb083a409fe3f2c38c9f0574ea561ee0866c607bbd2581d5f77ca4b3d3ff13e5066a9fa01a531b00d92f9b43a6fa37d54f2ff5b04ac680656d3aa99100097f54e38d879098e047707a53e87f09203dcf72384b1352786145232c66ea108ddcb862bc5ac584f0967bec57edd15b66d23362d10200f01e8b336c0bc071fc79f62ff56305d22b558f1413d6bf5e5a9d7e852880d8cdd3b36fc0bc354ce1419693ad9c1627e53e30eca272371e68dd0e35449da906fc20526f418f460425594dce9aac04880f824b30388836538819c8b951ea6e520a60e1c8e28828869d5e55a82d7f1a20a02ec874edfa4601574fc2c78d00ea8b16e1c2494f06d09527afd279a9849e7066ff158fb66c91d8b51a03db3f0f07a5cdb33954f1623b05d0df4c8e1410e739409eda543ea246ec704529c90657adb263efa7666d7bc603caa9a88889546a825d8db09fda0f0b760096f9aae77b04a5a4f6c384ae15b3e64229929797e7be805f1147532d2455b63418f792a49c230bc5410365d61038a45f8cc5e7bf5c0c3b65dd9e650ce953df220e7ffd31ed270000365c5a3e8dfb17daf796efc025dfd4499775dcedc799df5110fac29d19425cf10c88064650fbeec3ad49292754f73745fa9222db9a852c191bc3cedb84d807b81fe75421a23aea10a90f32ff24fdd5c05029eaffdcd8eda2b1f18b9f2662bbe96e9867ccec997516bfaf8bcfe88318c23b6f0b1cef9794bd1e7657d3624f154af06edb29ac6df72b2f44b1b363bf9e357f381a8ff1e877e9aa01440d00f36fe32dc6366df511ea00c06e658908dd6f6917d9f786cc4b57b783d46d366037c714ac7abfc7212cb88855606b71cac33186d1ba046c2f13740ef3e0d7863c65c3ed6c430ea9c1307fba9787c176a6f311b81c898cf98308db039ded57fa7fc0590ff41bb13621c975663a8bbc6e6ef8bfb9320c7efa53b74110b743784d88a65c13e04ebf986fa9d4954ac8ecec4ff14cbeaf955d65d196aa824d0d3b4db611f976b137fbf965eda5cf795b34a0991764b1e5bbb68e4cad88cc5a0e880d836514fe8c906cd11a6a125d1ab7bfc0342ef1444efca9865b0df333fa3ac605dea5a80f755a7f9fe47ec5e29d42c4a43def467a43df9f11749108211959285324f0c19db0820e4c63cc881a99aa739b870d503563d375336f00737502b24df1964006902b4e9067715df00a5747160819ec2766f0d5f3f5a2bb2c14e158ca25459dae0b87750890e846fcbe8d2ed543bdef2fb14136e07ad7b9983f9b4f4a12e3ab543e75f351a4a0f26ea3099aedfc70f8c813a86541f54e964dd74d95ce3ac00b0fe65b9f644efb8ab9735cb3a1757ea3dcb836c7ac2c7ac68b2b70377c63547c8adb7f7891ede7d312e66a9cbbc48fe46a719a8f6f3258549697f664e70575c37fd0f7f6bd2b7931db4c5e99b3aa25624098ddf438a4cae30f7efc0a206cdb937abe8ec2312803083a4c64f3c98078a42725e632889c5b17eefb30039a88a41dfb381d2c5d7a37a31795da01e37241c1e89eb0789c684b799e41944c5bcaaf984d11588af4ac9727ac31a44841d5f2caa545427de95ab0dd984a555bfd558f4e506fd23718ba58a1f51e1b0e3fce5ad018453a8a5fc875828e3ce38434bc3f3d580674e79519712a68de7bff4456ec177238b3407294bde4882672709dddc0ca81dd6eaf12d9e06a1529c10482267188a6294f996b2f556dab5e238255a123169dce27ae0c760a45e906ca5458c5cb8ff4776f67bc059f158662b0dcac0c1c43a7dee16ef65a489598c5f139cc568757f39d0146161c336a573b7892e2bae45180aef988a461019b00dbc357f222ff0e7344051fd7b0822f9dce3c126fffc886b59217b2af0ba09e561d7cac6e72f88d3d2e5c56e905bd487e6c723e0e8349580367495b8dd4145f5f31d9b5bdf606ba843f474c8121c32f83b907ee3a789407b66f3b8876bce5924553128233ab5f6dab44fc3d597c2e243940322df0a515408fa9b7fc4bf76363a6cbf7a0e2d402177ce9b758e7d131fe0185bf65d9259402f830af75647f34138e4b9a1043041e025d6ef521219e1c213f61d52f50dea6f723d15a16fe1e0f71aa53efafe8eae4aa7d038b2de10b6f134ac9048602cfbc882b8a3298c23730739b2495c7c92f3b4a94e876a66a997517efcec57e500a16e6c6eefc78ef5aeef0122f536462e7cb5e5ddecbe7a29f96a0274192f9497c723fcb5a2a35388d5c9d6b9d05424ce6c0b4e6ebae1d1421c61a65bb42643ee24ec3ede89e057ca6dea79205ce191ed44ad4b4d6b005a877c51f78ef8859f29898e2b377c037073fbc46a4f7cc9c1a4744b0602d1f8083dea3df7273c9b07c42f37cf2dba0c9cab457ae7f098834a376f3cbd141d1273db54c0e75b7dc401bc7ac5a895e5dc0a4e694629ba8361692bad1ab154d27eb788ae95c5aaffc5a4f95b006aa9d149b34153564389914a1f3e192c72fe35d7c510a508b3fca638fdcdadd0bc9042f7b1ac61f2b335d77516153292524a15cf727d8b972e98ef7b69d2a0bdc75d7691ad45f8668d196db965a07680e33759c326de10f223c26812cc845e1d96f92a214e35b3a685a84a81b21e2a608ece4195c4fc2cf783b3ad298086b255f770d84c25c23a08d90e646a9302f756a12eab8d9d27bfa565f4b6c19acf3e583229fe0a781c15fc82085455bfd7e02b20fba198500fecef48b46dfd5038e46a1822ebae2edef59d147df7101e75c01c93479c40d4ccc51588a1290798d054fe0a2a3ee23f75be5d9991655dd152e872f70a7914f0acec294f7b420a8fb2e6b05061a036711c73ae34d1ae2a9bd4378242d116c8f877211a1153ef8e2e0b88b947b6ef07fa6cfc8130b2e1c7b0fbeeda74329ee38b1111d10b3dd469983f8d7ffd571ed06accb883a39eb9be5c22538c020ddec2ba957a3470926bd40cb6e7dc70254d95d824a89b0609285caf2f035b3180f23a35540044eafe8726916188aa786c54e1fd633c0863e66888d621d2d174abc4671380020eb64c177014488b1e75e974d21ce4534859e078b6ee84681cc0d5f7c8461a712e2377e862facff6f2212186d4c31fbd6746f6f6cf34b4d12f2e844bd5a96bf9b4d08f03cb2d58c3ce73352ce5c3ab9c1b902c0ef678893b8f9e1608bed66b2497cc90880a5d4cce175294d9ded2b19c592b8a6bc257f80c92c2235d7ff59a87c2067b80c349789592764fde63206ebc9cfdbbd3627b501c28faf0f9f2f8eda8d1e64c94de5d657c0bf2316ef476352d9acbcb9a5717c4c8001fe34824cb3e85aa1a2ec2f0a4dc94f876efdece943e5334c5ef703fa445ff6395191ba4fcbfa1a28db2e762a8ea3b5ec86c1c54dec5d3d025add377fd868f8e9b3715903a96b2e9f17d60dd455cbb12e61be7a0f18a249129e7bf25a78547e12b2f506968889eb3685928d9cd6060910964c361a28efd14935b7ea9bf45d082fb632d70af13c9a7848c505c2faf42b002a7b35968b7b2882ddfa5e2ce2879fae3de15b99225e6c325ec8dfe6f5ad453f03a89bf96d1cee0047ae1f4952872ffdfeae7cc95f28128cc954ee3330b679992dcd6711a6d456eaf393f88422af868511560d089d463e925c2208d2e36892ddf872ee43737513b73154a2e5b2812e06fae6d34ce28229becc0c2c9ff9923cdaec306a9e303e22391f9ae8c842a1d98507f312dd32b6d1f97db8d6844e2fe6d298deb14b6560b8134792c2c0d5be4a49b719d437cd70e5fc3971f67cc2766d39cadac18d53aa6fa2eba3906137540cb04432bbdcce80c95aa63d04b881b2175abcee4589d22bbf9337fd265f2c44e41fc3273dcaf1e73643d887daf57c48c6073afd9ff64e2332d32e022eb56442ea2b8b103c3711dcd49b655fdb5a865f89146295d8dce42ade7b27b8ace53ee0981a201f10c36a379cca7cc8ce3ad34fc08dc50efdea1c94c80374ecd0ddd600ca9f18c458d5b8c81efce0a20ed8e607b0571335ac111410025b038bebabfd5f215bd491b7897d5eec4a923355dd3a9238286d1b2b35dab8fd023878a02d874ebc00079c68c052de43a6f162a69c347e83e7487959acd803e5ca5b292be1f507cf3f98ef46af66160b4ae31314df27a2be7946abd3e9e95b69c0c681c67d60b56db6281b66ec840d45259a5eaa0a6b749ab6dde7ebb1908029fbc999dae3f74fe72b5568b36b834a0b8c3f162eaa15c7d363405416ae385faae2b8fe177581f508ba211365ece2f3a3e539df769dfcd5fdf83d7b1ebd946e49bdc6891ce9290a933f0444142ebfb4d8895f08ff84c1dea92987a7ef02615b5bb3d5e8326db90c2f0aa084abdd22927b280ef7066e6c654915a3006e5912826a11bb5f6f9fca9e883d1d10d5a9062115574e31e2d8cf2ef3c2e51b3067392abc6e5dd0e225c5624687f2d73e2fdcaad8b032c514d8e58e783eddb6efdb1752a0dc4bcaf7f6d5d4b14f4936564b5ce3622a406b6fce135da4c6aa5cb3af418d972f767f1c66e0e6b10a4ab6c9583f41b00553c207c2c1e9387329a41ebb9cdcbdb3e8bd7eaa5baf38193b640dadf51ad3389a79216c6100f1aedc25beab39850055cf706bad12e740eeacccc4fec9937bebad67a467e37f41589db7213c9373d1090059dd18b8fe269bd2d3697d99a0f6801549f2554f391e51e1d758cd775c08266ad477c40a6dd88566416b7f59ad4d3f174a972ba817d079319740e60ea9238eacb1114fe5afbd1657a0866a04e416da28f5ebeb832aee4d65d96710875204659ae13daa46f465dc099d6a181c45b51a47e2a47e045ea4226146301f680119c757075e50d9fbabb26a0513f93118f8fce04fca321f455a240efa577bc6fac324dee69151d738fb3a7070a09309de1691c4c69026a7533c1c80eda8c828f18566576a13ef817c909d6a4eb23f901414aee025c0fb2ac5024da8c33137c3d51feadd68fdd60d19c002136ec020d6b2ff89f899749df3a6f23d5124e6ebabe643a273761a92af38247670d328f3be7cbf8da9dad0f72371ce1c1646ba9ff321304e71db0ccf0527141ac4c9937b5a7f8497d888e487858f8653ae2fe959e4813d16c73e966461e95c2ca53a88eea407ae2ef0b5843293859ef993da9eb1a602ea7a89cba87ac5547bdbaef3e32b134f7335c10c3239638b6e00bfb478e827c008d8ab7525adb833ce809a1ad6f5256e436c4ea933e37367212cd54319070be4c82273e86cba44eeda75912a57c09187f0b83d873d1d84dc22a762f435ace181a6adfb13752440ab6f1f6ed5b44a0c919929628ecac8af55e7e53a978c854b102008e2a6f003b33cfd1dab4ceabf6fca853a1306e3be3b55d8eb9816a15c31816eeb56d35d5eb4df3e2b201fe14d9517782de630fbd4bce196bcf1b5d007823033612bc9b546e1b8aa18e06c808847011dff4009786503913f1a5c2c17d58d42a7720eb3a4ea9988d90395d39853d7ead5414f7785de24ee174434518c917ade44edf907493a34aedb83f65024fec4236bad9a033692564241d877f6a2619cdbc170dc8b281e1bda3e7d86c6a49dec93ecd43383c64569f132f54e5519a1b9c2f99ae236e8c837b1171f583fb99bfe2a8ca727bace8aed28451c44c750cb5b4dc2ba449b164f452b921e480a3caa16c07013dcfd76713e50ee06d412a8d2ec861955ff2d9a8880545a976c83cc74aae2f87309ca3ebb213483522673f79f2c75d53de3fc0c0bf80ec737525bd003cccfe0da864cff16b7dc10cf90dbb25ba47460ca8bf447fd80f3c0dc02eb26754a7d5acbd875773477dcca194d332fbf2495f395fdbe9d2b2ba7e79ec1f15f7d16da6102a563cf0bdfd9a03dd60745b1072521400d5ad603c4627c6b1ec657714fa6280844a68e5c2c582e0aeafcdbcf7ae527db2751f06743f2787dc8a4e7c300e36a4685db03e1f2ff9b4988277795e7a76389aa7dd9b7541348d6306ede8abc581e3b86a9bf809047ee64342c7cce396424bcbc0f2b758a1c757cb87034f683814dfde7da54a733938415ef464dcbd7c9b5ad4926bb8d6c2a4671f5892c167369fe3dacf594ab6dd32eb4a61fd1ecd2dce681c584af53cb107384d6c44fc91d925ee0f371ee9e5bf7ca32185a6990c708b8792d9bd46e66be2a22f0c915d6ee1fd44109b1cf52d7c900bbefc2f8df522f1c590cfe78b4b1d506a77dbe18465ff3aa41bd16f7efc4c3f94f071a3f0068b784eeb227095e79047eb1614036af64a2f4927188bb8d57459a92d4a4d0634659f22640e64c70438c14ded780dc96731aaf7fc7e5cd29f144bafb503f553d51532bfdacbc4fe2a338ca27c8b4b8497e7cfb7ce81f68af0cfdc1a693cbc80a6ab6daf0b607626ad49d64347ac38004e7edaca411fb737e61fcc8c72cae4c4bb35ec52e7981ed9fa0ac68d64be00c322de84b7cd38fb4071c467ba5cd52860dad02b4b16bd16eaf94f766310c8394f5cd3c7a06f0b6f53389ee8c0fdd1be49d4f244bef37e35c1860d7a90990610cf4ec812d4436293a244c9d062778c0f52c13bf324f50853facc2137153447c47a3119c6e03ec4370be0d832dd2868ddc955ac2a1dc60aa3ffea1a2d3710b704113853e57c33500c8db2a4eb70578b47bbcffd588926c54e1850208b3cc15fd3115b610f80e24a25dacb413fccfaeed2a53b48bf6c1b288e03a5a0ebdd4d788a9a41b9f7d258fddc81a35a67dd36e68ce7c19324ed953af20a7c65ba8176eb64fe7a017c09d52a34a20d716cac3f506d79ced3d9a5756112c244198894f0c3dc4ec07badad24a762f5d25443596ae2c4005527d82e44ec0a3e6a1df76c790c2cd4bcb290b5bb1fdebf083aa938b5f27c0087df8ccd25d38c50fff09c810e9972f59a292ceab9587e7ba664d8b8b139355e74e7662453af85f7ae2091fc24d3bd7ac3c3a19a9b1b1b741f0c96a7156dfc31b231c6bed93abfa9760a2d14c767a9a69d9bfa1a7247d5f40465001f0ac72a94b1770d00ead70389e964ca1cdc0971055cc0d1bac38657898f9a77fa4b1585fe0fd37cacf047872a8c8912a66f1b3bdbc21e3a69c123e0e6e172a83b64bb1ab563dbf812ae3dece0b33817e66cd093e232d47fad7775d744cab516af0a711304036c014eb95693c5267a4de8c2e74e341eaec25e0bffeb6cbb9fc75197c872985699e26b08c0027796d0f56b935c98f53e7f5459fa0aa990e050d00ed617f2196bc231a6b5d64f244fcee5ae2936732aff4b36c0fe68d58ee296337949f4820c947c5cfc511afb6ef740ba9add274ac5e263034cfdd1f25cf707e177fc0c730ace4a65d192dec882a73434ccb7a66466450bf9bc1704b2691a150ff30710a381b3134ccca91b73f0448f76769191d7348dd53aab8127557222d94de663fc7dee4c284cfc7047102d654a7465c0d5dcfac7ab534741d8e08cf96df1a538d564acdcc383de6b65c45594808f750c736fe3a0718ecc7544cc0d719dcefe01ee1a7e424331f789d7751335fa9a82ad13de8ab3cc501269c9009fc76e0b54b8c67cd96c5cd6d6cbd7da9976e27ecf1627ae695fc91a910ce05e1c1052c524e959152a51930fafeafd1a967c78af6c42694680a9407b637540482c2d6a1b156f6c18d3b7f1c578f959d84f87231b513f46de60ebb91c164abab98aaa4b0cf9f3ca45cfbd294499a49e4a629e0a4d53f4c49dfaa37963fe6aad8e0090657a2c9d5224f12ab9544a5bb98b22cf3bd52b156a57773d17f883b7a78052203c5e8c98cfb262ac08f79c99a87b402ddab7dda766eac2d59f80871d48933840dea45c5c2e91b2b73a986c133d7a9b6e1e76ab7a66b34698b27215936da0981396d07bf8b3ce72d5acc34c92c58edf4b375f2b31d9c2580512350e0a062a00e2f079f85af45b4e6250a2e326e7092893f05c98d63342ed7bc2dca4217cc6b24c7bb8e8c6cab8ff2c29fa7a09acff4d5745d0c7b4852e446aeab16c011c8b9ffa5d788a5ed590d2959f9a8e11b7d29bfbe4a4dffd21d4b139fcc8ce7cb200544cf7f6308216ae729787a7960515cff86071cbfea6fb6e6f738d9a0849387d6b4a4c7ad7b8ab376e70ae4fc15eae354103e005d5850c7eb3ed497277a8825b4d02631616c912b5329647946dae84516110bd308e7340114591f1bd5dca9c71ca9b8eb85565d5f95eb835db197f4b9ba5d729f9edfbcd37aca39940caaeeb8ccb4a790b05538a2402705a375d20d304dac0c47e15f3cbd1857d8247e8fe8898fa6dde5bc7d28ff9eac610043f408c3126a074613a8ee9cb51309b3685661f468a44ac0c14783a16df9ce89b8c3fd733c1765d4fd39a11fb7aaa71e628debdb35adbe263f93d5aa509ea9970533448947ce33b44174345b5c44a9d55e21155918340494c4d90f58c997edde3a7918ed4460a115c11232b0a82cd08dbc62f8b846b0aab766ddafce635e377f7ddad537ea2a829976486df8fd8c6d576f1dbddf5783d4629a96ae9bb23dbd467a737ee0aeaabf18740bb20bce0766a61ae25a2689a6e21a967bedd8b12b4e22755325a5a2a0719f61f2de88397c5b0adfdb32697295b6b5d13f13db48435b66146950e956c236668a95b38208a024011ca9237b90e78697ae333740f1cbd89f06a42bc903ef3b1163bc5f9b5dd891a3ea2feb3d881043382bbc6e1df638b0ddea6cb84ff9cf61af3d34c09839ec6c0ccbaca9d3f576cf39134dec6c25828a033e355d271ecf1b64acb1544311c65ee127e4972b6e9e42a9e7629aa51f82864c660de72c9691745d3f52e0ad8aeb4303b4d4a7e9984f1f4f76ee1ac06914d5c2c79cf3428b1116437aad9195cd36008a1a3bf6d22c4af474d4b30da0c606f2caff1fd26b23fa7e2652580b2b9a0d32ce96c7d2779e14053857c0e6e35e0138b7eab8e9b3e8c2ddbd5f7fb6ead8300997ccd667ac62dd5f5ec33cfadc028793eed31f3a56c8d289b522c4c8332b85fc6829bcfca5254ac6a1299123e5a29b115aab713b454a6ffe1eb7d70558550b34097c2ed26ae686eac1b032fa6caa7a453ca6cf10775c7f6c73d8a4dcf3cf1da52c048feeb1c223d5b3ef782888b97ae6eb3429258d2393946afd58cc109087c05a4d7e464196ba16dcf204457e382383ca54b5fcc69cbcc4489acf12a3d02ce0fcfe449eed3cc54c7fce77d6d63db75ab39e62b1bb6902a83464a413ff085b5c308af7c1bb76ed5fe12628a0bf2a5a40e52dc31e734ebfff8866bb5e8bd1d44d618d12692b075c59e6c55da1f68563ae9c878663589f137046862532f392d6fb5f99248860a7834b68d806c319836877faed5ebcd04e74eda0ba234bc5ab02fc1e4e392c69d4dc93865694d698a9c158f7064c5ee96f8d5fa388ceb1574686b71eed7b3c918e7a6a1ad9597ed508b880668eb0cdf2ca893867548eec397ef3515ed8ecf8894f1b0d024b42c22c3d1caa917927e65e354e3f8d4224c83aa373bc4588482ea2ef90cd765df806c48500133a7c609467135e70ec9bf32a1d2092c30f15b3f18f8acc966fee698278ffcad5c6d57331fbda8e3c3d0c202bb2bcdf097fdbe32de0c9ffb90432c65ea5bae26903d240281a0e74f3b855100bf58d57ecca20c80d405a7db5bc1ae439742a7550eaf5d11b677e27e9d8b5099a0d7cfd1b95ddb5070213be03bbd9d593e4806c589bef772e73e9420748ff01d836aaf1aa2ff814ca91622b4a0f02f826361803f987fa2fb9a4b3337ea44f0a73dcb241549edfa47e0b0d465f449cafaeba2b5bd8007942206db88058760eedc1c3bf8058d6bb7d9f90e1d7fd6497f55f89f7ccc7c0206475f8662d1f7cf15ed02389bf7d4e1e9936242e861898ef0d08ee138fca8d0b819ae7098bb13df04b1c83b9f7ac3e2c14e13a0f112be39d2aa82350e097373b65e9191a723cee07447d44232156dbb4374b38d03b441140ce687776a0fae6818ca12d54f2c4e7d5695ac252ef29f0512a499e3288a035036b602c3ef0692006302e52c62a08f9c068e5d964391e1bf67fd98e191fe6bdff3f767b8ed8b476d836fc913acecb67c751ec3b0033677ce5587a2a2d31f3ac80519e83921f6d3012b9210bb333138435ed186a2d1643ab18e07f86b04efb8b2a1b295fe9765fe91dea7716602d4409dad524e24cd0312ad462e11f8d7dc2819d2a2d0c126c9006889b26c34a84031ab85e19166028845d69e082edb28a9ab81aa10d61e50b34ff9cd72f5dc9b697dbf48f41f7d670bad8129ebadae6e51e341b50ef430da1061c192bbc93d069f743b87325c9b96c0a1c251311a4dfd161f33f9d98b96dc264d4a7e762007333fcaec145a183a7094d4cfc30af9a6fd2b702ba74f28c679b81b040f0b6c9ecff000f2b1596600efd988b4cd916470745294c9b7cd955123d7b53230df903122dad292138e7bcbafd9492c607dd2193441bda001a2ddf5eb92748bcfe66ca3a234f64a09dbc4ad0b73b400af7a060ec00f8b227a4f90213201740630773205a2911336d379019ec493c84c790221dabc4ec8573e0ad2de3532859faf99b79e78f524f569d15356b0088d1496760582512891f98706e1e60ba32f0263e493705dbd545d68e8f87f3784f084faa37fd66e573f16839af9d7ebf78f9bfa11a5d353c40ec7c52db54e7b25eb5e91674fa2c9ed6bfb178bdfec3886d18d0eea0dbd26a09f5ccc6a0eaef6e855b2cb52aaa501fb235653bc0ae96fcce98f21aba4cf9c3a26ab48205a046b0d9bb1378329501592dea551166aacf8d58a4062d0c8674a65becd19124cbfe5365ad2f2181b1cdd6494e9efbdae989e64bba40bc1e0281334686ceb8291d614da63b3e565041d5087adf8b0a4a1c2a2a8ce47a3acd2325da21d5e3385550734da309e14b49c60a8218afbd78a464a202e32fadb4e0f61b00fcb17428f994c3de9f3c4643a4af9a66ac8b37feb851e4573e7877a21e43a29ca09254343f723b63b5fe4d87f08a5aa549deb8eb9ad83b163d8484c6f71668a03e26743572a0ec2b999ef57b92f154a5f4432bf46126b31f2b1b60cad123bde95d69c056451190b78b0edcf5c139174325c3de1d4caf1ac970cadc8251849d3f9f93298fc103868e98ffd34ba7b252eb91fc6c0dff385ad00c7ef41c0d30c7afb94a60336db32d9be1c29334f942e3eba28ffa6ded3b987515db6726942a2c87d0e87e7d3cf49c18046c157e93ef1b5777616254a22ee8875b23acee0c2f9d838c342e8feb36c5cb422603c3ccbefb0192e72a464fa1db52a64a635b19ebcbfb77a07194828a8ed448427fc48603b9ba0e6a7bc2c461f0f44affdd0a0fad58f9ce8fc8e203c115d017b71903dcf149971c6255b7f0c78fac8bff0bbeb18f25819a050ae274eedc46a43411ba66c62e2628631e750a4bbb1e020d29a262919c77ef3c66c53abdeb83bc922d0a4966178913c0fcb72aeab047b2b59474bdfbd77010a53db45120d7a90a8901969b3229c8cfcb1be209aa1e42627469dbcb08b564d26071d07f983c65086e036c591688e664c49c07f980ba51907afb3910dff278beaaf5d0de6c0d2298fd4991e9890e8893576eb19bc56c4b27c25ac17640a085335bb9533c076bd8a8347ef735d923ce7e16a8a3ef43ba68ec4dadb6c1b5dafab77dcf92ce3c504d7d269a48ad25753b81afea0d7bd8afe4ef2dedef0d164ee79c005a19305096435121baafc8788b8667889fe4573034c6b2194995cf936071412ff166e7602a76abec5c06212f750f324a0b9332111cbdeaa3e0ca6828a6af5e0d9c46420530813b6f2a5f82d7d7c7734864f2312278a952d75501ae48e4fef70739e2ef0f2387ff0caa4f655f84d9532f7867663034017eda68ba661e1e63437731b93df3bdaf9ba3e752f186aa959f662382abd6f8779b8a7674307a04cc30fd24663268828704c446da9bc39e808abea819e1954f6983b2b19c7c66b9b660a5aca533b135a486f9978448ed78e89d51f9edcf7a5e1237a25505f3024d9dff3b8a4c6eaa7027421cc7963fb98ec949e0def37cbf771df9d23fcee5e03954b537ca0246c29bbc62413119074f4a2176b0f366339a1a36d64d147f96e12389fce984b5ad8a16262807a5ff10e7587563ef8aeb8da60bf3e1653460c305bd1ff2ea0251a0cb681d9b07314963e6ad8e2932e871117451ce63918d9f45787f58dc10d80f222346a179b73971bc77351d88f7f913e0d5b6d952aa53e48b613be709210555371aebc436b5d40c47331f1bb51974f95c0ef4a345d4b99c46126a3432b78a2ed881e552ed752ea8433e7b8c52321d7942bd70948e6486f9010ad5e1cb996b9d62a4f8955a355f1ce602118903004a82d94ba56322e7331f169e2ae405f21b220e125744bfd80d614738a30445696069ad65490b949e1f955dccc6a1205365112bd2c68412eb38c2662c31edba143dc31017ee9df803bcd0a2abff56f3c6b08fedb611f4a45186896f4342404f345cb12b58668fc7399ea05c695e47315a22206fe575dffc03e38454a70207f6125b147afb34aaaf0fb4775f5b74ba5a69013b4e7ca8c19299120f5dfc51ff16a3ffecc8085bfaa9e24c1b7237c2a10a2d21fb63a3310a4efc81884531802d9bad19a905a95be2ef90e572215df732325c5fe9ec30429cc69f7f950c5cac3edf477e6b66c0ef9920bf3fd37e03f58613f4709fb880dc88cec1b6447fb90bbba9f09f59f1c36b141fdb319814eaf513b9de544d640500ab4ddf94c9a44c3f53cbacf50af252fda198aa12ca172b147695203d40291a2ec2e380857ec9f390eba4269a73087e6415033bea2e804fe14b2e48d12d54da58bc2ec7b2c1fd00bba0a7ea6aba15c45e2e9fe7149a487bf812f1a9b36f637b8a2c156dff887a6f7fff309faa83528fdc01dedadd0729ed46a3b8a7c6043901ea9f9f88c663c2764d02a62552fe12380109863a01677fe35b849b38f661bca09f1ff385a8238054397cac033f6978a5dc38db1c32e65191d0159c86bfd63721a65da94a678ade721e1893e07fedffcc5e2921ef6c67e92b42276ee5e406d6a7b2dd415ed5451ea851544cc9202b94628414e9a7f75bc7e18566a0e08be077cb1c22b367b7c886f4e21ea6fe60b0ec043e4c5de4e03b8da4bec528ffc3b1df2da0c081357cd2eca0f46efaadfa6881d1e8ea153ab5436402f31251c65ef8790f5d9dacc70b43638c510245d08bbc30339026929b531bcf346a317a4459a08abe1b33816b2c3262519a9352799ac2bb95736b066ca91758b98fa60d181eb1793254fee5855358048226794e22870ba84ebe167050d3fe49142964c84d67b5492d41ea61ef035934b7a8cada71f4ce09eae5b9d274115da230a1a22a50b01702e6ea5db102361dd3195f1651ae0679b464440df1ebe8f82a8a46e527cb5c933ce98bca16be0bb9e5ebeeca2e0322403488cbcfe259528285ce8e8fdb6e2f752079254b6c399c20220acbc14004319f76552401230ddbe4d06cb6fe8833129be745bba1830de088c0397dd457bf21455f3dcb12a860d0237fb091b456a2c04b487c9ff2e40761b5cd61d4a67cb16cd9198f97cee38e9753fd72666080f1ae495b9ce4f07363e726a9403c38a550c0472ab46a80802c06677eee9cbe217711788040e77c7f748cbe22fa286d178e65ffdfa062f1fcc7d0ec831bc8736bc539ec766521a07bcc34b14aa0ad62ce7c7717bd807ff72ef084c07971098918209355b9bba57287b52f04bf6ab78388e772c171461a963421a9fc0ea502f657e2ef855754d986dd7cb17b60b0ae6a202347f3fc316e3c83a5acba98af9c3c9707cc9a0c42433baf9c69fa84ea2172c29d5a87896cdd944afb448871705b2a2b63f6c8fa415c488742810b89e1b7e4d4aa5860a690fd860a4416b4b2827999963f8109fcc17781047f3a0c43651260ebbd4e43bb2ae02e00c795d15d54454adc08a662786ae0964c8da946c31c36fc73110db15c559b0c7fce09469350d7c9f38a6c46bd549ee2e08b9c499cdf52ecad7be54fa555906b602cff60b82a46711d2615c50bc4e953a135a39603a343c19df487f0a839b4a6c0ddc4c166a7f7cd72da111045073750107a4a4ff385d3b416ea8ff2c8edfab53b1b2fb573bd9e61d97ae3e022c5a908557b5a9a46be80173a0d9bca236a669bead6dd71d5fc2dfb643e95075a77fcf0d67f87c10ae59ab066113f61ce6f8571c90aa7cf578f5aa535c30be69afb60e6b8d0feec929fa217b9ab7eefee3c2de14e66d808054c64ce1a4baf2e1c8ca64e98153e4d67866cef441d97863ee8c1e2a7acff6db2a2d9a7683e35854724e13ee319dbfb7a65ecc7b69fa66b529f30775a9860f1fe57bc600e856fbe882ad9f4a8087ec90723ec50c5c176da2fbac16de175142beb379e2750e089c2b8ce33e54d39afd2fd185070985609b8d3a01e479352c35235cc192ea0d91b163c29afa523c7f1576172a87d7cffc1793e60119e7c0d779a72f3f1bf4518ef14b6b2cb3dea9cc277a4265ed8b5bfbdef503f7cdb2e888d50275f0b2bcc2fe2f57dd1ff701405ced036f86ce53a3863e3ea532905c1477c193a7e5f36aec7f3eb2e05b4f87a2557dc4984698e9d0b74f83e2fe0127999d5be4e25ec2b18ba25e53c25c89f28a6d836e0b3c14f2b480e9d32cb7400401391892916548b8eca884199d6dc5d723bd325c9ac0c1c97bc5c92088ee668ba6b1aeb528c027b56d2ad17bd16411fcb2bc3d2fd2d715c32eb197aec3028dc8f3e430b9f5f334e732896689fe75d540be2e362c129c4d53921c660fb884a7db07b077bbb79631c1ee1086336b47169ef006f342ebc53bb504e2af0142c94d8ebf3e37acbebfacf9939c5ca91716182d2433fb14f2f42b55b42eb8e6b510a6b17db40d153c054c01cf6e133e59729f624d5aeeed2d165da12bf18b0d7e8011d19f3bc3843d7a3f2713e83da0e71825c914f394898860bad6336a89328723864b01e237d03f442e0134e8ce2f2ea99d46bf63da5eff9383218688d6b8dd494cdfdc7f8ea3b83f9251084530c33434500ba0354bf90419d610491d3e050e3d9b4264878d06e315040c8ed33ca4f619d654f74dc9d2c7f7ea18232ea5041a47ffc97bfa08a497992c890a57b223eb43980553e7a9e2bec7d85010d1291e7fa69c2d7b4f3bf0f1bdb9b417d1d082d1918c9d4284135046ef27d0bd1b6ad6ccbdf79d9815154f8709c130ed2ecedca563971f7adce87668d0cbea44560ee375c048850acad45e866659b68e84e42c9e7832d19f479be322777ea38c86e3c418c8d5997fdf2476206c219359f6f677975a41780c652302fe86c589f11d1c64334613213ea305fcb213f4f3b90c5bcc21725c7c8d5684cb60e140d911ae6f5348b3e91aa959bc0795bda6d61c91f255bb0b225f98bf6b4f8fde38146a1befb85606a2ffe80281110768c099c63050980b7a1b06167d6499ed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
