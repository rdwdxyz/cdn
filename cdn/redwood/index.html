<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a1dd623e3147ebaff4bbeddc7641fb271db890b9746cb5d2b80721c0ffc36002603ae4cc3f25f6aa7522c1b4af5ebb44eb872e904545f932af747649ead1ebc571b86613fa345bef08758906d9c175c8e35c945d69931d9f646f904c63575cf86933fe99b301930d6fddd31624114ab4120f99bd3fe39f02c64fb37bde43a97fff96fa19fd2d75d4c53093e8e21c6ed2067fb52f119e548a699a50ad6b0df94e53461d1d2bd213243b6af7d58c8483df461b95ff16e9bc0930bd1806f1c9eb11c931958d2433f240c291cdbbd9ddb7db9fe9d25804820f04525b53a48b0787a4b132ec65688cee7e16a52b4bb96ff410d32cbeb52e49373791d51ab1540133eb2ef9d54e6319ceebc67ac103a33f840235a00fc877226a933a15c34621e5e1a176c54da67fed6e4d43bd162f04e87487dd6e9d8688c827cfcf2b26357d62217ac6bb5dd7acdecd88abbada73b5a6d6379406937a5ede18823f33512ccbd529f2148f5830b0de403e5b0ad7b783ae6676afe7f3be4a4ba7caf2183a9c68be00c6daa8f34acde5fff57323a0c3e1e1ff371fbab1807270d022351175bdfca72e0f4322e0b0529a4a4d7e5fd31c9bc2b8befd4b3b82e89574d9cb800103fea630f067fe52c0aa6205e6ade8ffb5794afafdc707c8704474d29b1c8cf182f9c9530e89bd9da03f8cefb82ffc81c7a437622142d4b0d574e2f70dbbbbc9e024235c8fb7ae144b1e9fb98fa6365efb785ce20b3e1b5df74a7b14ee75babbd48880a435c6ef86758098d22063d895e8f7bfdeb75107e1cabb40067223e0428a8c0115d163465ec69abb33e710b20c42d337998ca098dd1268b3e924aaf13a42cae9c2a8d0d2a12a06d1e6aea0c39d023a02516260673a0335de785d0aef700693043708ebb1b0ee79c31c2c853292d8082d90b32b95b660da6419e452b6c3acc1895a6c9444ca6e966940f1f6afd06a7c8b9fdcabddb093879a33bc0d2a2aec9bfc1c750984b8db913e7a663b7a65ae100950afb432f07a551ed120674dd5ba88bc4f4b77ed5ad6aa8d2721848fd18fdb95c7d7e457d2d0911067f42c025b51f0081af71a5dc059ec644d99c7e3633cb180d503b7b011ab1d8f54a683ca7aa98b6d26c19f818e06d9457505dc771abe60a676bed5f75be39e462e555e712bf10c9ac4a4473ce8a8b276922cd70b6c571284d5b61ced4a652934b499c10a109957271088a72a6fca239afd4a2fca296c9677952b74bbc7e352639f0a725caf12daaa540aca41f997dadc2d2a38e23e6f24a8f5ab7050bf17d262932e81a5aee95912e7beb574c5831c38730d272de5f8d9c42b446c9ce2aa1e13da374ede62a3824fa63c2f9fc0830ca96e3548a7eb80758f007607a26d43b7b81592ab4163be1b05b38f6b8fee5586e0d73e3dd9118289abae58233e66229435daa3800f82232dff09ccc7701875d333a0bc9ab3c836304f104baac0f0a79cde2d7183419a16b54c98528cee918b04e5e53c0f2193ad6dcd515876c157f03fcf647bc7e9151d8497466c291b03e3a42fef8eb28ea6fd57e1818e36cfecf03ac948395b83476c0a847927b8a40fe2a0f8ebd474ae4e337b0c40d1575f431c4d2078533db8a6f4206127031410dcb1d6bf8f6c4bfdc61c0452b5649e19bc26111953e31f454b0ee3dfb986927065db3cc2ed00608bbd24adbbd1931c6cc234361d88152b5c38a5bedb8ceb2e92302f8c52a73732010d3d3e77690f254218734f7c78c30d0c116eb9b45054583d5beeb0cfd8d7279a3cd2e3f73fa17f89de195248b90a9f957b04a5adb82af75f0481dfbf843c39191f1aa9bb5a8df995cbe0d973ef94e20eecbb34def1643b3f0d8130fa3069fce1740c92be21c3386658ac810751c26e58812e452642fbd91e085b0af8290ddf8909c1bb4abaabeb78b605945452d2128d9d4832407c1861fc2b4b88352ce281c5b2d0755cd6f9ce77a632eb852b4dd09deaa49d90d31cbda39d7fdcabb428f40706ca9f76b525557285c40cfca83bf59037783f34313f65abac0e81983a6cd5df4cb26002c6ef673d0d46ba930654b2bbb9d2fe9a15890ab0d84f7fa205d69987182da9e134173b510bb2d005ac3b8dc6b899ff73801e144d48082e4892df005d4ad3714d394a38de526b7cfe441cb21237a4d36ba69d66e6ef8b4e31e1cb133c25869fc28213b556aef9895b877891262e66ddeeaf9332398e1bc86df0461030e95718d78b8b23e57f001e2b33423df006e345d29625a1c548cd9cc4dc5a67befa710f520c2e770d3b11e6f81b1ad966c21f2011a54d67c611a7861da2f96f7444dee93916e8d2bb8850f0bc799524bda3cee2d46c1159c3eff48e6de5b02b19f9a3e4ee8aae963f5e1d474cd2ca888417837daba99284905d4b9d49f337f5c2d9917a4ef4a194667dc41c77519ddcc7cd7e11ac825325533fd630af5bba3398f2c98f1ba95a12ce66e9dea3a659164fc18102289a515de1299f36a79597a36ed969777459e94aed1e93635acfed0e00e2aba9d2060ce90ff1b85d4f339c0553ebba4965181157868c9f882e8c7a2e38e55f69091449b893273abd9dad760cee69566fb5f0885dae38e19d0160cbb142e683b18af2665bf1ae5294c011519798cafd3ed9138b5c907767a6ecba661c53bf182412ac8a6a51ed98af14add4b9314794b809f3a186d2d42f9bf6e284e16ef3cbd06bdc64eca471c1f7e8bd3df8afff5b7ed47b79a70e8a1ac257edc7cd797e8dbd254e12572f3ae0fcce5af2c4a425117f6f726d2a4c2170ce3d3b143ac639bd4690c83202e03ae7d520d37f822d8002eaa6e5cf8d78b2a60c0493dfcfb504d993d6a3636cba6b62802344c17d95c4f829fa7f6f88622fb3e4b5c7537ee4710daf182427513f3cdb7a3c9444203e43555101b07cdff744182c4f5cc54b3b6f117b2a497e38103019d85cc0d6ba1743c9b86b019afbdbd0d05584ad55d602eb12378e371e8641d22eb09fa623f09c1485b27d32dc4857b328deb4e4f70b8af44dd35ece58a760e2989096930f89870e27af6640fbdae18b7eb98011c76af8b845ecd5d323516b6bfe8f19069204c62086a206e3195bd01874e5a4f789ddb54618639d8695f38562859993212b7c9351b6832c0e481eb9cdf2848acdcb84aeac94c2497ec7f38e1d41de7d58371c3932ee04f896f05669614429d49a58e5381f88cec458f664754e5e3df51221bb317a4ee2435f6e8162435283bbcf506be35cdff7502bb019233b3b3d70096aae9173f334c29c97ede4b5caace729759a3601a16b78a1164f3ecb2393e818a19f070e3b26be4fe5491adcf73774505fbe58007336f4b68fcb377fe14ddc55aaae87fbdf4a5a0c90c6e3277c3eb64e3283c738377f6017864b3cba4b331f62b54b28defa18e1d69ff3c23f3de758459fa63d5aa1298034c1fa642e00bf0702fe5045aa5e41d23cb4becb91c1c9792035a871c829bb62510dd2f47e3fa3769d1fb350a34782ed4416670b6fea9bbe44b24ad61d02ef9f10c3610b309686363c23fafc14dc0d0b88ef64aa282e28ca63abec327139f412adf03123bd9d053891dad03ea209ea8449dd20c20bd2446f2f90bf19a3ad645e287f8186100863946ac35449a8a87c385ce7a38b6b0333447fc1f4f197ea0496d1ef6922ba71020ee8df751d62f44bfbb8a50d0f49b617c8e3a198257b1e54fc73a8d22f233e3ed3ba1029e1c240beff0f736bdede69635078cb6af07e84f71837f7975d158e98fe5d7683dd60e996726a2e91b4e0f8e4a290b1df006506b649b9d3b4e3c21a60f7acffaa63444e3d8ddd3076c4dfb478fc53cd50720e3c25036e86cd5ee6d21ba821fc11800070ec6f72ccc9e64198094157a9373058f60513c9fa33f25e5d20922e5562a9a0dfc96cda9a707547b93f4671ca4a2b8ec2f2787b71483a568d58eccaf4d61d248d27f3e1ef0b0f97e7e63de2142490f2f76bee0cde07c7833ff7c0b461b8d9a628d7d54a18b3547e3544940180511b6c967c96db26b667439f4e05e3924bf14862636ba09301ddc6968ef3068430f831a3155f4ce0f6d402376e5e5e2bb31e031a5156fa8078c27e176028e63de5557c0a08c99b06ed514020ab6ebcb9ae52507af5936454755b784b13a9b35ebd572b7ba32b6667b61206b335c4f369561e6cffd22d493074d3fd32c582669628e4e3c902b3d807cf70ee22d1d6d126c69a79030291c7ae029dc61e5b9d02d66480db3a818b096bd99f40a54b7e378ea9510b38ca3ce6fee2af31c2f7680860f071382e892cdbe9769969c21d3b9881b6bff9fc68a3e3e16d696e0aa8527682416c8ac9249b0c85e7477e47c32990e31a3efd129cbd4fe7288ff0ec57fb697495b238fd33ee47cf9ac0a9b432355379a7d06895aeaf34cbf54097a626df68e1237f228cdf6dbd6788f0582d2d07c6c274f0b4433cca1bc9da5de42ccc2953ffd9da17802f7b5b678bde242c339cb7fbae1afc40c8ea1eef29e92676e149532896e8b414ac81ab0c2f1c32239421b203f13c1060a70159ecb043ba436539e3397fbf4f00fbdfda431d49e8530f805a06246d0e8252844d7fc898fc25556c5b9e2a43366eeda6270725738843b293d661ff52f9c7b6b968f1d2f9bb13275b8f12a8df20c3741e263c4bd497c178458c88560932659724dc6e7b808b3660e096d2b5203dcac0f59a7b3894ffcad004f10ad41c011bd7e0d8f3862c38a43edfb2c2060a39b81321296b2c71e2da524a26358fd3919bf96e9ad824c7ae2916bfb258f8be531392dc0b28e865569a0aae47965f272c1f1816c9517c20ed196820c41570c013f9b652b004c4b81bdba13743752d2e817772ec0633d7eb0c097b18c2a250593baac27a6adbe593782c6c094bcde7867299a9c9a6e08e4ec4322bda3deb77d523abb4a806234703e9b4ba887a4a8a4cfa79f811564b9486585b06b7d0a209e1b999812547fee0e92c4a0bc286776787ebbbc4614e1e1daf582ac9d43cb5f08b0f5584877cbe4ad859dbb9ed21c19c30ab714c203d565d3de8d8e694e104ec305fac07356391843a76729153772bcc136ab1edb7c0ece519326e6d07122660cd94b100d0b3e44ad065b441d1d700f42d00f8a74b137490635b0d4bb1745e7be480d3588e041b98789e977d55f7cee0ecbc74b50a90bd32ee871d686a72116c7987836d7598ac74d33525773222984c0b7d7c86d1632ac2a0750eb37e39b43f60957c451e74b2d92dc591b37adcb12463ff3beb74f6e7b3fbc6fbf9690fe13aeb05f5225bf4b74957bdcca778dc99bf0fd6b350e8fca607ccc6c474dc7d7508958c624367c1144229c5e0afa2e7c5101256414920f2608251c15017f44e68eff92665a3799342b1538d698e7fa040ac52b1917afe021c69ee370ccc02bcb5b71c619050f10db9b065ea20c4a58fd247d08a7b360031ba409c0f56ba3d745d379e1a5b302271cfb3e1414546f4b68d535a230ea2ef3f2eaea6b8a9ecdb0c8c3f0ca28cb724c8f373191d73fb123bc4d995861c24289ce392736c4da2b2db7a0ff2bde4dad84b4263ef5c776b42084761761d751356320cfa1b50733ac947689ad442e7728eaba31308afd2a54334095a638b6a50995ab920f012180872c0f81234fa72a60921b1164b24fa97cffb98fcdcaf52b8ec30d49007cf8066dc55c93fa5191ba63f4545cd8a36d85f833f49b173d2f20c50e587467703020c8031d142e40635ee72632f04dfde3e1512dd13bd660d6a279a6eb5a14bdbe4cce4e05afc1b070a12e766c00d4a20de768fcd3bb536c66ec7fdd50f45f4027744b959d5a5e47f594eae2a322f787d9795be5de93e8eb2cb51868e69e67e6ea26241292a9dd9d131c3162f717dbb024382ff133f9342fc174426ae811b5b68c734f855395ac78a9ad50bf9708659f0c27854ed19a6cd0be62a3b3001771e1bf204bd78725395624f589eb168dfdf6b531cefeba7ad4a0b621f469aae6b18ae63e44c9963ab4deafc39c569a21a47f2fffe967c8eb3a86ffd618917a1edada7233bfc33b4db25431ede6660195ca2fb4091adc8a96f6b78c5e30e1966e2ff0ba4ddc00cd06589ed6d37064e2452b80ca49c9c58b87ecb6960abea9a1831a3831e4545b42cc3c3c7a2bac3f38971088a0779acc38e4ec28f9bcb1f86e5047673b0c1f45c1fbbd40a4c30b4b58f181f170da56cac10de774a3f5d244b9deaf0cf049e7f9b3514cafeefbc2eedbf64a68b32733b6c1bebe8408211b0a57c0a2855b18c29b7724c6188879379cc5a88722a0d83d0799f712e879ecb4728bb98f1beef4d718cbb076a616f33b2f72b8ee6611072c8b4011bbcaedd5203678402f4db09c247423a8c44a126356f8e09c04278eff2ca7c4f57d3a084b11fcc82e74aff5f7298184ab65d93539e4ab1e82cc0683c3e1c149fa6c3ae76d8a9f138c11398cbd5a433b3b54b1cf6270c36092145fe64d3f1eb3af4983b5a23c32c3d10886bbe1884ebc826c240aa7fd6de26d68ea5a4255e7d0e3f3a88f3c7ecc61eefb3c20795e6bed64f94d6b5d4790bf3320081146c7d672c5e06e02915f90c0c0436ccd6c9bf2d407cdc02b696eb633f6c1874e43b6a6c7549eac5c2930957937a2029f734e093d0a405c5183e927ae1faa6a6636e31a8d65b04db5631b43cb23cafeace39522e424cf1c2d57873151c4c1ab3ca3d2d24e9e92f9e9672c337b82cac9d7cbdfcfb47015b8319e6d2501f900b5deebd710a1d9e7c53bd3a54e3b6b98ddbfba3c50056b00fd9e0a33310591781451f35381c8571a86e6da6dafc152bdf51865855d8d1aab04af4390a39113fe4d7354146263d9b94c4035b70ac87f0e98c9752073974d3efcb802be170d3ee6448b6390b701d2cd27eb4fc731349db53336361032fde4cb339cb541f82495ca1425fb0db10335b213146a5580c253f59ccdefcd224dc158abdce5eaf9e48991030d7af9fd4a0f6aa81a8af26ca985975bc8873f64607798bd08de16462293c18d39709db2b3a63d981fe8fdd69843344e8785b44201ecc852847f5eadbe1194feb59ed9fc6113a29ed36503209e7b7ee4ac7fe022fb57ff9eef80bf8d7b7e6e79cb22c094ce2457b6ab2c260385aafe9be9d444c80f356c6a9724ee6e218104dd3d148355c32549834005efbf269bdcaa4901b4f5792abb483d23268f3cca7317280c1ed6f08b360efe752b8ef74c99bd6cac8ce897d1266ef4e3a81137004c0196b9afa7380b8aadc067bfaa904bc614257e66b23936537fef8a69c7f582a7bafded98434f6abaf64b198d884b0111df7de4e3ca302af70c933d8cc537889b03466ac13e15dda5eb9f92ab152b7399311a5477d326b6038c6bc7d5a8eefa99a2c42f9c7e178bc311c42047ff2e9cb54244b463674e5c7eae82166e396ec894989479da572ccf8dcc5c1bda3d2fa4c1b02899d31a4aabd5d959e05398ef0ec24e40226b416da5b4d0c9f8fd031423b96750780352c9d256630df4ff4f648536cd56e594c26fe4f711917e358b3494e3190050ea7d738cace6cf411c3f9e94073220fe7743b8dd7e376e16cf9623b756a2e01d53a53b1dadf7086c5a3ea5a519c3dfff26a31bfba8e74a729079073f421ddd8349daf079e6b18208b020e8c3620af6a9bc376dbad0d2ada7b5f060139c7cd4216e91b2bb4f3b9fa8f9eb8b4ceea24d5ab08dbb5907f635e78fbf0da019c31143078519554fe63e1659a6a2313fb29c998c44206f1f7d886627eb0f5abdd496922dd5fc7749f173f17ee8e85bebe334a285994b0d5be638fce6a913bbab681b29dbeb20fbfa5023213b6d01e0adb82396136e001de502677e7ae46d5b9cacd75f5fd79a7fdc824ff0aed9c5c5cce49086eb88e849a01939465a58bd9ec64a332b3e7d9123992ead1fc637fe41e8ccbc6e0a3885a15becb6fe0ea426f0a69d4ed7ae9b35d44b36064ae339ad22372f377bc816667355a128f05698bde40aef05fb50ab19da4bea46506a2c4a85613bd4d9a513308cfe6968c843fc8e773023d611bd869d46e14be2f76455ec7c3207e928b89ee637d9358acdb20bcee874bcbf917f00583324b59379b4d9aa94a1a34d0834fa27e8cb7cc6787818b10da754d6ef5bfd8215c5403f1a6f04c8a07c08fc40992d271b13ffee8e291e4337a40d53dd68230a1ba1a4a3b86df24ace2f9eee980c13f4a22b21fdcd58cf3c40d682f80cd627682a1e79e7f1cb798604edaf7c8633d8e22d7a54095de9ce5e87b4502988f5d2a006922ab7e02898713ad3278875ea1b1a1c7c31c0b33ec0dd2d44e956dc72e73158360dbb0f2227779960b93fde9fb03a16b4cbb638e7f897b51a0ed2993b095fa3365dfa651204ddf329a3f297ba1719c27ab17262536511ad75df6235483581f680f104dc6d2cc9d675e8ecb2c2072337265d37a40a8ba87de272f34a2f3cdbf9113e4663696beb70eb50092db420bab59c2c97f2e1e3fac0b8611ef17a2dd5bdb92fe67be799563a5dd2ec772dd0af5c3f9c3d4fa9af6a85ddf6603a32ad3a6d3a3c24c293e49aa1e8314095a2413da0df94e62adc02a9aabc832c0dc92ecb2ae79155cde1d184d81e4e1e1d0e25a627a18040c06b504461346956eff8490e3a059ddffdf98ae1482b66b8dd98c5cbc2717ef3c193573006b8c1120d43f76ec1feca386f0694da1df5456db384d2735dcb258c1873750bf5b4e2d3d7dbf5f8b00bdddf4ef97dd92edf77190961d7d6e08a88cea0c43a3cd59071a7e0ae99c26613a4e1b43ff89807690c1a2af771702d6a08c9a9fc21f3fe5a9a3525818a46788416c1176cca77cecea418c437343228faaa1b7ac9fc355ffbf43baa6c78dce9abccae3d4808e314f883d1c41daf188cbb01fde43b3fa0bcc405f15434494a1f10483d6cb63ffb86638cc3c9bddc46ea092a895c0c79c38174633bd15f76dddf6e3de3ed625b58134980702cab78d162e46c3af8a5bf5f84bd03f5b43246af2b7b66057b6afecd2162796b71e508cf17882b6b4e5876acf39d8750807c5f77851b1bc0fc2d527f94d92383c981016f61c5dc8faca93fd289898679d6e4f19305e7743b5e13dcc90cd1c129b3c7bd93e432c184460d47ba3a79c59ae0aaf226a87ceb91b68b5d6bfb508f6d44d1c2eacb371a4c56efa092e050a28306c24cdaeb918d4c1437473b7bb62c126b17baab7c8fe2c09fe371072e4e9dde8927fade463ddd5874387b9bb2d91e9c45cc62b8bbdffbd6fa158cd701be8a13d50353a9665f66aded44134048efc76ec42f84be73b4b22bd569d65bdcb202d982da2b3d60a0aded070bfe1bbcc5468f994d0ee788fdd5a84a84d213a7c816592e093df1e655f8c7e5957eae4efddec45ff6b873564ca9233ecc4bfe831c67af6c0ba7cafb864ed3f180f330cad8dbe611b4ce8f61846c58858bf05cd4cd244fe90677af4233e73260e0fc83c9e47146c13a6226125d5a280ceae922f3369e02f4996ca5f12ffa340e209f8610cfc737029c118dcefa11032d2780579d93cafbc7f9392b3fa7ad2798a9be6cebc7ff1f9fe4b941c9af656abe0d77299cc9d69f38574d3c5fdd0e02a8c1c69803e82d89b42002ce81d6846bbaec30b6364542e967bfa0983e4858337124da51561c0d9d4a4a6ab401879fae69ddb60de64c6eb20334fe8d848d443fdf7a10c17ab04c1f68c7858bac0aa3576380ffaf6b857e7de6297383b95f40a2e95498e9c8aef944d27b6100f3929e623b4f4586ee7d10127356daf0747a3ddfebca16a4368e5306d8e14517c87ce1cc42f3694e0452c3837d065ff31d45c61242c3722b1032dd9dff792ecb57972c206d7f4feb02cb0d68e629e27e89a9df0128828f56b72ba51f4e08b46aaab2b3668ae7c86b9d3df79577527c73fcd9d2d8138d09d41421e968c48671186c6eac3de5c78293ba8549b433b6c31e06285b4b6b815466cd497a9df38673455a9287f07ff3d806605e1089a8d2054a4b2933042df4257b479a8d2c42c4311d256721ad5b2c780351b3a53a37b74f0f032ae1e1dcb7509669943cd8a2c01ab9323b5b43f3ea80b924371ee50f71655214fcd7ed163c42c04cc472e7ca4d4ddf0c517576e197d2b53a567b4a544650cee5daefbb5e14368c2465ce055a8a3ba0f03569c96074a95db3fa0a49840488be110e508ba7987d607d29973f15e5ae71cbfd29aacf814403096528a011c8ecbe97afe18c2afb041c1fa9aa374ad020f37f7eb15f6a2e958010169c4795951f802f2024566eaf9d9de8605893b26cf5a869187e9a8da84ffe4f260f9158fdec8506732c9919606cc8468407f8382afc849a3fa7dd1e5ca6b7b27bbd8df5e582e831d5a19ce6e6cc114e476ac9f971698103ac7b87e443d5ae718321a8589d6241ee98ce233b80fdbfa539f729fdcfd2e26f039e18d715d4c6e0e344c26dc099479a7f97b804b87f11eabd358ca535ec1750efda5ec54f28087bacf5bdae11534ac3d146041aba0cc0a2d4ebd7039f404e02590db626b95c4eb726fcef8b05b60bffa472498c1a6326c96425da5e06f5b366412caf7ab508729010d5ea28cdb5f04a261f76d90f3cb7e19ab48092c51c907926ba28948704d918a2098ff41dfb0f6874bd5b6486ade720937e9cfa1b212e1d03e5439dea48c39644152dde9924fdff6b06d8206c3a2c839ec7aa784d335255742114cc525472b874edfe26a5ca796c1917ad424ad43b29b1c1f92f0e55b6a28da911034a670ce9e889bb6c59e0d6c6b8401684661df08c9a05b3fe4b8ed5411df209cd3feafd3f648c7a56ad5e306dd88d75b2406b8090137e2730c54b5d86f9906154c9c430f180508f8c09d0d4c1aa722295b35c4136a5f4f2cbd5bf60883bce1fe465b968b7688f30fa8923d25c906fa3a33c47ce59e2441adb4b22b5ecbe88f2f085de512462b04ede71bdb51b1e5150617ac39a9dbacfcc8c058e73c4c05e1e1d2c04d6f90f17ef84709a836c3693b6fbc5c927199eb79eb16467667db4f36250f42d51712e2ceb94499d9fde9c13cdd26bb0925e162c60659c8f3e768adf45a46fc1cc6fc0c68005f9a56266dcb56ebe307453e8df3e9af18f7fceb1ff59847a5c393b4ac0c4f4d1d442c07e916f5b34c122b1d36e72d69b903a28bbb72594c6b8ca34c55cb06c5f20800c23f938df20faa8ab36f741c7f6ef81a399e00fe89b7696efb1424c9a9111d8c58fda6c71157df67d20e6deae35b540562dc5c0127e9d59d170fe5452bb8efcebdb3335057e112f1a141fe205344514ccb9b912bc3f4c9362ea6fa856662662cec55d98de912269323e32c03c023069070186f0e1f652a594d23356594912334fe05480afad818474e875f50bc9314876041862597671ae73f902246e91abbbf41ce8779ec24c9b9e7cb3ecce381e58f511ee3e1a0c49c0a7f7c1545adaa14fc9494e7addb12c036511604d9080e85daef630c0a232fa8e6afe215e55b8c4e5332b40899da9639ca6f9ac0467007c1aba0747cd20b3550e66f3b127b5511e33015a5d092ca1b384cdf41ede5aef4209595d35446b1765db8aa303eb15c11e21c9874c79ebc90b0657b6204257ef862ba9d3d3644e665fbfdbb2fefab7794e6f9a290fe401df36e62e4fac9ce38fdb245d78e0f04bf7e199696477bb6895618349fc2e1420e8bf65c7557cb7186ac119f52092821cb3018aeee2c7edbd1da4d29d2d0859e3878021a7a671fe05c3cc1e6d4f003284d6ceec44621dbc446e1b8f54d99dbea683d697325c115acfcbe84542a56d680265b8a5041f60bcbdaab41482533566639a3addc59eb94104e13fa5392039413beae639b74a46a1074413f30a774fd2b7b9966f9a61ed99fea71b315029a68de26dbdf21e5080e40132ecc0b461bc306eec6032d89935e0c49228012ab18b150cce238c12c9c9d9d9344754c3bce935b7dd5707d1629f96249fda26750b1f4ace0e5d93e71b669a1f415b3a52c339d7c29d267b1a4aa9ac49fd6ff770ac1345d3b201e20a37b1e3ffd90937f1071f8c3ac595b09895326f72b7992dde8489a1e55b69fc36fe0d7ac921ea14b7c6d679eef45ec05d40bf48005ec744c6c26aa3c906e3cc4df2f592cfc44840b943f0461acde8e76f3ebdd958ef5a506168a22b155621f69e8ba33f86a8d61e2c5aec3d3940ee259f11804bc420e9a8e277c59b6c0454a9fb74eb74c827cd426cf74c14b44f2f550fc19f555e465c140ba44a4efd8068162bd8828f145aa5aa80ddfc6d07c7b8645f32d4ebb9a69a0a82df88555013b25b894ea5614638dddfa5b3be0d21195d292caa28bc6236ff666db22e80a6fafcef6a52f34f6f27d773a67e5c57c2bd8a6d8ed8b8a1940f3be5624962862b1cd6b08a5cecedad7a6e1a57a02e12a5be8f445b3630d94ae315d4c550814cdcedbad78f4261858154a9626934029000a11781926bd26077be220cd5f0e0509ff430e7559968bd51b12b46766d72c5ca3076956d4ca5a14a9de647d68a81b2fa9ab27dc7dd4359245014f00df18573d9e5915338ed529051c7c2f9ebac1ca304c23f790291284e4a6b643ab4d36031c0fb1a611340b15e6b4625f3657d18b2ae5b09b6ee419f229de081d51995ba5cce3eb6273d305c97111e6d2d8c4ec5ce75b259c7052e4d199d7b037b999b1f02ef1b6dc575a1704069607c3bf14d43e9525e1f1b73c51caf628f228fdb9e0f9d7fd99ab8b8da2c52598d7f7badf826d93d6785957602f3c0baba37836a662a280e200794d92cc240d0b92e9a4c1c9f6c254016566d4ed7c9491a75f5f071030149b27f5c75196e9a94f9626f0d9b28f0241b2c168cf6c32b281bc698c748996353f571341c1d5557eb89a63af30589da4051513edf23ec81fee1552136e54753097ca1155c4bc769514ad7a86b6018b5b99c8e5bfe6ad13daa92fa9e51b4351c1fc76afc81c592a31c166df10fb459cc65375096620264f438b4d10e637635535559c06af5ec5adaa4cbf55176e4c9f165e8974bf84ddec6087f71963a113a25940a51f26687367a7d80f366e3e1c81934905ee58824b8858a4a059ffe06fb3d622de4d07dd6ad635b1ce47ef4b141464f97b6d12e9e5ac93b78a715bc5f1fb2f33e513e59ab80f6edbcfd9799efec2cff66747b5522333e5b10b28aa4fa2a2f0b0a55cc3156a49e0caae2bbaac890ec6f11b5b898038db3e8d4b5d137b8edb7809c5f82c7c41b3c5550fb542fcd46ec6752d324c3e3e9e1172d44db9184b4e6ef927ba651eec5da7034349efbda56d0ac1d7da9ccdb26397bf0ca8f5c2cee26d3f07f57e8414fc464cfddd00b5b8b8d1babd4bcb29f5e4ae0a6439566ce494d1450d4c59c35aad31ec9c23d6ce686c4036af532223d1ab933cbac717c5299a654314cf8c6f1c13abe7a024b8a97302aaecbc4bfbe0dbbcb7f35bc540f4292910f9978945a9eea0a11196927e4cb2bfe520134c81c9a3ddaf014e97b2ceddbff39249bbbe32bde2a633fca0cad1077f7d67a60a6ccff85d1220e1a31a1bcec6021082271f05e30d8da900aa984bb7f7afceb85e10c1a57e6ce3d8c2c7dce6e4a011e1bf11a56d12ed186c7c203deff26cc378f1bab43e41ac6fde7098fac325b6e30599fbc4cd4097cdbf41f0f538ecdb715b775c3b74deb496d1cfa7d8247777e767cecd6fd1a055e65633b19856d7b5c6d191963c753b148cd4e7ae8e3561d394b3cf53d91e3f04651b101d5ccfbee64778b582468bdbd3f51e354eec8553e24bfd43d8a8ccb62b42a1a1acfabe223386547603c98580be147bc6056365a285d23a8e1f5b82719b0fa3a350c063aec4033110de0879dbc5f51b23de033977ab05edacfff93d0023e3f8ff54cc3b25614fee8963e091d83313a9394b13f10fa7b0a42b97fd40a1c56ce72064087652d2b9c1e59f94a80c9d811b730d8e7031718634c7748d31f56cac7b19ee6225d6bccc0da7315cca7da472aea9f6ba7202fa0fe033e4abe015cc3ac33a55fa41cd140c216ffb108b9d8d072444ce1357b295a83af01c0d75f5b91b29af1202df8f839f0cd1c625719bdc477ff7b17a0d14c6dd8f745712f203662137e45b9ff63e5ed55a9cb5cb23102b3d8c8574ec9f46906a5d4b9e5bcabea928036911609dff0ccd90ec84511856eaebd920f516cd5b145e8da75d2a253469b2a342dc9d467f4b26ffefeedf9385d6cb7967769dd4a75082babdba22a142eae911bea9abebb09ae9a18a0d34833749a71e80fc50fb4cdc83e45f13685dd85f609c568dfe3f25faac630d2b372b00e23d928974f5035a23f6c02ec45ff529128ec841c779d2a08ca6e89e7b3897f480aa2d3ea8b397a53d2df15311b3f23146e8352604378b8a1f6d358a2c15ef0106bb3cb57b1d603157d999a46f637dfb651864350794e6589849fc4a33c0ee610d9861d9eed11f0b2d48ba91f7c081e1edb427a2e0ad128e5c4c9748ac151ca38163e3384fd6cddb97a8a744822c6948e9e7f61fadc934d33bda10c65dbacccce6d32d79147db744f3b63a05e47701401f666a9012b8a897453d04426846d3224ec60e6f11300c2dae4e8a225000de45cbf9d0ad0f2d80a8826d8ce5416f3bfacd2b2bf48323e0892b7e44f65b8b8830b6383cf1e1e63ef51cb903629d8e5a79bcd10342cd88897ac69c9acff221bcbdc4b97a6f2edf06efa62024f5763b6f961f9110f1bf07dd7535f31deb5acdd6c5c9e00e007c06fb0895ad5bf65b00b220b70a7ef35b8a840ed00f31c376fab996d3867e25277e2895da257be240bbd1d5debd391ae92967aca82e0e36b727be5500d9b8cfb3ea7a89d88d937cb0155fe8bd04551f2ee3941bc2fc70db0574ca308ac416e9580da92588b638c43e3581ce290fc86d16d8d5de8ac77c85101cd2e8f2a93c54d9b78c27ddc3fbf997c7fdb8d72a2f5f6d230c956104cde6a7fb6943077a4fde822f14d299699042829a85349b8c9c3d5e1d7b997b7c7712dfcb691cead6d51fc27557968e17f9617fc02700018c4448861b42faf0b2f930dc7720301e1ecff9ecd57479e76047632b2b111a8e794f42defedbf566f7ee32748ab41782c51be2ffe4e040fa9c24299c9db78f6a795281c11f1b75fb6e2920f12b12c75ceb1728a63823f3c9b00398bcb5c01f74c356c00f3717ca7f1e6844810fe9fe4092e045d3a1382f09af7fd7ae8a39308e3779d63232de8cf42dfbb7bbd305c2927f8a771fb3480266c01d2cd4e3544e3700164d7ac26a1e418da0d5981f6d6d0bf3f8d3b71c8c6610a288c17e813a528638852dde03be9167a260ab06c2111741641aa6b5c9432b2f38b3d9ac1fb65da7cebb8ae6dd3e1532fdb862a852d7a93721b0d0558febacc5ff8e623c6b079bb0bf97af984b5236cbb57480c07eb29931cc8b13f99ac4990715be59cf581a464e90a246b9b3eebb08ea70d1aac045febb8b3b917045ad9dc3c8741df08c5456c73eccacf76828371adc771df7130da6cfe2763e25b9b1de98c4ccb1c56a6dfa47240f14c64f18c6ba58c3c9712f85ab5149865ff08733bd33d07c25e4d949326574549a890ff0a227c9fef27898777e1034d38adffc865025098fc001d8dc707a380d34d63e021a3522a7c06fc476fac2e7390b3e54a31aa2b19067e813edf6826f1230d501360b62cf6c921a60d2e637add6e119951ca84135b4e395b34684778d2e0f4d055afcd1a3d84e536f9fea3b6a8e942117bde70522455b7244d788f1d73d6ff04ee5e0de995b5c5d81ca877c66b5b5c2552a9263450b30a0768804971018605b357ae04a76dc17b443a82980aacd1702b6199061636a1bb1aadf3e2cad9165b62ccce4e374cb8d10eeb754727f1d47fdd6e471ed85ecf1e57fed2ff99a0e25e7a3b9af159f3cfa6dcd464df4333b722d2a702b8a017106b1c9f5bc21d2b79192f0eaf0e981f4ca4ee0e6a539a8a7b86c553ecd6735ef20e25dfb6131f29ae1a2d42adc823b5bd240d0e4b14def86c73a75895ca760da9bd645454fcd6efd351eb4531855cba4487309f55ff0132db1423af2162f0b972e3bf5c1b717a80c7434c1dfabec1f1b074f8509c6e1dcba9800ec25aaa8d12f2233bb46502ed1d1bb061b872f491594fcf3bee3793c74f1710bfe88c3b6ce1ebdf3c0ef709844c6a7dadc84fc0fef62f9b593c06a0c7483b177cef9f4ec05d577845b3f2a8c0c27799105de2b41189902ef22f8b682c3dbc5dbb924f96fba67fb850bf4e244dc4ec43c28d08714e33b8e248042a74d494b344fe918b8133fc6a92442ce926cde2d931e6b45fe8c954697661602b92790d13054cec5ebb51a2629e8ccae98553488c43cd900a2ab46e882a7f2740fc1256134a131bba33445b10671b891b97281ebd2a77ffd62a52cfaa9341a9c18bece300db33d85648e87bd186bd4684ef27ebb822bd884791990f7984925408df3ed7833837227d6745a0bd9be02ddf6d40bcbba9d1c05c2792d3cf883792547efef25129b63b9f937b4e02a0638460d0931d844030d0e7f76b967feb2058d7a2b77d9fb26d8dd9d9eee178b76b367bfe09be599eecedb561638231dd029b3cf6039fd2011d3ed8dddd9ca3283a07993c58747eeb94d2a0847ac94c84d1d3609ec58bac0fafe8a7fe55a793b078654d31170f8eb72d0e974c965a01fa89d6b252a946af9f88e7aeb1c6c74b2a13efedf052615dd2bfc0e8f4fac4d863b45044b13adde0117cbb9c3d22e2f74fc62a8819311c208f04f39d8388f0723274d560387a663efbf4984326b94ffe9c2282edbbd59a20020ade1547594b165df3bb7965c51053dfdb60562279d22ae201d9c25dad0915d5ff95f27b14388c35e4b699f9a7c64a7bce484fc8d09a11e3e6469160b525c19877714c019835e3c202cd1d0d7aa5e989be6212f0d06ee2048bd3c524beb194939d4487fd5e24ec7f1feea82ebe32609ab90759fd88afddbe77aced74ca9cb7c9b4636d10345b8df3bcecbae860c25f5d4051aaa73cc4bdbf054abb7172a5c6ebd1ab973774b6d55d2ab2d6e26c3c1dc78c8ea6c0714aa422705b93f2f0e31e3da556d36fdbe77ed5e76ee55eab9c9d9ac8d93fc34cc4a2aa5271b5eb0fb261fb75bc5a66dc2e54f2aa93192273ce95f5191b253060708b1eae8882399219feded2d950eb425dbe3bc6d65b2c2a94514ed7517913eab3888b530afbe00a2f0872825e312a60f7bcee084cb546870944343b6fde6df63acd1f513a9ca37ed72c2a94f70d1b16459a4edd9c28cd2d25b06737bd6adc042aa5e87ffdcd873d91b9bdaa1de6796a3ebf4f277f91aefcc8d6a4e9a254481f57520579fda30d73fd1ca1ffca6bf03f4bc6a72a49fb31aa50fa349bec9b301b2adfe2c5994790c50d92582d576568c7a2e2e484d5080fec2531ea18240b67f67f1dc48f0efa33fb60681d42a45204e9e05028ca97584a0d94956489c63aa04bf26e5a317dcd22ec282c221a33175288cda80a5d3dc5f5d800502d4bd342899b972f266ec70fc112f00d799ea343f124e1beb5c4f32e546692f288ce0da465abc2cdb52785b0f6aaec57feb1628ffe89dda585b8e81596d90868727eb0d86700b96f10cdb6b76fd12889429c9628cde5054cc0492de16997ce2dc0fd57e05c2544fdda1963c337adb74b325678eb9a6dadb14d8bd2549c6bd1d86d2f0ce993bf4b6f027a534b353de183e1856d6e3fd7fe78f98d01952ec2769145e4c310e775bbc013318993e62fa534d9ffd5c978977b059675895875b6723c05956ef35055ceab2e529685456a584a66020ae6addc4f0436d2a1bd8fabb986fec37f291e1ba478b82bb60250c60f4510d27e16275692cfacc7d16a6da71aa49e9c2cfd4e46f269fc91b40708d2b731ca94ae69e3bf03592b0520d65b653599e92befc4a9404d229644d263ce053cce468c157177a280145d1b5b16fc3b89cabcf9f3ae5011d27c0e3af893ea02960f4c85784ad5e5f993d3536e37c202f44f411410a92ea68e2b13b5b8862beea7553c8546445aace4956eb2b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
