<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"099f064293429313e9c5cb43ec299b8fd7a85d53416579e0c3468838ee5d47ea028070576cf3e0fc9f126ea0b39ae3d6e1edc9023019e18f7a618077474a00948cae5086495aae429d20bfff4ae66663b4d2a5686850d3872ac47f650d08583f7b6aeafa80c3d916f474826864bce764299b339341fba0c501529f30861a16b88a14479c122c465765fb984cdb30f23331b33260478d5c780b13a9f8eb1e9b59af9ca86a5c985cb6f709fee154e9e9a7f87dabba47c0bdf6ca01cef7ba18ed34d22e564653922e98e2f7dd6e97a16f37929d4443226d6f281b52ec4bccbfa37903cd6c1fbff3b6f34ce7f799a2d30df86360c26420ae83dc3b27301be87f61e17ea49badb1c15cab44bb3934770b167a8facd1b83cf76562ab448746a950cab1f271152e21c40206dcce8ad803f57d0c7c08e9188201c3fa23d938ebddf670931f6ce1d564abf405b984bbcb8e2fc048626cc4799e693b5379edbbc613835f4513542195dbcb74e21b9082b3ce813ac19d075ec54420d86c43d1e8c4c9fe6599ece97aaa7736e9d060533fa2ed365d6aa4511a5b8027434cb54c7b4c5ce9420a03370f60a4c9fda91b2cc323311a1db878da4d457ff783bd4d4fbd2b0570d4b248338c8da6ff5e62e1a37d048b03aebdfd6befbea42f87bcd8f00e8ae065b16b9dd5973a83e94811691fd046a3dcfe3ebaf47ead49881ce4304b33b6ec2eb302905912a25de00807f0698d178a797a2f0f719eb305837841d5116e2d9d8d3957131f1bc4eb172068030ccd6952407de029f91a73a33c3b85574e171fc3f91fe960e9a4010513f8274df31e7db2cc30d9bc63fa09ce007b1146ac583351ebbc46825c1446f8142e28baad87e230b90c242c3a2eceb5838daecbcab8ea878caf7c486274bd09a1e4586139fd252dcc6c68bfbd7ea33344e083ee8e2ffbbd25f7f4cebf0c74678ebfb7ab3db66c9d8265be4e71f08247926ffd694c101ccc5d114729340e1f6c12eafec1ac34a2c688d66fdd5d996b6909360fd7fd964323a099f4a5c907ef892fd72f8b7bba19175f8a5e4a099975d1d462bce424ce242e42ca186bb6001875307d0910b88746c53462665c587ffe16cedc0d097a88b5f5e1baeeaf251c1eb730d559fd6ea6085a50d1203678d6a7f80b81e7db75cdf1635d12058e07aae4dc230ea737dff5ce3b99ef47c084fd44eb61129ace3c01cd35d02d1ff389c1252fd48443872efa217ea95333bfe9bbab76d775d77a0426247885a707d70f1f0e72ff151e3a00a7793d1d66354387c152fc2d98ab6f20398149bfc3d2e5ef0a476b937f9fafd2f4bf6f8f9d864a0ebf0ce350bae8519a80eff41137158f6fc7bf3e1fa9111b74acfeff8a318ef0c8a1aba2c5208f2f8e7c8f8850461c7916424f67fade58fc3d9c50539198a4edf97f211ffb2232c5d56892b68d51eefbd03ff453279622de26117a91fd2232970ad2ae6c8616554c11650db30f698cfd5ba80293cefb0e334736b50dcfe023cc0031757e3b2eb6a2c692c484c6209daf5f74793934be022ec8b7aea83ca33db5c20490c5f68930e83e7316ad371148bedaddb8b9592d44a5ecd40a91286989465eff927cba9bcfbd06086e1105f6654ae052b766fe330fc5b5402bffa7946031b4616205a6945f0b26929c63b4d5688bd5c9cc608a17ab0ee5368c19e7a99be0df9ac77b423a6c7c430bd58a6fa0e064ed139884ea157e768cff2645535fde0246552a366a01e6634300b79a00cdc49bf19b14c5ebf159dcbaad3708de5a0b29b554f1d751281fcb95a898d596f2a3a8532649ea7b1d5e57829e4cecf0da607526cf4f41c028c2a83efb203f02680acc6b702e1c420c1b115be48f8c829276982efe8aab92e88694bac05568bc6dbcce8784bccdf80ea20159605fd31906c28313a50346c7a18a1265f6a9cb8ff09bb59d9c17ad1b14e5df38ad6f730d683a546cca5a2f52e03936894bbc5224d7bc86bd0b2b0b7b14e4442992ea30159d3b69fa48b206000f062ff2c97f5f136dbd49f3c63b1b918cd9f29cbda87696de4b3fb7d2cdc7bcaa71e8da49e85c8c0f1a16f46b6efb7780de1499bb47a719d96471cedc22ad4cf7bdc2ce39f3d8ea95245c61671dd12631f3bb291b7a84124befc8bb0dac0ff70fa994accde2cfb3b7f7c78efeb72eca46ad2db9e73e0810de8552b5b2989ba54c7e31660d6ab6e24e7b2493734850bdd83545a9f697ece8e16a833b28e1685660eb8fcd3f099b98b60149e1098ef90923277e24441485e56d7849bb610555097aab88fdc17b010a0f1449e72f285bbbcf1c9731ea8cd08a7b8c6ef35d87b790db6e9e3921476221c3c72dd4fa210a6fe26b03be0333a4591d13be3393b94643861d838d5af1a4d8eb662285bbd0e3e884595c768aef8103d56d87f3b58874c179e8c28c890d560b377b6c370131df48d5b74604ea9960d7f56ac022924ae7c44c030f9a1f1e107b836ba20c5001188299c6df691a9df27ab17681821babbc49366c3967ce3801d0a546113b6d418f0417cdfff781402733a1e00362ae1c20187970e0b5f62ce8db6a37758b15fd23f0975199b34d4a16af2bcc4bac95918e789909244f162592007fab13ef2dcc3f4ea89450bf1ed8f9eb9a284873df7c7b8c1dba0753ba0d2298c3a15124dff82ff9eee1af60bf6f3d2f2e8418bef48a612e7da746da4c488646242119b09ccabf79f1df90655d3b36ae364e3195ca75e7766e0324ab5bd0bdccef9fca1bfaab1211e449b155f383a4dec73796b797fd08bbeb46eb41524232bf35fe7b1e525374838af7a8e1f95f26a7304e00d68b919cc78e8d63a50993ecb5aeb5d065c21bb6bb1e71a3625d383d3710b0bd7fa7d298c3b6539599d1311018839d03ec6dad1cd0cba66e7184798f2c555e6eb9ce9be3637ea78386493a25516e84ca13e439a55b14006ce33984f4dcc30d5d7c4733f5ef0217d4e3144d1c38c4e13ae75e71f9a048ae85e666938781016d9eded097af8df0f680eff994f3dc34f9f5af1d17cabcea723a23e5fde027223cfd0bfcb2974b7c90797f298175bcf49b279440ada5ad9449f2dbe3039330efce14f92d0b518f45bd9a0ce34ef94c4a360970a46af4ebcebbc12a4ecca4a3cfb040e58a66077c89b48256b846c7e2ddad08e8fcfcc5a25f89b7850071a9d871721929b0a69d7dea30ba9903e4d94576504be759b2300390a4096675efa891d7da35b0013b004ff13f2be24f9063fa04632bd71de72446237e9bfd3192af127f2ae2ac4c6e722010e0f20bec8ae778d4f3dee983b610334543bb00e48a4f42591bb2112a1f494326aba6e6419f5f6c89d6e97fa8f6c46b795f0e4446e5fb9ec13f432cd7b99662340c8da04f91d846073ed5ad66b6c338a2e08a076d7df8857240353c72b450b73df1f84ca47fd41e2773d55a7a328fae83ca840d917befdec0a5c1a4cb80ac49c196072c0b657640d863e2924722a7bba20351117d4ae72e97cbac485e2284feaa3a5b0af5d38d448bc87320b41f2a6fd5ee132a7bcea0fa25b8ff47369023b0b0b5606b16b52de65412f9c20f6787a2d9868b6ee9af1663103d9508ad6ad5cdf24f9e38eddaa96f1ca7772ccb34e3c9d97c2af937d339c544fc3b90e947c0a42b1a646349b16f6df71984929498291cfe6c3fcb7d4e04f276a9964e99bba27eedd38d247865e47de52e3805bd489d8e1bc3b3fb18d56f9af3e9c644372425c4c10bdf7b2607a2e3adf1efa255a6456b95c5382bb2b3a60464314460394def5c8af4f27189890411c481297975d7aac8d661e28bd62382c326c37751d23bed3585ee9ee868c5f2787eefd78159fd009ff817a86bffa570ec8857eeeb94ed3330c62bbeeaf29f28bbab54a725d6c7164e65afa9ecc4cef33a2f8256e76e8931f7ec805ddcdb612fac116bc27537daa156927c05c0cfabdc6148c2bc0ec9ec760013b1d874367b1f8a4775bd6547b8d264e35b9c5194e716e378c3563a7a03e91877d7014e246ecd20151a5aaa9ea0837d0679d303578393fa820c77ac6e032d2d027931a4f62f3d4b3d95b85df807915211e6b98242a94e4592e62fb0d9af3bb8295a2677f10bc3f321253e15c7d48c11690b1f3ea6283cc47fd1f8c88eccde5c25f5cbacc20cee6d43799a2ec8eb58ee40e98ad4c2be88efd8cebe9557bf1063360699d21e1a81e10641a16500a32ce405f8723ba38c6bb265108340108f516b6ea3ad589bc5a6fdfbbe0190dcf4221438af806c377baf90bdcb4fb6b228ff6e9810668deb7ed441760d141a4f2e2049ee0cb4f1cb5a9d56a2f320f2b7fa3a8b2ca45ecc0f19f2cbaede3ef1204e85ed599b078c8964d0e9642699f8fb51689bd3436b94e63c79c08833d1b07b93f6fd155d8146f368816eac94c35f1817cbd7b82d63b57acf2ad8c276ad20836ba0459679d74d20182d5403db49d65d2dbdf4206f8fd31d807802dfff90d9d2c0971f17c76eefcc12b1e10cb0659bc36c48cd5d21b618922beb3ed96cf5b621ec4de0a888d65e99b0f12db26e7d0b77ad4f02a5c98d324fd7ad45751480d0068f6c60c02823f32a1227c68bf373b234a13acd76bb036f39d55a6c71252aa61d6ad1b9d48b128e6c1b7c09258d13a39a4e08a9754ec2b0a7cc09b059d43b7ac770a884ff4d922c7be0f99330357083f4b1fb42ace03dcbf6cce5a355d80d8141c2bad57c2e5ddcf186075c2d074183a2fc09f22e3df5815f6bc5ec5e59961cf77e66efd688886df2f2f907bc0ec2419faad1b4dc996747b6f2c71158dcb175d2d1ed7153b22527061ea416cb6ecdbb34a5675289357c2d39ed9ad02f471fe7ebd95c8e07cef25e134bbe4ffe0361add51007cefc12c2198598860fa365a349a08b56386df30639a0955c462ab69eb6ce5da5d5b3fcac3988b457ed2c8104946cf3f5ccd30b1ff7cdb41e1500ed511a2cecfc09eba62a18171caac1a4a9240436d1a38955403d48bc9936bc818e3b4e2004ddc4b18d9a808ae38bcd2646cd005e905e8c8354b0505dbc0e21e090ae039a3a4a32cc9091a4d738b04314ffcf94914cfb6f8ed5a04fc8317d4b39243c1bd3a98a011f1978ad7b9c34830615f090b6db133f032c61c8e30ba930e9b1396e29b5b7b6f27a7fdc4adda83ec43262660198222a8958db6a0d93c7b846ebf8a0822330ee6fefef1a63b24b3439a8e17bb92a6854bd178e512a2b9954273e9b9ed3644cac92f6909bf4fdb70fa230109d64ff77f527a9c129d00273e5d076d84fb2a8ae9cda1214905aa9cc6ff31599d56b993bd6fa1cb8184335472752ac35041ee6dc39d91b828a619626ebc86f831d92163fd89458eeec2d9c8087991e84f6300ef6977b4f0bc78edf886f4c91c6af58b4d70064182074fadfd7349d15bfbdcd031110210280621ed866f5afdcf714cfcd5f1ae5b1306b12a3441fcfb9c7bb57e38b0ed50fe0fd409e20d983ea37f228418f6da6c7a2bac6d6824d020b3984b4a2f8a80ae1a859b50d5cc7ca8e6050df411b9ad174bd956df6bdd657e76eaa6105aa8f23c532d349343d001dbb71e4ce956d1cdcf51268aa17e26839bea38d740be29c421425911ad7317b78409cece87d8963123033e3ede82616df697e872a3d6f02a42205967e3c0cad91bf9a1cd47bf9470dee86717697ad254dfc93d0c1df6846a9b47586e1a3c46d27facad533e068598528da5186857cc760be9a37e6650dbab623f5aace782d7cc1b9c872559b0e50aa5c45b45ba512aec0f58ab5cc6e4507b77ffd21fbb4187dce64455e803f30c0c559d3f7664da640a11d605aee740b28299a27454693ca94427b6a99d1f13f41a2dd9800611be9a90f0fd63bec7f0670220ee39d9f845a1a0b9d09fd8cf2b95a0b9e1561c02b2eeb4c6494282a6c77714b9a115a4a6c1e83d649946c63dc2cae6dc8d2e739d0f0c7e394779a667238c3d3c48c5087cf03956734ad9f7273e5ca5de35ea66500d02456664ade84a5feff975c2de5022f8e3888c0485277cdf46ed9ad6b3fc6a4c6757fc6159a32318662192ce69f0cb1353319b0289013fcc68c6ee993b1c343c24ec2753b9ce3f6be13765d9f512831c4cdec6a1110e31dc32ca1a3d5504309f8fdf333f90336fef3582088c71b47eab00d7a8769a4856d649395222c4ceafee40967795c26aebf0b663f318f9fab246fc0c89f2f5c124b99e4fd77ff73fa8ca020681f77a709ec71b6dda0cecc81ae28edf068e815e824c74c7b1e97df9ce89626f615b28f90a66cae6e29980194a354e9d46cf1b09f95112e8217057cfa48bff4b170ffa9cb5171f32809bc9449935093a5a1e25e9190a7bd15adcf654e31c89bdc68a53c0b6ebd89b677250ca3346d12113a845cb5918de5bb6c35b42e20e44ff05d4e140eef4423f0d87af10647391785d3885da6072ff95a5595c2eb3d5f071c7fcc63a032867bf54af7fc9488fce403b9dab1a00b398e849a2ee92c68a867fd753dcc34d173bd6af386195021ae05b428324b4cad5d139404b531322d7773ae03ec47022708822d4068eaf36640a293ec3a90ce98e8dd0da7a083d573d5166f359be20a622ad7e65cf80ff4927b8a5ac804c0c8ee449a8643c40188bc1de7988ac2f395a7838a0a5a5628a6806854eb72d6961f6f26fb4b884810af273bb067becee96c39b7d3698505cf7be0a4449680146bd1a5f8a68340bc1829eae7db55fb77a66a531a4ff3b4f9d2388ee1f6ae2857f5bd2d80cc43f16b7b02e803f4b5d9a1a1477f6e978e2bd3a95383f8008c09acd1997278912140b988295ba2058d15d51d4795d4c1049a145cedb548abc3e172f4c9370126165a58d4fff82891731345ba25ae65760d3bd2ed59df90ae39ab61a59a8417293b8d1c4fe6cc99a406e1bbb30eb23c12e4eebabf904d27ef2b2863d4005207db3aacddc9a44d8f8f6f01c75fc07740b996afc5d218daa817230f8e7b64b5218f94e7255a1d6c42cf10f70f6fbded4b3ab32429edc9dc64fb59df34e7086ef45f188b76011145e0358db30107318d7a8bf48f2b77b7adaea6aa8a9d4622068a63512b027bd2314f51a3f7379187f897a51587b04942324dc73161a37183f9f04e18a97d4d6c4fa56bb45f1ad396a3c3d67c1e0bea0f8949db2b3fdc48fbb67ae7ddcb099e6916f805d938d383952523da2b77d00bed478dbd7d6461e6ae5ec53a35890ce00248eff9db241fafd5336d09f349203abffdc8316dbb07c6c742b6d86602127a64a774130aa7c88453d832037539cd96224f160df7407e5ef5dd64f6d67a87763bd5a1a68ea42978a276ecbf63cd02f339a61b1b9c792cb22229e6a9ce53fdd28613fd00dbc5492e244fef8041bb850a73da9805729d0f809c0e4b26e93659c7695ce580defac5d20f9e0ae3760403c9a3b611a214767eaf3a32ab891c5bf62d31879e09981036b7d9995c0fc6567989911db6e0c4a7e6e030802c8aa0f9770ce43c9f23b63d1523907b8691d39cd9957900f9aefe5e1253ebf27492a3a14f2658a2a2dd54aee0d664c976f52e066b3cbea283ec24267b391c81aee4fb1e4810b0adb3b81be36ce1337a1fe4111351c1f6f2b42ba3794ac719d7ea54c36494085460a6e421151bd5a7e736348d8e00dbe2fa9696b044b40b6b3a404fe5e8edecafbf8a23063290415255959800daa28bf6db826b041122990c94f63c6674e3cdd08cc576b427ecb47c2739ac2e3d76574e7cd452c49337c69d6eb2fcde67750cc78b04807855c5f749c6fd77814902098ae968d1592e82c79986098fd803355ca026874028123e07b7adb955fdea8628aca22e68a98e3604e8a70cb0cb0c7abcdd56271525013789dd133da33451083006831d275ee34bf8530d37a1d0072c0fe27aef54e0e69745d6d6c9882a85bc871399c4d45a349d8e98573d374851fa159613fea455ec687b2035fd2bbc505f9e59d3789ed0ae979cb33a6a286cce661f0b412d29ed1fbf9c8311c8c96df7df3a6f0d768eb9413ed15610c8308840d61a82c58ecf7c78145580f2a33f036d415410da62f304b9d5c15e3cbf847269ad75acc9f0263cb70644fa0f9df18934870a029eb0fcbb8c1dc60d0e7cf281b73eb51993c99aacf2b7c2638e459e8551012daa3c21371d03fce87bfa534ea58fa7ec238dbd05fa77491d27f036a32dd0f35218bce5d198d7436b60958dbf39d8e9a085a85c90c3f6e84360db615c93003ace033518e59a22c1d33fc770cf1de60b333086f7aab3bfae60c30359528c03cd97c5ca8b6252b5441e02f5595f7e85f9aa69c096ad2b464e09d2e6424bd60e174461b5a17e883fda2d661ac171d3324c308116ba7e1e28bedfd24a2cc37b72c4fd99e01f44334cb67af3336df114f2daff8634abde68e90026fcafa6416e0181a2168eaebdc1124851dd11f471f67857028a32076c6f7360d5e3e454d8b918a8789130f8e4250e463d981405a777cbc57875aa3f494e46de4dd8144c33f2f1bf154e9f0f6083e2f21d3b9234460c93990b43753a77686418d111ee1e6065d56eabf7414faf6f9d0ca3ff2790de7362249031a1bb776db92f6e1182d63f8ec0b6416c8fd258d474685b68882ccdf8589d05c00b69ff3c69a121a371a520bd03d3fe09ca34d846652af1e519025d1a35850537af51e9e8a73064839564a3d7f37606526e251271d8a9dad399e837d679c8e7e9de927d62388cab7502a87dba32018ef28f4383a72b7e159dfdb783504f005d5024c4cfe31db3261ef1c38e29ede0ad02948de94ebe4fce3677cf6a8e32e0394bf87375c2f635a6f3320ce373b1b8fea35a5b3619162efd0447a981443fae7bc46b1f9bd01aeed5340848d1f3ae865971882b440b37951d22d0bdaa3a270029bccfc0e8d70ce82e7513364ae7f485cd73e4b2ec279f55b92b6a27dccc5ac168d0b63c1a17f4113e281135831db75b1531bd982ae08b403ebe5640bd125014f1b4a49a8f74efcf8c9674f2b802c737448fad317b4b3f42b93f79756fe21544d222113de904a06dd9f8c2a945c563758c5aefdae4f33f2edf77e5714753a36f68854b0ed92a07b7061d8791bc6b39272032a890ce1b09baa19c665a0094488542cbe6acbecc4ffdb5f22c187b26fa1bea96a5cf80e2f189d45a4787122f2ba5d2e95943e1a3f40f77eef7e4aac7b51ab56ef49a1317ff26e6ce47893f891ab53395c8e2429df01fa15af64dcdb79aef3f3b45adc95c2a55050478cdeac043c6bdd8739df7e545b8ce753cff2243b6affc228def0d002d014cccf6d4ccbc5855bcef98ebe2e6a9fe6b1326d17b2e59ed08997e254a92d292fbe97dd1e6316d2a4355a6234f29166978d5bdcd8dad15e5ab14d54116c73d11edcb0b617d7fcf00bd9b4f96ca9000ab7feda156899a7af4078391bcaa4f326332944100ed15295ef476ea776c80bb567f7cc8490d554fa98ddd504c3a0b23890e8e4d4df70ef12b035104d31cf4c5d1756b721fe351a65cd7387a2c4cf9596068cc3332d9596060d98c6189afeec8deb8b983eb9b4980c5e842d8970ba8684d7b11909109afb00c21629bc082d1dd91421a6ebfba4fb9579ebde8a277273516279ae7e44e46966713e01d3886c8c11defef5156926c9296d2cc1a57b670737f71793f31049018939ba45cb966cad593cd2c40272cf8669c5eb753920f10e82b47b9165ed32abba91757e0f750641d081f20c1353923fd8c85e2630ad9b9533e980d2199c28ba19864cc54eba4f1cb94f1de0b728afdab8be2f8ed7d78c7d902b8249fc38fca8251f9c43f0faece37eb12470b8e6db651012c50eec55100780714711799fd3f69feb02d3c4bac02a5d757a456f92dcb95e3b70b7a3d3b777265c31f44a886cbdd726dda8486d0c39eedfd2ca3e2e2bb76c47633cbca93b6878fcd36a543833848e6bc6834a3e108ec42b48ca85bd496afe8f3b5a3a9a9499fcfd139ccc093127601e4ee940cb984c1f3f52bb712512a681bb714ddff5cccc82f0187c5863de42840c80efcc1019c5f7d44ce6c172f7f707d20a582acccdaf96cd1774ea507934603c1fe7e617584042bbf1676eef92b561284e0bb0b50cdcff3be1fd4bb3caf020f5394daf1554b7c07336f14244c6d0ecc875f76d1d82767aa8f0b6ee06cf2e47eb1cfb8e1c7b317708c5dee40ff960825baba5e508bf8f6480cb22770de3ad78f3ddbee6a0351e22354043520f457af09b6bf396a7b12439b11b43109570c5601bca1955de769aedb1d52f8673bab51e6f67fb10605d8ebf62f6b2d98152e6f7ad7184688763539a895c3a9949fbacc309c0f2ad1c9c393f3f8f66e5c371cd9223d5d796ed99f2b1f2d8d8d6181a7b676db5395183eee7f4c7dbbfa3dae59cb9b239d35b1721619a4f8d27429eed0cb47c69219a0ba5ca00acff4637acdc57ada1169f101740e7104c1636c9cb0207087ecac1e653f800873f90b7978898e4b66c45da2b578d8ad68fb756ee0f5b98dbd11663c6b08b250b32e30050e71908e28731d632e820906685f24f368fc91625b47f16d8518a298c13406203838aa87dcc800ef8500c4a1c7920a5ba59261fea1300c2de0e8e4c5fbee61749a91bbd8275298a6a6857b032e978349735fa14292ff5a170000f11153c24cdb7c06c73c2c1958864a1539d693686fae0fcf787fae7a91b79f74f1c6a9d30d0405b0e952f8e1aacd4920dd1006c6e6b4315500552ad34e36f873a631e846aef6af80a7c0d37071dd54eba2ed36ccc2a341edb59980c2cdd8b36033ca318caae4de43d70d3d131f0327c6b912aceba687608422522a821648c9ee736778954ee909322bdb3900b24cbdf83d10b620f83f1eaf4085844a74859b70098b2f928195d0d6990e64bb506a1e1a6e8c286e4dc83c054f98b1bf008938ede52ae42d0fa3773e3de7718876f3c4e29fbd6940878585480186cb60be59207d0c976ce9fbfe2129c907bb6df74a6e64ab6c7c2df671a281326847163e309ad5df43451dcdb260dd4344203d2f8f6cc734b0aa4c7302902531e3162cf9c30413bd884e85d624f0eb5f27eadfa28e0b732d91796d3cd2cd896bd2e7c737042a1aecc351149699bdf0cca224672b39a9586832ffb9fd6245f7e469f99c907766bfe96307e9ee25b70eddedf67841a2ff793009dd4d541df00bd6fabb735f1fa6ddb04fd29361b8e07142570602685e646878ad013b712bb660e0752e6bc8216e1f14717462650ce7d5c71975a522d6acb0780a3acdc3d9c671de4dcb75a3afde21cf5ee75e6c399f148f1a76f1debb236a77ff3e5667704585fb360dc84e8d8dc56c33ba9b730d9c3e9aaf2ab74e2dbd8015faf923a9c505941b8214450b76f392a6b5e9fdeb7a09eec10b090821aca5775a7aaab6fdffcb166a59640ae0bc3e3caf11e7d7a9974acf4c3f66b87db83e90cc2fb9bbf6d87575cc61ac27a91b97644d40e1ee6357c9919a5d87ac2717d3d1f864650755aa34fcaade64b6c7d124c5b3c1bc07a36deaceeaed84a60b7a8736996e9b81b2386bca2541df4cb30948206746f9feedb0d31e447422d87cc779b57e40b55d53f2e02f2ea6ceec2904f99efd9e313a6e79d225db1a6244bcd22ce98993c783199380a4579d39a07ff1be41ffa5d71c1ea24625a104774291bb6968724576d72a1f100ac02384d9ddbfd1bd71bde862b4726da93e4a739e0df4b690f63a6c9efe6f9a99ce96230b9500716fb7ca96f3e746aa801830020eb35406497af28753dc3f0dbe679f32b6893ad371e02be9986887b5da870d72fefa3476e79c858a98c26ff42fec62359ac63034a22eeb8374875fb8ce21ce8f80f68c958da833b8dab76c119129f337418235a0e11de6a46f5a28d2fef7b9926a3592840587d6eb32b7da5f619bfc590b1b337825fc1aa6c89a0d9ff45dd37eb0602abbb0a4211689b33eecd51926e206ba93bac34ead1b917095d6462c2635b64b7fcc97fc199ba1cebeb3b0547b81e09bcf28108444b1b206b968de06d89e58e6bce3db043f0e92798e00da91839955c4e418a20f7402d5c7505c3641c8b3bbc6984c79d2ae27a637942e0c5c0108eef728df6515bad0728af0a30a056797c619573b2a0b21db9dbaf957e38c422a37b683a437d1d666b01568f00f4d993afa96f106edd950201fd2a616e31eead4cceb52aec3b0d0ec98c95cf391ebb59858863441a117d5151efb61c85e53fdf1872f07e45385cc6c42ff08cf4669006abd50efea64d293276da0323b90870105f95df971f3d797057c40292a357f7db32d4ebf05c6628d02990d3bedefde92fbf7be1a2082893a725d02da94ead5787738a1994a9060fcb2a52604b7089c00a690219e3d3d7bf1c6ebac6260eb1f58942fedd2a6578e30ed6b704540ecc8481f191f111e7ea91452731612709e4c6dc10fff0f22b7370fe383114c95e682714cf4ce46e7dc251bbec970412876442896bfefa54011573ad832384e2e42730e854895c0f6612c93e1f10b4cfe8ee711be4d6a0ea1b2acc9fd5b85bed98abd77a2a4161b5e64ed3d6ef2ab48816e68698afb96117637b9293abfe2919ec86b30c2206e433523fed2c7d46d67a0a97913d0406e3a7a3a41e3714e656ba9e9af4440591b150937d417ef123576f4ea0a14b75887b67597e4396e6d7ac5df817ccee3d5f259291b240579e44fac7379443dab2b5d8484cf7ed09a8b515e6d121e25d1031910667b807329118e05af35be3226aff3933d370ecabe6492a0c46b8ccda1505136d1cd2447de4113eb055194d3fc8c2684b9d3e2b96296ab8d7dab8dde71a9427491c25377df060734b7f8bc3ed7a40c887957f9c19b0802b8a4439506effcf9d48bfb4ae9b35d0dfc788e43428a2f396cea1336df1d340ec1068c453bdfdd56efb7d6a6d60444469100f157055c38a0de08257870a9700d121dc5b5d61037f2224994c89f0e15c738d69cf69fcc8b73ad6f3d751b00d7a4c2b2dbf565f51f919d6552dc48fdccba8bd9e242e75bf6242321c1c4acf9ec78acb4aa96af0a2deb1e55ed8a44a870cc86e6b7214186dd0ca3c17c7a338ed6a6671ce4ad7e226fde61acd2f280e41a9c528c4c653a8a71a11ac4152cf1abfb34d9a54f1231b65e3eec0a8951a021f21dace211f82f30f73dd45d028a579a9fc1c2ba6758fcd275d3b2e63da00d07358a10a2ff0c011b7d0aadef117eb9626ee412717a3650da3fd1fba5c0051672111d923c261f4b9a7dc1f16139b12be1360bd0456e84d2bd6921d15699163ef2b55cd15a4d3e668b6be6be91e1c73e19b77ebc196e70b53910751a311a05c1da02d94f78ad3760e37f70831bad132788c36e1e29d8eb4fb5955bc3aab33facd8a44ed96e1ec6612e838806edf2b29ff52bbb5cbed547a2ffebd08c67615449c9264a36f56ae6aed76221b361ab03fc20a5d5654697108b3a20f23f98e252ec34405145261475ef4623008ea4884bafd3e09b09856ad5d58b4ae07fcfb2e86064131e892ec02538b521552453193ca27c4e40bd8daa32d34655fa4731e4fa0e81f73d8276b75d4c910e7af8ab233c216346cd5aac237af0603b8670482788c5467c010dc5fb713543a5062ee35946844f801ac46a5522c819b3e68cd51e43d9d0221c121ce525640ff5ff0de26ed06fc135a54bce9b717f440876f10591d78e6081b9c50643350253170bc8bf79a42eb00146a2fc10d6a9f6983eae300690b552e294d9cda64873a8f55d9d59f5bca3ceeb6cc5fd129badae7d5ec20e46ca00ad0450e07274fa4187d7ea76548808a3f02d55f05a4fba2668f9846b5acae8b544b6b135d24771231eaefc71a5a86c24b2b79202a5e00db70a4b0c6147f8d43b2b3a81608b5e37d247e60240d50f3411ee127be4cdb63beabf435d0101ce795c0b981049c371efa0819e78377b788a32b0df69d8d517b8f88262ccb555ae475130647518bf8af56154ad96ba801aec964811b7f3dc0e942fd91da00218987449ce8bf21eed5dd323f940a4299ae91b03111d3f2bbf9170b5194b8aa3776ea4cb983bd1c8f7d9b258e662ca64ed7800f6713e6e6ffd2c6cec85e0e5664d33d02fb0e252741aee1a2a392925068cb1741b8f534d4ab857500844170610e8b079fe13b2051928aba7c5cafea045998f888f2eb672118aacfa00bef6297e4853aaa8916a6b9c216de1c25d6e5d2d320337d8f8d968be667fbfbcb2ff01fda5410fb6da44b9ac7f9cf45363604a6e887c1b0fe743614ef93b43f76454d158e8df4f602e2a0f8d81052b7296cbb25f073dee8e215b03da4a7d9106f6dcf4ad5f7611389d647c94955b1ad2966feaadc947f5fb01e1478c8606b28ab0c31c8b4748ff7786413f6018adf60a9a3a5cd4626f4e6f7ed98d0e5f2c87ec4c94034156589b9dc4dacb7901b5034cd96cd5d417aa703025ae80cc2b6b73fff45f83b4ce03eb574c17dcbd31f20dace666b052bca0f2b5ead822d15ceca26c143431b833aa9199b2859f88acf38f4f645db8a01cad47d03d682da8546c450fcdf4c7b764afbf0a93eda3cfd016d399b60a97391b9deae62bfbe6856e3173dc381cffbf4726ea07f0387c9120eec4dd0ae733eb9aded705e06f094c9a09fd917a5c0f2c3c9a5d4bfe810700dcaad0b37085bba13633baa073f6f78f96f940b661bcd00dc20627772b0c9a511dd84975f38a0ae732a6160c9547a67c43dfac6b62e602331b84e1397c84a79e36323d13153a1e6e0aee08de407284bb21b9ceba3ce16aa35888b650f5dff4ba392d1df7c3d8ad049b223c6c68cd72b247496ff6d5dccacfcad5b72aa79aa4b7a2507fc56b47b4e6f65a6cee46ea2761b3568791da928b8597c73750d042c93bdff1ad7f3545e78fbec141dff34c3c5f9571513c763379c41fea1dd8e996656449e217f1f4e6504b600a09e2adc6b83d7ebdb37b0cce6b64bc3c7da2b42b359c596f32136ca11f2fe06c0e1ae677959d1cb9a866925f854eb9bdfe7f41b78ec51687f07fe4d85ace364b0cabf0f1d71527513fffe40dc043d764bb1e8852c8b3ed510af09087f131e386b5443689f7d6da581cd36806b0b7840e559bb6765b3aabcf6fb1d3680eb11e35931f9984e7386cc353fc6f5c7898717d0d14242a427f5658197cfec8347fd49bd2559a380792a8554e602947dca8e4430c0735695001f5059e110c286f32f293235e8794517d6e36804c66717c50f794898d612c3ecd1f3fb80b1547a676acb10fc73acd4d49e7e95c0ade6ab1116fe3dccfb99e056b1f442e7994e6d9c7a209f621c66dbc30f8bc3387ce74ecf7b540808bb45a2abdf5027663bb49d436420d3efdec740c0f70fd966046f2e4a8130050c104489bf1b002b67679bea6b0d09e2520bf9755e06b2bfd2ca148f2cff7c0ce2e060c2759f29f10b1bea458430616ffc7d0d145019959eafab5e2d11089c4baf1973b9fdf725e08dfe3ccae3a188f77f5f6f1099f61d30f517a0ad5df4eb0b9c809dce23694e795c5167e794ed1d552a3d64abd61fc28008557f711d0481b1cb9a6a50c9aa7aae85b8708613a4a3cc0c966fd80a8eb46dee242d2451c54859293a017fb44cf71cbc7f0a94116c2fd9f983f1d6c62b22da24e5bb23324152c4babc3525df94eb98f7ba61b7aadd9332f2f146b16ca2b3aa7bea86e7296a6bfc0a205218f8c802e588e4115dea7cde92d77f1c67b11bfe108e3dd3e1d52cc42e3aa91a542fc61dfce788b9920205eafa84b5cbc2d1e14cd0afc5aa5e2d22bd0bb79c0e6b04fa4eedd165a4103c5f1b4034682047a30290b3259bbb400f0f01dae1b8084a5766ba4c7f50ccb322013dc5e5352d39420df2294b1df971adff92433734b886490ba1b4c8c207b2a38323d78f7747ddfd37c0b287fa695a5bcbec08fc376bc4ab8b1731d751c3b59b00845df47cf0e0cf5275afdd17fb257b64711b346cf2663fd47a086957ad736b62e58539cf0bd32f231d5553419f60f68ce4f9d5e9ce82d0e5772e6af9f7c9f2cd96596512321fca6392629a60652f3e00af0f6b4fa3cb5d2ca90b78ebd70773280a4972ad367a86c69d7afabbb31d45cfd012669e97adca1f4ac15892fc70d3846dc03ef2df18c1be5c842783caad3ba22ce7fcaf8dd38fdb138a7834e3c515db4edb7a4d2c52fe4cd421347acf652876b4532bbee0621f6acc6c985e5c876896f24dd8170798bcb8d49aed17f6f58cad5a25ae3153e77abf6252713ec2261f5d6dce99b53cac5d1a485189f7977f5284075fc5fa7d1249a3028b994f7a456499b23de132d8fbc696502c30dc59bc1a6faf4b3a845817a26c746f712f344f2dad791b123c23fc36a13a7488192db253ce175daf2a730b3988f2a65b704a8246d30acb47dc9992a4dbf2ed1ece3e8145bd2b27c8e63ae3e6c9f4a980ba650f2f46abb9922b541efb0d5bdc86226688f3573b55651ca9e3ab388a36bb76ee2a3b45d0245c98376078a4eb7256216c154eef6ba60a8953a1ec2f6d60a57a98c43c2d00e74d988afdb15dcdcbd3ac884efbbe5709e538805b284828d521db5af37f9bac66c3f5013b55d7577ec48886bab333ed3ea2ec697d0adb87f7b70082fd1ed94afa69e12da42cb1105429f42cdb7fb9983fdbe5e939b4c1d9524f856076a3f751698d7e2b86b3613da296ca8bb36491a75263e994ec209a51559b34189a69870613b8c993b6202cff05b5e857855ab98293e8329a99db8fd1d501c7f15a9afc7d75c4f6c6109b565757c44378922d6d7548385ce91a943d741e695253278f684abc0371fba635aedc12964ed9ac200044d8bc49faabeac1fcef448675a3f6aefe69ae9f5a5bcc1a993bdb5d6fd493bf4ce59789eba25a3a0c4d39801f630749e11fc9dedbe583a9b9f0e1bb532c0a5240e1200ae6656df016262ba649bfdb6c081eabc91ab8ecfb5e8fe1328d242b016c93935dffd89f2a7107d1840cf7d3f871908db91b1c54c687ced42dd99256aa1c3842ca0c169233bf50eb984bb5d45ddc93e3726fe2b96f2b2b0dd9a16275dd69b9b2b27203d00689db3b88887a9968674ed3dcb2b044e9532bede7083071f690648109fd15c4fa466fa28fb12095488e3c3b352790b57549f07c6d1758a4aa2b0579b7954f138064f5aa921c8ab10778d8fea55e2817e25f13aca7fc22b238b0a0307eaf9f96f94c911374098bef7d4d6939164ad89453036f8920f793eb944374b3099f768cebd63ab6eb173064f38971c75a1da64b0e15c18eb1939b8d98e05ccdf9a61b6dbbd18bac19dd146f8c2d9822f988d2949144effe2179a7467c6ec36a01ad5f1b7187ae39afd8fa000a393942b483bbd1e1d297b14d76e5b2e216e0655826345aa8b44b7b540bb9fe46e479ece7dcd4a37ed3eec2719001f4034abe1872dbab1f4351b825698c386f40cc3a492a768bfc80f940443602e337fc7801ba941aa4e0d84b08c09d375a1b8735fce6fa45ce2f3337324d5650fd91b7acc3ebdd06aff20d0f493523e5991f64b8af9a15dd170b29927b828c78ac1382669f2bd49cad4aa8b5f360a79152bb97ea4c78463bcaf67ab580e5e738fb8d21ca9c52fc91aa7ab265271618c65cb6971783e0bbac564bcec003911be289b899b8206612168c5bd44b339e1f221b288ed6297f2ed5a3e9b8ac8c02951896b451663aab3c4e903acddc21d058c87586243dc475d6ff97d67db0c80f34a4f6342879e8669cce80e1b0c4a09e899e460a96af49fe7181cf23a5a93b9cda14ce39348e01ae0d992e555e4e4ad39707a44f7b360a6e3399f3adf656e423201f5dee671e74d0f09275d0b38d4c105781be59c32aa364dbed5775dd2a91315ce604219f3a015a74f97698be50712fc21bb6ae34f443ffa67b413bb2d88331266d17f5d9ca78976d6a1fa0ad6b80428758042080e31d2ecec1dd0fc329fdfb83feb7fbc4b389f1b95d6791ac232451f320392064800f0fb88c07ecfbe85759ecaadcb60ecdcdf3c35aa89daf2b68980ecc2629e846ce4a83bb7c047d75cb1e8fd3fbde347473ec8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
