<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba822a763d940099e4d7c93dc71f29a1f4cc73a5f8ba6619c17ef7d0d9dd17830ad115c60181d642237deff1e29608bd6a143220ad933e1af9c0ebc78d913ff85449ce5421b82fe7817a8bf83c9db22396483ed084710bafb6eb83fa5044b24dcbaaa4039e995467427a209dca8ba9dc0b576ee3d6b2d67494a17e725a5db5b4cddec55f6b1d0a1179e391dfef0b7e4d3865c23979df4ef37b2849bbd32aa1dbc36805e943afe43eb4a4ab48badab8d9a61e138596c9c98e3b578e468853c65e01535c154d71b8e03fcea5115ae52644dbaea535f9e253cedc03d8f966d9e8ff2be1182b55205d2cf7b2d9dad9259bebfef5e87dd503b34564f7f8b10ba420500a764ae5b30876c9530dd82290201f20f1247ee107bda3ea48defe6d5da5fa988fc623b69ed6cfd1429be7c0e786eb3604ad25c758a73d4369f8089399660d14da2b167e5797c3861226a9386bc9c277b5aef061def28b328bd661e4a621057ff0e85a885aa8b8afa1212fd436717939186ab3e82ac3eaec1a73d8e916cfbec637839cac64b3562cec656476668497fe9fde8a782302a582dd7f0c1c514026a2cbbd0e1e6f332b991e387b2780d2887067d83d7dfc62f1dff6d50ca820b638abf6a47b1487d3022aeeb61c283c0d60230a2c3305d90a468bcf4d1356fa4dd4de1868259610bfe42281b1ea7e2f0dc5a7f3c864d72e3b01980a74c92a45330d8744829fb58c450d33e1dfd2e99af6c957a43a400dd100457b179d9f79860850f9eca966c7cdeccd190ecebd2a3539cafd769302526b21b762d49e9ef7e208320063285324c0b8ad82762742daf823b67aa0a5e5fb8472cd534bacb08cda0db01130b15b5202fd5bbb409cd705506dd23348f4c64a95d56cf1e253adc702ad3607598acf28e3e65845e439f268fe924c1228f42d43c02074fe5b5a02c84bf02ed8b5e56d4da3a2438dab96b8ea755395aafd13fa5b20434267def806785a816b834a20870218fbe1de686a55ba7be74552e1497543f00b9ffdcb20dc0e67d5ffbe88945010b568fdd5030446b8b73ba4d6d66ed71f5053b0f38c820f4f99ffe357d5d3baa10c3162ed86572a69ec54c2be90bed934bc1638c0c9c614494d90bd1a14d90092211c78779265d7708912c0891f8effade35b001236942e7d9877883f24852ae285b5a4e698fd9a5384280a32b2a605e8784b5d06fce90d66d159076bf4ce049926bc27e81ba8aeecf34851e6c43c3ab73d890dba3e84420d2896373989b29bf1ac6860bf0f2c6ae5ac4701b1cad63f48c35e3454eca971c9031853233c02a97142ec6a4601d7dc33711817a01732fc92e0bca6acee8cdbc0fd11cf26ac68f27f301e2860277ecb49849cb5d3f4abc851a28ee2ddfa071ed683d03b2ace53e2356334fcc8e28961e3237bb1cb6137c1b135698c57a30a0e0558577db7c8477e190ca2c9cfdde0f9be308909f5627128cbd948a3cc54b43f20a790b9dbc24d81404696c827aab055eb09f3d79c411dd7bb30b824b0f174a5df28decb137b0c9439da0fd5769d968af018e26b9abd3d0811d82e6997d4eb5ba9da8dce3afdd77862e7899d03ec37ddc0d3109baa30ea497f32d013d18b620e92bc04b71e34c7f33bb5c07d34256cb58ea2f898a91f0cbd453c6e53c2f92780f1d7d21f62d7e9a239daa95e035fb5d168ee94809c746113dde98757398c7e907a65ca32ee1e2751180e1644dc6e8a8a306534926d5cf4e4db93e23dcdc224e92de7029a402b03f2ec7933a836d96770904ca6919128e9d394d7fea844094802902b7580535cc734874f6d0b213983f97a4de6f30cfa86a54940a3a970d9d3aa0f9f1569ecb9b10f3a7038768385a03b4380eff313dd9eadb5e3a4d1530674a41ddeeb46683f24d1c3995a5e5b65f2fccb8e7c65c9ec1625beb79b11855fe5ac0fe91fc368ff3226a302792df471a76e365c237d46ef5d8012cbd3a6cd6315651ff65516aeb95ace92bff888deecdfa320db09d38ad57e4aeb9a8cb7427fba463e9360d21c8fefc1222c1a580f03e0859ee0ab1452c19f893a2d24e3db1d7fac77ed05e64e523e899cee45ed8b3486151522c144f299539154e1c53e1d2972fe784683610e2edd587662cec82991c41e77149af6135b99a44f89e34adaf9bf27a55d2e302e9fcf584728c555a452cc30a2ffe3c4f87dad5d58d06f99908a874e65c61252ee305fd925bcfda1e6d15b21395e20318ef4c10486f77e9bd817f9665ef18f810ba07860aa569f06d5ef4751ccb6fc0b3a47c2fb09216152dfe876f39507c9673f313d9ecbe9679c39d86fd4a2d26470af6cceb1a8183dbb90a47de7eb58abb0084024fef068cf80935e1b927f194f91fb985446ba3851a27f18e05ccbf5d8db174173d6fcb54c6e88e90a24afaf559196740f1b6b4d11c25677523d46095fcf21dd99a72184bb0d72f85bf236621da8cf2cb0f462d957cc5b067759720d95d7759f4bed447b4f40ba9d4947b18428b6901fa591574b9a8d78fb9945ffa1b36a474b893534c704deb39982d25099ee906b353051b7e24f3b3e738fdae40f19c6f22941e06d57409f193ed9b2263eb0a7ecb80f024cdebca165d02e86b0fe42a135d82d4968c9827efb48c46abbf1a0df9412486fd9b437bc92da5f3a6a39a5deb4ab1d5bb0b8da6925984766ee5cbded8f750d7f3da2dc843dcac3cc508a59ebcac35c13721a4617a920b76127c549fb992a8845aa06ddd8badb0e618a854da2a88c57674b2e8ea53f0eb54a83a24341024a6c1ef5ff268f497c7080d039c9f15c5017c558a45dd905255478a775877c2efc6648e94ef8c3255381133348c3fcfe985612fafd8fc1a22e4f94d56f34429ebd949c647e503bd4749d62feb37756a65156010e5e0abb46060ea9bb4f205224db0d579ae8297bd9d0c54de38a1b7f4f937f984243b69add496ed39928b8ce21e0999e76079d8cf435c991ac2de334d8f9c909f62a2510a7685708d144b5f7372fb123b56d4e5ee2426d51d1fe96f2c0f9ec7074c6f67b353baccfbb772e6867cc8946065924d82bf8b8be50929f37a8c23c16fdc61402c27f01baba5805ecb98ccba80a905f2f913baab7d549db1aa800e6bf3d68930e14d6b3573b880098ef180bedbe2fe6e6a45988259e65b7a1efe87c4994c53e8dbed6d3800f9b3856e0b409ebb82020a728f51b6f58de19a280ed256b23703f3e6e713c703e09ec9d71ac4048aa3096ca0bc0fb3b7824ceab207064182fdcc8e8e4bac6fa6f694ec88ccd25ed5e1073afbddd5d5552cf0e0cf3347688fb954a27347f983d9b76190c8e5d2fe8af35f7a807f8f51df98da1094cb5bd252f8f5a5d4d47b3f29f3b83fb0bd9d2e6f8a591d0680ec5f03e6373be2f1e6615cc2d2ce73e38f69d8b908bdf95741f56cce81522b0bd84dd8ecf291efd97a04a9198c27fb999d61c0ae5ab64fe491253bb7c940fd2ea129c8d5eb2b87954adca00deb1150a5771471aee13932f6af0a0cf91c3a78c6688eca48c967184f9c8ef51f22a0aac1f8b97088d2f7ff953a7bbc75116de224b296ab40a5c7d65b2ec800f2cc19556fdefd517f1c8b52c4098fa5c5d7d1b5765d5775f247264f974a149ac5d5e3bae80aaa0f16b6dfc3935fae195c944825d8073b7be8020293b9e6a3b4261bcdb3c21560271330e95f8fee123d2df7e95dc8e620cfcd0c25b1489b27491af9e932fe75700fe15ef64d1d74ea3170d645f6d68954dd4a4a95f8844dc3b7be5f095468a1117953b05a1162ca7bec72e052ef372aeab6ec4094a8fd6c76e901bd52fd97836a7ccf9b7f1713d10516be1dae53241fec19d7f4b6910eba7c5bccf45b0d9df392fffe6c6ae50e16ceadc87c71ab2da71160e8dd860326d1feeb7cb7b3f04fdbd56d46a2b20205ef4334d0f38b59280e944043a9491605ab3dc6992d6755ccebde480a94d611739a3520a54d8a521b2ed01c3e64ff7869d8af1053a57b5323d1c3c40ff51d260adfc6c763108211b204cfae1343d3110d1c95f8cb7b3bdc42cdd84745a3fa0a14702c9b8c6ecf4bdfe3bff57be8e9014d903e7877eda44f049eb1f138b79ccc0d1d9ca1851528380ef37ed57be75a7132d24971d0f9b40fc7e25b10b954bd27f3bd9bd634388e840158990e9413865435c7f6f1f898ca65bc5857a41ca72c77f8f22f83b8287065ee8f94d8b7a08d65739119550d0670436296886a98b9f09d3127209f44254de80402380ab4535ba6631a96bf42c41fb1b0f65a9a694087084b2654704bfd2866220fe1ea01a737a980a49f0b083c96247695eb18991a01547b6e2470b07d0128abdb2e167bdd92326400a5b1d75b86d4a99554d57d51c9a55e4b589bb7eaf55290d04678d778864b742c469e556610ed99563da968263da6fe440fbc1834ce486381531e3fe07938058e9994b3c4156b4e21ae6aa13b366a048a30261ea9bfddfdffbf033ce2c901b0121c32be8072420be5ad61d14f16ebcfb6c9fb243499a263c0212d85bb880def19d63cf9794e59e9a8022e7f7a18ab0de080abcfbdc873653dfc467ad9f8f8f72567d1be4371ccd2c6d10c33c15cac00260832499a4f2c6e7d92c5fdeb3a90c3a391ef188a4ad027920c115dc8a64cf047ccd27167348c834d4441af0032c153d48675e2837ae3c7786ce9a006d9c99c08029906a001cad3eaa70985adecca889b44422fb2a5ec9e07c33592ea74305b79c60c195f9ba5bd266c312f3d23d641e3a7a2a5f252582f58d3bdcc55bc16abdab58c759261731648dd0ccf8520e5ee89088c75c94673ef1d32b4c86662c19cd5e4092ecd212b21957c3ab61fcf68bbc2350a8ac2b90555801a3135b722e981672f7d21760afc3b637dac8bfacc4e2ab03414a8da2b121c319990570bd4355fbefbe29defcc940ce9d3a811fc25b035f9e20ac88e8fb9af94e34f62252d13f0f8685097775d8bee5eed645fbbb624895a7aacf9db18c37889c5b844697e67928770528f8947a3c2b5da8a56ad3a819551b57397e9942d6cd82139b3e5d85363996363c04dfa07d27b6c2a3b5d7ad1efd564d2e0fb5d00f4a56e758a30e644c1fae5ffb5235b16f96b9883666d2ba6af0dd8abf3d67a6f81a8030a57bd6ea3f575898b21dc80d7e95b84931e2f0310f095df00accb1c3e5ecb6292c65997d0679ddd0e21484ef54bc691afc9b4e7684bf8e4118bd4dbdbea59aacfcea175fd7bf8a4fc0340ad577ab28c4613016339cb95c7f4ca449bae8975d84b4dc5ffd59d7b7e7610fbab42ebcc81176e6468ba9102ecca1c94bac51a1537fec2af215feb064f7f4d4011275e880b478cbb20670c8afb0e235c2cdf36a06f675f9ab612b296f765a45cc79f4e16cdbb38d9080291ae58076c729dc3076377a33cc5a630c6605e7c8ec93c0958c7d523fcf658063f2b45d6bd0d268420f06f6d76458252bb867907346224aa6d955e21effba922686efb07b5608552c1cec5fe24453613528020cc9a2960103dc0e228b80a0cba0c1e50263edd0b98bcd3f05e648cf5abc739fc342ff881dda0352dc9f77a0c66f0f85ea4afa8950f5379cbe38f49327e0cb6e82d600810370ff01d4c8f56bb661d24c98166f7216c297aee3f47a51d155aa88b3942256d43f7bac2f0ab7175b1dd766103bdc2782e0facc538a47deaeca44804c07e6ac0a884384874a3858637f1ad00ffcaeb17765231d821827930b6bd0defe7f2084b8c8a681d52f5e7e2b55190e04763553f8b044d59a2babc9d82923b5c05b0d6fe27765d0b88d11c60ef9737a314bec6b3894b928004eca49f46a22b5a85ea2ac3c0ead3c049bd0dd87eeabd8d38f031f5ff6b2c7635e2125b63f7feda582d7276acbeb9ebb888c895f408ce93cd9e1811d9e17a2ca2865ae94921a7bda0269bf94a3127a4c4f9100abd9ed44963f28e9285c12b28e5c79e69a4086c6520cfd33fd973b85844c90214c8939060d4f370654bd2c277939e5262bdb616df83a3cdcf47e4b334367822aee4c5ccaa6d5e13e580878ee7007abc245a726e393673ad49fc59684378def96891badf76231664d9b62e3f6e6f0d79626cfc75509ce62ac0e46827a4b1771fc32e8b028e6b1e0d5092d0ddfe172c8632190d374a9d9d626553f6a8d63a0adc2ce175b8b1f83e262dc9f48665416a862530b6827df6ad67e8e33f46028ffeeeddce8b53132d64f5688f71cd7ad1dc479d14c166e5f93c1d1bfda6137b0bee7f4dec85d2a3571fe175573f248c356e154682e878a4b5e4d52f4a4867b8307beda7e3b75a7d2e08b57e1f3db17a4b2b27963d18a54c0a0142c5ca5727d23bf1cabc56a311e4f4971044ac38c392118c8c9b05a74d230818d00618624a677e02b51de726b2d7e2abd2d480825842afa7704d83f4f1297a671a11f5b2d2756fbc4839b95d750795b168091ff36d4c6b627e8c4a06dc97ade22aa1c41277ab74aa4d0384728f434030cc0ae07842e775ceac4516d56908f9b6d0b51aa7d12068f5e96013bef4f1e2ae78b65f902899a74a544207310d5096c3c10452a23124c4cfc3fb3de79e1d51878bacf3e219e6ac9bf7f59ef4499fc37bfd0db53953964fb049f7892f1ef7b3386a0a05db0b30919c0766802b10e9d9c70ee7642975619be5e00ccde4c90bd9c61f5c87311d0ca5e6819d8c9ea752912fbaa2c20da31c91f673bfa3938e0bf38bf9dc916b12cec93ad9f5d5c7f187686a061ff6661861e7bfc05c22d63caac9425462d9bc1c559aa5a210940e7bf5be7e12691398990fed379a819be1e05dbf01820d27d657d882c4a1eff8475fb5705a72d4b4ace27ee63bb09653006d4c115f1eaf999d7d38aaf904aec053e39e76820c1b65ea552217a51c83e121cc741125d874e9ae5f9d168c127326e33514d4adaf720b12f663f22970129649fbca0758b1cacb15df79e083a66fd9d3709291a5369ee81d67da427611875027870b7361e848145777e97ae01b9ba0e94a7ed0f9f93cb6bc015c6b5130911599f928fd4838c08e50d2772042cb6aeab78ef4478fae73249655224cf7652036e078d4cbf436cc887a9e2c03e3ebb360861bb9e063ef4d7a273a062276b79f6e1dc83f881bebb96dfdcbf0a72995c3f14ea74e716b8805e14d6b4dc0a5e33ae6ca45a118062e9d6f68d2808681d0f7b2d76f98283c5894c46c2c1cfbfc86a82d34f410845fe07eea68f574f2b5923f807f4287f652bcfa4896de84bb87ca86f2804e5b84059f02150789945230662627bf12fe6cc206ffd59042e97694b0ab6d7c97f5b90da7d67e7648a686ba9475c3fda5818f8c5d98f0611493d7c1bac6f9b0aeedd327dcefa45f0626b362bea0ab8d4acc3a42b617dee0d498579c622a2a170c55d41ab8631348363c178214f84bf8ddcc319c2a2589e141218c53c6e838db6b0c34f312524bc843c5568b5776a1491e62a43c799ae0c5801740bbc60acbfd36d2c968f7afdd599e5a6ed57858bfccca0fd9f61fdf46926cd1ef95a244d71f11958a45559b5154ddec10577c64de04feb170f1eb0c67414719fb9eb1c3535b1ed1a14698e8c503d4206d816baa53be9195c22a611ef08882e32126a98f1e870a9df71b9df21255ea0e13720665ef9d3ffc3c341a361266b9afc4489009525daeb20682c4e7d08c0df6543186a15bfb2841990291437dc5a38c98ff8c348aa0a289265bfe961e4f6c56a8c05bdcc11aea9b6391aac27d40825d6c3f51fbee1339e37b9dd5041b4dcd96d0c0f09119754ea8e46a62284c840e29636ed39a8bd523243ca787f1c224d7409935229f5da96597c314c0db4660ab648a88bf437558a31571b7b11cadb38d1c9f942112883dbff77b537064aa85bbed4690c8bc9ab73ca5eb756d08a272e2fb166a8f6157fc6093c8b19b144e72297263c221b013c51f55adeb1e574bfcb87478212d6776030c27e6e42e53a594e65134ac9071b68b0bd75082f9186cbac91cc95c350ea283b99525c0328cf80c03d6ec6bbf96f4bfe315840fa580a9c5f4940583d6b909491788a54eca2192de11e05ebbfd610847529131ec28b7b9d7ee760554f716865f2e1d4f3dfff042ccd39e0e71cb4943d328e02c38f990fcfafefbe39c3ca1d80fe8966882831b0d8f245ceed9eb289a152a8e33fd1b6e7afd32a21397f9b9f085357f51c529cbfa73744f378a6ab2139de599e60fe0b4572c77cd5ae5cb6a3b9bff229f42578f6041344bc48386b05fdc426035a754c5b444250038de68cd0cdf3f441b1a931c725b65cbdd7d1fd5a837c366c3ad554212a79abde72928454ba03bcb0baa6c780a57f40932d7a407731d07d5b4988160f0e3cccfa67d1e8d17e7e25263ccca21408eb50c0c6ea55508412a1c1653fc15c1187f0901ded75108914b7f958aeb89800b3474206a6bb8ba279f21c020545c0b5577490985429580edf394375d5ac904fb14c4f4f2e8a4c995dec76654144b78ac8e7fbe29e7567f17021b4f3f1b6ad821e6fb6b32bea1abc51f3f0d85b3f97c1a110e44838d946d6d05b3cc4e05e5700942fd183850cb29467a7de4ef20dea6fd69145cedef42832dd8f0df90c215218cb9a96db7a94f5f27bc75b644778ef62770ecab6c64f9a59757a28e6bc1c5a9b28a021b7a8221a63150462374b8646246b76b9dcfbdb38b0c30767329de155c5f8a86b8e786746b6ccb384eb4be63a6675d9cef6bcf6a2dbe97d5a71508bfdb8ccf1c72693bdf7cf56b9eca8dc2485d6014efd79a01fe30cd571faf585b6903ece844213a56b89bb700e542d27dad447669a39bb3a3109c8474c0358a965770b13e56b68fa4494bc786736f2f4e09c91ea7eb853da6ec3a9a786be63b264f7576be5db6dc846b2124f7c7e03640e2ad340a4707c4b617f09c2ee5441e2a6507c30d9cf30edccfe3a86ab8f401640847618a70773430453f42492cbad480d2569a5fe3ec59f16bed5b1acf374ab6903dec9169177205710f943767edad26fcf86131bcac35a1664397a5c8607b3de8f91e0a3da185c64eac18495f487028682b59c90a649f41251c23332fb8e8f126db491c6b256b60c1d26a4ebb9239d147421eb904021a664a1992bc5e9abb8aa01b65c6507e62e0a6ff8719e729459be023290fa1a81529afd9f60764541770e7f69c46ed9d09a0e95ba24b3238da5c82bb3138ceaccb154ac76e6cb17f0b8025c4734dccd2b73887a3a25270cad3139647bf55fdc34cbb77a63cec0a5fc49a3e38df830cd3a4f9e630175568d8ec2bca92bee2e0745aa81188d0a6cde1f9d177e1fa2c8796aca9f243af2c65f9db70ae20b5926edd6a883b909a15e9579568058a18ea488721a24802d9816c18fdacceb4ce2496208446c8d4bfe0e3207ca0d003a1360986bef24d70feab4b540bfbba71b34fa27a20e3bbdb6f1a4382a0be9b4143a87f8f14407e05163e65903a6b6996b0f85179e8b10f7ce49f7742340e193cbd74e2dae5842532b17bf6befc925bba115a4645634255d999425e679047ac119cd7fb205dbef330af23abdf997c8991881e599bcdfa6f60205a5bbf8b51b2eff85de50519a7b52b0208abff11b6ebf2b5c63606120a5eef53741aa25f03e6aaa9e42941113a2be8dbdc81144f76441653305e6f747ad06856d897e5c43600037b86c4cb921675c9c12ccd0bae0e6c80c05c196fad0cbb8ed02312d37e014daceb9d1ff9dbb285b41bf2bbf7fa2a80cce1dc92f8ecd0a1497c0e2dafa118c5897da684114de30be389d7df84095b5180ffcf3ec9362142608c76c515d73f9077bef8de5879aea392bfa6924996fd4cfc718e8a4696a9778e55206d40805b704d7675ea1e834f4b9cb74b2512d9bcf717f2a6d4b113a7c3267854cfc0ada49b558dd3c4cef3de538e62800456fc4b89d6f05a8ab2b57aa39784dfe92cea80bbb9ce6d10cd189f4531461fa03cc44978be076c0081c97d1ab4f26269db7ebe010a2ab91461a5a8e6ea9474381bbc8404b2bc7b00741295bd9782d2646ff54b2f28054f03d648e49894c557a71d51fb1d600689ecbcace43b54dd7b184ae80fe6177b0a1f799a9d0ca83c1c5911a19b46390a864807756f755843b5313fd4db37fe2e20ba00c8c95db9eb213a678fa1976ae47ae56fa494e3b2ff4300a07428484a2cd88bfbbf601fbba0e9124e6078589ec454570f23eb346126e8574ab00c6650e3d1876678e966236b5ce91b5683f5be52d52460186aecc9252eb50a6228d4b9e9991804ffbc467ad5a65a8d4182d3e58cde4a5b0b351a8790bc4381fede8d7f8c32bc1603c575fb5b821a3fdd1f4ca51ac681be4c5280400bfb65cafcbb6d1838420b142d05afa8f1faa6c45891cade1e1d7a82b04f708855d294d92e7d7d7b687d506fba0bec6eb2aba4d820db2de48421ffdf9b71d5b5b00c8ea1bca1a5b21906dc6b629b12b0a6a9b30b601135cba60a5faebc8bdca1784d6f965874834e80f0cb053c5d99c1b77bbb3969ccaf14a8c017d0fead694c8381bd10e1ac74922ecadac45e7b2a7157f2864ae3b834def17f6d485ec86671d1342f4c6448589b0337e3c773042e118bf60ae31d4707d6c7633da977cf7de7a385c894e312725b5f6a7ec89cd2d7c177594defb78f852bc0e8492eceb5a3047e3bc4dcbc6f0141e40c626b04e41cac092713b759638254e890250912aa1b76e2c47c451e88c73e7b757afef661beab50508870206aaa7668060c20b383a0b98de02acb5b402f669ac9a44bb1d988a5bebd0487f57b8fab5eafc1375f56c2892f993bb4ba07eb0ff2bac159101e88ac4cd3272ec4a00e220a69823206f144398314b8bb2b1d79238a7d6b307f8e91c9f2bf39da79d40bcea1a12dad2aebcd4dabc9572770d074dcbaf38ebeee277f9db3026d355133ded9c328d08b6dca46f7d71596cea6a8844b9243a22061c3b7d5c78735ec1802783e3fee3e8d3083c7b27fabdd9fff24b8e7fabcdf0b8516a7c93bcaa17c22d3e5fdb54062dfd58882eafb7853e564626e35276b427eed5439c936c798ccee5634ce6b8976c5efa3da458723890d844e719e4a779fa29a967453bce528248e6957e3a3318600e01ea37c1c734920d72e24b7614da45fed0e74e4f1fde82e653ab5a9469e8da761022cc8cb96039bb07d8f6bb0199f42e85a2e393dde2c902aa43ecf30b7add5deed471bc020e62eee57716c129ddd0792eebab3a96e2e38fd4c6c75358b3dd075881512d7ac1c32718979f2560be3cf8d35e2614dc2f764e136a86a15bb1c62300bc677c86e22a25159e8aef86ccce93b1fb84619f5a634cc37fec68fec45683a9ad5cb05d2b12df4439f4533d06829c603d1a011ae78099b9ee4f70da7c6cc7cc6657fa8313801f33cfc156cdcc99c65e05d282b534d777a1b2b18209cdfa73afdd38c7aa41bd7e337c08b2f53cb3d915b6044fba9761db051de31997355042326d9362033241edf95e295dd9c530c375e803f80fc6aae4bc5339a857d50b65fdb64de675b07ea75ea86f622f0358982f155e87cdcf82ae39ee0b01f2b8b038a8cf1ef59f3493996cb8d6fc3eb4b1e3f6e1c93d683fcbaa98970caab70cc3ffaaa99b505d84928fb362c4f7ffc4a64f9073faeab51f2f653a2ad198cec9021364f5b9dff8bb34a25febdca25c8bd07fe06b3afc90da51b2b0ee70a252b47d8f752cb4f28a98d8ef70da6f05b4ef2a74f826a76c9f257514b65fa641f978309aeb5d141e68563e1994bbe6747e9eb625c76028a2fb7aa67d299066b62c897dcfbb6c3cd881e9f9f4b5a3b46b17a6d3882ae321b4700440ee0fab51fda524905771cb22d14e7d0ad3a3dd385864fb1f306e016e9d67ba21d583cddb45380ad15a90846d8b31fbd44af2bc608d89c4aacae68280ba6af088d0acd63626f6cee4cd82f86c3962708b746138ee2b4ac2a855eb4a7b2db67c85e5f4a2fb2a1028718793fe5b5f2ad8238e393807c1a7f88cb13733891d18707b72309b81e7c4fafc549011c7f4f38ac35919cb922d2fd058c612bbb6ac7477722044d021d4184b37da8675701988f504596f65f7d32e749dcb53c1ec5f5db9ff1545736711429c00768ef582f3b6b8402453d59098b130086a519554e4f3dba206c72982a6e91ded0aa290e5db7f2e81fad149f58bc5ae5423d4cbac1107322759f31d32a6f2e9279615acd01fccda73d2c09387b8bb9f00e6e335ab1d491e78b1e8439886a74bd3ab6d073f2221462bcfe59569019487224bb906221675acf6ab7058b4f19196a7b31a97cec0f8c8b43a8e53a3712d9d7ffe0497e9a4a3156d169b8e3bd78295458c310a3af8265dfd8889c4d92de2527596bb821a1f633a141bc13246ccffbf28e8a96b36b7ff345f6258ee61fc766b86606436ccba5f3862c3b28026209c3025358504369bdc050c056d0549c2acb1dd020208a08da60b91a711494b5d47b137c272ebeb3f794e07f84ab16b03160f5b8dfa9a01e3cc3b8affb353f1806ca58e762f914295985a435e4e183269770f9280f85aba3d1515708d09ac6e4331cf844e79b0b2354eb24530294b454d21913bc3aca962940458a20a416d7b79354f346f26fdb62c7efb6c6407e7d0505474f510c0e09d75f096a9dd8fe66a9bb80217eea9886826e743323ec2880659a943324c681587b33270522987d986c6e0254230479b106b5d9bfe598b99a5c5f9e4f02d86722220fab861a2c2ac62b643e0855cda7ac147be88d797f1cbb30dae9e106bdaab969fdf25c295f5366f00c43549b3625323e0778b30f79e1c4edfa455bd8c5a9bae5eb924c05e32fe83867feba23a670c868510b8604887b1c86bd2072f19e40ea8d3499e61210dfb8980c102a0b0c950c0be1b7347fd0298ae5740371c56950ee16076f1b4924c06fec26073d8e7a71df02195cbe2883383a127d580d746676e3470bc62c97363a989000cc61a9ec95464a554bb8e3803c86774c5aeda81b48188d783313218af1d7239cb9395e68ee0472ea7c8d55a55b7814a6fe2f29367c004f85f74b60462ab1c352b125549077c17075e40d142d0c449ef105976bcdc045cdcc3ac3d63f20b3856c5810ed95a18a048d862a966fd9e6dbf031cc11895bc485b9063b75ab94ce8962d71adb29c9aafcc71d50729151e383129b16020d9f347eacb082aa262f6ea955659e93ed8341c65d646bb49b036250ad28777a54529977246623e1ea1b9a10098bcbbbd26ab24a9704cd34e9d4f13affac5cea780a6668fc248d500b2a6a0d412eb252da34235d67623a77e01ef538bd0b0b5efcbeffc0c869d0b03f53543e3add0fcefd2c5140bc568e43f30498ccd2509441fd35070e13dbf02ecd6f1644a03c9ddc6ffcc9377a40109197a4435af57c8219b8c64ab74fb6cf3eb9b579eef9e074140cf690f3dea8fef42057711184e0b31271aaab0da510fb5c9aa66a2298902ed430c16c7d9693e81d6ac62090fcefccbaeed6bccc5f2b4be5d8acbba79d9358260a363a6bca8e7c51caf02ca4f1dbf700a5da578d25f6fc0d9ab1fbf42e0d2f0deece6893aa44c234aa3b79666667b4bb2f5e4dc97e14ff7bc00a8e86cecdebf34892bc9766936e341fdac97dff4b153d5f5f8b56335850a72c5b653bc59ab8860dbd35da090d8829db64466c6dbfc1b6d774270a0af223d462479d68651d6929afd2b8d956efbad677c852fdb0a96abe3249f1532eab6d1d212393db650c07086656ddcfb333ab9ffdd17b32780d86470e402d6d10015b8dc04e244ef015b310e8eb4f46929babdc79ef74efd85b72bd60ad9d7c1f63256e4f22aaf9dc2dd20b7a4341cff3e82e133364c46ec97c7167a7346cac32014f903882797ff11e97fbfeebddfe5ca47501b1d192ca42b1d41fdcd448eb7c6be08c8eadae70ded12e27814ba16ca19de1d6358dfed4335dd58e8286fc8abdea2d1d7c22696ed46a2022fe923bc347bb9cd8cd1dff7c716fceaa30bfec47bc3d32abbc35ff2017e0d53dd187773c0a10076571b92b33843fdf0779ed93742d629fd16fc641df7282f12a5a260581902af47fe5a93c61f14705608261b3ab7b50e4b0529e5f2c7af0a2506ba4d9805631e8fdc2f2924047c78b05092a691ae568ada4a52c5c17a9c8020e1b74df7bee06d2dc2082aedd73618769cb9e408d72a2eb87315760c4c07983983d31bb485122750e27e9f24f7baf214cf274efcdc3a81ae32c7556fea48b1d6681ffbda0d8e76b8d7bf9fa66a1d4d099dcbd63247d721cb6d65c780568b0ee331dabe7fcf6888795b05311721a731811f3abfe445ee3b71e4ceff61e58912922599c82929cb9faac879addf6f2925310cb13fba79b41931f2d4891bf803837323de332c80aa1db25c9149086101472bf4f0669480a742147edb0d962720ab1b9c6c3b503e742ed8702190286a4164d1912f8e94f4e9bdf26a871ab42cce24a03f703fb4eb6f0b17b309bb09fd9029be0f2afd1e8310fdf9076947c554ef974a09314696543cfa309b575892e43b18ed7f1116a8a9628867c28aaf8a1b0013d02a43610222d86a2b07b51286c8d24b2d1c4e0c214620f0ffb205186c992d5eb48234783c0de3ceb733941c78f85bea1f3de869ae674fd55f472724855d902d3994be5a606b4ccdbf451c87ec4fbd9890e6d99b5261a18e9fd74e82b9dbadc51b42007e65804e525a158e687ad0cbead6d7cbeef5b77159cac6d22a3203c5d602472b617fb2125bedbefc0895f5e8f357a5094f77230fb0248d31412b71d2ba29623a48a93a12e0f9a0d1b348e09678b71bcf7442859d62ffbd97fffc5928c160a84b19f6f05ca625a0c1c394db11cf746aba87ccf4104b37e22ac18707044c8ec62ba3d2a14ef615eba5582a04086c021abf0eefae4e8bc7071ad4836711a9d57b3090763866caef5bca8ad3fee1281bb4a3afa2630e4ff16efd209f780e4d51cb49c0ac1765197afa44487122da392c9bdbbaad50a5d8800c0a7147b7c057e83aa57a1a10817c56bcd43ba95f28408102c413e33a16c5937140b31d2be76a9a253f933cc7b783d816f0eca69116b5109a8b4569ee2f58895410fcfc636b7a8ab3f5c043e98bc3aad657e0e5f92befbaf906bf2f9cc54906e3dcde7bea0f4a6791cd834f6d2de69cd3c95133cc4f19e0fe21ef432fcbe6153b1c86a721db44a327f2071156df6f47c00ec473459d521574d94203a8297090e7d5b82a1cefe8b8cac996d184eea130854a5854d8957090b3378540e61b7c0711d07e1d622d54d5ecab39e054687ee9ad7adb51a88f93502f027d2ceddaf0cdb121441241148e37ad991a6d179fb7af1614568ee8bfdbfdb7e467d64a90816a4b2053994fb0277b4656e197f35539d4ac86211b0af8b298c8961c03d900619b6f2a034067c0b31d3b0a574ab5b0bc7ffd26ece3163b058fd457b311a3b6759a441a1081b7cc2fb979e5c57a97688449fed6fb855c6e067cd953b789f20bb0af38d7229641193fe13ba9733e001a11e3d83a14670056c585350545dd14c98fcd719af8503a7819161935aabe93fead02e1d7b9186244e2ceeae6c0093b63fd304919b9a9c3153b808d623b5f4ec5f54fef872408adfec6ee921882b991242304a100b17d36a072fdc7830e49091bbac6bf2a1f51977777b96f055dc9fc5ed7eb385a96869b47881290ae07cefd4e4a7a04e70ad4e14d019dd30da3bc22f2938a872029c7286de2fb1419dadf5872b1fb76eafcf5a85f25892053b5ba1a72262bb17520aeb848a29732f01bbc143e4f811a7ca73bf813285f9b72112a7b61b4e62eb02f200eccc568d47c9890a68a28f19b48ca36a409d365806fc969e31b1face0cc047a11826785e5f2a9c9d0fd6eb54703eda3f12f8b87773c24c71c31788a8614de10e035275076b4f00eabaead78bab303cd26d8f0f20a5be93bfa847097b71d17e2f8c53e89e49aa92ee31ee826f0956cec3d8959dfdbb050858a23aefb8804dd2b77af9c449b4b85815bb2a58221e36d8ed9e5c379b887ea02f8db9c1958f1fa51899e9f8d26e67b7ec98742f450739b3a5c171f42f1e6fd9a02a4c64a7792ce8e9b9d633c10151440c863462a0792e63d569dbd5eec59768b8738572336f5ef436e4e5c92a0e741907041180d4b721171220f94d7b25ba3957b2d561bf76f657f21ccdc20da423a4fb34c1ee8d7b499f6906d8ca43e8f5724869a0e01ee745bc99077edd08fa74f54667082340415ef70a394fc1c4ea189cb852a9688c393275caaed77ce6385cf5f27756fd60f817700322b78100149384223830c202d22c475e8a83ad3a8b1434c89160ca691055e3826f80a4b8e1d59c8328d6c48a4b9676c5957cca09bc97c7ef0ba92f8f9bfe11248572abdc0ad1efa473dc4ff78de5fea6799c144fd27881ea2480ee99ab751a5a4865565795cf77f9a8a0bac0de2dd2f6c4f0a823f963f0967d8868cfb1202d52b637457942825ad03fd11086a8bb46c3812300f9be36b79d0ddefe72b811dfae185e98a7e02db3b0de6ec15dea931b349ddf9e05a4ef08841b5165bb62b68be1670bd2630a886bf2f35961e339929807e1d97b8e58faba2e338e1875f1836b81076da51f8c0a3aa872ca3cfcec24dc9bbea14418a517ce9a93758b56a8dc7400cd1330bea28830a3437815a01de353f4052f391f825f7704d97262eeaeb69229307505c35aac19a5472c4ff34b6a0ed9033d4372e1d9b4bfe7f67111d1b147db86e8a8f8cd2015d59dc52fd47dedd9709ad4b54a6f88e47c51700e537bbd3093e1e0bd7092e30863d0efe486b6cbb5596b89206ad9b0dc7149ef1fd033aa8a154007d70de8153fbb961e4aea49633a470c285802a62a5b8293ed6daddc91bf3fffb117bc8bce3d975961c09cc226ec66874e6500d75c4f3fceb6d99e3655e56e4dd85399a7b2add211e2de445e6eab62509b5f3f31cff6414789de5b512240ac41d5d9569d5dba71fd8f5393c240baca3095222bdd2a39a2b01e5aaa2697a70eb632973004e58128d01284425b8426b629706f1c680aa34de57a5604d8d875a11bd525c912ddab57b94454d9037dfd41b04f27acf696f7acf8f64df2afc6894cb5d10a9a73e1e161b78a8a3f303da4127a6c4688e69aa1865f87e364cbe081c3686b833e9714fc38aeb88065138380d63a16540e705027e9e520a27e5cf26ed59adc3a1c76b560ed9c90e6ec42fea3c8dacb00211da9f8e45e9fff61332d687ebf4cf99652c1891e98f49162b14053dc39e6b481768fa81d3a20498ebd389c307ee7e722c828292936812475f7b1f83a0d8902eb10c579f9ebc430e8caf325e1f5be68d5ccac82bc81859516950cd01ffb1d88be133f53a23e64962539fc74302753b81ec8d24b806ac4c70cf221045c6b1e4c66a76f5de4f5a0dd510fd904f30d3466271a154f3f3e9d07d7077a007e3a5c514927c642ded1f49319766504041a0fc77bc676b49b397fd9bb6f76bd37ba7fb6b0e210a18a6649c0f110921e2c27f27b3ed76f8cdc70c05ce0e49396fbb07ca7e37bf42d61877c51784b01642219aaa1900a889c976d8e35c56224d15220ae4fd2fc93d33c7466eaeb6f4974e4cb7f55cefb320b5d50036c4bf5feca6caef2eef5b6eaa5aeef9d9bd38897967081adb59472eae762c6702c206cf7393b6a6b0a9018710b7409b7f455cde96a5a016838459467c7c6c05cba2cee78c5a285bffcfa1feac1354bdc7a1fb7e569c2186a40fe54e9b815c448568b818be450b79e21347aae5b4b83cccf594339329ea516fb3781593f25ba4dcad7573a8f3969e398b41b9b06b9247eb3613eca553c81f172a5c9c1105de23567d4ee1cce112d8a31fdb68f3a9cb259f12e6943e2b055b1b562985aeecb49d023114b9b73a7a4d4d4e0e7bf37edaab39ecc510473bc5e4aa9a2368633a330da9f99a5005e4374c95560df90d15eff6c539a3778940451ca0b97eb8e72218d5b198d0e8192a6d65940e0d87cb2ba57f8ea7d1cb694d52163e3e4f0e6266453130e9f2dd685d00f54a375deffceaf3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
