<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c2b6177bedd50447d7a8fe79f8439e2fbe0ba6c5740946a6c5ce5ff96b8a74aff9f27b844a04f9bab37c7eb702247c8fcc9d7148af386435db6abe65e1aeea682c95261b11aa58817a0fffd78847be48c2b521039367b4890a2d32275bc9423e47c5bb0822f4b4c4a67640b3cc1ad47f59937c6b7f586e15f3675d57f1f48bfcf6187e3575a51702372d647010358f46f96a5b9e9e78d30405d14c57942bb81504251c237036eabe27123f12497bc9ea5bf1382d1c9b404e1e303e8f13f9023253ebfb286b206e311b058b091c301664d80c596b6572db7a262d3dcb2c423031a58164be03eb1358b245a60059b99fd541408c1156195057297e034ecea00a51483affdac12b0acca09d48b6374d5e0b959394e1e583b59925e946c1fc594abd19f2abe56e380440ce74c7269c7b867ae7e56b9c3a1e0284b5ddbfd2d417c78f23a6e480d5292b8bb5f11bdd526de18aa1dc09134d76628408c56977f99e03ab4e10f7c74a56dddce3d4ae149e0b0d156b4389061952f3e526d12df283403e3528cb0487029a8bb4984614a657377b575b118c1f2053a1b6ef3be44457c9eb0d6a5edc1d40ab4aaa2c8d6520cb97601a158e270cbf068954b9bceefe769f6903c9195f58f59fca164897bfa0685e03be48c0293f102647ed43e900fb473ef8f2f2834bf106a92019ed4269decf5ba6cbde6d0b7aaf9aa5f22a7e5e1ccd4af7b9e18c6785bfa6cbded2a9ac084c6a122a4b5e5c36850bbe57fcaf616b865b3a4dea640f53262af2384f4344c41264817ba53d56733188ffbcdbae825c644ee896aa9fbe67cbe0fa1e97b7a9ab3d0ff0f3150993032b32a7850d517ca85ec1847f1ffa78809d7b2cea901e901e0bad4a8ff2d8fd156bc6658e605a5dca776d25bb7763db7cdafb7f07d6e545c309560b52d5812f7d2700659d24372a2fb19ee442cb6d8fb2375f1c4715543db9e75d609f29b6392dba2f3ced92f8365ae43a789c893e005bc68698d52a6c3176e56b9ce131c551fd285314e9a424f64479fa3ce985a928a252dcdbecff4454c45926f43effca0edb65d2d16850932751a2ef59105963e9ea2c87ad5f029500fba6ef8b39c3df832f6e60407bb45643d22a3316d3bf645d0e30759a78ead2f67435675a8ea20011fec443a535bcd923ddacd9e67f74abc7465bbbc794677bacbd26678ed22044bf21662dd5a811a38398ae43833b16523a4e4baad336d278a610f27a31c1b628794d3087a46cd1b163db2eb6fa30d77632fb855d4fb1a99d2dd0f4b10caae63775f1eac06423843c83733c6e3dfe5a3bd5c14c5957ed11281475425d24628ddeb3efb41058ce6111249fa235921ac27c06fd222af0748a6271240618894082d3ca82c219a7b5837a25df4a125e39ac1c3f26c263e21bee3b72b2d63449fc7ec7a45cf5822f3f12524f3b9f60f5c2528636e3f3175ff82c86477cb65c2b02b944537be41094378e9222a8b1db2c10075ddfb39af4222f5be4bddfa22a25783fb15fb9b60b4eea0ca2847801809226e27b84e5fa74a21683106f040da1f131708fb158597accee45625d6969e784713e8b420f205f65c00d5f26a11a6490553636493b569db857b558b8efc142c22e9d42f4c1c26821b6322659def723a27f459a5fdbab1690a3814882e655d352c95607d804a83a1d3f045dfe7b1ebfff9f197a9adef3e1ad5ed9372f20db5a5819e56d2b0e639c5d2099142c4c86bfddc42156d995d6b3fb0971cf60b5a5651a560dfd727a993cccb32f9265762e0c94475a1dd672563813ad0b4d79762ccf14365f80114136eb83aa4b0bc81f763b27b899aa23d52fca529b0572959ec6b64801d0187e9117e03ad547ca71b5f9dcbaf069fec4a5de2e3eec88163e32ba7736a498c0a7a7ec4aef4937e8d18030046686469091646774df95380120abba2987f6c773e4a1febca2175c26df4f54ea36e4c695c948979c0b6eaf6c3e10a38553e4f0eb0724f2f9df15cbe6a7f70906579cb71b480c3e235743689c792a9f8028a9a14b9e4786aa64745648f6cadef0f442637a686b30ff4163ac9a7367441dceb97eba91ebfb4943c1a7299dfe354d0a4d5c104b0daab911deb63748d1e9ff085cf3022f2fd2992c385664eb5955891413cc46aceb00ed7ecb629cb1a1f5e87da9368463e76537ab6e3de728920fad82e768050e022d4da6f000b342ecd36dd9d93f01c2730f02ad6ddee92dc2007fecda7448b8e5954945cca62d5fce4027bf2a46b7914ac295e0c19b986a5c9985fb665409f6fc6db955c254bb89d7cbb4a821b1ca40d328c59fd2d3ae4e4627f13d835de5075bc9ce9ad848f05b3afa07bcf21a8ea52681a26bdeedcdf284d02529a9bc21cfb329c7232f817085d49ba3f705c497256738d953a70206c039d9447c4098b764a3f0c5afbb7df34dcad3b696fc624e4514bef154f579c8b9fabcbd5b0f26eb4eb87bf8aac5f42e18e9f2a28c272f04cd3eeea4230441ec12e0ec21ab43e148e9a9dc2a01caf7216c0ba910b326c03f099a0e6d541fb203e709af12155039e7ecb86ef2963e761c9b2c03c6353bc3027b16066ca667fde7d18b1321cf500525e6f2ea96252def8a759e94b6f6401f9e705f7e69bd5f46aa17a0470afaf6968573066761e0501498ecd7a79c92e44f0e8c4bf252efbb351ecf60cae4e5fadc1bfbec48838c1956b0b4994bab5321883ade5958180392aeab3e741976c2e6d590502bfc4bd903a8b4eeade2e4eb9dfbdd5ac6bd0c603df739669964ae250aac8bf96c8bb93ac896e5949fdaaa8f19adfc203f13e31aba37bedc9c69be4592e1bf630934201c44739dd5c92cb9e6e5d19a6264d7d2616a786b5f212d68f87b305aa6cca659b525f8b9f983418ba9e2b7df9b1a09f11dece2cd9436b45cb08b50c420b1120bf1d9e0af42915d9b055cd0e97a2dda623b96aaf672fef0c4c4947952400d1fb5243349f1566f81c906dd0ffe4fb2cc0363f2b33a0aba1f9f2a3cc54c1590efadbfc36cd8187ed7b21cc6bc0d760f17cf0ce6659223cf688dfa17fbee5954a2ae12c1922a1c1ef4b4238e95683f4f91a01c484b73ba49228cee2f47ed064cf0dccac02e39a7bacf01829386113e001d52000e758dc43b7274609183f80100dd2c0609b92b2a4883d2ff3df80a9cef71d6ba4c60f0408665570ac8ca425ba8f8cbb962ed825d80cffb40a8d8f083be8986c755a8f0ee120a1f34a0b6ef4fd2ddec54de0c0ac8a625b8b48aa7c0682b218efa8efe6e52cd77924821b61e38d2b6d53cfd3a36e4e6f6694c54d8f71e21ea3a642fb636ecd68cac8a594d6cca5eee929d0b91b293a722e204f431a39b710ffff99be34abbc11585f893395f174b22db416fc501107dc1fb911644baebc62d44e54f98d68a31667009e94812d2264edefbf662f81447abdeff0959271e0fd8fd63a4d79211598355f5c2746c813377142834235ea739988a920e54dc7c4a5688915e9c8d0a905b1648ccced2f09ed662d610cd79b20dbd8c2ac0935ad76ca6d453ad649d15d0784a8eaed749e0e382f6f6ff414c070015f73c00d81f989a57a2c4e80cc52bdf1483b0709606ac44ad47c5550ce52ab40fcbd7a7bed4fecd606e286929e20090c9f6dc5b54b529fb5bf1cd16bfebe61ed23e9d453d5907ce6047ea3bba8e29233bb44e81f5772006403170b45ffa42d2b2ac4ac53857245f109427d243589c22d7bb80c39cbf82ff1ba5878f46aa44813b50c5a6cbe56b3f9620dfc5800b98e1ba4291dd0dd32f735aacea7d59a4fb45c5ad2484c10b83b70917126fed765156d7e44b53272db7047748eaa18cc3f840ca44b6b22f9da15d8fec423c16b1bb10a59932f665007a049a77fc21d2f5b937e8862c8465aa0914c8339c00063e513d022cc77349e8f8b54fbda5b93aba216a1618316a104c8bc8a82e99594b227b50fe9e29383b63751e6955c7f6dba5cc85b49a65945f90ff16e0876160cc29e342327a70711194b2744321d70a5a4133960126144a756c4a5b0ffd270353e7d2f00de15e0daab747ecb05eaad69395021516c8ada325ff251a565e59a026563d91612f5779a5360595973d438d192377855ee313d78fd0fcdb3654cc38cf9b24c13957d21ba7e709aed1c0054d22aec7dd41d5e1804fa7fadb77ea319755ea7ad1826e4a1d7e840d2bdd965c3069b043b602c91a3d474f3ccad739ad7a0119dc4d26110da76f188719f915a3285a3b210b8c6cc617626023d6a7c2ee1d1e54f941fd39fa50e27f13dad6a40309f7f5fb891bbaff8eec674eb1642e90c28395fa94fda49ecd7e4b5cc701f8ea4489ea66557b0fff8e1da5896c09b1a1b399c28d6a6799b83bc44284455b80aabec05eeac74408970d72709d9c94a678e630c74450ac41b4e8783628a4e3d3e6d34877641d29355456d61ef74c24f96c2aefd4a29667fa851e46752ed6838ee37ab19825db60c1ba3e881ba4dbe34b628f6579147144bccf56ca57bee894e4c25b41b647cf66441357da5e6b711b202143312ee2d2304fdeb2210f46e0d191dbf6be5643f31acf352d92dd352f9cd7f94ef56cdc05113b5879a1c4c70082b8423496cbde02812a30c9132aebcb8f11be8cbdf6a66b36252d05cdd1d47b9f30372a54551431a34073acebce7ce3f79bdb02591333966e8824823249c568275de5a46a40880d08cd21e1cdc3559fea1ad56eb655ea81fe668a6f5510bdf6c4aeb7052594cb5c7fa645dac6a62947bba3e384fccbde97400a150ee1d3f322b83fe730f174eca05f294c941253b68ae4d78b8c0d4b769b24feddd0c2b204106548d7553c488bb7dd30dfdf88b9b3c3795e4267b935e7dcdfbdd16cf8f00feb830e0f85eed5498b6751e29d7c37305de13b6030cc825004d09bec085a717dd5b6459388cb459546f4cc6417789cf746532c53081512ff7b65380a06703c3b3bf815268aec5941edbd060ad6bfff8c9bb10d38356c468d7835369df2911dccd40e75f87dce4c4027749de0a060d702fad56db9230e1aad95258ee750922490e69fd22039564d6d626cce82f3d8933ca58a45e31761c75869402928088243492f59736bb9d8e307df6f164e96f7276b7496f093eb7ff198c6b72bc67a5adfb0e046a2413e0cab1e7d66212383d791010d4e25fbaeae9e0834288bf9673cd122e7ca73b76fab032dc1ec839c2b0aafa3fbd4909a566a2d7499367adf38d4dd144c46ecf704cf9f411de692c40bb97597e8a308ff3a9775d45671d6555d49369de49d1d3f1f22b3aa5081aaa6df76e77bf18cf734a0ec2df44c3da9a5aa80b6c8263389de991f4e10ba9a05853e22ec98776d699c72646185c38a81c5a3bb62459638736e01ba473c28665a92da8ae02f796e8133d37b5b6881e25aa0e1d893c4aee04b0e748f5c3bda779e3ce2e6bb3f833629764edfd3be521710a5c8ce92cf6130f132a15280b8c15692bfcd560d453b7426fdc1bae17c4e5b27e440c62bd509cad7a44f67d36e37aa4d161798faf06782c8c407df74597ed9eb682a612fb24baa73b13274d06e721112eece34e7b625c9525159db01889e8edad3ee153a2a4784497dfd2b8abba1240f09aa3b195039afcce22712f8c5a8496b4468c2dba9ec116e05b4d02eaa23863ff1cc77e4766f919c230f732ca02826167dfb63228604b5843a883de8f0487bf26fac27a085cac36f5d9175fb44759e53423cd771afef16410b4c973903e09d7820e4de837cd2627ca0383006d30e5a68358a2d819b804aa2a5bede9e83c4f9ad78003adc54d833ce45868c33df8dd0b93c9065114dadce6a2601ddec15020a2d815cc585e63e783af034e25e954c9591aeebe6411423130d5ef7b37d8cc74967030bb12d8f1a8680f4bab682b97073a5d65aea4885a3203b838e3d332f32651fce67ac9f013ec00604a30ff2ea9e3a453151ca79778f6400521960393cd8f94461466f20953e01cee94c2ef86cd7766197cfa8dcab9929a855536decedd9071f9127238081816259b126f6e18f269604a5499e870ff3121b1697e62980ff5d893ec71d793f68d012766c914480bff7db2482478555789e33e01c9f8ab8146a0b1fa0a1635cc210ef36c449737845f0e86bb8f9ee24b6e196382058f5ecf7dd95f461741569040f20bd79aeaeaa3b181321a05f84eb6f262035f31254443fd18bca7fabf775b0abac6fd75fd4697437abdeab87193bf2eb1c40f74f9de61406a4d3efb471df9d0a8e51b710712b838472c97d2af15d7788305b7da20d4399aba9ff9f3dc6faf6e73e3b5424a8c17e9add907e38ddb5936d5238916bbeb912c72644ddc94214969d01680638da73c4edf2784eaf4a3198be4edc4149a07682849af472bef8eb83fbcd2b99d9655a6909103d1f1f471ab0fb4388433862957693455d782ed80ee75b2ceec7b17f279e8ec99fc04ba6103939c8e5303f698921073a75060d84cc7701eacd0fcbb3757e4dd6376139bc8e40caa131bfe1961443240821b44b9df14bcdbdba372a1d69f334d66ba55bb56f2a6939093ca3394c62df92670b9c337f3b6274701ab9738d3882948f1e4ea7a40885fe880581edaad160515019d0aa9c8da93dcad327418fd7713d0ee628dd2b763beb9829861d8939cfdec8fad51d30da0a06f35070c195d02db0e28f439f3bbb007568239fcf287b9a3bec1de831f261fcd57a9e1c1c9870c7b08d363bd99a57b8e85f3ba673291fd87c509d5b1bd6a296ebbb9b32cf873f4ebf86c9d44e0ef65f104682737f2c7a93bd50e7c97321e511cbe7319e1a3ab208deacc73888bca1d4915126c871c9634e39ca6b80c15348f681787245c01eb6e5740e308cb27a6afaa54e57859ead2c0cfe29bac5466c8e9f7f950e845069992c287c45a48c87997f86c191da053b380d3a1f2510bf5a2b49552f2f8d5e4b7f5c232d51bf422acbb65fff658ca3f6535372cf261ab0b1111d93acb64aea9bece0d2ef166045581d39b97cfe3a2e0dca949c4240728cdd7c367b02b0c1bca879e517b566dd4fe2455abc63682b124054000f374ac67ce83a9b0d046cd82f699879367f05456d755d70cb61473d342ed9b3f111ef852a457fae627d3d1387f0cf268d074649982d60a3724a7a3af64a1865239108137af03dab291fa11ac2020b48219cc7c8ce06efdd798861d04dd076c538515abe82c05349eea99ff369aad1797837b8d02d9b3c6b05695bd56cc81b7337659f8f28a329a56905b34248270f3e6db923a95aa6fe44eb5de406a7053296b0c7ebfba3adb409a5ca9e83a13448f3facf25dc27107c6d9430f56becd93e0f67d5a192da80af0cfacdd4e3da61441e2d7b6ba652c9262b22d089646b28e5e58bc6bcc4f42edbb5a794773355c26956e35139d71a2ddbd4c954a842fb721b3ba24198e6b65a15ba6f1ef39ca17e43c57b207e9ea50a17848a27afa639478ff89830cfa35894462c07726c4972238832fb38b56fdea396626c8ff6fb9c1aedb0f685f9fe5e54e0315383e1d9e1ea310d2feab9b6af25b9d2cacbbf167c1e5e635fd479ef6f6fa5067a37209971f2f1bbdd7a99cff048f6631faef7c4b59eb34d7c3dce5440dcc52da018c1ee22be80c3c66639a7cb34046d7d01945e6a9336f1c9fc47b71447a218d0d0b0c9a70ff4f0d624548d792f436a26ee336bca20a8ff012df88ba8ef9c81c4fb0c8f259ef66e4ae7a2e2e2bcdcf6aca55cf488e27c50f29a50843efece2c2ecdab08f0b6ded53c55cc408b923c1c2e91d5773decf33aa2c0da903343a6c4099cd68fa508b4529023707af0b74afea920df4a75932234971444fa7c8a5eb3ea81ecce71b129cc1e78340cdfd0675231e804c1ab1c02f909ece36ed8d9312e798909300a2321975c2fe98b346ccece357ee74a76f3f6fb7ca460ca7447d15b7865a673f9e33c16fa84ae6be223429ca8b9417d7b3b8a162335f034182a4ae3fb078b3c1e1da61b50c570386b5f01cdb5a32babcc0ec5fa9f4053a745ca016f6812a859895bc302e0d8bff8482f8d46a6ae4924728baee5562cfddb7a8769560411c074cd8ef3acff1612bd4519e962392ff1c1eb40cb8d7f7ab0f8655193f138a96319cc827937f10f1c8ab7024992c0afb9a62847956a4c4b97004b0790ed8b0b95bcd7b7ccb8c6751cc4f48e7e97c93edddf0a74f88e9a3f93589eb3bb1c76fa35a3ee1e5918605315b52786793da9be7ce5fa7c62367571d6a9cfedb64db23e97fbab98d9456c6699ca6c9406748ab28cf0566eae3cf6450879e0bf5f9eb1957c486c28f280bd76b5c923e3a6820530cd845eea7a6f35e5c01eedb9d5ca63a3cd26067ee1d953bc88846e26efdf96e5756db626c654e0e0b27f336d7730ebb7a9b728412b6056b9e991eb29bd34bda9a33b3e4a492187965e994419d7feaa2827919359100f68147b835736f370737d2e09d9cc6ed31be611bd9e787a99f3e41a249ca3bb8462c21960fe463e2de7e82034463c64d21a5c016b09b1818074ed45e30f58f4ac85f6075cc15adfed8e2f5d8c1187f46841a22c4b8fae52e730ab5531fd00d1a256bf6299a98d075fb14f2d5bc1c962e9270cf3aedc597f54780f2bfa69dd683a80a0549026ea6b9c2fa090e4c7e4466eb3231b3a6d8681836271ba83024f3c9c3e80704cde91f479ff2300d02baa6299d00f588687eccb869985671c3e4db0ca52af9ce568f47a5e3a4cd70c6927aa19f8fcedf4ecd6d166399acd6826b5f6d4e3ac1ae5e01f4126fc9d572a6b65be3bf82a0cea86c5ed1b6fe93368bb2acf49f2d53f296ccddb10dfe16ee95c8395cb257d4096ac0a4172371c9e96d3f004c384bc57a12b4013c4e94af30203df1afc87d9a141a34098b784a9e0ca73dc87480126c8b0716e97c341366d2e327d5c1afd56ce02f25cf54051f6e52f83e34589a1219ca3064979376b9385e72584f3c7ec7fe57cb4a51798213167ac6678a9e66f99513cf62bcffdd46c0e3e0ea709e3b53ff484ef8da14417f934d39890ed8235b99d552a903d723e89b015bd8ee55c41cf12892d357de2d55749f200b1caf911782e03996155c4a7df5b1620bc511093bb8fbc5c33cbf4cab3eb2b1e6593ca1f917ff90907290f41c45d13aa5cb20ec7d327cf14c2a799a6bc7fb77f062739cb589c37b3d8478e591aa2b9e72e83fcf299399a6b5510a7e03c061d36e0498b9dfb54b9b3a0b26f9e96110142720c1cb2da762b907e21a9bd72060fa10154145013319a023d815a54f26624a16ac8e2ae7176727218e4eaef6f278ed8158621656d7d9749904299cb0d3bce511aafd71c51cf894f9eed6d6c74cc5d6d9d5c6d2a2df5328ac555696458bbf13f2881f3cb12e21eebf5e0d0bf553e652eb0c5a0724e2127dcef270a12a8bee276e0eefd423d94ecaf8e867afc1cb636735da6803da01e76f777cdbf2fec31574e924d0a4ea8f825b6ef875b4ab2a4279d80097e7fc674c1ffd5473ddeb3dd1c677e5d3de79f2ffb93b9e0a5eaac43717c41cb18ba5aea05adc5d094820e6877374f13427e0ccc14dec5ee2caabcb5b4bbe616549ccecc5ac695b9569db0da52ac3ee14b740b89db2ebcaf04cd4d607d8c24ad9cb2f4c7e733928a891e03db4fffbfe022f23ea6c6062256eeffa36972e7e7a59134d2a8310a3d7895f7319715612359aff7a5ebf56bf6a781d18fb5287e164dcec90c6e419ed6416ea4d6d40e5e2d7cc4a4e3eeb1246c466350d7abd77c1cfdc999dcf08bbd73f747b503657f575511c4aaaccad05b406866564768e37737171f6e3e2fe1455fd88ab2750c32e3b9eeaacf1052a4b828d6bdbf9fda89a7731f6a6005dfb932da1fdc80bdda75fcf252669e3a618c9cbbf72fde37276f781bc81563e69aa83396c152d888d3e24b058c2a19ad18346db76e61c86aee275fcce9db305cb1482100f60c11186330dd2ebc8c900cd26743b21167be1e3633259ebd03ae0913781a06e3b96bbb8624343cc3048215038d4c3d433af156d3dd26ebff6eb88f3ac6c4577b52397925ed0cc593666e11d5f025ad6c37bd4d5eeff6772855c13dc834d57104bb205f1e4cd54cf2b7a282ddc528e99244289e55512d57c4239f305a5c26fe5317d396a19eea793dfae987c66e72afdc5d8aa61a67e6b5ee7b317755a6616b8ca83ebc4a252958aad18fafa77bd2c6eae7d12df56d8da7972dfc474942c852429ae9897cebda43e9cd5d5e684cfeeb0ae1533c7f475378ed6e4684caaa390f6d02015ab330e11a5d9187405cfcf2878912aec8aea6034c7a2439264337b4836e343ba88cfcb0cf12bdb88ca215640cee720bf58c84eb4cc26bc94d86c61f5436dd951cf96bd64f2cd5afe282cb24d90c1d7eb3683f02b901ef8ee6bf24d14da41bd1272abb8a6ec825823d61c96e77e281b52703966193a0636bd1492bb163632712dbee9daaa47e4af6597fe0e7413afabde8befb76b81407b69d4426b26fe5e0ce9ffbf4809c3a40f022371aab0596f4e9f04814d33c84452a50836b077e047bad2496ea10da6a77847e13220080a76851809b399fe4f2e8bb94040f96fd6f80bfad7108be26775f20f4abe8464d1860c2903621db934b0631870e00de63d33d9b83de2f2a91098c1726012e96e48630599d8b0799886591466491522319bc80f21acfbc4d21e037fce3f0778cfbae5e990399396ad89053a4ef5209f6aa6b70687810433e38188424b4cf5929d93407a2428f5c9109d0dd78fd50c39352b8d0baddede2ec0ffddbc559b7f096f2e88c101722576ee29f4b72329780dd36af0209dd997c91bfa39c3892653b6239e5133e5c57ef7249ae770caf37b6063d9dce967df6a6f49301d0557e3a3b15410273a193eb294b3e84e4e30f8f80c687b2ecc689a73145f227e53024dc1931061c059836795a8b9f48cf63afe33fc112802e2ce48a3a19cbe7913793dfddf926a4f90762ab6cb2368f9576af3e462d2867d32f1ef4d675ae17109780a6e6a0f766b17e50f80a2b5ffd2adb011a66825e2df72e9e15d818ae0adcbf2e1ebf7f7db08c5a28322a3687009b32c57f08a1e20989f67c80d187235af20b8a0fe2943e2c075928976a922618d4cace0ddfa68836b98289749013212b6bed44a83259bbef1ebb57dfe0693b12984195ff5a2acc14220eefe1785cf4fcefcce30179e27b5355be2798944fd1237df213958924449ec3adf82d8ca6e1cd86a0ff9aaa337ad5a9439aedb1ebf6d6011b2301f4513567f92db5aa09bc1654a5fc016d944aeddeb0ef7365bd6be841623c024e34ebd55ed4a79ce442a996fb1e28d1aafe46f24d7563ae34ae7e59923832e5340bd99fc8bc6dfe5219ca34e109ec05bbf34a77094a9c2429c377f110678b1b6c592c08c392e186196b408b57811a4c4bbc10f4c29822ec78b40de2d5700fb53f62390b685b725f300586367832491ab3612cdf1b8397acdbdcbc7800a64c1d518d89346f6458a9eb336d790aa0eda3eb204e7b5800444a8a4600eae3be6fdff9c3e0185f7e8269207d99ce66c0d6faa10295b75a65a350593f73b5765be8d51ddec4d4a3f9f226d72439f9d76ad3e35d4a7e1b811a230147a3cb2772f045778bbcbe8b8ec73f9cd1c6235a6199532419c38d11d92d0c05366974ec3e7e556d1c5517fd88983eae32866f32cd008277c8de63646b2fcdb5e871fb078ac5b58d958019dc7e0cb09a639d7982f80867146570ff81b322f6c1abea3d3a553830b275446c899cd0b27b8d70b45ba7aa4eecde1e605758d1d69c373b1a17a82a18244a840829220a8d1c8807fc93a1df67a3dadd334378241779e5bd3e829ee89f34a75241eca6a13ac5c5c4f83400a6d504a61802c056ab1c2a6071f1ef47eed579c4b801133a4512010603e80c47f39173c9370ad50d928ea4cc028b84117a6b7b9a3b8a0569390bffa87558d9302fc9a11d0b70dad29250dbed46758fdde7cf6651dc1fb9f6c91c95ea4c2446a5c375bbbfc48602811800b66bf89923c9d9ee32b9b0ee1c4c1eceeb184620e5806b01404e614d5eb8bde49c4ca4e4fdc0c94567de6d25c2bfe61e015df00f3b4b3ec4c6e8c6e4b550c6ac89d5442ec3f3931cd52484a2e12ba6c63db06b3cb0c8fe1b0c97c441397bd170acb1a9e404e95a6443701775a350212074a4ca344821b94926573737effe2692fe3ed3c440a7e2fd00a04ec8456d09f7d67b4f47cd12642e456f5533aee6a0fda19afdd48bcc13ffced71931dd5b71448f0a586f0778298a7a64cb1ff9b90f838574cf6dff1c0e97eb702f4fa43bc4d5ad1a841fbe30436cbc66e58944b3e2587186d990dbc43f6a39766300c353d495a1d092c2432e4e94554351aef954a4dd9645f03689c0320734bca080d03e9e4395c10cad43dc242cff927e2fc82b34cb3c60183a2ec8701de262e95df9a82ad59abeabaede6624a519b771280fbfacc972262a2ca852c893e1ae2be9bd7ff0dbb4273afe083b03ed07b92ca64980ca6cc5929164e955f3d834f3bb86b2db9598f7752fa7b1d20b6b2899f7b3156f877b8d8454854f62195a102d541eedee93bcccd557f839bb76f6933cd8f8d75a60a3d63255807fb2655c694cf625d9141c23e3fe9f4a7aabac417032a1c83061a3169104480d34eae722236f36c871ae6ce0172b2ca3cb78f923f25589f094852bfbdd6a3c400a5990b1bb4ce61084042389b857e7b8e8d6017e726e5b0405ae05d4cdd1a5807db567c40291c11ffc37f41d49792e575f9d7b7055f440bef0f879b42ff293f24987d2d65675054c92be803b77182833047226bbfe86c4af6c2886e89d6597a96236f594eb486744a366f333f68e5cd1caca8fbae236758824c0a7960094294a27795194e2f66cb13a9a0d70f20638946c1e85a4364bd4672a381150e444f7f64d16e599c97131fcd2dfbaee7a046177271a109fce2ea819bc288aa5591894b9c937241bb6ebca5650d5d2bcb2dfd11248ecc1384d64c35cbc6722f15ded882d86dab66645c041ec43bb28a86d9f60bf740b6949759c6402bbc82d222d72753b6ff383a50eade4eead98f0597984a2d08cb38a395aba8c22e364173d323beef9bec8a51d6cf725d8d840edb7d7fe3e4dedb7e580980349ff7ab14712f7f0868fdcb6ebb38f3f8ce1d16f2f5a1e7b8b4848701b9f100e4108eb2962a527293752a5317614a6dd991137b0193e92014d96f5695be237f4b1361350ab1e3a4227bc82134fa89b8a31cb54b778f8dd07f0de135c2c95368192f35e5598c80018928b321bce1403e3a85c230c404e443f859be12efd8fd67fe8e0cf516c1b08fa9e001badfbbc45dd5c178cbfae256c71cfcd1c9477229c688ce43a3efbf70d9536171ebaa078de46f4ebcb3ab35a8c87b7efb26c1d4ecb2fda0d508e6f49a18476e4f9676fee4e5fc2ebad5fb5cb48ca3617d84fd053fa4f4734358fc8d27dd14fab5c8f25b4b9469ae682ab1279dd8b3b126c509d1a2019eef6301132d3a35fee4b47dc61e51e733d204cb8b2e6779ebbe62b06220c285fa8d5dca3def58296550afc5affefab056e37cd8a4021c8be6e724174a10a29c57e0181e72a25f1988157209815625db485866a95f467b4ddf5f487817e5919ef3ed8f1986bdd57ef9e5a34dd76eac7347e2ee8e7ee9c178b41300fa7ddd660a2a924f15718fc499656db746bfd67996048a50d993d6e4ed948bd644e42520ed4a8ccbd0cf1f3b4b1e1c14ccd0cd73a491ab9203b6990960443a2697a11cbe523f1a39be510ea3454d6351d4fa3eb9c5ed09cddccdd942f4225de17b9938dc3922bbb430503e0e187e3ac55637fa41e77664583f21b978af085694b3389689e9f39bb7dc55d66d95368d87bf6424997c0f2d411fcf383525ad89b8f62641a684dd086e62d7acd9e41d2e822a99b1a8ffb450515ae4b772f8d289a479e6619105aa7756624461b9ee2077c38172692268777fcd1520a03d3c9baca46ac414a2741e045065512fc051f307cb381a8f987a43eb6ebb45a34754b5c36816840d0f762ac05a021d31b2671b05cf86c62f2479870cffe0bf7306a0f16bcc73f9ff9292a0cba585fbcda6df2b67a63155726169e5ed7f1ab65315aaee7cace6c329e1a697ab7a4ecbff98a1e6fd65b6bf8630589ca8d1c5542a929808472d2b0262e200c99c41a927f6364ce7bea42c39a97d26d786a4993b5f36edce816316a44f97ea19f5246d35c125864d1c4d7d09ccc2a779e1131018e3653710015a9b22a76692da464895cb7fc2b08d67a9a9c98397af7d26ed6d7fee39d361383acc94071448238947bf92ff51a948db8eaf3aabc8d5f5e330729648975aa227de1464f9eeead325d85c574fef519c2152316b734bd88a2c8de4ed3d811d33a0a00bf0adfb2252ba3cca180fa3cad1c8ba055b8c235b11c5e839b9d7813e41d222a0d86d21bdca660733e09bd446ed1c43e516131e51e642020c6a9e486045e09c1c22b05631e553dd128bf2329dc72199830d0ead64ea45548b2e250e0059cef1eb7f2a59785423aa97441cff06b63b6ac001200a08c8142bad5ed4a7302192582c9bb7ae0c36e844906dab77f4041a452fb81a8685289d0c68663ca3900d1f9620dab4f65a6f7753320da1195f30bd7bc9df0aa233addefcc0291eea7f3a8b0df53379b3cfe2b22f88e4fcd5a34e56454b0c0581bde593dfa8cbc1d0207de14cf11be8034ca8191b6dc0d58fdd8c48ba19179e6246e9c98938021d041e33dee73dd2924bef59e962912272ce045b896317a723a68452d1647a1f40bab96bb57194e6e82f905d6f0ad11a7256213760cb727787701e7a00492cae91c13e58ede83385ced0dd83edadff91aeac74d414a69a4cb4a05140815ccfb1258493ccfc11a48816a6e150049cd142eea8d8a6c728a49b7ac47b9b506b22383ab0553a0dd249da29e460421db33354628ccc1ff9ed7bcda703a9118b51357052325c3775ca72970f07500096c5e4ebfb5623bbbd273fea87fb2eafc9d61324d0866bb1457b515d42638d5b0aacd309e325f038059a6e352732b64eedcf424930fe4a3b36182ea8eba7a43f16efcef5a89992dc4beafeed79023e9c0f1fd725e9c648532b0ce07ecfc42cab78023cb741b660e85f0c0a270e5c46e8fbc7acaad7a6621bc3eecf03c35fae55dc46a25c30cc1c555dc70c4995a6da19e68f433c9e1de7df5642a2a1edb3699c56d2864670b366625dd8f17b4f143cfdf7007b1813818a7cc986696e325bac2903cc2c4eab9b1a61348bd0cf8bebec503365df58272c67469975e9c59d4189fe17605be539eb9f4ec219589fa2a4de18594f20d68135bf4303dd957d592b852e5d01c80bfa64c20356b07b87f44a4f973eda6584c51bd980af2c702fcccbe3c8fd4949bc0bcf71f41ead030f239b1304d7cafe043558783288b69ee907906bf2cdf9f88065140f96291170124b64caa2cb769906d399c51d8f20bd5f9f8748fa8d3e6ff1c17e65a1bb68bb74acb30b34cc74c58c551fe398c339de43a8268a095a3fa68659acf1ec3f9e75021884b1323a9fdce4714461a15afbf2e90c72f2d4f99d7616d400ec963e004fef62ec7d918bf2e1399dcb39c6f71315c3a7d76893c9494346126d0d0d5fcefdce5cc8bc7140876878d19aaebdf3d753422da4b8bf400c4c46947316860b403edc0434e899b4d30f0e5c424c3bfeb0fcd0bb960096a25fcbd41e9fd38c2f792794dc45d90bb640e0a2cd46caac6950f756806d037e77e0c762e662a79901a8e39d5c184cb3caf79e76d22c9f12e35e5eb32c7c75ccf547faa775b407037e4687c8f7469059009c5e0b8138796b9a5c7d45f4927f61734f342d154d27b41b781a383f7cf3264232eb778801ff1d15cb5f07e409eec90022c490494c5a71640b76007b89c5aad66c063a42cd54d64db180954d2045c28da760610c596322e289188c5d58cdea01ee1ab9752d5427cce3562b35020a60480e55869d0d3e465e72a7fb8355c0f78f706c940b61d4e75469b78bb6a0d68b07499e4e98960e1dccae968cdf952be858266678b33feb235b6fd3e3d8acd126be141048845de84f7b6ea53d42745e1d582636811f4763810df3030bf9fe54c652aad59a16e1ea0f4805238ca431f1c7d55d5cdeb586a9ae38bc4b356f931baef2cb0fc692bde941cfe6d032c02ed9cf94cf39feba2bd805fe43a6ec586ef5b632283a7861d8c4e5b8abb127884122810513c2600a27c3f364abb7a422fcfc51545d1247ef5f75c5f53285f1d3331df1e48f1f5cc86f0b80aae081f83e63e5c01b30ae2930b748f78570e838ba01e68341c77a239ff8994d51341ac78ad6fba7d8c5b6dbda10154d69f1eceb8fe68155a06f33f379f91807da3b42c61edebb10dcd18106538a6a3769f84e415c68469d2addad689a947d0910bf8525bf2d1b26c3d1736d22bf0fc0764cece7147ab3066d51e30ca5d422227582c53aa9ea6ecbb40c9492abe1f444620ade068b9c6636bdc54662fd0c72d922011c94212769b3718d8e4e97b09087dd2c1b9e0e3693f0888ca5741a6e47ea903ed1c654a4b17ea768ee17bc170f1c98161446a193b89e6525bcff1099464fca405458aede738bba73384387feb403678c00354ca9f35849c6f38958f11da21b91953776567a2cdb4a145fd7ab55b709d7cdf27c292bab6b7815f29e8d1ed142c021a282a7b671c06b435e5e7c3bd9814514a70e11dd8c8460fa7e0f25fd74adc23f5f4c8372ae806fc5770b40217a6a344751594ec507a820be59e4d684e9bb9cbc4273dd77cf2787087df6e24774d8b971cc024da878181f1582a2c165dcb33083519f003958400987b09ca19f77693960bfbfcbf685c64b9df9fc0a1ef88edacd174ecec592bd7764c566aad97a3655b8c74668d22f438df7ac1df17517f54754d8a207a59d3209b2a7476f90f43a8167c9a9ef8e63ab3de8ff6a6903aa8f198e1e555e7c181fe8ada7cdca91a2e66904da2b81c75d1fda9b6f399b60203dba9a459152fb6de883190160f4700d2a6ca9ae0fe8ede3dcf1aad10b8559eec44ff7d0b6bd1b17f4adb7e7b104db59329e923ecd28a5a61d32a7eb8426bd81d45c4a0aa0c36f913b33bcf73b0c192265af47bf29bb7c181648a7a5fcb1fd92c7fc4c50da0f9a89567bfeed25325f13afa4dd2e92afb8767118fedeb535de822dfc7157be13f1e6ce37b3a7f8c0337a5140b91d51e2f7abdc64b8d6e6ec058a06a90d4a39cb507b5bb5c76541420d19b9d06bb08bd8ad368466225e40cd40a3dd92ca26479d7cc7d94a7106a342bce1678278b097413782457e88ebf3e7508e424e88140de6105933753a51743c7be0710b20d0b7d9375d29cba28b6c8ce5b3c34ba8342e4a46f1e522ac595d73f1a90702f558a310914b58de627db9cd5777fe59adc11293171e0c134b26eeaf34049b30611184d9d08a854fdfe0a6ed38f93db68336c4ff735dfc5f241be7ec8dd40e6c91bbdcb366d1f78dcd75cc0f67e2184e104f49552c71dbcd4057ed95435cfcfda720e0f7b09eee9735382b43b657d970b3eeea932445bcf4a73641d53805d83b663cf4dd984c0fd8158dc73237b7a872e14a6ac34257796cd69b22c3c62c291d50c2208bf095e970755fd762d6068ea53a73b14c5c5851c0370a781fe6fb44ba5ebc6beb34e42a1747dac62af6c459ecd42893d91ba2c1ab5488b69c01b64075a8e3791568f06175d960608de94bd500c4f6a82c8bb6cc5959d053bacac7c24f8b3b9532db348ce62f0e58bbaf7e9a0d0b557f42a901fb348e00fb27b80d5c8d56980fc8c9642b503da73badaa71e08bac270299cc7be1763ce93a3229a966475b61664f2c1bdb7446c6431dcb0cb87d336f134604a0de3fe67866acf659c624acbffddab564cc3d0af147bf662e406789ea577ab2bdbd0563e2f5d923e49c1804562403f1d0b31449282a8a3c6da6f5783c48bd9ae4b1338337c40edd0a2b5bd937767347f8fb2964defcc45dcc475eb584c3c677a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
