<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3fb4d6b6be052d5a0b9c087c1e94c4c6fcab10a353700a1a70220cb7be3e79f99f331dd5e6c124ed0b1f4e7be724f7ef69dde875ad0409ead4ab83f40e220c140ac02263837c47b20368b1a92828264b8ca0f4c256811b19ee4056104bad1592137653c5e0d06305838b42f3b6c2eeae0d05f93a54aa0c6c1a5a1ba25a1ed56a396957ea6244e5f34dcee42b22719d1b7735de016fb965a03a6e2c15f1625e56229c779040be6088fcd479a51334a8ed3980f226dcedfcc8a117c3893132fd54f0dc1eee0216824404d09af65b18b091194cc03de76a2b286ef8674b14fe3e7b097da2a48f934ba091acbc76c38abbd39a7b4f743b9247e9b7144933498c39e4f897801b3afe04e8fd45a6890c3e679817f357e803dd72d304821652c6b79a16015a18fde7219148e6d4a374802e8fd3e320edea5f9abfd4b2381431770fb42ce0495c2739171cbb9c0255124d972605766494fcce568f824eb48bdd53843049fcff7477059efb4bccc9b6f27f63182d45204cc50d47d0fa86ce87df4113b96b5dcff1221fa4650a7e9920bb52702feb2411d77a06ac47b71fcdfa8ef5edbaf04f548b401bd048a49041b77a7e4df0cc46db33b01d2c38eec203d44eb0c817dfc66fcd13aacbbabf1f4fe0a0d2970c64347c1b2ed997acc4fa8d71ab9bc003f0c60cc33cef778823ad6cd086ba69afab2e92596e6b142324c8724a967cdf15a934e365ca9a5d3945191e55bb5378725a744b70c8ccf5d7436aac9451854abc2bd1ae58ca58cf45bdaf48ebf3d370603c6bfdb5ceab769535b396a26fe7feb184d057c212d084e9a119223156a4d83ab5d8abe7513b01cc00e7773b3f4e77fc1b48f6935d5fc592ff3d69dc5e3099b17778ccc580beeab9739ebef9574b673c35141451425b1af94cccb9e19affd1656cdbffbc19cd80032ae12061137d454b8524522af5e496f0d6a016e3dafb8d2a950584f1e6e16d2903714fd8bec17d7be3d61c7e456ad28cfae8673da4e10c882be71ff51750cc49c4128582935d875cdd0c9b26bb3e12bde8c92d2efe6e844d6c78f7cfae05f37ab33993129af4461e88bcb0438920c7927d07ce17c6a64b00b6fe57c37ded4caa96acdf674d36967a730af402ef5bd654fd4eb9513183acb14045459c69f9cba24f989d629e34fdd16cda53d4f8dab80edb7322d866dada619552fc430d88722e5ef80b7b62742269e991b063b8c01e1d5ef2d98a1496ffd1a5d2fdb04891d6fc2994caade02fe7bc3d8234592fa476836d976df891dde1ddd41c5813871ec3e2e6394c10f3d3e147b0a23ab8531f4c6d51c2b9604662f700aac2343dbb8485020ab0ddbff30281863c10b39d45dace6334b4afaaa3d4df90daad854ef8fd4f22ecf06f8846f61e2d441185f54d65d1227a9f67f569c46732b384d9756b3a7a2a7b316061fae5379208fe11027b7958c31082c0c49b14ec2b8b377ea72b40af91d1fdd847643bf55e4830d043e863926b10890a9cf45082862a95401e4a5bdb321bb2ec4509404ce0392d565f2166068ade390b094726e84b8fdc19f27a17638424fbdcc8d0282e80aa738ba26d6095ad646197f6630179e7f4089a1d24254b7e624c17e368ad49b06bbba9f11e80feabd5d527229c1724de18aea5d029bc66036b5d6888549344d4a257b1ff4bddf883e2f3ded27a666c2a4a0725a1d25f1f0b88bb2f53eaeb6735e0e3ba388a334e8fd61e08720b405e286998d4ab67263ded22027e2ab94aedf414838f8d4bf8f0aafa4f6f831ab06e21781db36bede48a24348589cc66ecb5617fa78abfbf2e135f5500a694e135f8bda8f26d6fa62f2281c9610c09fc1d8d35e31986b24abc7dd4d875d1dc0b3dd26c00f7d8720260256734062c7b97f55e315e8f0e658c7dff254b556a0533902642f1d628ed96499096b3ec7dd82098a06faff00919895e18421cb97301e7fa7083f232cb1df13b487b5a7fa05a91e5736269dbb8c73a9dfc7cbc07a5b74dad8826fcc3dec4c2896d44fcee19e772af62a519ce2c11534b107fdad691bf35b0d75d0f91cd8ff6f64d5eca7b64deb1dbc204fdf62228e7b7aa74ff52108c42a3401363ff7bf9b39af8c806e3ab899f0f65830661aba5c7b5d5d2ef6c68521886e054e6c0bf605ed14ed5ccc361bb8bf835b2b2dbfde72d6208eaea22e47c8101bd93a6531172cecbb0182e1bee2565af6db65c5574427944d3155db166d5a957dfb342a715e37dd08d90cab3eabf0d05f7b2abf123998f0e3e9d713eca10d2085cb1ded3ef5f24d4d213567f59ad6407e5bc51e2ac8b1f06d605c7a3dab3da3c14c83e26c8fe786ad1358bab37a322858c162874f26a7af199ff6fdc098d7f74876e98d54e23b548ce904d95c462dbdc9737e1c11a3bbdba69d4fae785ce54abb4d27360b16c219fa208c4bf289996c854a9a1378d02d2a28d31a9cee9d71520998ce882fe3dc8bdb39617817259819d5ff4ec3b95546c5d5a409c16da87c2bded6e6f26ccb5b33784231a749709d15a8d62f8efe6a0cb59886b18be9c323cf024a371aed9c6355bb3b54f2a995b7e44952c6aca8e0d051ba44816eeeb50133410febc908fac2b336ab8d479d6f119450ec817c27febe071250dec11a35fa7469266ccbe4e9ba581f7e9853d13f539814c616802d9268a8ee6fecc9da3f70a10e03a5644e8684573136f2228d5eed6a9ae53573471dd6a6f9933218fd921940489295635ff95e607b7d8f0fdcd4ffba990d5960112c24f7e7f459dfbce62dbe931d71ed1556ee3f42b77b070b98825ff87b56b9126abfc6d9ef725d2351c0dd14772730c687e6c0722a769e8b1f249ef1492c1137f7ae55e19eb7200410515a9b61a8e908f17623aa0acc1e55f633c3cd2e0608027c824ff6ba32a1cc6dfd8c2109f032b95097eda0f2648b086931d35e4722b43c078b846f94c23cd2b21171cf4a320c5b83d16322af3caf3e68919602ccca5aca448d99fbce30ac8aa5df640df11e96e28d133252653987d49cf2ae04014a6d4b3103d07fcab93250fc5ed4aded2984c04162c63c23af646062258e14b54038c412d440e449c497742624cba4db03114af55436206959631f582dbed37a8bbaaae2ef3ab81bc06ffdbfffeef6e8a66bd2e8a3f1b06f4506f821961d2e7befeb7a4efe4efb4ad649b26f908b061f24d97ac35d41fe0ec91f06ccf78cce018ff64e46bb8e2cc4ea8e84aa11ef6089d687f17df7aaac2dadc05ae4e1f54f4a8e40fe4f2fe08012023d854a8345afafd316a1d6f677ad4777c8cfc03da3a15dcb36cd837b1d0cb0d091ec0b6526f6c81a02e89e24b4dd87aac79bff220c6a22540d3ddb1e6a3505834df7b8df32ef6dae66785969f0accf168b160d4ca4f88f3f7b736e2659df4d6e0f58692e146a56a8f602961c0c841c5a91d5590471f3a6e9686e91164a2098a1ff969edaae9a67442950c5187e7d513f3d571f793009593feecf76b1912456a414d7522739a23a6441978ee1ef456d8df74f2c649c41f1e51c7e34c754424f5def03ca2c233c83624950448d34bd5e0c86812c10421ff06443d467c20d07e9b8b56699c463e863dc15e89f19df3d5b0db1c293b433ef883df317952003abd73a0acaf2339637ae0acdc8fc7ecb1d8621d85619c4b2ce9cd5f52279611f57c38445e063344d5714ef6743e60025568089513ee4d4d8b84db3a9c181dadaf552e15e42fa1291a86c5a691f731af0a05e4a65c50471f517c633a8998116535db7695f734141bfa38d640c3fd36931bca904ac551801a5297701b440f7e6c50d1836f468d644d4db43f4c70ca02f24fe8b8d4e036afb0843c24147e35fc68f524a48309b63934243d4b36de7d281039854c7d7c11b12a09c6c666e426d3941d47b8584e4b7cca9a08e42b66db3bf7553f12f36beaf661b85a26ff1991f7884c77fb630d9a2465ef10ef0443639c99943a6092149aad067df4ea2a2f0a6c9f9394d1b26de5a1e4f35b46a12b7a01f62d8724c91c0fad3d903a96b43fdbb43f3a2c2abba75e337e50ec90806721acc12d05461681eb270572ce3a0a43fa856e0db6e6eaa2d4d5c2072bb7d7f5ed49673e64b0cfddffeb76ab32f0c3eb2fd61cf5d061ad59e64c8c5d3987e9d707f949dc72d9979a0796e1b8e4d086e8bddb161cd44fdff8024ad26c329c0e95fb148ad72b81497cbc80373eb88fc06a2003f5df0d22c785940b4c3c1bcd9e166b8e4def1618c7be6b5a31571ce3570361c7bf302a325dd36b8a017c67081ed256e7b63b282bd9d9abe0ea077376e13fadb11036e9121b74abf31555bbffd6460660d2f9293af80d430686196e40575c92aaff74db886689712faaa52cffea448202073f1b35ea7feb3a9ecad49ecb9f228fde9f1c9ee14e6b870f2db41f62601b7016d040b07676b5ee1d1e6a67c4546c18d54960aea75e2996ea09c21c10b1251dd29f7179e89fed7862527b08fba53060af89e508e4e9b9ee988e0b209f4a0b2922f4091a4e244998e72c7cc882bc954942b9f06a36e0727874b7acdbd72f2e991a159bdf9d1761843e49d94a31ed25da1de7fd90a6879c83a77f8d03f4c0294ed554df592176ca75dfe3c12b9a755a40c9c96fd7a119929c80aeed2d21e9738166b662e02800f4ebb3e41d87196ab6e77759aaf59446b630d334e1f4754274751d1a63baa58913219b1f9003f59e3dedc212da54c55eb4db5a3c61638171826a87fd302bb1710111b23ce6cb513e6fe8978a328ae45ad34ba65d132ddd710c57fabdae12292f10edaf2d3cfbf0477bf398bec9e06de40377f09deb5f1996848bdd804a95bb5d821fcfb37269494e0261fde64e3474f3879ea7799a8637daada2384050a8419ea1066e5fabaf042856b71eb3c679a2b60d977debb72d7797fc5d3c836c4b87f2c09fd1317415a10d88a6b8ab4ab2a33c33c5e64159287e00910f8537d559e45f1931cb1a66e33aabd841f20ae73f32ac96a40981da75e8b32c3f0c54f4c705033afaafdc026867c6c8eeac31bf202abed622d76ed226c9efd3b88a6e7d5fd697b20852bdd98bd8a211311aa590067904d3cb6ad1247acab6c630c8a01a1bea7d1a3bfcf71816017cfcc04515dc3b97f3aa5437f30774a4d34eacc9b3ef4b16243584b029862031c9372b46132db0cc985825d23f2e7c00a262c185968fbd47337433074fc7e471832aa42db30486204e02e60fefd7bd82c783b30c3a9e936a44dde1f9873654509440990e69dd99883f351878cc3eabe493cb353628db03a1ea2377afdfc15941e3d62d9a0ac4bc4269aa05c64a159b76a23a479a1844df5a8611111e6078f6f2461a104b63366329f61604c51a0d0507adf4ae6103a208f72a9bfd14026dd8366f6f6aff9364fb1deae2ceb5fb83f5665f6695ec9ead24a3903cb260f671360499367e9b2aa42cc10eb920fbca23dbb7569d42ae72576e241e2446f328b09b49f9e9ddaf1a6604d1b0d26df5eb198706a955c22e6b056529810c8660595ec1f9559c49cc9ae549dc8824bfb040be9058598c932cb547464007d0db5d3f96898607e5ed0372d99e59c5b1502fbf656a02bfd01fa423dc271996af64a2052356d80e59595ff878ae62df3c001ab75860b703efd568807b8db4f6740b5ea4082663ef1509a3409d5be6e9640d66052e9c1bee4c97a29a51eff0f8c35108746719537847491ec193d7f5297c50c0f951ce5b8d8849dd8c41107c59d9729736f0f33eb54d757cb0b2f3a3d92d7071b657f1dd066af4d09918c2045522cc28c82d24e6be394afdce8ec1863dc500fa84967c30fa5977f2f147f792feb98c0fdd0fb03f677ca3808bdee01ad38799c3539749bc9049c92f9fd8b0d5f4d4a171c31f8c470db2e779de09775d380cc8285a94906887911c54ff95b147cfe0eacc8f50a301440a5201a39b5d4d66753363ef3eecea9bb0efaf968384352f6bc3a028fd292eaf4441825294ca1b0f6a8c899e55600a6b69949067a48b65afaf2d5156ed7c6f1d27d9b16bdcecbb9d98f6d5be024874f5bbc0ee4256aff98dfbdb2221b30f7c33fb15aeb8078cfb5f26404510f534d482d82872beadb7b26add62ed5932bc4bd3fcaa989d3829cff5fa3dc33e1a4ae4531a0ca6972a23d3fb60b0a0dae15252efca725962b7b486ec9c50ee8bc59a0032bdc439eb94b5691d405299ebd3c5c6af1d55469f3b9cd2eb7cb09f5595fe318ff5f86601ba3f88f6fdc16fe9dfcec87e478e465bb5265c475fe69a1813b0af090f22ff6c679fc1c271fa68556e24c6fb27384ca20a28c8c4e8396170065da23479c2b9efcf3ee12854279058f1f6b744a7a6574f0177a26056ee361de4940c23c65a6c9d3ab48abab103b206b4792f87d6afbb8ef0f0483c24d429f9de74ee2464a065d21f65c9d53874e0b9337afd6af2617966084c51ac19910a90059b1b4141bbb7ac9c284d8cb452fe654b9cd47ea42dc67322de4eff5eb070c5c6ed56887b03869bcfed355c37ef2f6dcbb8a21369212b5bd42cf5445462e3290da306d515609514d199dc905240606aaad9b12f44d70e308b478d2ac70fdb37bb55d2b8684e21c68dfac61c5114b07b66883b9504c440893e4f9b4598c3411317ecb32407f8d87ffae93446ba4c021a362799b7715e6a6699bb890cfa947d0b233e504c1058dce96d07913b8f7ab3264ac1ba75ede981849ef6ec98188cdd16afc9a988f4a1a2a9e652e81eb788fe931ebd83160a1b7bfb351515f1f23f13bd833563b2e9bd5e65950e141151511a2b932ea384aac003f2c7d9ba55579ffe86c247b65d6351d0029ee7bac94d154ba2db3ca434c21a90af55190d7d45d06770812232d3023eba7dde3a0bb3105e811011f24ecf510a8799604d09736187f29429cbc318eb2a8d31e20d57e5527566bbf00d64074a081450bad790fe06e5f3b1ee07072c05a59655674aa4032d0aa966df08ea45409d05a43c8c62182a32a94be7d7b942a751fa5f25a4936bfbccb88c46599d51de52ad1ec67a2c861ecbea70b3edd6c87bc37c02f3238a92c680898506fab704faecce6dedced550d89f2e80c9e7513b246cc83698d934072f10b955a970fc6d3309ea8e2a5cfbc7c1500abbe9c3db3a6ccf01235058f03638895f0c45480cb3d01bbcd8252bd990784a8717c1203f791d39004a13dd2270495b9f77cb572838c6834573334490f00f79146c04d632a40c749e9732949919e814e8feddecd0b889e28cba1ee34efdebc02e60f990a1ac82f50785d9143c102f918d0cc37f8e7ffe13a132f1bdfa515b3fd354bdd27076234432f3bc13fb689228be2dddcc3584849dd412414131170a16be85e7d683038ae8ffa5eab7fe9f5a72eecba8c4506445b97fe013b7bfccf124aaaaeae41d78472ffe71a8550f39a50689293049bbd59a606260d938d4c652b295b7092688355e68f5d663ae82d03a3355ada012d2f54f250faa5032083669803ce6b5dcb4e16de69d006d6f17c6fb80b2f3aaf6b247ad22a14612fbe71e596ca6737f7648fe4ad65da19b5b0beaca785a2e6bd04fd251e220ae72c604ba0622661f82b414edf2e41836e591ad2f7bb58c01badc206aa6d39ddab79fb43ef5d11507c6290911db64137c27483e92588a886fb091d6d7aa864602f969fb47764a86fa51c08a214840319c6bfa2dbc55a3a26cad9ccad4c9822d7e41fc54d33d9af8888f002a4aaee16ff1605cd7d9ec453315b2056a7008933f99052614a2861e90816dc9958bcc7fc89fe2b1067c2373e929cb2917f6a938e491262622c654f218853eddfdb379def20060f438f4e9ad4080b9d9fd5e9b89d5ed392dafc43efc6d343d00f8823785ebb485f4552f5558d0282890a2787bff0b682932c8a23c4937463527603acecb093b122cc9620416951b265179f029ad0097e930df36d3be22e23dd85ee76f2b8455c7174e071768370168900022946def049819da2ccca94f88ddfd0fa6a6e1d60d5cbabde800eea96006913604c345f847f409ef6b8b908b49f534745779f29ce492d3f79c9e5cc2fadf362f3e8ca795c86d31019e05244ccdfba29173a5be84ebd06dd475a677b4b6ae568f09fe300c04a617ac612a0b9400208ea517eb5c3009f32b89a387989b7a3d23facc8d5d8f5c453c78222283ddc5f597b2550dee2ee747b89bea36f93251d190e4990f38eb28e493ce1f70e665ce59a04897b50efd8e8ea2da67ddc44f8b73cd69fca3029a0d7e2426b3acfde04e6c84f5bc6bd77f242ce60d857daefbfc0ef44609d3e32023d0de304363f4f8acdaa7280c77a5efdac2d7e2262e861d2a890ec95ba027bd3f20306b17da0b2b47aa366e33d0dff926a2e5520911a50a74aa6e4ac3a687f3d7f63a5989186a3904f6aba3bef7192b5c15dd0f1054217dcde9cc10d54bd4cc37e4e839237440d0fa2004ba55b4e8e6e099c4117fbbdffd2af03efcc5c7f3df1f7297f62cbcb1aa88acebf0ce2edb0118b3ce8946af48455b8281c0338d8fe4f414f1d42b1d1163240917ad34d6d61ad057a78ea003ea26a151658bf691bf67c0d77a0a97da572726e801a18a4285547f75793e6839d571c2151c69ad2170404742b1678b9f7c5e2d5291800eb6822605785649632b70a212fa51dd3f66f66f8429a31900034098f84462d79a6bb2cc583d8f67248bf1a74d6f3c3817ef7f924c9c6af896d38d01033aeb94e13708e0c433a40297d541ac5d495c6e10b349425d3281f6877c5bdda3db445000a21d9ee5fbb47f05f9b7efda4f25d9785628f7081c04934fefacbcfc81f5b013cb24c9af4b779b36415a04ac8b08c9958656fb8698d554a8365def3d3e9231af82221a161db9f06608e84e315ef2953c6894d8cba88f762bfe57c79a4b31716bf3dac4a467e6b9e9c93a2678f128c39fffce03b44cc8ef42b277da1f49e42b5f50e25dc046f18a0076f41f551c5caff3b96eff3b56980c16188487b1a493257dcdadf1479edad0cccd15ad48cac534b5a885773bd0ca36c673c94d210f4d4ec138d3f5d23b14b694b15169bfd71dec43ed72388e10be7f588a0ea852517ccf5599b5aba90f00237e09f69a8d50d61570efaa40ffead20801292e08fd64c80995d7e14791241b9b2ed8bbdab1df5db4cfb45a64e4e4194ec95dcb79ee5ad255e6e36fca1b518735df3e5e38c09c1ca79e0e96e72f09ae043b3b4616e7124f53f13139684001e2a6894a30ab3aad76cdf69a234a919c5fa39279f17d96b9116edc904334e588240928b0814373c3370ed285c6cc61913edf7f5a777caaa22ae2d2ed535705f20bbf99c865f1c75cce1226d5aa1cf23c1ad90235520253bfa365750cde0db7c6b6914eb0f4314abd2c061bd8c38488c9a1eb7a77d2a56ca25903a3a3ff996e75dc8efa14becdcc1e9d96d0ccaa9f8fa3fa1a632e14b843d3a421415ad011890eecba1f9af481bd2b4bc01d12bb5b21d60c2c90445c27b986b1ddfded2c2ae49738162edd91e98004b6f7c849c6a8651eca1bab5c2d57e3d334e1851ac9e102123818282495b3932d4563b70751e46a6f07eb7bf1ccd7895f85eb4a4adb960cad9fe1d0d2c493d73c559abeb085d99edab648bcea7ffa33e44f88bcbef28cb54877a86242636930a40b3c7dc07c51fb47d8ae001c40c84650ad5db84e3c534cd1902402a838f28905f8ba4450bb12e7097a489bc459d69cf21f8cc3e7f5cadad22b1224002eca22183809671cd869d0aa2b381226ac1420edc89eae5fbf608f9c641a24bd649b4268c900267bb4dac1f7309f26518110ff817da1bd1fb8351e95974d242b9ba33e8cdcabf347075766bc5ab3d65c080dd052395119bf4293dc29a98632e6cd40f85a009f5453345066f52caec5b5af867bcd635af5ecf70744f6f90334340ae95fa58fb0ec70dda17d7a704cbec2ac620fb05427bd5fbf4b7b1cd5bf882e532b03d2cabd2a9694ed44d2a4a24d5bebb7c145105fc2e3b6e47253c5d4e2b3b9123baf698dd675076d47cb298ec7d1de35fba7da808690c3b4191be7bdabc8ebbaa5c0e585253fbe8469626ed3b1ef5218947b09053026e1d75772ccadfbf0faa59599985617fa8c9181f6178cb33ecfb0a91fc2f7582e9ad2de21db8984f5bdab81efe32802ff99728a5e55404e4aa6f7ba16f08d1196f879f536c02182fcd50f4e14dceec9f851555e5c4774d74203860151fb3dc91d6c7714680a691475eac9a545e81f8f4cd2c48eeaf8485bfba67bfa2c028f59161a5f0d2f5d782185658209180b3f145f8b37ef48012be75ca186fada73214f590ba1eaa50d99d2542d16dc08e4a2ba4b51bce27f9b0ad7e05dd7694f539676fee287b15136218ccb7c656689c25f897fcc6c8f72dc5b573da34c85e6831e22aff34192fbebc17d004d82da02d3fd80a821d37a26568050452207c64ad31679d47d0f0954a78a989fc63dabc9d42c0cd3061b2d71b94cfef4b33b9f644397faaa544f0e76766f95ff770db7470e67feeff97da2978b4a664c454195257202dd21919844a66127ea74220eb89a79196c679e4d123af98bd0d71214861f078d84c082371b4dc5d809924d912340674009c68fb02ee6f006ef4e0799ccc48fdd11c2a8dd21af2e6d6f5e5b5dc20208b4da9cfcbbdb9fbe3e657fd50de17088fda5476e15bc704af704bdb6da4e232a45b8f8486ef7bff26e70fe04aaf4785a5f51ac47e214168d36aa50cccbe54db6958a914660ca3351a78ad20fa3d134791f4f7046377f4b022c12f4aab3b850b9edf3ca6500a15abc74acdffb45ab2d11cdc01cb3cf88d58abe22ae0d5e7916e78d992bbaf2058691294939b881a6f617e6d4873a93e50b540e773b67b6cdd1f2e2d23171839e81adf7ba10467934d3f6bf3eac79f02864873d084ebc93d8b468842e650517153f621773717fbb94406dafcea6da828d57cc31d7dcd3d7679b90ce897dbf5a67cfa71a3a3544e7c57021b1b42c11080f1efc2ff2914d346a90dd10eaf6b5131ad9d7ed1e4ebbdfd963d30ced62e3e8fd4fb63c4eee1ab4a2388d3d4fa2f86fa9029f0b939fe855b05e12f5f575c4e66750c025fc4418bd94b6bae97929ba3629eb5522d7c3b5317892fd540cfc060f988121a2486021cdad2ceb4f87cc560f0bbfabe5c81ac02433501969de5ffd5cc9bf3b16fd2bfd2a067d1bdd5d6764f313f86b475b37ff088f99b9194d7ce6b3eeda6ca2b45ab7b4b8be787bbbd2e29b91b07ad213f0651ac3b84e716a4344c00364ec92026bcfd811a1e6467389ad5fde459ad6a5b190c9baa847b35f48d1601f2f442197dadc48dc9a33eb635217fecc9ffb92f8aae3ee4518e37fb7d2a966a529bd87d521bfdebc737082f074c63b109542e50442c7008f6db29ac74c18f647b01df36d264a567eebe8556ad8ca1958f8f11c382d976846874b55999116930ff406afc71ac3601a4ad917052343d15be3e54bc91c5429555c07e6a6149d8fd7102e9245255259786f4daa5a4c8486a3febc6f631faa6643be02dc4833bf9f29ef1f25aac38ffd91fb3bc33746b8d90af6486e62659a8febcd190e411759116fa0ea4a353dab5521ad7a44e44902b36c3a339de74953128fe1e026ce5ca71d0149ea3b0f020256370e6d5347d968c1159208d4f4762a90c8b22336740fa33e00b2356f42b98d3cf4ce5a8f3904fee17b417069c0528d77b8934b5b272761b9507aa7552bed33239e36ee9e035137483617a3649c11b2acae6ddfdf55f36814f100291f7512c0dc80bab7cbd5ca661771043995db1d82ae81f1d794e9849a6ace453f8edb8cde258d6349985fcc852b14bc1bdbe6930a4852510b916b3e2ca5942ac5f1a6f94e8bee2dd32560461aab38c63d7ddce6916244745420dd9e8b51c7ef416907af2dc93a62999d32e1ec5e917df690845a76bcdf64887dea17d57aa13694cbd7b06c91df5156666305f6991c01a51caf834ced108eabd2d4dd6e080eb6bf165f8dafb6f738cca902fb096c13ef95b9c058e9f5988121a7db088ef4fb1a99cedfe7e34869058d37446b1b96345217acf035120ffe62aa4b3deb44d50f8ddcb2301dcbd57e66bb4ea2621b47d182e88a267607e7b049e094b801ece013937170ddd506221c2b76e5181912dbf0ad3875c34fb1e76bdb9a00048101c7b0579241d64de7ba2fe04f1b5f308fcbd67d44151817442755ecb3971ce491a841e5d47e0515d25a118b87a14a848796f0fd594afbe9128593647e2bee80f6a3b302abd053ee5a1d6796b0cbd9a374b03a713b7f68488c5a6c79f227b9b7745f6c29d95843b95e543af88f67801cc8934c5876aae77782f299e193bb8e11d2a7383987945b2d69fabac72ee429bf496c2ac611bb786f1cc3fca515d218d59f66928fd7ecf2d46ff848b0b0db11406cadaa7726101a1b32de73292398dec85e632ebae37cc18a272a0b2d2f1fe123e742bfa9259e6d62e27009b5792fde88d7f4d9f574b3c862427d1faa2364288ef1df5b9b6250fae0526b29e116e3617088f129e09809aa206e070a9d24f8f05ee82995e0e910ff7290f302e8f4a8ba4144e3bc1865a445fb9a1aff4f9389411021c042d02918ceefab39b6d9ab1a5ab5fe52659a823a79a86d28cb5f5868351a075bac7e4b391df702313c64d5ac7876f2ff715fb4c647a6230fa4fa248ce7a72eaa0d84c31d37de833414a4fc479d05e7b0eadc9e012db7c5956ae7d9a22ece15b4bda64168980761b2f2c7a5ac767c1f2ec4613ed1d1d889d7242b01225be420e55a42db40dd355b80fecf59c69956bbd7206f97cc5812f774b432fd5d62e95a0d4b07a4f9b82db589e3400666e34b3328112cea6d9a12c91e49324728078ad5f73498c422e31b00caf37bd6da46cfc1087842bd10803cfefb6a0a5090f01192f3445c87fbabe8e90af6c1bfa9aafe840167daa0376e07572954de136202ce76217a3d9984e99d96fe5c00ecf7894a8603e8848a010ca08dbc610c073e094f6adf580fdf5a24656ccfff830302ca60a2da315d1075acab84e9d5ed0936dca2b9f2a483650b08adb132f97d071c7c57289c5d4f00a3410cbd759fb93eac60c2c9c8b08055f7c51ed2cd47c651462bf173146631cc620a4f16f41350ec189690cee3bfe92cb84053aff0d40593393fcc549d594fa6cc5a41ccf5502b5cfb7082d9fcc228acdd0be08252eff11c072a1ed90b7e7f7c181db07c9eb4c22719b399fd47e13269738ae578088a911f88efbd4207c10bd2fc422a5d7e3f041fe696ec8fa31dbf72c3ac1303a0b7d4569b9c0572e895a451720b1b1ac7869f6fa0f02c0c18412ee4a9fe227a3bc1d9438c7734278ecda51528bc44eaec22de5b2592c7abdea94b666f50709b441d367243753a91e5b089a540df3b959439fd653896dff796dfdbb265756309f1c035544c7c2a0d97dfe88e61e6822cf2152e1295eb96e7e43264e711f2c3c8e9e5b4e99cd1dd8ec98fb7b7764c64230e189c95a672ccf1800c754e93ef88a444bbea1851865c6ab14eba14ecbb5fae362ccf777c99fe91c19a9dcd9a31a39db93923f9124b82a4a3919748efcc29f560d8e57acbc268397ef066a5fd93502477bae01dff79b277b1b6f36c2a8ac363bcef01abe951d0ea9c94b480e428372135db740be32eb80bd306f7495b2a99d3b3b3af32aaa86b8fe98bd6107a207fe9903c931cab3d9c7e5ce757d99ff807eb1405977c86664f6a6ea3794f8447108c87bc5f3eec01a986c36b21b857df0509b9ee038fdf7a8270434b3670c2d29b9f42ae6e833b2898d7bc416c7b75a55859c2c99a01b53181216a06e869b50f73a1174e31f11f57ec2a8186be6c71e17149a7e5421ec775e9d3fe6bde0603d8770c4d09d93e804f1abcccb9cfbf5ffa437b047376e4b5c654bdbb145534ac26bc587d599fa3d81668f50eea959ba9dcaf832a85cdae78eef36e0913ec1ee94543b7608dd81e06fe6f24a11bd1514db8fefbe070ac280f78060b5c3dd75dbadaf82afdd0192aed60c7fd908893dda58f7130441b8652199c4e726bf1095573c855133c0eb43bfef449b4d627083c2cc85bd9500ab08e993a716324b9115507f1133d9112da498b6be514b59d438d33167dae797ef66c6137a2a9d240148032164f507188c2333e228e619dbf9f0e75a160b153e3a3dc7de06fe59f5d797f03bc14b40b08cfe216cbde200fe51e28e62866e3a720d01d49cf2d7a89e36e5c9e61ceaf512fcb1e22d2fabb6dda8f09a72f8325012838368bd689686e421f8731dfa13abb9e9f4f9ca0124a9a26a82eeaed33ddd95a1f42de68013ecb4cdfaf6673d8a72359ec010331cc0bbc9c2fcf190708a3a0b88f42a1c27829a38f14ad64433a58f42955de43b43a4b9e968379500af30403d4763423112cbdae1e196b1af9eec60505f0d8fc8a79f92b72cd6ff791a538318aaca37f37102f46e22f63597cab9e2fe14429fbe281010c56686ee0698ece9320b529fe031ba3a7b9f5eec9f30e8ba3442541bf798259ba1a89c0c217a95160e68809267829e0a3b81eb936b79eaafb3619ba14c5d9d2681ba9360d02ed87f9dcb57785c1c8d8efa7afc883bfbfa9ffcfbdfaa19c0a08b90ca494801ba118aea3bce4ef72e20486ee661e77c191213e6d47bf75eb153b8d11e61f51f19278d44b6af7cecf6e00ad5ef4345c3f539b763b748ff9d7278a8ce941aaaa9f21403238885fafed2538672c1812b896ae30c98d6a81ef4e6cf88fc7783c6371f80685614aa660825389d3d3a57125bc17db3335d1e93dac048525356c0da9097aa1058c36ed4c9979337c92e35114fe1f58362be8ba26a7a2bbde60fce8152fcba252ddbc3e96c004c6a8e3337ea61a2dac4aa80b160a1429f4258ae83f517dd3da423852e9e6dce68e0c3a7f628cf949b42d2c1eee90d475e7f62a6cad527cd470db717aede66d2d341e2c808cba0304f1facda26f57197e1197471d34ec62639a94c4104ad6685fd78f7fb6318d9358a2be866a8ce2ba0240967af5ddd956b6bd97b3ab5265da6ecfccbdee5bc472686a08bcadb6e0267741ddd18a8cd9de79cd5e6a4f2bc19d6c8e12742c76e7d5a0e54b216fe81d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
