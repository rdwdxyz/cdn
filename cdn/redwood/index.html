<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6ae3898da719b0c79baeb6f0947088eb8c5b08c155828792797c53b8b8c6bb8231b40b8e108838882ee5c615cf21d5854bf3356a509dc1ac6076f21567431894e6c006c8e21d9b1d7d6ddf28c8b8d5aa0793bfe31516b1ba522aa66c7cefd5a11d9ad2e1e36cae71a81e567448ec723e77bfe79dbd156a9a9794ca36bfb3bd9c9bfcbdbe4d77d0cc4bd21e69393e343e7de93366a7b425c6877e9873ac012e0575fb36e3a55385acdb9efc5fb26725dcd0b8ac4eaa8743925d18fd3a02f8978862fa96c5e7c52f6015f55c33e5b09d704878547a46d7652e23139d053f822912b5600b6314eb9730ed06f717ee9b96670532a7432808ac2baa484520bc71722d4d235a5e5343177d49184810972467a9f773aa0bbf2616985343109b0ffca8056406906ebc34f4ebd513fb149714444a280544f49778485c5a0e2396821d53f0511670f76ab2fbd94ef46339f935e9d7fea95d8fff2ad25c5b1f4f1dde0cc33fde7864f8311d72cf626deec254ae0a32d77bbba04425642d03d1117853c7c53cf064a14214187ecfda35f571bdbe9b147251e1f8645a6c529611010afea902757acddf2393aa97609bf58e8feebbc9ea0af8b40f65ff1024b6d898b566de6193700f41e28ea8a912342c278bdad4eb0cd97ee8ccf1d11c5bd143601305fe6899e0a1331837737c387005d1591047ef27400944f8b316dc298ffc3f29ffdb58b21ade53d30ad2ccaa796b7270e218f9d5ffe52a6bbd2c3664b9e72baddc70e1a3f0f657d6ff36218099f794bed378755b5e2cfb19c02150c0e9223402ca281e869582ead694edad7191966e6bddd50af13c617b026b2b358ef09a8991df148a7cd663a84db7eed1b70150d46df76f610efba0d568566230576690a5423fbcf771c16ca89ecc1619bfd2b0a3195922c8a190a4e96b3b10b538d046ebd216f3099718ad6eb2a0ae1f17a834b9f075c7027ffa151050707e43e5a83f7e90a96fb22b48531565c4af9817207299245124ab96db5dab939ad8f0e96d72916dbb53aba77fe94ceb3c46fd30bd09d4be8846ec0edf0b9b428227cc109a0ccf08f75ae26f9a47b6bfa2d1d9c20f237ffb995bbe159c048c7b653e5bf357c3f6bc0fb3bf97b825adeb4a9a6c3137ea90c743edffde61d7e827b047aa363fdf947a8e38cc76dc38c682854eb261aa120745e87da371fa753a65837b5b73027506c8c16e86c5054cbc45ba66e4fec4e02498d2dd5f68e20675b4d7879af194da2e4ba32aa4ed03f95846cb7caa4ed6e632042587860f2dcdd09873e74b8fbe8c3fdc8558e66b00506d52f62272b3bd51a8fe0076175c52742dd2cce345228ecfd27802b1b4435bc7821e579555de4b44f9e4ae7eb2ce9b6e0746437e4f77a926e8f12a52c32a3d17ca0df1948da91f07264269c718557a4bd5b4c9f258a8d71cb6a29732e926efdf4b706bf0d3f63aab07dcbe8290c5d3045e74a474b23ff53600511cf8c09ba541fb6c0f65c4c59fc0bbfd392d4291ba8709e2290a69d2ac1bdaf987026590d6e516aaf37ddaa36e9af6236a0447a18f2bd0dba0e3c53b2b5ab085d4a602661085c98f9e76e1266546cac2b66367b5470e47539ebc6d506d287b4ac1048cc6c30bb89cc73521020c74a4a31961601c17417bf621e70748a038cf1ab1104b99883cb23c51bb04ee72dc3609ef0252b3a4f8baf7e846929b1e18b1e9014dace31dac8f307212ccb6c78e3f47e8df61cbf24d88a0a10ed0c575afaf8a4b93b61207ee2d7cbc6d7a71fda20abb602572e8d554e8c99960c02b459a017b586644f07a83bdd6d489cadc0a371c498ee025b3109faefde71ad1dbbf89ec99de22a8d8930d943e171441a3705e2842a7133e63a5e12b2787714e65ca72b1a46d37a4cd4a97d52520d5d24cd3342fbe75a836236b82233282119a2dcc5c0b4556a538fb47c253d8e6c4e773371cdb69ffe0021f8e8af19523eef458be56d7d808036542e048be553f56d4c4eb7513336d54b99b88efab34817120ea6815fa2a8be288860e0a70baa9adb7d6775944dc5d1ad266bed5dde3956cc53ebd9555973960bb425501c0978029aa363c9bc0c20b584148fa26dec90f028e7886f73c79ee9dd3e85d7920bde42805520de6213b6150227f8c88ce8574d89f87048b0ddc3d328dc36e928fc637f9fd8f1dd67b1f902890b95b98c9fbf5f8392cd2fdaaacd08e79055d1eaa2a031a04f01c4b91b74ae8144912faca159cb0756b79be2c94fa63ba03ba193526fa56ba245c182e6891216559bf8bbc4fc9d7e6875017efdd24c530765011aea087ff652047a3a46102177bdab8b147e2b08c37f6940be278123a860e286ae3134d1277488aeb036e8e0b24350060c1d8dd322c592cb28801d9bf02d6d3d62165e8b16ef4267a04be5d72e09c2284a55ccabad0648bdd19c112bafa2c0392bdb52468abab8a4d8b4f988d66ea83958c368a1506b2b415a0adb6cdf89e07059ded0a64d7da3067cdfe60cb9d169750c9c502d431fbece1609d69b8d726605fb3ce50bdf0cc9bd1422c1a64426acfbf601a937ffe06adb38489a44bbc12319b159c091956db864adb5f6f5c31f5548f05f49c98a494cdb096cb61b6cb284dd579b3b20469cf74461694a8eeca9d09e34814f73f23b32e693f9395762b1ab5077704700ff8e604ad9968de5dda4a21f4116673c177d593f231797f9877f5256d894609d55d5fcf323941069e0698660e2f443fd34c0cd2a8eb7ca319efef5cd7d93a8d3f06b442ffeea1485f2076bfd9fe47033872db5e9d0464440d926ca7526954417f5f3ff897f3764680e6e7d7ae876df0e2754f7c06c7c044841a448d56d5a37bab580d52baec3c85a570cd90c67292b4771c57235e17220e59da42faaf84bc50f40641089f658d0e5fb8a56e970276b7bb545aab5c09ff1314c5d69c1487138c061f7b2b4915bf50488b380a93136b74d0bea8b4b14bce9a4e37ef40d49ec37d50bdbb56da6a9565a163866ed23a1866e83bd1fc630e74164d5b70c0e9f54a50354e91d3e4ef14c4f6796935649ff86071e36f2ac34e48a86b3a6ba79ea522bac9fe3e700a2e481d32864653e50a8b975161f906e187a8af88cd94d8bd69047704dcd6ffeec0dfe6c7df3db5e53cbe34f0e3ded68e973040f9bbbb97c7e2056476d91af833837a581910b5a244cf231b0ec6041a73141d0102945126f77a86979edbac36e8c532cce3c2fdb372f782512ce2cbea55cdfc58dfaddbb697fe2d5461cf5a56a26b87bbfca25ae20dc52419b6f660ec21d287ae10933c18dde38b425beaa33c00fc1017aa6e132ab51bf2faecd0e1b3db3227c0f0b7ea96d9229d019bbe4b6460964045442aff7ee19bb14b21939aab6db9c465856ba2ae69e29f0286abea4cacce073f42251b8ffba6c37b9dd6847ab5b2cf4177a1982ccf4f1a96731e31164d4d75f6d44e8317d24573dd2243b7451aef7f6ffb56026bbf5aa7ad76260d88c3a2cd2c8ecca7a16fc63d089586e278873ee676aef009b83f9880a0eda682a9c7f5a82f4a18786a88305529be1730e7cb4201d6a0bd2e8b7cd676731d179d9265d08c157e235b5d72080705e8e41277483c2f57b48799412cb972613e105116f1e3dab1dfd7e183a21eb1f4f30e4ca98712707ccbe19c583db6cd7b74d9ab87a3de107d97f8c46c78e03bbf8fcbf27a551c98cc0e93426f589b346e204a83a0abd5dc319afebd51401a3b49ab915fc79d53aeb6223a4a8d1a053747ad6df256c4a0a6bee2db8086e3a7e350b586e6b71884d886ab2d3f9d024a9bdd14bd4ff7df945e1d905962147b2c8a012185252ebcd0d05e34a26fab2b490ecedee0d4c2dc6fddfb811337cc89aac28883480212c6d02e3fb49667778d8dfd9e167a5810d189e4af8380cff1fe5109ac0410385d7e47e87ab751e893ec7ff41459fce5c65cb370ee884f858db2d56a7a735831811405440fe35b4b2c33491d3b2031c1fe4ff4af5a908e3cacbab7a86a6fc982d8538225fb8b7d4dc4e724556928935be7b941c927e07a0155138995086a6fbb415e9cc45f0e070953843f0b910f56f702a9e9602c79ddde54ab0d8b41452dcfe9a78e5c074c119097af947ec70992a85b274b0c98185c25c54d25441ae4f645547df588ce93dde42d43f60507fd1a14a518aa9e3cc39b0cf142ef13f7b32578ffd0a3114bb1a04491f65cbadea013b0ed69d4d3cd09eafe4907bf69b9ff2fd75079250dd90d692c79e8391bd09ca7c33d501a66c191c82f64e3d6376db51e09bde4e5376ae0af686576ef6baa224fcefd40a8e89515ed7dcfa251087fcbb944b497ce5b6e8be35586957c1e5b4f91a8a1b69c3cb9bbe8b9166e61473d2de957c9589cfb5a23c1280c370232bfc466da890c5822a78565f23ba9bf48f4efa59160dcf182e2bee7de88b87d10ad9e8e59ebc7c3b88c2bb8bf1ef9d9f98d73f5fd36a31354b8e5b7f354a3b1e51e3a7b2bb308b5221b6177cdc4783d1176cbfcff0e7f30e177a954488c8647a33d187be81549439d8f60bc8eafc055417eddc263150efe224ebdc9a149d2c1a6c9c9434f5ae2d5a0d94069f0c29c1bfdc70bc8128060feedd6e32082da3528a1f91270e720194731c219182af464ee5ab4fd513c541880745e786e4486e1372180f4adefa3e46a521b5f7d3718432861809d163c32dfbef8d838c23259e049ed92c2dd50328846260fd1391cdd28bf505c99ca3d6a72d2e0c071518cde685547e5c5bdefedfc2ad965b1f6abd5a65f6cc8b6c9c76f59cc3084cd28c3cf5e2e63a2e821c4df225343a1633784907b041f822830b78d329cc52e4b510cdc03ace9ce29ed5d3bf9e441e1a3759dd464f5acadc24e059e5cf2226f7670d31796c0ca57f5f7b69191602c998710ac7e95dbe6874bd46f561983a71613850711631035127490e3f8e117d68a95de495dcc899156c6d5a467679722d72b01fe3acba66f897a42b8592404dcf834fd3d54d7b472f3b7340e25678eb7fbd9af70259f1c8b44f27baf6a80aca6fb041dc5a56dfbe0f8763e141c9b9bd9f924c76cc3b0f228cd02e596f08319479837ff95098dce71debe5b1998a07fabd076b9d7f7636c48753f2ecffcc790a631336d1a50460a5025a06a7d2ffe21bb716a17de16be44c69fe9ed11ff1cc03e972bdabcfc2b1ffd8a08422d989320e41191a800d657b2a8d71fd9781ba54b3c97d2f2bbcebe913d8eeca65993912eacd748ef66b49c066e23887b77e50de1f39f5709d5246ffcf3d1de62de656aaae91e2a629365b0eac52021d6ab5a500bfe1c6886928ad1dbba9b0a5e996943923e475990e9251cf5c2a6376d3ecdd49de99195d6c685f2fed77a7459319cd16f4d410cbac66453e8f14a5e67d4933fcb16a668f01144fbb1a35cb611804085138d5858e0a151090e30ff5c86c4ce8a598477e3657a4a2359db33f23320818d4649329e07fb327e73ac0592f4b0d7221c3ae6d442abc28f3e07fd1f480d13291c15178918c2ca35584d243971507ce76210da1b7624ad54eba85ae2a49d652477bf1e629eef5aa3face65949d82f111b7e05fe354edd237d741dd6c613a6421e0f992fd7e2ab64ef5b1ea0fd7bcb2c3f999df49fc1602d1425a3d10cf6ece299741f13c7ef5b5920bbcf517942e2fbb44944bbd248cba03922a74be32e0dbf2d852f307cb1dbaade30cb9fd904cbcf94c1c48b6a73a791896de276ff2f793fbaaf8840a90cfe64a97784ae617425baf1c95d3d42ca2be036545d32b70b745e75a88ea6a2432876fb9ccf003eadcfe03a9ace0ff6dc0c5f818fff7336ae40c1ebcda83fffe87cabdded81314ab04f9e7c5ef9c6f4e6f5a03c80001c74c00a3d8b79e53b8de270a4b881e2b1e3474856dca6e7312267023c341c1606a3e90f0a5a2f21f7258963e3e14e6ef48775464abc412fd3551eb694c175b0545bac1d4516b7d7ca091911b9234ccaf7dfb1fb1bf6f803dc5f3ca97461a54c9be1a0263f0ae046292314a241d72acab3c3fe36a1552514d028f53b15c10d77349555fac5606839d7ff97fe9d272de37da09ff1d8319b8576950e58f52b2721ffbd23f8e83c14b485658beff90355950803ec3ff33c3553f0dcde346b2dd8a8e4fa83e540cf554e9cf23d1651a2de5b8f4d3d4ee1f94dcf60271dd229c0d1c56c5996ab92c31af7b39a31626bbc5d74ecaedf0cd25506a5e88e9c924ec260b24f1270b55d21a4d548ee6968f01b390fca9ce5a548b93f571b229a6bfa201b0837c03132f976b7f8aae57d4c41223ab9344b41124733d4dd8a2bf00d649b7fed2f3a3f435f985dc261138ab19141f0411cd9c879b2866c83101cee4a55d7fa3c45c73ff34054a781c624da8d94355ec3cb9d90062eb59091c039888cea7c63ef4a1730992fbbee2f0d37daf683880b16b1f9eab591507e7f69f41282a2e2358a76173fccd31790e23bca465b68bb2363dac424bab0137555ab8b367626a2af15f9fc38885bee96690eaf41c2c59632cd30aa12f83fd737af94393388ec218c294add404d7b87ff5839385c581d5e7fd803f2019ce18fab661dde63d1a0c37340b4d91031c7d98589537ea84ba62395a4d64d0af4d1a9686a2d6c4b272a597ab40e244872404bf08db9aa0b4d8eafba62b74c345b67e548d39a820eefbc3565e02981a5d46a213c56b536c04405f706dce32d3bbf2b0b7894aa70059d656eef6ae6dff321a362a3766a0759a2fae6427869b69514c914050cdb8151ba9de0b03936539a68d6e86dc11e5f734c232ba7cb3d05dec50c93dc67a4fc5ae42ba4ddf61dbcce73e6cf4cab65779b711fad212d982b76faac404ca3b56ca01705e57a808c99da4cb0f7b2363e3e0e332380f48b2ffb720d66425724b2ad68ec775fe2baac29d0ef0498a572cb34c9c26d6dc0e55e5d3a3f759fc7e29698df22bc08c79d0eb57c6ab6d512ce46fb24d3147e0826a89f0650481d0f3b0a6b1bb96433a4d8d15cc14ca402d8d9fca94c98c421911bc02fa6b066ed9d5d6c1a137b5b5c69c04cec640e59b0b091461de67f98facf1e5182da10ab405af34af7a786f3c354bc07f77574b629e2ee93617e1cd1e4e4ab2dead1b86767616ac65ccf38f94686f020942c08a5d94a7efa52e6961643f836c87937d0ec4d75824a069576f905b29d3654df68fcc5fd901078282f6d7e4508e73b43d6f8b1965c2393f2f5b56496eaa125487cbb0239173ab3fe864c6384cdc86a1dc420038287a7124201c7dabcb2c7339073274defd230606e28182ef15530349227a4e16d2ee76e2eef524fe498ed5d3bbc0c1115255da4b21a5513ad9dbcd988f1b957ef915dabf71b6a12191476030d99a4b214e281d7daded198d1d8a9f601b7ff7f96d3cab3960118bf69646d34dc26553d5d15e9f54c44f3ac9a4f439a2b41bb1587b9738b62c1dcaa40ddadb8c44dd9332c3591aafff9c2c04f657daf4f2a056556623948276b48c4d38369403ca35fc8a1055ebf3dbff9c2be2fdbdfdebc6ddd7f55466624e27a1ae41d9af3c237dc80aefde15c0af5f729254cfd6b09e4c6c5fb35bfc7e1a66b26436bc56406a2742e07af40875d915905d7e8cb82e8a53cdeaaf082ce0cd12f343d42802d31ff54b1cd8d091d4daebeeca1008b87f0479dea0d83a078af254471dfec93b48db020d29b10322f96efa37a835a7527b14c4986b42a7cb75ae2139f26c86d1165fa67b52f88d02a727019500665bc4ef808663cea5e562654ae1a1d46ff094c9160ce29620e9ea5feb98f527d7380bda0ded9751bf58a8830ba761df8db7db720ee7f30761ce1748009d3ddb517759a6aa65ac399f81d9a429719c217d3b92fddb94279e3545177d3d14e1c8a78b104f011b622a4d3a2f45234aa754220b28ff9d3f438d41667395199e93042a45fd0b4c1a08dd905d6afd456f6c058145b8e857978d994d544c9234d569f4b21ecdbe60e5d02d7c357f42211769f9520bad90dc903348c1d5f41f4248e7c864a2b6b4d514edd756456c946a8663fc937a41739d039b57208757ecd722793d2c64ccf5ad660830cf2995af19e7a1faacde1265e2434137007a12e50f2a7261c19366ae4a866924b5169f42864158bbdc4b390c04553ae73f0516ddcd1540d45acb29cc6e42d9c9cd8655ab965a2164a8dbd2c3add505404e47e7a15b261f2f1bba807a5c4ef3d66f203d989c3edbc64834e9501d77a56625eaec47635ee7eeb9c9c0cf84fccd259206cb15bea8f6f2100fc8be190e3fb82250fc6931d692ac1ae299cbe17a44998f0409154d2d4956ace9a1b9c6dc16592e0902de1f92f204a452defa32c1f5dcee3f23ad81842c79e81808d1771a78b9663b8aa1b59772d96eea9fc7341386122f2a6974805c06bdf8293ec5d61ac94269b15f0e90d54d301da62c9f1e69db55df8b0289cc7180cca54e762c19fd03e71ed258bf0ca20106c080fae24270f3ec67bf9bfb992a2036ec8e595567f7f1b0df1285a83b375dc323d1228ba220418edf340fe1f56497d5f99700cc66814fa76dd7b0290fe409ae052863d2808950db5e4bbe4e961149cdba379d73a729374153de6589e77a3fbd11206cc512d59ca418657786e4e7f3aa02da78cb0ce237a73c6c781d61887463f7c6ed82e42b1813611dc0d45cf12d2ee22be54d47a82884d03a5ac00de966a3fbcdc67694c110448cac8444beaba7e89a221c9c13b0f8d55e0e32935bfabe323a72498a30a7ef563fbf090d1bfdc9178051f0c2540add82922620266bb748da1c5dd1063ad69e6cf7ec77553cb53a4b694c11a31538b051e7d357f58a4dd5d3427f2706b4213b9df6ca962289b7982947c72f80128b86e4c392bcb4c39ac8f890c7e0d0bfab8850c60abf3a4a8b522e411d1f53a0f3435713deaabe9d67d04e8f99c57f21c66c29a79e7cacdbd8f10e05d1ffb2b06cd50ecf95eb756ba7a5311bb80bc4ed964ce1d5e754ffca07da33691e391e993202d72b88491a7a8a141f4a00e1ddf4413d89841331556a8314ac751f85aac58a6bb660d3e03a1c5ff7a2074fc9930e30d63fde9dc65114d2f0117c198491a5d4a4924823fb06a0a70771149bc31a1e0401c45a699db6af449cd2437e520fe534164f09e8c63afb6fc0d259c49d62a8c5ccd2dc7476cdf1d3bf8551cb1488a069d56cbae44faad0746fc933cec4bdbe32232c424443d90c8c302247b71dbb185543fcf89845191e6647afa21637757bf34a4958db955f45e3390c26e54689e09512882b2c79b0df1c4bd50cc70d3f0cd4f447d81283814aed3033b09bce7b451ec9b41ea4eb3aa1526e0e4053eb48479359b19003803f2595992fd93fec84ff29de7643783b5b3b92120045259f3384cf3eceb188a3a88bb0a71a09c09a037b1c2e4de5851616908f2ba43312fc735edf08a673a68072aba6b80229341db1a3dbed7e47131e5a81df61a027cedd055a7d6a928817ad44c81619cf611c648f1882232d082f52e54425f0d81b0f61f29d517e3afba4b984a86233b2b82368ed5c95aa775abe04bc6c34eb428ab090b439abe5c7cd0daa750e38534b4011d7ba119f3ef6cd7bbc545c11cf299b0738f22984e79532c1c67aeb492775c5eba9cae11c00f7e3052ceffb641525dd95db319d34af30ad3d93228f8090e2a938653fe37a59d6a3e9dfdb2f91d3c6ef8b7034fc31c27c7f201f08166a97a72aef6e4a4bd2ad6cc6e82cc7bc8f64a8d9f0528d1604ca24de9a5dd440964073483a6ba843ddf8e87acc80941491c877b91e1cbce6ed399d5854fe430527310562b6dae0b307275251aee7b0afa400d9f29de71e1ab0b555b5619c94707abbab11f0baca4b096653d87510adbc8529bf131d395b81526b9cf9ad1a36a5cf88f2a0c44652c5dc3b9ac89df78f8908741b076851ac5959b55a7e5030935df72b3608b86f6330b8018ffaf2db61fa233418763fbdaa896552db2ab405406186ee3f7094c9e34b2c8e773cef8ef39273c25961deb657f67b80c443db70712b03e6a42b5975d1c9f94643fc6dccb13801a185c737fdfd4ff75519957fd311865ef2866b9507774db5e117adb84a46528a7f304e91137d585bd4da5825419bb62f535fae44b9efc17b4ebfa05e8b96d3bce0340741f54b997d5847287e9916a253f5428d5c3f1ce9ee0c6f4409e761c277ef29148494dbd89a371edc64fc480dca429af7b011ed61990c22945fd6bbd9e5c23ff7b67277758a6a8e5923ae79979f2424a603e1fbf8b79d76e0ed5ff3041bc359b3b602d16197616d8e89809c5d01ad4ab393fc83c095140ae9d8d03a272417ddb94986a0937b508939addda9443f5ea1e3ad772eb34868ab59783c7dc68f8d564b7097c21332caf27dd2f6d8fb881e7d3b8c4e77f3fdfeba3dd6f69dbf651e498d3fbca27fd1ba040761873e666476d48d134d08b6c809e2d202131e073dceb123da5f4bdda8c23e77d06fc058fb86bf8a6320770dd43262051f48a41413e409d3e8bb283e9bc6530e43e644d00923bb028f593c0d65fcdaaf3c4428125acf5655a581e82f2566eb6a04e64e1ad95dc54828940efbd1ec84d2be640ba304415be4c980467b6acedc7d8eb241d752e1b004f1f27ec1d53d1d869771fa484d0b39364483859ac100eacad3919ae072e5374f71533a137bbef680a570ad22581590a2b5c92619f44b92b1803b761d9d45c13fa19427f86bd4714ee6891e22d08c57573f0c9c01562519edf6b427e5902d9239810638a30cdf2354126820f0ea9477f8b3783e1d7ef74f63112daec0902030be729e89398c5cfcb81063740d744dbc6113a4c40fed1c64bf9af971e2cac58ebc3ff28a2ac77ddff955224b34ba4b0e9a5f6f29e4c9cef65984248f05921c20014a446fb2dd1d3ccb3a78a93d1b228cdfff5fad1ad2a7d8b3880ba964c452398107ad5b220239f43210cae2ef3d123282680ff108f82a456c1685eddf234c22ba032c41cf04c8c9d225db69800c4970b169685704033537d56c35b61d6607c73d13261e00a06fefbc2e56c5a91bb40311d51fbac2ca58f0921fc7e884e7f1dd84a76129ff55097fc94963b1d3a70b8c273b008d182cc37753bab5141d1c917b30a9cbb985076151dc3c73b5a83017cd877f155edf35c23ae4970a134d86042605f26afe43e2e3302b574b210f2187247c51530384b45b4c5217fc506aa4d4fe736157f36fd824e64ecadeeabccadc6d3e785874cd5d05c1e78c3cd6429659faf41b75f61edbe007cbc9b7f67726369ebbcd6f2991ee7f9aa5bd360eec8f2bd252695c15109d99ffc773ff8c27e47ee066b84622e95cd38355bc0626c75934cdaf5f0329f4034373341d92f2b5389ddd0d1a768b56799a91d6152c44560180b7e64bc46466951b87d1ac630e99abf2197d0a7ef6d2989bb1310a6002bdd0508f6b891143d3f0d0e2acf39d664294d7cb94eb93ca9f28cc767e07f1e8b62cb8163ff90d85949baef944c0d4cca1b6ae92b35f6159df2250f7b691339d982e7d6402859bc7071e639a9fc5a500c4d1779e95dceb3d625a96f2853cfce20b1071bb531884636c3173992a94a39f8ccad23b4468b95f5922d6087651db3f77877734bc85b16e12d9eafcee1e7c3de9530d2715acdd7ae97a627ee0f29eba9a1acffb15fdf871742486848793913dbb59c30de778924558581c4c8708cead5b3e906f9cd4eeb69cd9d42f1ba3fe0cd6d87e3a0863bcd7427fda70a2e33497c061cb8f593b65e5d1a314ce311f3aa601022bfe80d5a1f06d8bebd0e611234af2724a084d1def66fd3e7987ce3c118cd282f40a5205a79dc32358d30589281edfe6d3ec20e4bf73be77f26fd31eee458f2f17f3c422c9a8a0dfc7fb1849fa1ead1a08c7857e571669ecc9a72c5ecba0e1c19164fd51026e006d471dccf27afefd98c504bc4c365b00ef8d7ed9c9621adc583e7d4788c523029809fed8814689a76dc6d893c535fa752ead89fa9a52d4f4295574a880153a9fae5d7d85b76c2e54b7642786927fa6a01b965838e21c5a769c149dc5b3f9f58a92595aac02e15fad3a8e2b4a403d26ff65e6e9fd0b2ae80597c4d34454170bbd7a619fd1100271dabcf10a990b9974d848cdc212d7acde160525bfebea8dc77d91b9210cc0e90bd47f819a9a99cca3d525d2966e02649df330cd98548952d4cc88f3e67e5ab7938c31aad3541bdbac89033840427c37e6dc39e1bf31e6e2c36bc8612546bf7e00952a399ba4de22b311db391bbc443187ef33da872f198c87be4eeb9c29ec2180e4c42976a5868181dc3709141277522bfe733f9da6d8bdf6fbd162561f683072121d4aaca8bba10590860eeaaed42f89bdf580319012ac33940f78bc1593cf02bb4b6c670ae41f979dfae4f6018660a473c90f828bd2e4dec205b312bcdf283072bb1f90f4377560cf38c14434bb61fac5975d98301878ab127a29827ab5820a21a6340c1a63f7a8ad04ff64ac3f1312e6fb52f0ffe525180b78f51091c60b9919eec8b3a9ac152aac90ebf7b71ec20ad4e621793bc820d2a0f405b59ba9793e8addda369a7777b7e9b70d0995aa40f8321b88df546e9908b7d9606d3452f6c6abc35f8e5e382062ac301bc40739ad19937e709fed55641575cc6633af78a218889b629ba5a444c3c95b4e0d4c7ef8d2ddbf70808c0c1c770097c5c22edc6570dd7bd041f98a79bbce523c1cd1aea2b6aec770790b00bf498467f15ab071b11f29ac4067585d083cc31c9bd630e9ce2edd6de73e30ba47abfdc082752fd0e20face01ad4512e817487a35a7f4b034ebfefe39939084b1a67cf9b4edddf374c8cd804813224f49fc3dea597b1d40c1414861f533651aa003b29cb3f5ad971060be6c69d5e413d21f3993d8108fae8e3d620949ca9b4ecc3da675c7685f56757f55329a9dc5fda08a3a058c812182df4c0c798d54d1a43836ebb93c4bcce16eeb3736f1e45dd2f9e925ea434b1bd79b5cd8d725e950ccf7cb25771d48ab2dcbd93ab70fa289209de3aed90bb9dda2810329569adb9446e9aaec0fb658c0f26939fb39f66b41dfcb5554af46064631634f34c85b41d25a77ce6c1035a471da6a0ccc766a04750337aec4f29332b97de14235c306ad787f6a6f28c38fc3e6a543e40b38c6aff60c469e2a27cf6b64a3bb263f15121abf85bf7b2fd4f4a9b64f7fb86e62590b8b23c3812786b35a48adb3de6e311af06014bbdc2c9812b2ba5a10e51bdc847e9729ecba2f324607bed86f023b76d5ceb5c22995989076cc653c2918b04eed9186ab1c639b85df894f76c11a456c7cbb2bc28cf405ba05fff859d541cd34ab14dce3cd0f8e8d5aa5c3c56c8d825ee5db7e142694b28fd8cb1cc6b43fb07a56bbf20ff1811823473f6e7f403c91f6d9cbc82a7403da80836b9831280153e8eccd8e39b3714310356162b720e815c645a541ba97c9b4f2e2cf1e7602d57dcc688338d2b48dcf931976bc6989dc659100fb36d29448b40fbcffac35d78641a885062ba82d830f7efbfb34450b9951518f8c2ba859734f7fd1a9be3c38d364fb055ff16831e02c12f65f35cfbde779e5fdfed6d750522d667383aef1a5d1147226fd935658ba605435fb2ef57b60a9205d5667381e6b6f1df31d7c6a8614dc2ba96c3ce2a61680ac5ad94ce8abc07e4f0915a4e2144dca4f2d4c1aea0241c12b3da39837499350b50ca51fa0b12f6c9b97efc480ce6972c3614f992659729acf98f65f602cab2d87b0f267c171d92b3701c9ca7aafd8e5dfa96e032d17b9964345a7d2b60b9e5a4f3c943aebaa54a1e3562baed1201dc8f16342083f26ef6798730bcdc97ea50265bd3aaa243914c7f12bc3d2565fe7fbcf44ff21b2ba66ae4803378025646ca29386c747e970239a598f54bc5f6b2c9e78e74a2e10e70ef52c70ebf1c4c5ef83450cb07763616482eeae93c509deadc327aa1b14d9e5511a403b20b8079550ee9549f469782a54f01eb987d5a3e0a3f7c2963b9e876b7256bdd17bd2827c7093182e0e7b9f809057dcfdd172d12db1f7695d5b8e162fefab694fc738b8af1961938e8a740d41ccdc4a503dc395f4e397be5f926f78b16620c21ffab6f1d36026b535b23cc4a7077b388025cbce047821100af6fab824740dc3b386147998bb05ae282ae0194c325826e929bbabbc4d70ef8cbaec140a17d0d698ad4f8391eb97bd92990fac0000ad845056997fa557e4dcfed35abee16db501bc1460304b6e4a15482f65cfdc712fa4aac8941965b2a397c531a000fb9d29ed1374c1402e9660190dd39dc0289caaa358cdffc2f056acc71339d68a6a0a7d365f9ce58afb7b4cb021cbf903f01f574263604403a16624ffe71e3f6482a7badcd2a8b62c393ea879fda081a21a36aad469f2ea23c97e49e0ce9403c5d763a64abea41c7a02644ef5a8ad0e2cc776804ca03bcb38e179143d4652ea8d80a2e02ba16749da543a7419d33df50ec77e36b172eb2c78d79e5d6057dd1359f7586afcba226ba98023b136621ef70f2f1ebbf7b7f66343d197ac459dd6ed54610a60043b7882b4a05517a0656e601d7e70bf7ecc22b9b30fc9b29d21331e41b1a2374afc401ef405e737bab4bfe00275a14f40766ba37d44e1b5e26c4b357ea7df1ea5fb33de16934e0f7e16d0895da0c0a3cf7e17c722f810f5ab905dd19c7db8ad08a86e3b17580d11dbef979f5c4dab73af339b2553a576ccd0bfd42a2123103b6e5e9d0357fec571276a70214a0e851b4448cbb363a9153a4f96848f473ca1ac2273e5530ed4d3f69feb2bd00da24ec70b988a16fb8b448252989f08d9a86d6a424f85a0d6571cc6b375198e6bc0593c0001575eed8f79f9fb93f92093ab9722d2c196da428a9a6746794260eea8f5f76c9fa4289d0814a4060a1d2737bf5219c52b892be1b8315b6565c00d3d5eeb867365697c7f28676238e6281eaf08babfe7f5f43b8b047a9e7937d96bce76321b131096fa50cf4cc0fe008a05796da2773266c6857a8ed899da066a866708597f94339d9ca4db6f7c2f280c71124d32ba8626975c45e8bf64e16a5d1037628e8ae3115a5e86468d8e5a94529dfd11474d01d646671fef7cc2a31454279561c35b24690cd641beb42f657c14a4438ad8a5d186bcb71462acfd3df660c05f0433b3dca1de938ac1cb6213284f195d34797a415df409fa3abdcd59fb3d668c388c897fbe8efb7d9169f6662d691ff099321f16dd79f27a4d582731ed925a50a88691134a7aeaf71d4b6bc6dcdf4fb69ba6cb4c0627121463d3dde2c2180c8ebffc1be399c7f05b0749dccac3ae733c36574df20981161abf710a16d022625180bc94e530baa02abde36bdceec2813b4d5346a309be005275e895ee49b9542522326c841146ab3bac8a7eaf2b08459d50a8e688b4dcec3be73b001d5be069df3b274280a1c86c34ff1fafce2d27e271c460fe793d155db018be5f4e0c556bdf8177290e2af60120a4528c0ad1d5e511ca8c0f94d755d4bda2d73d2d5baaf3575477cfeee5fa4b2c6b086a53be34ceb44eba4f50e90f30765398f3cac797af0d98e4a2c617f9dc19d05c4e7e4302dcd5432034961fdfdaf4d4055b65ead84f17d09a172b8dd80990f2d64ae7b99d49af4b367b90fee34011624d8743177ada0efc981e3ef9cd5c2be4562125fe232d2c36932582029abe0f49a360a2bfa9ce00e096294e2b9055fd43285b47659f341e58fde385bc77cab9913f9c4b4c4174566e862f45e1cd726f8369de8d9efcd909bc616a2fed15a2c4cd40b70841e894a987b2c045a2b9dd4e994ee81a9b2821e8e341164cb8aa21b58a80d9f96f10a746ccb666fac82623e1ca3971fef424c886a3c04028294508609fea0133a3019f31c8944507d71babdaf75c34c2301bbb5e814bc9c4850458a30994033893414925c84518faffb269368bffcde056fcf4a6d6bc7698611452ea50e5113d75242bffd4637aa6bc3e8a50b5b7aeda87d7f488eafded74c4fffa86774bc9cfb5aac9ca4a37b450acbe3ea8c2f74930ed1b9c0a0c87f757bfa9e78d7f7f7dbf47d4930706f1cd93c17d55e6f3587b94ad6072af2379c11d484932260cdede62b620d93ee6dea71892ab06a4bf6502d4cb3d0686a569bc8fe2997b51fcf606b19959d56195840209024e2162d5829240eed902c1c9a5095649005b99c5eed7ac7fd8c3fb0be7a8121f799ebc5fc58082da67dcee0538a71d4d2ac344c6de767cd02cf250e7d576a13bddc699ebcb0a408ea89ee463b5b2ac62eee627c3f9df50ebb69ff9463cc4bcdb670d88a278539339fef3673c4f86269370c21411c458f2cfded555feb367750b47f14678ef0d80b20f1333d63324128449927222c37b0cdf57804e7dabec4ca87d465dd5cd5fea85f8e811845c5c2a136315dfc4ef8b3fc6dc77410d4d44c19aeabd60b88530d9e47c3b09fff5918792e959b5f70a80f06731e713f79e58351468eb93adfa7cc36612e838dfa82a9d0df26e9df4e6bb284d2a0d8dc4c3fcba4240c8099fcedb9ff1e90dcd76f0ba069f4c88842f645116c65a9df6b00159856639d401d6399ee02a6db96089a7ba367757965a8ee1d7aa23a0a64f63b910b3319f9743eadb4a2b71ae000c4327b3b59dd96bcd911840cf6acd48840d60f6932840526cdff8ec8297fbfd944a70e42d232f67d7275cbf413663d07f1a2d717b18f9a3fc88e4e431d4a8ff4f337be79d8d290c124bc21635e9b825f46eac19ab7bdaa9e55926c9ec738851322cfa9284e0a7bcfc42fd9516bafe498af9bdf248737971ca794c672f15cf2e47cc42f240aa5fdf9c05c0fe8234e089d7e644abc73e0a7eee2c51809ff98b4fda9bfaeab55b5d4294a7933f41d1143984e59b18bb8ef07107828a1dd5c03595eaaa9695a95216ebc653004cb381f4d0a043d84ff8903fe8d137e0827c2f0c8115dd397cbd6de35e9fc51ddd758a55ec596388acb4d183b4f176fdc9f3a78a328ef6fecb5c0f1f017da30841f4cbd472ff6979009f6bb58d29a2514d940f9d0ee78248357c4df61abd6bf640451ed6b8977890252d41c6b97d4f1202a1aab83787342aaaaeb2985b8739c4190a5f2d1db43f86054c0d70b68cd64bebe1d9fd07a83bfb8ade587601757b041f5508f1ad7275c83827844dba1fd7605d334c5d723bdfa48577daff6fb59b9212ee74f3ed893353ebf7fb453073004b10165daa7d97f08a9ea7133a8e10f161ad8b5b34755df3166561ee7735979084c2064fa5860bdfd228c542f4ec983c28a416f9a35e8777eb8ab1d4f77f78bc8265291b37a8465d6c9d5090aa2d2b01b113570af38384db46a07a323f2ce88d0e000153a0315c5bd21cd78090c401ef824579007a6b9d8445900d3e079bf3a45ddbfe50fc6be284333e71386d432784e805be09f5f63ee86d3ad1d2d7b70876a980d094988e66ed7300c6dd557ebde5e1ab188cea167ac31f2b85590cb5b7f5b756f613a9ddaf838fdf1ba2a1aaed93bb15ec62e4b43ce430a6a4365788bf6c2ffa70c67fe75cf931ffa5bdbfd27ff677f02b9a1deb7a795c5d17bc4b9dd6476521cfab01f0eed70303dc865f278eb331bcf0a3f3d5dd392ab46992528e35aff89e1f62e720ac42ff4a4d5737b8f6310a95e0a4075c325a497f8e7bee568c4205fb7d13b57e5e12097fab417adb501263e77d53f87c9c39c2ef988c80abf4ed45e296cda6869482046fd17b2a97bd6e81bcc5ee5ec7533ac08e78d85cda64b82a7bf30be0117548eb8dc49621ea5f3c1e61ece34c5d3a17101a359509111f6080d92b95b0f711f5f6d5236d19a616509befed00213bdbeb939700f0e836d3dcc9af703a3c3c26320a4da3ab35e85bb1019253de7fe163dd3e4f2e824dc16f7bc85a8f07db3fb9a966a1b8f5fc38f278454ffc26298886b6355cec5fd4a6268cee58c0fa7d0fe301d740224dc2a819edeb4785028272e81ef57394cbe809e2dfc84f4a6defeafada0e2e71294bd3c1ffadd3d666c6cf715cff9e9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
