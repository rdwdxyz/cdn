<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"538290830b1e082d73edcfffebd09ab212405620df680ff8b649bfc3d02b747f4864f3238e9d83dc6199b3bb0a99e6a82ce58afe8aee4a89fc785c34896c063c5706cd78498a063a8e8e3f74dd6a87a1acbe830419c34985245b797bdebe4a77cbee5c8e7e8ddec6d07f04fc6fe1578b6b0da92cec9937065b64cb0f88a93ee6a38ef37126d6848b259172edddea40a75946210de62d626457ea703ccdef499a13b34e08805275eb16620134170e31e32c9c1e9888c052ab315a7b51bfd959ca266439b79af85d1cab33ad377216660d3435c0b56e3c092a2dde262ad206afba5e59e814c267c805dea9e310a55b3144b5540ba4c307022728879809c562672dbca7bb2994342d106ec41bdc71f5208dcfa68a2e77d355ffd60ac539097c2c6898eb7f222891f23fb803886fddb507701eb67a545c0b9e62b3176bd8a794b3768355b1ee836a50a48d81ddd7a27b828d7d781646bc6fbb63bdcd29eb267dc1cf0c16172321077d4189aad1a9d52d28204fba1a12649f023fba61f4992ece21fdeacb003e201bf8b814a3756864f7b417935944a6c110ee0496436a7bc2aff5e19d9fa48d03bc532aff52374863f6324ede5324c8bcb52f183a3c24cb45dbe6b76b3e22c3ecf1b86ac1e318ec99808041b9c7adbdd7db1939aac98a1462fbcd9caea85ecf8a3b233295cc4de9afe29ed2d0b56768318724fe8f995a0dc96847ffcfa21e24c23708d4aceee8b60197d8fee79c83111d7eeeac5bf7725505ea93673013a6955422057b7b45b2797fbd2f71cbbdb77eeebb055a30b7b28419c6ca36458769f6665c6dcd5ba951bf155d4065c70f7a10e930b96ffce2183e0b919b04d9d14ac21a043b1bba57a94055e089f594f643aa3c9171cd8f3b053cfdb7a429550ab1e575321d00c8f105964eb405063b7f8c6c386d4e057cd89c5b712410f8b2f44018adb6c4497d0f4a7a6f88e50ec7000e692fc38f7082cb45e0052efdc1c7278c19ee8ac7afb36d936ef762e1c9c5f771c3b04c0e7ca22137854f0555e1169e50e7c8feb59fb7138103e8c95442ca14f032034ed40bb82e66b78f25c41d1d098d5dba688f095d81ff0255effd4067b6bed02fbc182457b330ce4eea2faaaa4c2b8ed60240931a4e07b34b355fe29b49e285905af0a52b138357e927c0b7fd4155a573d81bf5fc1e9d47563c9551a1b6ab50acf5313c70f1cdef8586accaa7a12c3165843885cd9601c1e6f6fd751eab80bed5ddb43da69b668900564aaef2808d09addc6b153f2df6cf9f5b7c2911729dbd53661119428ba7913a43c1f31da8341bb0cd3c2521e3eecf54ceb374ec53f18b20d3c206efe441563a049de2c52e8174559c83e26ced9625239c3b5bc6225829b84c054a6105e3ddb425192418e742d251bb23bdde6b95c2c0973133963a0eeda52f50d0f32ff4ca0ca753d17c26e852a88308c69b8d3bf6dac96d87e3af5bf5bcf91f0aae0458b7dae3e47b328a48f7760f6264b7b560d478682ff84a2dbce9f5b47d7ad419e74fec6d5be63b0c293cd819a20429bd3eedb578d8f3a7ce49b98e6c8a583559cd6a6fa166abf4be73a6de4bb38b3a39e14693ef87bffbac889d16ab0cd08795272a6f3abc13e475dd058821b4bced4d25b20d24813d3f01b09d40145b9253620c7fe9bf4d752597f123db24be95f3a6a9d6d614fbbdf90e47781403fd49d3a08f66b4d347fc94ee6981793ebfc2e9f7d76ba5f08d4f36f19c12b5fbe0019c58e3787a96254c9cc62b00814bb4527513b6d7c0994383d437e7b94206b77b23b7e767f02478fb84c72049f2e3144981a4b4f67dba21e7e62843b7ea88c613322fe6022c3ebc67e5d23cbc3857e4f79066ecc4a0ab10896569e20917273a87fc0be3f4974813651ae1fd60797f72e4a0e9a5555acbe6788637fb630093ebf23ec11189ae2a70f6d9dc19bf0308f97b24cb3f104610b867fb64ebd0253eaccb527b2eedada27a7b9b1ead2f360dc3960806bfea5511c724aba5a8c50e24e846afec4e985686e96c68448b5a7fd14ea07687fbfbeb07578bb40f9c79d336397b141d02560dc173a1db1c56f9c8f520b8f5c88a0c23b0ea7cfa75127b589903f5908276eb98bc0fcfba0fae3d6db7b167a947a63dd4d214559fa87b418dff29ee6b364731675d73b9d803fd0347f8c30dd67d5cb0fc9be441d8d5d5b595f998b72b9e039521a8ff40e73917d6d4ee3c18d7905f2d8303a350a026a46b9931a32878f5968db13f3cc481d256f085f3bbeb277c04c7ff89f5013df71f5a421c37a1c0d86e44754da1a61f4e0b0bd20627f7fe42dbfd23c2c578db7931a6c633e028c4fc77e915b744c775cbbf50ce37314126a10eb746dca0569c2be805ec0d039f997efb0392c81418b32fcb340079246f41d2500c038b356dcea9688d0de7d4764a75506a95b1a89437807a2091974f2e0ab95999e0774b650e260974f36d0fc71fba76e1d637270579c8300c0c26e24a8390ce5d4530df4d120b09f099bafdf0500688db62660087ffc04587f4e7d6904bdcabd24fad92a36f3d4216d7dc8055441fdb447f38374822b5e5076520fe67d5e060f52480b89c7363724bdae3a60e43de8a63b7d86dafb0ad904b57c4dff0107b581579ca7d1af72cb82312458a12f591b963705ede542946d89945b23e7be4047c239937878410e43da4ee80e848b9efd4eac6cc1862b6f13d64b0ad8522c4b3f6c9c000c31521bcec768574d66fdf9f211b1a8f971b23806367ecada02848056e2a86182a49e3e2df74240ee000d8a1e7eb1de7983a079c71e184571113930a01331f1035916fb213a6cb30863799e53bd9cbaf84f9533bb9232c63ebc6e604d2aae0998eee439d40c8f20df91668b3215b6b50f90880bc23031d566c835672a9394fc771fdd2909517a27af1f8fdae67e7c008a31aa29737e2fc6bb8320d4529d4ffa75174480d887cd0f3e6dd1c000125cad8088befb2f917cdabf3f7537caaf9a23424d415e5022381da02b4c9fee140ee9303a8bb065fb3351f3292b97dff18300e6f7fcf538a84fae9839d1ac4716ae6a8d2e8166ac69194ad2d450a63debeadbc143f6b5ae1c8f81fccb0f656eb231a8fb6a26f3c01fb407d8b93dd12fa17ef17d231d31b7c1300bc834a152d149ce45f713ae241f5acd5f7036a2c1b34fff466825dd9a7cce73c64e636f5c69ee66a98dedbe14f47126922ad0b22fda8b1102188c8c41110e3d970f50d51d7f8fbd0610175fa77b671b83754d1efec51132e9da6ae629680e08d2435204a79c7669d7f7b49633f06d3a7f155952a67e6256fac732eb6794db93821bfd6d5a7026067a6b5cdd8e1d3628e79ad91167f7acb1f03f86cc379831b856b0ea6b455490a4d276a1a7ff5834afeee1ab8fa5ef4c9a8bc10a661bf489962b6d90049b7bac70061d2a61afb48df2db1d9794464f08af8708e163f45332957830a142952abc3c2b17fa69787728496401b801aab239d0ebb07a90cdc25e2d55ae1f8c6b92ab794beaec62ca442daab5e33c2501730f68d32a5faad85c3f8925724efa7ca4876299e9a2b25dab814743028bba3a503e5e3bd2627f1eafa6075feb9c359b734638d8cf3136b50faf878e7950e535e40bc414701d6b121c9233a8fde4edfa345cd98283d25f07302e392610c7faf6a8ed1381cecfa479bd86d19f88f3e903fafd4437225b4f7bea13ba99d08a6a7497a8731d0fb84c00215eaf79de26eba52c4e3b1cf2e9f7c84c58fbed7c41febe4173ab7ac6c3eb9bae2e3f0316d95b0e21ba6ae1b4cc9c9e5355993a9ef6aa1794f89d81fd2c6a679f2d45c9dd27d6f91fbb25e0f470d0f665e068b584d961abd8b022ab37cb6ff95853336dc899b73f66990f0cf8f15e93a40cf70cb81decf5cc37c513877c1e3b2c5678d5f4f06ad9e3bf8de058bd23d05bf1447258ccca14fc4f765ef8d11dff5ebc7ad2ed258c9751fab5e05a38dc16814ec412c21ef322d705c814bbf635d126435fb18f5ec3b39f5cb5ba89146f5a65c9f762e29035d59eca94632244bc2f6f27bbcec9c3da7ecb77a6d8ff65d5d084d5da358e49c6f8b8dc4a5e681b52147e3d3103efa214a924bbbd027dc252808d67854b429421e02dd78f4a9dad3f840f0c7f768102dcc291e4038b0766b3afaee02b574c5273db44fdd17c75840c56d3e7fd46d4b2640fc4d681e3691b88b50ca050bd18b4ccc53f4ab0f700f4cff6cfc0895cf0821fd3ee1cb7ffa9ad243c3fb6312afa7b09d7189010662f21265219ff9193945d54ea3bce27336017f85460043e8e4b4357ea9c7c76d5b5bc44cc2eadef84bf02c9e61fae84e8ec4f7213562125f95656f4901fae9e2e7d01c69fa71097e7b6bc62d8ccfd2afaa7d5f8ca598d4d6541a8b36272bdc0ae63e65b03057db57cdbdb50784ec9344882bbeaba96fdae050eb48b2d847fb08dedeab138bdd5d11e48caae15ab4d74d15e9a9ee27096f25f7ac083b4b59287d28a21f6be1791bbf09ecdf7bc11853598da4181794009a2711e2519fef1bd003032162323ca8f9440c6258d2e69cd9cbd18a2ecdaada8c50c27dc8c6aa369d4c14cb611a9764fb66d36f039360722482340c777e2d484d9886f460e891ab83112de94a363289901b27f65e162824a2083c81119f291ac8d1e3a00da7f1346801ce8166fb4c977cdf2fadea354922fefb09a3c8f899dcdeac03159870b4545adf4db842f7444c9282f7b784acf094fa42eb5b6edd4f2457e7aa996c0acd4174e56d1afa6dcbc2bf4616417bf985aaa7701e32706981a22486a5f528efb32c4c0981d0a4514f03596a3b5fe230c43d4bf6b373c7d6628cde8db3db93a81e59e91e4a0349301ebbc973902ea709f67badfc902a9653bd49da74c7c5f67d1cf165e5e5298f96f7db832fd65c30af70b7fb51e02543157c648da9b0e2d55a44b0fd1aeb4742aefa08ef3c45694e54f9c80d4a17ba076fde3fdbf2294d3ac09fb7be4d7477606b94cfa94d211e9a28f470043b7d7d26f9b3b9f488869a8bc9e4b84e2234a2647340f56e9df567d3b55e7f19f59100c13ce71de6a9179a938f1ae3c3d4be318d918e2afbbaa20fe8d873b6c6259a535602190a27723e6ee4486c8e11de827efa0cce4be13d2f41fdf1ddbfa41942c05ad32179d8236040fa424bed5c037a45e5741b4b4a510a9b6c7b6c9ba00d6227d4bc5a5f1355de7bae5a4954a3da9b1414377f71c6239d44d5ce4fbcad11e3144b9ed739179d48b44f7fb987dddad375c656109506595eccd47b7f5bc6796f9d3595bb8fe54c881cd2b618331ed44a6bbddc0b3cde578a8db0d25f940a4af3c52c30f99cec6e47b33dad0e183e8abdd4372d0c5ad307c724ba6288ddaa0f2447038f0bce630805cb73167684685dbeea493fa612120bd57ff38e85514640ef096d87d5959a2059da7fa7e8827a7590b46c2f2bc6a9a4feac54471103e9e8a5731d7c7a571aeb5b9d8f823ab44894548915a9cbb0cbae3beb1bd87fff9790a8d5ffaae70ebcbccbc04fa9cd36f7b1068d31a542a8e2563f16781fb8bbcd979ce4d01a6edebd449db4076758fd6870e6bae1390f4281a2924a3373335ce15bbbf92449ff2d840c9b55a579242dac3d8a1389eaed0219d199e9016bf6dcd2c32524e836ed1d170e7ba2d0dbaa756bbde2b61ee8cb720b568d596db1ec0e9bea8c2a54b71bfc0d3e1fad7dc607235ed0b1bf25f0867bb0b633a31cafff6e9b92f429fd688b7be3ad95e63d58ffd9002965a8470d5621ff1ce5a07ff34479fc93dd2f952f95a186a9d309359a1fae637b974a17a87917b508e857c4315479d6a5b3ffac8cbc1d186c661938368b361d6c423c26cdd58f964d7ae30e11f6479e44a67d644c0b198c9927b44847b6a4cc34b1783bc952e26ee2b515d57597816d3671621c3a147c938cda7f9ac773a59e5855019cca4fb3080133451118e9be02b8adcdcafdf7be5efac9746f413828575344ee993e900dcda4b1a8ca0cfdbb92e61b55e67fb9bcac98e14aefd6a4aa5c457e8bac05bf09e86540e3d31f27e9c5cc5c4dd8f71cfe8024b94af57f1eb04956e98534d49abd8d65d88ca78281724c03df72b093ea692f1f2e738d61a10ae8c213bf045e60da4534d7addd4eed651ba93399a9e691415f41289d2952825c76d2887d361e544516f9398c06c1e6616d0e9661d347c904c589fab5ae5414bcb863e732baeef801a6667fdaa3d8bc5cddb1440d581ed7e72dc70dd8c7ba8077ec515ee44d3a0ac3d1cd4f2e6f099535814d3ea6f14fec036b1d28822d2ed9dd26aed5dc01f2f2d27bb6229b150c3e526223d7686dd6dc2f39c8ad1bbf6eda502065ac984326f872e9cca1081a1c12483aefd1d998af827ef900e3a6ec11f58e5e703ec96037a8b4d2d55941eb1d27d2d8552f69f19c82bfe60fb6d0077fe98ce2f5e9dec58ac92db6a783315c9a8c7702ef2cd4af54396d7e5d878afd6c2d15c1fed2c85261073ef799ce566ff980a9c92d49e061ae0fe1b5c560890638a397bbe37d3beb441291f8af3d1137bf28558d1b910245b8590f9ff30fdea24614a62a9e5b542e2eca55de08576ba3d4df237379ba21db64b0c3e6cae3fd7121599597afbeff346e33c38348f3e8ed6700b13a0e5aca8cec01d4462b1d6e4913da53d1fb597f10efb1289e72fdc623379fa2cfb750de8ddb02b44df5de1596dc1691363c26f99c0e9ca81a3c28e434fa39618c64d1c2aa334e21f13247b7f213c872c5dc2d7f5ce179e1346bfb10a0740b3c72b304be9bed6a2ea7f493e66c63755db8abf7fd66cf2575f7a4cf3338426939ff25b4b8c121921a9165df21f0528d2c1601ff116feddc64c030757472999f34c37d086fcaa792b3b0a9a386f8a46fd4149c015f9e464fa712593403f5612c3a2775af0d1b3680db12686746aac2d11939eb08d2d93a0ccea75e152bb6b6d8b9d3f236a2f71d6121823d37e8d2be242f6dd3e4d6765aaa0e5674562a03d650e193ef59b6463fdeda20f3383ba4cea45f9ea7efc7422815a447183405f26784e63c2f8914de10aadd3d2f55e83f53290068c40050be591c949583854ddee158e4c9e6293583fda2d97ba075cb0d3e5426ac084d37fafaa32206609fd773631bd1005118fa3e929d8a38bb0b80ad0d47242e388b17d9c2f6f004b6700f20d06182c90370112d98e322744903cdc4b95b7854519ca7fa2a3a717d93be2d334440765c3467b7468e0c6473e5d8e6b816960afd6d40ad4339172b441d433a1ac5272281f922296998207c57b02ddd39a286bcb02533960e7bc1749d6ad47e0568dc28b07a5bc74d05b468b16641b07a68afdd78f6ec2189b1268e76b110e5a5f90f6fe1b56b68460a9564e2f197ae7a2706dc01b0d3633b5002801c5b5b27be9a0ed71dec62118aadb7792223d624f33a18040a04ac44375f28a6b03aadc5384162deb209f5d073f689b9dece84bf1744c8955917eda22fc193ce3d27970b2ba9022dc07fce0303e12cae09fce331e0df764f0320eade9547bf0473d2a3d088b14303a85006b74a09a53862c07966539556c0255ced50b983f27a885ca0c3c58929574e4d2ca7bdedcabc482a4460d52b59963d7124c5116cbfca54ba0c39ad3356a0d7068dfd110a4f971d978ae6b208fdcedfcf9e9d561052c99be8f27a33aed4550e49c2f863469846a12bd8060e7ec2fbbbbad5767f5ac75134921950d34a9f300db7a3a0abe3fddbed49290543f07684d1c55ebeb674c7af89457aeb6ae5baa18644f4fe57f38fb774730194370d5925d4c4f5101118957a1500179f4d2da1695de41bbe4cc7c30df5ef524d1ac2fe829fa19474d272eaa9777a602f28ffdd42027fe85ae7a3ed0ee6b50e96b4edb0e9d3403ace73cc926222e5d5f0b56233cff666b1c030943d3ed587f13fc953d966b56d57b19b97accd064b8c14e329d29caed4d98702ac845852edc71d021e21b0be68d09e4994a204ab003346ecda9b5a408ea090349e2e2e6a2cb4b95c14154d4b3026d5be3ca441bb5f4e44c7ce234586fc92c2a816cdf1197bad8f6030069f4fb0518c6d95ea171fdfb5221c366e2c8fa08ef9bb1dda49f42cf8d27e4c95f1741037653c06fc59a81e182ffe680ae12fdc262b13ec32845f012a9c9966c04dedc2ca45ef08fa976a659267cd085ce7ebec7b6775bbc2594eb652fa190fc0db96439c2a3710b9857abcaabeafd861ba68cec3e4377b1cc9673aacb3b3c04920621b3e2d85869fce82dbfd2561c146a1135bff885f2ce2ff0731ae08726bb690eadaaf7264bf81e9e5c7dd02147c9f14b8d26c47c99f6115b66b38a0a7885b675e5cf5eab0a2b65fce61fb653ca3c17850ec514fad253fc5128abe68957736cbf938511e1d11346bc918573e22cf632219662af703cdf9894e0584136b0b77896bf413ccdc23dd69ada18e3b4b5d41dd72162c5bdb22092733811416dc9f269f1c089082a7373c82bb0c118a8eeb785f4cf07040aa81cab87cdf597e0e4bb8123585f113ce6ac7506b679750c9dc3de697e05075fa0f27e185dfb7b26d6ec6acc31180278c75aacd3a1013bd9a15e8f8c0da80a02ff09b39cdf9ff91ffa7c8201ccb0f795d1b54da06423fbb04ff72cd1a6da391b3550473f861b91ca77d081337cee121d085fc5faa5b31d8df3e4ff9393813f54fcbfb106cef9bae8d3708abba1546db4d76f00d556f443b5979586b58b07111fc154ba58648bbd843db3bb1a82e95a9427091ddc198ee9b2c7c31c2d0b8d802ab9bdc222a09359c9b2c63c9bf65838059176c5eba157aaf5fd7f377f2c4a50feea8224aeeea8be3fa8d2ae4673a0b64620a1ee7fea98ca234218fb2f54cb0a13c5e275f1f75307aebcc70c8da3f5527406dc280ba258b6693c216bda1f805b89ab29b127ea65d80fa7f32d78d699a760c0638e2ca66c830cb94eec492043c9f046e2ee5268ca6c9ee70dd16d0a9fb18ccc450d385acef47b1831acea4cdb0cb7a206676094e24c2151ce28dfac8294613a6b0467f5fc03f2a4dd105d7dad667c5662c04c275de306d39c607bb4d806202f3f45a5b4de38b9a61af7e4d6b53f04459b10178abeed33258d34b0727f6ea89b9c2d10446218777332eea0fdcddf505c1d8756f252ee3a182b53bcd3b8e9988a69ed9d3890e33e590defdecc3fd3cb980e4e5c4da7ae19c6bb39e28a8c49cedcf15b29aedf97cc4ac25ddfcb041b30fdcfb81ca0eec9d5b03e4d7242c2ac067c0f736ea72a68cbcd2f0365d1dd542de4421bd409107c03ac4c623328a0b9058e76a72fb209ac9edb2d9ca02ab0bebf8f050f30d234b4b4165c2b5a59783c9cb93de5ab15aff67090c20d42ca081b50a8c0a68a28de6f6f564055e40de278eb8f4b69decf606b8e9e738c7bfd96f79c4bebcf5574ed085c4a80567d19e37ba8caa4c1f9897e37599c26f06cebd3db2faa7f76565bc091d78d765a7a31e4e37b0cb46f19316bee4484d2cfc56d1e00e7663cd018d2d0921c74dba10df2e69ac6b34931217a610e42eb6e209ed26b04b26f3c136c2a35e713468c6c8e32de8e6feaa6a18cdbb79e76da6d9d907fe92dab68a827ba0a323a7de59ace3eea860a57c73a5eba2eb7b2eb9128f587d6b8da86a2248e00b6a30838fd8476c9f7f582e52fa2faf941954cc3dc12568272db0b9aa8d0021cb5bde65ad5d996bc52403af8dcd9be4833239e45af73982a75016126771a33cf1ff8c2cdd6e586844787a159470767aad4a483501c7faa7cf42fe9edba187b44be27cb5442bd2a927b3b6732e1377e8f87a32c6e555ae21d7129beacf9c907ac54fc0e16b9fc8d76977c4d390e8d2eecf6efe63faf37d777c0abee1b36e5e20257a6b617ac51059a59994b9b76d6f38c36e7a2dbc473485c58ab41c4dc8fe975d36e6e7b762198b6d18f561091c24e9b1b3b150392aa39937ffd44162061fccac38013980415eb0680a9cc7748337313c8ae761cfc85d71b394bbcf776c47bbb7e76679cb1007d5dc8c3e76ba1a2e290afdfc128e531fcdc29fd57a8653e291b9da21ca2b744e2cb6fe51fc2adb60536fb8fd46bbf64b6ed80953ee41c9c068b6c4727d766ed696ab629ba59dbc6fc52635fecd0e2e7c2968e77e0b6b48b859f84241fb8aec67c6d2591f80cf1e34895ba74ed6dcdbcab8e7e26c2ee8430913f7c9a4f6ecf91828f1fd6d6cf1e4b52ced0ccb5d9bdcc807ae1b39076c29650716bd325f93797b467687cab7af1f2e4d5b55a6cfd399676e558d4f896d14a6bbff1eafb7abde823d5990a31c932bb664a4cfd329ef1aa89ab6e91c7b31baf551db055c0337152adf8d474a4564712c7d01187decead519e956ef6cd471f0c755d6c0cccb9a68ca15620cf9d1e2627098301a6e6c0b37295f85e34bdf9e92f4e9744fb94269350f40de329d51faa52d6265d69ba08497c88330980da1b25f3bd79cc07c2c40a8e7ce3cc17778267c678b29e841f4a9a139f670c12ae0cc2adab70cfecf8431fd417d4beb1ea423da3f6bd0a22676ca46b01a0cb210b4cdc426dd532c9d4327146183ca4fb2a769c4d6ba957fc01969759e926dc010e68b267d25b40f400220d2b1143c2624b1918bf3878b00c3c4729151174e8c8a4bdeb84bd639270221aea520279892ec4a51a98027d7bdd08f12b9b8738c00a81128193155e07686f451af60fef81f6b339d4cd715821bcbd69ab0ae27f31f1f228732e5c988a141eae18a759950c8192f983a40ddaeee9d62afdfb740da0e003178cf520fcce04f2158435625896568f18d2296787b4702e2d5009d9bf543b7bed71a1c31352f91100043907e7a47cfdc31f95d7debe42342c134a50331284f282e45847f88771d646ff7b5709ceb59d9814aaa1e74009f8038069cfe4c8b2b24ff307f0cd07f53af7486b7c7f7f189951dfa72641c4a50100d908209a2ef2e590617187f32465a1d39b0553d1dfadfcd547596ef92011810b46f5a399e2460b537e6ca81d8b504e64ab26c56b39777c4df0a97a7f24667d87184dbe655aa91d09656df0bec409784ffc31c17a68b6f304e53eb9ec2de34eeb56725921e18f2abb0926bef9edbc6ba9fac9584aae83e25e3dfd541bf996f68e0f96592d73bf019d1a18bd7be18f35ddd7a2e5811a83f261b03cd235a84da7ac5ff0ae9fcec6de3ae912313744719cd03e8ee23d2ffe2603ec74e36856b1123c2939588f84bb7673770078a514f76597afeafcf2079a1fe48c08e477bbe4e030b5b019537130c74deb924f5e6ed32004297046ae84fa4a40d081401af6f2252cd070d5f982396ae1ed22987f44a3a55a25c34d1c2b2dbd595e41ad6382e28f6529d6f31aa8c1f1a7ca686cb474850c695b5b81fb59c7c860e0b1cfdb2a1798d216437b5868d7953e2c23be0024d039a60b8f39d00a9d86a91890b464bab233eb3ef6c90c3be00ff0cae179fdc5270317a9d564d320f1e042c14d27a3d63eadcb12a56289b89c1ed664a447b9c736b67407877d2ee2d25fef087206c74e7ef883f05a4c57274d7ebcb38ef21363de94cf8c25174772ab447ed39f640adaf00ef8fed9dc1e03081bcb14a4f95acc785b019b0808e8cd2d6942d105db4df9b7cbc69749cc5d218900b53f58f2106d87a9cbe15b912f32a2d6085ea56e699634d5bf72df0cb6c9757d49439e789c0038b768ae368c638f6c1f0cf14751aa3291d16ec64c7acb7c21b688e55e1a96d9eb3ee3c3a16902691413f398d1b347bc9d10054b324ba5d2efbd79420f7ebbda40c6512ead2df0be661fce6061b93dd06ad6255e567134f08255ce1b7aafd962b217c9dfb02c9789f0b7143f2750e853439fd1bf9700da25a048cbb26a48c9df2478f1ccb176e709f6b0000edaf07b664330bc6502a7ddf999eb44901f54ff5f68b23e655f8da26730b7872a19c2c5ae5d46fb0e79ef305454a15077809ef75bab5633aa9c00a66daaa24338f130278c4ab12b8d48de3bdd4f44bdd30bbb2dc478f0a8a6272924087d9181e1b4ccea579130908dc4ce7bbf543933b321dbb94291ce768160b470bf8ccac8089d475b5fae65d93e1fee2eea50b9c05828446f0d5a0b6013288b96500d5abef605675b949ec436424441e3d4e9f13c69502bae858f79bff6543cf58dba2a034730072c173e24e29cd78213de288aeb3ddbcbb48443926eb27ce2519ec8ee9532fddf18bd4c52014b2260ce6e04a565a6717bd048ee409c7171bbeda561d9a5babd2d2d00e83c7a3652adaa164cb8aeae975bab0dab2c7b59f08aa9b947b3c82b13a641a8b6ef55f3c0c7296a5681781ff7095eeaae110022714612e47e33bf42f76d23303b939f04d196db395d254b39a8bead015f412e2f7492befe76c01b71860a819737f85297f7e4fa067b3a02780cc146ef258d2b57f20eb20cee154fd8600362698070181966d8700ec1ccdbf795a8d9a186204e7fa66b81f92f60a7271a31bb299b6d5a5cd5ae7550d8797abf9203bf65181dbf48dffb99d63296e5aef8a5537803d84cc07798a6a567a6e005e8b1235b87f58e70018f1b2893b0c98aa462f6fa23f04bc1032014e7678be881ab34c0d75b79b1a2ec5750cc4d0ae83baa00d70806f1149a3840c10aaef1a57420480b62a53e3731796ed8bd28ae3b6d05944e31426dee856a60fa5d7abe45648d04c3335aed8885789007d71a5d395833ed47725c3ce876ae651661e23a1bac329ce5d74e96d3c2dc8e0bc8cd2215d8ebeee85b1c354605c8a72aec31b6c5c9d407ea41dc86429de2f8baa7bb8a1e20a9f2a092348f597bd6285f79b6592dfd09df420b120d4cab374c1c6f64676ce830d9533caaee54b4b84246c54892e5f7aab4d2eb67900506a6a5a9231f46b1838d1f3fdf895c98172eb6109d8a20a1f729168df91b21b74ac35b7554c6a0f7fe719c0646f51858e9513ccec85b00fb28d0e11be44414ad0e9766499f17dce4098a38544772d879e2472756e1ffd9ee88dfcb034c03dc169986f90d6cee3f55414f3daba838e12895be66a3e3f9732d71fc9e4fc1bbd55e54b646b2ff6d04b965b05b1d7a08e9ac84258d10d9109123e3faff1d5d643dddb467d91a9602ec5522a8fe5989e2bc30295323fdd10f3a128b29968b6e79381d96c727b287ce8dda8aad98bbde831d92d8b0fdf3d19957cab2d62dee92250f70710c85b997ac92cad42ead8392df06862b4e72f1f5854e02d96cb26f588fe8190226a08a7651b7d510935145e866c3b48c5ed946aee522c81c97db9dd61f796bb532d349600db36ad79c3f75898989dc7b424ca4e749d3a0600a21904da2a5c587062dce75d6582bbdc15af48642a2642cd84a0dedaf12ac82a6e4e7c25a9496e67a2fe3bcb8f332a0b502c48c5fddd1d76432ae72753bed77f1ced00578a7d754ab018e12cd714d0fe6015785b92b4563d051a18be850b01a44120bb7a4483333a479971f87c881c9a104cd97c97e6808a1f7941bacc7c127a5836bdd53c9b4d490936c0162918cd43b8955de5a5ef1d06c245e34517c2f802bc33f6f67bb2de87fc218126bd9849c638efa4d719049118e557b63f5a67833664c274cc4c572637642bd4c074a98032dfa7d10d837bf6ca2905d7ab76c3aaa33577fb2c5aee507e5f6ddad9185f632ed52e6811a3e33e5f082fb44f0912374ca97b81430163c4b0d296e5440f39633796b00742635de8e104bae5ed914d99455fdcf19186b97e8d312c362aed41c965095e7ec868fc2ef357a1c9cc4addcd45eb1cae849a7f9cbfe9d072fcdc40826af7335c6fe9c63ea50e32749765fb5b00dd885879ef142c2f41d0f88f5a8f6b9639d5b1de7ccb0454d4a245f7a13a7c33c1fc5ac6bd75b998821bfd1aa95770c4fc5afe60346b6a1e35dd3caf9b4f05f453470421b63784e102dc22653846127725601f1bd5996b971d14e086cb26bd9054ad1d75ab775b4582950d116c42d27c7ebce0f55ebd3c2023942067c84d68bfc72a8b343e4d07a20f6dd44051afd7797e572b7526b445db7dcec75e1aff74aabd2d1275d106334d1840048d7dad2fb24f904339ed714c42058310d42d788bf96617989ef74b042eb884f1a5e7a62bb68f1e05221f0752d1df2aa344c5e5e4a121413021248ce76f0411a9a12df3fb2a35bf6a29c5a69523b80bfd31faeca2373e9d24ced90e573d3cfbaee9cfbb463dd685ba0b1299300310a4cb769964b3ff2ff3cd2ef1d0b61a70dbf1f6ca28a89c3858e7a6b8ad7f7c83fa4e36189376bff293ed9e4408a29c2a985e6e0207a8448130f1ea1a19d8a5f83d853a779d00560b2d572ce770a0b7d37f642413ef675d0540661238da6b9e8215c2063d77b6085960781a30ae9ec91c19882da8536061f2924b46a0f6d95aa8578decdd6c5fe54b735d8a5b4231f4bffca6512109cc4e5cfeb53e133b59f80452a49a1fb871ea8b5b2591d689c242f435d4f5e5ce0ba8fd8bad462d0e96a4f7869b2d701729ea7841e0d1ba03430473c781d6967eaf39747e2a87afd84843b2208604c75e7798ddbe089089e46567126ad451b1d3a00067d1772447cb6ea15a813fce0418c885087eaa08874db73ec0c56ef9ca9756ea0b2cd5051b1e2f2fc68a094649c3ef7108adf386171dc9aed90fcb0970185b8677aedf239842ad345660338642fe35a885e2b0bbfb45441235af490830c8683e4ecc963f365eeed62d405682058c20900531c61e0a2fb7563781c44ac75febab07aac1a4230fae82d29a864a77295fc8017b02a2c73eeb552da5fa32b45469903949fc4a0c0e403e2c49e2eaf45c94925a31b4631dabcdfc7bd9a1d9a8a7cebf633ca7160893de93d11821f0083b056a015ee3934fdf106edcb1e98e79d7bd20d37f406e2db0eb0d6e254f2d14ebf48c5211231c4795f90a994f46709b22cb18a7994192b9e2fd71d51ff4725bec8a7e7086e11fc9fca6d690fd14e4dfe6da23b6c1217e866edc30ae0e82b319720003a19d212bce3b2184473ba2725698cb2183c30fe274fefe32286162b3b869e00e793131546bb78546c15c09bc542c204fe7c9d51cb091f6b5079562aaf283b5ab76dd32633f35e06eb728a17ba88ba50ddfabf890df8504b7d90fca70ac3fcd5e0d5f0dd00bcb7a2ce7cc3bd580bbd4e3d92457b610f46a7eaeb30d323dbd043426020f1309334a41b5b82fafcfcc74e5779ae55eb51ddaeb213672a339f93985d0f8c0db4a41a3498c9e858da9ac7a89f54bf322dbafcbca3e67c22a87395d9af485c65916c94e425e7f80fd7cc5f4f6714435caf15629a108fb37f0342ab2a8e922dae0118bda61762e059a3017412fc965d47db9ec121beca6723e4771931d6f85415560d1001af086b3bae824f3e867cbf6668915a74822c464f4b8e254aa7acee48bb42706bfb8904beedb2642a7681f7b7fb618811b58c3701647b684416c78845ff6d9ba2166ddf131c22dd126f84c57e62831d9a0accd4178c3961fef7e24db6eb6a3adcce6470f85cf6986beefec55e66e0ee2923387ec515cc15ca873b8a96f0a81017d77bf14d2dd0f7f8d6d6b6a0566232be3c901faf3a8cffd70dbbcb50155dcc79267d69cfd1dcdfcca20563e4d569da6380d0990ede07d04888858aa2601cd59dfd4b0e2390240682e3bf07a1ce1f2c12f4fd223623e72baaf86c0c1eb1dc2d3219b83e6d48137bc578e5fe63d7bdc489b0c28dd42624a2271ee34bd1312f2838065ef7c475b4ccaf43cccf838d7647661721670e5fe4fd1b88fec4f15259aacddd6f5f3f0fe9e388f777b56eb8ad1407fd7d7718c9d945ca9dcc449040c0bbd296fbf2f47acb615984039f41f8a91159dcfa526a2a9ab93e660cb789fac81995987071b8c3ceca42efd0346d72e6116f3210bf04a2cd8e66078440374136283e809c95b7f6602d8cea4bed63ddddf37993a5362e303d5fed2819abb40b7d3342449dc61a07ae92fa62713f5b4ecc9e40ff2c57e5a298ef9c0ff143b9e7672ff72dca8d2fe4ec6736667e0a25c31865456d51380cbf9e5703c5853b4fdfa2c6b0e121fc52c8ab48a7004b5348ee83bc034d4c36335a2198b9bc7b51a33b6b5c5658464652c7a29f44b5ed4cd75a16803e2285c4a0e72ffb0a39728053a2aaf077134c25850924566cb3387f0424b0270ef88ac012fd8fd69d1dce22965bdaa1f782dd28af4bd57fddb0e5f6cf49e17d2f8ea1a0ff41231699712d70579a195bdaf596ddef549486befc44c87fba780ca8a230eba43584dd2cfa848c39d59c4b31847d8d1a4d7453a50aeff534d5f1185f56053a6dab3d78ad775cf50fe12fa1e8708efd1f100e514bcdd9020b06c14479bb4fc4f82f0d791008cde1d49c85c0b56b9c06de066e51c96f3aa7515e48d790250ba0d0e50d4b6b84b1b6f2da14251f84bc5024d8aa089368863ce753bbb1245b679e0a7c1f5897df55ed8de42494ee96000490ec29c539e72204e603eca16b81d203607b53b4516a7bcc152e5ee36f096a895bc4177f90fe9deec31dbc02dcd3418aafef0a2b3dc89e1fae24256517760a8685f56c2abfe27ef2291d00019912e5c345b33cc44f7168297b7dcbc008de2fd20a8ee0d0de8266f6c21896566f9a99eee776b20a3f55ee2243f758914e64a6846b228fae1f438bae2c8322095f9eb7c60e9192f1537aa43003a7465ea229576c0da301ce73ae38fc367fd2f13768f99b30dd31e7af21bda84955a60d3704a76d06af7774225989da0881bed2477cfebfd3ec12cf817fd101df1c836f66f20659e6bbc56422fb494e895a419b9f019faa2a78591c9b44b34b7f826104efe98757cfcd3345c75fac33ace0281e1dade27b93eba1082958edc5207b2705af611e313d1d12d9e31fe4653d6d32f0791961abb4aca2bb01e3c13ca57b83cb6472870f2998e1595b645799a279d718c935e95d6043fc28bae1e80418ac5d83222fee22827b535abbd4d731e71e759434879d02f265ebcfa6d1434806d8e0258e950c4dc3ca86587421ea9be50dec06534a5c250d9b22d5737d042f464287ab218d225f14cb2bd2f5c26dc70f3cea3e90152e6b00a1bddb65a17651df9e2f556fb62be461dbe7084f439fc6ba8e2e6f6df7c5a72e81f72fb1697ff87ab209af0ea4ffe76d1f663e3af5aabd0a9bae13d4cca6d3d6384059401fec01170fb04256ff308ac718dd401a29f0fd57431ae41ebd034ce8f5b8af5484a073b5380150c68c7bac175a1e67ce2d2e9ef1d84a2a7aecde5a3e7175c9a2f5c9a95879f29afea5e7e4d59b3167aacb3fba2359ae9fbb8f046b9152f232c3fa98c0a44cbb7899d4f726d267675206753e71bf322e40cb5cd07a1d8cdca4aa076a48f46cccabf5ffc87648c5081e341478ba257873f442bce7272ea2e59bb59c386dd4bd2799b04b2d6d72f2b59308f1d5af8a7155267853f42966a272c2a9af4c28084616647758d1262f2d4f058cc72832191707641e915fbb438f444dea874dd25d4bdf9ff8fd3c26c93866868eda6d9686d9e5a4da7ad6cb0c45b34b4943260452370b0b17693bee965f2e2d10eaf9a71daa92ba60d171a9e517b278730c1d5a790391d25db3b1a0daa48d2f44528860fd5dd11a0822b120039d27c62f483f10daaa1061569afa4f3c61ae8e78a030b3e686b0209879a98aa48a43d85dc078517ea7ad5bf0442741ffd1d2f548ec039064f7a36d0e29664790b1b798409f1b80d2efc10193178c78339c8448c49934e7a2013255cce528d67dd52017a1634d37738da85bb0e61762d80aab6e92ef8d1f9aab9d5eb03f342119fcb8685ccaa252100815fc86b7c6a782a5e9be79ed0ba252ce71ba028f9a9e70c16a7d93a1a8cca6f5c0d841ea4ee23548a9ed0dfa126f4f5111ab7e5f10c2c1598d470aceb8f16c40d8fd769680b8ecbc75e963d0afdbfb255c2e42cf0119da37f3c720b73deb09a2aa37dac117c5226e87efbc92a9fa6acfe3a70ae7dae987e63db9f0f32c8f75e54e2caa7ca8e3e45f2a5174b19428c6889d4b60770a3814ecddf3d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
