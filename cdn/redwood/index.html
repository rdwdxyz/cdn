<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"442c0c237ec98051d3ae09e89a254ee4b38a7d62146d3df3770c1d290648977d54ff52c5850cdaf263b1370d896778e08f7a2a9944d38fd66d9388c2d6bfe40ca329f601d74a85ced53fbb1897bd061aad83e00cc60bef0345c25933b8a888ae0a11cb7cefc56b76c7da4872cd8345e7009f68c2b0ce0bbcdc76c1c94fbd2b008eb55843a539ba831816e9ea3e048999493887dead3831167b596892179aa1ba5bae1a9d76f7c581fe1c6a05c63a9b484f037e696a1d23ad5ff5441f1579671d205b968e85cfaea7a3c0c4b87c4b58a6d5e11d1f2f7649f658276c427041898ff72e8f9bffca411483d9560381dd24de3ecbefb3d4842ad6b494e2f514fdc2e9c9c62c8d86c18f9441a90c48eeda9b2e712bc96c55cb3f4fdc39d032edbbefd5e669f30c057bfe95c89dea2265b023e0d15cc740c54b2f087a45fab3f1514e0f0de2041de0f9a1aad12977a991840f2b0c5e20ea4aba81ed1208385d6e2eae1c21cca05b5271d2b22c6249b9a3f1ee4f2d08a60a844ee6a6bb2eca076582568135710235375d1e21c80df898dcd07071e0e6746da29f25a103c76f266239c6fec23f45b1bb3ec772de74183984eb27be69aed4d7acd1eec4ba780f6da8ba0b4c2da6188ad87e4291702b1953a07a5042ecafa61b7e0ef0026be4f89e5cfa2972927bfd35f1e66dbb3fc634462888d02803fb82ac2b0773238e56163058ef07d4f560d09d7bd415ee917ff3811922ad72094c05b73caddaf44da1e5f2068f79f7b754e990d5381d578f3f489b1e247e9bbb9563a4bf42fcad29804e17fecc57247a28f3abfeac039342192a3f16ffbef0032598f0edf356023bbb1b829a175d8d1b5d2f27960338b2cdbe50575770dd65b42341785b6a12e53392c346f394d3f71518a5752d6ccc614d495998af5c9fad89b455f35a8ab5ade85e2e576de77eba7d2f1a530c255a50c50af1db8738325ae1e9bf63057b5b7e8918e0ceb6cb0fcc705f6cc3afcd32ea22cde30e359c8d382f3ea5637f7ad58f87e97e59b161f0cb5335767b1f84f57f525389fbed5f0806af47180dc9c0712fc30d16e86cda5fcf5bb29c6bf553bf942ed43116d99588e17babfba8818b7cbec22b69473fffa9c40465f843c333961fba928ae990c6d7c8b764b7b9544598679d86ea61cecdda09e9394caaa39c984f3f416a2fe96b25cc00510906da1b38b416887f5beb434dde487e7aa76ec7699d16e2fea03dc9eff46514f94e445024867a63f56d56028e5efb93536ed6fc0e86898a172bed2b6154afb75be5d2c4cb650bfc48d738dd2713143b744311b157f92ed4f85e0b5e5f0dc409f193d3fffff388a71d25d076c65f2fa6f62c99bdde91cb9e8524a0a6e10f37f696e9f3382b720527e57583cc1bbb1565db0251c8b684ee288b8eaa745977c1fd5a734e6634505cb89cf5382cb8292dadc3bbd351887732e8a292504fb23dca5dca6e52a5e6eb98b5a7a5db0a7ed80564d591257539c0e3be505e8ede173d39a36f668d3d77e81ebca1dbe38d16bda2fcc83f8086152e5474db07f6af7e1ff22c3238ea65fd5210938773352114565a6e8cc840a1a7d862535bc9b0668caa2bcfc46a7539b79e10f041f82be942304ced58adcd7556b7f6a02c05e9e56908046f22395032a1561035c3924dc8c3d8ec499f4e5676edee75e70a1213d3259d07f4dc8db38353881c34b6fe023b4f82b205ad5ce4d081c393aa29a275486c519293ffc6e0882906ad6a4cbbad3565daad924200e409370493ba3d70acbb3ef7beb2811bb75c4f488c617a67a04f869f7af55b6a96bb12fc3a880385bf6ccb7e07f76f954d6bcc9055448d721e2ebc66892d1ded0ecc77c1984c2c619cc82c7922532a93912d09bef77a2e0c9088c46606f23cb575c7a697d05f270e25672e9d3c785086e4da42daac5c184924afcac8b60f29caa2b3e76fa37bdd521b60c88f6bd9a73e1d2a0623d0340a7aadd5e6e4423582b53fac1bf290d578c662fe21d60c2e5c03e8eb43abd308cfe7446b037a11262796c7b2cfda36d05de5facd1062d028b419d8a49ea53bb2f22861934fb13eb3c7d7cbf25a0f5499a1af76cccb6d8d32c536b8c6439cbd25cd4a70e310e73431ccc67934ca15e3d4299a3990c10825e79f3ce309f5f7abcc09cf1060c0619c2f2146e918b10ffd4ca7ecebc2c5fc4973000a5d6faae464d85d412cb139862ab4071dbe3181d712be0e7c648da582a974875a67f47d3feb933a70e4b5b136e972457f1512d54adbc1c47a28dcd65c082cf98f5236b0543e74c6c004a5d75e4f68e6748b1c73d3a1693aec28e02557a4c5848a2f789209d0ca92459b0f319b112632cbf1b79f6854ccb2fb8e19b2f5e1aaa572178989708d1ef850fbcc8362dacaeac5abd543c8b6422c7ba2d59aeb89290738fbeac7197d3cdcea657ccdcb140a01cb3d358e23ba452cf9f2629fe1113e883be15aede179af973c1c6566d18b6f14eefad1a155670f81ddfee1ea8dc9bfc4729c2adcaf83c55229ec9333172455dca451c6d7a7593c16966f837f8ab1e9fe04f02c227dc85e25df24faabbd699e77fd24fbed10f6b1ee78f86b1e627fc6502e7b425b274d460c04a3098e22cace68fe5d084deecf4905d0c3bb4553d33ab31cf09b29ad67cac63289b68d61387d8687ae983649c26b54ff9eafe43832aa946e1a457af90346e1dcedac1899129315b48f9735f3904368717210344f5c5d995292fa16bb06316e7066310cab5594eafd66cd860191ebbf836afe73d9f51826eab9bb1a2b9ba8c6c412570cce4574844d040339335e78e68326667be03948c5918ead4ee0958077a27eab43624e244b82c02075c38ecb07161606aeb5930a13aed6ca4f291a3ca3863a360d4959469f828a61f5a323e6b8e9c69dca73d6ecdd01cd8eae61a32088c0d2d1e4b0ae2a7366aa218550156ef8fd4b062ba2bb11cbafeb0c6122a7e05e69682a0aff9c842315dfb112fe6ecf0042ec0d18c60ea790a453de5afe738420fdd8c394ddd66f1e5bff092d3746917f14a2fa4d9aebd5bbfa6f8b9fe29587c86535d2e2bb7e4d924bf8994e15bcadba81e2518c47b13cfb214d97512c26a0f07c6ef19cf1abd83d4d888acc9d59fad1da71b347ba38573ac253040a49c360e8bb6b2b383b5e8dcb27e6fe2acff84ca59a5724b9c33c59c5bc1e96591a2ecebdecd6f98533c82fecd3f3e0fe2fe7115e8253f78d12deab1efd89f85cd40319fa358de448d0a80d1137a880a6fa6f871cdb2e02307de47a7e21453729e83d656305e3341f8db56af249b5996aee6ac1eedd7e0eefe90253234b72029548a83450dc3088fee9cd96a8c5eacba43b051d0558a73beb522f33dc939166208f22c738117789d1ef942e4c33115cd6e6704b673b8bf99009b1a03cc7a3ec574de69f8bbb1e5640aa5cc56d0466c7d185392a4298dda491ce81f052561783addeaf08de9e05b314f6b9e822bafaa3bb61fcbc7756c7131f7e578183fda9676fdb5f66e34a9071de45fa46d6b23252c2a44201b80b3b7ac9820f7292856bebf54055b17ec47387736a9f6b17592e27bacc9a3f50c8c894772ae7f3ee8c1ead27b7a3176689faa74ae2268910f04f960526d3527b2c76c1847af122afb6b05e2411ec7ccb2958563845214e0d3ec988657a7526f3e11c821ec968e5d7a3c54bc306fd4e03c54a9ac465ff535cb6d2d267d3e1fe22281a7f02754504aef6fe213ee53ad3801966569aa2da8cdf1dfc6e7d97ea31668ed2a4a79ace05e15d78c8abbd155762476ff3e8b034675d2e4c4f60192ebff3ea7712095d9ea9399ad762a66739fb24df2b72eb6ac609830919f0c8876ab0b8fa915201816fae30cc26955ac3e38bfdd2f8c8cb4c3acf7927432d218246c6d95e92920b9f0f8274edcb2ddb0ef5f9db402a5753f4c0fcc5ceb7336edcb736d5332eb2316b6468d0714d55bbd93e4b2e4f64131b669308361113e8af88ad004a3111e9c36608c1ceda107b28deba1cc47a8f330a415747762d3bda4bb62d373f6d8dda0b2e4d8eaeed5054daeed3a0196c9fe50c7bd4ef24e0e2b3bb0dcf650a581b35c27bb064728b82346df5b623ee1b0041b81015b82064b271bfbc0cd7b45bf60f03f376808d24cd346f49c01e987c36a125411fabdd5127b2c80b7e936dfc2b610cf7672a8c42d452aa34439c31e4ea377173d0ff61f266b3828927bdf0a821c04767602afc9122995917cb41699c82ed326daa0d7565dddc02e26eec9288bcee885b2cedbb8907811e24948c3da5789121fe48a7d204ebd4c0fa4d976b9be5e6131a5c4c7bb4ec47c059052d0079ada1184d5139b5f1af060bafa046a5590603197c34b81b1eaf3e2d460402301571617cdd51b71c7fadc4d5b3c53e8c65d24556623380ab4f8397285356884f9f63ce16341ffaeaf173300b4756f198ce31e0145b6d2a28bbec827fb7d3405951ae69f14f14902956c35763455ea6f526765c39237a06edf751ae6a4b451c1644a125779e073b8035991957a5672087de014b48e61a557a3b467e1f1aaa8cbab02fa11a2a9c2e75fd89e682370b0382653bd19b4ebe2a48d8ecf4fca22b4b1a8d47ed49b1f8a72bde0c389fbc9b7cc3a8b38eeff90216e6126c9e3c059797e4f9194b871c6cb13e9305eb38761ec461ef417bf074859227c407020ace127bc0b48b6a380430bac1ab77cb323b3625ab28a7a7c96b6f21a8efb4d4af561dc661398b1f9c4dacf340c487050eedd910e35ad24ccbefe6b8b234be252155f20255ee76f22254718ebee1c4c1c5c7e2fadc6ad1a021d7da07c7c963149cc3550d8f0fe68976e6420fba2dc914a2f0e1a66dcf8a24a3bb2885b8f24b97e7d3aa4c3da7357bab6d1b785ab234c3f08d618d149fe64c2f1633ef77c7ad183d557d726f5ce0aff8a625c8dc612941f135381f9304bb68407202996407d97931e44ebac44707a11522f0e41ea96181a607b96c1890760dc030bf23d32d81dc9c81d55e1837975fcf7bc3f44d745f7efd5da2941b61bb76505b4325fe611d5d91f35b31399a25ad7dd3594bf3b352eee62073cccff9073390f4d6bb8b1b7275869fd10c088f0e778cf83ab8d2b735a671783cf77176f3ce2dd9cc801c9049b38a9409d7b52c64841562c1666393cebdcbe19cd450531885c84e735622171fb27ed2ba620649bfc42d983144e993fba408ea324ed31add2654726fa41052169aa3dd3cbdbb12739a2482b1059bfc88f18cbd611862e52f72c54c6495a712741561c65e0cd2b4920a19ce992da0f0635bb83a0d9ebf47caadac77f24b2871cedc183bd653407b3cb644bf57da4a4d01b4e5fae07a976df6d5bcc6cc1c40d0c18f343165c71ce708d57ae605613117775e0b9f4c0bc6ec734fcddf307cdc2786b8a9d5382dc2dc8b3eb57d8cffc44501f2a8f336dd23cdbdf29613d15cc062fbdbfc5583e999521447c2e2e5585c87c8abdf1865fa92e09236fcc220698872b510289663a9a1f74aedd5afbb5b641ab641f08668310e7c3a7f34fefe0f14a598d3e70c9ac00a803a78cd9f08fcde9f5b118c886a225e0d4b9dc894d656f24b6c7b0b04e06ac74807853eac345302ea708da3f1d1341fce43582ba474936fd33fd9c8ff2aeeb431176ec823fd57d8e472392e630f78b78d362aa3bf1fb7132e441f1173adf899f148c53999e14b460dfdef60f9cb52e36e5bf2c1b2b8cc1b0ba0fdf523c4e26f1b616c726eeb21098941c882117cc851108822f7396cbd9ec71a565fa9507f40c39c713060755c66795093d365adb76e0c4d805c3ded16606e8ff9c3a755354c5ac46ab52d6e97a3550f71643ec774def1bff782f511b05085e6b74535c4a27c226d676afc5b1017307eae867a0b57285c699f4075b5846d36a4c668fea94b06c91a8b5aa274ef010678b50697483fc708a1f036244368601509e8a560f5c96c916d4fe71396c7493a1f40fec64456a3c52b60f2d01e08cf01c11ba6d9a950494dec71d396b67f1dbeed6b8c31abc9db244a63fd36824c301383ef2683f703f8df4135af5a62568857a09ec9b0d7e0a328593e17a77e41c4db97febe68f1ef2d077327feedae365c72b5ba44c7bc04fe67b2675995237600b65ddc05aa8784be969ab863064723f94307b809b4f7246079ef0e85691a225dcd79b23bc387ed2b0b5685712784cf697769bd95829d4b2ac09e16cbb0792214ff0d994b8645120759c8beb3a5b6aa426522c910addcd1a8600d879777e07e51c945a2b5033f536b7b870e902218cc9104f1dbde665ca31994d7f57c7b56d7c06b7baff7529d692587a304d6e728a28588b6473ef334b20076175add8363c674cf27480692f85020b6077bb674b63408e9acb18e592bdf0a11b0872bbadbd32a4a355918704f00deed4b81c1a6fee42b97fa383a785d3dac31888c0599367a925060b3f5b29cf9b6daddb7156d069dc62e09c8a0a45d13fd5fcead90d018d637f8a8fbe3d356e6fa6892d5ba901e5bd3527c683ee3f86b021ee5d768988a64ba5334a808585b690925ebcc79e64d50e18d4e5717f8360a989933ece619fabad39a89d109a5c4c73971d7bdace4d4abe391f1021d83ed48610d697cc0d1ea9af1d4f5d3d313fa8aa5eaf16a12d4e73bef4704c3c52438d754125bacdd3f9babdfc554c1dd26a99f3f6e837d4d8fc21e537ee8363ee253e890730969900782de3de14b550ad0dbf92c3f054015588bb140416606ceebf0a9fadaf13b52a3dbc53ea0318f3e491b6c64157b242c6ca7edd3154d724b44b8973c2cfc0e37d8f5c66688fabff2d5d2c7b5ee6350aaefaced9e1d50fdaea67a6a71f8560fa9a16feb0aba0778af8641c1492cb3e8d5cb267dd79be3d4fc43670e98b61b19d43dc2a89ce075d3099ce77b5b62a5259c1566ccd6afe5b423b9bf9e92f98d699fddb470cc254aaf2df4c409f3b59c27c3a84de99ee8305e01f945abd089cd3004db0eb756485b11c8dae0064fe5c9cdbc7e5366c265d87d17ffa0838b8bc56adbb565f4938b21487f0c53349113b33eb383c50e1d3ed4c612aa5b50d3cfa3f04afd93c92baba6cddba83e606bd46d97c0b7608c007859a7fe3b7ef67aa5d6b09cb49f4e49a37b9dbfeeb4db9083eb411a1605b6c1a9ea860a0ba28b4e38878394bbfa9a3ca9b6726d629f1957cc261666f86de924562d14f3acb5bfd29d05c57b06001e108666d317f8375c4594aa632535d82ae39ab45cf6f0a1fad77b9f4bc5f1e2846db686f16d3e2523fe2b101b3e986922b94e1b163cf10d4a3a4ae1943fb81447364b874166c76e398f316ce6aa73ac42015f5ae9d2c97efa59b044d55a9c8b24e9e072630768c1cbbfc9ef9963ef77b90b81d210aa0e00d8650e0dbfaf5b19a289287671e090636f84a1964588418f8c7e0583fc02502c606a24269f4cb7f227c9ab0db7d93432c876f53664cf1cb19a63b5a0a802fdde27dccc21f945f09bca1fd06f3fedcd4275f33238217a40cd6a589ea094f62ac5b8fab84f8f0bebcb15918f3ab6ac3c659ba67cbc7a88d16b28737cbe950cf0782b927f645140248119a257c2357ad857af4d727e6455373739736208569de4929a58f993aa1be0111f459fe2805cc91f98e57b91e1a62b6c1ce6cc5370e58f7ea1a1613b34b61183b228e448d8d62ccf9c38af21b8e6474787cb3d68e94800c1eee58610c5784a525dd1b5e988c04f10789843dfc91fa24621698aab59bb4b83270e5e241a59779e1b6dfbf33ce056fce514da15ded2c24d9c7213cd6e24646279735b1eb3b67445cdd09056f2bde47e9b3a4f70f0a1bfe74cce5e61949258e8a4d62692af507ecbc85b3e4f904209a8e1cdad1bc4075181d26286cd913990e6c2e11577104f192e6ba20bb784eeaee9d3e1a5a3d11a4f00b5865bee6e1f2a0ee3f10066b406250d3d3a0048438bfe51cf1922e659f7d3293817b32084f526749af9ded4b70bd4bb2dc93e764ca62f38a257839504d77f7cd13783f229d6b92abdd97fe28a4fcaf650101028337de6704a3adba9bf06087066c8ebb748dba6e97430d3b99a05c7ec146a7574b9cb31506034d82a1c6b95905cb98df2679a120d4870be1276f0797af1318b7a8c3721bc170b9f4b41091466b79c7ef4f88791337c8d40f4abc948a43c223817d7db9af7d75b1461fdd4b7f71b4ca9f9cbe13cbf6bd96d29a347d0b6fb5f189468b573363d04fc041aabc9fc58177f406265a2ed4d973fd0715da839f8c6932f1d8df69b1a8bc494997d092a651f4125063417b11736dea344c3f05f8c29f843daa6840c4e6a1983e5259ed2279db3ca954877d305e56ffeba2f7ffc0079c352f4376de30aa251823ded5e4cefdb98319722e07cee5e76c6d4e87d6d43f18b506055c8f4d10a5266048f86fddd2465da40520268438955998338112027e458a59f58aeded35b429e4fa9ac22d5d30185d87357ff770cdff6764d63391918cce2d5e8a1688f6d6b24d9c251a27c90de1ff2fb0f2e7dfbc750fd6a216fc2e9256badc6ec01a0e06659041e778f1693d949098c9f951c9b3130afd84c798cc4ba7b84e14dd302a6599664cda2de9d10e1710dd3f5f581693ee6282ac4a82c4cefd91ea63bdbce76014873f88dbe39c58dab5681e97ae11889e85993746ef09a2ea33df8e48c608ce11c4c7ec636d1118182c6b4378a20f9d7b06807f01c4d808a2a5298619405b79f7386c0b62577579a012285ceb3134264b8947550d6fba536dbabec6eefc42733e8802d93d6585f0c0517bf8266c7aec659403377e8a1517519fa047c6fcd4157d7937084aec86e31dfd6d36a0c06d22309620c3cfec8c005085914476d27daa32ef3ac4fc60733aad6e44b06d0b659a9377184400cd64041f88745181f08f564fe1f683e0000625041a7cdd36dbcf78496d0fa2a42d3c4d669cc4da1db78eb782bd82ce8d977a3522a260f1e19012529b3fc7cd7e54c84d9cb7483ba0e2857853e6690d8b975aaf74093441768f3c76ca79bf7dd8f41d0d460fc76704de33879b14be996c74ec94faddd3ea789549d9e2179d020a1746ceb25e1366fded761cb6d36af806d2d5d158337415f8ebd51044852e7baf4f9fcd939ea5a3d36fb1f54d08c665bfcb02651dbe9bd82575afee3544b65d8bed3b1854f7991757107fc99da8dbfd1b6efb76bd2ea50c8a45f8a006ebe8d794572da67ccb45aa7e719a278b5fd8c48bb4b6c5f35bfd46c96ab308df3b0953aafe3bbcd587416ac82534c0f57fa81b23616ac77ffa6939487777605882647542876c37542bcffd1096f3d8ab9afacc92558ab27ec281c204b40ea663bbb37d0ed4c64ebec2134480feba6dfc749c69a0627c4af87720a6347b19d0a386d8e76713edde62a56c092757b8419748c6d4d50e2e88d9e1cef55dedfafe9be7f6c17d3b3567957e5c94090cb695fe605f4b9cefd8891286315eaf670831c7de80b29f9bfd6f655e2776da1fae4e7fcb47d226bdf8acbf6ac08e83253afea627cc010a520d596a73c87f5335565a212b25db2d1fefcd7755a3925f93eb1d05e67a5bd07a8c835131a11cbfa0f86c7c4d790cb2dfefdcb831857ad03ef16096f21dd4dcadc06a4886c2ef1b18fb33bab8dd71d7695434c9b80247e066f8ea6e55c07f9d83e667ef910636d2719218df8220f310cca2bbb90cefa3c19868ac27ab1153657c610f71e2fabfcb20e8dc87d5de754289bf460522c782a7ad4695011c3a86a4c0bc48d8abddbee4247c6ee29652f8b30c5224542e5887de0b328878e6e3c1357e4e82e86fbe0d2004cc7ba70b913738ca94f56168ce0014e7895a1d7728154340fcc478c536779dd8a1208d30e69b9147b954be0ef4f4e54a98341d26e1a55b5f57f800219774fd1f41f9c89f9261055b5cd7210753ad22aae8625dc5c075449b5c56ef66f58b57970f31ec94a22e0c0b33e8a5ffa6d4ab2e1e9d4125e8a5872072b31b651b1f6eb3e18898e5f920e4f3d61d2ac60385a3142a900b565364f390d2df9b82f5fa77f61d8e0b6fd9de9f10cd4cbb53667a4b5e2744d78815e39414392305c464123e002d15bd0ca75ee4cb8c7f0c297fef841a1e2f8fc1dbea60c33b1679743199e427ac587795d2072b605fa6026ae904b3a427a1beb4d8032e6bf5983bfb38612fb362794582999060912ec8f07216194895cbe05629e35743c79e290c6dae441195641fc8baa4ca175c2c37965985a0ade612f29aa03aad2b8b1e94c253c7e688476e4f2049d9de4e50f4698b4862b41c5d4f9bfc55731810f427cc74c34868364ffd86bf8e43cffb44de9e073d6e4f4378008f8dee5e36ab86b82b526e5fd1da45ad54287728919715994928934f0256934d88485151b95cf469d6c505a541736f4d1ac339c972635ae5332bc518bcf6980228d6912f196b7deb3f46b6f1458e0199e92a4c42bd4ced34fb819769a95934cdbd125399701c661bf5c8042c844930fe51947e9ddccbc198e7e626a0ac8b33470d4f50f8e6c8c671fa4d8231d413d0fb90161bb59f9b3b3147ef550b15eb8f4412bfe15113cfb3386a064b9eea3f9b02d664bcd97809fbb3e82fe91f60dd9df1d4b2eb8936d9cd5e58b75977225c84addd352d81c276f12999e9a6a04da7bd4acc8d33a42d111f2a3f12a669f194f2584fa951af3c93ef475fe1180d22118dde7cbf23126f35bbddddc96bd8b9629b6a7a9eef21d49f8c19a5b7e102604b595fa049977a3f7804e2d349f10d8d09eb44aac9c5b0e532c582e9fe6ea2f0898f5648aeb5e26d7a9e5d01794eb49d1cb497e66dcd038c5c8023cacd1ab3dfda4928af1315df6dd19641062fb653409bcd3ad1b67601fe413727f6d121ebdcfda725390940895e6fbfe633ccd1a49dd30aa797a1808035551f654fa7476fd1bbfaa0e46b7d58319d15b940ae8b4f155bdffbd631d509d6647374c831648f92324bb3205973a6c45ee001f1503199fcf925a5bd3003ecbad6e612dafbf33557600d831d40809b006a0bc87646440cf4eca1c6b6c14bb110d0c13e8f7738d8820601a5983d2fae33b1383c870a0eae280d7eaa6040d9696915cb9c457745af20a119b4a4e9dae5d09cac8099415c017f9442d3558b406d7473bd4313e52b04bb285cbf4a19e2dbfc68d4105ed9a2d049f356d712f9632e6b9438310d509e21c363395ea6f693c17566460bc9d3bf6d9f68a1cdd2968bfdbeb50e63d658c82fe4368985493f1d93986d38c7c6bfb622e5daadd37d494facd01485e99254e85512fbfd561579b629c07d2322e61c6ab332a03960b01554e18de021610d36177c89c9c6ba8afcb542716a6fd1fe6bec43036514dceb78e9161e7936f4bca8c0011f148b681861d50329535fa3d3c1c2371e28732270f5c662bdd1ca66fc9b8675126f2091e9d342575e9189756924ae0f2c7eeac9150adcd3f5a44da802fe27e99cb15a1cb35ebff796b26cc5e1d70c4f71b6bbabc7f0c693ee3a4453d0c9af1b8645b44c5783b3d68867027b922b204aea893d349dd9327052949c8cd28ba0b6f10dc1146ea1338749baf7afeff2c25170e4d8ba4a95ba79e7521947b8f02c89feeabe9873b87458c6da5e10692d72a3834b4c110055001b336cd9bb22bb37e8f50a09c0388314217a5621a5d26a5561db2ac1411bc185c99bdb70781f6d849de051e87da0c96a7dcd5ce14ab2fbb5480c9288ebea8a2c60cc101953a6acc6d0fd7043c36a8db77111031f80f5a6183cb051fa8e07facf15853956eeb91fae7efe74c58ef0b1d27e50bd3339a763dbd721425ef12c66da8784801c1e5ff28dac331a4caaed685372ff3f4e5f1a2d18ea2783b0c4cf21ed4392ee2facd89b8ede1abb5b865be9af48600884531ebee5b18b4242de5ddef1541bc53762a43fbc9d8feabf9c2e08ca1d58f24e63e6ae26572aa6ba3cca59bb2bd5d114a769c01ff3e61081af38a8589552b20211a68e299c8bc44d72702ffdeefe3bdd0c6fc9ba16ba5b94fa430bd3b07a52b3ff624bf9e74353a02cb68a8908655872a8f3db3f5c21bfab35d883a998a13424900edeeb65156a8716add9d2bf04731b6e63a3ea2aebcb800d07aa0590ab8a1827a99cc210c4702da46186076560e3b34192e24eb29b1a4f21ed2ac8987c44552363f5529f546c25e5ec6e11917d0d66b5610da68f8dd21cbff9d4250afd7557c9b69157a2c3bc9d7db32e390f73db6af3a63260c5227aa6512378ed9ee28951f3dfacce612a1dfbc00f8787c5e5900336c568fc932ad52e7aec471376281a3caeca49b6bc5e856e101cf0974cf6c2651b4495400b97defef38d0785845d8596694deef4fc2ce0cf88647d1f95a99c9a7957f73bc29ca943238c4f49c345a0c9be81ba34c2e6a4bc6128e9622cb1d40b9c4daf7624af957e4635c2cc6ea6e8f77c668ab851011b98fd557811a4fe7578267f9e55f85d46ea08518c3abe9600bac8ee548c22b5cab8b3a6d5a3b61092b67c5f120b175387518731495c624b657ab2279b1357979577b233e921cf34ad1e39ae8b400f8ee50954018d44475e97c258583b93651c0fc6800d19e644dd07deced657c01ac6e90dff198131898e38507c4e6506c6d614f48122e687d3155bf89e803bb8fb011634e9d1a2babcec43783b8a2e7cad81afe134f10d69565d01fcd3a7e59b4fec68a0c51a9f5fa8343b9928ccf58c719add5156d68b3ba90409a8f227590c36c0fadad16083a5d1f212f20343f0e9f3cafef03e46f93d54f87b1de7ceb5e04fb68e3e67a55bc13ba3c4ae1d5a944d2fab0bb9f33fcdfe412f64fbccb496f39e2bfc25dfba18049df42ca8bfcf7d3d6743411addcbf0a8a617d4d83a1c89d0f8f5030440cab206ca53dc3411bf23ad93a57aca3c3a476442cb803cc4cacb4c4b090706ab801f13ae2c17b5dfdc084fd1774bdf3ecddd7f5a9a55f69b947d4618234802774675733a958b4fde9b4951f695ae31cce13f869ce52dde2ebdbb11e6bd55112b4c0733d18f7d5c76d05a565218ee268909641a526f3c001ac801f0be81ba7042de680c580edffaa74ca46e4fb5c78c1b3fa01d4165695036817b6c757a82e95f1d7b55aa0f7ebeb62a0176614283256edb1016208915a63b709761ada559c8a222c8764e981a2b34d0f41566d9c4442b3ce2e2c54eac771fe6282c83db1339c6493d8d8994878ab5e76198744fbb68a8f9efd3593af371468fda519b455cef024ea6e037780fb681b01e0e6246642e44bd3c3f9c0d1addbf9fcebd075ccd392865c4f2d85630e5977cb7a2bb2c2cbb85468971a97ab4f2d3ef1f7c305de655a41138304e53ecc933503dccea9e04051af869e7dbec25a08671da10a56f76b9f5f18eeeca21f1037f9141854066c8985b40ec1af93023b2fdfc65f7e0fc5b1d8ed2a1b0ef46b70515a7092c61d0ea562b77db7afdddbd5e6d85b0e7ab95792fd9991ea45b449ad27e748b83a6eadb74b480ff89a0551f71ed8d28eb658985e407fe551060dfb1ae209c984369345a6d50a3cf958a849173abb604d216b085627617a89ba2c6f0bd1a7632f6f3058fb7a4e5f241c616c4f4727c1883f38e70f2d302e1d49fec088ca62e2950340d552f5138562e65b907bdecbd28a1f5885cb984b2510f9c9552ad343dd20f136a002fd3fbd0486a66ac1c19033f54353a97473e53f77c6b9cf78606858deb16c38d3100bdb5b9a16742d3852bee08438cf49612be9b2a45cc19474dd7e87370670b6d103ca77bc9b5409e81d96b71c7cf78553d19c4c3cc17397649f9955ef0f3aaae52c55ad3123746c01126347e8d9c75bc0ee47d3368411fc09997476e9ca21fc4a08c74fca84e73fa60a6a1b961cb99a6c173a758af4e61f892c5bc13f10952ceb6e1300f42f2dd8fc07807b1111a654dd6244e0beacfd7ba355e67c33146abe32ba59187f0d32e9d46ab4868df8aef8519be98fcf7fa1a0d63a7e0beed7d2d9abd29a5beb80dd3fbed5e94510770a2c2345113130452fc784fef6b746828165b930714ca65a5b356a192dd9e9a6fff3543c4e8fa1d445ea3d3fe1cafdebfe797c94c16db2fe9ae2ede54cf1592c080227b92fb52b095af59422a65ab33ff458049278dcabac7ad377de504f9c57c658bd9364b523bf68e14e228333cf90925ddd01fb47af463f474f01185af96b3114dbfe20ff3cf2796a811d2aa3d56ba651f37776f393d702dfcbefaf3df4c5d081df5b049c73a74098acd380f8ff902f3849ec13e742bec5845437f0270401cc280f4742643ef3a73200c1d743addbf53e8e2efdd59fa128398514864895d32297cbba341aea9f42b33605347758affd70e2da6d3e22bb574b20876792b907162c895b988fcee0a41fe102844b9003a36d9be09279415bf6aa104e666f1d5d3c1a19052bbaab04bcdfd218732138e37b5867dcc3b72796d2732cd09c337ff57d16816375b71405141a19c2d9dec09327586944fd46e7346761dc427e92d43a6760a0eea10cfadf9557a8c2c79d9d6f6785f06533220e9ba6aefcf5ea741445af268baab24d7ae4658465da9d267e072acdff136cbea577880909d666727c68d284900e0ee6c8643b4135da5d1d2a371310f888b1d88d6e6b00f05d5e6e87b04466d0cf16f9b23ce7e4a98cc8bf9dbb1407e2189c4ff6a8b3e1230c298b1faaa3143bef24f9972b729d0e577e2447e7dc20537fb692966343971342698024eeb37c3517b91b381ef3ac6f7264deba800cfebf1af5e6d37406f4e0452f3e6bcb33d49229ce841c7de15abff5d91351fd7222f2df26e071fa55a81fd98dc22fccc9fdce93abfb501fcb9b9d666828f97a81065c70eb135a2e9996bd2ba2916d719ced343fa1a3b053d6b5bec76c649c56ad76493c2ebe06e1aa1f038840faf0db454d3cce2ec195d12d4a6a921541eb44e990779ecc04477639467d427f7b05cbb65e68f9e4e86e31b9658eb6cb0c6e64eebab040bc1a613771f540089ab1d9a5167c60546b52a9795cb1e968819b5b6b778ed7b53497b3deedfb090a3b78a12a79ec2a351bd3fc1809f6fc86ff0b280bc8313c4c62c35882dd3cae1f1e7e180adc04b918ccbcd2b3f630caef37bad91ee5f865105d930adf7a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
