<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"070e6cda827d3530797cfcfdc34fa8af165fcb1fe8e738485ae4cf970f1942695ee52d70df9d18ee06694b3dac99f2cfc64ed98c4faaf9eb1abb7032ee212f8b02ab04b5f1d8a2c17a55cf214c6c64cb0341845eedf4a21918be59569788d4fb2d8a6a9a27db687248946c0c564f4d1168527e1d2a3324b3157a4d84c6afefbc02366c64e568d87b2ce61358653f71130630257a94373a0ffe64ffb9411490cffd7152bb92cd66351171c441811fbb6b2b4b0596ea41d73bd6c168bae1081d179c4ed01f5899efea0ab1ba5ae67893a4558938eceaa341ec6aff9bf4244340a132f9ebe5ee719c5113e5257415eaf7ddb83859a5c0815805d7884f790a598f587c8738d9f1f9392944020fbaa1c0012f4f272a1aac4af6277349f160c68062b573ab793519c986ef876b4085e3011213dde590a9e6708dab093c416d0c072da31c849dcbf4d767c0335c0705fff2a891013c8ed25e339682ed5d2e9fdbe7a93a4d47fb5667ef254773beafe9906b74dd1ca970fd82e23e9a696797fecd0cedb04a323b9a972709e5b2d495722f14290cee0216c66ca026cd9be5f7da8a3d4b1040ca32d3bd762189fdff6f9dbb82ac3b7a90b4299ff74ba5db785466addf228180cb61a20b1b6160672fed36c59ced909e378b666089ef817b9c44b7cca65c3efcc965179b1424bc275d1d70ed0871314fb979b63cd932d18a6d03b8372939730bcfeecae811da565a3a25bb3aa081a13c18aafefd1bae7c47b2702323474b636055a33eb0da9127c5b77ab85e5ea8f86fb95b35754f5bfffbc4cc67f40ead6c74c62fc4d13dd48678f6941af842cf836688f5ae0fef6ccee7348e6178fbebb321e47a6ac1eef52f17115bcb9b7dfd1f8dad02d992941078c635dd431d276a931ae25cb5157af38c9f3f2ec32ed2205b9ec36954fd580a8b8588aca0a8ffe7d5bbfca9e4a289ee50d3a39e5a4e809cd2a44cdfc2c786b9958a7ee6c55dc11a57f3e0e4d5400c2cc5ae5b8cece045b539fc51a7dd289232270aa281872065a14e84627aadfcdda375f75f3bd7329d11821c4e25991436d7f9917bee04836d8d20013068e497fe215bc03c9e98cb8a7438bcc1d1483459346a8a87f83e01c70e5ab76a6acf36c8a9a11403315404d4bdec233275c72189af758accbba6c34a65c4f92f47229be86857c203e76ac712bc44ced1102db6faecccac994dfb8b04666ce6f539bfe48a95d57021e6f87ba597319d2810da4ba3db1b979bc8dcd447728bbecfbf80a25839350e17361d13970293ad375aa98ac5cb4b7e692ce9908b2150071748c490ff4b19f119e489a416c83322f542792218510b21dbc82538cd543a2f6f00edfa79bc494df6f1da31567241b2a3adc24d7c8fe2ef988d6ef6d0b584f41e4d08032530a846d50316b151ed70029bdc4a56742ca8fdc7a85ef4bf9cfb0c19b58b2c745b2aea4588a916ec81756d76635617f8c2bca8648ad9986f5e07747c2d5132b985426c2bb35296a273b3b98164b648cb07da1f286fce9833eaed63039e334f0cd73f049679709cb7d129633414a903644ec8c10fa5ec400440004c7619a182b006f038a12390bb33adbaa6744925cdbbb57c6058905f67d7bde44d79b45b4bb6d7e018376e1e9bd2c97170b469574cffba5b82afb086792b1f39c3f0e51c6e617e7c68231234274de29b63361ea8c596ed39eb8915a86f7e5c4848b45155331ccec48daac7ec2a73ec7a6550e977a209f1844382e50b870ea2b7e92e1014480ca53efba9cbbf3cbf2d8085ae9e7ffba02958589a9841d6a505267de36ba921823d9cc683b3c38a4ec984f554f035e31525b4dc95ee8a45952b80d8f21dcbf05af1cf0fdfe9d06931cd3df25bbac1387b41459fd6f4533d1e60ee7749701322b6238b5670fa60c100fa5fd93c44fc6b49c6a17676380c5753fca01dc3241dd1063864c1118dd898023ae575f5f34cb7d915fde2c2329a2f67671ae63962b15b2d3eb4dc3b650434f40d4b3280a2efd1462826a8186accd8d14580587c407163793e3b86ed8ad968a2c4fcda30a08c058fe2a93a2f1b992aa36c2ddb9e318c3cbcef40cf7cea5d12d7327c3d9d472f51d72644feba0ff9b5fef93e7e303b921ccc294f2b0deadba4fee0364a08c6b8b39817e829c3341745199fd735b88adc945e890233d384feb663b85c02d7d380c06435d94bf36bf1a10535733a24aa31e152888406f91018b866a5bfb3b64b1223b8895d95d25678392adb865d3aef5caf15f08dcd954128bde5e0ea3dbc43223313e56385e2104294b650b70153bed8c16ee4d536cd7a561bed9bab16145b884c5dd754cc194aa77f316195bf25fe24162bd7b27ed778ce669d0ae61e28ce3b1154e1afcc95a09a42bf19a28c07515a4e0c2255d89fe0d2eaa0279dc50e7c6e1248c48adab84b2908e4455f43b596481cd6154513391e1e100c5ed66b2506f2a2b3de674e36bc417cde199f2a68ad69803eba6052c035b71d6f7f5d7f6dfa550c04482905a89f6eae2e1950010accd7cd9a878f01f1bfc440b7fae73e5883122e0dbfa34d8896c51662e672d0572bef2e701d2c68eda5f1621ddbab82eddff2d830acadd1360871efa828da77324e6029c075bc68d46a73f798bc8a6490de24c5111684fc72912be4ba4f4ffeb1ba09db393f07740c7af2b40786b5feb794f73e7d0701ba6ebc0b84fb6b8b8265168a44881065dda2eae40605e6660418b1d1ad8ea35dc034d5a6d7e613c0de78863ebcf4122348167c0a364cc896ceed9e00763a4e4d1e072035db6ac14554182782f92cdf8e3e5bc898c63df2e2f1ffddf6fce1be37ab92ff624fdda3d07953ecfcf3ffeca637e4de70603d550958724bc81ba4fb03728c3074c9399362c8fe461740c2b68b27b83d947cefb76e1ac5c472f70751ea3b615375075f0139b49335f144d3abe0829b911e0b34c8571d8b82736961b53b48bacf151971adfb52d62a003f9a018d89b099e7a51a7def674e630a1c35dac3b150c59d5a76c339a30eded6d22ee0de277e16364312bea93adb0cab65f1494d14747825d7d1464c755c879a154f2cadcb90b6524a5af14e24c6d6e8deda11b84c22cb9d0b5a4207830b503a5aa917402d9a170ec95ae7c68767e5ddd466ec245e44ef97ff4e9c55b11b5ece740f07e5110335fa4b2a9687d06c3bf77ba1a80dd58b0da47b70076e22a7cd24009668c6880489dd9e8f3f4304b61f1e52d1ef1ede10c8617c335a3776f682acc7ab2c26fc806ecb92047617630191bfb77e22c62caef40c89802f01f846c63e2d3a17b0d5c01fc64132817dae840e88ba4dfbc2b56410c70e73ad0750c0ae1e8a956d13aabc563f3e1f708797e1eaecbfe52bb5f2c6e05b721193f5b9fbe121340958239843dcafd9e5efe9243c60258c873816554f1d9fb7ffe970ebe77efcd7cabda5958bc33cba0453f8fec44d5f031e7c4ac42066b7d765e067e5a2475b94aba51e821ec68c17e69310a5a43592e0aa263067ef1ff3e2bbfd4e665f863bc19f5d21e9a1c2fe01e412e891993d35260c557e2a0de92ad2ac953b70a200c22ff3a230e20919b8b97f236a7a3c6352c23287725db8e2049515fffe5568e70a1e0a5b508071d50b8fd4ad0ce0da12d5520da4030b11c15233db61832ce1426ec347b39200b3c8bf9da0b0df620092c31edbccbd1bac48270d08115013719e1a360cc10d696df89b6ccb5b9e98f8cbb8bd39896d028e1cc548a0419698ab17763e25d25d46313db40a237ec9fb7de09cba20fcdf9f1521813d0b5fcfd4301b102d24a2e37ac1da4847368be136ae41d3a6bfc23457dc68c3921f1d9a87505328eb16a1c86a0b5bdb6b655bc2cdb7a67d0dc3bde19e0b5948062d6d7ef393412dd89ce6db777401c3c99cf125c4e984927c01b80f7148050369d54a956f0da4686c1164bdbfb333a5665fe65c80af4d968caff87021abd324ea755552a3d094adaee4d39ad9396e51c699dc5514f2d7cce530ad701cb2582b9c7f18af10b9a4cf52ef4df65ce2380c0eb3876a82eee65ddede120d6123c01b446b12c062c86a01c05a72e0ccf3d866805e75f624ac777c8347b0ebad0008691653e21d05704756ccbd1d544110d03bec323e50c74ab28df0f5651074dfec2695f06a69c0ebc0a5df852940c4a059e4506e899b074294db5d204e7f2e9a69ed686f85eb11eae2c1aa1eae338026023dc32f840e14fa6cdec7bbe5f5d82d8dec66613a1c1be0654d00a6f7ce834c3a276e794997ca193c54b2d698d81ceeb092a5b0d666562804688ab8169873a239f961c90da0fbab6704476b4f8a90f44318b1db93a49e24a64826022f8b80a41234cead06733c565a3bf20ef1f24937ae034dcd3e73402a6bfc4d332804accebd12035abbe29f14e694c382c1d00403956ad027d780e39d2c15e659de0388ab8958ec7c319f89b2b9cd428d942808ddb7bed88f220c75fa336a4da8e523747599297430a4a23d6a89b54021bd11d15efb87bf4e172ddb1998d15976d1bb93a8ceb19ee0cfe72711ba51d316a53de7e4aa2cfcf57a1f5d0915477e8911dae4f677a7a1aa35e4899230ea3ee96eea630ee05e1dbd9e458a7402db6958e5b53179578116b99ddab730f0cf112bb370c08746027a2841828b122f73d3d32d7a022712b447f2b824ad9b9c828bf18683ad9d5f4509436738b9cb1210e61813acb76adea09f76ef22f012e277a8bcc801c88954e03ab46d6069410075ae9aa9dbc934821eb4e75131d0fb9e82bf3074ecce39da4d3ce35869168ae5caac49616c0ffa8fbac81fb2acee76a3d5ba2f1dd031b95e001d157d66a91613df3a3ef659c2c01c6bcd088f1100077d81616ba35316aaddd8151c7281ac5aad8217e6fabd6ae50d7e1e67385a48b319b0ff5318a15139a75643c4f663a1bfeebc747e9e24e0ddf1462da2ff561aff2718a73a523f47bc4a55ad535d552034631aa48507e5df4cf1d5e963734a1bc6caceed288e46e922abb743674dec1cf3c6f70702bc064297f668a36873c8c3786a3440ae1ddca5e9308e77b5547369f82a593b1aaba9bfd998d71459ccd7fb6bd2c4f574f7cca62e3ab7ad19a0ecaf2943d907df30a4d6ef04f5e7d5570a38f5ceb63ce171cabda9e011c23e5ff8aed201392da5309a16a8fe25b4a535c81af672d48b48fbd90e097947503c379291551fe2910637db52c62d2f3e191a038c6f8a5ee9787cfe613ba7cea2c33135206e96f4a72bf311e7efe3cb61eb763819c86b6d6a61238325cda24dee01ece1c2056adcb7a0b1dcc37f851e28710dcf6d4a1560ee0f7cdb14d44a6f253e4d9b7897312cd9e1cb66c0b70007884afc4ce90efb0e2b9bd8179f9f91e0daea218ee7798f22239da62aba0c505b936341817368fea3293a313b95a032e9d6d3bb062c4ada82da751920945e4195fade24658069f0c74d0265ebe3ac132f070484cd439577a8ce4c09bc6fb5e3e258b90a0dde79fcd955618ba4154f9337c589e1def805ab11ec18bd1a8dedfa4207d39529379c6e87636d1d70cdfec35735d49be550e57b30900922ea6f9fd248c3b7052553486c7d11fe8cf15a05f97fc3aa16a5267b9bcf3b676eed17003e078625844b59f4e985f81296b22fed1aee816b9d295453ed7576f05418ea05f8fbcc127a6d52dd4b74ef305cdf93eaf218d410fc576209a37e862519fd7a45649c178c935ce4eeae5e0eb16d6681b3763aa694ae7e710cd6b9395544244771f59315fbc9de56d7a9cadb5c06405671b755de202bd8210a6815dfacfeb8d3327e3007612efb257c21dc835d2699eda4828610e8dd634f48df29181ff7343fb64d88279050ffdab7915082a1c11ba6bc2260c5f128a68d53ceafd0d77172fd7eabfda423eed4cab8bb345f3f84723d07d128ad435e54c75e476b25741cfe5f141aa3942de08f8531c706efc02971b736e953b603569506716e6959db8c72051a38f0fc66dcc4284d4e016206f3af76a70f4a5d0fb0b2fcd1fb5a295d97f45a3b6ea706eb4b886692871f31980eb373d50bf385935b8c16262a48be4aa3410e989c609ce2ee1edb94d00c991229d2c551bcb4dc02d3b5994e390c050205da023d09b046880bdddac1648f7bad4574da4de59f5cb93698ed90fb1a4d2cc88a06ae5b671fd95febcf73d5b614669d3d290099f57c8663f242d11393104bf36ad330d15f14388e5170566ec3757ab0a14146d45cc3ef990cf41a29633f9d0f990f9e34ff214ce74dd28d693d19c371981e6c650e1a6a3570391965910875d65fe2204c4fe5cf1be7dc5ff985d6c8651b1c66c5a5354b1eff7b68e95161187ffff6e11c04cfb607ab09bfef8b740fe5b2693b373c3044c3373a8ecdff64a3aa1e7941b49b95a3c1a7588197c61cde3d4d4ae4a36cc5b0cfc3711ef44e80ac7620fa97c216b3747bcba47a9d6586e5559aeb6da82395e9964a4d8141787fecf01c4a4a34dbac89c1c714922e3e5e57a2766f974e5d39433e6688bec9cba14e245de699ed62557217300af76a376f2ae0f33453e7e021c7cb15e2d4bcb03ea130493289c361260a7fd8d8eb859ae5c5d9ad0125b9a577c90d90e8fdde765fd9d8d7dd2afc61986b1d35386cb9b8e651eae4bdd912ecd3a516226e8b5c1e52f6702f0c6aff7161c27492620ad128cd6d51f22693df7d6e3b6e9d314180f19bd1c266a3c49b18402140e800beb3977e57e70b8cfc7e25c003923a082de6b2e65494277d4537db27de294c44fc097f077695036672420fc6cc1a79046082089ff5e7a79ec6bce43ed1b4571fd8c3fecc35734c1a9e59005f0571d97838bc27f8de014e41fcaf0b4b75009b5dab92efbc1f92a5f6c22f9fd3c7ad383dc1490c8924bc24d1e0a7e538af95bf332bcae66a43cfd875bc3f61023d4fb9c354b3de8f91d2c72e403110187fca3530edd717fe13a81f0d3b3f43ee23eec01b05ceed87ec2bc6ceaacd07f036cb1db3a9f477703c31f4b84ea3fa7f66c8d830b00408a99a01fb5bbb5c51378f00568fe5a6d534cd86164d6b013fd16538364426353a5513f934b9feec77ddfd734765916da00114f9d281ac3c62a3539865fc3c578482e75b6a9a3812bd3fe472340434cdc7092c947b3538563db50eb162395947673ee14ff9269090c20a94b8cb8cf1da5a445b2fb91cf65449afbeb23694e92c71c01e0c442c53b7978924c57d3e179e6208e65f99af0d190b03b1463cf9f293c667bb0ce8becc8236ae2f831366a1f229bda7e8cdd10909c6d3e0ebd1a9ff3d9da95cd5bb997faa5bf11df3e4afbeac70446bb48009bc056bb82bdcffdd2984f8a43c2543aa1eeaa1b8602edf229f6ecd83c521a5a772c3b825c0e9ed0e5d796128319354f85c1ff9e0c05c9bb3e7e796363197aa6f118a295efa496cbb97bc7100d964c5b424893dfc0a7b2035d0e53c97cafb23ff49feda34dd25074ea5ab11898a8d5ad519e3033ebab03e9cf3d257837ae064218c82e20f3105f47255dae2440598b7c0b1d4830d9d408ccc0579cc09c1549aa59966dbd2cfa436a22f7b9ddfdfd90cbbbe76a2a67a29d4ed64fbaa1f3c799016460bb0f905e7c64fa76147c2a9cf1d50800ad47aead8fab292965147ba4253b66630d99504f42517e47e6066beac43aaceccf27e6a9ad62a5aefd06f362f0855ea9a6e5519b22866000152e5c87b459a9a59fb4e1c78b16c9b7c9ae0cc2c1a1c21b3e630afb4e1304798b764cae0d78a5f91ce0ae6a82fd95a0f3fa4113f6942ea889d0f018b68ac585d5a0a6511b086421f45941aebf11b0c461d6dc94a931f5f4b136943025c339c539b707c7fe495f2f2d8705f02c30feaee83dfc32bef687a47348761c66b40c6f930e869d4709ecaa6891886893ceb15c0749107599e3f3c3dd9c124bea0ebeb566614d8e3d379d2f786cf876cec4fbf8ee8c3111062982624d77faa3b22af3c5059d43ee6c0bd27914a0a6ce9f5da2af028fb8ce654e79c1b0a72e297ed0ca80084bce79bc9f863266ab5a1d7271e38541f15267abaac703db60a7386ac19195b60972ad7a18885c21e9dcde1102b927d236b75ff4b6dbd7cb2c017f9bfe1dcc858346d517d7cd6f6c3b5fefd2f6781e3485c47212d3b51bbad6a6223653b861c8a1ba2cced0846405e31519a00afd718788130ab9125c3c38c1c7c00d1c06f1a48521a85043d714f7f37fb4d864c0ebd96988339cbeabf6a8f465e7cd37001dbcf0f3b1afb86780a3bd0cac59ac46794b88e607fb10ae5f9c214d0db6ea980033fd5300aecf81e47ed8c2bdad34585b9de0bde8be552727daa70a4548b087cd69d55efba5d88da771e1c6d36a418fd90d19e925c92747b072b70aaa0e1b098b6e93bd2187be4a85fd38868fc5561a55d796c25e1f7318864b78958694f0d16cff1593b8ccd519604daf7ac5ecac3a9a41a69307a6fe28575b45c25e9573b9d66658f7849c4246a3f08bc20814ca20835372a4eed728a435c8f1cc9253bd4015955e8af762414758d4592fa1a73c56bd88fa40486d763cb93d3f549bd9739ed812a7bc4c0c749fe8455cff447fa3151d9ddca80b995a7064bb1a21d636c7e50eeee655c375661ac33b7210d0431fed98c35568f488cd13cd474cc5f01d141dc0cc49b0348044d7ad3824cce91577aeb2b8a6312b871fa563ea651752bf4a5dc12d5041236a163c9c41a9c1e9f3b38cd7f5e480494b5272258c48febcd96f5f7e76c33dca66a0ce2f8507de658a6c9523fa4b823f740d81963a07f0722cedc2512d397dafdd3d7a5d69845ab715ad2d4f58ae308904eaaeea0b71e50c6200890f4c220246bfd7141ac818f5845cebcfb962298f62912bc8fe40b4cc8b17f564e426f344c53c90699e8fe5445cbb40afc46703d230fb741ccfff138dd44516f3ed575f054e633643574b8f3dac37954a8e28cbe0bd8ea156883d3f2db4f18f8a2ca9d28fa891aaccbb76b00952c8f86ec998213a0259ca167c0e56be4330ffc89527701919182d10de606b23c8a19c91e9365366509475af933dda95273fea1dffa26b86e775100e4c47a58f1b7d05768671b701c26681666c1b41b7f13edb5a4c56f98e276aedbd5c5696a385f0e23e6ab318ceb088a51d4d2dd565c672b8dab0748ff7a25b6ae3f5a6ba9e8e013d1f645d4f14b093d40eb0ebb9ff0490e178e7fc2263456a92a5b2ceb7898e7635f22dc2908a07aa93493cb57e459309879bdbec5b13a25ba4793defd9d5fe0f239f4910ceb3f1c716b147916a9d337305cec2d157ec4fd71aa6a2b1ce5693848fd68a6cef8b35572528e9310d389660732ab510295d5cb44d996732500db96e93232b7f9d54b94d5e710fcf1eb524ef1025113f10268e532e61c2baa85cc8ffcf3e0b7a7453712a6caab2b7855fc8de7ad0f179d9105d23805b878624e37a3b44e0fb2e743d0817e3da89a2c211b080a790e56d3c4e251869b34a2cbcaca7d63df965135bda1fb3d38f9e99f107a1fdec1c1a1cb8b2a2921a045bfe99529f28f1a7d52bf9ce4654feb993447746e61b13ef74a627bd2e90fb98ce183de573c86f087ccbf42c4a9f4e9b368e0511cea814b0a3330a70adeacbace003287b2f955d5519c455ec47d6d071644c775522d5a4e231f77e9b1ad87dff2ee64fa06ffb9865824c72ea8b89a762f989d434075277502b4ec8906efb4154a6598b19a1e69463bdc7f908259d47222e5c518ae3f29a79a6dacb8799cfa11ee8b9f6a73cd3c37c03886611d3735f7cb2343bb8a9282a8647a9a61ed37d18aea58bb2b599b809c81dd71e54d91019942e620c472e352f87322a4ff8c7c5adf6e839d68f35311a1749a23ed0a83e58ab75e796aa427247c0bbd2231ef76256ff2eda909b58f20118d0b4e02ac72ab79dd2687557d28df5f10acdcb77e53eec195890daf0c6406064f1a4e6d635abab8d6ee24d1a83403b17c6ba8e039977e2e696ece84ce642c80ef675cf889f7c1ac7173b9c3a47e21ac8724852aea0b8f221546c6666dda2ee7f8d1daf24a973e77bb0260aed2209ba1f8d0b6f530c4df5042fd6969f4b1fd8b49b4bc6c5db7e02fd7cde3e02074d208c29cd341232acbe58f37642144e9ca96800133817f8ca6854c58356969f4ac49a68de2b71fb99d9daa2ce1a8ddc3b0284a0f74278e316c7c6d5cba94f2bd4cf172c4cee4ea4775081bec1c7050dd20da610ce65ef063d0d988db5f9126b9e335c0471f11197c845ff968496fa2cbc909bdaaebb4eb9cabb10b22f652c0f174f73cd366784a8ac7b556e1181d8f50053fb19935d20f8ac7a0c170686a8382448fc157ccc473acdced996c3c950741843ff2b9eaa4e3945dbcc4d457c11d01fcc450b0af43252285258ce0eee67c115c89833190182e1089783d4f35899615372bcd71485c42824687ae7c22d5f03f9cf75eeb717becd565f6d6dc5206c6d0f4001ed6d5766ae958933848a09aa4a38fbffe265cd98ddc93fc5464dbcc474fe0eb099aedb0c7eb79f60076711ec2e18dd48bd1e72aa93e0184607db439ce4f4566be1b2f8a9157a6686bb8e90b21ac8902a15a732a0e6ab7bb48f11c1c084c04867bf382a7a0a8a084a3f486f634baa60f2bacb9f33a06ea105eeb215c65e155cf4cdd33949082593d456ee1b9b43f3c1d011f95dea973be5fd0ae8c3ee3a0d48d177cd74b49c570b5a582934ca0b89883862a84825dbd4e60cdfd56fcd7e36c502ac52ba4156f7316d220980ff46ab8b4c482cbfea2fbce4a80c024be1bdf6eefb2d5282c2f4b887fcc4ba8d896428091eba96c0c8b2670acf99fe21d4d647d92f8c0b550282e3064c251e7ed9cb32ecf4a460e94db95d5aed32662d89985e012e2632b5d746b901ceffd32a575886e01b46b56faf6ada4d55e6ad8d0aeb66b781cc35e0b2f2fbf8b001e69af2e7aaa119eed8190a5a2d0ef8fde6a1cb8a48171553ea506fa0dac67c4b10f4444f1c93c5f2d2bc24e990c78f68bf6daf0a4a433b9134aa10f05a5d8638ca4beb13dd07a5b7a13767f2b7b50ced8b42518b718d151680e17cc4eff7eb9ac9232d6b1ea183ebcef872efe8f3ab3159bd8219fdea64a9a965f11e6076fa232253646191affeaba1e9a1de2e362fca81ae90396b2cc81bdd82539025726c119971f908bb84249699de77848f4fc8e2a0fa6820d9454194e5689ba84079e2a8aeb64e3728215b3200af592bc8d91b38299c5b7c1431a2de9a0c9e28381be424b70d528c7a43e310de38fc76bb7f6e0d94407eca41c7a9518c7d8664d84605584988723594f3ee721bfa10d416385fe2a44778aaaa8000ca22c258d5dc13752f7f748046512ba750704bc48cce329ae9475678b4763adec811afdafdc5b27e774f929355316c214925c3e8e44ee1df846aac72e0ac9a987353b2c425ec8d34505907a37c059983309b27a4c2411c52ef3282cee7f195c44f7b1158699da3967404d97b55006c86121985bc14c4b206af7b3dbae43399d7efd8e145287aa7cd0e2d69665200f54d9f1e1efb714bb50677037809238e7d277e374bf053269d65e6a7f79dabb2c5a42ec8c383a700dc80a49116f13c9ae935a7484a135081582b8f2add6e7da790431205e83a96771644144621e49e46e22ffd30ffa0251a18593b9d92268fcff3982f8cf2da176ab7ecca9f8feee047bbc075f860e5e0ad5664eee31bef1e8d95c6bf729e59728fb7251a1454ef1fa3549b2d596b3de93b5343e1b8eb09d27d7a8f219b2a802d5c100b624f81b198cdad08c27b6116b045cf22d664d4917ddfd84ed8dc4db9dd8aca81e6dd1511517b002e017d72347a1dd635fa93b1ed669f9996961d9bf3423596cfeb42b283b87e99df8b82d280b2f6d99cffabf468f4e50099e83738aae6411e1aded3aeb10eed9cff4d3409f68f9462433dedff1e9b1951755b498ff1b5e780fe9592526204cd766da70b671a249a7db9dd95cb6c308e0dbc0d65c8238ab65c11b4c510497a8faa37d08bb9292ec14b3f00b1ecac2753a15f806ac198f1165f7f9a47e8f5dd924b36231c77932b02089cbebdd5eb95d462ad6c34df795b481dbc2b753a3b75602fa21b082bf19423acf6ee6039672542eacbbfc446586281df887af72524cbe74ba18e3de4c2906ccfdf00fd13af4d17c191850d436efb2c8fc8cf5a4e99c2fa4b71d89c6346f58a21e76a05732b4cd4d1a6707ac2383b069bd6cb6dbfe144d136503db8bd9d2d38a68d1d21d0ad7a4c848b2147a0d0b0195f58981128a64117b804f22a92b4b5e617c0d73bb70292fe8908061acf9b0bcdc4289dc346c6293867215543b8afb401003b30c078e7a008fc954d71648bfa08a96843f9756973ad300e96cba350ffe00c361d2244df010d3a312a096a6769831e224da804718181f74f4359d45133890f44f06dd13ddc5d11c561157914023dd3ce04c6409c6a9990f48ecd8be61a7910fe36bbbe3417ae8aabc9cbebdcca1e6b444f237f770269571ed616b328735f80de532e431779c46cf98d1068665f440a0b584fd7788dc48344add71d40122756d929c108ebb07ad6b33a983ca8fc80a6853cd02387d3e6e9fce690102064afd6769171cd4db330eb4668b57adb4bc19612369f536eca636914d07235a9daeb7c131c3b90b263ba2a14d6231bf3b52f669a7dc92f052068f27e3cf0d1d8e7d9638f7cce805b4eaca0db02efadcb81e83b6ce4b628ad5b8dce841318e2f0d0a75078a71b3f83f9f3a5c7fe10099742d23bc70d87a8b08d3a5789b78a8ad324409e1bd15cf182ee5255a6caa1bf5f021367e2b72bc34ccb2ea263d6d50f42905083e326929a8f0547e57fe32b9a6f45c186ee6e94f79c92b6d5ca0e94fcd0e71593656f350ac410b072ddfbac416046013f37baa69707096ab6a922403299e1ace20f49ea03d59e3cfeb93cf073d3098614756066c7850b89ae24b156f47bf2032a6fce3ba38d52e0c3ccef6bc7338e6612ebdf08d99a0d2fa682bd8c887903013dc510128e34aee11367a73ac2b804f09ae95771fb842cbb0ab526b7e863ad7cb43a5c1d683272200d431195d01eb45adbe538ab7198a7b2fbaa52405a84640f6b1bc6dc6f8b8c099aecc98dfcdda940f453f1633040660c294066fb9e9f9834f7a7dcb69d5bed7ff8815038eb8d36ce4f421335313c6ce8be5e509aed7f49bb87a51ffdfd6d0f3f032cd9b9a303d2ce04d82c896c006fcc4b8b927682e2352f2a0f1ff15381028222c2c5c01c2c55d37987951f97ce2d55658a03ac8da12521e9a4534fbdc6c3b354d5eefc761b706882581d5cbc5fff737351d43c35ba96523a1f1bfe5606a00f69b680a01ecad829896ac2a523cee3ad25e52b25b17de727c70c96b014946a2ee5ae44944652aa4912a07a758d94a0c8bd26420f6b3ee646354ed494149aa525ae644dc564c36d5f1c4722c7afe338f9b0ebe6b43140087f3b4edb3699759265955795d9c16bcc507fe597dfca710e9b952d558d697771d19c300ccc96a6492545d0257c12a0171cabd95e8ff9f4b7efef90ecd5f30f11cc8da7084cf22dea6890ecc1d96c5401f0280908399131875d3abdd5705e0812aed2ca3b61f73554423167da7c0ccfdf564bbcda2cf57fa32df4daaba16fccf5285dd98630a9bd3df60f94b5d740af7b1e198a82f981e2b5a2581c2838b2b1110a96af110f035c80dc3995c9915acf7e7922c31efad0a52e1a072fcadd866388eb78e16e2c2b3c95c0b2d7ca337327bf828dfffa1ec58b723fac3dd32303a7e0b06f487c32907b7b1bff372adbd84ba9db8de58d59cba19d7d1f856ba50b0b786df236e0f68618a5e048042e00bd68ff1e6575b8da8b87cc9315b5a464ef4ebc8ad62eba69ef32ab3b1bfb868c65bbeee48b081d40e849253269be235d19d5852d55e5050b2b9763a04594c7b77132f771f29a39cf0d78ab8ef2d70c9ba97554541ca9f0cfc85e6179bdb46f226bdeb5639a63de955736ebff8f68eb5fe274504d806d6c2c005101d5f4a66b0b89f35262a67d271adb210189070768d69c39329699c98d7023d0f16ed34ef915fcc58c54d7ebdf214c769adbe6316684cc3254fbebe349974055c773039059465b456cd431995dd2d0ebbea9c9474b4964822af374a9f7175a03501f1b5c03d8fc26bb0691b62fb07af8f6fc7f262ed55fa13924c376cc944087dbd857d4a194bd7aeeb53845f9cc8ecaef3b803f7b4f8afcc6142266971895abba012e842bfeb43c63baa0a4c5d9756e07f5f8c9d112409d665b07621a2ce450c52ecaff37fd2dc83d672fd99149a78757c7f7fd9a14f62e409e986db185264582181a930af2277751e0f62197df57661547c31f238df92013271d7819ac2554f212e2909413d62e675e63b6929c29243808151369cce7ea6ab6ba89672b0d740d442eaddf55cdfd3e413044549f98183fb69be1d66c41200cb391f2a64283f4110bbfc9c714cfec653122c8eae6ff9e0d36a3ae7457dd0360f38dca41778e47682d5a45abe2c6b32869feee9a40493b08c8c2a650fb8475717a2ade4a6de43621676f299142ab38723b93c9dba1fed098bd85bcb31a53472ec7978a12063d3078ad31083f25c3137a3a06af87e140532f15675a11b77e3b558eec138ee864e2d861d8524e81fc20da10a3ebe7cadeafc988b05351a8fbe9aa72fc9097b687d04b1536f5356061f31943307d263fcf5108e6f1d8dee98d944289d942ea132e6507aff5057fbd9c54116aed20f20acdc9232672d80dc9d9dc110605bf160f1456ed9ae29f2fc86b4ad495a613205db6ac14b56f224a84393ffd0f8a50a7fdcd14ad18b9b842ef11240e3076ce991d1a23350d225c512cd9e628c9ca204033426b4d63b226deb191886aa2710fb1ac6dd3c33ff8bbee4700c5acdd4f1f68023fef0e44bfe13faa51d21226ae125f2a3f99d2f1d701463738143532ffb9c4d2df2d79a1d21db8de2eb1fb90e1b98e8042d530307f42e0fba0bb7228f9bd61e5c8645c0c3f83d861b2658973e5da3613b621cec772046fd9cd5aabbc9e1235ce3ce83059b3cfb1a1d7d25be907a41e21f621b1795a04ec5605dea71760d7f0fd8137a504c8b08ff1e01890df1aee413cd01e3b54540a81c95699af57a92af1e43b8ffbefe2b2437d02d303c72260a120bde7a8df5eeedac0ca28c93b78bc73cb07fba6453448fbebd5e970664a8c181b8fdee90bd7dc7e3b12a53890373e36d7901763a6f46597eb3d0bb53aedaad8730701aa75b0249c24dcfca025f7cc3eda8da346e377df811ca2afa45e3a518e26ce94b7bdffa596c90b4a493559ddd0b334ae1ab1c1d075643224b443a8c79751c3fcba47facdefce2280316f1648de314897cd34f95f59f0b534e082756946eb0b08073eef6c48b4e66835132d7ee3cc3af2d43d5c1760e6bd5d17283b30c7ca579261aa6a4d9d256bb033cf10982d45ad5e098224400e394b2d043bf25730dd76c6500bf2471be6d5e3c61885e067da7217e9d1f51fd4d76fbde0785ef06009a1dc0b69b112b62c2d916493483199d4e26d86265317b41bfb69111de6f36ac8c3d6e1b1ff5b33fd6a67d616c14a0dd1edf9bdd65d2c6e632e1cda9e6fd125e048e0f47c4d22a2ccd59c1f9346be4f692bf9f156bd38a58a375424eb7357a842c91fe555ea1c6dda2fb7d9703a96444a8f7b9daf202b02cf3a3cf0c8af31bce8baabf06ad504e53b994b9ed32cca7b404b5dc294c3a5525b4f36aca20065b4977fc0dcd76f34b051536bca150d349285a353ff13721eb18fc410cab84dcd6700be3d05d8da44a4a8757be0a291f4adf663e34cf663d877402636bbfc2f60cec6a6a71f765203f629eaf84e27f844eca31ac2347e02f9e7ab8cc0f3e2e3322f499ab6dddb9c5a79a3a7c493e43190202c9b4f2849e67144fceb04510e21e05ed88ff3b9201917630cfcb99915fbf6f003e6b3c234266add289090a6e8a3ffdf1818f67c506d3563318e909ce6147d3dad8879be58a8b1d9166126f122d99125437486fb401adea238acb14a7eecbf043af003d95a6040a9183a0c3521bb3baf2255b89268add23a6b6d20971eb7943db04fb3f22b5e5f33b59352af7e2d27042b03b9121993851bb14f6d02b6ab0c4898945da28b323f0222d05682531cee0b4dc5653b1d84933bc2e425e14390b4895fcebee436d6ab24c644bbc23bc9376caf86aae3b00d3793acececb74cb3151dc0fc6508f5515c392fd88403cf04e68482a3ac94158e55430c94c783493a362772e5f767205498b34ec8c83a08ec7bb4d4f18b10b89c29a36f063a8ff2d1114ba3fc26ce178b1932f00115f1c27d0c2c3c68c60dfcc516d422e4fbb10154f35ef9f29733fe58874aafbffd35f917aa41db1a602ebbf7414d10176ab26912981102d3050f7ccd9a7b0893d174a6460167a5635d3efa05c5e089c28b7883ff4db45c89193700d7dfdcbc0500e886a341007705db134acb412581aa9da4aded217ccbbb532d087465dd08db1f4868090bd643b8d3ee050fce417bd584d7fa5af8f00b296ea5d44e63749e4e6fa47a91f57554e850147d5450b9f14e440b6f4c417baf96da50afc76cf08a9ef9639a3a60488910f30376de019918ba77d9f691f6ef9b2d55f4d77ff3c35a508e0e8a491ee84aad840eb6e6d704108d702460c4f3a2378171db2e546cb682b123270e574c33b1e3e00a94ec1ff0c2a559e49433a038a9b2c2b0f5350cfd7b0e0f5446c020a9a0ea8023415eeebc0c8561fe3c071650a196edb8ad8e20e377d884d1cba32089fe49339a922f89af9360965867997f5b70fab7d5189a1f36eb3ddb4fd3b00d127cc14aee67ebed9d8a0c65430e4ed14e194a36e302bc923505c0aa5d263ab86e92b2ea9454e12631a856a817d4a0949f77e60999b3c48597094023504ec9b4229c92aaac78b2ba744c0012997168f2419084ba082a25709a1ec6400484f9cb190d295380b8e44d96e3b56a69ba56dfbf11e947003d396a3f6cb62d6486afc9040f5dfd516a743ded1dac7e86ff04a0a4d26359359082bed2005c072910585003bbb9855a966c6587c36426922ee7262b8c220f0c960dd1e76170f5b862dbd00654d4e505e21a105fd17a61e2f93a059e8c039e8910fd9a603d23e3778ccd68e82f819416c8d75d71266cb44648cb964ab261bb5b7a04834336ab3ed254b3154da84e2735c92181dfaa3a24bc99fac9d867ae82c94e1d6bb46959f71f642898c137b5f5e13f42215001205d54a084a7842f636fcb78caa6afaa164ef1fadddf93b4ed872dd39483f740624bdd2a57fec771311503dd65e7666cae0ae0d6b2142e859d3d8ae685abdace5d1e5642b8d21875e27d4a24309b84341acf41739991b9d34258473e99a714c2aa29fb65c6728bd3c1cf16a38b33bdd10651cd409512def3d0350929aadb5c129bdee466737688dc841614f51ff95c83efbb1cda53be73dba74ff704051a9f8d1a318635479bdfeea4afa71a18d5f8f6ee4830d0c51a8eea305eaa1544f316172a211d1c3f5f963f15a89ea0690da5767051e48d078edaa65cf5bdc48c77e8a7f14bc820edc2a8b2798af8316d42e049755859068cac13c9335661f7cfe1a5befa25fc6af082ffe3bf78fe6d308f366fa18f9ad15ffc0a670fa77c10ca07606e2643979246bebf52499d525ef227632fa09441de5fcf9b3c6a9f0ba16159c1ef5568557f13878a12fca829b08baf2f39ff7bbe3a7c115dcb89ffd236adc0a6373097a10111ccc4ad37a64db49537c3a1425f4c46db3eed2ae05320e8849e31a6fe7f966ebd7b0b8aa845ac43585cb55771856df74e433df00577c3d8fba2a6270aebd7882f16d044b004fa7e4014297a9a1b1d7eaaba7d3288d75f735a277d03959d993ab0a2e4964588b5e3ab89a6ae8e60596fffac52746d1171285ce58b05413a4a5502a592630df80c36af772f535e47beeb9a3e012a7a1ff38f28a71cc7b49582c78dbd55aa13ac3d6cd203397789a141456867eb9822934d7bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
