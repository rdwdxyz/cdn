<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f6aa761b0ba3e66a212f3063f9544ff3926b296574f080dfeff2c5121b3565b079083cb94936511657511e58ace9f23b42531091de4d3f165c04201dc112764144415b2fe04f5a07e950f7fd08f93600d16314311a3826f0615e230e04ee178a65645a8ad5b47c93657c317d54e29c399608b355616c7b721353b32988811b1b5695ac6fa8ce03179ece5046a54b766d9593917c87a096bfb1db8dcbdbbfd88eeb0ae0c71d25c7575c75a5a170b4e978c3cede244b54fa62c6fad3b2b7b6ba91a243c3f63eee523dd353887079492d340a5961ec0928dcccf7818e1195eef8b862df6d60c3d4fc5725db27739cf79b1899aa7f5202d79916f43388d503a1cf357bfa437e8a157ad0c500483e95656cc905234c45977ae9eb9e74dce0cd8ef80645129b5628ea908d51c77e1860c633536144b91f0a9834b7d78cf9c6cf53b48b7b4e3e294a73d37c2147d8a1c683bc73fc7dc19ce12b52296231ade54be421ab474e43217fac31aa5d359b5348a08018195cffa3d4a674eb215455112514aa2115dedfa717a286a231214026c4047299301fc2fadae5f5ebbc8300d3de4df4a6e2a3be55b4f46c60ef30e338757437186f6ad8592a19fe9acf05ea53f169a7e5d995718c17cea5e2aa7cf3640d8b3948619ec3cad86971a1c37d55731fb901723bebd9a317fcd1a4c1f662aadf1e3106fab864b7cf7c7091287d2e20954d478cccd444bd9961cc67bbb7bf06828990814fbb44f809cae18fd66598604609710c8e318673f93ca3d188a91bca0c134c6ffd5388613a3acde489889d954603dfde3276e01c8f8b6d37e8135822ef5ffd309d3bce7b2550eebc69777d993412079155eadef1be57ad8a77f778f58a0f8b368b3356ac708d65e9f60f4a4d784df6c0c8b93cb69fd0076988e60742c1eb3603360e10f4deb54f25f151faa706897b58a2847a5174295c69a18422df7121f8b47983cf0f1fde32ee438dffe40f633a7ee7ee566887219fdebe4e95ff93ec9d4aee091c84dfea12b28b933fde196b44b2e852e7566b125761742a41a87b4cd1f4b4448e999f292e3bef76d33349d18f50c52dcfa211dabf7ac4b0f6fdbda8e71d42a083cee075bdd5fcbe7a07199cee9690f67363b4cf2765e173f17a88dd87f47e79801c0556e19fb093de376efd39be7fb9acb4d7e295fb85380c1a9a7aa06c096c2d1ae020c0c5cab31d0fb0a9749f06d50a9fe831ad2a04c43e171d3914f5a9b59b3caf5cf7bc7b8fb4968d35c4512803bd1a2a2019791f3388088b1c60f5b76a125a28992e9543439da33bbcdfa64cb3f13c519fdbf174a7c8b26ad9f89d96ff7a8e819c64a18ad11e5c0bc882ab2d80ba1c2e331af97682e6087f5edb273ef4ac864e8aa01522264ed571b2a4096141781ffcd475ad5319e4d46d370b4c81cf3103e1fb884dca67771f44e9a26b499a21ee768462dfe0d8fc890888f8a2cc56b083ce62dedb4d95beeb100c1fc67a89668ddd1ce980b703ca2debd630ed3891346331f70d2e1bdc0308559cc43cc1dd5b3b20c953f72066c9894ba4ad05e4e4d8fa1cbbee9a0903bd928d50597dc133d829dc21dd80c39ca3e3a006df056d30d02f15250f7e7799eb48d9a3cf4921154fa804a422618cb717aa09fd97dd1802d35fa2bf21e09f1b429821bd872bcddb77d5cce3cd2b235e352f69b2a52b178d38e93e0b3142e55d7b73f3e739d6784fd9f39bf8123976b22b86df36505ae6fd21e314b4fb3b88649f79e2469a82e1e03ba56e025f251e3203f40408d042ff7b2ca429910ac61bc61f460916f9244759903c8174adf684d0300306dc12e0644c49b99bcb815ad3e3f1ca37f88587853ee1df510f5edf771eafab6ee0eeecc4205a245c444523304fc20878ff0498b9675ab40aafc75ebe5f6749b7a35cb0d3e0d4e834250585f268b1c6f2318b34660514b4843a5651e0014ef686617c49b52085cc33ddebc739935125356923aac2dc1358e8c98dcae329581f23e892508003780928d972342590cbe6688bafe43720bca43bc80eabe5beb709d2d2778f80b06da77f254fa2ff4f8e5309c3a8caf05dab72ddd8735416d5db6187aec82ae35a088a899e1b9826967d10f93b594b0481c6807a680e0a288832ef906a504038d1bd825ec6e32765d5e5b627d2ce03129ae1228c7313c26ea9cbab02ae50cec868f3a33cb86e779bd18752cb98957843064128a74d15fe6240951db06ca17d960e86c7d6fd3b27c013571a50b87a9fdd5a9cd19037092dee8266efd86fded66a5ba5c4b9fc32164f4981da6740dd7d6f3bdd01902550f2088488356e3a98e54fd5bcfbc673aa6de19f15538faf66bc22e8cb6c9f9e778a4cc5ea26346c973107e66d1cfc18e4dad394e20bf48c8735653f4ceb64fa635776ae9a3a2ee6394b70d6e79b050d7b79ee2a51ea0160b39d4a1ab8109204167ab133f2bca87a441962586ce25f68ae3b95aa496e51a70539c1a29d17e8595de9e1680866d0d57a0f7028811457d88e2150510f5a1520d26d86c4d9a3783e63df80ba808c3973e64e613c29f724ae0a56df6c742b060d14534a3d84d10abf37a8bce55c9dc9f74c7445c861b75757c9583a800ed1648a8c65ccaaa8a088e26e783b6264b14044363326a3a2bf72addb5808f480018b0723fb77e7461fca94451a8c46c1b4aaefde2740a824a70659e598f8f054f77316761b6adb749da452614a26d1e964d840818f69881b5deb5f34bdd7ca261569bd22165f2c3e793db8c0e0d852e962808a8d8adeab05952e7167146dcbc13dd5f2c1df7bfa24e3f85c409db2219048a979fae326c132c39c82d87be4983c6cadb4fc64b29d75a991a2967c94e7581d95703f433922486958abba99af19106795c5b18d0c08d4de175d4442805dc2b33329338fb7f70162da9747b90ee669fca976dabb9aaa9cd9657b0bef388c064adc7e45a10fb3c7911e6ac2b5c8e05ee7ee31b059146e9e0deb214dc18ab36106b64405556e1711e8da3a6de7f8a4a57ed68b7e92b88b69637cae8359c4ac4ec110c9f16329bfa764407dba20d4a0d6b788d615edf51dc0db6535f67ffde4c365d698ca26db493a394d9370187622d18e656469ceaf8a2ced335f8d45eb0202df7916335851eb4102226a2a6e668a02169cb74adf19e18d57fd6f619ad6518ee8e2840bbefad9b8eb3ae21a80c6d7636761c117008bcb7c193be8cc4d1ff0eb75b572b7320af307d2716b68a16401f34fa73ba1d0c8eaec2fdc169ba1ddc7ae07f15f03ac30289f757c6d46cf26917ea63d91263e608a345781327323c97cd6ccb37c72a89f48cb713eb455a55154632b3ed6a8844effef6320db61e9409d827745a9054b3e4f664a580c7f5c8f52c21ed034553741bbb69d56b0cb7bafdca65892e3e1550fc5c2c2f8398807f8f5fdad0b4726f31a41aca574ffc6a1632d0e86c436ab7cb2ddb2006320bea7479589c23128cd94e9984311641cc43a03539834806a79e01ccf8eaf484e8ea010b85409564b9f7b11cba48691154ece15d637184e34409bf2b31e3663d1db69440a92e6e4ee123b8e57c0b05955e602b68a371b4d243c1c1998eabc5281f04b108e9745f431323ea445cab6e260b28c816fc780da567df277a9463489dce4a276374f9088df33cc787a88572cb29a320d705761e36c6b4c32656dfd337a4d29b901f8aa83ed20275f75673d8c8b5675b0efb676c96b58ffaeaf3e5d225cdb4f9e18c5fce4951a68be5503c77737072be9a4b2d17cf47f85d49fb1511e0dbc79cad69e454a471ba9599d2c2b40276751117f2a024e7bd08bafce20e8c33ed243899d91ccca350a8031b8c5e012aacaa081fbcfc3e52da32e1a58da5c4bea63d76c6048bfc982998abafd7ff78762088a86ea05e94770cccde6d3bd2ffda0096e71174ef7db0a38be0fa4765fc302e63028eb8f9ff3f31ef21ebf4d7c2e7dcc82c75a7b4d11be711dc6307d53f2f11fca3e5910958e43e2d10133a2b936db7221fb97f6a83e2b4bfb681429afec9fdeae80afb1a6ab8fa6b0e557a6bd68f1df25e7c76450dd55505dce715e93bdb121eae151ccf4f84a1351eff41ff449bdccf548968683e25e73c48621bf02f68b9a013be2e4b1f0d8a90395db3ef69da0f41bf12523b736eca700ff906f9e60f99c4f89c7f77c072737da11eb20f0eea137166e17d2d49286b324df323400f741c97a8ac3ab6eacd93d28d1c9ab21653d3801d5979042ef29abcf6d4312c1dd65dee386de5144a5738e0b0841ca707d30d0f9553217df2d119abde604e2e19163d4015c2b5a402f0651a547188facc1847c0671f2a2fd1869cef6c136745e804cb8153e48fe6b4e1b4957343ba118f0929eedb78de5b634623a7be611f2283df07c6b0d8df9696f5fd4fdd6b96017f089471bd86aee97f105cd2adbb1dfbd66dfe80fde6c5c7bcd51db9dca0e370f3dcf1d91f9e7c67f2cf91b345f15860b89667e3c95f7b1ef46e46093877f7a25b7697753a5c96e362cf8af9f5adb86885fe37a51795ef656243dabc46dfd5af9936d667062089d4a857e55f114d9b014daadb5ee4c7773551ab8e3c13489334a9b078e92180af8a050ba8cee69fc576ac351dc2ecb8e0420aefc22ecc9c9ee484efc879a071ea631953eb9808678c2ade3c582e65afbcabb6a1f806afd02fd70a0b3b7977be940de8cc98bf368a7bf5e1eed781f1d11ac19deb2d15290d7a805372cbb63506626d96721bd2985354cd80ca50d3d316497fea40fbf978b99f72a2d701f92fdb06e625073d886362a3f0cbd15bfa8e0e828850c7d6362c3606d3e7c304412cdeb517a680e37c5c5738324225ffbbe1f2ab4f33ab19320cdede55befa01d7144deacbb354e751817c104650778c9b05a41f701709692eb7111da7ac8f78c4e417c15ec4bfbd383629fd107621cfa5dd307a4706d6db0659c7e597bddeb9cf3d1ae951af5b00c54dd44d3ccde2cdfa994402c7ab27fe1e238addc1515df746b495760e8e274ab1440489c949d95df16b60cb13fcd99de5dff3c68be34b3a5da5c73ffa912d52b5893a4bb4c2a7fe896686926d2fac89c1d8752ca97a6b882373c4365f564895fcf2bf0e2511b8fb508985319e87f24fd36ac4b6f6fa707b102dc57689b095e8d31d160d3228722371ecebbe2d93366a01264a95c044b887a6d5fa9da1b25ecd0a116de261b788e8623c46fdbcc214606300ccb3b2e7f564645e5e317a4f1882cdc1bce872bbc41883ee716c118ad2089066a7a9b4ecd96c1003f7faf44d6cf64c6700985e4e521a41e8c75b7642d3b23d4bc8935fadc2c581263d6e060e8d45b4ca2a486959a67593a629c8ce843bcab1048a2b6783121b43059614593b3771434a5447408ee5cf8bce376cd913e013423a9acd6fa06de63dc140dd407afdafd78d5a94b386f8537c768329e1a1661eb8c11ac59b292e79d47f51c32ca6ca597afc3f3f307fe133b05cc8dd46cee3db6399d91e40322e300ad4cb508676c6531981a15e1db0b591e50fa85a6c99b692b45c2c2962719fec7a203ec8a99dfa0d9949bbf1c435c0c077f9e0772f3d777a2c16db896f104486ef4a2ffaee0586f8e7012d01d26c19d3058143bc4ac10ba59701402660975863a56178e7dc9bed0077e71f02dff79aa10f1dbaeb2d111c6bb43c3b1ed1eb6867f132aed88a94ddd3df4a0709a7143dca0e622861ccec29087c84870ea0f1855827dc2192d9af94fe0d70f8e4a0682cf8711f1381df499b237c410053aff2d822968b7f6f16a8d9672a2e960bd1192b73bb107226eae21b7ee9fc44f38b56e839a10c86256089d73e6664ef37e1e08d9e67b95586f611424e528823af539258624b1c605d763fe65c50086b44207195345b60e26cba89579cfd526c35eca12e032ca37c8369ddf5079e301da6d77f1a1373b20ffa55f2747b83d607c774237094e2c0d04b2008c32e895baff16fcb17ff95a96af4e668caee5831fb6041012e1d23ed3dd871ed2724e0cc5deb786bc7fdc4da394a27273fb2d6d1dc030e54e64c1dc6b92211d9576207dbd6eabcff51070973714b2f2b7102097d626c43252ef30f1d3993ebc629024b41925645c98d51d8128587a0612dc0cdd0d013253382476b967cfc4062de31cb0658c973399e0b7d4721e5d85ef231eabc484ca683a547992143a15359ded213485beea0088fef7c4cec28c5d88f761cfd7e6a18664888be0fa5c9ca6b2d839928fed6887950b807796a4c0068238cf3e06a957586146a4ee1b6ab3cf8826af67402603808525b5d5ecab5fee9c099c16e5800eac2b47d97ecabfc2a0cadadbe250ff16ea8dac6f1edb42938ee56fce9b92e650f1f0bf714c921da99757fb46e797b49b411b24e227020728b9e5b5a8c1fc24c8e3069b777730acaa8492c8ef9313a6ecfe033b0ab07bf29c61bd406bcc53c2b344a067b29c99092c0d9e15bb4dc768d9e48d235ee57369aa4c119588b42bb11cdb31f158604e0b77c905a4f5bd59b15eeccc9811f1c7e0e31d2dafe685a2bbb1453dafd0eec76567c21957a7cb75d00a41a239df5284f6e5ce1e3b19a07bde5bea325025ebdd45fe354293dfca5592eaa631c7848471b990867188b1ba80fda182c1afe8b7318a5ca74f2f5f02284a0012fab01878bfeaa75f4107d9f48feb5054e865a1e94c7566a57167f7b66b657a35d87b23bda24e8d66d96bb02311a5b3ad96059ead170148f0119dbae4c73ed1974d6bf7b1bccf382459d779c918b495fbce46a414830accea0fdc4d622fcbb9b1e112fccfe568eaa9b0648a255d8d65b3e508b44b53d8c5b1c42f5bc9d0bab1f023024ab5a8feb9e21cf0ff33b73a140bb656ded1d1b867c118e4694462baf27253cd72cdf6f62aecf82b737c9042ae85dd0e5f200b77d6be959f63c23b9fed7be27fad3159905ba7a985b3d6d5c4689ea44cfb63fc7bb28fd5f1a9b995791cdc8b790b27f36befedcfe5a348a93e0cee620c4f3ffe66b5f347184eb0f6c14cd35b28f7e6aa29a75927ff3e5731125071a2a016cb8e3bfc134572c1d555d948e2d21031a7aa72697299c137a26036be9e31ca140874264e46deebaa6742b303cf74747cda432f50310b6eb14a0b4f737a706399caa58ecb32cc13f360f402fdcfc564f4a8c8774e50f9f6190cce3276e799536aed71fafbf711c1d74c61d1fe88cf554e93e1d1ab24a44800a41e930a2216435fa171b7d3950e6ca516dee0ae56c668dcfaf3ed4d63932a4ef6a70b0444b09ec249b43ffd69bb3e29899a1ac76c58e2c785ebe45e790273dacd2a6d09b5056deb2aa98829333b81a35155009b58f1ad87be960ee59844b51135f2d3c27067208ff23e7c188de5aac0918dfba5f288b13e776a8c7b3c42e9b1a7539d0f27ff68a37de5d6473377db032c9b02fa247ba604d4d6e7ae98c1aac61e862487a5dbf1ac7fab998d31230154ef7cb9bda5145caf149871641e92de5ac50f5e7f7e668a0aa3ebe1f5573cc18da710f677e29e54cc29c1798b911c0db06184cf0d261e4b680f05ddf95c3349d05510ecb86c04876660fdba9d2514469d47f806d1a59af5b473f52b6a70066ade3e6f5a2a89fe3d1a0efd1e4cfc59a19ab5d54f671779528dabcea9725b10429364ec5836eac0ff1b31bd0779993446cf3f962c157687f0a3dc53dc2a73c6c513d353553197fb8bd19c352d1fc39570047f6492128189c4ddafb2e878c342b6c828e22ad8bda2a3f8f4512778c13f979385e9c790aef6bb03cfa870126bab2248b9023caadf3eca67d9ad7716ba820d9ce128128b310956cd1085ed057f04625a621185771fbf39ff5e936902cbb7c7f05dd72a6e301ce290dfeabb18d08c80aeea857c3614f2527f05bf7c6707657307552344f5cac9914ca3af6663e16d353acec0ff7b8c58b09e61e468dc3430b332bfe5b56fdcc9fcff11e38b51f258a82508dcc2ef780c57d5f24c95e1f7ae9412f20aa002d95ab7afdd30165ceef389ca009b47623fcac2063a58cd721805b74bd57ee37b7c3733ccd5e331ac65a328820fe1d189c4d4c90be6e6682bd58bcf02fb5fd98fc8bd978da5c01652ce620491d49a1f5f42ce711bbc05e0c0c287e4208e6ad3779d6528782ba86e08354edefe00ed1232baf4168c59fd683b3aa55e12fe868f21c8fd54cab90ad76090450028335c7c6480dff1db712533f88cdfa41e422ece02e85db687496b84f118fe23ef9058e71ae664d53697f3a08df1098cc0f5383b9805bf85bf40519314225fdd14a187f9ece8f819de2881ce950f384099aa40be33359aceeecb97b2a5ffaa26324935665ff1cfb22178d46ce19e3aca773c62338bc2c3089bf2ae222eec598d8e8f541593eac78c1890fd5a54b7f31490d0548f5e9938efd4e780a0a8ecf7b9e7ce27e6767da73a453425e1d8e6a649d447a8a5e34599801a234e0a33045c8a97153b08430a592163953e976a1e7ab6b6f5141ae5b4ec8cdf1aa7d5681e8da3df8f9e1c8bdf89d05167209c53fcf02252c6715db0236160593ff2cff5fab034d6109426a5ce6283e7e59ceda81950c6393259061b3b8765b2b0871393160a7f07e07754fda44d20961edb69d816a2c50000811e7a2b89e25612a1ec1ce3e1ee3d1eab235ae76a51cc80c291d1c4ea061733f9875210ff065393fa2216bfda7dbf6447c494aa4bbb589bec73cf5152a509dee0ae87b52d1bf97c10821b6f2da3249cacb858a172eed865a572c27df7e62369553374428e6ca1cd08159c05998765aa0501bbfecbea4ac6bd0c495f1905ac0170a8e68aade89e98050d0d428544cd5a42d99bfc0d895c6616b875f1abad9622acd34acd540db8256d4f137a8f6942c38f9a85384b7ac981e5b4055e080f88b308dd632c4e8937810469c90d276d8806a730bff5946e471285fdb350321704c54023aa2577c8a8a8c7fa9cca8fbe1889a72e2bb6a232d202881ca151c7fc212ed1a7729160ef2136c4968b4b9ff54236e9dc2d354ec8975e405d107f0b19ad0fa57de026d5bb4159ac9946230233ddcade4e2cd642c2cc2df7b38d5ff7a9f6dfe572f2dc4ab5b4f13d6b2ec034bc60db0dafbd4ca1c7d1c4812c3229f1b89f489361dd99d3db23a8424396cbe192c88c26408389ba8770dabd821afeee54e8bc99673a35500712dccd70df803f4f4977601be8fd5dbde23bfb7c95b9ebde60a837bd0f8881bd6e5f46d35fcafb0f1f1ed4b7841d8a8767dcb517f3531704f34a39c604f0ffa288180577f95548def4ef2c16696da60e4381f0e1140b5e9cb1796408f8f246a67457ed6ed93789c0a90c83dd09383d3e5704b8c9b6e891570fa9be877dfd860f5c54184ef451fd60df2b2dca98f3c5bccb921660db1d90f3a79447a0b20e1f0c63f5610cf32e07a46be9ccb4ba03d406b2a1ee1152a84ac23a2fba7134f3b33b3cbcc166e398a049ae94f4d869093efbf4653b4332b9422ee472cc93a5052adfe7524effada67890cbf1e632b9f51e05c89904f4a07d47c98167cf4a35bcd7c7b576d8593bd87cb8a582e1ec3caef536a930837ac9a6bcd7db57cf7cc05e175a20dfd28a623f7fdc1e15b4ba25f391772a48c084bba6507a070ab5d844ce0ff973ac6400e42e7e7a41e73f4a8b3a74b80ad295ceafe20ceb4023962709eec51f39093107de6a799b8579b60dc8bc1c99d0549811960f268779a4dfdd617216227d6fb6d9859b12b499b3e3647dad5a8480afc8174a23c4acce2c25101f77f1451f0a2272a5d179cb51d69ead904fb992865e2ac2624764cb852af61413d810d57937e6a83fb647b9e2ecec15e2a22dd9e4c410aad8c9ed272f4b2b716f87ee70d7c9128051f060f18cb47130a496eae4a12f921c6641d741b787148432155eb63dde76d2a951f76467c73c0631d7ba98731e2c27ca5411c67d121e26016379b01a0efcf99be7934dcaae104160c612a854b01cd78a14bdcdeb40722b2175bab1e72cce59bcda36532a84baf3f4a16a161451fe25770a63453be4a4baa6eea8d2304667c05079c1e9057bebcb770c3d2403099c7ea5b207c3eed2db5a1c2fc335afc697d72821df3378e690d1d5dc527affec60bc9a06849bb6dd5a0449b96f6495cae8c4e8e130791f0b6144c3cb9d3b43e34df81645f889d5d1dbfb2429c24c3307e98cf2e62aa12e4203843da4688125ddd4840cb8cd6f0cf0be9f284f86f87ce46ea458d1d3bf0a4a11f8f9caf5b599d57a226ea84ae4ec60c8361bcc8d6bd43256f62e28e130997c841a3bd3a37b6e92bfefb43052853bee9618e0f168a9f2f775b37d23e7285f5484a66446d12254d9da25a2b6b1abe18b690d9f979616a64261bf05f420ef619c0a495896328cb77bb36806bcf4d689a17d8d44658c127df5ce10631f2622f1b8683c93da3c778804c5cc296c4f7924ffc8620f120dcaea512c63c499e89c5ab6b913992fecac516e565177bbf80f1cf12b82fa5faac6d8e3b68770c98ae21bcd3207f4f17587765979a68afab259dab9c1651c46767a3edddcf420f197bb3c64803f8277b89a67c1a03a6b657dde2f83248a1324b01e1a9dc531fdfcba71218537537c8e843362946f2be672392faaf9574db5e3306d48cd3ee4c9e0060c23b0a6a71eb5e6c663a3243e5bf2cc1653b9f910b9c1ffff110ad2ba848c1624c78afc7d6dac2fe63c1c83274659fac005984b4448724b077d844ad00c3e22e44cc2da014fd92f0d0657febb9644139d9cac90bf2852f19b72ccefb50c85fe1c81a88e709333805c8666bcb4f24f026ff1c8a1ffedd3317e931fb578aa84e8ca9e19aece6f216e7f06f7d53262410d8a51e455ce06b3f94f6d00131978c8dd72a60897eea0248f653855a955127df4c6db217c1d8db46345b4ff20b2d915c9ad9134c47f4d8fba7fb3eb1c7ce68ef64178409e13c179a8b57c161592da89edec615014061c8040a2528de76165b30799454e99899995f7743c4a1df25fcb57d647003eb922aa6edb668455307abe92705a32504b81aa0231982cf07b3efe87031a0d961780ea9310459c006b71ab86e6140cb371d4215fd738fd286d3b0caac427b27bf53f43059547ad3ea7b3043651b5b1423cae2cf9b76f5837a746f696a3e63c79fe14d596207f9c7b789352f4a47e8e9fe51a957811a6d547b75df26cbb01ecc7af514b6517c7e38fa0c6366cbd43a7cba37368f3d00a44454cc13b5dd6b8b0775e83b882ebdba55fdb5a4a7a18e963979cafd43952a1ae4a7fac90deba250e206d28004a5aa3ee9f8661680fe411a3154e3021a6c15105675b35d21674b216ffda5c1f1f7736a6a33cc7b240f415fb4785dec2ae28326fd55966c0b8668f5f59a97058ae11fd73762500a5f175f1def4ce8a06ba465e40f37129a875d6a484e276bf2ce80a19b01cb066bbd179f6b8b9cc425ee303479d0f586829c943eb14c9de5c907c1d2fc4e181876c43655d618c5b521208c6d1fe8522e268a90533394cfb09e8252523cfe81a182d570b9f8778f11d750c5e0ecd61ff090c56c812bf9fbce7f6f838b6d8537daad0e5e3aed4f35a8938a4038ac6aebde82d760b612388b7ba61a078b52cdbc6b9a4d897db31cce411633e2ddd5079dbf6c5207cb9f51742494636a3c11251ab4960e25fc5da52036269cd1dfcf1af2e41946ca4ce0f662792d440c8c82bce0041629290489633a7e6a1434552d3a49733288c60c8b17bbc47764fba7d1b2f13f77dca336fc3d0502cd2e3edc49c6359f6bde8a3f3edadc44a8b44b46bd6e2b501e5a382b9fb80cf103dd3752e18a190f6ae53de82f9835eb49d5fc8fa0d0dc7bac6385edce83ec0a3f3670853c1d1664b7bd551e4391019586f2284e3c69057d1106b016c9cd54f6fa359ac469a9e7b339e4e8aeb84762400876c86c6ca40589d6c1ba139c113807e1c538d57465175632aac0104c6a58e3fc0747c3def6d0e1177770d6bffcc3db0544c316dd8a75fb853e52e6c50e5b2233fbd512107cbe0d42bb2ce9b66d4aa0ce4f5b7f1b460af6885aca9e01d78549438dd7163defe0e77a659ad562622efbfd146a46b88e29cbde530d244f80010edbfb18f95c5721b211ef9df98334f0c019363506ce43241c9649c09836a68fa17ddb1543679518d86104922b665b81620f9abf049c44acf2ee7afb71316e72f2f58b530f04c922ff9a6abee207f1fd8431cb83871fad4d90da32501a27ae2b965747a2e47a24d4a5122c0390aa1c4e7ee1cea5527b8cef30a04b5d22a946c37fdc037c3cdc60894cbfa00af21c60fb435529271bee7dc7d1c695192bd76b603279f82ac706907753c11a4403c661f6ab3922e794cf59b4ef8696b1b06bc848a4f446808854b242ed3cd073b703718473c70d0cdc2caaf021e0d2025704345ac4ab08db5cef959cd1c3c9c7e3750e5836c4a7261148daeadc8f22c4b08b107c5ac8d83a5bdb911688a46bb8a86af46ab8f4708ed94ef65ee540bbf2bb62900db35f0e6fc58c7ba4dab45f4588c738a82f7c0651e2b6e1c891b1fe59507055572420c20bf72652bcbcc3f80febbadb507a52ec3b4d57d3857730fec9fa2f16fd6eb88aacc57a52ab56763e0f1d3a1116c4cfc13464f858969c82ab7023d716ccfe8eba2112325c450baeb2535e2123c9e4fbc15cafb83f4267bb0ef548e79afbf7da6afbbb3c93583b1314a92af076669f35dcd8441003f6f04b73cfa60edb0ffc5112327c783beab58e5a3c785c82a3ee5d8766d046989d6ab4d23e65996dec01920fcf104425dbad9dd25f5dc18f01947feaa664ce59c2873125a9a5fabe0313675f92e5b66a08e25db98ba88700c64f41f58f0faac9d52c770ecb893abbf4dfcc4a27c529924e7d27a1acdf575285949db878584744f5734eb7d3c6c17dc002dad80328b8aa41edae2daf9dc934e0888dcf2c798134133bd35d60364e93a7d4f2a85447868865595142ce088937330b6cf5da463bbddb82054812d166476d5e579e6b6107295fd2a8b31cfa90be873d02c692416de75931df4b742b10f2a49a613fa5e006d55fa76d6f7528af9f983fa500c1cf63dc7b3d5c24718536daa60265cf8821c5110b29ec563238ae1af37e3ef3b3431e020b43d91c6cac33030030565ccd287229ddce2a92eb9c4daf0033c3a7b397929359dd267538e5e33508573108431cc5046bd4bd3be6e96633d58135d563be5eb9aed6a140bafdf5c7e7f0bdcb9ca237c84ec20682f178542d886e1643f81f0431fe10f05d6b3a567bb00ba591b48719b0e277cb5a1e875b1330fd5ab3ef4968d1c1b27f4d7770ef5523567b0e61123ccacf1e6529a68abb6214f587db702c7d128e1a1e2d0d8c9870d8100c02fd2e9260e9d71a2c88368195effd5e59f8d06d6d13049ffa677a25fae691a61abd0d87c426996998d7a5b1187565efcce52bcf8c03cdd5202be7ceffdac8edfa70ddf325443d591858b3ff332733317558a99d58a7456f10c4890413164189abc2f8c41305155a08cfce8ce7a634318f8f2b54f9bbbb345534963b873bb4a6080cfcd569a140f248743334bbaaa8c03aff7a12321cbef36e80e368f944bfa1f9811941681a4d7fe308e5f2f398e35a78edd8585a302988ecd5294b8572e8a210ba97c757452bf26b0693e315e78f7d63e563835fcf321f12ead0e57d17b0f84b6697fae32502ce7cb9cff7412a3faad79f55e1c06f4a0465f1f79875dfce3fa91bda21ab4afc0f018126c4e444a0f67deca2b3e21fcaaf788c59da4a3406930e4b76e5cf71abc4032a9c2b99382bc31b8a46eb8edfdb3583a7e1f96a069896cb27b929c216605bc62415f4eae17560a7838ee5b2a3d608b69f99970907df04af944901d6b9579e0ad2b007f648f70cc0b807922592ae76d3ac4dff30a12212d54c7dc1847b6241b2b364441fb50d693a4b8471009651ea92aa07c35e3ecd58ad3c3717574a0c1cee4658091b0a7d6f4395701b22d726d16e6c5156ec47c1b2f339734fbcd75aaa2cdbc85a3fc243f48f2036aed4a1ae048c069bea09bacee101ebf094b93ced786e9e87861c7c9dad9937738d8ce161e888c15fa7a4eb5cb437c45584fc96baeaf48400ceb4a3ea60182cbcd005f50bda0f50e7579b5ad8f1720e937d6b2be806c02c4446de20e108e87f20e6f3b5f8aa1e8856f4601059cf3d9caa4fe69281ca9390b52adcf6f3aa65743cd02cc6e005dcdb1ae425a0dd8bb4775e97a87af5d8370270bae8cac2810f8c00aaa21742e36d507707854b42d9b1831013d73e5d700cba44431f7ef952d078aab4d2bdfe899ee4bfab758f7be00ae8378406d895aca390d6ae2f155f1636c71217fb842cdae1ccb94be4c7ab607b551cf06af5cb016b2d2381c78faf97f6a42df5290feb3eff81bdc16f9df597588890a462349e0742d4e1da0062e8311eb5010b193e3c5090330aa0c2bc209e55b44b127a53dcd184df7e7e9cdafd63118dbe9b1940b02bbaff6d97eef5aea860ae3953969b41e4b46fa913725ba2921e134d87e4a876d42c374a9dd4f4ec50c21ec3b53a4dd79dc42bdc1e7e91552f5c2cb025391c8b55480fc76e9a660a69fd2df5912d6d43d80ba5432f5d60a59540d0f2c02ba1745ea37fb717897cbde5e4954a494720721fd3c9b9d6c70edee8a6dbac749d34038ab4079c2e9994da0c3bd438c83ca476afae3b33283f133077409b79082aa28799071466b3300f8f2226f7a6f3dbfaa3ce725ef8f4dd601a371f1a3d58d4b43e046ee23c3e3fa6f12bec1c0e765dfcba3f5352b46ec7f7c69e5ceaabaea51b66bfde1ad0ca7abcc250129f0a671f7e2eb4716c570fae4b4dba1d060059fa469625b0bf1271ed25b1fd26339a364c1a219c5125f9ad1b53069eb82662c43e328454c6761c79681ce76e19867fcff9bcb20da19f06ee76d1b10781598900a35cd604aeb219f37ac13e88e51d2e5db7b935969791e8922949e7e80ab55f2af1eb8fd951243fd4ce10510ae3ad5e71730338ef3ebde35075ba30d53ec75342ab37fbb6ab665530a234c32e0c1f367973e6068374128e0fc3b1c2b5981c158227fd66a77de229422cccab0140131751995ca8898d7d2498c79e498806dca6dca7a7a53198fb1a1831b2429124116cd0eaded59dcbf9e5a149363432e581dea959e322ffacf2ace6cc26ae52c111e9ee40a05173948d3a283b3cc3b16754a40d599779e40a4477a826325d4dd355285882f5835ddf47abc808cadd71082b5e4f938068fadb168cd8aae8cfc07461e0baf6d4f857f6ffe2bc5c960ab0473ca07bc7513630b0282a52035b2828ccd5d87548d7b4d37cb8c9609680520642a0db77685598b8f53744ffb3e87184be59e40d63163c392ee4604cda6879999bda6536a0b130e4f2e9b2a9e354dafd5597db9ec25a9201189b24ab9264b12c8cc2350a0bb2a5f05a5f3348aca11b5732e7f4ebf1fc24ad53134f42d0fc3e2fabd3e9716abf141960283c12f6f7dc1aa849a775263ecef8892275133d5664850cd9d9f340c46f82e76f4455b9eb4c0b21e50e4288168e423f9dc7c0e31daa7fa73bfaa7dea1016a99178882041bf41163e293c98d6237ff6f1260fe91ec64c44da2e2cd5506fbf53f1b71cf080ce4c95ecca196a55cfdb23fba982a9f0953b2cfeb27831f200b9572b358be386f83956bc9b76ba763bec89dc9b071ec87380adf411f59bd5214ec05ea27407cb07ba33fbc1da9469619e9acd96d08665783ab2534bb5ef2a07a074253ec15f5d70e2aa72ebf74ef602357a3dc37507adb691c29b316f4eb937dd4511f7f4176d35a07d3da277c461440331ee1720d93494a8b397ca18b9835c0189a680d7ef9940b784f6a39410b3c0a8e3e89c045440b9b45bef80ac037f7a223a96633b14a05ffc60a975aa030f57617f3b00524c5f3f7b55417b2cd39d1c0999f066cfe349d54f4c5763ade842cd75381e395c1932417b5e515ca247c3fb4ae3e26a50b0b7bd0d493ed54d4302ec06baf44829deec9e0fe091561bcc383975807aa034fc342c2039e5d6354c0dd8c6b9d2aff53dfa70550b92ec4c64352d3a0edf6beca2fe6794f183d044546b401bfb65adfd173d16f2fac7f299afd028a2745e5e64695903bd1c15f99f5da7ba94c1ecc67e5fbc934ad3aec4da771c882e31561ea83459b2a618715dd45574c12fdcb886440c67e2843ee2b55549720bb986b80e949705cf206937d61ae3dbe3bf4e72fca5690dc04b91d92488c9b8b484b38f34207ca5192cf97c621bdfc2d2e97bdf6a54808d879e0c41e90b4ac7a7bfd746451692c64a815bf15fecb245da95f25feeed96d80e92b53da5014b9a45c6218ab95d5ff167ce594c3837cd2f5fd2896582bce2acea9885f22f52a272366a25b6d4dc26a7c4c5e8ffd23df5726c3b9b322ad3a38dc2807d00f7aea45ae6dc376fba0adf81cd277ac496e02e5c12e7d992e6dc5b460254bdcfa07d3fde26497252622f8396ce8d27f1b487b71f68f957ed1158e845463bcaeebd302dfcbce79d3998afbdf58e336e5d1eee0123976e21fa7b0f5b447d4f30f2c5d47a6a911227cbdc565372ebb02cab26f67971703fd7f1054522c558f1627d3c9aec82841b6f107fa1737f8b4bea8a3f87f99368287831e8215ac25e65164b1ed4ca3ba95ea14567eb2af74020c1837a70a440bc2a4b5fba121d556f78a2fce447d1d3ff2cf8989405ec9bc6233bb2c772faa8ce2deea2871525289dca1cfa1c9c9b3c21e2db01980825c869ccbf107bd1eb2aa34302489eba5e471d4742fd90cb6f396dd903b2b32b3b509484fa80c9d4a2aee86448e410b887f67a2e1882c9ed93473840105b713b5c2eb53ae5d443bbae3740abeef2dfa26a8053a018ed3c55081bd330edbdcf3c1d5379b78c14260aba5ca55290529b910f706eaf099b243f9e3d3a8e3a7ac4c4968aa3d8ea883cc293d140c4bb97d3398af6ea3cd7994d4ff9ed2ef6e17a969dd0b740d098fdbdaa11fe92d79b1c41a9a4774f80e61979e854d7b78ac07a0c372a1a3f853d4ed877745b70f81ee0d8c33c54c4805c71503c9a3b76cf8a2a808adbd7720401a5c181131c2e285678c13873d6587a2b9436157011f5a723fe39b34e1a8af7e971f669a1dfbaf87dee96dd73b377d5246bcb2d3c4b869a7f68f0a74978855df4f8b2945788e40f01e525166d96c9a6eb5de37415798ced4834203fac2b3fbfb8164904384e853a12e4917b8b68502b1f55e6f73e04172d27d64f5e6cd20c19f96cd844adf5502d623d5cc35947da7a105ce1e6613dda080e11a8c6c04bf218256c69baaa6a29958d4539241a4edf35cc89e2d7c6d62ed3e89888817419b8db2c30f22f5674cd3f1d201f5b0e7440fb6a7dde6542d7aca0eb1b230c25a82b1dff6706b1cd715d050a8e0289c2e7b1270ca750529f874882a4a9456be49109995c1f7c75797afea977db9febcc5cacaf3c5513662d99680823902ed065f1760568f8a96a1619b8a7afdf5f43e6872a378bdb7d5aa4174276c069ac3c94d3dbdf94a18fbb0fc406e328c9d943e0fdd18d2cad848952b8b9764ce37a79887dd8dd4cd6ac730151b8024bb025b80f52c096ddb10cdfcb2bf62c67ef03a892830009a694c08b605e29455afe36d864ba57312b483bfd6771904a7a5b0b16660dea059043371ac0a2a15a70461aa3ede94ab2e2d75b3381b4c5ad007f5b29693fc25cc4aa73797e2accd67def28d6d6ce4e5c1e1c1fd515e15feb478cfef566f0287be765faf04381ba51f8e4b98922955244a8137d5aec32674567244cedbe908ac7a644c97e0ae551d86f2ad0405c8e6a14468d2d240317403267c2ca7776aea5bfe4b9455790f0fee333e379303efdbd6efa0b657e0a1b2f2da5186df15f1ce482866bf39e2af0954a5e80e68683e9ae8fb63c02faf75d264f147102d6183c1e80c509bef6b771b0f93d019ba00ce5e74f726b11c00d0ee8bc00114977921e6ec97e7aafaa6404797dcd4f6405396034610693f792515313dd894dca89f2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
