<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1967d53a496c0cd6d8188e9475d88e296de78d449677666aa0dc3efc7f88dd01cf39a1e482b2238aae2e9e954a097a3d9d68fb71f490e47a0cb3a073aeb4d6b5f0627f08801ac6db40e33057eba5ff0fa1c6fe4552cd8c43d66c619cdff3a022c8cd87606ddf30fd86606e1cc9ddc12467dc485b1039839a04e578ac1456366502c5acea1a349a1b0ef1fa9ed26f429f080807273959b993a28a05351859e0864cb43798e70f97edd5a058393db808f1bece073fc011557ac27b15fd3233614e4ca4c2a4e5e8586459635a18ac5ce94e4d9bfa78d5d4b4de87f927188a38b7407ab3cf13bb7db8ebdac22b301a9d4eb1c3e4c7b6c5b87579ff5c0a306893baf5b364927d2786f9e9b366181a54d0c2e6e228bdb383bc1a246a1326a7a8ebc6719feb44b9f680507ea4330cb9bd88d3da4f4db96452b8239c0dd534125633afc82bce5c7b64a42db7b07c0a6bde26c897ae2429a203733cf4d1e890ee1504f002a896332393df3a46c27de5545317d5799df4a224d5bca2a2668ed1c77da27084f5984b311b156e1667d3e843f95f81824d608e1189cc149c1159b55e55e303ebac6372689c693236c41ccf88bc0af306b10c30f1d38bf12bab4d20790451bb9d58840101f343c664d4bc12c855bf4f8bb2a384898b506be5663343335f597fb8de1fb22afa59d10077c218e3b6baa4db72b9034f26cce61c9d3253ba854c6e5c388bc92f427076cc0910d223e8edb300c3a6b2a912d5c0c60b964ebe050b047de12bf1044eede5b028cb6f9a731b8ab1de2eb162c540782ad7cabe1c41afce7b9fc2f221a01dcf0f24bda24f0f94c81a23fba3b5904f966fe5b2f89b65cc842298f682d3a83ce7144f8e40d101f8f0b4540362a471e4febd48342e2f1ff1915e02a016a4ae4ba34460bbe3b9252f4c07feda00439e89ba1ee52731e0e7c57ae9427bae00208779fe70140485dd92b46649bb46ae8ee5a3bdcc255c73b152e7b1544808db8f5eea29a5f8e744bd19772aac97fb6fea83a4a0a74e0e6ffda94b3939fbfca7e57b049f4202a22976898ddbb4cf1388b0f46f2c5007179ed9e163588cd25ac8085aecbf22322af33d4342d009825ebde3649f92a0c7f183ca60bd57755d06fb17829bbe2c26fa53fb7672e24204ed206a3faf8474c020db22a9a364b0a9a91383cfd6ec8d5f4d8f983de2acbe43976fb608b2f822124d3e63118070323af918654a979fc252a8393738ec7daec9fdbe753896b834b855d73572182bd4ba9612be90e53ddfe2cba959979341c8c8c86adaee0fe5ae3ea2dd9e3eeccc0956ca26987bb78a838c24c19a424e95c13e02c89cf6d319100b8f02581347ede772a1045426fbe5c4e38b12877a46cf48289144030e8634da3cfbb63170ee1a9c0acd751aab1c238e0bb6aa8d72ca01c4dd042375976a70ce5ed492b5f6fd09aa41cf35a8a05f701df87820d2cd66f9c09fd3cb4d83025ea09f71a87844056b2bd8a59c282bfd4ebbb3c3b707189d49955a2e1f35e8bf3b46d607065ff5b645073b025c0723415a757bb819ef95971d6a1bb3d0d795be992afe5197efa7a3ffb8095b859b21983260ffac1b9258b8d589ddc0ec4672e54887d6531075e31278f1e6090347cdf83fdb0351b03cc8ecf4d41484c070f8b6004f45378f5cf58de2e9eceb8c2fe92cf5a68973665cd32273287f93b44c2199ef98159091727f08cf5d436491cb33bba18b5c0675916786cb0255d3a868bcd0dee1f109cbec9046b14f1dfbaa081c0a06a2f0ce9b10ecc8a5ebacc4d6c4e848d6bf2cd229bf0ac044df0005e3da6e8bcdcac9a866f7e04d913579be0cfac11cec43e92b6757554a4841bba14d1f02d96e702277d7b0b1c137ec0a1e73098b9e1826f3ea4dca237287acb4fe9a4589d7f59c64094f46d1f7c00769a631226b5a26734c6afa7054b04d53c5148e050129f3d5873a3889d39b4e613971397baf66da43728675669d615fc0995f36a299b3fa189a80563ece5b2c636c8578da436f29f1ec6416ebcd31301d2c9de3ab41be47f0dbb9da88757feca657c046ec6598db087571eb1e0fffe263dd6cbe53942ed5131c7e8e2269dc3848a9b88a3effddb0adb65ddff83067a7e500e803a9008c62586ba11be5745ab891fb25be8ab7f80269fdbb0302925ec0439c1051ee8f8cf75fb769e1b243569ed4d81fb1f2cd591ff37cc906f47043f675b472f6d3cb6ff2e85cef9221c701f0ce8945d1e2b0c9bf044341eecca37a6e3de87e67ce92a1ec44ea4846d84e50e7c515c8dc15c45ae0fd2f4588f572a23b7a9c01b87fa7c6abfaec401a5b11c1cc706321e2a35177ee76d3a0094ec90df9e15edb1003cbc2b8bd3625993b617f5d6efacc12dfb315fb308b96023757bb1a7bb0cda5943f489c2026cf2731f6a2f7c3238329e068a6d28fe0b7e71babfe534f3145efccbbb45a09066dd9167f5e80258a916f4cf95c273cb84a03e6efd04d17307fe1986eb88d07fb8640a77620bb0906a42daf1261f9c8cc844a6305648c6f1ed17556a81a935afad3934d3f79dd03f3ff37097f524097064d41c742be4e7d11f63bb010664c3549f3e9ba84004797e558bb54072c14c495f4e50f573662a19f23e9d2b837d83417c16f92378d300699e5264e43007c5817f52e3a6022eb360339ff2dcda2c811358a264c9fb0c8236082473e739bb36ac5b46c18a68e0d8e972366f1b6fc39c63b1cd22135b816719b64f4c0adababfa7989027fd72e01f41a665619c272ee1cb498b4c7f6fe97fd52a47cdf0dabba8ab11d6ed27b0b0bc33823d0636ed74c29c948e233b8bf16853b2ebce336c0535042541e5aa05cac945de339cbf62739eed013fd4b9feaba22139af9fabe9c03b061aa16af82623d95277db97bbdf48444707c2e3aa75a5b7ad9efc35b39ed84d824d5a1ef598356dd9be8b9b4a93c25d9a9e8148a600b072c3295fe8957c5588fb06bacfa3510e7d3049d61ad6cdb2d362c3ab8559ebb776833bd3a7a1dbf5a47a61f2ecfaa1122b2337d517ae7d1dca7311c51a95b5c57c488120744526432f3a2185baf2bc9edd5a9093720136ee8565555b5cade44a7f0e4a4ad50a826c36d599ab3f38aba2ad85eae7b6c96a85b90a760bd911d74d5168bdaec01a490ec20f066a15b8f56a9a30c8b957cabdcc61210fbebcd2db93f788177e92d92a7a04b1613bb1bd8cd6cfeaaa9ea909fb6b93ef11867219efa63126f5fdade55263b87def66a2ee4f7d46e2337eb5d4b935ba7ec5c6e963fb183497cc68d942d9cafc5ea899b854377103bcea35a28a85568649e3748b42137825cdcb86f50c9912c8512bf65338860fa7a167f83a2663dd3adce1bb761611272e448243f3b086e0938ffe7934494566ee3e970a22ebc2db946e727caacb3037049b816bbf0f2972112bdc5755a54fe399379e88d5c72b6fa17c87502b1a4f967fd02c150e0668dc1a9b62e3d6c805b94a3e7490d2ad3de9a3d80a5867265ee18736800e45c8a3be25f37365bcc0beabb3b34de99d7e26e903edfd4763f4ebbea02302ee2957b19829b7a8d66912bff7c3b5abcdb0d02657d5014cb04af02a8ed0e27d8cf64b1f9209d0a49a55a268436b8c2e3d87aba59097dff30c9dde8cef986a437bdf6c05e833f3907268b5d782db11fa8a2e972175e5b42c3d53d2f04c1fb92da9d3386b2b1d04c4167e7a2978184ff78c34e4ec405cd6b501c8b71151a3b85718be5f9f552dbde2da995345b66bed06047cd1df05ce49177baa6cb4a8470f278761058dc5a8ca796528ff937ef7bd1629eed1821a3e07070eaaaf8f7b709ab17eb5159c9824bd313ccb0043d5eade623175c3dd2b92a54e331213a4966baed1f1fb7bbb6b06f9063e373da675b669d69877b410cbafc565230892ea86bce9487aa259230ea4aebe33d2be2df3be698479cddaaa6ccd110ffa2bb0efb46f15e5242a7a79a891ccf8649a8ddd070651c485ee056220baca1eb6fcc9f698c992c89739e891975a9163f3b041175ddc68459f718797502df5d0c06ae0d13eac3546568d6a41c39d5fbfe3cb1b00adcf4fd3e39a269ecf526169cb59ad12532a30aaa6c0dc8d37f12f8cbe0bfa5dc9702cbf8b2a28f51e7174fe25db82f70f775cc341cabb4f6f6b9c79054957f6ab5cc6f309e3f6d687b332a7b231c5c3c8b8955e83e0e245d2edfcb0b90cb12c6d893c66365b3909b23aa0153d7d303c299f90eb5c103c993b32bea3e11a34450fd2e1b233680d232b6846c32eb600ae3c27fdea9852a57e9b885c775349660aabf05b92179797688059ab5dd817c1d4a8b169ba5942162aa99ff79f230cbb05d53ccb2c5f59b0d36f6440b3460c4a97ecfdfcbcae1842ec136267320a24ef3826e14731fa5a7bd6dd7a1a46b9b7151f512d2743e94b1d0623d7e4580212b7da5afe31eb31da35cf6ba3393f7e04b360cfc154a683ad27bd8b30f9145cbb9d6bd83ab6910fabd17500d87c4cfedfd5271d2414dd8cc85db8cb0f0f608e23b16bff58bae04df0c4ae9b5d0acbeb2836ace312c93bfa3334179f6a28ae5c0a63130b5305fb79469eaf97f6044f608fe9128f867576ac73822e7bbccec0d3fe2cd11c96039b80cd6502327ce49458f456617d6e41b531c3acde80ca6b03356a9a5ba6759dfcbc399584fc1f1333c8cc5253c6e73e506dba1cc07884dc7767315d4752db186c3e0ae4f478fcdc19e0959774b51298740d2afa52270eeab8fda6993c5676d7a67f93081447f598c8eff5ce5bf27d31ae752c58345c4c0998d7c175c099e034960915ff97728bf7b0ff2256f9719ac01fdb70dfff4e4f4fbe307d22c10f3dabfd8148e92b5bc1c3d53ed3cf5672870516c6191d79f0c50fd2b39fc8b4e25dafda6032f87bef4c7f099912c05243904935be7975dd47c34c552ebd45d4255ad41ddefa60a5955c12306fe46d548c96f198c488b72d6ebbe8a76e1c3d77da5668edfaa6ca710424f1898b138f36929ea73adf7c87a6f2f45d7a9812a0530f63487584529860f75b2c5638ed2afc598d66c471fb92b43a7c86178c2e414c62a3f5662390fd00da022198fad13c06b0c06bea7a01e0d698559ee1513b05166dc7561164a439494b3a315b3c2167de7dc84086788e0d72dbdcda0ece5b98019802d138d40fcff1b769a1ba104fdfca17b0db9579e736bc96d30c5f79e400f8d8e042750ef3d49fb2cfe3451b86029d93fee7a4857100ba2acc53fe1b1020baccb52de10d374a329d240830e87beb65fbd1ded7e2b48c4903dd596f5e57d7a598c88d3157c3089ffe97639d39fd28890da16adfddc73c52dc3dbe14c325ad0d55f7a5663028cc1833821a995a58358e8a9e72de1cf717fc328d23f4cd40466b9082a5ff2e2349597ecc8cc61dbac3c8e411e6fe299867f760d22e08605aa20b6723ebc66705dee2fa7f4ba7cb6915563829626000c8e1e446abbbb7d7f9ab3cadea3a394298cf88bfdbeeb95bebf2b4b794237052fd996c08f3ab12b49310fbce50201ccfe8691c6fa9a9774a00ede9274549b9d45a46bd696a7b5b1b1fe270a3bf3d017f7c3caba4573f5ccb0dce2e4ac30e08ec4141b82c997dec5cfec0db49d8576cf386cc623dd53374378b117a500698d74e982f3abf8d141a4cabc1580296b4fc6525d8dec6acddb57addc4af12c99696b02f98b11f6347b73b9e51ec03a9590b8c8957a6ad64e4224bf25a3cdb344112368cc053d14666a783dce738c7e069dab5df701ffe567dadab4efe083b3be607521191793c521a5312b3e66842d0ff42958583f0785648988faaa12c679049b2bbcd0d54cc0762fb619dd7c89f3e584f0e02797fecbf4cdd0fa3f40493f9d4c8b4b71c9906b0dfcd3b67c79762d49e33e75774b764679a89a8fcd01e1663541675fc58698c72c2593746a8d77b31a4e92624a1ecb8fecf6181b717b0aceab6b499be9b2747d49588a1f120228d413d4da3e37f116754911e082d9171803632add78c32144336b64ef01c970b6f71f84f82a792059590983337eab59dbed59f5cfdf55602254186047461dfeab6bae026907959b37715e7b5530a9e60120533453b9e390388225e345140a64d60615c5aa504d7d2bf8241e1fa508cc714d01a2160f1143533f06b689a18a9460c1b4d999dfbd080e33f7394d4c23b92ab922a68d22325644cacf1943ba04291360c6de8a091a7e5c6cdbb832cd5939fd479f460877cf2e66fb59726c0b0cea1adae66b1166598dd1fc471fb258e00dad053cd469a0ea99c7d3a59e09638a1091a503a6269e4b1674503686160c7baf4075cf3317aca1d859ed64c5e51cb5c812ae62dd13cb810fdf06ecdab949be9779682a44324463a2cf71763fb4463354a225905cf8c4b30be3564790b38f6a3896d15dda87175cd234651b7181bb6b65810dfe5a66ca8230ad8ee494b1a1fc009d91fd0e9d0b128808dd9b63a7bd5f538a71073f21fc848af7a34e5c4975b6ae8aacea676187cf0e780a3599ef3a2093ecb70cea9757e99c5cff95bc4cbf24bfcd19450bc6a9d479f7ae5f97493750fdfc694ec1fa766a411d630020e13889c10ecef9c161a5f375a58b0cacf3dca923558c3340060301d784c99d69e490f29a1201ccb5775fc696546e70d4f88fab0a51268123e3aaae763ccba3da8573ae48bfe1575ab02adf18733fdf94e36d56165743af6c6275e408f380414276d5cef4ae387e0c2e881cd42efae90351dc99b9742a32c2dfd37917bb3aeddb3396ec024d5c3fe6dbe6cfc1e449715ea580da99e731131b030a84f7d8004dda95977ba2a709d0717230fe6af4af0b5b5ccd2fc24625b4aa054f68dd6ac4832bd44168a5f77ba1a7104f1cfb442ea298d7f152aebb43dc41ce10c06b362d4f66510f3242784834da223b7a94378b217a8856a60ea0bebcadfcbccbaaccd12a67ef5f28cdb2cf8194eb566aa98322960c36c3ec6a79c099d512e561efc22e00a7d2a0ed8b520136659a135182edf04c3551b00d31375ee905bfd94e724348b013635bede12c36e48602376ba10d137ddc9bd1d4accd180941975d4d9366c3ad84de156780ffea1b2a22c0948b4530f06d483d8a6d49af5be284847179a714285c8548a9129027fcbbaf7b551adb89965be1511bfc01b583f28cd669e9aa7d7396d2ee7bf02c08ea9f488793a4bbc532dac8eb07b402937c28d95f19aff1d8546fc6b119b078cd9638b9bd1c7c308b1074fc7dc25eab8e44b2875fa4928f4ad095595bf96c2ef55d468a1299e45482f67fd33d9fff5d8af918542c954addcf1ec6d01bca2c8e67119cf6deb440cf722627f6aff448e4565982686ddf6934733ce71bf18c590bbc1c4445051a8ffcfe2cd26d90532c350bbf7ef8643d8af33728c81244d0953a304750747c02b1a652f1e713d00a32f1cd479332c67c7700cc596658f87a66990ed9716c2414b7463ff81ab33ba9aab09ee636fe81ab3e1da4b3d671d1fc08928687cee42822c8ff1062f5ea816b34f42bcf83f08162b70385ec0e5863f49228f1f549a2f4cbda088a8429df4c6553419da70bc08cf5b8d9dec3df5494c878c6a00ef543423d2d28c193baaeacf1b5057a07ad7354c81b04cbea01af45648bcaf0d12d7949f58ba3cb02aef6f91a742a83551feb4a5559b9ecff117615a11654b38a2604647b585cf6b07a136e9b69fe6ab247977c349cfbe4318e2588a789f0629adb10ff94456026157709355324661d259d4ed259b18ecbd1d823cd4c038f92319cfc7b9b4e92dd22580f88622b43f0116207bf559510eb5222d21d89e4b69632430cd08e498514f3e50cb3b01b2b54e3a6c46df20ef57319bbcb921458bb7baefd6a78caca9a897318317a3390ef7b6b04f65cb6c66c8ac11ea96a724eb2888c26d7b6cded2530c75f126336cbd5890b8753892d9c65de58da396a2c3af3c302996fe40144650c0a7b3930793b3ea7c34153376e3a0c44918cb14fe034463d7fd376948887987b91ac3b4f8c695ecef65fa3c5581bf9154db1791d8126083f19cc831d4bf19342e1100f7e7939f73c0f0d413a30f98450292d9b0f8d8b8cd7aefa0054f704a01513429cf9b1bbf115bedc79eced0ea9c043192c7b2d4a978b0dbca5601ac354c6f192c1d3521fc04a4e3c1578047ce5ea7745a90a4cbc38d4c8c0cb4cc4f6e36d99756a7f350fafb2bd522db0c3cf57044765b9c6398bff3040426cf2650c68aa4e8ceb4d9b65ad87b901d10e7e491cc777be7fb21379dfb51f586594c9fc73d13327e958c176551667ad27c5a0d3e8a580ba3d324a56dd17bfaa98ceb0ec7a54acd4a69a766f74ca42a1116771eb33bdec7222b461e2560f32c02d06da486f7ba5342166a8132a69e9fd27585eae8cac3710bb5b2e65b074bb695bc8914476fb2ed13ba821f95569e2d23d0eda69e216cc4a49f73ffd2b7e1b742aa8643a1722a107f4527c0bf02363e63e73c5dc2d7341d8632e849caa869d1615a36a9d83e9e6201d8b8e9e1e7678a5a228f9415c3e859e3fb1d915870b071edff98d9d37535737e9245805c4da62e5c473add2c1ecbe4ece5de4c2a37030ca2742986749a2b9f97367114f5ef9a9a7662bff87a7db2b24668ab9b9a1350fc9a7c7312164a2ee1b942446e73f2e67739400d74a57cb94166d9619605594654c602d05a1278fd23437826de59d59404460da4ad231c3a1afa8d433a2b6301d5ca35ffe675636fd4206f742d552db004cdceb8bf6350c909b6fcf47050199bf8ba210a9dae95984ba8a77de5b89419fc59b48455ce8e0dfe7770a5aa2e6de814666598e6f124f0d81af6917d5a2642b8459b2377366ee3ee07fa00b87e423e24b033cfd13f4a8467860766ea1724ddae763e15bacff25f3a0b2a27fde568fcbde073837d11db8584953b3d485dab6fbf09d89be3032dea7ca70349f507e51a669f2434e72ef7b1d8779d7c9776323f5d7538f05d59025f4218b098f0b4ee6853b9ce91954e08721bb0c3c88e03feed333815582637d17127f461ecc0203231f0900ed1bdb1e6aed69a024359d7c00987688de93d5c08bcc9b9a1fb6c2b5d26c22d80180d0c15218814aceed9fe92401f893adb0e40b517dee6e8b9e9839ab539c73fee5bbdb768e11d5f7619e160880c711f87fdaa60d6012d3fb1d4da753834658ea7080a37be6afcea83398bbb0dcefada00db723940a79dbf69735968a0694a193a0d5fd0f984d95f56820741ca825f4a38cb839d32e9357d267c1572457ab80efc838e38e6dcaabe403aca4d1e9417ea8951de0b875d433c1137a4813e2a028f320e1ecff1480ed39908745ddaf53ac02564d240f6e028680766210cba38c5c438e1d5ca47865e5a3790857fd07548d99ba947fa96eaed00f62c1e5294f3e2cf8982de05e877814cffcb94f0b10cd51261857f1b67f12dac756005a273bc86bc6c24bdc9187a2e4d024c862acf3f91179af3847161898d5c1f96a0dc956e480a5a8909ec407cd1c7b6ef95c8832b4c8a5024aa18382ee5b94427d4695c871c3a60bf9a75a02236dabdc512284c13b755e6b8a30d71b74b98ab94dfa62e4ed99e645e6ad61e42fd9cb491904e8a87dd647b534e779a808e143d50bdc5b7e26a309780a3b0233bf7b49e637c361ca5d6c10dad2e964e5eed28dce83f081f8b7176a6dc60a4f4c2d201d8880d2176c67cb14263f31754dd55af3a643f0439d75555db669d5c7016a352b5c514158317a33ebbac0f2a99399c7be0ca16818c9b0c610f970a0c7695cb1302de6c4fe7b5bcec0f0409bf8c66900eb8a7baf2103860062c983dfc35040639c5199b7e72dd0306abd57d73e99f42bf288901fe7998899386cb966a2ea943b90552d7a20d23c5e1b5e9737b81dc56e1e2801717a3a45903e2eff509c2fa8735aea7af9d3043d236effed76fa6b7626f2f02fb4609100bdfdd6d9eff934e0a31fab123517b978787f3f99716759ce616f67094d7465a5e98cc6200f9c4db54a08d1eaa9e1a1c819b74c9491eda5fe0ea2faf9fa4106450e88a88745d9c82abbd27931b9964bc219cf1cd0f6de15f40c871c9a8b9406df876ee9ea92e3b5a5ef58cd694d7f92681e232e225b3450a11869ec3ba18429a20676d4a410aa09a6955e286400fb065bce65e1fea98df94df02bb20767305ea2b7df7742ce9a69d84fe209ec15649e5d97c2f3ac552a5576e662985fb9ee675400ab7358df8474f38e5c85459d80c31cbcf983302b3b3d1746a99953574187ff8c982ac534e91d64340fa1ecefa5b97f4958ac56567f77cd754a97655f7538776e33555257e6ffb67925a371dbf38508a40019fc762b18640c8ba18b462f5ede67a4a4c27a278e252597d0c5a9181e511f32cf6d1bb3ec28ad5ab4b8d7777453202b205f9afac4934a2ad1e08c1933c93a03baa5385458469b37a0bf2310560740d7039e80f147323b92a8032c4ed1ec3067f51222ab1392dad17ab84ec55bb14d92bf1864f8c81c5698a4e8dd94a3afd1bc9c000b16af6a91a00190c1061eef350176aea2f6fae76242120625a47e1f5e9542c811df08549c71e3f84e49b8208ae5037051e0a425a17d60360fce56a271ec71b277dac15601c314ac64a661da0f2274f9f8562b500134cd594c7ef2817ca505f941894186d70fe20fb4401c80dc590cca91f8454b9703b8700233379182907940b35950953a4a3a66fc0011e7d33961a85b10043bc3910cf8f88b5fc96cb779d4d261a293918338ed0a47694cd86e02bcc6f4d18f95ae0d7a762b1cb8af8d5873f0a41bc819202450d48bc9412b09eb405181acb5499255b3117b6caa46e9173a4fff417e8200b01de487cef95c40d8b28454273c68bfd6d813fae38caa00bad9c2329fd8e36c330e1679ed77ed28c110d921655cd94e97f178e12a6e239dce852f57a7ebfff003693a97e2350856d9e74fc5e1b7b930847cda8c15d967358f0181a89c3f2f8f9e7775e0c126c191ad773f8b7ddfff258e212603b57e7fbd18de0223fa4b3cac51a05af1c0d7f56375f5b8565b061ef9ff9f550e750a7e294823eb17481fdb3b5b7cd345944be01a39653765d4ab61f2f2c66b25b9837a7205ca31919184a38a660433b818673a56e9cd93204bc994a77063d22513a7f4b4a16f74df94dd9a2c1d34bad265b4ace0a757255246c130a94cc666e4d8069ec5dc49bdb19d27da201831ca3081368f3a4be6945598ed590f2e0f06fbd693f09fab3aaeacd61207298a81183b93ae9a40735e0c60dc68e7261ca9a88d408df615c5db7e2930215c0f1cd117bf043a35f272c0f3130562dc8a9a057adf094d4527c6dfe55e9542020eb041c94a810fb4a3fd974e878320a392c54043e0f8f9983ce1d356f1030d144e59c9e470566dd0f5b2d35559d049dfa3b97931a5023e240590187c479e8b63395b775571a207efb41955f993566c23f7236283b1230e4e57647cc2e9c0d3e12acb8060bad85ed4ced4a8e983edcac6ce7d10e6d95971bdef34672b66a75832770b9a584eb14a09b379b57070cebfc2d0964360542d16f7ea39d2f6b9de90db7df7b5a22da9239367d7d9b5f4cc8ecd21cb26ce9a19bd17964a10fcb21287dd85a0962d88e99a334e12bc5e2cbbc5cf9b8b4fdc0a8946c316d4632e08396eb6712b8a02b11d08932feb3c1984f69f4009be6f6eca3920995ff63535e5aee33014dced9267b45e9f62c123936e878f2633020040c64c9f8df02bc8b8b8a6cb185c200cdf1c5051333b3c56d78f762cf53050b8c8a0e4a9d22c73a31124a9a589df0a367185894cf9b25a8b951d5e1cbd48aca47d3dde114a4f320c4653dd05dc4c7a03189208765ea0c748f31d0b2cb58197c1022356275eccc5a18dd3667818b3024086af51199658d7abeff406b81c202e5f381a5bb8fdf0ea54b3e776ca4ab0c6c9e76d8ae1e7d7ea09a255d6f2beb37a225a6d9a10be2db5b8af32103e55a630af7cd5e54ddd8edc937fa02b62160ffa20f0449362f3eca2d25541e08e603f56a124220bec8a4c2da65a2f34535324b63108915df5cdb62aaf4419ecdfd8ff794078a1a65a607b16931c250c6ace4216d5758710b21cb57521d15b83b8c04dc58ad3867e525ccd987040706de0878ff9b3d474dbd7d7e14bb63068cb736a759dba177da889f1252bcbfc2e7418836faaa4cecadc109a5bdfbb1ee6d9103238235710164f14d73f4a0b1a3075dd2f5a733b3ebb4cd5055e6dc39a07e739436240855703a1da470979cf8ae209934af046f90be56e201885b8f2e346b77186cf05bf4d39f29981d7f93914e1d43a78c54e0e400d1fab34dadf85e44755150553266b2ff1fa2c6f35c4b75c088dad9c6253b207d2257e12547e24cf2de9dd91e4967076426063c3bf181fe933726c2adab8a612c7c65b4c96c79208c87b279f8440d205c1fed5ad4653e51961af0d70656479563586cc4096bec77a22b5334f079a2695a7525090746a3fd01b0d0127d0cd7bc18fe80fb19093eea0844126244615ffac5c5849a1b7be8936ebdb404ce2422241fe981046be8ebace1fd842757dbff6a505599cf29f71a36c0dc6d136470fca99e1fff3e703e0b4a7c114071f930aa7ce5cbf39702cc92156502b41cec120e4bf0cec6cf71aa482daba77fa5aa12b5dd4659583ffe1c733422433c920d76dea793e1f3e4d7e1d5a2ba1bb4af4cab3f764c443de5257d35889a1d66b2d641c318b9c15fcb71756e1965354dfc1ca362640553eb0d4c3b9757ec1ce5eb8449a14807007c5c0855dd75a342dd93c71860775b35bf785e97a778e0eced544cea052486d8f45017bf293a035e1ee53ec9a03c81472f57a5bea54b028ece645090a261eb51d9fd28805e434f6d3210d7f77dab3e248d70c8fadcfc0158f4776a728cfc61139856e45efec6257c798e1812247156075b129894cbac1e55283d6fa96d47c9138795bf574d490041c6b16a362891465d6cbc8e3f2af1b7c6a56996e46d19ce631fe115a4025d19a69b69503d72ef5e2d2b981a195d0613982cd466e9ca82231b73599bcf50ad7855fe5b8d5b41188194306d000208f48421149f31c9ec0161df9a44341db25faf1f8abe00af15029625bbe7b0963ec6d8ae1ee44604fc2493bb41b11c737bffc8c2f7cb151b9f292819611af21fe39c7b85c327ca8bd22c27ee7631715c0ee25d11887cd0609716621995d3b3e7dc42838d54d0d97b673b35fa770b93f3cd252fdf3d44c6bfb5a00e94961b0872f79ac2d050a3d196a462665ca00ba3dd58b6a00d653a26c5401d3bd3561cb402b673dba2afb7adf168bd09a7f900cbd059b76e4fce48471b7fc2c786ee2dbad17aca9ec0fc82187834bcb357f7317f312f6e1ad3d143882954360f623250c50cc46c4f9b19b5a7469b2477eb74169a33e8d5b361d4223a798a7040d548122d74159f388cab1dece4ee05a9e31e7e38356ba72009bd8ce599271b5702bb3fe66f238070821a4d7211484308f58d24ae3c1fa1d05359c6de204deeba9078110847021807e261eb76f76c1178ec87b967b3d0a037806b5b7adccc784198ced2ece5d7238d5d3cf4728a059c5409dbfcdfc3bb115dfd349c09c6b5753636eaca48af2e5969b61aeddf7760944004bd625a61e8a3eabc1abdcff930b4fa8f6e35e6232b4d79ce0f072d727a65134dbae231b432262d1f806922b2d260f152388189fb3f879e50f8809681ed5982026536de41d0d00f67a2e25085e2c1948aec435d15be1a589bc1bc446ce03f6eb8f4b499ea8599fd7967d1176b5cc676a74085dd9943207182a056c0eee08775668bd6513fd1a5f5eec14dfe6397a6479b400168e3aadbde99fe0fb443fa569ab4160c8cdb88574997f983157a0932b39d91128cbad9ed62ae2580d084c8f512e4d6e4a7c91789620c824a7886ef6f3f1237181b4365e489e1c37e8c3d5d070edd662c2cdd76d139f35a9f3ab3908711d4ec008f0c0d2d1b9d2fe6b26d34f2c94ccc8da9b421f4f54ec69c21bace57c90ac9dc68b8e7251f7ad7a103393f92e82daac2e2f76a4879c178fe93dd3f2eea74446352a1d2b8c39520b2058d7f19af82b2a97814b185e4df8fef193f2015063a759168349fa71a9bb49331f3c4a3c71ecf94c2a9f3023bb09e768a5d2925a7c9ba49664eba0fe5848b5f6782df60661d1e28677a1f5b128f83650efe6339ab1641fcb9bb19cde6ae2b1cced869c14033b6551260ccfde04bd501b6be7af172fee36f7e7ef39e4e08822762ebdb8a5d9f2eb184732fa9cde3583ac2044a871d36477e63bb58751a591dda0f75acb1ab303a696bd8cbf8df059801dca9dbc5ff398b3b760a01c460b6cc806bb6ce87271e7bc156bea82f4fe7835afa32b4ab84d3b5965bfc8f7f4e86e66034347f53ceaffa924c27e10dbf2433cdd50cab0b1c2d32aa1c8bbed7f48abe442918d99173f07b659eeffd13f1abd44142cd7f9fdf3afeb2c1791ffae6ae92463320f6e86e754ccccd78d086d8726f5f589b35ff940bc729a298b5225ee07c44e9580cfb606f6a25ce689161b6b2eb43e521f6dca2b2a1b1806a848fffb8f7666c3713de6cd1fc42b4025ef3961e0f36ec24149314a3eb2b0f4c8a9d561d157f05d36b326d2439dc0d93a62904c07669690300680c0f7ad4b4ee4fedff9568d46dc9761265f9542ef78e86da49b144ca9913b6f2c253e458e6abd854edf68c09e07ba849c49ad98de422d3255705a1b9126f32caf56d187df672eff09ecf1bd5b7b7b2ef7177139c7368e81e4f071910bcf163bd04a0deee6270103be38411102ca023637047e87001adfe116b1059618d4120601d104edf576385246c5828b652a16dab52fe3ed1cb1f6c6c1f31ec05dc244d2f395b920339e1d225a0293dfff8066b4333a2c11a103183d2a008684c75fa50763ea87ca4e003eaf21c51ad121c4da1a401b49c0d4ad9297d08fd89ddc513353e19670ca7b0f71b89c5f5bb52eb826b5fb954ca289fb3e0cddba53307c55491056bb39f1f55528e85805d46e24a653d76f115e0398c614861bb05f941cb1e51a653c29aad0b549c761599bbdaf4d16dc2d2ad0274f607e167cd0fec65df1a6caba04e722c2ac2190120972cc8838e7678037","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
