<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c4b5a656ab82d77a63b5bf4604a9ed2358d07966a4dd0598ce74018d66678cb4afdf7b713e8c5b4e645714c2351d86e28400cdeed22cb901a0d2711a2e8945b2caf36ebc924c245842e33a696072326c6066fc4fdc0fb0c19d9f7e13582671e2bad74b09c156a146a1d0eded29d238ac9baa9d29a95ddbdd6e88325852ab2c03afcfc272fc5bfa9f5873f6a920c734712a7baa592ae023d42eeb201c97fef7350cff0b2f872212d76b48d005bf773176e1405fc2161190e4af98c5c7cbcbe62c1147e4d861c96c53ec02f8b0be2837c0af894294f60ea62566f8347e340f4b1f4a8de29ddc0aa07daae77b1afcbdd092ba779886bbe4b9b75f53ea18133ab0dfff151cb73dd7e5532b66bbeb0bedeb0b4365b9e062b305cc9f8918b6d62af4cec8410512abf768ce037061b00d64eb66ded18ce7d1aa7f7ff00b5169847dea00e744ece74597590826169a08f9db7e6c87fb3d406ce3dfc1a72fffbcdda2d4ff230b9975e733162304a8d794b82edd5a5a9a914fa2113637fad7e6d9a693ee480ac0bcf0d4a1094667704e352f6b8e12040da604d4f81a363ad907d5d62da04d92b76c8ee448de5de7ecf651c34b08202c90b03892cf02db7d8d89fe6d2f3a9a129afb59562ee2e9a3b3d9e90d26007f7acb3a05e43d7deb5b368282fa91fcfc6a6b9192f69bd9641c6cb926bc42625fa95331a271601171c8b6d2ad953067c82d026329135898a7177ba1982f2716db2bc6615beed9b323e02cbdc0c7b65e5e877228200759354fea0a531ae8d6bad147423b243ed547babeab0c07d10d74ae117906c91482ffb3b1a0379cb08be71005684c47c393f3ee41cd3d53d26f3c40a047a897ddb02f98f04f941bfd4122220b6f80bec841ae42d6852d34daca3095239f1cea04f8a32a701b0fb5c25423142f1d2b9a8515042370cfc6af84d1e8892e86d116918462640d03424072be7fcdfe64c2f3de67f62b864ace60ce3fb805c1a9a3f81764a9de9a9ed7236d910946a99d85aefb605ab94b1c99fdc813d7566982bcc7eb17660a6ee31e022475423917dc133ef2f9d3447d87ad8cba9585642970b510bac1f048e094be53f1141d0b8aea1c31a25d7bfadc5982b9d7b5d5380a26b15077e95cabcd55ebcd041eb8e235ee0433b9f1648b59a8ab87e9acd8a5e28269bca5ddbeb2f3c49f9df5605261816f5de5c1dc6d89a6aff71375531c3841a8ade39ceead2c2eeb895414a0297928cdace05f6b21994e0a904363f9c3f2295d6156294e1c535a521dbde1cfe0d3293af17e04f219b03c32fac7b00ee1bc57e4e3a80b98bde3df912b688f3d469b8cb808eb6fda5581d8f763fd91ad245479193442039ef7b7867aa8d95468b1af7d48585e438d949d87083fb21277ab0f7b49274dc95cb95a3b14b9be2131ab52da6c0c93ef5a05746f66a186b966f226e810f2f07ff7d04dadc9d8b27628be6d9b031257a43a6b7d9c51dbe7ed94145d9dc04324eb731f262e1becce6fa8e50f50c25cfe4e562eb9b2946765a8bb48e29b3dd345bea20becffebe5a30c5984d2334b60531a6e2725a72383ae69e01edaa02e109a6bcf67918f9b3af44920cf6486116daf5d58fb6a63d947b2e6781ac1910f846a07373facb7e147612b14dac10259a60e4ac19b254800894558951e2c7d2b51c5e82d5d71f5760ac411e36374707161c4e96e81c38d076edb95b994bbaff87be060c2f823ec60257320577056c7a34e247897f62d9ca08312e79c3054c64b089c68204d18419e770c7d7c9d00e9d586341518f83121788da5534a789446f71ffc24423a8d8b2a9b23dc8f3a67315eaf05680619e2d16441e71db112c82316b15d9d243ab1cc2942773c74171e7bd40bff3dbeb216e2971794a9cac0f40b91d975925d7f9c6f9f1d7cca7d27391ae817e6b5976e6838c425d8c3818542a4815fabeac8804cf82708ba281b2a92ea4e26b19183661ecd0a7906a473c243be14e2b2b14bac210c0e693b6aea1fc6b54ea32e611f32eb1d09dfd57fe77eb8557989015d6b71d053749672a87543b0b245a7b45c0dd5be4aa10ae8819b7fc88fc42d4e916eedaffa3f45fe7d61f9e77cf4b19c1904009ed6795b97aa90450683c7d7c950bfbc042f608118876ec07dd7ad84af930b22282b562c3ebcce4fdbae8423952074333dddbb8098f7514cf11beec7582046cf1487110f47f21d6728128334e13c560e4243879046aa835c0d89a1d529f4da1551cba8d96d1d88229b16cd54ac19beab6062293f33dbe721645ed998b49f430686c86b52b6739e3eb2869cedcfbc3bd8ca745b2261de2909b7ceab89db95aa078c8c5aba58f1c06ead0f15e49e39ad2c1b95f76a63e9c02a4960caab7b52a14068f3c59433f20ca881d0f75efecc8a963f07e4efc18d61d1fb9702229f1bcf5f402899a621a1d311c5ac8acbed72de22ec6a399a3cb8e4e18eeaf3e5935cec4a5ab990a0aee175a258518dfc27be3d6aebeb6e8fb85b4b0f15b61cb206c2e3ce64e3176e84c78dfd7dfd25e4ced9f03f17cde5a8e3c0230d65168e041383ce315ab3e7cb022f9d00e96a8623269e1e8fdf849907b0fc52c7395d1829e26fefaac83dd2da2a28fcddfc788577f58860461d9327f0cf1e2e4fc23a367a070311eea8078831761f9f80d381fadd311b1ea8d8c1e5f09e5e582d635e16ccde1dae4f22e2977cb377804a9966f4697aafdb74aa95f8b928b9650ba549e7ac34ca0a34f40ba522fd9fd0a620e96d7efb8f1523229bfe468fdfd6180c75b883226ce312ba5197e671aa646b48188b51badaab5296853bc72cd4f4038333635f4e0c984d42cd82d9747abc45c569d7e9be304b42b60b137de41954f6158e38a9577fb5b3ec0a24ce20c4380b0c2658f87feae5f2c303ac35f4933f881af8890259bc55883472d646ca468e911edf3fb232cc7f59cfa1c37c3a81df348fbe74a8b96354502c4539b5ae3d4b387c18b5dbccf7e1d3f98d68163cb9faccd21faff71983d135700ef604111dd3c1c808caf889d4a6a970a1e549912caaf8314a1a015ceb5a83937fc3f7239d2ed370d38b5e34b3ddf6b872c80a61407cd7dc5fe2ffb685316f33c46c4ccdde5dc4d5834a5f04b3efbf7cd3ced8a16668df97c288a74962b4257520e0e8498273155320d2490a813ef325ffef7beacaeb4b98d168f4b2a6893321ef7d8ce024318f1073463241e1939ec9d75541e5a3954c907300e9e93f539100e8dcfd3383ddf55efbba5a14946c438462f04a80561ec4a6ac39d0689b456b1637dedba66fe359faffb2cf970475a73e5a223eee3f8c789cfa86326a3bcf6fd4578bbe3dd9cacee39717638f5aa2954227db7d3dd5ba9b92447010156a7d0041f692c890fc3fb9b2e107ad8c7e2d718d7bc4fb12e35a30ff7e140e6b5b232a27055f0f0ca8d975063b9b47e5f2cafcce8dd72a2313e2d537db762f0507ef89291fc8d7a9e0ed960b3486314d2023d966116ae6e1c3da643161fe29015a62badbf87cbd139bacf2a38aabb68e084c30e8ef23d1387cf6afb1c749e1c3931a1d069e617263949f09706eacd8dd4dd190eb1eaec1df9f1d88f0cb771ee61c00252d780afc20a45c3654af330aae803899067067ba6a97c9b395c0df0762ba6e27cf86af0e1e1cfe674c7d3c48e215ac266e84839d6ad05a916d8a3532b0332ce2c5d12f5a398fb8aec9f178af2faf391f10f147d7ef298b2bff9c2db945dcdd19e75354c4653e0b483de20ffbe2d074fa4e991f8304e5bade8d4b30521ae478d37f326b23b5825cf70e6cede491a970adea59adb8db99d7b23a7b570d8104f1c4c0da8658755e28fec712aa1bdc0a7eea59ab23f955365bec2b57f917799af4f2b64a1fbba4655795ae49a5674bf7370b677a3f2cedfeca2e7ee9d750b495a3f696967024d167d31000fb122e98d99f4a7b4882e638366fc34249ef7847a7e0c9f2400887727277178b999198ab73de73651206a94396541b3d98ed23dfdd925f05364fdc893d7afef2bbc923250e69f6d8f2ab3dc54d96f6e7654a3c936e04e4650bd0a887df3b834d05eccfe4a1b604f25847450aa5d05a5138298f111589f0c4157897502486b09231208e48b6df08226190600b138035b7de3f0a21ec470ea31330a3fcbbfc21de9d58efd33379d51ea02496142b4bbbb06f9d26615af123467fa0c173bb1d43fd6e599bef9d2e362ea7e824f6e6dcfddf74e2b8c7afdf7c0fd4199f7be263456f1787ce8d564c739da32013c9671a309c9cbf82bdca987db2a372137d711974e1a179ca50d341d8bc063605a6318aceecf16da6a1eab2b841a9fd9fbad98bbc2a61c5da54e26b2717c84f3e2ef8af54887a71ececbb67c4f41f00125ef7cc0ecaad42bd5e149c86dbc851e2be1b94e727d1d658c61b7d17ca7903e645c7ecd9af816f684b01b7a5ddbb843d382bccecd3e2f98bc66a1721448f41b060db336123d55605a4017b723632e25d476769c5efd3d189f1c1fecb417fb166c6b04fb8e450cc978d5d4dd04b9be6381d5f15abb1dc022996b782f6a95a3348563a3c58f0d27b04cb2bc29569217ce511f7d18d324cbfadf3844ce4b749254ac451d1b5eb5a7578cd7400b82ab6389db3dd6d06e14aebf574806858857e9447537ef3d72d7874c8e3603a8dcff48bb175a926fc58c01e790b70ba69b54c976df34af4ae0dbe4d7e57c13c8fe6ccb19f22c4d370e4c46f496f1d08a654faded7f80e0a329fd674cc9f95dd1fb5e6861797bf81e4157f1257d35053aca2ad0eed2c8b3d72058b1c00ab83a799295bbd5d163563e72c064a9b38210cb73960e300a36e22bd890d80b3a9b7a4f8ef827a8005ee24c3791016e915856336b6a4c79b528a7c56b7d4a7c928fb49777ef73d039c094a12103e0d6e36fad15982d12883f3dcfff180bc9716b104fc2f7982144a963155a607118e01be63384f8365aa228d67085bbd0d47b58f095da78465def898a7bf4935d98bcdb93cbd9ded17fcbb5e12069e6baa9fd7a2199b8e6715cafc2659b43cd10aeb4a848d174740ea43845786b38ca7df65340a89c43c55a9a53d4d7431de406d3093da80c9d25a0e6508f082556fcd059e34b4708d1eb270c4f4530ca232a526127e89c85203910717c410d7e06abf30cfa555dd391f4596e67c0df39d6e1471deef776a2e7f41fa752a3bd39393223e40666b55c3e43699d76d25c1c95ccfc3cfff4e8f14a698e43de189d408250822f17a1ed1f09f4984e1f8244537374543ed07d319c7edaa55022c9744fc682d7dc1a73331970d55ad09c32856c39732f74d6bee9058e25dc6fd9255227fc9961f2bc6eeaa912309b85a124bd39733173586ca755be3d61a4ff6e4b7728d644583397e1f6d6e31affc8857b24691ea8a0155966894945d8d281f237de38300b202b4daf35ac24d94ce4383a1923ae98d0cd6f5aad4abc3b2a4f750eea9ca13fb371ceb2906443458ece59c2a186f091bc15cbf959c8defa68e143175527a50919ec2359fb9e17d03b079c88ec719fc953d4eaf7a6d2211ab284f4c6fec34bd573bb6bf15d51b1082548043c5ac77b471b5ff933db778a10a58078e8e2f65e80b773c17cc5a10c3b8248ec3ea09a0f5979d2004e78ade5efb274b48726ec22d938dbffbfc537dc5e7c068fd55784f0286a35949a2e73a960743e87647789ebbc311422ea73cbfd69ef43138c9644a6148ef6168a606e3d99d70b0e976517ae51a25e890efa00129c926dc04156bd424a742284a2942d2a373fda83f0542aab7a949fed91246a1c9f2f6c1af29e2ce0ef28588452281822fb7eff31d4f7dd4ac7e87164d9114e83fbe42be31359e0f35a512a9a15b83943806da94f4756ce96f3401d2e76180020f5a9d09fd4cccece216a85a1c0d491bde7ca44c16492fe1f9853993541d8c12e6269aaf7e7a15dfece9662a868c9207e7a60c8abd07cda6ec65959da46142234a0ff6f9566ae29f22c1b3760d5f544ec46ab50018cc274c50c88d6fe7800b36a1a21855df83531d030252d54c832772800edbe53161cd00fd663a42374944d89088cd2009c6168e0c1500e48460e9f9c0fe9e36eb56c43e6ea3ddcdbf42df23a494be89cc9ffea6937534bad8f1fe8ae472c57ccbc7613b1384a7605d5353305158a428a05f257781be22031d604eea6e50ee010e2e2843d922156b0c563664ad628fc0b57b48c2016e8253a0629e40a2f9be52f59588e8a5453772cb95ecd2873002f1c8863ed1c945e70d5da1a7717052b425e417e071dcc86a492d8dc7cdfe2f57fc073853038f5ad6145a85a245677d7adc8d41d29bcdf4314ec3d5517e5a827a1db5b7d1f53963719cc5df1ac13b4d7ed6ef9f50ef6b39d791dc9dbe984c0655bffba241676d31512e56727ab1f1bd3da010fd4c5ab8684f43c8e830fa4a4ba20b6238fa9f5d38c4235a2a570ad6b7d3b90b1c8fcf9dd1964969139d6bf32c17bdbc2792357d096efd7a85df6850a603f4fefcac9429f37dd0fea98ada4cede881ae0f90732b4ac297c45da8440690209b1a6a6a480201a3b5c93944596b0b322ee022cf387a9923d07fe233b65a5806b258b2245611b24f7293643d1219358819e706b7498158233cd8dd9d5c01d3c21fca564465acafd8e9d505ddd8751ce1a6dc367473aa58216f636fb656ce9c7543911de0ea9806ec9aae7904ace3ea9b4e95c0d31e15dead6e33fe298facad70ed5545c367834bd6b2de02183cb46fbae257f538d86514de04342579d0185b296ccbf9e806dfd0a685fcd483503f9472f3343fafaad2274855d3f97f66c09c79184c3e47e081b9b9e1dd3e11a19633e33df8660824d2b14a557c2339d5c6983a75752b82a578ac0283fd41ca02691d7b36f5f6afcb076057d11c7bce49d40633787fc7db263f1d07486e7106ced9b7af3df30374e605b4098734f6a0ecdf55b80b6190728bef2e4f841f0bfb1bff888b021d89e83f49ecf3993647ba7e31377ab7bfb85ca8a2190b39bd1e18ef081408536666176d6e346604677d2dbda5a4a3af1175aa5295c95d8f46ffa62119ca1325ef4357bb269d77c0bf9b12fed53e52550e83f940dab411cb322c3f03b7c4ac4b69df4c8a8a32ea91b9daf22bc37f36da3d127193b3e75013da65c0b1c2405050b0ab48bb85369def191f8a0cf14ba59c7eb4138e2d1fc4a596f91f53ef9c51c1d7483fd60c3a6d1df0dff48ba39c0b0e209ed05e5a54dbe5e5dfd102e6703686b59f23afdf74e560a746387018972c7288adce0a395e40f5dc136dccbabecacb1fccf183bb6636499c87998092feb67dcc0caa35770a9ddf14b5edf2ff09959891e9fca864ba34cc7a7ce9d8a36c5b50c29943627c07fe29fdc809d142842affa10ec1e2267e664f8b2312dfaf70e41e7f30e3f207ba24713aa60460876e0209de4ec4f31310cedc07b9c362e59832439215a4f542748f7c802d2a4c1b3d92b1fa51edf85917d56b002251914526c16486738c8afa591f140d7e7b8997d5a8c3ef197809097e79094b4ebef52ab7518eafcb3655631313fba9eceb84e0f8568b6099dd43d6bfe8eadbc0fc4e0cc8187eace27e2c217c60a199e67e1c87c149ae087ca767399893b8f17eca4be744b8064d4a03c2257f55463af1d15df615c33a31a150fba8e4b7edb05f115e560607e8155cf258cc251fc12d7da28d145d5e9cb190764e9578184d1610790c384489a71f2be0c194ee841aa9becd0403e017a26f3d570e3dbab17d377ad6304a998c44d7e8b75df2bfbb602f0e401152e004c4c335b6036e3fec40f5d92bc78e317bd0d3810642411fdc5b190b352c7a45cce9671eb685ee98e48303efa2a315c0f13af245d01dbeb728f580c7db40dd3ffcb8f090f5bc3e5512100ed8579cb42c13f646616dbba78fe50223c32747c43773fabc36144acb7a6c57ca1850c74d8e12ce5355b58f164ede340245c0bade9057050a17f18413906d5189ae530c15efa6db67a4a660ecc879f9e15bd67a4972b9766fc04eacabd7c8e0b93e4aba42666383b646cb7c13dd091c813dbb163960233e19a1606f5092aa9bc375165b5295f0cfb248988b370faa2de9a870bcdc46076b891843e3cd2f76565fb4235208a69d0cb5bf87ee599b7da9de462f52118a168a7d5b306f48a067e615cc2e3ccb6e4909b89630dd523ec902f1fad004e9f0757daff3bf6298b3b7bcd339a534b4d8425fb8747f99278de6a41250b077d6e4bc899738a698ea06ed5f656095d7868b5f06e504808ecdf05d41684aa0609eaa850bab100a38af5b0d399d0aa7cc91f011d635a7887e3e4d0521b8b624348d38105dda4a5aeba63bc6a2513c30485d733c63abd53e1e623efdb0bc39b3991edf9c0f123e526ac6566264166bd6620f04c2431e0af705b317689f17389200528af2bac52ff8f35e7928b48c73cf5adf28bdecd86c651e27a0ba7bb618c8b30206bc4c8b61f2fb5c87ffc11b892213c451d6224756ab634bc88e5dfdcc30f6a7f00c6ecb92508adff4ea1ffb87aed07fdab140aaa9c8063603dcf80bb81fdd3517c14c05c68f2a4fc1f20e929c8f4f31d0a3687e298fb45470709cdf64844b68345d1a52ac355afc6b40ea2bc2b504436337dd5657f4be9fa78a5ff14e4af1c48df7f9ea092dd9a49861c034f01358921690f04c0e5c96efcb3fe71e723a440fcbcf5574813891753f476c711ead9720b34d57049af88ba9c27447e5be6629e9fa2ebebdd952620d7786abc42a4caf656e7428747e304c3b9b85375481253cc1d3227e6b6e419c5e5f6718cfac78406c35e4e887c66cd57ad0dd1c3791badd4d8f90cc7906a60a44d704d5ff8baab09c1f6dc884e3fe5748ad9f80bb295f1104fac8910bb9024452b8bf26c44bd041bc364f26a94ba45dc4256c028e33ae79e80d9d02c01141364e1e910bbe8d684e43cabaa79db0a3b6f06d911a6f1ed9b1022113112c58f55294aa8ea6e9e47149da2e87beb29f8715653eb46bada33be239116aeaa0611f3d60916dcb092310de2c52f651ae2c01e6f4c024a33ce483a7a71b26c3b25c111deb7f942d40910c1db5ec68d8be3bc310d5293fdc6025d974d23686ef4824059675e1187b5beffe1872a79c7425231b9e21a673234d2e61c0a84c3d485b755b75570524a25fd0f7007961010e23776bd1db548c231158f51357a262bd360a876d41ad18c7013aee1b53330c3bf69066817cc47192d5fd18277b874581db47aa52cb75ad31b0fb92c3276a39fe3802ad20c7e543f4dbffee1d2b3f82b2cd3f10b04c8a3400eef3c02ce9b7b9e531b1b6263b49f91acc505041af2126dd6dc6aac1866d96d74ccfbd81f7efd8af11a0810d7a03033dc01e77800ef0266fc4dca6fccd4f3ab17d3e701ee5b21fb91f4f68df65400b84142104e984f54a52e99caf9edbc3de57a0e3c6cd5322b511f8dfb804a523dedd9656f731c49b237439a20dcfb82afaaa9d6ac533b623d30433ccd86a88564e63f6397810f1aad06f7e558112a3577a6564b52a44754cfa2ffbda9949fe5ca8bd9b66a2149d5e961e78a7d806fdafc9d5f9e249c34da9908971de92760c2305782276aa1bfadb023cd59e30168e241e0ec3c6746c3228df897067e9ab59f6ae99e1c3d86222ce485095704944e99db76b5167ef7c91248bd8bf7b6e0f5a106fb172eee39a5d4c0a966c545d672300fabdcd63a47ce91d8cd81e0d5701c5e9aae2cee1b8fa75340bf1d57c2993856e35351edecf789ae8d9277dc174591ed805fd48f32586a91586fbfc7bf67036a44c1dc9c5a06ae32412318c782e39a841f10a42d7fbb0faa19138958ad0229fd5594f518c0a65e7c947f3ed6d20c26a55e75db9eb8ec024abbc1375e4691222c729672494811889f1bb00b9f7222f93aef74b118c41fdaa5292c7ee0e58026495aba935302bb42290df1cfdb11c38d064e616467f9a73bd53f34507eedc59b6585a203b76ab82218ccbd9149fff1c59db901b133e6af25ee375f2331afa3a476ed6dcfcdea23a3751bba22dad7eab2d47749f9d24e4d4f71f67eb6fbfd280b9e403a133e59a8d52397093a2fdc1106f9a8c65f72fbb0a97f6bc3b3c5a6b0f0136ac9e77b12f6634b071ccfbc06829c9791edb390d829ca25e11bb96d0149712a982f0400133189236780021c2f165cec8d52bc7de78ffe506270c28a265cdb694867c4e0f7c4d00c6af63c1daab0548e8b65d9fe1b1b9faded81487c8920af9001e353aef61732e06c48e1bab0971b81a7b79888e8b7f1e60284a8f059a821e9557ab5c27cd1c57dbe9758750041f2180832e89941c7357ad853a8020faedf7bd562a45ee70cb73f20036f8e71da5bc4217600d82587eb771101ab5e732d24cc50e10ca35f572faf8898688e882e224c24d9cfd9643b7d3931b976ac3659229f748a2c869eae7e5d911b9900bf6e7323a932102296f26fb69ca46ad90dc5e590ddbf3b3987fefacfb29202eeeb27c07213f9c4ed6448ea23e58cec0d7621a74a4383e60580d921cb7b0073325f33708471458ec864ad15b90bfe420164ca1d0cd677905d5352d762515077b6ff97ffb4c08ac444bfb4001c1e76047ba1107a6f3551f3b1d2258e8634468f8126cdce2deaae4250a229337b37ecf7156203007efd6316be6d1df0ff7a2cc7137c6a5ddf4435340d25d65aecc5d7efdfccff69eac86d621db7b7292dfd902855766f087e47c1930754ddf066ff2670f45063a30afec933431ac73d76db97b546b5fcc90448487ebd7b208ccb232a88447e3a1cb31c9599a000e512bf524c04e5ef955270770ed38447a53d0e9476c12d4578e47882f9745da1cce859f9d2436b6efd14633071ca8824713b5d8914ede9c40554807bacafd122eb535f19ae259922b76b5598e5ba6cf69cffe7570768d417cf711bf4455db8f79f6d7a9001159baf0ff7a1a9d953a0164f38eedaab94650e0ffa40e1bed888ff36c34cdeacce9cf00ddd2fdd4bd8889fff1f863e764caa517cf7afd528bb80660bd2f1cc060319746c6f6414bd7d1aee336b9af38eb0b19df63f53f5c3d9d2251a4eebab3c301e34890e3e13fc5f322a07a90719eef113ac86b1000d91e297dba2aa4e2e392af11717950d8ea5f7b29f71148e9563b92a7300637f1f8119d8e8d3fdb53a795237f63d26078b15d4e09d9304574795d0426b13b8c70b44150ec960d18ed7c1cae4e57408a7a81b84d0504b04004686d44bbff9208f599750acf6e69d1d39f948f1995e4409e7eca8069a5009d7a9a882a44408d0320cb29fb99c9ee9c2fe483846974c69a64c3dca067f0df4376b51b0b6a740b0a815f78f413d53e7e0c5576ee740821198e7c20e537fe5bc07006a1de23ab1b8e8c1a9c6419b8c1fc324fea93cb2a82a4bfd4054b671818d5ee2da7608a8cc1720b623aad13de76167df22b24ec35c1ab0268648c74e46461b4e7bf561627a2f3873c5a44406cbe758349817b1d78aac51c39d71627c6373cc699e236b8c48f4c187dde7621a30aa7d609d8fa89382de5e6dd51410c1cc86a856a0352ef6d66f0c53003d473fd84a8144fd75301f8e0adbbd49b13c4039e8bfd193ac0850174e1fa3ed47b4c5e261648498dc2d89df3609dec9b0546bf414cec9a9b529d9cbc849c19b680f9444fcc1472df85ac24771d71fa6c55d9f036f2dacaa323e2e91a3ca885a6459b9a0b4c8a36ba0412ded85430cad96450def6959e1606004bbe76bfecd7ff0506008418bc5b13796592c942a6a12deb69d5d81ee122cd95630dad4f02235ac728e36fd9c544ab5f2fa69e30056af145f804453a7e74ee6896bec8da0e0b5e01e286718d41df5d50cfa659cca48a95c5860f864f46a71d4d2654172d4e1665a50c045cff317e3ad69acaa52d9d091ecf0c80758fe17244f603b35ec0f2786d880f85bf5e3dc719eee6866009834c8a4e4e9c9752041101e06edc791b058d0735ebf8142c211d36a13331b6a0f1288844bd6de2d4ddbf94c5926faa3762257528a893f667fab5de8f3fb04c4e0e1ae33d482f2bed2c9cdfcece54caf796b516dc0740c954ba180155f73a9c4b087b3bb0a71d73ff136a69ca6a752ca66a81a0055898797dd29fa39105f983d9573adcc6df24ef99cf4dee27011b29e2bad4ef7f8e76a584df02c009431b9abd03172ec2eed7b2a0abb197e02859fc7765616cef3a382b3c4aad94592919d029bcc6c21824739d5f1003c6be5c4453f79739840f25d8e836f2112353b59883ed6a4dce3578b86a70dff780a9b47cca3e03e4bc248fadbe7cc5fa3f7d16f7227bab079ccf13c9420c1a60e32a93faa57f105ee8dd3e00f13b175000194f23b0c48317c22a4ced07694b5efee6b7996feebd347a7a05c3ab2d2cb05161ab48c67bb643e3977e2e129e0bdbe7da9146377d149a40eeaac1204f698d49151857b5db23e51aef4d4a2ebdae050992659dc1d666be7e96b98acf43a4d9d7d01102998944b233a9cea49609bb019c385224873e4626cbbda43fe34306fcb250811f4da5e733929981639f63e365d9992e01d328b83b62c4f6481c6a1ead369966e94c1edfed54a7d0a115986e6539e122082830c4d6693e2bd239c7d3c1c9e72b39695b615f3104aa9f08836f6f2d05f39d5f7827ebb11597aaca74c7b5e249a988e4bb2ae15d8f334ec43e49e991ec7f720f40fc1802ecb4fadbae7ad331d249e405c89f17358f04011037932baf5f972c204d3fc1cf6f4f82155c30f04e719acc2ade2eb368384ad0b07d3730ea6a01e53b102ef4f6cf51b205b937440b0a2fe77eed5a18f77219f40f9426d2aca76cb3abbc39e30b732860d9d98298a6611664f72b70d9fa0f0aff012abff360384b6e7f7259822f8e530af921fd57af52a978ba9619249e8944a68b8fd7a6180b8d76aef889fe60a9be338b9de282fca0e1112319278b90bbf1953f79d6a005672acf73f75f9de70f19bb85c0caa2529949d9087ea1985cc0554dca39692c90de1daa4fc4b7d3beaef4e15805d2c15aa055a1f96a6e59b3af4c7a45b286e2431407e209e95187e38360651c25e53ce1abc9780cf7093c58475c3b7f596069413fa6f787e9a7d42803bfc54b3b6b7656d80be39125d55d032e3590bb5cb26e2fea262aaa3f75627b881460ac07bdade38231b21daa6484f5e9f395afaeae502c0d465b7a76563b2c0743ebd3ff5173eec772b042057cf84ae7c79c1b1d8cb35c3cb7a89b5508d143c9357424c6682c78d7d175d7b585a9c12f5c78e0b0be42e3ac8964333cfcb3772f2ed88be0cca20014d5a9ae4d9ead92495b07490055e43ef3f30a458b9dc62ffe708fafa6c082e3c60279960ed11045dc8136a10db73ee30806c1475c584a90c9a35068cf67b8c72239311ad7b9500bd9d8bfa2e09f697bf5915e65a17156797726d85c5c59534f6f98c3d7c39b20ce07ca9d2d75dc13ce95b8ebff1c7717f502bd567df390a3b886ba8c873facb897fb055d0c4ce0d82bdd643485592878a1276c6fcf1989e938526001fc4b3a8370bbfaf3c62cbe316e2c85354a5272a4e525969a3ccb6e867b42850db7bc2a5586a1d15cc02b555215c68037a10a244f985f2634627a256f0749f7fee651e2f46cab7a2f9ca573c2d4c4fa0c5cc4bab7adcea9628241066d526f84fc1ccc8fbbd9989b558d1946cdc89b08cc3c96b42258bb4c841f4018f2304e0dd96b8342e728c5fa77a698f8d780d42ba0c4f44aa51ad71a73ec0f51c0945bdb3d0a266170a92c00e9bc18de009c226e8db24f2778ccd4439f9520e221f9dd97c9d6e704c8856a6f6e1c4c58b1e0c53dcf6d6fe9721dd77748331dbe1951b0f1608bd5f910598b9570234e95cdfd11dd1297457cdcee9d388ae9b43cd4a904eabb0bd0a3309e65efff4378902516a587fc2411f438ec4934579d9a9bfbc5f64b929a89ba55f5780ff33d01077ea054c398efaaf68f022e1b08e1dfa65b50de9054f71c5dbc2a4547527a0edc3d65b0ceb213a9bd388be9d3e956257f89a85df93f14316c78be371d5e7823e3149c4d325e01b7a66147e4224a27b533457faf0184d0b73dab228302f8f2e136024acdb7c020ec4b590c0a59a346e56e6c27e7a5d39d99fbb7770f3bf8fc0f4d48ea8d45ec531cdc38b172ef1cfd7043534d80e39b28335286892392398564de8535a76822947049785f1bcdc8ed945df0a07e6166c0ce423944e3e7d53be8b24e50ee052fb04d12846a7139ead7b766ee00d6602cfeb444ea172383c0322c9b0767e004cfd5304b1440d253ca991b26279568656bf3fabc076813b5e9cfaef439ea7317c3e7a00512a82a212716bc0f86723d0a7d56b2b44eb3eb16affc6eb4ce7f3e3e36934b2293f3864ead9c2923086a8c40eedb597785b2ead80e492baa01885e53477f624583178eea42e9fbdfdb6b2b5c8c374c23a8a5f64124ad78e46a22c2f483d902394494264c8a957ae96781598d2179befb5e7930655ab47eed2fd1e66da20766506e3e1330a76af783dffe68cf7cef1d5576f504b8df1ca76bb7e47bb683d93e025482aa7fd49c6b0f1e467127d67d0415059bc6dffc5a1b1e29447636a99b476eac3689c217eb786b51b1597bbcc3d61a836f3b5e676295a4ff57dda8e286292f3d8b8556867c9b3a7506fa15885cbd4be44c9e962acd7a4622d7064f23af3e497af23703491087f09d4725e032d78f37f21c578567a0e7a1c9bd9b29d9c41af5c6f1ca06d1daf817bcc2142c36a9ea7cad5fb10a744396080ac773ad72ca9807c3dec551586acf8becb0e389c070e2cf7c84f99db625ec6a25b3cc766ce91e42b0820894e407ec4c48beebf4cf8d561010585f91bf740d202c12b095638012ed00cceb45aba5b713e8591c077ec029ee4e643718b6bbe952513d85236831d3460c3379547002f71b07c5639384de9e2f6b934c710887417f989165366cbe44c42a6a11941fc20031bfa84f2991b3971a901fcc47ba4921a519969677f22dccf32813dbb57a220e086c87a39dc69f0696f78ab8192b5eef639686bfbbe5c824439d38ddb6f4073f2fe60bde47fff90eb435de3210bcb963d44de8675c0d30f2c430287ec70fe4c67b5181cc936a9a361a3168243992b66121c86942f5fe46706658c4e8153fc21fdc51a268daf43e83f913fe65f1ffd900a5cfac66d51591375b6767f62c2baa2179bc2631363e72de16c6acdf1086171ef1692a18359542dfb0e13266cf8f4414e0507be895505da60b28ed0cc15b1c3a2e26d5892b6c34fdac334cb0165a1feb0b81e3a0328d4d012434489ebced8520a03889a2a3a6b534cbba72e2203726698046421ccfd2c16cf3623b0d47a5181f99171d6281b53d6ff06651d228482bf8b736c8355e92cdd667b6719dfd5666cd949d2c0884fc95dceaede7ce0428bd3ef366d21ba6cf1b04b0cb330b114fd732450558632cf9381bd73794e8cbcc5e586f9848976587f47fb873b110949ea04aba0d25e2c7c222bc304fbeafbccb9e16aa1ffd39fcbfaaa3f9b313bc333d0f1b37a833a954c9c77483b1a65bccab600f8f059e916cfd972f82015c593141991648f6bf5c0e5fc6568855684b6362091a08e5d50a3940029703631fb0485c4f1b6490dd015b078f21ce87ae4fd996f1cac886a5cfe3056cbf8e28c0687e9999fbdb2a2148d069bac516242eabb2bd232110d340a633009ee5ea524513ad9486a15692a7def62797b9cf227a6714ffdde2728d6ecd11b8bdb70a2ef3ab21dd2e64e801fe2f2b2fd65f696717bbdbfb244788bbc0ff11be8af54b2908fc607a84e086ffdc92315f4481678ed2105a4980ea21f1a02a6e45b61fb5715c2f88ddb2ea213a1cd020bef3ee2c47b5054d4c8fa2dd4ed98701065180cd88e8d19490d0007bdd39bf06784ab9aa92b91a3e9eff04bcc05ba8c78411f6b1b06e35cb887e16d9b8f47ad9fb86e9ca8e9b5fd0c68065530c8b93f297ef26164fae19df072da6349fd0d3bdda1004dd4520799a849ecb0516608e2cc83ccf34b3c9ec12de10e28f0b87b2361c786e3b3238f9ebb61a7ca593ea6be47643c3d9354d2a23d3141e1be8a7d73e6ab1be14386dfe56893bf44900fe265a597de0bd3881af86ddc601cdd3ad7c848be089e2bacf41e059f0b2895f52c237bfa6d1050157b1c5b95f5e54ebeb77688793515f7845e03102fb6431a055da74711e20cbf58cd0a5376e5599c0e7cbe201edb2ec163bfe15eb9f4af8c86f396736b54c15ed77c4c8ff4920a10fc75f77f28cde97de189e5faff9ec43a1b146a9040c6c92a7495a6090502dae7d21a3aa0c8e84fce5e9896da6af26a75a2aa1decd211a532b422b1431e478d711ac2e94aa361d05d2e6a950010aa26830eaa991c5ddab5863f2388e570d1247913afd0abd2f59367f98b20881c4454720a0d214fe9a6d09367cf537f55809c0b0a12b268f08c29117ca94286e31c680580292d28c9dd1bec77488c93cd4107599bf08456595499bf5b0f1943b33d6643c3b0e1abc21ec450ebb6eedb1ffd25d2630b487199639f877faa574c944a79cc1abd096fa8112eb4d0c74ddb5ff4fdeba8f10ae1d22e6d9c9169d7201e4833f40f39721c0038d5b309626e448a6f5b3f346840df9b4f84194fa5b5e44906f17d27d2a4c5c76e640ae1825b2b3b5318753f4b62a7ffec50e1659e713c2b115d29a23a030a750005ea64b2a15ecbc8e241e2a3ac1f5fe1f26456289af18478f30df3c64af3526c2b0c2467ba9839dc8ac4ec9e5903f3c0af93b80d260f116219bf0e760c466875d146a56bed92f48f8cfb9edb86468b2730fdc7afcc30b55f889a10a1f528bb0aab9c157183088caa7cfc0645a277efbbef2c2d0745bba412270ed9229688b6d11dc82bedca7726530925fb2309e81a017d32fc58ec36ab1cf96f4119e1a6cd4f46a777599a2083570a134d30c4e4e689eba8567521a01a76650db30355dd7777ad556236d7dec7812583827fe8fe6695be047b38bbac6c08ca1f0c2109d67ec58d9e4cd36b4693d298557cba9c478dc12cbe48371793ba666f183401a199102e89c81a51bc24d8bb2551e07b2a8f3fd5b5676f1f7bc4a29b48dada7cf95ce7eddfda3e30950a1aca7e9b0a6469c65f1c3acb2157924d344e4146144229524ab0e1e5ea7421e28bb6bebd09e1dec3cc9fd8430052ad352fb4ed8b34664cc266210d8384a6e8a4b0f52ffe61085c9b044e0502a2426fdfb06a2ea164a09414d494bf1019b3f6eb26831677ebee24754631a3612c60999470f07135a235a2c9a021325e7300d4dbeeec074c1acd5f781df85d42963b287308019b077e41e5f20d0e4de80a880d5aedff2790378c9fe409164fd01f710185466ca9adafdc98cc28227910c61532f6d9601ab92e3acc0fa34d4d4e92e9137ebb79e0c00bddd91bfc58406a73a31c649368019de8fe153420543abbd7fbb4a48447405c9490d875accb40a7b86bd73497ea76bf1608638f50094c46241a0b3c6b9b23cf69a4a89c3724b7d636afaf470c036457f0fceeb2473face9fd4e5fc4d99e4213e4f2f21b41481fa5d4f98904228eff50b8b3bf7b194bb30616b14af0864846bf8bcc69e653c3d73c73d49be5a2d55d6dfc63f4e64b970e5da87eafa406dd3e121156142f4eaf6a74ac0f466b2817f183f6f269224719334fa6852c0ce1cb67bea6e46bc9d9f54a526cd38f7387d836a6a0b2849710e4790751ae7e1bb0b9bfdc218ff0e9ab62931a0ee8bf049dee7aa6d84429d273dcbad300c972bbd7e5c4a46c8a21b950a4204242fbb022037267a0f6ed15368dc14f0a834ac6b0355e70d045dd5f81335e34c1efb8b6cd3df07ebce8f678a6eea3ad9b417d36bcb2b5b951da30c747d9d8fecf9bd2328fe5f7f2001986f31dd92fc639c2365c31647e9b21db3b5fb4fed05e260113156cdfffe7cd8823f28dc32092d21703765545b694425aaa269244b91287de5ef96309b6d58f6d34f0ec792be8fed38215de908ae7384ca44b5a424500","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
