<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"514f0ceba437f8520391cc09a8d4b70bc32db0d644cb74494d3965ee88e904a471027d83562d744bd4d3fcec8217293cb4d8e1e5ecd759c308dccba8e1795327eecb4b12a077beb028a018c7529ebb760f7bb88ca52e6e7a7fe86e3fd3d19038e60fb55b9d6406d9349cb804be4ee27b84faa100e5aed117c121f12cb5646683b5a9b10eff54c2bebe94db3442d8da3158c3a13b17357fd4ef0ae4248a8e531c57ca2b71cd5eb38ac846a2a479298ae2b3ee8509204be31c8b1a883def3c5325b614db117ce57d546c8e885bc3cfba1de1e78762f2edd1f3837b89eba7323dd6add5b2b8a6e78b6e4ac5b2c78cb0875ab618f5c2399a11c8cbf0f8ef7d6707c92cade3d86bd46ce93297763b5a45a78c16f65164216955c560e68fecbbda840969fdf417332801ac2fcca3389a4b507af0ff17cebfc5bf68d0689eb329aa9c137bae95f9f86efb47deb08fb48d2e3acea86a87283b3e27c0a59fc1dba35b77eecb83b3f37838daa0275dbd6da79111aa07d47095497b731e4a77756bcc03aff3a6d90b0938118f010fbaa0410f3a69110df2e3e5696170c169c7d803497138c632c80fd5c439434728d87e81acb78c822374e108dcef6ada399ccea9f443f449c38bc9c8aebd9df13bc7213c0a1e1529ee18e14605820b6e182697b01825b90a428701ef28cfbce6021c8b4bb46f77c544571cbc7d9587d9c8231e7be57cac09cd354f96ec8e96c63a4d54aa2955ea3ce5e3d9954d0643e27cd48aa9bc4d320d4163879cb4daffae323ce2360aeeecd5252438b6071c399a1db76252e614ea75a537949416ecba6f14b9e0615831614b0a41a57bc88e7a534cde7ad291bb11d032898ffbfde6f312deb2f14de27222d21b5b38afadbf592d358faf6d83d350c20dedb054ee7f530bc502b00504d50ff65fc560375813124e30f8bebed09546d176c3d536412edd8980bd4ce208771bcafd05575df9ebe86bfe30fc15df85626f0ea5cf5c241b4ec96506d4ae7200ae1e71010355dc1aa4e653103a22cf4c2aa5e41d0eb56e7dce5da48216a74c3b811d0598324d586aa16980e138d895dd1e9e9cd4d4d120140a7d6cb8c2c1514fb591563ff500ad973e2064e81f9b1ed7b022e4c22633f1e0b40c2e65347eee73c1b8145d6cfbfd17f5456b4af6a9f9754220894c600ec8197aef22ade088cae564c58f951136a6e0134a55f749998e090891426c88a3ef5a579222fddffc547786e718fcf655827c2d6b4f8da61c2a5af6669d3707c8a3c47476316c635d028bb8855fea321ba7ed5d5576f809a6b2c665d84d36fd85b3765786b2af3ac2f64542c0e00db7241e911b2bbec039002bde35d53d0b5638d46b191425fb2e3989ac753f98d122ca2dacdb3ba20f04d2d4913e148f12d49acff9b6c67625ae28c24443ee2c22a2255090fd02b45822ccf278f623282e91374d0b5a2c9848d470906586b5d28bb4658e8bbc23e5d5a2a757fe5bcb5e7bfbd4028daadea8a01149b4d658a9f992050fc4544c197edb5fa01bf9caa42c551748f05bb9b320a4051ebab9c88411e4197e6a267f589ec1fcd1cda0d66310e7dec8046c88db4726831248dacf269712c8d8fbbda816976f2c7f2229a82f28129d9c64c3950632baa2a1fa3a593578afb5c24a519268e9e4c1a3a0f05b2ce1abfb5339ec5de40b2054dae4f1f9d2b78dc997c5c8cda581fba68dfb398d6947d769341b9dcd8343b8eb18eec0d1bccf996eb6bdd037afc819f06e439426486b6b9abba68d6cc7e0f3ba3b61f442e7d8ed6efcbedb8f3281678d48e4b539703e2e48bbf9fa0e82118e0e200390719bbdefb3666e0f2cfca235b16b6ca686cb25cb5b1065b67a94272cdb760d81b53e1feb073dac0ffd449227c4953a83ef2783b5bde745e0127dc8672fc23e2733dfcf8eadaaa45237e38c962fce31d41b22d25d5dcddb4b4547680d9d1ba98583fc2108c845c0088ee148f97150ec32f242eac67bbe05e3d1e4ae9340a136914a2f43dda46c118d473acf841c4e24315fc26fa966dd443d3729d71bdfa3631b43f39f487460744ef2220e443c42ad8a8a0da64c1a83e4afe345d27490e3629466105da555402b012c625698069600c521977685b5c8b7ad6b53ba6826851e27fd76e1333ada6ca5d4cfce7d4837462a94dcb68f323e9ff421018630d4648e4d4d6eea0feea44b69879d58aa9d4fa27c2185da00443e1c2c353c19d098faaafffcc76239cf22fb173d86ef671a628773122b4213f3dfb3765a121877d805d06032c649c38a8f5f05c681f5bd395851f5427da719e77c717dd0fe676951c9bc9052408b997311f0fc6bd007e91f970961cee4105147d3562def2dd1e342616e84f46938d7c5b0462cced1eca83b971c8467d938243dd2e214f6fcb1da3be66fb67b69d397e19072a5df2b20c6e30aae3958151d7f08c9c223ab84120fa68163e474c5c4367cb8ba561e73eee581e9463cc604794c9e5da84c2eafb700dc3303d2eaded0c498a5e31356424b4ec517713057faa18dfd15ac1d53e3ea358666be166aa171c68c05799ea62fe0538bcc2065db0cbb5198cbef16ed7e9507a29af970d3288920bebc88e289f8fba1b39c86c666360541797990ec8cf4a08a9d3d8fe5780880ea08e9db315328450220ae46e779182065ea27a4a71417e623c397cc0751d0e8ef36863f95cd986f5101f4365b99f9ae2f640a444a705bd90e02557ada2b2bdbe92965e06e5c59b7bbf8f3dc8c0dea2a175bc12b8ce8f4146dedd3737fbf0d5fadbe18057ae713e7a6c1c04350b93c37aa38b850593778a2340f395a84ac51698d4034e5b528642e9115952ad9492a7e2734691266cc32e0c4d1a6269f967b0ed103258db3017987d2cd9b9fc60f73af304f4028bf4b85e51e19847740dcb46ccb593773515e237dbb3ae9f1e4854cfe9ab8e1ec7c8bb2a647b18f98af91ee765d583202642ba7e6f8200b8dcceb6ac6be3e4cad2938273e8a2cb9fe3aca9f7c312228d59998df53835096ab05f98eb951dc32a27e34044738c9e987f72950dffc1ff293970f3dba6690477eabd6236b5c5fec279b1bed7cf5373e70ca9be078f749b589ae4410f5fdd630e83e90cb45dc9ffbfd0db44e31bc6ff33d6839a0517d8477791a3f80a4ba9a01aef5242fe456b9789aff91cf913d1612158bd196ab7974cc17d2146e0b4d31f2019837aae30092879b5bb4290dfbc74523a6357484d90c70c635d392b106dcf095787e0d0b97774abd660246199d8fcaaf67f7cea15c8febc077539a9d2780f581fc55674e3784bc2a29bf720012dec056b639364c3b78e847a4cced16df23434f18083289f0e0417bdc928e802fdd6356f6ffcd2be5c15e5ddd72c2c4241453c8e44ba7fedc63d4c1e4fa4e04f1b6251aaea1789e6feff42d93ae128e5d9e3dc16680d76724c3eb1b10a6ed94c88e7993731997219566813696a290d68dee5648ad28f4e3969a82e0972407155edd69bbdde94805f347a76dcd6e281ae37a37062fd2d6f055fd7e62bb8f2c75c9c6f9939f4b8de6e08090994db6f0e893b1a3cd78ca07cff0bb1769295c4fc895518d44c77f4e1b602205d022ba432dd00ace826bc978e2d3de1cdddb533a2ee5651482efe1e9e0012af9fda316022cc138810c000c4c500b7c5ca2d82cbd74c4617109ba4d55d9e2ae3462fab6ca35ee86039d0a9ea96896e3af2023594b7a799522526092a2e63c710b25aca36d7ef10c1d2878bcf2af160904783ba71c4be04264e1e8e061371e9b157033ffbb04c3179845ebc90b74f1c1be8f719d3aa98b020c3df6a9f576feca74b12d2e8b0d917517265d94082b8d80c1e938dfb3c5ec9979c688bcae8cb9f195963dbba3a917ef5b22daa26855c697744b06053f5a5b2673b33cf8fd80a42b1a8c621e06b8feb5b1aa53583036e68735e579bb8b9de6ef2545ffab8b8556965c4dde8b121c38a5bcaab70b8fe388ec5d0df0289b77a4d09028b857faa789b16100c3de10ffc3befcbe811bedde4895cc078a4dbfbd71f8628683e56a02568b92981f27185d67378f311c73ad08d36e0e4c879c407c1087e0a5f34e1fac36cad2e060da18f622db8f7fcefa835717ee3484f65ebf7aa660aa05b33f4368c68033e7609722bf2faca7bf00124c035f17bb8490d20bda3e1f0352691b3905e5cbec0184fc3519870f54361bf9712a4d6e3aba589df88b0741bca7b61a0b8cfd27c84e36241542640abf73b9ca684e6e48ec4148b2a0c16181ee06e7a80e2de8d4f745c9b6b1d25ef108d9d139019bae120b3c76f030e10f6910e1aaa6f1804418c84c0b8235fc0d0d63950724e53b41be4e2fb5eac13bd3767f452dafb73aa4e3492062c503371f5bd15f0c5891c8c383197c0757d59e8e7f0ea57e7fa8789e3088601b437027fe18516dadba7098d15b9425d5e7f530414a17ff3653fb7b87f3097ad86b7d3aed6da3ca4ccc510c6306e1605dd807eaa31a2c5f4f1c95618bf900b615a6236c4ed8363ff13c80d67d1551c3458af8d1943c77fb1a1891cce4891cb3869618a6e03550549938b45171db8aff3e58944bb7337d80921307b7c5819bba9677abf718a20bf34439928a2f7af93e0253218526f2bb31aec484f64f91c2e2daf638677516263d82eb77d057dd9ea32226abb14c9faf4227a307ad9c05a532fb77e8016624fa11e5d1a3226072022a616441723a63e63a3539f7deb9b53433a2f29de1a70250ea34fac0a5a20d69a1e50fbf5e6d87a333bc3c0e7d32e90423a12e9b189fbb8bb78a158ec0ef4fc58c6bcf1a1b5f33452800c608566c54d67bc74531cbe46cb6d63647b83b0d34ef95bfa0cf07044c7d58bc6d9349c8100cad164774d352f03313dd78526748541928a0b646b5d06dd489726de0295145e7cf049005ed5d2013db9e84981ca6794e36068eeab84e56472584162fa8df158acff435a3f486f5a89594735e80e5291500d40e75cd8553bbfad156e95597976f6377c62ed93d0261ba389a956d9a0147f65ab0500a69d6f35fd57fbce03593fc2d59737b388cf3ad47c02dbac9ef8324d09c949da4ab541bf7dc7e43486786b8cfda073c0852b1bfe0271ee897bba65f627570751b36f540f45287af7a9d9b5994d529aa436d94d6de536f45802eb5c49f3eebc416dfeab9dc1bfec606f613c44ceea6f48bee988e04e6f3ba2e9d4f6746deee67346c47ee630576b3e2bcdc1765b44686f25d4417ccdc1874ab0a864112797c4503d4ea5c7aa9cf17a2167ffd28e7103015fbcd5116d052ed02607483c63b220a7716a1d8b8e7442531feae73416db367a97f02bb2fd32239afd947c6a0a7566a1ff0d7fe880925549697c2a490d86dd53be1f3e37713d18705043be592ff7019a6bd4ddd7d6a1aacec8f1737985b97a4a484de7a8a95ec7417209a8f76afde9b29c76af65560e852352c2c0cf76de7361dea5804bd9e47d8167b3c2f640612ebcb15d8e41895e4d5c88c73630e27cd4be8cba6b48dcaea1b83cfbd20a3d80f2f659965e8b92e2a1007b90a2bfdfcc9289a2b01a076711c0792b5a118430711584665e425f5e36e87a9d110d5b5f8910b3cf8344f123fdb186307f046a66db74c5477b39bd89fa2832308c5a28a99da5fd357ab365f81de1471d2841187b1641a9bd8777a6d31c9e71914e8d9f0f4801ba71f1e97bf8591b305050d45c41a33348dc5e8d3f5e709a213788a0c676978eafa222ebaf11b0e256111513ecbd527201ab633c6c84d9d0983fec0cc02ec20b35ff91cce3038f84b6d7c1822043bf67c2e4d90dcb0e0cc2db9bf941f72ab4c38c22e4d66eee3f8e31969ef6e55237858a77be085498360b96f1a617efa099e6266d0481fbf78c8135c47a2ac5cabbd98f173849b045c5dd47bbf4a199841bfb10527004d1060e865da747e83a1383035baa7827889074428f47801ee2987763d1ed6ed3d8b5a7a027dc08d404b0bb4fea7a6195fce0421b3a1f51ddb1b8366e37d33e8103df5584279ae4ff2060ca6d83d3528ba7af657aa78a15c29f93e40333fde31c8a8f84b97238475ee61e79f49bf2f2b8f6369f385d0a5304db4b008aa8120ee06bf8f4285dc871e4c6024bb27bb8879e7a084e96dad8851d71043d6507c992e2652b566fe041d8278c18f7c308c23148ddc385ae678819833e5600cda0555d576de0805ffacff7431d7de6bcefedae5769c1f375cbb7ac98108a8c261d98c23df5adc4e74716bf60e8197b1029f19b8a219d001b8e058c3083ca19dbd5d5d647e77ae2ac80f1e0d25398acc5b394728eb189c0665cf593961a7f67d47c94f05148f64b456d7a614506fb52253ab5fb00dfa8357ad62b4c651fec3efa54aceb256ba30a9e669544cef641c8d7943c99f8bd2d332118e4ee189f16b2085edd8b15436873c46e16845cd4b222d4bb7b4a984771f683838976d9ddec9d1f66863879b8d31a5c506d4467919e1cc642cb79ddac710a8da42de5f33ae3c0f69a51c2273b33b9bcb81fa1aa8fb06a142b34bd40a0f3dba4ec70343613fcbf054b17edde18be8c2970fee8daca592d5eedf338d4437b6999eea9ea0364a888277fd7b651e74baeea64980a9c1a82569ec56c58169eb51287c7fce86a68707cf7451b2de2e809ac8d502724ecd534603bd2a1b57bd902d636399d1d5af3c7b4c62a4d593354bb11412a5360608182bc9b688d03bd122aba65756fb79516da0783720542f2601db53ab9975d3d48e11d1636f50b9ae0957a66fefe7394dce7d1d91fcaeb5d29fd6b3f67825ccdb5bdff763b31dbd1283a75915e9094edbe7078a3507bb050b6e3603397984f92326ba0be6a417923485158e4bd506c6262b79474d10560f41b98754eb7215beb176d7ee035461379fce3596fc87d065daf597c8e95f49a0b025e0eed6e72d5109d9d4f586cbe338699529596ceea4df6ee7603b89916eef0b54cacada71d23be0ab75b3fd99d49bda137c6a2f38a9f2190659e040f0fcc806cca55cd1033b2249a934d99c2898b0febacd88e3340017bcdfc5ca74421e043377d936b8511d23d8b2ae0389a328d254504bbdc855300ca6f87d2ee73a142ac82156c2eb35fe4b4873d29f066b9f4dd4ed142457e160c3b86e15e1ef2d53197289c2d29bb9df061c6256cd6861f51ab0b586cca4b6d50ec02b7fd5f5b8772e6b552fdd55a9cc6ccaf4d28f027c187edab90294e11077e7a9f30961667ce2fb613ab63fb0e6ec32fa04d8149e4544ba03d20b41be88f2918042eab09f929810ece2e2299d51b3094494782b9398a565e6db31a19e41a8f53a8e5aea50d5dd89e0516b03366edc1cb9baa71777ceae5239054aa8fcca0011a08bd7088616592a6fee2480e7ae2df4d68ca564293896ea61be7514edf275b53cde76677468b254de22511a02d30f3ea2e728dc8a39ff0f2c028c8025af14a318ea2a085687b351d5fbe5939de0920e6f5d75aec95137d3527d7bc9c57248e92a6eac7ba68ccedc367933efc6226b83f720e4b1a454bb9f6ed8ef8a2b977ab09961dbfbec94f7d542609f719508443f1b35a7074fd1d6473328f16f1b6423de05fc4f83e77fff4b7082ba7a6104de544ba5ea376ad87f53055a2573ce6f12b29c90918c33a7b6aa70247119646d642fea89cf5374b193ca792fd4398c1a38f0790f417c4ab0c8d29fc4422799659f99b607609273eaf7294a0c984fd735cca76f5f8e2abccbfec64f63178c9e22b0e612dd5fbad766bcbf7e2ace434f22820e3b983d8cd3523101d838919b657d6072a737e086394548d8dbac0a7b371bca5d8aa25d10ed2ef78b51910e1dc0cf586cb7c3fa3309f8126188382f56039dc16d60b510e2886328ebf3c2279be50df3a5287276dafeadb1f882ebd89ecf49e4b787d831bea42d318dbdfa5711baf956deb0c7ff7a8d292c2ecc9f053aed007313ab0ad0d54cf333c497fd36831179bd7e5adcc03459c3d828913bfc00bad436504b8b7e5cb11d635e391f7eda822420e1af9940eea48758b336e51415300a80e2cd5b4e0fcc8c8b383df7fb9d8ec2e274c9a656661e24bd10b15e62cabbfa2b945601eac2f3f1066f298d23e09beeba4e4c7f910ec4f8b418cf6c5afadd1329b9ff5e49f3e23b630b1a173296b7feb5d34e0a00984acb09df2701300705b937c4a40d7bc8a7065f3bb010bfa4b3cbe8b55cf388d74bd6e609be0f0ff74dfd519818fa5f0634854a82f863cb82ff84fccc9f5ea767f3d1f8c738449326d6740a706ad361d590f3ea392d1b938ce9683e90d6b34813828c58b4b2c7d54171c533da7e6b88a943a6af95202bba264cd461af5a7f1cf4590cb03367c38de9dfc3b15a60906e8a43e9378a833aeef940d6bb0af902e7e1405686da6b017dbaca56617454a090bfc28cb823eec27cdc3da58a61e386e0f48db7e10864fe353cc949f4c9eed0a18fe3325a8b1b47822d3deec4acb700c8ff415a6ac9a34c6b57765774c89d756b93236595c432955356746888b4678da3700ad73e8c8e2505c4461980ce0b4578366f3c3b1e1b1eae2f59eb83e9c9ff9f761783194db7672753a89e513d9060e3bec6d1c38ac5c6df595350a018868de7b11bc9ff38f61e69c0ded9a83f83453c65737fc01617a1a743e1d9a2dd412e69542930317600039ad50b8e5c1ee3216e272d12a1ddb63bfa3446e6b7b96ad21963e94ed8879b71c3dcff5fa69a19f12ee0afc2d393a870c60b67f2da110f3653588c1570b728cb0e49e626ed5e89381d5799413dd93e641d1e9cc498e01f777e391e76f0c996c244677ff0954327e46d9954a8e59f7f529b289c6e39d3962f7c58d19cb61af02e8062739218138fecc3613fa821cec1dfce9fb22991f7c66fbbe18cc8419446b6127544a1ddb758bc05ee8821e4b7b6433714884116079735634a96b7ba7c09fbf82a58d0b0d0bbadf676ed0e8d67fccfec4cc15a96887bfb8a296b492ba18ea681c473d6ced7a9999ce9233aff9c5aeb9689a0f0607a2a91ea99506a33fd17b083612dc9e746d250876faa6392558cc210824727f8a8012e97d8e28510a8c7ad1287fa4d379498b61458b18a0e47520b4cf01a1e6057f9e932b68a102875e9115a22fb62bd9a1cd50dbf91b19ed8064a95320e58d1beb168ad9e415fa57bcf888fa3e6162c6820b58fe534c439b8308a38ebae89d417cb76116d32967fc8045060d1b807a6d2a30191bd82dc485d5b22e438fe490abb9716de2e7a89b0a21d7b91b74642121c000d593ba6456da5754cd93b89c68f2b4ae586ae9a79e35d6b72e309dbe59902af4e84346df1e9a90019d3c9956ed9b0694a4fd7f06812aed6eb2c9558cac3db1e8e38cf2b4f15b1dbec9259083a78572b63b34b874fcf106e094225dacd2ced0356464f6c9ba57d7d3bef1f5bb5faef9841493019e052caf50964f2e6f90ef89797d54e244379cda9c74727a59042ce98c3b335a28ef7512598e614866cea4a8927a61d2314b7bb89db9f82e9408ce46a0a3f37978b49fa7ee476a8f0730135723db9c63048a09e0cb55986afe89f56a6f4f32937831600564f65774bef8f01aaf20e145e3a889a9bdb178fef3d39a6cb5ca9195728a8906b63b45239ed08172d3a1c97345de7ec7171139c5d3d31b308c36c95cdcb989de37c0e32cdf3574811e3a3ae563518e938c329be960197bd6b722240e2f193a75d4881aa5261d0573a64976a3822016c99e9ed46acc09d60a39b5375d3905ea854335dda4197bb6f6a971f7cc06ddfe1a03e8805ac3aae5e2146f6714b2ea0786ce2138224fb27d672b5407987694d35d55177739b7ddfe7fa6dcf84f711b8238eaa399741210dc0b8645f1d87059f23e96171234b6cca640e44c4bae02c23946cbbf4f05c867855e7596576feb77a1e2278584d89266287c6dda08edea412cd033ddc9c2efdbc39fd3ac67d750d7f9f65227e0ddb603e6ea4a8d8daece3ccf8dd485df618cd0d2c1868483076928ed0fb8b6a30453b8fc3be73fface817d75f0ac24b9958d348a63ac0449d02e499b94a5fee385517220893d17cbfeb8edb701b9d3195ea43f9ab99e217ad7975ad24824445f2090217d7e3a4b7f6e314ea1c2fc7bcbb117ee834a8020693255956a8119774c74dd58e922aa1c38920deeae9b1057dc66baa326eb3df18f58e76588945ecf730b775c9ff21f8f337163f4f585fc6bee400209dee84da5fbea85b87e416463588f188a7d1eca2182739b3c46b0b7b5a9136ad352568b039503f385c9fc541fbf0038f6e558379178fc210f64c9534ecec0bdc3a8c71ec1aba897d9301fa5c055a8936c77b1b65003374c487fe7b8a3bee5bc6be079f08104cdab8a2733b75227e96819d4672ff56e453fe6324ffc56d2178835cfb6e34c0344c8fc8bab46f58b3aa752bc1cd8aaa27cb32a4f727fec310071d8e8fdef7877503ff54c40e5694e060b9ef215c987d7fb1a466de8bb303c3f0f98ff6661b09631c489f4c2a3c82f7000535bd311ee07d71dc67efe811f9153d80d22317fbd56e74de8f029fdbfe90f978b1967f5ac4ca15045a9d1bd333ee1179ce9fcb532a927b4d1c7412deb2490a524de8f87103ad25acb92c0fb01092367011b780e398bb39392aaaa3a25617d30e2fe0494a7d2a629d1d9d15ecf15b333939d1aabcfb46947210a969070cac95928c96a853001b038c1e017a18b4f55454251ab860f67c33e0fa874e8c483ba5deb1794c5ada35a810d45022d936206834c32fcc0f3d01e269365e1ce22bc95607717e095659b9f063a901fef7ea850477c2cf9d2b078d9b09d6dbbbf64859324fd0571e8e065543c615cafe32befeeb28088125291a9123150980c4ab1fae5fe60e39519513ac23005cb048b0a5416606230ef67cea74a9ecc4fdb1cc8356ecfadb2d5139769e325c6e4e9f95f1cbae4ab382e27c1d9fc9c453aad7b1842339445f7eb8cc2d76fa72622755acc604e5b4b357c9ef4e68de0f6151c396776bc01b2fb30725f8fd51a0a31732a8348b24badbd6694691b28764a8deb690f25f428f37f2bd0e1fc8ab4984f8f1723199dc354d40624416d71534c2643c318f3ae0896148d5084c934d660133f0e71e20a8e121404b3184fd0448349215d98c0115916f6e45dbb04f85aced3436cce8fe0269c56b8c8d311d70939acd1109852df4736041f66cde7dd47dd458572bd254580b9c04cfdd9fe5e47427772f0887547eb1f8a744f862cbe5d75e2a926d2e96526aa207414d416ec99dd37e5f31978e780749acf152e501d4faff94b9c296e3cac6e8c7dd9943dda38cd999e4e95f854eb6bafca83c074323fbe131b516f8c99cdadd96c1cc4960afbd8afaacc352acef11c3a25d3878305c33fe775edb6fb04b5071114bbb3f1b7316f8184332b0c79ddbb5c05f206cb2af8c2ebbe84ed2e57d0f38e7248a38e960edd583caa3ae08d630486b6194034c5ddc6eed8141450a051db83c2254f3f9d42b59a626fbe17ee3a02a041167dab10864736b8195b952e3738d44c3f50ced0a0552df68ef3ddb1b3c4bc6715652c194bb0d8bb9b70abd7ea0ac2ab5cac0b2ce87de472f0bfb5232006340a9bc541ed6fbd36f6d3d4f30127cea6d12a5db7dcf4d3a7c4f816974ab0193c0d47523dd1cd946fc58253eccd5149c5250a0d5e6df6f1a4b06e3152a2f93fe6656d284200fbac2bd632111cbcc103b05bbfe463a7600b7b939c82b01cca6a2d183f8831a47f271b0fbc8417ead5adc2315ebb63d40bec0da8fc15d8e8005d7dafac1af09d6fd77c60ba37d8d4ea48ad0a8b343d114467b460d223fef4e426f941e5687578ee5bc3b04de65977c77ae0baa4327eb8e5b4b8510d5506e9891ff0adebab13c7888c2a1514900acfdd8c83d5132b51affdfc1c136753e7882cbeb5eacf4b131d37da02ede0e2df2bd80a179c01ce80a07e0bbfaafb3df24a427fabc9e59c450703ec4d09abdb9e832e0c3a350f5ccc32592f987b58ce1f457e4385e8613b2cd671153f8c4530c466490458f9f3e7058d396e63ca114a867a5050dabff3e2a98049948f0cd8904228c89e1f85cdb78c7a4a36ba64b3d269a0c58c5f6cf62c4fd3fea338909e36d066186dd12ee39774009300eb9758fb3d12d9312ce35e0b7cfaae8081a1b5d004f7b5ad3af095b962196144662bdb07d2766253e29a72dea09f3216ebe1282d90b93e66870a8e20e5cdaa63517867ffa845fea1d213fbfcfd0f648f0bcf12c3b6e087c27faab322abd28f14206925ff520ac6c0627634957bbdc652865770b2b13abce495e7ec15a85b51557b16771232db85a1bd4ca54fae552ecd2de99922e06466f496c4ae82c09fb61e4bda07d6e939c6c32b7b743ba7102507d62546f06c89029330aea70fa9389a23d32704c44410d864b50ec79b77cb6efebc23209b0a517ef688eda4632dde50398dd779cf270d4b7254f128b27d7e099943db5c449ed2df3e9f2d582a4c0abe1b85cdc6896484368404efa3627930b43fb1085cb447506eb827d2e7672547498099f45621553297a379ab8bd374af3838dd7a2631ebc95a98b3d50b5895cad09cb90ede10907b0cc9658b3d24fb70debe806d281221b98194578e7f9eff5662fa08cfc8c15a6c2761c07be0eb3689002670c366d0b8c3a7a781f87da24dc064b7ac32b6570b04a4c05c9099fa6ffbc286faf1d8cad41b565b5592adf2fe3e79111ee1d51e86e9646c4a0756259ef4c285d657440236ddce38cc23f9ec9cdb59b56d6ad46c6206bdf7757b2eea36e4810dd5aeb064145181b98914ef8d06cd28823479a05a7b8d8bd8390d555491f840a4a6d73b22721b66902c96349dadb32a75ea44b72724b5edc8419f9b0552b5e7e79f5412d2286e639e4e5507cbb68abb0fd1fcbafc7849f2ed6ebcc1ec03cb9715516c9fa9b539c7d9368666d5684d0e1a0eb5998dccac99199eb606debb9506e8deac5231bf3b58b650f337c3b078e4320f5d3b3eb232bac761ff665727f1b40cc7995dc0f1def218cdb709980b0c07787356a3d0b02f19ed13b58b3cb06728897c4cedbf26035d732d3dcf2e116cc38719b5af0c9f255e3bcebb3a7f49c1170ba85a901b53a39338b222c8a585e3d3e4ca691eaf1ec7188e338607f26b9f09b20bbe46578114f9026d8812ee065edd0c9e5a2cc64f9b62577a40a34d9ef4ab00cad679fb4cadb316a27738b9dd75af96c4edf8dad9e23a2ede3297a8fe3f09f5bfd52c6f0118bd3a74e38cfa244bff4f1800ea373bde3fdf6205b73bce5ab6e6eb33f8ad819ac698adb2e4cb1180c8530bbf7783bef359d38df8fbd6253991787dd3aea1379c46fa32703b9820c5acc64861a61826ec6dafd1682fa3a9bd0d6079da16c607035dd0f7b4f9a259b197a360a3945dbc457300c1782ba4ba582844f838e7388eeed967e29e310ec4f6b031089257be495986a3c56d4834b20e6acd8f18d0809e8033ec58b3306c7659a7ebb56b0a6450cb2e37d79049f34bdb0deebb01afa1bca0460e938de1e991d988405eea9c5139d44947bb78fa79175123cc25b475eb740064cc4be0766bd03d08ee18f2626f324defd287f22489d50794f82b5e6b7196bb8190b8fa9c5b4ad4c5dcbea72431e1a20dd06d18c80fa27bb5556f1a8ed261aa77a2a226c62f1340bd1f6ed29df86783362045415370eab5f271c4152db4267b44eca3becd5f8d3363e373c00b8bcad1c65c5c4f9cce15cef11609e56ded6fb556bfce7046d35cd0d4a41cc1d8e490a28da23518a22724e2388d6403e3f1bc8f68b8db99454e8d307c2bb484d6632a46735c27c15ae4851a332391be8200a7960ec10fd8e15ccc57ebd19e628a4059e6d83c4060bbe2adccae850045874487bc3452ced6348495bcc63b77538d3424f3b831f54983ade8b340c5d9122695a234e9b44a5bf97185c28184089f8191daebc03fa544446c29cc6635f36936dc85f35720806fdf09057da87521cbbecc4ef9de6103da57ea051d1d1ff2dcff1d51be9fa8e6a30091021ca5dff8f63e05a5af0be5b5332205a2ef3660ba7e531b721f123c1a900340cc2fca8e8424420f22c5fdc0a1ec1ad622180b974de866d8e42cb3ea00c824b3549745bdb49fefb6892fe861d0afe20a4af4b8ef0156cef36cb4a0984cd94b777710b30fd523aef8af83c88acb41b0973ba7ef793f35dea0897b8870702a08bdeb57af1021122453bf0448108992499c02d1ef6f36c88ce21fdb89db03f6a8720ff56220d7b1c0b9a2d34f7f1debd123335a6f932bb18d0eee50ac1bf7db70faf7fb0286ebe4d8a51c6cf6da23e5548fcfa625bbb58c7cc1a5d110a922617fe1278650f01aad63119bf10d5275e7243b65b1acac7964c1fb7d7bf6375ddf677bd9163c478018becaf9656fc569a913ec51cbfe1fc7c32b2ac70e88a1728bcdebf646cd5f0e3c9288bac6c2569cdfe03f67046592b8be9caf07d3914f7c1295503a0b1421324bbab69e125b7a9e1eb1a141255e2bf62149827f08dda6e41207dcc831d3d65557f3629b64c4196a8106c9461a1acf188c151b7babed27167704c37915045dded149b365e3589374f575d65fae6613861fbc6139aec1e6309458950c9f3845dfb482e769f3ca0db0b257ec984304b9155e939102f6ab6ecb434fe6d7758b0a68a0f116de0c941bb6e6fb015cc08f7b49b35e87e1c18bad66984ec50dfb7452334d27ca09df3474cdeb04bf7a3ba58d11d16bd4a1c65270eacbc53766ad129306793b23e8d966011f02046ab5d163c5cc5e7bcd60de988e25122fe29a3515f0b511cffcedee8d205e8daa010ae730c061f456bd5f400c6c9f722fa44ec62ee62ec1f28862464858607d01d83f2fe6e1c71caf60dd795a4dddf25215f3b339d39a89fe872f9aeff343e2b116ade1b37e2c06288a9659d986eb8a76b6d01cd0f89d19f275dd12d98b859bcf56f36c84a8c421210f625eb6429611ae05674047b15e5c7bdfe967433fbd685b96de497b3f0371c7bf9eb355518b52bfd51bee755e2c85ea3104f4e5d557ffa465f12f2d07843526c9a21663c9ef79876e4b03f0538c72d83f817ee9940986d7809bb2e7c10cb7fbceae376d280c1b7f69f4fd337252fbe8a5599f75c60206ad3cf21ec844a4a52cb534cf60d0d6fa458674eff6d3cbd9066cedb4f394c797c62bb3c1c9a5d448c79e609e23804b66aff856ce87e0019b0711d369d990240ddf60ead5c4a41969e261e215747b95e96b6360f28ea04204d2054dfc929839668deac9bff63f290f66e4462f5f23da46ed759a2008352d0a76ef41e5990679cc1cd6bf3a82601401cc9afebc3437da716ef7b3a2edce6f26de2d93c79dfbc0bff7a33b75b2cec302cf155c68e0a3d5a3adb88f33e8b110eb22a2baeb4eeb6f22372bd3b95b89b3ddfa9d7f1014811d60542eef0cc25020a068cf6f3f9aa66e65a50b5d9d62983a90255caed5a5bcf8b4b2512eea9a3fdef0b99eae5b8aacaafeb932115bfd386de921d3b159673760f16b7f2d2499d9fedc703f993511d1be3106d4d70da2a69f5a28af75fa5352d9e34a4c919609539cb11d4eb9846c899c8169b4bc4655398fd98ce7f5899862480acd1788385731a254cd16542c4ca3a9c9fe022388f55f9ecc59c513346d58abbfcf3825b1a12f751200c671632d46ec6a631a08a7e9726a522a82652aaeba5fb09ad4485e0c3e1c9a2c828a0dbc060ef21369b4368318711aa8a740db68c0f524ba76a708cca40920f51e1ee84a1b8753cfb4ce0ace9bc1997e08fa2949abdcf7f8321603c4c6ccbb5b7e49369e967b3ff2d1a8f25c7959bfeae23ba783a614311b44dc556b6f9ef302626173c122f0a4355caf53a8f0c0b98976d4a3808464f45f222df72a1eb0aa4803ec7c1787965e146accce31f5e059deb8bf9ea776b63def4ae52a069097182dbe9a7826ee12692f3e55ba4a9d49ac19ac56d5112ca56f47a341e40f8e55c0d6956d7df8e3dee86a84b3bf1e89baffd480ea75cccdf3e79e6688f6ff49d62d9a0b12eb7cb22dd49893d54821b9d3286dfc617559b4f46f560603af85625833af2dd9389d3594d163b21769683c8b3ebcafbd8eb4951c599400af9be7f54031bcdcb5d0b22e3ecc30abebdbb6561ada39439b9ae78e89a99eeefad41d093d29043005141dd66b83587d15bd178aa465608e0016c25a0445d19f40b17c5fcdb3fafdadab5d7b19c7e49e6df4809034f3b830dd11c9331f691d5a8d6716e387258663906a97cf5fcc5bb4db5e61eb83db397981a8bb8ebf550efc024d5f77cdb47670a2a4a3494f4af0f3a32ea6554b724d151fa522ade5dfab59459fad9d546d02b2456aa98815991e8d1dda6df6161eb03172e3cae56981386667c5a48bd6fda52ce46c17919377506df9652e15104d0b03b00b976ce9303da4a67bd5f3ef5deb71b5eac0dd36ee76e6cea5e6a5cfff24402b0384492c0062b8094e5a4b92e6a07595e30b4b55f6c74cfeaf3795c14d9b72d7d381979621a83ddcbcdd6b74173f775a7675c8c2ac7c1f11b16f5950bb4b297016fee0ba0295d38c2510eb97149bc347afffc061576b29bce65e83b24ddfadeefd11bf849a665e5db2a464747c7fa5adc5ffa0ceb0acfc5c4783d67336f4651484fda15692808f410ac013e756c844ca8a6bdce6cd8ec0a958c07c4f6daaa2903f7ba1f2f4752f62979c4ff48d9dee130cb35c90044f8e36f25e0bed8c151319e64f707bdf77d796bed5b24632b65da4a110fd53b8aaf319b8a176bbf1689f79392f72ce2a68a16ecdde8b1aa61ebf061f27869e4b2bb5a8a16f350eea863ec3a6a949cb79eb1a0cb278b2aff69272758a2fd103ed78ceb13cbf8889d155653618871168ebba079d7a5cafe92adc91f8c5a416af09e86bbfdcd7077265724ff1bb1ef1ced7077a2fc1a30b84f53a8d3140de7acc8de091c3aac59d70141ad63f26b526e3454edb98bc023076e26f09d239a7a8c70ac2650e553ec57ad1daf26d64e3d0c2a69205d7d82d39aa4a3dc0e4d02d01e547fa4971f010b1ae29ba88c5481588116b7a41f1d14dd823da19a7af4806831e721f2af87ba59371ea8d35ebd6c73ab1ee995d130aa9e27bb3fefa4eaf456311997e87e7906d72fe6db28270f7d9b561309b78b0bcc5e571ac9fe2dcee1f7c7c5891b2d4f963cf0cabbefd8ffedc47d292b4f8e6ed2d8a5e2f98942f2cc848742f9115e615710f067fd62b45e77d1b3de58c23699cd5c752768096961472f9504465f5c2c286c512661d5332149277016542f74787dd6c810007e282cf364466887857a71b369d11bb7d33f8d2c7e0b1c04d5eef88ba87058eb3c112f0c331d0a7f3ba253eb007a03a05299bd9b89d9e192e53ae9581be1016b757ec176aa6a799e3370f6bd2ebe7fe18a7c288528fb3b57af88cdc70c17cbfd7776bfb9867393b152481e6d2497e3c7649245459af6ef70821fdf48b57765080345ab284e5a7bf763afe89de45b114d06dde741c7909b5ca731ba7079dc21a7dfcdd43f97e24d51e94fa27a2cfa5dd8254b75a478460e15320566cff95dcc84565f4681fb7add0ce1e2e9ffa5cb613529a10408c50d3d39d669e31264b81eb1f83293ffe32af12cc4a12ab1f47634d42d44c50f8288e341eac353a89b3fbc773ae76d22406704e50f16b70acdb85e4caf70711890418a2aaa13025703c25e876957553a637c515a9e1fed6647887fd4eb0ce5614ceb0b8855fd95bea49c072fe4a58df43631678634ffc2fce38a61f3a99cd8ddb08681e36dc0545146cccbeb0eb6f72c571dfa4f208773cb1ff00ee0852cf0ba6b7a1a8a97aa974a5a5dc48f8b08fd46ff754c32daa1cb69a703cc0076bb0b0de7e6baaffa4b0e027dea6ad3553c184397731a7e2bbfd2f5ba4f8df598640f90db4f4315f3ae4bc6e2a3fa416a26c96f36502594064d20664f16e1c1b68f6ab1c832ba1f97bbc908ff638527c912fc0c580b0dfdb72996e6029b8fea5c629429af9b7ea3a429a9a21797c20453419909","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
