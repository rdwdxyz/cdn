<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd17718d7aaa04d6aa819b9ee83de166f620b76e2cf3f78c915c95aa4ff5bc7982e3e32ffdeb1020f5ebef736c5de9ca299a06fe1392c9a5e943f0c6c01d49021f83157cb83dde390c62eb206e9bc1e5d6ca4edeea24304df302d99c61cc2a50f286c35a446af63da8fa38f7574bc5edc9c5107dda45f7f4f06cc1a55519b7e2b148cb20408e9745378bc8788549d5906f88433dda7cc38b6c2e31496f41a5f1ca7aaf3e2c1b5415d459254c84d4aa37b7fd3e273f2612f9da7bc64fd06301ec58d5e47a1e94e53712c032f1da48387e96310f6479de63436c324bb2aef3a3104a0427f8c9eb776059e52e40de1d1999cd5df0c38b46416a6ac73042368228f898f83e795cf48d8e6ba65d019b646d12c8cc0bf46d5c8a3d7cf1cdaa768d3f907c38c66660a49e5e16055c3cced9b07c21de659b0e0209121bb3cfe2946267971f735660fba8d67f95544c06577d18c4b84ebf2e18bec4393e0a27ee624f205f33b5d2b51262f8c8907353acf6a7715bbf9f1632c11b76c6885ab8764457a18e10db34f6a0187ed523b43444655ed60bedaad25e33424cd20cab3b6f5f72ce1cd83a148db15df96a1a3bd2787db17076c3e2c87104a3d6cbdf33725137699f9a71f4161bca81f3a242ddcc1506f31464d32814b2e5adaca1c90406a70dc6174ca0c4c761ca778e3f9faaf94ef3d87404ecde510320af9981326dd0973cf8dd48b6530e07d7fd083d1a8be6646a3bd2fff46ba35fd0e69da89cc56e7bb3b14de008be235ecabb2733060158a3ad11f7161f5ac3496d212ba4aa5eedafe9a4bffba7f6a596110307e64b0ab66ef834437595258e45858b6b13566deb6cb670f604856c3b886e9a6287399231a7a00dd1c139c1a0b5d9d674a267bca5b122aa4797d9935289ccb0e80b70672ae22916b5c7a30dea8eb565b514cc4103ed83b4af813125ca69fd412e83c2fdfc292700cf13706a8548879e318d399033f9e9b71a633830991332e89452163af9e1927781255360e802079c1542a507c3042a989ccfc65f4016c78f9f4c9d10b9730bd6b14f695bfda577f5e934b3988da559dc18b033e0dc10b8f6e753faa6dff2b07e24ddd515ba2b37831de35e6b10c05401583b0b827fb52fbdf36807ba0cf4ac317b445eaf7543639172dab38deb600297edc1b7aac6d43b71c860c528d8c703b2a3da63c15d9294d0343e376b63bdcb39076dd3058c4170e298ec117b684950f816aea16e04b753affafd14e0abb9f7fe583c66ac6866af2141f9b9c850758714297ee899f7a2192709c823e7ae03fd4a52525b37f0275c8e0ae5bb8c8688af1cc0490f54e163419bbce37a1de3410bca18f29761b43db2dc6f9d6d9f1a4d2fea9208fafdc455fed0a65705f964606f1ed4ca5ada24bbe075f66b0a5e68e17154d09f6768a16ee538fdf648a3402bbbc638c1788255183b2bc10cf40a8af1b05536396026a67ea49080c9cad7301e77b36a74e2770f781251b8c9fef1abe71584075056ef7d22a1c3d7f8b7aaad6fafcd63a937246953f7b059a378c7f316656055d203870c578abc58d308b88d8feb96796290834786560903fadbd385ded39596be0266a746afbcd954dfc9788c345a9f5fd46aecbf0b5d01fd99ddc48abbf5eca826984d3475c8a9711bf97b9513dc4773a40d8a88444784afaf215a73cefda6068fd556da03fa1a764c14aa2c294a9c276224472f8f0a8929efbfdd85e04aab0ca014177a27486e156a08e5f69baf395323030e59d6ab004cfc8af86b4c404b2399f0aae85eaab20386d28e26154b17eeab4817acbce66f1d27b20ecc2a7278d79ea456197084979339eb899e05b49ce9d792a09e4c4c68cc9e212ea060d173937d45ce95404277b0a7bf26894a276d76a3772b47d852a49cb3ecb7cfc8f9143b134102ee4abf0e190bf4fcce9a7cf7a0374d378ec4e998799a25dbb3c0af366ced0757009f8d8a4f97c211ef63bd7adadba34c03c9c866153f6f591f83a6ed68f71ed963764dad3b8bd0a2ca0d0a5e4c08aff1a4c39e6b2de4de87779963622f96c4a43248b77bcd4e96273bf100c8c03a7c21571d38cc76d3f6e15e23b05a3a72a1198397349a8dca869ae02247c1e44286f2f4b5697b4265ac1cb80d35de9416d3ecd38ada2e36a8738336fd55682691742bd72dc32e1ea71970f59d66a4d876b82cad70831461a95abedef4eae2a9c25df11833e0222abf2e3ae1313f666baacb810a75ca5a6f9fbfca783f0d17bbb70d37a943c1518afb5c5f01950d824ae5754aaf0f709e48686ec458eef5878e3e4fd59753f751f1a67ac24b6ea60449e16e0131a561323014cae31fb872a439547747f8ed0d52c5d69ee4022c636d326e34fb109206cc998b9a0e06adead6d3a3c0a44c0f57540e6552504616bfd99be01c3c432dfa88aacec196dc2559222c78f276d69c3fa878bb2cb0458114979f8e34aea7c88b54f4a499f9f707dc7aa6c3cecd5db537b8c9f9f038aac0eb8e0cd8e52aa72c84e33c20330c01cbf6408934a05ff893df433e36c8482b19a09b0d5f74d32b7a4e4ce7a6f476e8e72cd11f57a44ca28bb04de3bc19405b163f35559a1f9c25c8078c3d9c8344885d6e1c17f407c76c35192039b26c02e2125a001f30a69146ad3e053bdfa846ec0bb7be6f2126d69a3ce8fbb0420ecd24c929fb5749f81766384a1c25f00883bafd955ba37dbc8914dfbdead46140ab35550bcec813f7dfcc7905c6ef443bb0795bb4ab44111ba02658f3875f588926a62cb4f3af75864975a883213c70021488c32967eaab3c62e80976ddcd1aabcb5840f1eabff49dc229d0468837b21f6743a666834f2c3eb4949027b62909d131619e7ff72d52167c35126bab806453da02a9cb34235201abf0e2502a216d78c6885384495544b8c119b6f058b322d10c413d4378b93eabad2b44ef97a0bff19247a53a0c3e3644a10fa76de2d7d4266a9b30ef2bc164f42f663224761e19adffeb8bc12307339a3e1512b1432d5a8ed70f156769ca7538ceff684eb5329678e374796a6a5e5f83ef03d07c9c35bb556632d44f40644581e6aa13b08e0a72d04da84bc8b5200f0a27aef375bc6798d785cc0d4fbd709832155194e2b1e0d3eb50d305272723ee4da8a6a393987f953f3c03fb2bfc8f2226a9234d11d4f7b3f737f16093a77afac1764bea01ce83a6694745f4ad068179c29ea0c507e93ca287b8ee1b30611c2299c3a06ec966a87cba0f7773dc82f875939a6acb6a002328e5f97cdc22d1f1b8202937bfd117ebc5cdb28a53aa41a75e61611dca4f443bd4161f2e825bc3a50e031f34c561a3a29abb2ea23cf75e8a22da654ec8ebea61fc43447ecadfe5643db8198cb8021457e04367b177db6e24dae2c640da865f870de9f7bdcfff1278ab3cdd6ac3184173956682f7d405ab20ad1b42861046f0fd282eacb3e857580bebfce2d8dd17492eeee6c503b4c94fd00b971a3f4266d621193d069c927f9007d025975310bf77de11e2ae5ac865e2868410f8c03b7d5e615c8350f34563439c9990398f518cef4f2b410151018964888d6ed763019cafbccccf082ce32206c706965fc0d6f38df54de8001875c49d1d943b0ddedba4b3579e955f7fd5eab6c6c82a796b277eb3cdc7b5df9cdaf6f131bef2036d22b09527a769dbd9d75ad6ede370bc5a8c9bc3029ed435a98f0153c1d59766be9ca8d783e08db9ae4b72a649947fcbcd9747faaa69550f9510c2633a52c1735a27ae642c381b64d2e818ce9ab375bf2d31cbcd0586b6a1b8eaeea4aaf750b090c0bf740854e7a957ba66ddb6be9b7b9a09a874128d757f4109591aad09512c7819c8473f4e863a8407378ba2f37984f349dc3b261e6251228485e84488cf594aa82e175ad99dcf4a0dc93aa5f6a3f0197942ce8092172123dac28182ba682da20784bd9a58f7293bf01fa4324dd7070148a1e64fc693ad0985436b67b788fd6fb7d1c3a2b86e922b2b53623b7efdb4605464a0786aad3599316ad54e9cb3891f74391136a84024eebed80b098a170726eb6e83d169b97deb0ddab4e60c15bcc87cb27be5383549249462745e3d42960a3f1e19d048736034421685c792df9ebfca147c0a1aa2ff96e4435dd0ee5b098dde9f9cb2a9e32986a77e6b72d63b17a31633dd5d6835f0a91e032f851232f8664ad32856de90ea97826307d9a1b3b5723f938228a339b1349e688ef0ecb908794beea23360776f488d0ca7d291c633d837d46842ddc08b6d09b56a7fdddf6e4f946bd422936d3c16f5c70b9f710a873a983b848e686d6d6d6e1fa3bb5ecd4ce6eb6e5787d22f7d0d90a4ccbb7ca077fdecfc514e500348f6df4cd9b84de100637e15c0be1ff6afef0e3280057192c07fb397e98f492dd39fdf0d23f6a6d00f8dcb032b2605e9452b72ac0a051f777ddb6c5940479ec1747ce70acea186df1fc2578beaf60bb42b619a18a83e4a29054791ba9b0f4a5c14bf6ec33a2d606ea477e137a073f684fd325267984408dcfb08152ff5c21dc2b157429970950202f9af98558667d6ca63a4197a859a82331d7332487a4f3f6bb7558548d67299ea1be05a85365e706140100fd99e10efdaf5fd721be8ea39a29d18dc9387315f090fde7fdb199fbaf098b156551dd60597dd3fc9269836d52a38c2274dbc549c1e1efcd511c87b078090097711eefe01b13002b6044b13c4c0a8422aa9a8dde542102b8b259b7263f8209e2b803f273eb01255e340980de12c22a29b86f9e75d2b6fea6787a9d4bbb0931ba11b98deec8ee9593f390c94083f51291ca0bcfcd773f4941146cdb18e8805ac53a7e84f26f7144ebbef3b3c6ec0d2e09f22fc46c013e84196e91a6874a40c75166f82557c0fe6b534870d0836b167dd3421c8e7da8f5a055268c14a3fe9f552289a436ffd8dc2b89800c2d73123d38908a83cb97194e15376dcf6ab2da382ffdb9c32a3daf490ecc4260c63515db5b7bef4295df026e5f9bc3555fd0523abfab53c50ba727574645a36ea3c04e35315b1291403b48346debf9b5c7134d731cf5f882b128008aa87fc57766e5507da02dd871dbd9747d92a3900a263383c973490785952451dfa98e4b48346d1fe75f7fa192734ece80025e2529920c647b4dd781cc4a1b6fd67e0e87a5f5b43a6046446ee6a2b68b89a856350f9af46ff4b58a8124783c4e8a71d482234f93aad6dbb4a42e05d59a48bdd442b79d59d9af51cd3b8e48ca9af844fa2d8516d6295314aa87b8d575766b869b1f33ad13e40dd18d6f763553d49876fb0c0a9d25116bcba5b2866eaefff9995c45c6123c019c36e542c5cf9b57c6f2ca930a6663e9eb59b0a9e8640364ccd5005abc3cf46d7d353555fbbf9be15b176bf36169d4456b01628320fe7f8f032e416633a0105d7e0f6d1741afb84e3ee863acc34dd298cf76054e8a0483d42070227f740dfa200385088a6b321e1c11e01bdbc9b2d042a39d58ba0ebff70781c045cf414695cbc3a6d047c919c759460a79a423e12afb041fd682fe6c7ae59fbb6c6ddfdbf417db1aaaa52b97ceb2e177d06ede9dd9f7b57d560e3b61c96f6951f4cadb0fec8e8fcd5082624402561459bdd920d2165421b50bdd0a30c4f1b3cd73945085040cd4583aa26b7b4f87606c167092fa7888074a81a2e8a620da0afa506ceb8e40eb0f9b04af749aeccad59c6df0ee0629bcf1d23cf00a6735984f72aed9636da226d42bbdce5ad95c65d87ce7999b86725f1c2fd7d8444f11afc1558b742702e1b82cf7c11ab665257bd0f280cf9aea5b9b277cb9c8135a5ea08dfa94bb153668087c45b15dbfb3b5ac784e6b2ad10ad20f986ea2ab345814d7872469d395ccff1ef1000fc4784af2eb27c5d4b96350c0afaccd4bd73833702ef29a8f52f5c9c081f7faa0d1e540520865727f4ad7da4fdaf214c1d461b705bf5fc8e04cf9f8a2e988eb618a97b87c1d98886bc851609a017c318000cfc6b44450e1154f69f105c23de15514f3f075a77844d98142ce86ca456e73dd98056f64e36fa02faa0daa971038a1708149576544fd9b2a610639a7ad11e95b328d80db4623311e8a38ca5c3e90ffa9898d09fe9058e3cba5d4d4757dbb099a2aebf01cef519bee328968131a80c876a939cdf7c2f04bf5f1b622dfcd6dcb4a7bbf5f0addff245eb50bcaf254a54c5c250fc8adb58fae4fe82787a63d1035bd8e949f5766a7cc42942bb00b7f4214ea68879e170897026a4650402dd8eb5a44e714de8853ff3442ae57526e65d47f1cf8d5f9f5dbf3a12edadbd0cdea3a8df70573831911ff341f12c8b8e8eed57fa947a234f8da1c6b0039f04614638295da6bffaeaf0c2c957e0e9b5e66df25e82d38f041654a6ab2be961770e103ed8f505f65e26b3a669355e851e8638f4f2230e640ae3107b0fb68129abb0a99b79e5826b0947ca4d3700199907f65ee211bc8ad49e7ab4347e4643a94cfa919b3f70a774995f07a93d585c8a2049c0cabec707eae3cf99d7ee3b9b2a62be9029036a9946c1d2407651458030b6ad47748689d72633a0040a1f8d7f1f834f88faa519bfd14d4c4ccfb1b6017c346fd842b208b872a75c77833a9e9faf44db8af03665cfca486f9395bd0eae1c400701196793888b6f4d8fa6faf78893f7f6905c4fee967ec57fbcc44e17e7648afb65f78765baaedf493b5ea933db989a5a1e85cca9aa9928f340e5365b72368f08a660fdc53120e0a10231b9a250505bccd80dd710b39d2af6bf99abd6cdbe604fc796b4387b09083777c1c679d7abc4764b73324d112653e8cda106f14836a597cfd12e9b3203d5e90125754fbf8452bfb19fbd3655d8aa1ef71990a65197135c5345705f076319fbf6eb9aea0597cc0584563a502aef4cba9e9697b9bd3b0279f8ebb344028c6a13b1bc904b19c88c149d4c469e081f9b4defab328a6a25840ad7151f79692ceed33f0a10969d4c76a2634d442af35cef653eaa9209463ea0401ad10c63346a1b6583d08783c0261bbda4d5812fc5bbfce36216606bf6a3c3545472f4c250f5ccdea74a7c36efc705f623f2b1b6e6eed38f327783e32eed775dc03fd3d73212f1c193cee1695f669a2b1958a7f3726b7a4a5c948a2ccaed78e7275b277a89fa6cbebccbbdad1a33133b7082d89f639e7468b82566b95943f9d328427934403e3b37a30770e8d91a95dc3b113b36cc216c30db628ea32337d449d6d0a59294962f6bad95bfdbcf9f977833d270b91993ac29417feb25e2ce4e1c6261909f4ee7b2656c2f22aa45825eebcd986c4d333a68f89f604a5d55cd9d141bc2a09760da699445f1fa5f376f3e852ee6fa5311f89b10bada62e05ef7ad819e8310468c8e8f8760c12137a88b858ebee6cda4cd97b1196d1eed74e63448b328e1fc1366aaee828536145f0eddbe6558bf0b6174e3658d6192746f7c4ad7b754bec7ef86dff6c4a9b70fa365962b9d09afa9c434da399ef9ff6379ab76f165fd7e12676c8284bc243e6f42513e4478fb74754fe2dfb20595e1953a62a38ab2db7f449e38cdf5752466d6973015804340b4eb335d1e2647466c0ed2f55a2b16622090dbc7ef4d3d196694510684646dfee6969b436c096c4a88bdcd49d5f3e2d147825870c854ba516e3769f2f293d1b2e9d208fa313a4d8929a3bc016023fbe8cef281a9d3ea751b7cfdaca59adc6751820916afbd475c297c72b19cfbe3bfbb153d9d44a3850a0ee8650a5cfc788426afe6a03a033a580b3e532c5869fc7262d3c1a3fb4974108f47668a559135602fa97ff8b6a793c04e656ceee97d2dac7f7598cfae4634e16c1cd395c69a53b3afe585e416247386945275d5cd87b4e32573a888c9be72ae8bbf23591e7da5355ed76d9b4a52013ed860a63a5020d9292f58cf315ad69d0d0e3a175f35fcae2e1e3f9054afd2cf8555116cb584194d38b67dcfecfb839c36ddaf31029215b0f79da445e0b7b306a90f47ff9ead0722a9251bb202610e2c58bc00af946456143ae2dcd736e8ac635726c800ce7be33053f17a2a37bd6d4c37f4d42565317bf09f014badb6bc53dce3c65913c2834ae589bf7157c30ca3b3e22f65be2cac60db98337d93c5208a2c7dd8ffd5529fe65320084238fa864b2fd2d662df3d39b446cda62f0a65a0fe0657baa5d66862827c25f1a7581103e5bc475980daa1b59b5737048c6863fa4c3142cc1492a868efbc4a6ef2fb467766479caed9dcded4c5da5a6aff1b6609773f7b9a7fa9627e647bc58ba8661bcbb331268138935720f0ee3e76c2be39f83e81d4a62cde74d219d0487adf70520844818c6c25989bbf3128f5f329ee35703b030bd265a77f146abdab2d901da91fb420e2af04d389ef2dab59cd5004a0a248da7e029f5fb50e945d5d8f0933808cd13248cd0a02a88dd45e368627bd822701230950cceea52fcd6fa21c07d381352df9b5feb6f008bcac6bb9f470482984e95ab028d7c275c1118728381db132ebb70e8ea4d2cee973fa4643358e840128e0e2cb39bf6b15d05979d87a29d7c1c042180ddc73dfcc8c84958c14e0a9ef0f041480a0ad11f7e62f9c14d79f337913ae032dccbfc6966a273d7444d27809f825df9ba46bdb89429ddef135ba7e62377c19fe8b136866c6474d377aa21f4931fec6463726fd9b3b15989ec31f21b5b949a3d9f2361fe600b3f398de8f6d982ed760e07aaab7d1dd8e9ccb91972c2b1ac6427658712f5e92395d253c121ee64c6c4799bfc93e8ea79416eedd3996916452d880c9ff4c10b23d01ba6522dc383f84cd3359714776c35019cebb875ac57f41367f4cf40b5b138c8c60820f43dca941cfc271cff75ea92896ca32dcc7962df82797b8460d8bdde43c78d77412a15caa6bb704d305bbc3f51eec4b68dd4a5242902cc340c64f8a218fb3fa5b3a6310f8931a70dbb1d84ed38d01465fa4023b731aa18be94a2d39f3f7490d10dcf34dd8e82519827300152b0da975e3816ab1ef4e9c1515e92b779f86eb7bd32c23b29438619cf66cf94a38cc13f7366ea841afd8c5a5737c31fd89f4a99e304d6c2a8a65fb0fcf5c7e78e2e177202d4e2b5a9d6372fdd68c5113f9c91e663c382fdefc6237cdf3941f527a2b43e9217dcb88756275c43b71c1b37bdc0d5c7b4b8959d1a94349c26d2c315a59318204b1fead6e6e6a4121819ad7672371dd6c12cf9eee4b029552078168d88fd879548c741b19aeec64f279a136a7dbd3dcabf82bd61d5b827fd86b5afa418cbbe884cb60e040621cab88034bb9597ed341365364d50ff9149eb1f254dd9056ff3c89ff433303c43b93bc4a8ed8183ce37ddf099999e0b35fdcd2efec8b1f797984b876c603cbc83ea76051cf7498bfb44fd0ab77cc32dd173ddb1ac68239d994a764be26046a01776955863abcd45a5ff0b683e7e169067d5aecf77de1af8f02bb399367a248e7ab83893339b6e099aa33631ba2ea1e33d499778a30892d3ce8d39e0cdce26dd8aa6196c04df3ccfe15a31fc0758e783dc61b0d8b9b6a6bae95b4bcc18e8f22dfacd988a30a0a91712f18ffc724853bdbe68fdd0216a2f8e85f086da7ba546344b2fc3938149eb58e52c370b2f7a4df9597ce953f2945077567961a19dd787de561f0458a42a2d4b30039253ec7dce507de0e7356d401cb1592da8c1b2a96095f749526482ba4c601bea82a2df93668535dd1c9b6cd5479e633da59d7bdc9bb80dde15c36b3cd8b24ef1719a23f214d285c6ccbb1d4d7664666bb9b3fc55d3aab7d526a4787455c0a1d90c8c8a13d6c2406680dd489cf420ce5bb57f3cb02e832a6236422517e442b20ff79900444c713c6b0f546507b31a291fac66b2ba7b415fbde270fd2750eab4b16f0f6f9c873fc975450bc04a8d8150f4d33a78f3a53b7e82d3223c6a62d34a7d5de81e2a3092daa0b78fcbfff5359d42dcbbe0be7bf95e810dfb2c427e89aaa853015572e6c3887370325a90c442bc5f3344a236383771228c2b858cc616974f56df1df85f16fa2b923d29f07c3a1819f9d6e4bcc7d9fa776ae2c6aaa64286cc2f6f3354b04ada878175b8aea058bd72517e1f454fd3523f5c3194649936d0d2ce6890ac70fba3d9820ecb1b1eb46650f14836d8cd5f2a758a80fa55aa5d7898dd61e2ef20ce28582e89ce73c5e6b501c0bf32b6a3f212322ee964ee8ef0d6b3537a5ddc1fc26e1e613dff195219e9a46f246217234f48f9605ecf77b26ffe2bf3437d8f894068bfb47a9c19fb1bec4fb12a16c01aa209fffe06b0e02cfa625402ca78fc07543b605ddc33ddb419eb696246dcddc017e95072ab484ff9cbc303bb37d0346e38bf003288fd681a12f5d1ca235fa6689059473ed417685a883663274185da602d47a3a944f2ba503a2d657f6b0c744ca78baeae3741feb5a8e090bd1de8a13023d961a2e46d841e2b3c5f99d6c179277aac6ed55807c01cfb72a655cf2ce7f98eacac9f3410e803fb77cef6e4bf3e25c2f02dcbdd74e16d8250fd7cb6b96f0aa46271c7d2652d843f1722e3a2cfb28024e4377bcaa1c2c437c1e3251b88bb65a8813c4d44d11d51ffaf8c0f694cca740630c24c0bb2e9b7c3ff5a0bdf6dd646a02cf89f71363b8f470a865a80ab196b49d362d39867cb23e6be1683997beae55e1ae21a676fa6e66fffc255544b9a91aa9a54856b9a9335be06d9cdc6a32b2f5a9da1abe69908fba955a7bd9cfc29d36a91ae19b323060f0cbe8cfe9d9d1bea41009b071200fa36de5fc771eee34b66d541222161e88a27e2b9695dab2d505fd92fe055c92ca819fdee0141c779579a9d6e7d7f243319c559511b4e670e1295e9a6c49785b84610e890876899f9b9f9a1cd1d1f5169c3cb8addf9e0218c9421299aa39b69f3ef477f556931cbf32a22f48fbf309520cb782a5388ea63cefef11568fbe65ddec5a577a744e33579e477ffde9509470ed10d5c32a958b80d7295b4a95878d2f03cdedabed3c632ca4ff3e25ac7ed09cf897e923f5d32e74511395538d556ac91515299f47bd94db918dcba4dd659558cc3570cc4b41a041e5fba52b511ecc669315d58f3924bb49186c42aec7584635ef2f0477cfeb1f7fb537289c3341c2eb7f26392d66a750ffef4efa4c0b77a0fde5b95dca9b1f7562b4b360db7fc9949c9c4c7b7de402adc3e6fa193bd5bf0f9850641533b3b579a99b0002c99d24d4050772ad3f61530d32c7e2c7abd2ca2924797784951027370891916faa0778cab3750db555074d652e77aab1a2a4051e7d044179131d489f4897fbdfc91f1bb0e7a3aa5454c6f6b1a5822e4eff96ec37bb52eb1cb396c28d8b3b3b9f8ef1d28cbeefe99f82f2e10627f3dbb0222995c04504e51eb35bf8bf60157c6d6996db17e4585d9ebbc2dd7913e1a06f6a43780141d76e4c7c23b34107ce9a83ddc8b05514ff699baa65e292ff6692b2b4daa3852f952ce3d92095cc4842640863e43b3174bec04c4811a060e630f57d8e8c769647fbb787bb1cc99c376f89183bf760c25467f9edddec3c8551400dbbd2a85b5a35ceff6d82df438c51e86268cf780b27193e2c637d625dddd4daedbc7aa44901755162eff7b61d028b65b1983740e37a3811f710541780aab77643f3e95dc369fa520f30432c0b6f7044cc126dc3997f38159fd5a16f60d3fc047594aebfbdbabb938a05e410d20e4ac5bb21e4b012b7b108b5b5e447d5a752b3e460f998aee0b7e27baf8becf329031ccab0ae1dfca861144200014d09ea719347abbe25ccb6de49f0a0e479f5852819917ec0f493f56dde1089494508832a58ee4a1f28cbeb6f7ed48890c667fec567c1091b4dbd3eb604d6cb5daf336abec7c3e531e9d8edb51b4551057f96c5889f8171d1d67736c690ec559490c76c3f077d121f839203f7bc5e350934ef9272314803178107a99f229860c0c697fb1c0205ceae829cd0251718dec268391c21b13385934033e8065c29ed2946fa4ffd53263c2be849b0bd05a476ef06d0021c270b61b8929740a561191cee25d01a3808886dee3a7be267c63328aca38515dc3ffd5ac361155e12560fe6556f9af362ad68555817e51d6ecf407fefe4c394efd4366652ada0823f2e4068aa66e8084839642ea5b843950deebf7618d573030c4a8d805ea1a310c506a3fe9dd265874e3fd8cc14598dbbac69b5f814ad943f04d4ac45135278346e040493483886272e29850729ccf18b6cdb5c2338a21f9306dcf152cc08821dad372fd2993b958ffe79ca2be5e6ce384e62bbf7ccfb86fc0eac0751c2946dc7705077b55663ab1378a82c992fdeab4d3e96dfaa05a7b23a883003ae1117063d8855e232bfea21acf8ddc3bb1d320d73b55a59adb153793a57e6d8e0f71093af690063571eef78d752e1d1c030660392766d768a0ddcfb8ec2c9c713881b40f6357fe0a7b929f2ee0d3cfc9cfd906ebd749ac01f28f85e9b3715c1178c40c86bda656a0fc79fa5a80f4252fd44963b7d695fa537cb50e44105aacb52221ebc25a70624dd618b0861154d48a09aad28349cddda5bc245793cfc5fc4138ceae2d66bd1288ee011443be9da3a2d30d2a725c08e26b38291c6c1a0b6ab014563015373cc1ba9bd1c452b0903327d96b3928d1acd9d6fe2652ba772e80e17f3b357ab66c9dd4ba6a49b31cd115cd2b9c9987f437b8f2e39438b962bbe74913cb9f36c92412300f2dd7788c65390018b33b4cc79ee84b96f655d0db35a2b3cf0f655b695265623e5ef129a486959a13253fdf66d8e090d42d8e244d1a6a37dc2c602d8b3655d0a89006eab64ddef0e353dd78c0e0c7900473af8efb13b0577b016b5075390d9fd165f6232d45107e5dd2486c71b40b354daaf5d296dba35973db247e5c3c26cb3863ec61d859fa706d446e87658ea92a2eee10651abf85c10247cf0f24da34ea959d6a0debca429816e84ad2eafce496e65946a64271995a5d4f619e509cf3313bdcad6c7607951c70a07b91298a8aa556658e8a0f8bd4262fb469005506d915039af1f18ea88d4c4e8351bd90bf7111f1cf300971ae257a3341e5e361b8e29614cb6e282a43f249ccf167905b88390c224ee381ad1da5f19de5568af9ec0a59452acc81b16c554fe16893660d831a878dbe49dd44f0555759af825998c340488020462b37c28df98c6599e34236bdd5b1933c70024e832bd24817331fcb50a4ebb6406b43e50516b7cbe16f027cb6799070da349760d04ac84708126d6d4db29d260537082bd3cc47b4059029ed2106c6c7312c66124ffd3cbec28a31dc42ff93b6fcdaf7dd3c980d8a2ffef086e6907c3b4aa071e0acd68934a0fcd8453afc0063cb4211259145c2c97f632cc26cd4e1b0e02e876b464e99677e3d1c6309cbe21f2ab0c500a2a2b1f64f1bb0b5cad7d30c705ce2b21fbf3009dc5749cc0e119623e7f48ac7685e1a23a0c62edc57699b788d98047c04d2caacbc99ded3f1e597c71e0aecb5ec2b4d444c379e37f9c3b5e4f451ab5c77b7b9342d66d0e88ded9e20a226803b719664373e92da461f083539fb9ba5becb508bf9de2b004c4383ae55fb3c83caa3af6e532f991468a8a3818815f4e1e8078f12667502b2342ec418970ef529377f3ded6430c88172d2a5cf53388939ffdccce842588a95092b7a2a166c65af6133451b9023ff25d62b83b14e91560576f4e9a963c56436397265f1bf7a12456bc3abb06250895555f4a8d09a0c6c0f1941a7c2d2518b3568f7b4ebf80658d82998e378dfbbece116ee063aefffa534f3a23010dd650817e56d4f1afa141c3208ff8c5b3fef3b079337037732cf4f127dbe195290f11115fa139df52fb48773755d3657b5e636bacb7b4859be918d22f6b2f38614108b98bfc62527138c7a329c2e71310e922797c6cb26eb1fd864bf0c71c7d1025ad45269e2c1169fc389ff1536d4367a2a460fa11685b6b586cc3b9ea526623555115259a906449ec15f4772e075f77869e4dac4c431acac2e0489881ede44df821023c0f9c1edc1f5364869e1fe900affe46803acf9e8d6f86b38704a6f46aca37bc149374083ee4b94dd1ce4c1dd7b13421d0faffc886f5f1ca11a46d39223109b31fce0494742ca62ae136d96615fe3b8bf320d6bd8ff3062a9dadde4a0745d19b8ec4417f967fa93266f06e646d7d9b8cd82f692dd0014078cfa483976a9f008baee156f45814df27d6abe004e714b10f66d2f8fd0c913290fc17d6d311798c099d699c9bb0acd173c22008add3d3478190d457b6b83c353673d5645accfd07a370b31723e25b496e3f8290f7302ab6fb4ac40a92f64f2302e331e42b27dfbd26e397cdd7fa7ac8be8f0471d46690d571da2172b83e021089b0f8818343e5f79d013d239df3e07ca35d6eb6fd12e8e02aa1f7bd6e6e99351db9f6ea7ad20732bd8db16b3522a9f9d196ca157630fb0afe97c824dc827e907c46561c9718d72e85ca88806c1787e2c850289636635a1a34fcd320f41a05c62e8dc469d1d1fb9ebcf6b4e1f24f1e42c4efd39741498b78486a643ecdc6e2a1430d9b33ee9b3c55c95ead46fdd2c6457d0e017024d9ef046e4aae3cb947439962d4540c46bf9a84f6aa7640ade7ccba81f006713a695b6130f1f96f41951810f80a032bcc2a12b8e2a8f9735697482414bfcf55324503be8c253a6ca3aa2cf718de50fea25dca64679ec33fef005cd27b21455b36e15adc11ce7ae99bdc8cbe6577198fac106aeb28f07e3cfbf6080a30d98fc9c8d8be7c6aae36d5b9c399a789c411b2946a63da4899a3494e420439a1adc84ad1ab2ec8d4e6ae977d5ba3331b10101eea764e06f88db657ebf6286048c96be16ecfed334daba91fd0ffe6de0d0b5ab506b3fb9064f4ec6801e216a6a66358cec26d900783eb8daf3faeb61886aa0d35853a64c811c32b509ab4c1738656989ad6f01e9b99b4cf93f903fd212bc630cc0b1ce69b482f70948f25767550a717a344f568f4071aac89ee9d72b7cc648018431e40a34934fc3162093a2c17ca37b43774806254aad0c007b5bcf5ed0a11a635d0082a1dc98bbe86507d78360b156e47100d6d820257b8f889599f98be46ea7ab3f2a81399e703099469fd68b57b4478185e5bf3c491683532306f8121eaa6cc0e2873f03a426ad0af4a0bca67b9c271228383985e4591a4b1cf441b3bc11d2caec205663e93da0db4fa0be20ca9c95fadf0e07b6f64601c0e7e0042eb330dacadf980236bbdeb688ebb19ab8e672858b5428a0df7bb7fd87d48124036d477efbeca17513dda5c22475eb07c77512b45b9a5a9953a9171ede930a57196e3bdc9f8ce13f9168c4c1122dc919fb0affb7d598759ef54685cd9fa8edffcd63b4f6e96510bd91f536782cc6dd665a5f1ce1bb49368a7af412d5705b49f8734f4ddddee438d16bf89498672edd94232fb0db94cd161b63defe603a68815ffa05b3289bbc7609beddaf6c94c32b66dbb2a8b42128c7a1e1dda643754c9318861db2c1a453efb62ce349b0d95115b33a1f66791278d7a14f712d42e5b279e1defa50d50e0f49356168772c545d32da6ec18f40d0fdc564be02d7cc14abcd6bac8ec68bc0959431f13069c54acac278b04b6ecddc4b121ed65e3c09dc0e3a4b69924fd3a04b33749c209dfcdf92e364c940308706a75f00ed015132c9e6d593513c67a9817f8e6affd2e9969035846143650304f5fefe62042b94e220c870a7f0f27a90bc23079a3029e4b2f2cf104fa1f2401e1561ca15d08be28d6fcc18b9972aa5ee130ca4f2393650c2b0bc2d9e2af039b3119a88304b00029aaeacf045798063dde2701ab753c12cd717068b603211ce07e012308b7925687126c6452c876e7664f42b80db706fe62c3fe1c790a20b5147323a5ec348999d374a168689ef39fd57652f1eac2bd3551818e7a79435b3fd389314ad9164db88dbcd4355f14737ce2e4dbc389bb376ae86226ea42ddbebc8b5400ed6460d0746c8c196cae0436ba0c8aa03296b582ce4395bb1b5b695c3e544de9a22a7afebd40fa799a51aef3da87ec96141bf24508d888c4c0ae77f01ecada842d5812b23be73700587e0ab52cba22717644e34a7c57382d5051a41d8028fc3bcc1c8b6aac6a93342e38ad59428baadef669a3edc33ea9a04feffbc14284395286eadf159d3711e6913caff3f9433b928a129ba2992a9ae0a206969372428cb50ad4d68db4b3bb0fb57e1cb9e28f171fceb0869b6bdaca559dd50ee0511a81c9f4e8516527fb1a61e9fa7b9ece945c3cbd277bd431fb3ce012bcb3caac252f33ed7c926be6e837621523cf1a3ebba409a3d2d43af774af8f292e133c2a25357e4ff0f0f01187baa8a14cbd22121788e71f3994c25d5af0770645052c5af4f586d1a66d70e9827a8a57854017b50936d109dbd3ec257e6b1f665f830c34d3cb539d8e2771796491c6d7b508927a9abd6facc2b28a5fd2ce101be27f1a3ca3b500ccee59a36d0d9af4f13994cebcd62ab3090f84c96e835c1623da92915c1863863061c7c5ebe4d167c238f3bd2d5bde1288cd28e954da8ca4ec4237fdc47e068503d6f3896f2c7c328a9dd227861957df73208f846c98524fd992030fa108edc2e788667da20e67c4d5e7bcf27410d0b6f17aa4a861ae188d00a5da1e5e9585b28fe4faf536e57c1047eb2d85cb7bbfa3b4ecee43c834adf79c9b5cb953e5f4ec665025a2a5ae1619bce044170877698bc5c141983b7d7bad75d3343e70b8d9850fa7598ac55853627cd5adef00b9e30a3986775e9320f5148d454232478f69a56ec6de36fac4857ab907facfc2f436879d11fae0406abf54991d9cf16c99da3885509741f50e2199b20ca3e6b26d9df784dc8db8a206024cfc81574de206d03994af00a9596d76ab71f451e56ba706d0df60775403f097edecc705b88cf28432665fdd62c82b52e52a9bb51f8997bd622d7b95c367d6f00fe8a7a6a77713e6a5e9c8ba346d27587efacb433ed8c957af27ca6eb1ffe2d18609e327de5d65a4074d255616fc80b02fcfd9acad4bada7a97b0afe3c1c5a4b20a58a2a077ed7349cb23c9e7cb89d3096c5fe03d5f409bd139f29b08ff489dacffe49b631018f817bd9afe8248fdfff3c467899ed92b531db711fc5c1285f42fc02bc87d3a68fc7cdaa911950c1098274c15964aae3970f0010a1797df5e467241f4549d7dd39e869f72cf93abcbd5b74968b4d2b5b613c9b60dbdba1967dfe30f6f09b51b286465b6344bc03eeb53f74e790be7e3ad3078d6ee11c9bbe9a9f1719d4b59ae3c66a48412f623c7af082f9e863620fda0b88718dd02e4a9cf7b12c5e22b714155db21a77e44907d0efc58d18e29597a4eb278f89c3761d6543bc3e721a2f493150b18340a6bdb8f293e53ebdbc2a60b36c488eeab2a50d9595fbb9a32f9ff67d263f8942a5fe99484320c3a6e8c2ab13cd88206cc3d2d9ba4c4a4da64199f5aaf29b3e097f0ef006f31632bbf46392a94a8e43819bdde342757d6517e13132ebbd20039dd51bf45b2958c5f8f2c0d9155d6e4ce33e3ff0f229cdf18276dacad9862b2ddc40f95456a7c5bb5bed9f3abf205ca5aed628c6f8ce7f1e75b05854aaf775d19aaf1c994a1d8da8a1ffa680efb9d6b27f39c8a154a698896bf2b8e0fb850aa480f14e7d2ebd82c71b784a6148f0342c28f55b3065722da78ab0f2b17de970471df163def57286460126a48c8cd47fa3491917bc2a32856d284f92ce4f6460a40acec54dc11b7386a407d91337a9c30fd8f602ac21dc727f0ec2e8290d5774c0ce5a5f523ce1a0b5899d4bdd6a79ded6ca8eef317f073c54d5cfcaf2e2da0d42f9cd75bf13e6420e6f520ac5a1ce65b69d3d51cee4deaa2c871faf186132b49dfe945280babad0d312dd8d82fe856e8dd75e3ed7d850498ffc4710f056392c169756749cde06003a3ae3fbaf47f57d555f9e46bbc9e01910cee6d6db37464c0ae4e2ec6bada2aa31408edc679f9b05c5e1973ddbd44da648f6f8a0fe9fc3e8fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
