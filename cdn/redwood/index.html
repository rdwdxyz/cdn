<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9466de2b23a437e178b349e153ecb3aca914b6f86b6239a8456eb5aeb9fa63efa222130d28f7dc8455b72f6b561a4968ef989a32ce9af818217c9861c1b7343bcf826261cb13fd4eb290da9c114529c90ce48538d92bfc0f017a232d402b4892f1ed9b5b3cf15eef2c5a6d076bcf19b9465a75fe9e0e4120f9d62d7dedb69cd47da6a96348c95c3670ab7782879668a4a7a2a1ab49fd9acb113498415d9574fe400ab21f13446e6f7cc75e1c7ac791334b3599387f2c317c0dc2c3efc90d41589d4368a3ec501ac9ee8b8838a3fa85cfc88fa874234d6e4fd1bfbaf09d8317408dadbb594e367d3eaee4c7dabde21102444cb227b7610693971d047628b99eb1736b0aee8ce4f0c6b94887541936acc8efe5e5bc9960364c723504249fab160b12e370747988a138cb9301b9a1bbbcd404342ca0af992e62feb546848948c2753314309b6c768ce5537951e2f2a41ecade2ee682e4bc988c73e25f7c0f08f88e68eb6a44cf9ff60bee5f45d8cb112f0c1b6c6c10c95c276229b3ef54893c2fabe2b6b6776d867cb96ded379eb7b85745e0d5dca3686ea4746d98c3c1343545ca3c2e99ebf27c217081389a5b97893e6f5c1779faa0fe7837af1c5a7d17b97865bbafceee352266f21eaa8c83bd18356b90398b670c39cc534a8dca726de958d00ebc6db97c25f7cf4a71ee8970958c4b0426640da1ad3511123b3b019ba09050fb04fdc8d7ba8bae3268cb1db9c9bfa752956e20601d05ed248fa20364ac88acf1fc35c51b456ecd86b6e17b70c85c033a9074da785857ea3a588898fdf3faee8b79be0f5882c885b9d2a62b5026091fd10674caa2fbaf7d60815bdc25329829447898b924b9a3293c70e885616ef1b7bc8a95514f8a70edc393d39908be09f7478410cb2bcf7878757fca2eafa07eccfb6c1601557e655727f7f8aaa61dc38d1d315226b89ec7c8dd0422bd688988e723f6bdda73af2928e2e333acdc35250a21f0207f98430d7a5ec55177f62aa1fe9970859d79b50dd28435797f875168aa2ebc48696173169db2cb32b610ebe40d2b1a83faedf4b365580b93d2878663a208a6660a97914ebd3d2234a399fb340eeb5120a4a17049bfc116f0939842c6f6033cd04bc567f117fdcc1713c0b58f8915cfbc87b977f98ddb5b74979a55e4829f23f9f91e95d750604ba2a18605723e690e57e065c7379f044713a91e7c6335995f2fb0eb037415a8acca9c6a07c90d1790c0a3b11a5a878403caec02a84b121f499c0076574c4546920da09dd92b2a87d4e30e2a1411007ce9b86f885b7cf5f6f1b33849632f4f318a155b7694560455f6a6e0a0f4f8f92397aac977b90b327d3244215c3d658bf03a12ea543545c19ae4ab63695aa63a5c063e0e49686f0f60912a1a0520505b47d3bcf5bfba8a95e9ff0779db3b80c114dd94fbfa1ab66e3c8f0b5df0d3f3c95e1cfbd20be7ce0cb63fb23827a9c6f8e366421753e65303159ba0f941472e41952cab67630d0f95a5ea209f247b1fc14a87638130de58b9ff8184ef43756d83b8cf312621d779c71b3ffcb796b7031fd2d674eeca28eb13b0767ed1fb96bba44185ceb6791a6478d3da65708997e36667cc010bf28293b8b01c08f2bb05d2497c0fe8253f472d9544ce015554038d50599cf3841650fc01ecfe8ef7411d3655e01b02ad6b7fe9fce37f1ce6869f3d1c2cd83316146606edf8fe6a183a078988ac8628d32437879a97be78039cce8b48ac77002b620df1b19a6d9a4eb9bdb95ee7b128ef402015c82d5831ab8d0728e8158c89adbb7ca8813ced22afc454ea4c0c6c24fe2f4fcb6daefd6a28f930102c77cde6104777881ef8a8e630d23cc97e6f9149682942047c251d6c91ed33a771cba97136ab9d71ad3262ebe9fd97f07a838724a1f084cf30f4e23b3058a5f0697d3785dc66b723780ff195621424400a4580922f740413c37a0ca137f55acbbd5c4e5f03c88471f36227b80917eccbe4243345b44269c71241112efa59450fd27b2681f377b5615d306e5a4e29318c54780e1ebc60c4df2efa473f5498bfd6045eb52f2a1a5048cd339dd6b820a4f568defb91558b179d45e2f54997b8c1d6434be7c20fd2d3db1bca296d7d1596d7fb778b320105155a838e8e43cb1359859d5c39693ccaffc9404212844240390b1ae3a8bd3fb67e144bd9db269d2b7f10ef41bd9c27cfe5975ba14941635e974f4b918fcab2e858ff71d28351ab7fd1afc6a893a12d08d2f41f81a26a3e206c011f3abd41da3405be8acaeea0cc3b57dd05f03b8cb0f54d2a1b01504b460aae0211431cec8d387a01940651bc190f6de1268882d7b323020a31e03c494d29ade43a3a4124a2b8f40b0ab8e57ea8a819b86704be99555c3b13d57a5aa95fbef3d370ea4984f64842b61de7ee4565c3f39a7ea9d41a6fac623ccc676c1987873564082d128321e6828334796041eb820f2feae85a6a48bbbab57e5fedda433941d06ad63e26c61c8cfb59586d87afa38c5910f6691258b8baffb3e989de790b9a28f17c355bbcb5351cd02e4eca23dbe2ca3c828a7b3c54b43c29d9fa1b53cb608075bc2db3afe7fa50f63ca2c2deb4658636ad523394c079d17e5215f0299131bc3a6b96dcb3f52d691e7abf7a605b9f5bf2f18d424bb5f2e580983f24da5c68dac09b613a71ba8f96ac3d498ecfe21ab7e8f0fbd49ebc15c2a46112d650cf5c25bb01d376b16e3e83fcdd0b954ee613f51b55d21063905b261466440ce004c98417bea132dcb238ed7260a07f653fbf6521ed9fcbcd9fdf3f698b2000181ae83799a8001c16e08166059135a50578a6efb513446647eed3336d241f5ede328b5bf1031165b19cbb3e4d37cd1679f3608a9f56b7302f52b518056a8292326ecafdaad8bd0af827bf5f70e41ec74ac9de065b5f7387cf9aea4047d48d19eaf9b7c8bb41929426626e7d7b02e32db0c088b6cae74912fb988a1dd419ddcf59c32db498192064dd4f841cf60121af3b39fbec72f499816ccb95b5449b3db9db1027b0141e3127de1a94ac5491e105f30a9758f2cf3f9397f6745e45794c5fe0d47892dc149def54675806f71fe264c89d0f75951034a6392467a4f13c39bd20f3cd5b68ed06852cc530c3dfcb95c5dceda6737335ff933e864b64dc271914c148e917e1469af156e6a279376e3f8cffd8576022d80a4d91a8c1da43803dde4a09a2345f02ccb9fceb06c9508c571522f98da431260212dc0517fbf74f32a6d17298c829238b0adcbe5c7ea19cee8a6f1ff1f6cd01f810d575ed1532a30f70a50d3a2d54a8e879b6db5fb31f98fc222626f43c11938c0f5872f8012e667fa38cab873c56bfd82a18436e6b3aa9ce001e6587f9e4f13f04f05bb68068c03a6985619e8e4334686d9186221dca85288cba605580ff30c11bea8bfbd0f9043654bcb2b8552f7b252a5e8b0aa3941f1dcd7e548a4df99e2323152b1dca9077ed68e685193b01b38857c7c34910820444b18dbc8ea6f6cb3fa39b786d014b529f10987616f887b9ff94d083984d6e5b34fce0eae36bdfcf10ae1fef1e576cced08ec8dffedae9a0252652b9cedbc65f07529ffec25c0962c253c1bbea72a45152e51eb314296ab6fbd527c841d8e73af1e5eba64e7afe48b9ed2249f3b9b7d86ce8e962022f3db96d730b8a486a4b01a7b0718058e68495e2f8deeb6e0752131871d2ae092537c7aa22e4a91b63603eecc5505e1ea36e5a56439771bab884544ac99f817855c2400223288a6dbd1b1b5f913dcb017df7e517a1c6800f3079bd937424ae6649b806f561a5087cf66f8659dea4d961111c3c25f9853540ed8080f7d5bcf00ddc1de31da80496bb871bf161021e21aa24ff47a0b79db52ad0a7899cfe9ce2e442d503fc931a81bd3453c0f88552881b9738cad999b91329f614620c536b1d6b1f958d4ad2e83752fa5e973cbd3754b27fbb882dd0d44c649fd3e9530457026dc275826dc5227848ea70e7b6b5be4790eb92bb9d86a97968d33f05fca95ba8aa15bd643b686e3198ac03b552d161f33a9b0fd7209df3d251a095efe320d21def7096ad1e289556bdb6183d3563b0c8600640e46ec6704b36e044d07a567b712a29536dda6764cc0de0744b934797faba88a8341e7ef622a845dcfc22293f93d9dc216e8c90a9595dd10afd03426f8865d57cb920bfaea1fbcb39a7536362c1b32338dd13180c9acd8b9f178d53ac513848433ce858f5840b6589ee1e168bfca1a6a064b5ab670caf9a71c6afea4f50bfb548b57ce240280ce45ab51c0d006ef2f9f75fd20b8b0e9ab4e396d94b22715e79a2950f7cf068a4e373e1648102e45d5854a966c0778d09e64ff39f4dbc461da02ce9c1a7616e6970b4cd0e25c3caebb2bdd6ff8a09ab84a60d3620cd4398688d77d47de27afdd73f751ba89e196e4b282c3fa4c89cad1250e61c8ca32a991c600839059fd5f5ef0ab43e2d04a2da9119066cb71407f6959172365f18d2b97273dc06116130006f02e8c43361b377b0d01d5c095ffc6a3f69a12042c3322ee570ee4915ebb4022e700d6ff50417e591bed086d2cfca9949178bb5ea898fa10f8786609756463c54eef22f97b83646b2e4fe66197e97a88a7f3d67b8779c0153bb625151fa4894b7928cea27bfb0a39acc8a455be6b38d89c8f864573c70fa8f578593d756923eb81f27652d24a0d3e63bf9b83fe060fc9769e9d3945a9e7e7302919582125716b0fabd0c657253785ae725385a46c52447bdd88cee9f0f38bf4b2e740fc39c0ed63434c9b83bfbb409186f9abc4dd2fa7566b09bd230e271c9e60a84c0c11449fb37763e3955dd3f68c7aa2eb0ba758d6f6c52f8deaa14c64a1229bedf80dba048edbc5968ece16b7f787af63a01808d3b8b4a5916a62a0d3436d41e6fd0ec1e448a4fbf2b3a81aa151ff831c4eda51cef4e0fb834f4da37482139daed019f298260ddd82502c68301579e86c761d69e8849f12ecc4ba4c95d9d0b242868bdfc1d7ac83ae04d1ef11ac5b79999bc3a0490c86238bff77737aebdb2069475eeeb195b1e689d535a1103b28d01bb6ecf5b92710903072d84b6c43aba630c0b328c4977835971e79d8b99155cdc5a1403a2fa94f9c810bac6d6bea55d7a81a1f24ab285ce4c464e42605a925ada9862dc1472a66aabd55840ce31b5a6470312588853000570622951ad9d71afbd60adb7584ab93c983711486f94ac7381d09b33ddd7e1fcd55037c5c92a6198c2a8c06d59ab5dd7052b2776f6e8d159a3291854ea4e9e74f2fd95136a854321c795c35449d3749a182683104e0196fa8feaec263f1d8da292021fec5f49ec999a0977f1e1818eb63ded138d712b841ab3d28d3be1b9c42f8b6fcce502a511481c25780c8d5dcd914f13666e1a9215df3c5285866e17d360039ec1d1347e76118ff2dab872d47be8bd6433104199e8a64dc9928d741a57c74f2a0d8eb21fdb3557b4b6a6eeb3367b2becc5e14e95ab87403f2a3a5cf8b92bcb8a033463bca7c189a95dd505001bc8d13f1c15419e0f72657664ab8025dd55eba6222c98899b60d0576157e2fabff3532b69751c6a8b4009f7bb5c97e86212fa3fba6650df9c9deb297ac4b012efeb78ba4f1161942cecc3af7e83a960f66271565fe56723adcc1f8711a361eda54b1e5a741c19de39ba4b8d2df373746349136476f19ad420d4430a704e6f0e21cef732396e100060e4d0ba0339c2407bc5547a2ad333b005470b85127ec34013b4e7a02d9752efacf99bc562a19a82f800818212753a5fb07bda8a85880521f16958a1aad7a9c78131e2d64e2b78ccdb0ec99c5b6c3e25b58736b92b55c749e64eb802f938c3825ba44da48d81128a8a0f7c13e0712b4b1458a4bf8e46e6ef537079d404b5d1ae40c2cb128a382b212345a9e0fd9eb9e499952d87c563619c17884185dfcfec285604c7e545e421ed4de2c9ad5fcd58051ae463a9f244c46d63f45d8168bcfec7c9bc2abfc79611b5d8ee0eaf0268e67e55242b41dce72a1369ff1be5374176c216957af6e6c5afe684515938714af1c665f2dc59b3db80c44b266c9965f29facd28bf2533f3d5cfd4ed31436a42b166b101ac501422e4ff759e0a18be9500eba02fc76e2b45c1228247ead61033aa068efc1ebd1438af7389063fcefad8a65405a9990e346939179ff0b7af8aa1ad1931d8f51e8cbc4941a0bfc556cc85e2f21dc0d900f829b86b02303c18cf54d53a521ade1c766cfe5b175909de63d24bd32581542ba114f5265761d88dc40afb6219d8e0f7f7b3cb54b17e53d9dfab4ea52403f945ece815110d705f0e5906eac8ac25345fe9b3748e6de764c1529957b6e665763931cdda726ea0449c59436a75375d64cd2b3c0a92a7209c1bcb7c3ffd3956b172d3ebad1cb6b50a18a75000a422f3d9a3692c72f459473c6229727c0be65bbf6cae01da9cc70ba05bbc4d6957e210755dac76437cbc660cf8f04c95436296336194244b2f27b3335ac337df727bec760e1b9914ab7e2f57a688c468a870c39a909ae8a0ad39971a2acccd0e2e665a1a45ed4b5461c9cafcbb18663607bf05cac5b7dc6efa58dcdcf92c1c7f4380cdaad67f43407acab3f188ae54a5325b4b9db285f733e3357de5a311f778edc660184fbef69ad879c895051e09d2d2b125efba12e9886df445210c619d0fd85bc7bc9b76976fee933536080782f759477e459e3ba914ffbdd83dddea9ab4c34b430ab415a9c7f1c4db797c02f5bc66e11a33f75d6f327c4b4e3950de4c2833edac44c1c73ab409c1bcf9f388344734e42fbc3d02263988d13bb1771d228f60211701a4b11ed0ca4c55b9f8cada2025b38cba4f90d556e92c918c5f434bdfeb1062d7d6239e2edd40cf9bd6e2ead606a5ca12c05cbb3dcebd3cd740c854ae8114701d60bcaf3c649d95b7918e0e21518226d090c9fc188845f48126f4c61b4b22fd6b764aae4c958e37d44b24929c3b79dec69c804807ba7995aaa4cc582040e664af1f3144e9d5c407ba92b5ed92aa9b921cc5bf7e99a3c4608374d14a04c39447c85fbec078b526d863e32829207eeacb7377347a64baf9e5ba82a614e2840c1a8bedb78097b9c6707345ecb3eac5be8afdc06bfdc23c45170ee25e46259f47a1ce342bed6f8af772de3e878d44e819c97fde7f1e859bb85b2ec45dd1d9bc2a4751b3217cfca044d12bf4d7580c5e67fbab7c7c461712989bf38f4aa4b72dcda297d44cdbed682ae4af881a4d1040cefa9721363ded2084f3545635a7e2b0d15690a34288cea2db0d118a558740046b0d9cb29763760b3d8124fbce487f2c081b59432c6343486cab5c505c429a43b1a3652e052147f7846a3c314da62059908d9035fd850001f527775c68de2be6933c06b75a04262b0c20cc29506cda103fb1021263306155cf1ac275eaf99212788d72f3f317fc8d4fb6e05aa28edc420e8d6a8d3bdf07810aab54363a1b6f2f25bfdb6649426f71bc5930abc0d38cbd9043eb8d2813d9bdfa044986c82f3757277289c241add531d50b4533506c489fecc840d89c595a318bcdd83ac94ff145f20f23f2cc4014e3a6eae2eca29a1beff4f190fbd3a739947430a4b688f347647cd7dbd7b20b2c1be1f643978b0d49e621ad7576605b5693a2a1ef53d89ffc63916e92fa863a990f5a4b72aefc3e3863e7fa03a86c852abeb575bf2caa129f205e50bdc7c5181265fbf68fddcfa23f9bff2e67277d971cab8f22d8a94331a5f8206dfd0f828d5f7cc403a86cb6017f38c33567ec8e2832f84cf7cec6887bdcd01b92e86fafaeae1bb4ebbf17d71cdded40c647c06b894073986633f49f3a93ba5abd00ca5b700e3fa87071c274eaeb7d4e2a1fb685ee2cacf3d10d49141945aff4a34076426c2cd0ec778a169376c10c7d88e5b6542d85327fe0a59ec14d2473762a93b1df9f952bafe13ff192bd55a27873cf6880d12ebc31cfcec1379c01eda750a24393627ee15d9cba9aeb620bb2baf93656ba550c44fd02d5110d52793ac415e2336fdca75862be810b8fc3daaa23075eb9e245b950a8853c0d1cb1d24885f3d0eb5d623a0ee095e017f664b41f2458dbcfa92fa988f031f49b33e87dd6031b4b042a42033fb38ba6a136b493e794ab90780c89d200f50de59d533ad1864db4a90a431688a16cf7828e55b1d87deb83d7d187de7b96edb486d85bdb9ae3d3d3d7fd8048ee89d339ae61fe13b571a9485da78594f24032f079e55593907acab354f5e95ffcd236ac6890c4a71872fda8e053a940e9db7fe715b53e665ddc4073d66da6bbc826d6ee581ec83545340ebdd34fd70f7f889dcde16f937008e433076f4cf8293ac8273ca9651b53a0bad634aed4bdc0ee9b61d76129b531f31faa489315e8c6474325ad2b7f180d7dcb3a392ca23ba64f5cde9b9cc53ce93680373ad108da264df4229f3c40a9dc1a1be9ae0a2ea0f6753f6f193f97f546ade2df30aa1bb1058999783a0a0e7e780e79bff1d9e151faa37998e7ce2e6b363c383718ba4791059c9487f4245e4ad7d39b9b72e425e83c1ac6bc0de551ffe8a7c1463d68b88e4a9659b6e51135b38240197dd5d91b2fced5070b2b1fb26994d310750a8bf9d10da4ebfa059fee0660934d4a16915fd2ea837c248aeed2b34c95c8213d34aae3bde91480dd5e09bfb233d29656b9858f46bc9ea45f85a9238ed02e36fd92c0d027287420f80d0776078f6e54e7260d0bfeae46780141b494e59142f3f9bc8eb20521398c153ee1d61825c910a491c3f0647ba925f20761e6106e16f226f66c413fd300014109536390b1d86c381b5040bf86c37df1c10b0996721239d945e0ea11e30b4c58e86133eb8f05a892c762bf2488d3b7324806be891ca35d1043990a786c450781e63f73769a70bfe86749e7f1ef891fd255f03cff4f27db5f1646b23baa2d1e55cc302c863d215481913454743daa3337cd16575bcba7b891be86f0646f27d3a3554445a7865cb745a9dbe739189fc276cc884b1cc8091275a28160031cca6f6d865caa15e0c228937e88c368db558158168e1eed673d6c0a41bab0842f0d020c9420a0a0f49e9c9102c9f3a69830fc070513286a6948cbe6c6d97284dd06e235e9db9812bb9472466a8408eb4552b9ba08b4d5c5dfb367937cf22ea9f9639dd6ad17e522c0291060693f8795a80f0321171cc20d2e9bfbd94fcfea8c5b08f5146f45b1ac696d1d49650769eee4456871dfa4a5979e2995358d5e1c0f72ec5ed6f47337b155bc0a7aea6e85cf4293c2badf7ba621f9694278271467166338174178305b196bf4ef165a29194b72a0b8d46568b53ded292eb8c1b13d445135521d3bee17ebf20b8f9e3a4faacd74d83d3ef2777cb048b6e66c7ba70bd89e62344c4a3271eb2f9781d0537d1f815668bca1093154228109aae12c9ade13d3fe45c42c3fadcbd90921eec3b5ebc1c17a696b60835f6ba430435b333ff1300707b82663d93f789599e7e75ceb033d31b0ec90bffc45779944db4f5e0b4c1438aaf052547a2cc1784205ae64b13bd2516b79ff92512957dba5485754b228be1faf59f2471169deb2ecf2f673d67422d40b2a3ece491662bb00bec47cb3cb1f75413d8b5ce802ab62ea91255a0151e2563b71a6d1f4443240c983c58bc2d93dc9663fc4731c5c944c76e0307e7050d7dedfcbad633321dd52618ec4cd207a2b2f7761e479f20ce95856a116159355a456ea14743ddddc2df2dbb6c9078b3d8c783f3bff3d5a4c6353adc2893db31da42b48b910bb285a39e26fe0894f52afd1451991429adcc2770b684a42ca4f3a2f260a89ca88381ea2b90d17db52e293bbe28b391e2ed6d7fc634f4f6740f174771659e5b13747958c47fa13bb39f2117141fcd4c2bd90a3a93e17a88d568f97c9f9667c5df60689472fbed6ed429c4f3dd0f0e71b7ebc459fc1dfe169121456b8381aa8c07fcbd5dcb67dbce232ba25b70fdd98f19a9caf5089e568fb4c951066010b71a23f7ebbf92d18c9cf51ca973bb1339d1d90e19ca56d9b47a71cfcc2b013e643433ef8e86d67d701ea8413edf955ff1e7a86617fd55ce7e78766da03e137c79f5280e0c255e349f489f57b69d53b21c522a5857f515be1efc67a8aea14be98ef275facdd0da70935eb72f3e7edc29d8181cf3b71fa16914a02221b17163dd213c4e5d0d88f2220f7d5c5659c6cc4e5cdae18d2148f63fbcd7478d983e8550bb289912692528e4d9cc570387be5bc2b527a84125b92d2c352709ddba0e88179ca8051668cf3b8d35a4b1e3219f5d0377bbcc02380c2a1d59199c4ffe89782a9f4d07635c17e8f55679fe32a8bfb5a207ccde077c714c077634b67dc775e6f34c5743a1c55b778c98dfd5d6f254259c3a1a44c17572f8ab186d373401d29726cd477f619ffdbe6d3a9ad70aaf5059b3378d7e25fd32ca194160f453f5923ae5359b80fe45dbfcc7c2a44b3891eb50e6870095149ea4806b999fe758048905410f9130f799879205328b044c68a87ad38bc3e6f017b93f240317390b54dbda266b0c38b6e76543073b75b5816f6ddc95705c198c17ef176c05029ef2aab20ae3cedcc5b80cafbdaebac5171a970fd8492976706c6202387898a2727e3883b37f0b0e585cd0ddfe7a56ce90d86d31d029a7cb11318ce7caa4777a166b5ace177a80de28f2fc3d30efa4b2a60ec22f1a6fe4ef01381ecc2fdec29c37fd30cbe5427501b1d701061851965a3ac1964c39bd520cae7acae500ec94e773e9b88ca2f513666056a7a2ed71aacaa26cc6e7b7902381e3f98529aa72d7cb76a462b8035a9aaedbc096d62141258f0f9d1e886c9a3820c402b075928101065e43fa2e4ee6730757209ba229e88dff7d76838b201181e915184b419f34bb6b56c6a7516a25988f13d18b135de55ec48df91c4807477a7dfe254fe4faabc70f664a4760035c42c1190c243565ee23448729d0fe47e99c62497af8ae878e7f2ef64d5f9b792e9012b4f787da90ed663cedb057767db82f6441d9fa91c37e53ee2183536fc2ab4734d09be108f87842f123112e0d34e7f65e9e7ab8646e07e86ddc07d70f0b7331b4f7ca66eeb13908bd88da15dee882ca76ef8e24df17fbee254e6d84e079d2edc74c5f180d848a33f8d49245b890512d5ed054c16c6c699c28914d89f4bd3024862ff82f82e4644a78932db16696b7041e71e177c5b2dc8e0d69b6c3f11ef886a8c3529882c8f2e5f03c485f90bb709a7e627425931550177e5a6013551fbf730d3d17e5d0301e35484ad9710b3ec80167b47a964dd3e06138bd9b9478889103ad95b8633ec4b4579299755df4b28af3efc5e68a3be2c65a762972085e041a82fcd5e574dbd8ba7ecb34c55508be5fd05a1c71dc7c74a5a0075fe061efccad68a921153d7bf4c34a8680310db3cf5d01b91d97b74de0951054f04254bcb495fa24163beeff22d183f49e7fdb12494d9a135a7d80ae6bf0e300cb5ce3e94872c86dcf2f5311913786575e9088ec4375d57ade01f737e9cb9fbdb0ae5c24a11c55336b99803ace6af4d424f94cdfa2df6677e14c966c0dd9d240bef1510b1b1a5a7c1d2713c665fccc61b8d962b3c5b594ee665854d77e1e6516e7be1ebf2be424c6b7e6e9abcc5e3a3cbab5da435a7280e20680b553fdda9e69d140f0617ca10f04fd9b513bfdb562e1ac5729f0af50d805b823385b437ac5d33b86db84904cc1a14562d6ac43377485cca0300e678886b2544abd0acc9271af9ba23cedb9c17e301c47c4d3903dd6341d26173dc921d057824cce9f8c8a2ace2777fb093b71d7739c7f67bee169f80f03bd173d5514ab2449ab5d29b70791c5e5b8444315041ded9fd3fad5b985e906d22fc34f4412afc5332b9e70ad5cd889082892878e4eb18ec195148d12e3f1a9f978606d278110e0d48cbba63a6b4c906afa1c994a79f3e340795a10054e0adb6d8d8f77474d3be200b2b1e07ae30bedc46028edb23dbc7767981e42ea76159a9dd5ea5bc99cfd8ba5192c27eb388ec6e4a98d8caa79d327277ffff3a9f492c3399977d8b0a5caff700210657f061da4834f8b1f5b4577fe332ac1e5653e354f13c2bbecb4b3c45baecaa70235799e737bc27a9f63d329de516b7be87d17365819cb0e3be90447835c359a707d0784eaf23900955497bf6d0286be6dc04d0944aed3fa130c8167036c40b783507a7ac0c9f6ccf11db94985459d01525055cfc06b7a019a5f1d1cf4a5c84315b8d4ec33df72ec20ff38269e88830e655f2d30655bcf86021d5956da79e3efd23c203f1eded2951e4331815a978b8f68000612305d35b804eed06b941925c03a378f242d75946c803d77b410396e74f7dc0ab87ef50cc6fabfac6e86ea5c99f9d3e5bdc4a97bdf1341d9c28d7d960fae8086eae9426a06123fcafbf3f4386c7f985d885e8002b305799c8771b4221f07db05624604faff71c69882ed83d06f58fc73e856d7f565969aa09342d5aff9268182c37c47aa252d99fb5225f3b4949b483c3af25d44cabc8e7c40bf25331f1eced2974c070074bb51dece68a1de2a8ed2dbf15fde2d49bf52d39b9ce233cc08a4805be5ef35f272c2d995c0c55b8c131ca4e9678af638cd43f83d094cb89e3302ca2c2001b67938e0b98fdc9a7682c697f0d60632bbdf9d6e0106d2f87cdf62f02585e1c39323995f1072c6b40fe23568619da8861967230ff39beca10f373f3f37bf5a494299e1a341e76787d04e648748471ab00de6f2350beb0e53c4f901d8cc22250254cba37deaee4ee215195aaaa63fbe32d15bc81c0243bc309ce3068143bcc89e43c84c3b6784f34ef37e83314f3d74ed7f8f83e4d2fe22b8ff606510a651c398d528cc807023f164c8d8cd726a8a439a96e7f7719872976eba508b0974e5e3a6409540641622442146ae5566e313076c7439bae809896696a7940676cb3672102635d1708765a32c72096506df2eaa456aedc665aa21d053735f62faae86e4b7adce59d2779c392ece2f3769e789c952045117274eae9bc6400993efbfd021a14c8cdafe7af80af225a7781ef8abec85770bce4bcde19fd9eb1cae294244144cca7220793e797af195220e16bbc5d6edb67fc3b22d6b4abab1b71054446f6938ec3ef0a667d65e83d7bd097a30187abf5b37a7dbe596b985235b3ab4ddf51a7a1451983dcff9b0bfd2c6c8c8f5b0bd4f8b4841d1205e26bae78dcbc14d72200e8e5c33b613f5f4a6dcac6d8d38686ad7e9323dfdcb7cebfaa5794908808bcc7dccb057ca81c2defd0583b9ad2a9c0b88de6d25c78f01235f963cdf364d106ede9692990fcfb2c71b26127b4d63525e03591feb799a52ba39f8087a300a30eddf57791c8e1e66f72dc1333a032d5cb8517722544ff072946da5ffee1127bb6033c13feb225fde0ccbd18566cdaebfc1049d3ded54405107c8b246932d4bd323082f195176a072098a1dcbd2c3efda6837ced33e01a8a141b91b2adf558e66410a2cc97aa89833599abd3922568f46948f85558ca7fb85486528504c87f2f868f4a655c02dd07f56d61e058398a3a9bcbfbf68f2b08cb6093f8da648f6ccc8ee472b5a1e5dd16aa80606a88e4d799714bd45d7e36b28f0c076547498a1d176bb6c1fe45144e1d9e0c332fed387f3c9b5767484c339999fe3fc18d707fb4a629f9bece94a33592be617d8cda4d135e3142c714b5bbb0ec468c1bfecb0412371088f4820278aef10a1c28b6e70201f192e6389f065f6f1a47d5fac448f0c6f1aebf833576fdcc4b848cf0c94f8d2eaef7689b72d7ecefe9574aa87c343ffc389e232b1e82a836f8b721a31256e54f6fe5f88549e2243428c34c2c11782839668a615de3f6e4bcaade0176c8c14f4eccc9b1ec0d44281fca7bcbfff17070f0c9e75f7853e3fcad39c4688f114caa44062b6ceaee5dd5c9ecdd92cafa1a9fd20567ec6572e24f0d1705e5aa7b7b81bfe5a042931c54b8514954e6dbc6c03aee60e9873530479e76a4c35f872cb2b1b52362f4066508b637f7481a2be51c1da0d95bddf359436c1ea5bbb947350ec38370aaddcc582f7f05e8362a56ef6bcb11b896de175134063f301753ae3dbabb99ed8fa54e96ac3125b93ab4a4acae43f8fadeaddf8ed6efc12d11cc5b8eb1637f38802d6ea9033a593638ba3215755e7ce432880747cd04e48f41d2f07bcced0f0148c7eacb8236d7e0456bbf0eb319155625584aa8704066b4788cc82a7cb5db9190a268c5c1829846c0cea0b4d56544014d352f750b99cac2c2642e8d0b198d786ce83c4b21932f3813b5eedb9cb8f4f2f6f49e8df37a26e05ad5ea4c22ea385e09218747ff09fecb4427f9134186be3a009fcc9b9ed34a962bf845d9031c2aa8fa92cca941e850199a42acfdc65fdf6e1fa0bd1da9b10521b1726456c362fb012a897563fa93faa881a5cf7cafb505c754d54bbc581f38a4540f637c775cb83962d7029668d7ed35d43f874272e6f11391c07ce3e3eb65d512d35113e745ab0a0be1d64c5f78907eab4c0535a372a2d083bbf99387196fc0e743cd921b617ca7d6e2ef102583846303ac664a196b67f487ebb35ac6a2a512b45c67947d13f92f2bde725e76ba82568c6d33f11fff01f79c941c90c5e852ecc1fdf547af94c555820bd3e480e69f95610075237f463fb371032a0690ea259875c60835e354501477815612b0f6110a7063805d1d5a5fe3b1abaac2e1b4f16087468e772b85fa159b67aad3faf96128252f38050f4476022f4bde41fe843cee6fbd989a55094b6beb021449cb5fa502a1787179954b1264fe04b77ce2111f12d479304415f27f68f0a1ad3b7e7b700788bb2ef792afe5cfd13f3c81a12eed5743b88ff5913ec8888ecb1c17f3175ae7eaed0ca3e0a697ef26939b5091ac250a6e7e323f3cebed81bd28e498fc71509dfe7353bbcf5938141a74a5271129b858b94850daef3bd50b53897490707b65b6c533d8404b3fc46da4b1a487015de26fe0cb7a88b2111e1c1341c493f3dcb49e7828e5e652d4f667ae0fbba217de9603bf576c5bfc9d716735dd34e8e88d9e017017bf84c4c8cce303215b7df3aa382384487e569ccd11220efb49b9150fa186a1b4e6954a76da06ff35547bd7d1109aecea10e23124e9b93171cfecd68c617ddc333fccbe3a560961173b09e10f89b4ee72b42cb5cbc71fc969ba34b27c6ebf8d98ceef468243c8e147bb906c6354552fa8b82874b39b03b72265ee459f3bbd8efe469cf50b22c5dcc6794b1491e6392578b99cbe6b1ec70bc6894f039bdfaeb5df47ccebe2055e382bcf40ed3ba15aefa55874bc42220de351afeb7c7d03e20b5abeaec1a03723983b0ea411a35dac0182623ae27a21b2462b8910170aa2e90b2819b98bb63f1a605efd2fd5bec98ac82541c0d28292eb80325cffc3bc00e935d6ef38199fd91ab1ae65c7d8e3165d5085b6aff1ea12d0be934498a09d5019456b69556b97bac12aec0f22d828ce1f1c9fa8c143a557a838c5d934132cfd51b2851f624efc4f1571e7987f064294eac13655849d15b54aa8e9c792cd690fa9e54fbd7e10c84080ff5975ad21c5541c5c2cf6207c086825f398c2c58cf34dbe5ec8e35c2584b5ba9aaf5174bfd18c2466684e1467dcb6dba94104039505801666f3ac3c006b9770f29a8363aa0060377bd378376453686eb2063265ca1191939b178d83cc57a798d22f80f94fbc703a43ed43adbe62cba308c338e41dee527645c03f2d2458fee18fc2e62e5cf6519d315e4adbd3f03d1617ed9cb5393957f9f0176732b3bc9c2cb718a970b96f3eded9abee3cc0ac06a8d65a162ce3d6d616412f4f1f2b9855a48896d577b33ca248df86e6065c0357903ad0a0bdea2a46345998b31e34e313004a83f1f7cfc30cf3775d18890b7581a28209e5137dc9a0edc88b89863e1fe8001152ed0eb02f677288db4fbe347180742e52556ca0b5ed6695c23d297a9504f566527e1eddeb05f5005fa7118cd7de3f3d2904f75e10d83ca0e464656e1679d00d875bee0eafced77687d850340b8a6fe4f0f4063a7b059c8d10d05698de4546d2466f84b0fd9996978c82c774500f08c776915c6bdb8cb4b372ef3473ddf315e3b6f784f3c7012ce3d87603e6a6dc2eccf1f4138b9cb8274a9b0300227837b36d2cc9e9c6043cf0ad60b02cc9c149af82bb5e28d18fb72bb2ae247fe0e56b00ef5799a982d437e68050e33bc6db35b91c6e3ee591ba5278f11c40ad09e4a6097a14cc49e000de3de8ac68d5623e3cbbc771fe768a53e1e30f868eac2ce0f21c86bc6c3337f638041deb3c2a54010584a594f193f4dfa385d4f60b5292c0a518d877bb80e87648344260ad2e50d251a900465c87ef70f45460aa3910936da02b482a640e12fcfe9f621f8d7c0de8ca8a2b4bdae50a42fb2e7874adc18ad43b86061834d7f1144651771fbc4d19f076678c38b364fb0266fda2a9e74fd309056ef816e69cd4803c78711cbb0f36a7c89f3062b17abdee0877a71acf83978a4627daaf029e412d7cbefa5dcb07bb3ab95a703f4f1d39983c298eee665841a968692de31ec91de6b15f1efd7e7b262d08b901f38c2409f4f0b1852de9ab9b823946e2577fff9bd276e2bcba26fe7bd81c0f6dcd06d23b8363e642f7d92c478ef645658555ae10204eec9b3c52f71381b011eaf0e27dce1b23747b1e663a5be1265c42e4db5f8add8edcb4779d143c085ab93febb5e16bcb2fd7ce8165fb5f238404a2035e993cc9d18f53f9846c65be1a9208a60da92b259e33794046d52947adc6cc0fea8a72ffd934de2ae272ee9089d4cc701f560f3a0d2f83f913a3b76b0b1c114f78a38633c9339360668cb982466b998cd799baa2953ad7f0c2af7ed150a846f150d45679b2d1f43fac3410edfcf3aba0740b61811ed697f1fb6e6b0c0eb39f286e6b1922ba77b49b29a2aa119c8b8a7f0eaad89bf1ba0160dc49efef804dc854efc3c604079b18d3532b78f8350c4c87708408904ca697c8061b7e1b26b3f6595bb2778b7c0bf76a7a137b9657e79b953568464c24d9846b9634f56f99fcee6ef3942b48e29b991f76af7f645fc853cd4194b335de649e8cac0bf2d208fd315f4336bfbbaec82cff857f1c9a24650cc5762dcb0fe131cb2c6cfee76aeb77d47bdd62dd7ed1428aee34fb3ec1c6e6f9f31a42e60f0d8ac1b1d06476d38d94b2655721df0ec0c7bbc5f056b4f52c495cd09074f64404ec750305f3d4addcac72626dfa822db5d3ed4ef1bc503c7ed6f273a7ce37c1811c2e397a2652ee11329b7f1636b087d23164480e31d417c7cedf1336346fefe2db9e341b4aa449848e58ac246d17ca8e65b23951e2ff208ed077398ae3bc0eb1b36dff5de158c3d6493815c26c4d904f35dd68d4fb23c3e99b236f60cd4d49842fe6c512078cc5b1929c6348aab833efe393d4944f16c3e180f93e492fa7da69f34c34c576911ec711c9c0ec89ebe55313f0f263ed8d3ef5d55faee94728c51ec576cb9180d325faf34266f9538f2c33fd4a5cb56985d79c0a3ec9615371641f2917e1176ca787d1ba746c7efccac3923180ae5abfca572ae6ff27dddedee1b6939d00dd31247976d10036bf0ee485b97edc4776e8b94cea95818b1eb97dfd80984a449a595e8dd3d36787ead8cab4bfd3fe84b0167a3953e5676d0b2edab2fdcde8dd0353cd160a7f5fb353f2be2dfd12ed1cc478677e446185881e32995e2383749d71828f8a59ecc89b5d88fded22b3dab573e3bbdcec937805da8d97d4343347db76a99a4d21a5099d528954a8e80564be9259efdda1146d3396b743bef06a73f80445f0323250a4da4bac41b13c32fb61e0a1df3f42a2d33e839ebb5f0ffc0316a5adbf0622e9a1963cd7c1f49f32df90143d484d96acb49f14e9bcbaf86ee5ef078b64b3656f7664721e99e737016bb308c3c9cda170e79b9e6413ea201b56426f3e71d44a8456ee44430faf4fab6142b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
