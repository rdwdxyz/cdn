<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d7c1b6641bbb9dac46df13d5aedb8d2c76012e95cef2a59b05c1a9f0422666f6b7f7ad3d7e3330d765e30c797b592dd53d486180319caeeb592425205cc8e58d37d5d241b414b24c237d9dccde46502a68be0c3cc24c961644f88a97578bda750ce6abe7378a75dd6693b3f272f07604a3f160ac2557f0f4a776743bd42b09fb4e37b3211091403d93203bda8bb6bd9d2f1152f942f7117a8014d2ee8c2320512e5748928d240e137854a8ccad42d72f8d93726f9810a54af333f7c65a76904ecfaf08c6b2da03268c54e8ecc3f98f4f5ca972697247ca7e710b221622bbdbb63ec3af2c9464f502fbcdb2b071b10c32ae4fe13385e25d01f64589fb70a55c9ce2dd2cb035a0bd8a79110bed88ff544b03de6d67af47a528b49a406b01f7d939636337d757014a6c7702988cb652d0c5bf1f5fcaa1ced57513e3f9c946e95cc4aec1b0b41155bd2d61bdca98b901b15716f049f77f078a226b5f921404993da0e3696532ec37dfe067111d0d4e4e8092f74c78134c3d748c6ca8a979676254eda3483c447e17fd169d1e073f0c255710bf986615a3105c4f478d04e2f5301164f758e88858dbf52b7072e646d3d3c337ab68687b8a1e382a6dbfbed2b023374deb41f4cf6d0beeb98a55f74155a6248127e792622c9bdee42fc6c00c4923d1b39bacd2f8fc819c2672934c6b7828381896277aba12265d03cd26444c42614ab5ff1b76a4cf84a2f5ef451adb2cb0574350af10730160d0746026dd5a78cb3eac2dea582b0265a9ea760a452704e5a2ba575ece6b1e2a254653176bd06cf79e7346038adfb6db8ffb2233fb41d0f63e9dd8884699f23f51722961f48a451b6c9a31c8768286e7a6ee543c883c49d8718a3ee972e5a5efa10697923f5320162ef16f29a6f2982a17434b66cc4da40107cc1e0140095ccc039897b46e78200fa02a68cb48360c7e0b654fb4b16b88154cfff190d95f32b0362ecef83c3059cfda43cc6a32d17f104e3758c4926d166434c5573c3be86676c48e4c0c74e8e25ff0c19b1a71fc3356063076a541cda3482d92d190ea391ca6929b3c564063a86036c00e4a73f11263cf32aebd33c7c8bb73b99878179e025647c4eb9f8f79c7242ad0e9f96989649e2ad0b9d7fb22c62a5d549797a6cd8b53b0b8e78a766b61654478f1e5fdbfd15078d58b80b7da98416220b7f4896b80de3b3c7ab191b75765a5b26ebf93b93abbaa1c2ed00d7d3ad01dcc030010243c77199886d59e1add9dc7bbb82de665ac4940243de9210bf761787809bcd0fdf74b703e76ff6241a9f1e7e2cfcd7bfab252944079fbf5a690c903056d6cdeaa0d500cc5ef7ab4a3ede2b9a231cf04b6319583c4ec6bc77c12be3bb5132e10b3f24333c6e64d23a0c763209f4c630a5f05bb13565940817abef92ef492760b1691dd97da96ca7a21733071b4c406192477925dc1485be549ca771dff731db7824dc33c272bca87194e174c1fa226306ccd668eb564ca9054712c17b109d11120453af13ef48469f93cd5f13b77beed8767ac65a22506d243ada0d16c8cd8f27bcfc9b989158304b830c0bcff8c022558de3910aee5be8d27d256e2b106c38bab78bd62f301609f1d541180384889f68a4036d2f203dbfaa907e546bd573f2f6452d32c6960a49578a1344726ed5389dccb71f38cc2a25148ba2541c45b3309843670f9e5773e7e03224c388d6f0e7e9ded0d94d9c972cb830bcbf5f312b15678fb76e0128ba8f8e0812f8e1fdaa8d3353ecc78dcd79accbe00ef168eca57ae1fd6ed0a4fa810ad43bf4d6807bd6977372e3b458ecb9dde9048c35a3251a7bab7d5ce7ad1a5f47d68d77cd02486085ffc03e21b987795e00d225697d5e89e8de215d280a5f3cda35bfc525091dd0abdc64586a646d5db2f55ae4328e36e13e3e4fcf7137c3904517c6d25f0f8dd07386fb31f282a64725d5c0f4a727f43a940c84014db66298a22b7a0eb8e77b0f82f105c1e6085539d8efbe6092e0e767bc0b288e153876430ebeb80f6e1235b10b7cd9c0b73a0c82e365341b090240380739090673b3d5ad17cabd6035e0b8a31c106e38a744ed0a8ff273cab40d3a1dbac45b736ffa05cab8e612b95edcf9935d01cd7c86922fd5a8909b7c0b2aac8dee9e0237025f576fb5d00d98dceb729c558385f52d2288162d9beda5039c1e4a71878ae3a6e4a5ecf05d1e697bd8a7a8443e2f927624f960212e3a226d8115028c41e8284f513f62ac0467e652b46cfcfa550b7674112193cf6e292e694c9575ed1e18c2cc050dd66d485efb4338551430fdf4d1c3d02e6bc1928169aad14bd8984ff17c94978773c9f0668d21111fafbd76d31d988bf14af6f1779754bd4ed68744425c4bd810851db20811d61aef31053fa8e8a1537d5500b189cb4c5a2a18821eacd43ccf36c7443192142b131e55f4b9a12abf1368f71ae7e78ceb5521a7c743a56e8a21d2022eb0c5b3a4e490cd41726d916657be77e1905a6984801bf5b0be0d9696ae586c2a13e4cdc6038848200a4c32bab5b13829d3e0d208ceca6b43ea0cb12cc2b2f281dac05e8ea8ee23596189a87660154f5c8b8b74286c4e414066ad2dde9fb176d8613735900fe9e76af53e21c188ce1a8fcb92d9d4004c9cffdfc2fb3b043a16d2569f215de760e0970da4c5ab28117050df82cc47f5b8d2ae08504215ff38a16c6187e99dba79266566602f9803eab89f2fb47a9998b23b7e01f6fc87f0faca2b940604844634db2cf2e84d75424fa338966aac7a82bfc6653056b2bc8a7de15c744bcbee54e08822b5628d8089ccfd032a3122651c84fd9c3af0315de62e174340f52e36c8ce1f6b88761ca82767be7c6aca2cf51c37939a7ae1bb7ed078de1bb1afd29ba729050f2874b71ea9e19e03b94b5193a45b1bae76200936970c835d800face7295565849edd6bf03b1a7747c39597abd5d68b335764eb4023b3c2e7ae889bfb5b0fefa62a499beb7099bd499acfaaa2a0291e064d6940dcd10b8f95a97fb59808459559ffc99916f375497f8f716fd3bea1e6df069021c2f01c4d7b17b5d587cee1af3391a154aa7d0692df7214d1423a730b5a5287089846b30e92cd057cecf0113fc41e35e98c5efb8a4f7e94af1838edc48438faa4ec9345bb36479b8059eec717e4ec6249c19fc955de94ffa6e5e5e41f323cc16c2b8529d43b19bf148432fd1eaa92246de31f4fba21271c72098e55c626fd7023d231a808e4a187c97bcdcd4810ed72e48415ed683a8efbdd2c83e7090258b6b54f433b4f573c13ac34a7f63b7d54e80a14300f84e4300a12b9861baac233200f0628a7117279a73cdc966179bb4253611665e26646ff636e65905849e49ce81d32841c3903c478e2b7e527abccfba81fcb15a48a25170504872c6d88ca57e7ede8f34bf972dd2246afec2535840a9df45605956f40a98c01e5f6d38cd309e10785a3e0eca636994c543e9a3d262a18fd11db94288c2697ed4fed25e3b65757983eeeb7f40b2ed832037c6743f5668b4f3889b2148e0345ccb63f77e5a7b38f7c55b2ea8d8667f00a1c17ad858ade1401c06be003ce9796a6b1351523e34531fe73ae93afa42557bb89e6f35efe6d74a4d18907adab5914af79996e3295ab3b409af01cf2b6f7b654fe36b5b54d1b79254d06417620d9e5a06347d9373f2b717786063883b4d309bcf7bfef2c0c2b8972bc89dcbd891185ee1ad2f2ca27fb1c7e75be660dc03431e97d7948cb74b82c81c24b1b7d5e7de05fe5a928cd60f4b4cdd8645800214b330099fac744d263df6e4ef0a31c9a7d6c54873a41bf5b133e0dd1a3dc6068606fae721659a2912edbf5288fbb91a5c6acabecf0f909967f1eaf1e6557576f2f1fb9162a0a112c4fb28e6bc9778d96b4e7f6e72dc9262e2bfe6ce41d2c9823bba3d6776c920687b1bac35432a3d2a7904ff2c84e50ecb495561e0a34247fde48b8c78e58af95a53677da3e1c45681fa33d386458bb6188bcced03208fe58cfa551bf257e6b31d0943fa4ecd3cc3db160360dbd85d2513d86bbe9e9433b514f9700f4dde1e5bfe67c2a978ef3eb6b75ddcea16566a533d3dd3a10b148a82ab240c51361c03a8ed3ae59d5e979ed8c454bcaaf72cbfb423050fe9d81564ca5e184f59ef2983f28ac50b497ec63aa2d797eaab3b0ca48d5afe8747ac2511736d641509fa15cde3358c1515dcfb305db40192cc396ff5b4f12021eada01a2c137e87eb9b403df25302bd71f5592a318b9446b95799ba247fc75eb324d372a592a909b839599c200bc6217df00a313ea0e83d32a80e2278532ac427e4bd32e357a791504443953da470d1f93e24b304ff04b58e5bbfe44f65daec6e54d587a601ceb402a99c4d1990092bc296cb12df752459e2010414c2ea04a7bc321d91eb773eb1c8d682aa1c964433606b169b47f0745ea4b48761ed680b015e66721f1beaaa36cb8db7343ec1ed23a3b8568951d5333f3c7bccffa35e35c06506864913a7ac5802c1e49f875768faf5e342763fd4afbdf16d9cfb7336aa651aef4fbef4d07cbb845fb760eed1cb7ed1f0cdd56c1425f6dcabaef725b8eaa3232f9fd910625d7b96dee6ef58c3a5684b44e1e5a0a130cb8dd6a843fa6f0351bc6b02db4cfa57bb1e860a8b5731bb3a59577c6d70196cf555112b1cac341b757d912b3e91160ffb15a8e68fd06dfc9b2c1ae87a41e3df91c8a75ceeecafacced9c4faf9a284426a34d218511cdb753ff0d5ca12bfc173ed8bfcf234ca25cf9fcdc27ae2f4541c3f22ccd10fd142e884173d7892307d40a14e00d809a8eebad026fbbe55b84742df09c84a3069e47749cea57959825a8cdabb41412f480a56c8ec20f86645d66b5ca86afdf79f6f907252cbb80293f6f9e3c2fe36179bc05a82debbf3e742978f7f34835f1095e64b356408e5e668ed8419d726e6351bbba2b8800b101aa98727918e35cf4605c0e941ae0b501b6c014f94039e720f3c2461def35684811792225988cd5d7d171a4f95051cd381100e1ea395c7a26ad9e89783d37ef4df1802f2385624799a11d84de76d8c2a8fb4c6da01ccc60eeb89e84814a1ecf5a86d6aad1001c06769b38b07554ad8700dd190af97247dc0e76819d2588a22b90e1784f833977fc9314b3a57f2eccd265332a908e23a1fe849936c6024dabd08ba7e6a6575bd411b316f5a9ec5747cbe222b0cb328828e605549fe2fa4b224d22072f116f863c73dee4f6e1e6513622e4d5d6afa7a45d5a87f88a0c0c1e8f18ade21b6ebc91d201f5f0a80c8195b9a01a2055b085418af5c5be4456107c42ff8a8a3f2402eba3b58a07c49e4016987a58053c42d945b7118ed9d0ae8409a4e467df3322e2541eaef4ef00fdc56e31b0c25378db673052e50052ce00b4ae964b76d7518015dfeefdde3841fcdf6bf4b580824022857731918d814296686daa77eab3737b55eb8a0f59d6bf721ebfa58bae27391c1f54f5ce72caa236fc4ca1def5f6957cfc47f4e5f64ad25f76520a42ca8575fb9f21063f65d75741e64fbf7dab0004f4d505b4560d79064a91e69dfddad74980b7cf4eb8797fae95ac200396b71ed2a1faa8a8f6b26840368be5d82ea5c2ed956c3596227970384ec9f9daceee2e5de263acb5fa4a8f1929634c52ab1980d195eca8dc0eaf410b158d549d3ebcf8228a02302147183415c5ccd650d7505cc7e8793a8bc303b3c4a3f4f853622e5314dce032c9161bbc0dd9f447c5c56fbd7ca1b2341c1d7aad4b0c9460cf38b4b37e35c868d24e6d67d2cdb84122574afd1c8e4c49e758322f6695dd74343be826f8bcb04dbd5fb5f3784da31c466731c72abe355e4811dfabf4cde7b90a9c1e49642cd69a6c00c6fe1c73459b4f0458bae1c27268f3a1388d94d8e52092029bf200ae12c3ec9cec382bfe73c67a5e58650a0b6a26d8c9a32aca1ac9a841869556a3c18cd77415310be2c80520f4e0bd8bd24db4c0fe6ffe95fe5fd72ca1a12562c50e2b51ca979eb77c29c3421f8a0273b2e79296cbc0c1b382bb6aed21d6809569c46562e94ff488cad6382f36795507e3b0389952979c5b596b966cc3d9a0d542a966d06e11430ebc4e9060372c64de466ce820af7d12ca34a4015e3b2bc14475c9430b073fe7cd18736f9c3763b49835f5fe5c3d84282a8a65bdd1b2d77cce2b8f5064765e5fabf45e5c893afb626a6fec5a0ce350e8085792f3cd9b25e793440d4eb0416c2d8d4c03f02b4bbd6ce910d1b30939174f54d2fe3655e42fdd7c7eab920342c846c574dc17470d5ab55a00126cd85a34c50b8463982af270834db6e5c031f777416dc300ab281849939cc1c3398c6aff0cd517559c80ff093a26ee60aed7190f9ecd4bd3ca31be78429265983935a1e2ca50cad2bf54459c29816ee7ab7669611b05aeae056ef5500fbfd61314b612c945a3a79c28bc22c8ae5704e2855db24bff62444d05b4476eb119dddd583fa5e8a6417e5a695d27718cd54d56d1cdac77a62bc314c0f5059386df2c1d90bfa7277b4603d51841e73eb79f63d62347d39f428028e1fd1a93d37e9783c12dfdc1b419c1952b5cdee729f7131f7e73d043cad1f74f7f89e6c48267c4c25bafc992b3638ab6d26231a5970f3491da33ab4d472e6939fac0ce5ada62a9b4e0905af634d30f327b36309cae775bc778a4fc6c37600457ea308630dd20e49371af36446c04c79ad7f2a333cefdb894a8493d77fd311d227160a11b7fa80b8b96f63a2d14b1e299e73b17196ebe957bef0afab95a43d8e616c3510e7f79dceb36541428a1f67d2c32ac0bf680b8c9ef825e4d188725d8199d2496f09bf3b0415229fa3a225f74eee6ff3e54fc522f40031d1b7677e800bb23991b7e7b03f5c270a3b54c92d1304e1b41cac52828f7f47022bb0520e509193d7d338512ada4f974534dc8516d11eeb5742e5e20b1ccff854d2b17b0b3f6867a6427227b31c2e28dd018cc7b98c29909e848cdf5e6e08dd2b4aff05044a0c80e3677607a92406ab586e10ab741b58988681a70c3a36adc14dd11938b4cbbea66196d468012cddeb90173aea8d70d8ae782a1d675afaa72b3df59dd1c5af0cacefca69a7990ee8806f5a59a6604738880478d2f2666aa9e84afc015ca727b4507a206036aac70402b6a874435e1c25743b7a9f36371c42c4a37f838f1abd24a421b94af613419f40bae139fdbdcb8980284d550f1e7734e27e7789570ca679f491488b3ba5ae2552b3140ef5bfbcf25a13e39f349b01179262746d38d9bba65530ed3b0fd44878fae8ad011590239f6d316ab65271bfaa40b592d41df20c174a16b928973e273d61744a52a638c775e304871169df67a10113fba21e64c6512476abc368944d2e81053da4500a4235e427edd3f66d9b7062f0b2919470767c6106c8f1f0627b9d41c3d86a33b2afa155dad268b2d58e58a17d6d7340a06c4e2bf984911209eae1ee3f7482bfe35ac74917a283a6111b36b58ea0cfc25bf3116ee2f98c9172c94c81a6cc51bc584ff721d060d6f612ca18064469ffa48bcbbd72d04a6cc8bc7d2e7ddd2d94596231eb6fa56c069d95290ab1af8764e6c52fdcae395bad13bd04972953703baed2f4725474bdeb588e2b162f5e1b7a856daffc362175bf6e4dd617b6a673f70fe4b270a2ced715352e5a6efc08951786053163e87b9abb1fb4863a1f918fff63bd55f60ccdab60e3f55092706353455ab30a8e4df2556accd61b83e0e9cc60f94f7ace184c8a0c1a3901dfb06c47829c9ead2233dc075792bae0b274968f53c8738b338c4d032cf5293af5b593ca1ddf591cd73c2ced6fce2f79ceaea6e0318f1887ec55c8ad53ad78661b27d3795201f39d1779c73a7afe320468d2241b3c94c6ca52e0504c5459a309f0a25477e79a0a681b6afa5fc7c04914ed6dc078e5c0658da16a7cd9b21536795eec36927efa70d385ff4808c88a138c9d40134d4940890f9fc2b99404d08952b309fd6916039da2915cece6d13fb5320a2cc61b88d4e73f6807f2fae8c5628dc375f76246328d3f8a7a22c79ad1755edddb5a88c46610894a7b6a9d1efa0c2cd00a10fde39bbd0215ee748d311e394b509b1861952864f60f40424231b9459c839c40d86343b47d51ff1e70368fe6f053e656cb5f0f0eb079c130ac530e9a70f770e8dd34f3d57ad63bb7196ce4e166aa108eda9445317d6745a77f398bff6ccf73489d1ab1f7462b05343f470c6610ad586139cac9ccb7ec58ce89bd8382e2e52cc1af9930684e2d75923deb7314c031c1dd0d253db082bb7d7e14aab6b968896eac49d3b270d5a6ea1ec4963a7aca77365ce71decd65ab93ad588a1a7c294eab9671ca335e23083ff82ccda959ff29b3eeae6998e2aca9e024402b9890a098b2ee299c7f341cd5c74f94824aac34cd6494968007b2a44aa96b6e16fc6961c9ba1321af030a371b8091ba6ba9ed78ec26d3d85d4de3bf7587ac90c3c31e21a8c23f19067901ac7aa6026df6ed37d1b79ebb05cd72f31bb3444cd2099c0842009c5ed506750450bf248ae5399eb60180e12eaef9acea020ce045503b16124af68285f63b7c884f0771ec98853188bcdb6fd7f612d25c6200aed4156ce6bcd11e40cfbbd0643c441c4616b25a6cc2e677f875006b898a6e09ac269e23011250f7e3f86d82494b49e44e3fbea4214cb254f87bb1cbf72024929c139c27cd5d73b47240c6ea00d13c7da4c271e89a63382e8a336f386bfbb1e94a7342f8c14895e6da917cbd6cca3e530ed04450e8e5e237290495f7998caa15a6d83088339fefc6f69c15b94b765185a31282dbd77fc97cc067bb9b56e739913873941affc38bfee8aa5e18cb511b69462d847907fa19e72529b287901f83a5ad129fe1942055eb3053fe0969f44104d4433ee64098a71300a1f10ce8c918f22266bdbbe287b8b2d432365a164e6078dbd0b9687013887af60d10fafa6d343d12f63b7413d6eb06acd265995e92759789b0cee20210e9a9d74896621a24cd958dc0a747b5ce05b704545d8158771da970b04bc9e77951153dadb4d578b11c01f28f92832e3e18a4f032d1e193a3550e4aba8b3f63e553918ce20b112422edb5cafb0216db49dfd571b1b414a5361b762d0327770985d673aef77c8f9a8604a0413414ddb67fdd2e3d7999dc9a2f0f4d72b28fb4fe826eb824018d1b95dd7fbe4d9dee51809a152defb2b9eee9202f7ab4dc45d59fbf813e0948fd9dad708e2daf209c5999cda0c0b1b813ca5fd7189953de5903fa477beec19c3922cf3e055863f3357885b0e5be8b9e02f858fc1503def3f989aed782052753eab8bd623b6e8f98b14f4910661b5735041b5d96e21c4399bbfd7adc5838f451339543e35f6a2b211aef522b324a3a02b5603b0943b1c8ac45d6602485ffffeb72a4edb417073865b5cfd7258b00935a9b57a078f7c800083954db50a240caae868d41d04cc0f1d55f0fdc8bedff12bbd4b793073c49863adc140c7f150bd6c59cbb6d88c3cbeaf7c10136c64812c0acc9f7c8d5c7283587e2c0adcfeb8b74e8bd617e32e0dd3364180755d54b59b4d4c9a74e9560cdcb0cf50da0fded589b89244474f22b6fa413988458fdf1199b48ece5956e5a62a56f3958ad0132ff34a4a946c72ff82d390e962865bad508bff2e8a14e990920847f29f6b47bfcf309d2d3c4b8bf5fc55a651ca408ee643f15cca1611eaa65e8760d8a478e8e39399f3a538fad6c5ddb90db27422566997f4c19cdb614777020a40c56b59da4fb86dc3a48e0cff2cb1fba4aafc37ef44747d068b2f1ecc594c81dd32db3c228c3c06208594d8c43bc51773057ff6233053d6a20872c929b3390fadd918501257a4ae6582e06569d10d182306dbf4fe356b0fe837f994ae2d82d3a2532e9b1c3e3e10c227b087ddf232812cb2e4bd705c458733525c953d6848d4a6d6e99530beef6ddb462e9c32f369fe11300100feb88efab706129a716c2c81d745a0625be4c5a1dc87e942d0ba251fe64c9f3790dae3e20ba9e48c4d0d1e87ecf60a559cc6c42421df4f3fb0d52ac44595d013d885ce626624a9c3cb7f51f92a1e339268606fdeff6f61bcc36ad1956354db5b68727eeb6e9fb7bea2d7f03ab7f5aff2e660fd2615c4fed80973156800750f40446f02b69653527ed8366ab6823ca90d0e9a685d3c8cd895409dc742d02291b6a3b43095abaac42f96378b0cfba51f71085250968f2e0ccf5bb16bccae71e1b87de13327a6244099fbc9b91b3d67aeafb5d2a419cadf2623763f6c196ddb17d3498fda5fd5a9502f2e3a6cfdd0183bb100f0bca395b23903a1d43ca23a2f658e4b771d137d136bffd9a9f8d0184871c879a10dc0ec64e80415326861c28ed855f0f70cb4a63bd28f5aad3fb619f2b51f915ce492b05c66f03b1b51e50db2a08020a970522a756d1b63aab3881ee656e875c4f4a0000ae69cb92afc725ca2d6d0716eebc0b1874f1b102006e645b8e4968e618d496fd9e72ba3a721f9a4a99eab6719a7fa49723677910fc74b648d41798f3cb7bb137d09fc001103efd0cbc23f1662de54207fa2b5cd2fdfbe75b14027a412fcdccd0afc2f89ebc52c34f712ed60e6ca5ae7927e8175e7f965920d3fe28c75ef55702dd97ffb09ad450897aecfe487b57499dd9f65300c7b7025ee4cd795301b9664245dfd0b46639d36e77376c83e5c630df108485f9e6e82a00cd4f8abeca7f360af0fb590f78f0370233b3e487e90774b5f9fb2e086e4ef3b9945dbfb90b377f165c53200da85d7878ebc8144e67d0c7e7016883fbfca9a8f888ee04e1d49b29f25c9ef842008a4133a07bbeb127a417b303df9cf07343a4cad3f7109f21a3984da976ff13e5a5b11dfedccd0d7ebd950c3edca5f529c32e0144be9db3cbc5acef6687a439d5289bf3ec3f0bd4dce9309132d7d92b5f5af08ef803a7b401937e1c487ffe4bf36e014d2442cda5ef682e25dd46c341de398cfeeee1450124d9d7899311c2cf1b55e3ffce8250513d884e2beb4c16cb0408967b43e5bcaea7feb8b8fa8f8829da0184a036570dde608f010d2278ea63082469ad4f0f77aca52c738078767cb61563ba89b31d916eee3a9f8986f268ed6d8926efe85830684a94d72ead5d78b3e4135609988537e6afefebb46a7c27e772a74279a2b0e2fba6b8e4c87020615c77ee24840db8715e9beabc1bba679cc116cb73c2e298cf74bd45d07b7b7e069cc06436ab528f95d069e3c05cc16a5a10f4a7ca10ba1524b6a553131bf6a1611b19e9a5210ecc40aed452b4904da6294c8ff3fc2fdbd0695507aa54998fc5036941e1b0d9af72d6504ddb0d507973bf0921c74a3b01701717ea758c2baa2364a44edd8a28843dddd266ea1247ddb637c20fcbc71a31ecd8887590ed019c4f1c841611c6800da709f3b1d5be77d42c5e26384e411b9a491338f0cc249aba42939c5c400eb131f51db2072d5b00f07d3eeb01e70229516bf127cd33af584e6907e977b7a7273c0191b687c37571229042b3392b90ef884c5bd23d5569e1e49c00238d594fb33a7ce7d8af8f8f2189ad49d2734c8fcc0dde7444a0c644970670b05141c9242e0e1fed0c131ad0583d90e59eb42b12a1968f8354c4b71cdabb796f21515824e17db3d15c9d6bda94afcf615c96384429ffce054d37ac2f55fefcea25161b3f768d6b48355d858f5c97ab0c57549d75a2bba6aa81bcd31a862e9894e029f07e495881c6e5c94c2a89234275827e22b35a20e0ccab2ea9f892a2f7b9a2d716bf414b7a9c13ea44a92f7dc238e0c316839c96cff64b0b17b5472cd645c03b8bd4db5dfb5b8966c69be40a41492f56fe0acba21bdd7f1455eff59b7d01dce750fc6f2e14bc685aafc393abe9e7d5ce6f4184d40cd7072992b79d217b8433d24db78ccfb2f31343d3ff59eed47a02d5dec8a0b809b1e2acdc31bae698203df34a3588326180ec6c02a7522f690217b5bdd67992e0313e7a0816f24c4a6d898815ada4ea411fd7b1d84875830e048aa0bff28c1189bfd06f3560fed261823e0a929264b61ea385f6fcdf37f52764aadfaa70f3e7af482519df573d9591c5caca5b2a2689a3f47c218faac6598b3a85df84e806b5fc177841d0b0faa78511d1444f1cf25db5004520c940f57dd42cb30e05c267907df2f666df3d60d1fb90f279e9d7aad6b24131cbd183e6b43ca838f12578794db42952bb8057bc48f3f5f3b841490a53e25363c6134e276dbfe808c1b5b3db2c7376314e37f32528cd09a1e9f57f102f2ebe05a60d1d6f6ffd2e55f2cda6122aa2016653dd4d98027816f3b83d3d4de011928fcf115f1211953197462a9bb5af62318a3ef80cec071fa7a5181d1cfe58f956363b5a282c0be293fe670bc4541e55f73f21fe5c4b37d888d9768365cb327b10a66e7bd0f5f33279c7ed69832e3f1e2f989871b86accdeaf6b3a0eedcae99c35b7b1bef07974924857845ee92bd251cef2f0e86d1636eb65b1320f4c4c8d201260360e64d06a302acf8e1ecdc434a90a7d519bd8297b8e8ba7abbcf19109c8fcee73c484151c6a721dfdf8d912a79f1c980d6ce20d7990a856d58229945c280354d4dbb7041a83fd75c966aa731f42bed3514adf7a1feb109a8f3ca5adee1f80f0f7930095b4fba7e10dc9b7eccfe4ca1cd85395e1ecf072a114ea48a6e5884b3afa8839ace9b639990e73bb42e5f46ef522c626ecd7eace63ac924037b7d48cb3ba30b7b4cd4321feb4d4929e2d57e963d0df689167e892cdfaca54c45d0af42e0f72ca7c330238416f097cc2a6f2a4702145d6bdccc77cc63309ff25c2f6b733e6fe51f26b28993846506ee4a08150a75148a7586ba857fea166bd2ff438fb26e6831bea46d159fb31bba66e128668608b7ccf41af23161fd0c79effe01f4cddb87b4408b1702abf1693e30b60cb53e012f1a3a0787d3a1e5d65ff47661b8bfa46a0e0b899d1ffdfc93c087b0ff71d5ba6329b7be89e58848f22949588ef0298488e8055523b4e206823062e91a074a9cf2d14c7b8cf1a92d7dd7ef1b6ad627d47b4d32c069aa4292c4016804254d2c120544579a49958d791d9b0ad418234ba25c7cde8971d871dd01f389decdc922d955ceb2e3d0b10a8710361c64e2aefef85da6545bd786d544951bd17bda0bc91ee39ef358449a349e69bb3f32cbbf50b69a37702964dc320ddd35e8935370d072bff4d11fb2fd84c7b05b9cd409f142d54022d22f9d19b896716803d2fd203b9e4bd5ebdef3429d0300b52bb68fa1495a085290c8efcc03c2bea05b8f0f8520e6925a11f62d1b4c24b224a0adf95999e676486959685d269c7f35482099f246464ada8a78adfc36bf3f1ab3d2db6d5259a0e6b03d0036b35667bfbe69dfec573e1510d3504331adfeb50368b111793a9a3895d59496aebe51cfaacacd4987abc9c6137a58d6979953db7dd13b560c8f0c01df1414e0d3459de01791e7db8db33f50de7239cef24dd62792c9249a6fd96a8ddb6c9ee557c23685484e1d65033f5bf46f7d29575eb5384f36c0d88c9af18b6c9a30a9be3f735736fe9b4a2fb68dc967ce4cc252c44fcf9fb9cc37e5e8ce695949cc3df89ab4f3b0b2a67bf657244cd2eab709d38c63d9ead2cc5f108db948d098e81f40a702ceb3e45eb5e7024ebb7c89f9e9eef174ccad86df52f04fb1219b6d70ceddcc517848c99947c6e3ea04331d2c18d497d49a4971a961497f404e12f6b90a0e722d9c9372eb413fd65a2d09696403cbaa9ad7ad5e847be34f2e17e5d2c364c0e117a561a2896a28c70953c4538ce415710fe35bfebccfa20bbca1cf261f13106372d05650f978bfd3a44f758aebc29c1f055497254d586b1534de4d68991ee2659a6e95f91e4a1e2f7662637fee8d63c7d67c82e51c2fd945c86f85005fdf1d170dad3717a6921c9ec2087ef2c6b5cc670914634bc646a0a8725d45a517f7d17fadf8e15c725f37eea26cc46c315c9efc3b5d86989b3f718e7d16e765202173dcdee8a78200851322feed50011eea98bb5fc460d6dfebbf49da1d80ae485d71391e06f72c690d483fba8ccee13bbee9d43fa07fc2a681f1c1187091da95a32e3a14216a18760974eb67d60de7ce6e658cca35c0f9f93a57a2b084593056c2e5951b481ec3d20f75d554e6fdb61fe1e88f33be7689d01b095d84ed3aeaf4b3662b7f7eacb6c0f05380a07f5fba186f9db361d8da00a1a6fbaee952a41f0c38ca41d8a73c6c438f6426dd8f49d79e42db699552599a7d75083259247a7174dd83e11e3bf6bb388640b1566129fc9be7f886e2f7fb63026038161f081d364690e3b4ba6e4005b7d4668d855c1926509fdc7ebc49306bbf45f12f36c982721d05e2615f4222db63af0de9ccaf15630f512f2bda8aacd46882ec8ebcdc32a27a380c28a50d18fd19f839f2d2b03635e7722a57fd0bccda697c99740aa2fc3ac1acf29f733941f31ce934f6601a8b30d9ba79c8416a8f1654e52649e471424d7c2f2d3579e8e19fa461f473e2d860c0e6024d79e2ca8dc171453863df3f10d7c0418b818fd276831fe02525daa6c6732a65079272a9cbc47375df7882e09a50ba1deeb5f6500254ebade0fe56b112c806274b5358d69ea16342c157a3382c7863d0c073c620872a386b31f433e971d43ac7f24637d4f7ba7e21f7c295cc3d144557bb85915a6869c26db564eec98d9099a821b28e5c5fd9e2db50b604a9e5b2c8e82db630c81603c83b896c4ccc9fc198eac469ac93c6eb3f1f7e77114444c3bedc181983c26cf88627796e94e827e2f18268a42556cac309ff6021b74210e5f8d483e207eca280a42ce62c2dce28c0437a85d9ff5ca41d87775cd8414808b737bc3e0b81c79fe4847dfaf8c3ea7a19d7163c3c8bcb424cd2935b42c46645730b3c7352cec4fee24a96bf4cddaebb013ba091573686b7a093a63945a085e1654c166ed634244e51ce3a401f996c562b3e7121486e2a9a8f607c9ec828c6bbe6822945c9e1f2111bf2de07996769edae5ae84ade15d68464c97a6b6664a3a3bdbfcc9abcb7b4ed24e73367a13c577c95d1c9ddd7ed1503aec0032085eb279046ad88e276c3190ba725e3f49617b2a031c37bcd7d8537529e90c4cb960c10d22be43fa75b98e7ab7491167a58b36e695a1d82eb80540ecb2f6600f301715cf4c6c28eff18477298a951e51d2d463eea458347ddc405cf610971688b532ea0d040fcd001270a0140e7b6d2f4ab85a9f4e806291ca3fbdfa57c3b366677e4c2db48073ab6fe3898613506314f88a6e4c1b895e5e42794f235700e3e3dfe89b89e26f5890e4dfb87e9698558318df894505446f4866cd52429474dba90b06c727b47d2af5cc284d7f145b7c24c26ce7e2cfd98175cecaf5abaf137f04428c9944eed9429035f597f962c5c4bee4b18554c71ad1ab2dcf72903a505a13d468356dddd1e24fc73b153e7274dfb4a91764a5943bd9b5a0d170cf760e9d9a168699e443ac621f1b495704c0f4e5f2eb0ed65d3f35034af50e6f2a4faae27e0e5d83bb4b2a46b6f185ed298022ae11848ba76481be6dd9675406505583bf7144ca8207fa16d31fd862ea22bc696bff16e18e8edc0b9664d47b7cf3abcfa51d4c409181308bc9124fb3643642a75e0a464cb0a5888ef05c7e3898b04133b76e2f3265d907b8b88e60e45456dee0c3606533be26d371e23a9fa024f4857946091a8ca28f061ce4c51dd28fd94f5bf3bf5e64d89448ad02f2a56d232f3606ac7ef9a0ecb54d7b626d886cf9098c75574ccdc45d248995d5a19c5fb7dd5b37c4d6f0a25df2e0f6a36bd51fffaef6e5e7503603c814dd5bbbe0d9ac769bd1008c1b26cc0aa0367a6701becd9199b48eebffbcb03352f58426ef183f30f6c52a1e89dcddd481e65938e7a1b8db0c46877ebe3e64685f9ae0ac2f1eb9305e786e13baa157503fc4d0ef0262e2f8280ec16919e351e426b4028b4a98345956f97b4508eadee127fe760c226b203a0730928169fbfa5606ac34f0d1ed9821cdbdfdff4eb1c5715e4c787cd6e6803af3d08daec8de1a83c05a9a58dc03d123cf908fc11e67fe9820b18fe7f6dddea57b4f74e2b3970cb376048a22bb7d85a9356801520efa0c556ab18cb91112cdb3be727fcbc1ddb65c8fc87674ae19d855a2378cd4b08505edfb1a34a070c9b4877ebab54e719148e93ffbad1553a6d791f34c11ff240e3b508f3c1fc6fef19af5a91e5d265ca22a01d839a8111c92a09e28e87c5f766dcca7273aa8ca189facc0bba6da2c489943e2a20050611193235cab69a77f7937c42229494c6d5ceac0a71831307d67621bcc15c82421be854e5309d6170124f117adfcbb6768f4e8d282fe747060929c2c8eb1a576a3742c11eafdcf79e08b3134c31c52905c28e29c97340e97410a695b3a91f8f0b958d0fbd2a734ffa0386cde914144db0ce11ffd24fa3b494cd59c8d5735a840bd1bf61a3bee0736e9767a454434011b450713a4ae7bd3c4dbf186d50182143eefd9c1e931eb3dd5b771faf7400dd93b3cb89d679b5b7ea3aed49e48b7150008398e5203900f6320a5134ff44188dbdf54b5712c2d0c4f7002886180b4a685ebfb5d18ec2f07cefe1fc52491ab9883150e7a22c67e3193ab0467c3f4b1790ce542978ddeb7c503abad4c45556389af54f8c6bf462cbe753045040759af9365b9ab866eb79aa3986db9158facafd1b99cde67d9433d6fe4d3a4f7f48db94a15b3c8b4a2ce35543511132ed8711de5d8f3eaafd6116a0e2aeb7c1159052fcd1036324d0388b7e3d1b38c8caf1e9cd605921fdc30795156016f942c1378f3fb7af6c79eefb108dc1b0691d374b9399800717b277cdfe2f630da0a71b5e2cb3efdffc80e5624b4eb3c5a6da17feeac2376988038252bc56223e16a1501a254c08d7fb9995930aba16bfdb718a06c195a35e048ebec0efd3488f996c90fdcf0635db1343bb6fca947667907a2eac6db119d468a148ad5585b38262bbff178eb16112f791cf69721a536afca9b50512952bdd7aaf8af3d1c51f8a60b7ff1c2fd65c63054dbd3a69975a93d060f03b9dde4574f3f1585d898c2f6e9739c7d9218f79926d6e1ee65d7c2dcff2ad8bf88535c3c6ff33e5e3b51ae442a60b91acbd18741f217299c7982ae7c4d0b52296fbc3bcec4eb5a65f7b562dc5a8fac8a975f0c6c325a4c500bc4d597805fcd36446a5268d7682418db33a63c786cd15814f09e5e5a5d7ee6f4b56df203c0edf83fd0daf0319606561e39b7b2ca0f52bc9bdebc65f442adca4b27fa83814da5590c994ee7a97d392cfb2b7cb35e3db36258518f5ffa90b1061722fafa47c7fff59f7c13d2c5c3312b91b5e672dfca9b617831e50ac09b0353b87363baf6d9481d6bb307e53c4caa6fad20dbe819b558a3af770c18a7d32ef1a6815fd074c717918d5886129973732550ef232a0fa73f49e04459771e207afb5654e7c916f4c3a9007ae1500bb1302bc070a8e9b2a09a30223940f7a06635718ae6f1313bad71b9e197a67514587293866ceb03300af76a13037f267cfdf58adfa2ae4b1e899b944d5646e62d8c8e3c9b2e0ac26b67e4093749199bf97a104667e304e84dfe147508097189b16450b62900afeeff7ccb202a05708f54cbe2143ae7ee41c6643393fceafc09a8d6ea09c11252d65a54aeba5de87a721dd886f0e03d94c53ddc15adab32ddae527777074bdeaa1d15e67ec0d2fb132d6b99aedd3b4533f1c7afaa119b8fdd7746b58d3f886576729dadd4544d443cdc46af6c1b0737e7a403cd8fd032e78a9ef6a4ef2d1af22411e6d7856c20f87e20eff7f963c6569ae2a2b80ac9a7176db836ffec07586faa74dfc923d874eb63eddc11cf279d58131ac34a3044cf994d93cb722afceb518627cbae86fa9a228b44f80bbfcc97ae20fb56481c9e49c2b0ca2e2d9b45ec1c966a705a4a5ef37f46f9e586bb9c657d519ab6e07c96760d5bcaeb26ef2210880b6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
