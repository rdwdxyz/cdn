<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f49a4934e5d52ce6fa6fd92c5882f8d2d2812d3cc61df6ec2dbb036f86caa54c9c1d05b0b8be8c16a66c87ec735f7f440dccf3b6dfd81953d7875d33a4c2568d475c6c11579193358ee49d90880093525ee673baebf86386d372d18fb9ca2e0666e61554667e4bd4be924c688308d93c5b8472e95b562cb9a02c53817e82f220f3b846f75235d56615052e706a75dd4f47ce4e9217591f33e551da046ab164d3f759190a908ae346c6bf29aff667bf380c4bdb2660212051d60af9d29bb02a1d90272cc1dc2ed55a967b160a128228dec1ddf7aab54db274e46b661b67b8038a8463e604ecd69ec19bf4e49c4cb9c511172c1a4ada276683b5b13def79dc5469e7725ada83762fb2ffa56936b4e2dceb2340700bbd33ab90862b50d51cfd727ed8ed7f822a35593cddc1b3078d635be6cd20aa5da936c9cbf75932ff3205a4bd4e45fbd85f25aa858ac0459bcbf7e04f56e4a542f7ce19db382ae0939ebd2025b3c6609d9c9242dc8f61613215274905b588b775263949fb974b5f7afcc4dc07b6978484e1b45a9e870233ab5c7b9428934570d43f644fda442b602c07ab4562cb9867ee788f5d0281eee8781e327a18de41db55678a1f2d697e634b26135554a1aec4a36389aa37913d3ed2b6ab21c116a54ed146a33f0929629420f1176d84aafd11128c446321606185f02cb6c72b793573e7e5fe6891bddf9440a77ab838408c937815614a4572f9f3e7d487cddd74ba6d9c4b73977124132bc2831b25232265524be301e2882aee0323dc689014821c2d0df2aab181a099a0535ebd6c172646c4d7347a70f113e445732948a08187bdc56a75ee3e1af2f38d7b22231a757e93382835cc9a0be774643e3bd5f8bd1084ae6bb05099f45091493b7ddd562fd7765d78aa07ded81c9614de43318365a8a1a3fe062b68b4bbf1c5c86d1df7067abf6180d7e1a2eaedc38dd748ae7075af13c74f3fc8574ebc411d95cfde62a7b612e5f2f336ca93ab6fe4d219c2bc59c7423312b9540a24dbebf707d3e6823719883338480f7b77b32bb68d9f2c3fc03f337255a0c3b5063ecbca65518a1ebb5feb801a7e9a40650e0b36bb7d8f6e897dfbbb8152bab1ef860b456c00f0e527915a432cd2437f9d8c1b0fc5536caa9219ac45751d652fc3a97532d46ec0cb51a7dd55450a23ebf516f181d68e18b11e58272b514a35314f5e7a424b6b3214b607f5dbd5517562685a070c1d3deb0b968c128b3e0f72e59365fa3c4b23b30c3469582cf80b580f1466dddfbb18da6d8e76d34f93b2e5050b0b5b74f819267f14c7e560febe3aabd67594ec756d7e0557c7d69c1abf84bac35e75eeb450310c0970d5218540d597b0168e45ea505918c97722594e184cf8ee8787edfdf68e974122d33f8970e63afc652d4bc3a702664fa28df9de10d8f78ca72ab35fdd9ec52e620973687f4945f760be653f295832fa01e49daf1c0af0e028ccf357679256f0fd30b122b42abf2df36d578520abbcac9d4710b619321202e35f6fe18c93445069c00eb98fee714cf01aba7133cb72b288e3ee73ed67a23a877917d820ed61d4072c5a455223679df154c19cec1dc72f637a7eaed29e1fcafd266b8dfa873a65cdc44cfc0b4ae30ba07d5b165256cd59c95386db287b1e54a41ca320a6a65662fe2e0acfcc33a93e1a89fa11e06cafff9eaf9ca4a6250ad6f7038a2a4a5c9dae254a38283c809d5b7105af815524d39c0d8b534efd2b787a45c735448fd079851bf00a7acb6b3ddf70c58edf0a890d0ed437af98347a8820f1f123a44ead51f17615866171b13bd216c759a680ebda04aaca676fedd8d140db709e6a1d1444fab27b7ae24b6e5fcd38da9a69a70174817d789508b4008dc6e2381f00cbe439ff030b6bd9c8f88f621ffe1209193ffac7e41e4f5673adb091df05ad9739bfeb5b6a549339309494cca655c4d71481eb75f68e7c69b0e81417a5e702990f064a0cfcdc084ab3b9fd7127f9a0d7826274d60fc46b569e6909918bdd8b51ef430b6a0d1c731bdf322e1205b703a5adbdc76da195245dcf2626604c2510473baab5bab6572d09ab349d73c698ed805942db71e37ca79612fe9fb1342668b90c820918f0b7ed501965f74c26d9d8198b434d5df8f348a81f30081872e2782f558ed42902fd08afaadecc643088bc6945a38c323160290af0b31fa05cadaba0a96a32f1c966d250fc5fc23fd43e4d76c25fc73d3076bb0a8cc9eec662db05be67562836f478c68e887864f7aacc5e5d038185d7988c6a55380bafefd784ff9ab26e97b82aae8874e5c240fb1a4ebecf88a2cf7f5c717421106c971d41fa61fcc476e99c4b8a2f3869c53bc48728dc8a272cc7fe0dfb34334544510fe094085e8c0f50dc032fa955981f5c62a59415abdbd5b74239756cd9cfea6b1136af5f0f9e3ecf298bb92fcfc9852bbb366a9f4aed2ddb5ed3a084dd1bc267fdd02b68026cd15b0b63b40ceb45081c3a04ff72aeaf5f91b738471bc3a35a43a02512a4cefc085d261383d3841063dac3b4b24d6f764f7adacc0f2a4f169474784f27984cb71d4d951499abcd544169a02ea2ee5f9e7004516ecdf46ee4286f02f54d81425667b638a5e198295f2d5cdcdfb704c2f069261c07f2fb82e9fb3773222e88213ecf16276a23c8203b498e028e56f778ae76eb4ee71a7a4523bbd124f3bef611032ff55ed855186ce5114f00f89afe41a465e0c0bbe5bdde11f53ddf4833b8c418b2c4406cf7a3ac8bd9b3b3a7a1fd03a45be38e0630c93741d47a9dc8dfbe12ad957c95543937ad8f378d24eece7f3ef36bfd296013dbecf9e9d08e8ca7b10784076161e2ab65de8108490bc850ca237499ca479b3afd1c0416de1f89cc2c6916c36f58f38ffa3fcd3d33e00a1c266574ffc0dcc1ed18b0b24427911f780fb5721cddb921b753bb5915123544797a32981828c1a89ec08acdcbc36c289963f7cf556286b6f35bd67658a8c8c8bf90a34570c92d8012c2b656054d2504a7444b8b3cc8c0bc3b987409bdf4930111b3e9c045a4f2190d3d0184d13144160efbf74ac1e727f73afb9503c7f81ecf4b9016ff8c99f138457ec2ad602b5013edb70cb2cf8fec40b203ebade8bfea2ac2aad1664d46cd936a468f2cc0b64a33252c539b9efeab0a18d4c48367c99a4cd23bf735b283e336da7b01229417887d786e4cac6b5da07375b671ec56820abbdc1850804843cf01840b08047749a9837914facdc6e46de03c40619acfae619d8ebab031bfc718f3a34410b9f03198935c0fac94bbf8e9908c527aaebec20e2646dc81ea3d28fd2b4dd5ae7a3d2d6c476a45dd1d64f1a3d1d7976480cdbc8d6d63a97156f2686a7432dd5983fcdc82d540d4f0639cfbba3c27d49261323c881a915a0f388fbc34ba1d68d5bf647e74f2ec73482072146d72796c6de6b069a93c148701a4159d6e1e3fc8bb0e1ae5c2934f41b9ef290c4c9ed2ed7f45c421895d75a52415a9767f7ac914a65018a69c787e9776f63d8b49098b5d675c790a7c546d655c26701067eaccfae35bc68a4cc76aac0cd89efc46f5e868cb48d9e00ebb209bcfc2368e56d30a7f2e79bcfb281c614ad2c21f46e0583597586844ea48a8d561f7a901298f266db9dd64114bb778bb9062d8b3c9d03cf6c48d26e95cc1c77944741a24a56f962bea6113c1221bd9c2cfb0525ba3183914ffd8e5f196b900ea280fd8189dfa07d6b8f140b47f312bbbbf3edc03235626c647d6dcf74782c7574ffc3144626c4d0ffdc8f82786ddce8d64d9b77896729fa0e11fed9482d0bb075ec16d004383ea44340ce8e5be3b2cb70e738e0bdf04063f76437c6ff3b1334b5b0cd5d90d46572aa9469ad61610daa9117bef96d26a59d5a43c9b5a115c574d72afec774e2f1c3ec6b7ce57623a207301685b8aaa907385ee881f30d5264602b37f0629f774715d778301ec7853b1d86327541f03af463a42aca863fb10f156f8a3920e2bd11ab233dbd422570651d00b38662cfa81ca672ac13d43bfd168419c0769fee936c724b8656ff593ad20c8fa4ba300aba0aee4a748f5117a294f70a3611aa263a8c57b79c04755c010ef9fceb9b02caa26e2851a043c00c99fba91349935fb5190d4994275bdb7d563569a39f23296c6246f9d096df9b23f7080f5d529045e5c40441ab6fcb87a4f271d9e53570bad27cc08b42ef8741da87863e98d52363a2bca715dc3349bae31dcb59f5278dec6006631f165290f8a8e3f10fc07acc344085508c6f200cfaae9d87ff5b733ca282d281386b516557f7e3e9e5f296f4b98b0ae0662c45253a2cf042bc048fb74fa51e725aa44db69be9a74d577924ca1e3004e0c5c862a470e5ee0f8d9ea289660b3107a36067999272abda2d3530b381a3e8a908207edc4cc15c383bdec3039806aadca83aeb7e9805fb514de4b08a101281012ff280d4b2cca107c289270fe1f3c9ad3170b58a21de4d865eecbced30a3abf4f100a596e957abe638785d0b1919ddf8d498f2ab8d04a1d566e457d582e674ff06d9158383900820b019e0f9d3a1eeb1236adbdfd55ce70ebdf54bcb47854bc2e3101e736f693e4564e4828a2d8c6cb71eb93846142374d308924463b0357c9614fbfb7537708e81ee2e3c7cd31817a4ceb505846eba85ccdcdb2da4d52da186b14dc436ec94f0f2647e0fd701a2354962790fe643a9fb67383eb806d233c070306c7d43370217b6775626a0ddcb3881ce80c88839d24b7765c2e7a7b2058d1ae0b9cf8ed2025433c71a6320571e7fcdd8f6e787a4a640c2d08cd06335fcedc447f4eda74d5eef771d496956721fb657324f8b609adc34ba0b537e7dfd196abbc8cf5a0af3838712e8cd7f0c6f3a227f79223c1387315c8265194596f8f83cc930006240acc93c7383db384e86a6e48465fff90b78417909145ee8d87a2d71ff69cbda0fc4da1aca00719d0823525b0cd6951ac4dc7592be7d86f8dbccf7e4afe577479bdda02b7e764db53fa45b87515d455346ccc093cc78d88a0420506041611da61262165cb9820e4c12f1cf97cf80bc3a17f18a397f63c5fceb14e4b658d83293b3cf64cfc79c4c9db826fc62b3645a90b07774bcbc8b078cdac109a7aed6a5f164e81bb37426e51a07d80046c7013c8d7dd3ea6e17ab33114a99ca81b97f884a9d783fcf5b229f53f63707cf6c3ae24b6fc030b917e71392a8d6183d18cefc42dac49ce5d522d4429bfa3fdb951c205389a5402ba8302840b95f551a4236b37bc14a45b3f9331ce11f6f7dcfdc2ff56fe1e473cc1bf5263155b77c31313802f428a6f48edb3610e30e9fb7d8e757060080e24728c2798f263d0c16416af010615e5586731c25ff1863ec2c959e88035dcb7ed006121d9e5f9fd795f23e63154cb36824c0d1649b4e74e6792ec4dd64b0f7aa9af2b29b2a5962bc9402ced9ec9d243dc81b02c89d372f80392beac22817b732f5051df4b74f89277ea89be4b07904330e2d232cec4feb107e3b210eddc2991874589cae167b42bfb14b02d29783a96cd46227a9af715f931d11fee0c23af74022c5f108b611fd16f8ac0042bcb8a8358a4d0cf73dae94726c079291f7c802c2c9eb62f57ed846709bbd0be65633e0396c790f4b3234209b04ce2ccd59693f32573e3407d56996c71c92e96025404b6f57b1ed8f705cedd7c28a98a665f3adbf562c0b9a6700cd9c67cd17faaac01e084c5600b0573f567b2230ba4619f7ba8a0efcde006e8c9fb5d768847c2c97abda87e35dfb18ac5d0163d9e1b9bea8ca8926747fec1d994a3602ff118c41bc4a2fd60acd2a06ca22805d65cdb54e2dbc7c417ff4dadaa6be09351b5a3f16a525cbbc756ef5aa467ae95dd341343092384dd93b90f7ff0aeb7cba0c5d324aeec017c08afbda49a75050d337202460dee99779ac7ccb5bb7b8033b4edd0d80cba666e9933cd43cb2b2c40918b09fe673a33453a79cffe0f4afb49918d5a1e209c797b7f9cff4545bdb181eebf5b17472c18d7feac319c0d499eadcedb106500080fc5a1b3cdbf36e8051e5938fcec8c62eb80c6d5a397e70a9a942611f0bab933ab64920e0a7ce4e506346e90ac96851166c897d86e98c25e8f6a958f4a3a8767b4afff20b9b65b5d4bd0bb71120bd6577013d6511c94242aca5ea80dedd396530a1ecdd2a20d2c9e7f66db1d4c603d97d4d37ab8222f0fd4d3cc4394a1f0d56ff8512a17d8d0c6018b4bf37acb8c60cf9b9f18d1aaa4e596afb5f86216e2904b145b5ac6c31ef044de9638aad2a622b96414262294c138ac5675b6f2a34dcd43bd2b27eb4b868c7f6e10146718b93fe0dd82bbd06f1e29275c700c4a5d57a30d7daca42d9fba96027120fa1abb9a9772b25171afb04518f6821d2fc596e2306734ca97c5859cc81c19cef01f5acc3dcb4de75ca6ed92ba91e36d4b99e345ba7e9fa93e3b20127b50486f02f98705640afd98cce8b53767946a6ad9b3f8106de6bec01eab3f336822124d38eed2f4de882de4dc4f66e824e8d240efda7440bf300e8a9600833317d05cb851b591e078ecb9eecc74c75008b628fbf65a7a30b15c446c1cc8887b653bf55a6e4b1c93671b9708fee36a6fe6e1fb7c6fb9d3592ca82772c490350275aea718a8163e482aac7b1bc2b0327dd30f31da728a3dcb98fab560b761b3cdc9abe9f71c8dfe82465437431b4d5d7c05fb464b54a24babc2053079f27efc0746e422506d4f5ab36bcb115f7e861325e2df65bbf7417aa5fc3298b403c401e51bdbafa9a8e55295f36c1329ba88d9f0f044fbef4867fec6746578c0f5bc92cdd142c4e750c02b423003fc792b05d875081ab557a7e0a589437f7066f5897eaaf89e30443c60947cfbc519dcb169d85e3bb231a2bf2193545c91cad1da4a8f0bd0bc2925eb83127e172d550d3a3adeda0cc269e1b76816dc51a038c3893ff7d026e4f0ed6a7847dce82014d5e98206cdf1898284b3b9561d7769c711318ccea717d4e171a78963cff1630f21a557c72d850d5c072329cbb4cd173a44ff89a95a96c6641220c036403226821872a7c3cd9d54ab31e5915e27570b7ee751c878903b82130297a268b94b55e42570880c22c3c61b9b7e01a15c81589c1e6904a55796c4b0f1ccab928d6c21a14a2da7c5820f338349bdb92e8ec8c3dd65dd6145532448c6a7ef014fded593ccb104a36f77f9dea48d899c950a7efbdd920510c09a3ace94ce1b3450d109604f33e41f5dd2a2d2f00b732140f6a82e71c615937a20173768d9e02fcee8e650666e47361ef1d57a33014a17ccd93fd6c3571a58903a26ed5ef8aff2c13fc1175d99f374fad68dd8570d46adbd12679d43c123e00d2db6fa40be03ddb1ae4fdb128f702833f7c358bfe365d428370b684631ce89369bb251ebe390cea0d4e6f2982341ff36bf8e7cf59513a6ded6d4f4d4c9a870d9a635ecafacc077a0765f141f22ebbe0b7f1cd17284a3de64ae480dd0c665504b0d017b9eecfc9a309307e87f79e3d8c7b05f69402bf8866dba827148cc78c5c0096a42d34641ea332abce0232b45b6d4ab7471f61978f9a5ebfd3ec7036b130a2d6a0e80d77eea9d0586b0cbc98a11de21ae5050b0643cb5ec31d34f027f771a89856768e54fe61d7897b3603a572b7953bca12074baa3bd416cb093b8d44a1bdc2fe1cafe022da34eaaedb1adcceeaed1b2faab5dcececcf8b8cc406e3961160fca22d663182f2e080c4adc5bea2804f300b79f217f03aa7b5a7fd5ce8d827296f0bdde81f47d244aa54f56d1f958350ed998088c16ca1064ec633ed8b93f1a53a8feafdcdf1b1442c42f28436fe22207403853df031a166bb566a3b80051331e9bc236c112fdbc1dabf6231384774fe457a0abac3ab762a6f9208e0cc8e06d41b0a9c30655ee46de9919a40c07371aeaf69e8d274d13a5b01eef94db25de3cd67ac5a53d92d1d8951505ec72f8f92255fe5591dde86dd635550b63d701ea284e5601aaafacdef875a132dcc7a0a46ed8d0d3cd1c89639b79c577a1466744fd5a58a81c95af89106ad1b1eb4bddb68a87d781a5e041edd1fd28bb5c0cface25211835e1d5e24a35fd0633943254a574e6e222bc2195fbebb5737ea8e9983c276dabc787db005aa9cc216ee8bf4abbb45b060735e2c778d8424139584d475409f3be46f4e35a82ef46d2d4887770d31f5f6ce125c7bab26fb0ef9c837fe80f3e7fa542a3d334930ff9257f8544b58d5c01434653ada0a2456831070009b27f7360faa8036476a3e22f507d5d04829e195215217d4a505c803e7f0d0b3a5316cda74dcf087db616ede6abbfd13521c702781e48c0c9c319832b6b6f24a0610ec958aed020666658550b5f4e92438ad2439e5432f3262fa81ea6c2b781a5d954a3fdb70d1df7feca2164b4573a5be4249822b94574b2cbabc616e2834de9ae7cd005a09122b35a71693c2ae8fbb7c1a98da0cc3ff17fa78e5dd36ef6cc001cc8c7bc436be39bcd2806a4b70fb7d6dc241fea5752635b893a33a65ba5b4fed6f1190733baf99c2adf675abfb2d8b86a50e2ee4bcb459f40ed24a9c47b5cede566766b34f81d77716d56085fe62158f4f98fda487d9f751cadaa663abaa863eaf873e4c9fc132107c10137152237c62ede8a56b8fd60004ac1be1fccd9836299780149c2e6a516035bf48358f3692c3b91ddec80c65376a06c74aad9ab3c549fd52f4141f6387122b61db967166c81b20fbe04665f182c8c33831a1cd7eae1adef4415bf3fa370243b8655d94b5a20ce560686160dac6df9f3f8da8c1fe6a875fb845f59deecee32de8bf8ff01615696ef7dcd423144c5edc9b32b7838f269aa68295b0b434deb5569247b20f2578335854f60126c7764683b6d48687f4e3d3f8b600d4ffbb9fa3ef0fb3fa8addea3669228194572e58b1bbf6064b85b61dcff4c6930225d7a962b57192c325d8de13d1794739c3a61aaaeff8ff25181e650dfd03393b6b740160a88fa3aa99c044c3877f8d296e59ece0e8d2be9e88e59e51276c2478d35de2b182cb689f0ec160d3cfff9e49b9bfdd8574f3fdc6277891f96990c3ddc5b45cb6404aa4cc901fbffa432209a0dc0bfa69476414ab00deddc30148b196a382033e8e01ca67b2d6d03444eb7f0455c3c1d36607dd165061cd2149d540050f6bbe440b2d89c263cd2d8ef98c9bd047234620d467a238f536ce76707dba51b98a820623c1d7ef8d45f2c2f740acd3a4e606cc6ea7197b705aaff134c780e4272959c526a1c950b351dfb4b5574cf69b5c21027ac9422146787a8b25346c14d7b976561f24c03b41a3b919fb323c8b043851cf09d79c5acbf96a657e6094ca617248414b5eeddf15fa220f1eb14dfd4b79c0e8872a492b908d64718faceb52041ca9a186de435ebba86cae9a769fad601441517faa69bc3e8394f37fe26b89de907758b20c0c36d116dee7848e64f4f834b1569f29f046ecb148269ba7bb0390f09b58db366fe11c7e41b04c4b51c645123f792d9ac2684d0bb831dbc497dd8d64b3283cbf52c90a8d14c546f3ab2f31d276eb7aa849b7281702c7291f7a25b12a607e48ec801d3467e09abee47d96c64d8717c73e02d6029c55fc9e1b2d4685c0f6c01553ce0c45ab3933fe8ac725e829fb754e1986c2598e5fb73058ff622bf96ff5d6f3e7799d16c15ae7415a26e050632a6d451710afaa6efb263cb8ac706de498fa1cc1418720dc442b6db2b3c6cf3025e83bc0af654a2529d54f7cd3cd634deec687be188ee7ef9ef4955c714b61a7c922d4e830e4fb1134b54bd730ad8f6158de003bd83381ec1170cfbacbda0e41b151df7793bc170e5910a78bfb1e75fc0f12ce9c8a3d130e69803c1f3f022467a191f2df9c63da8359bfdc9c5ce3e8c7de9cf25dbe32ed62745dc3cb2d8df25aede99cf65784881c70f7128503b66d743d5cdab51ed13410cd2f3e90be8974282e98bcb2b34718861d2a17348399a55a6828cc6a442405fae7888f739cb2cf2d2d7d9d150cff51a36652e130ac5c937250de249c696d96fa4990bf5e47ce314ed9bdcae4bdce070dc49b7407d39d9e8a49fdcf02e0924e6fdf3b96b73ccf05551ce6eb3565147c1b1ccda243152d39c13ca2d66416a2b209a0217e709c791e29b3c3cdc3f8f4ba482640afa4147fedd18c2d85fcc2b64056d04a0a4b47592eaf3a8af2d0606dd76d1f5c37e9fad12839381c1a94274da3e1e3cc53004f3cde2514b0a5f0c1810e89131bdb2ac7f0f217712dc0a84cf56564a72c532fc6353b92fc74cf0cff5e466637aca5162e0b79786853ef079d99d84d797dc70d0ebfdbf724edab46d0e8bcc73437527f41aa7ce8f6a2602669e5252c2a734112c50fa135bbaab426741ef1cce4234338598d6f3bcd9829a7e60e0fca60381c38f8a133e9d0fdee6d0c4a7d49a66fb2c8cdf96ccc7c030c4dfcdf52c24660c66f630b911e314ed7a4f4cb7e0143ab752bb99c37c6ed5f0abac00673142f522f20c8a588576884dfc2fb17de35a99762488702ffde0f59f2bfe2c23c84097ae9981dd907f64fe5a059c86d1639c10cb2ef8e49fa65a557524bfac35d0dc9dfc407eee097366fcb2cc770f4364abfc3d6bf47d5821a237fbc56ef07b730e25eca3405438e19eeb8b4abdc78ae030e9d8b5f70744cc0a85cec6374d43731da8ddda77f3c40f8e1285a067ce8502502523c17a730d4d5073597c3de9e6ca4ed975891aa68c0dca8aa7b7d7c3af0cdd144c374465593bf34334b2e252b714d5558e5bec869f07c9d75c12fae34a958371e1e31225e7fc2ce0857b93e3c9c8de69641ca6275b235cbcdcd245f0a0421f25b4f98b12cfa0fb628c895ba7d56c67374d2b0c1927718943f940a959b772f5aee8d9183a8ea93f6270c9589cd86a7ea31e5129b651942d55a0fa2475b4f44dbd144754175dd06ade64b1c3dbc53f383885cdc9eedda057078cbf2022b9719497ae5b18abb8efe159aeb7e87ae86aa7306e746bdd2a0bc09bd81891474ae106c389c528dc9aa01ad842d1556f1ae1335ab0219c0c3c936b78dbb515cc3398a3dd5e8b37d5e8808af881d54466f3392e56ef0eefd5c60bd6ea9af762b7435679d3b0b134d1f751a12e834e358577caa838774a08eea374d079b28730bcd1ccbaaad02fd45e8a7a8f2a0e405cdd25c580e2b8dec0fea0e0326e2bc5f483f002aa04fbdc764b0ddab1137eb675193104e39cd0281e6dc13e86017428bbb34e391c5db5a2567c7c806b249f6467b48033f393e28ae727c7fe518e818d646195a1f89207677b13f3d419dd9876880c9ce3aaa16554db86e18941f646bee2a95340274f749c6f897186f6c9b50b2f6273f8cb4a746c140f5a201f86bf58221b8c57b003de974127d406b5447819c06969268bf80c2f7ce0d7381eb85624bda06c48d4b6a866645d808d3620f737434c1768a0059a3a4e4708d7177c48dca7b3dd1ec9299c9e735c24fbdd4837ac8b14762001c951b64033c39e5daf67b2ef3e9a04ab52141a7f65d1fd763d5c97f4c5ff525d999bca56ec723502074da87550d2579e4625102ecb3d9abde2214329049a134aa1de91340c3e9254d609d8d23cdb7e3ff99f166551e0599e0830810af5c0c78d8078391ba9d734df543dbfd12ffecd464d91e84053f62b7727c2d8681b7ac111691c691729189ab35380287bd0c4125ea1b407a77758756ae3f9e51bc974feab1f4900d487ecd1fba5b0fff60650669ad1cd1e2e8ce6511444a1cf5ba5af7d8a7416ca50bfef60456ec07214febcd72aeec49b524ef718222b34db4ab6a3b96c3758ec842eaaa83abd91db86c708677f02d271acda1bffa2b4332449725ef821dc34079e51ec9069157b6b0188e1a7547dffba1c760701257135c0817b74cb650b9811dd912f37c13bf89146beaa6c73d0023e4ad5780e048c6fcf98a542afd737e48ecd6141db65b11035098dafd09f00fbfae581231e2e9adec292ba06c46afe9cd9b2fb740a469531a6078d61c14bbfeab49e17afa3ac59eb9bc71705df937f6a9adb968e0665ecb2e96443941b0753d53aac68091fe59db9575517afb95b2ad1219d06c7968079879decd150ec39ad39e979cdedffc783022e37096f0cac1891a7f7cff1c003e07bae739ea02043bbc352f80c52317ae8dcd4393d377c35f8bd799fc444a2812e1447a125110487fe4d0c5f5667fa8d0efaf60d78b8833fd121d03c4e91a9dc8a45f98217fa8aa69d0634fa88bc943735d6b69b1f229cf996161a259a253f34c753c29a49ecb096b06afcb9a172ee63e108a25fbb5fa1aaf8615db060a5e1f044bcabe47d2896f2ace27eb8e6297648e5b8b2ef4d68e7aa08943c5ed8f294c7959e88df62f7ad3ecba7c539635a8c5b12f2b62967ab21f8754bff06a56d30f3c641114a23264ed9e8f2ea9eee01d3f244b72f6b98da2b90311fb5d7720eeef1abde2668230314e70db02ddee1202cc9b52fe5cda8728ad4c3e51c62cdb28f928b04463bd583e393e0779e21687c2e680f2a3546034b48c01905082cd80efdec1e9d209634a8b8bbb7962c5662b31df85185cbb50f9744ffc6f61208273bc9c5483c0d6e25b8362abae5e32a202a6f04ddb90aff8369f4aa6aee29bae8c49a55151fdf944224395d22c01e77fb4dc5dc4b1344f3d6203393ebe0b19160a62b1ae64f86a8d9dc63734c780d14bbda9e9257a529d78d6e28320e0194be855d843e6060434678081cb5e5a1538345ad390ef7a8d4fce89e969c27ba1b03506b5ea7864d640ae96ad92420c5dddefa4804aaee3d51690d7ac1e15562945473ec960a8b17ab13670cb53aed533cb975870823397d37bec84fd7ceba91b999a66099614c7830600ea31b691aae5e67f841aa5dca3490a42b47aa5e63a30d9fcf5c3a9fd159bc10eaec311f6c9fa8d99340110a75f3812f33842d79366ff3e6cc16f0eeee8108e6ec47d1737ab5d42b3d64159353c369e68bc5aefa6b380c4d951f21e54c6da8b5cbeeb7f465fd0117e06e587b4179e1da787612b1d6f3855731a9d883ddc06713914eedad5833afea70c9817dd027dfef20f421b6430915abb1aac99710dd4e79417dc3e5927a87986637c4843a1cecbc54d8797bf20f2aa783e88743e7e71a74c553384236ad36425c948864dd106291cbc7d0a02dc828fd59f442f01d9cb7e7af8ca868aa59af8ffd00e15a2296e55e5f01c9fd9a0bc23ca906254c8c19535d359e733716a67f2fdb6f1dcd2f0e9e074e2f51009ac85f9ee6c8f0efb7f1666d343376a708c4aa8430884c19b819ad80917145db56e3d774b76062ca4f1197d1d3c93d2ff969eb35144d0d7e1bbf72d7dfd86adb2016f179a0d699e384d4e8f3111a23bb9792e48a8564a997c826a41bc6ed2d31ea9214207a1c0f048982cc18ae38d11c7eb294baa5db57b913fc5ffa1ebd2252d2084b3240ac11cb3d4ee2565f048719cc3fe4d36bb978eb7c291d2132d5b9385c77eced5f97c0351f96c3b3282127515fcde14c9c34315c4e8680358ae8e608d03836e4142bdca96bc71dd161b1474c676d9dc7a2bb9cb1bc00fe8ec111865d1dc4c46834a417cf631a479f63cfcdf9bb0cf986674c0e5f71d3b438aa7cf644298d272f9f77c3e0a14aa4d9da5753e8e95806f75c3ded5eed3b9b7906d6114c57db557f79070b20211e4e3d589b2aede5a11d21944f57889c8f4013eaadf5364f34299b0a004a87936bbe7025a6f53b30a18b645ce6f148fdf0749d5266b2bc7a960092b6be6afc5d42e8ab047e9de138924477196bafbc793d354ba0336828bc4ce4e467c01fdf853529e1ca9adc2e76b51617c13932cd3a89ba0beeeca33c6415f27c9f0e71591882e35d852c3b657995806ff72db6d0addd7ee721579e999ceac212016355472b34c7cdd8545d2be0d93195030eb2ff621398ff74278f4ac3bed27968abd48a30c377e56a91570cfad7c98f7fe85b65f30787dbb02b9151d1e8c576608b87865d3f43ca0182d87396d4a3abecd162c35a61056087d372fb1802f27e96b77199cc7d833dab864d2d5cad26edd0469cc449c9487c4c9de408697eca4e980ced0f7182e0829923a6fa70427c2453629b8259240339ecca45aa9e44367c12d402d34fe1d99ecb18cf81003bb1b927cd20766059b6144bb1d4269bc1a393a43fc68072ef58774a9896016923e81839619101e536f3fdd994c49658a5cfe24b28829f98fdf112e06c37bdeb885127eaa0e1910b8b2997b5436eb689363dd5dc9ae32b83dbc941d92c3be14a8570f196fca1c8ee8bc8904d316e27cc6bcd62faefc624ad97bc249ec532f374d0b8b1c557f7427c02556f41cbae3d1e7d3efb3c25da22a7fd2639f7f92323cb6f8b12616a7e6051cdb9f9c598625a755fb9ee0709a419cd345f41cb84e742342776f865a49cc80bc5675606be66fcc0212208419de11d60627a3bec9d6deb2757ac1e5d63490367780db9a4a63cce52a0029b2a34dfc44c09e6974bdb02086a350ee3062eb7762ad13ef90eb2b36b4c615d23e869886cc6c770d768e9a4aaf77fffed3e6545edb3c56a72a5a98e93fb13f94d2f4e6d945b54c65e2ddb7c4b824d47214b01b64e24e2c2f7c42bbf302b150b3cedcd66400c9500f6c15ff210206191b94d32431e47998effea453ffba31058afd10c40350af1270defa3df41ee962a3aa3990b2d869b8cab440b8c9c055b6ad5b42ef739f3acf3219d74b3205aa826cc5240d6eedc3603c934d6147cf752f88d0f320276e9189da17ab8ff7ad2ea58ec437fc9eb6492893d3d74da9ed9705dd384a01505bf49265cfa49e12a9d98115e100223a53a0ece99d36f2208c7783a1bfe440c12d5d978801bc8b5d87359fc1c58f59037936bb641027203df84a6f1a625f19f44c4e588fadbd6a43750b19e120156cdcba5f939c6797ac8ee518d93423787cf4f02bca53f395d20d02edd703a048818f09cbf3b86cd9e8ae7815ac3f2e29bebcc3e88748008836e292845d2b594647f791a10c804e951f553985a81eedbbf5f288e48c0a865fd9aa2fc639aeea7402aee00c6949ec28959ae72c14675906e052eda5dc6bd9d8d204ef85e03b9d294ce871313bc48103f3e3863c309c17ca5b6d93dfe9b9cd3a4b5912f87cd488a8325c56ccdabec4c7dc1ce834d5cc7132f9a509710eb481e30af4b9497ba1ed528fc55e654662d6a3ccffd504baa3fd39ae5e2b5c302c34c032e1b58cd46b1ed0f5c49df99e7619d2c46f10a508501ce168890f1e8fcaeb952aae089305468d43bb2aff7c4b7ea4742a7a46f42cc5a9fd52b018be0dbe37f5d3ccf9b3ba4d81e039d58f3d2119bd4ba9b9ef6e88b1816247f2ecf51cd5e89f40e5a0ae9419f4979bb56674fd6c3b7d476c343f5b129229b7f81ff53d105242347de286d223a604275562eb17e12a5b9099fb8c43764e4862f040afa7f379feb76368dc454d3bb1c2ec736ae42f3960c320aaf5228e6574f9c3ea7e175d80ab788787cf96b45ce2f879da3588196a93ba7057945aa4be08daab6abd5f5d52e62c1f536a3f63b3634af7de6f511cc51efc99d66d5d1fe01a5ac91c89936d46600a09495c244bcad2d43c1ea8b484654be33e014c97155d850dfff8256c4b9b159fb8f62511584c4f1447c27ac714f24c6ea61dff321d63f5d5a6eaa3dbdd1f10f79a92765ef6dcc1fbe6f841cf7480a6bb3923b4714139adce03c521562b37a79a2a257150e8a323256b99dcf4331b188891e397de862b538f91302e82c6603ed652f9db24df4648c59fd85321bbd015dea7d3fe5cd5471e311d7573c5528a98c8d16d3933ff1182cc7de95df17970782297f940914ee7fe034c9618d7d17090772eee3f9ef84a287471690e0adc8f8f9bde6e9b31eb5fdd550aa05a12fa5535f367f42e782a9a6b935cabe1978798fb37f074b7c688904449005c018d17cd4004e87f1822bca12f74d55a72a03d604373b74edc1a13e2c92bd3e0c7419808349e1ffab1b3192eabb8508daee2bf921d22dbba513fd512917a5590650c927915f9c237c0a29a4bb071c0fd466101b9b7051e989eb370753e98e2a0d271ca082f82c4c38f2c731c552923272c7704f5d2ae75e93cd640754d381ca353101e9c677e0a5112c2215e6a70bae5033d878d38726e6b8dcf0c50dfd1bf6438951db8a3719a63ca01087b648cd9e9e56db7f71abbdfaf7a119e025aed1c9334b5e07af898eca5ea4737d61a79d381b1f28bfe84120ea8b4ac58b1ad7b28da4d1ba3354700ae5cb9cd287cac8bd9ff3c48db4463d3096cf7ca82781cda3ee1cdca30ba1fc81c441473e4f6e403a4fe3b51984bdf314a3ab2233c8a3234c7160987a17e0d8b8dc6df3d43a2d5d86f241a88227868c7eb68997f5f92f28693068edf81a6d8af50009d6d7929a46b450db9b1883f350995b63ce11dbbd897b3fd4eb4226f29efcc3ec0d95b1f5e978c021d3b609a24a1e5725d72db3b639abf348879a06d9258d8094b15470a1871c92ca7f4a5b88d031e985577c194a0a9a8a145413aee5790ae534515b76d56cdf70295987f60b1248b18971ccf48cdd5c15a3c1378352fff2cf86ad33b7f28314cab6e51fdf4d7eb41f0146a1927c0d351119bad27f4ccacae3490e9433e290c8e6186f7cc7b0134ecca80a14626726ffe8bd60c957b3e35d65cf4464b26305f34d9690ae13fe8ee87c3484bf854a642e4232c3ef68f44dab7e7b69951f7cb800adf769b9a77fd7d7558bf2ab6b9dde89312f2115a74f181f354dc03840e9a20f9f71557cd262946ee1f2ce3b73470254914e313b086d85a0b980131edb394d690e8ce4e0c37fd3b0af3901ceb12e0c6f0d61c03df306a064452a3fc84de286c98c0060faa743ca19431ce062b93f58027c3061e138dd4d36b5756d9971653f5252e5d2a789e1db751fee244dc987ac539758c21118cddb5f9cf496b4aeb7a32770c7ecb7223845776517dc529e9d0e1e3fbc275bf5daedc976e7804495915df613b350225a297aad5a01ad6c4040aa67e6af518e68bbf2c51663ed81313dcc3565a67a6dcca50b658e614d4af65e5ead005216a6dc6e05354f74878e8764cc0f49e193f7a4e6fd53c84b7be7d59593c07279edf87b77e1417bcadce94b953b1974085b7d6c2e86255eb630139edefbe44d5a0d629477b1371aa358f4bd110120224d02164bd62b7d922aa94f9d7e3124abe69f392e536e65f0aaca266601ecc08ea7cf2e7fa7f9a237225bd4f20656c37edbc358c3920994438ba717715da762db942d4129bf4fb3e1377e4df17f36e6cb7f3dd15de8c8ac1bdb1ffb1adc2279a3ba5a0d978b963f7bd8e9547841de796fa5d895b83e41e471171ecf93b6beb44b61e44f117bf79fcfb4a8e1d44e238839572efea219257d1ba082056c92b7adb68478df3598df0177ef94827d84a4fb3e6ed99d841d1f7e11c97ce72e523477d00fe55065d4d05c9fed23dc3aa92cf2104c04c51db68554ad2287c60292acc1cc25aba6a3713b295e8c92a1fc28784c47508d6951d05e54b5d0488c5aa382606a194070e80812e27b1629baf6a6e82eea3095b010344ae5d0f1df9501458eb72e17e327b00d5f3a03dac5db3700c4c18f027313eebe83b711e2087f47a81d01fdf263c2646886cca106e34c621b49da1243a455edd77c0681bf7e2810c201b086c446bbcbda40e78a6234b466fd8366ae066cf6dca367964a7897f7cef0cfafea8cec80841eb3075399b0101aac64e4318b631b114a33f7f1df2dd22abfd4aeb0d07c02ff70b700b77aa93a32229945183092b62c544bfd707c5f21f3735aeb81f4cfc53ec121f92eaddd8d7cced8db844c296678294d40dcd93a2d30ba4ce391bc2e81f18ef5cee43b54c11a254124455a07ccb87acbb8d4c71a63205600af893dd05234227746b795d1bf0b9570dfb4a5eaf3519ce392851a0d7ecbb7f7b13d3e90aa9fb6c013bbacd8061a8e4073a225cf67df328285a948a044434b0cb51982d3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
