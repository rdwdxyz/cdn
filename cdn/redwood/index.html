<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ada34bdfb32532cd8603a0970a365b66f97ae154d64cf3c6b47e0d0b9d9ecb767075090f075626d0c6109c0ee3f46653aaeb952172085754cf3a505b3163630cd7d9e4d0eea70d101e433917670fb9b2c2855a4528576e50935094741a3f06297d21243e5182ffbb4e03257bd3b61c3b2a1694b269a9933dcec4ebff79cfc7021561be44da92dd452aa4c972478974ba5f9aba2ce9e8bd47f0836b5c815f2cea277771e07ab2ae310828a7c1d21d91510ebb438904d8d450da274f726c696766d257ac1fa8a5b52d842958cb7209c32c3bcae24a980d23b26c57219005f6c0ba455514dff65d37e3ca559ccc592044308b2b4449bb0220b288581611ae7907fd88cfa77af82579353be0dddada4057ad96855f0578b355e128160053194d359ede572b7729883fe07be7403e5bf582d26c8adab22a4dcda1969aa822fec6b7e8322f273f34dab59b2aa8eb2da2702be01ee6a369355c3d57f4793de8dfa4891f47a44aecf6bc8d54489621ce2d26b6acdbd549f349f51ff8c9a6d80416dbd8b1125aafd817515d21e46e09f8eaae6316c054dff912dab536ca4afbd7fb3d275beb14fb56097b3f1f6e8473c70d85612659b95f51bc6ca71322b1dcd016f1fe0a59a3bdcddae34b3861a6eeecb70b02d52a6458263936c3e479e146b2efa804df44ccb6d7973f560bed987bf52846449fdada92869292d8a1b17543c6ed76d3a7451595c497b362d814d42a5afc22e29329e3fe061237b6fead54f305261b3ff5a3e48693e6b72c34658481f6481aeee5be2ff8bb0b1e9c4cd69ae72be337d1f038d8d335388346d0752ca0b99b0a7624e50200171353d9f7b9b583fbb18b11e001e8a4c0f528bb8993d2c390400a8adab258e2664031e5ff4d7fa1048c06bbe9ad086ec6e09718c09a80432c24f790aae92b8529d2cf8aa8b3abe95524c37870fcfb91ef3e1c1c9c82dd932e20f17d20c999006beff471ebecc7a82e277a24b572a9ee19d46f5fb07a034c6ff5bffdc928486466d9326953d0c54312d2a12f2c958f34be92d89ed8f938f650ed541f07cc47ce193c95b2d6f537804645fb8b06e95068aa09ad80c30ad79bcb01dbb145a107c8b8c5e8e7beab1d662f5c428b5d55c0bf9e161b9b3dca79292fe561dcdb9cfb91c662e3bf3617385cbdec96c3e54a508208a070cd0af9b7750de7486175db68aceb9de1c62efd9a004ff761a4e44a52d967d77d2189e47458d94dbe5924dc4a070c0dca1490af3857b0366d49325b32d98a7375fba977664518c4d2923cd28ff107a72081ac38430fbc21b694e61a6587c0daa5fa922f0fb35767cecf021e546d0d32f72e618804020358a88478aab7ee657f1efe3a4728f2b1b94eb473033b9409932141801a1e044267b94f7dfd57945a6437ea7a7628205df2fc182a7f77a94f5604fe6d2730949f20daf5a696bc37385f39aec04593fa6736ee8137ee7cb4a23608f0a467930e0d46d77349fc4ed3eaae318bc84a14e6e0d977033798cdbbe49dabef9eee5be382f7b8694ac6d3a8575c769a1f298eb09b4d99beb052105faf3138e066827de049c57722233159deead746e2afd30d1a0a7a663ef2a7b52a9dc1fc09b035d73d64e97ec683a66040b3d6663ff12bbcf3295964ed75593d836c81662836271e6d410374333ce3992769e37f6ca5726d3db031032cdf72766295e50b8be2f2fdace522e0810c9cb77e8bcd36baab37b25dfb3e541680bca83985c21d1a5e7f509daedf9a497358e6e95117c2442a37e95354258480bfc794dc07af03009d2d01ea8006002f3fcc25108408096e09f60395594cb85b65c954a100c51ba8fcbf5db39f8a835ab646a1f5c461fc8705be9ecbf42538b8197465d87540a1b5e38bea3deb441658cf033334f51144051b5e7a56eb07d469b483ac582529bb01c53a669f283235fa1971c8b54a3cda890294d9e029a9fd4404ff0a2bfacb6b398f060d26937c36dee7deb59515501b86d08c4382b9bf6a8edfcb7fdcb737debb232595d0fecf4746fdc7c467733d91f56bc7140fe5ae34487b61f7f21efaba02acaa5fa4b40a6314064e9576d3b1d67494310ae769ef0407baff45e755b242ea86025ab1c1a31eff2161846b9c9f497a23b1f5d4a2d55bd3ae20114ffcca2f631c72001c24abc1d542c80c56bd2dc6ec68ed505635b64b85b47a753dde29949a9365e60c2ccbb7b30f872108fda3d8e20cc18f01a0265f2b25755b35594808909c95b8efae46a934e9da1eb6c5031d39e7536d7ad0bcbd4eb77ccad15a5309217e155d5fa7c31e9d45a6d181e84f246566c635e04538a3ff1d718e40f40e49b92c15d511483de490756558fc1010399d5cde3ac69c0853cc3d408f7e9b2024b48c395242d97dd5caf65830c541055922e14498f0ec5a4524c6ae2245a369aef683dc32e27c6f9ee3d37ac11488cd192a8543bbbc764b1901555581479a48a10e748d445d742c014d974e9632aa1be5c8e8bb7baed39b6671a1a3c5613c83e0e9714b650207beb807b0c9595842bd267e29fea90aff11c19edbfa0f0b6bd54884d85fd0f56d3c88ac838369f0368c4a7f856acc696f2672d5ae4116da1a25e27b29002df6214d82fd4a2e02ca8ebb2c889f354c623112d52b6273bb9dd60b064cf0782734bb51863e2b7df683e15c521ad2a9ac5641f8ff6250d31eccd8d2f6aa420a5976d2356d3480a4ea3e48d2ad07ccdfe378bd39bdb8abb01e973de60078acef1c8904a4499216bf4e4725897133561fb83c2029adc0bd34659348f6c47eac193f0b6d4e3beeeaa1941b7996597e3612997ebf415a37e0ebe783c8fc6a1f97387139534134d7b4bab4382a1eb39310f85774d17fc1738b533e0bc34a8bc92ee9bbbe271e0cb37314f25c9a901c52f5e874178440bfd33c646cb5c82b01ae28339a4bd4f2f1046b40c728a9a18eb47fbafd797fb92a6b6bfddd2a31c3f2bbb55ea65edbf4e6452bc99a55ee43f4bdce1471bc40e39056077e028bad2cb77477e938ffbdeb0f0c72a96fcfe49eff3380c2dc0b3f2e7623e35cbb2e615c66f6bfbeddacb0985c08a58b42311086e1e0bee868a625e4827602f712aacb5aaba6daae46e3d3058b9bbca1245f159ed878c44983899db2deb16ef9d0ac0d5f0e34e7df36d53520da99a96973101e485ab5101bd5cb7cb466a7f42453d8ae87c634cade21c06668fb8184c11606b94a1b5f3915205425c863b36468db966481221e6dfaea219e6990a7faab7aafeb6fc308bb370ee7edb3de842c826ae04c01eb587fc21ffb6196655ead92ad91c7030536e56ea233a52658c1e72d37ab5911fc46ffff040632f4352e1bfc56ce97fab503a7a6eaf28a197c8683988cea0d71bb4081798c5f9f9408912c7179deb5eacf3d088f5280ea75c9f01e2deb717284520f596d93c84ecd122f9938f7e74811e7dab8a025d923824a6566fc41ae6b8ee12150608b446d7278d5145e598817c1c6b1c210127dde61f5775aff693c726c24636bc7c886553fcc6b5b484f172eebe6b5db42d49c872531b3537206f5205f33ef9a814a9cececda6195d1ed70be9a949fef5e5bc58fe37ff7d51f0f7a950fdb554f103a8b1275a43b3bef696fdcf7850dcb2026ea3e8a6542bc2a8b850bc99c941242986044f1ca1f651862824401d0ff6fabcf84ee27f0d09f28a20658a7438995d89b74e309fb4c74b4240078bb883ca873a5100ef90f5109d0a7c96171315051099461c2dc1a03b66605a4a5028c0bdcc4d9c8d807f928f6e0228a231bcdf40a76992f1341d9c52b2d0d60f23b1e70575e1f359899d1246a683c41a4cc41e8b5142c0a8243d25a0bfaf31fff4332386d2d702d3d8f411cc33a91809bda1ded8886112663345e5d16ea80fa6523310acf49bbb37fecdbded492f1bf1b2101025d605babcd1e4aaf10abc81e88d4ea207ca44d21153cf401e78deabfe2c2c900a2e36c925c3a700f3a50e7fc1aff038531715b3244b9e036d8bdbdaf819ba8365c3564d8e98a2b411bef6ca7a9887572d718e32beb74d006dc8759cd94332ba02c299e606c435b4104408113d8f9c9a8c52bb8296694a5e9c2ce16378a50298b3e1b24691c68eb394c63c2eac3df759151a39ee8d27f322c9848c94f2e624b80b4e21934acc609639b07e149450733657efbf5f76b69bc7aacfebce21141b0a75dd3d0a790985b1a79ba93b8d67ed16a6fe6a32f5f1e77d9d2a21883bcc7c27659e4ace350e924a0c8ec48d2716259a2aa0829d0559337e1580a6d0f5ee35d8d5ea2f6b168cfb6f8b7eef5466563d97e75977ecd1455fca981ed4a07d62f7cfc52b0a4d7344fb64b83e9af634a9621ddf0dc28db6a237d473237c6c70c86fb05ae9ba389cbcb2482dd8d6e0f4482cf22d1edd4a1a2ef42da55dd6004aafaf02a445a671517b56f495702daadb0369c90605720150315671808d2e3c0a7699f3c9acebb041d2c0248363aa4a4ce51cadcc4f455458d3ab53265374a9fe4cd6893387e28a8d6f8894d5d2295c76f88b57f7054e0b45f41554f60ad2139dd199500cfc7f5f1d80d999f8a3ed44c2a615d445bd7d7e7922c7754497c706e719e59479270f308f667755ccb84a27d34f80f455a181525ae2bd1ce9ce751278912baf4595a14568501e80db5d5501c22ad731e0e0f5b66762fe3edd7424335ca20f8784dde108ce4e15768dfb2a10afaaec4aa75d3240169c4774728cee5686169a399beb872ee3ea75cf455a41088148f82520fc93243a56d5b11b423784c062b87ff9d17c09e35048a7814838ca3d6b1f988270ff1611c4a3ca90f6d7af411c60f8ac3717e59418c72c0100de22c47c4b040855992a5ec235f989ea0ec9f700219fbd6b3863f461082ba45a9d903870f5b4c3bba480144600845b47a127b9ad19c564da59b6eec559520c9744d46f01948c19b1cc4c074d40e71ccc9bffe471dedbd920fb860ab4d6c33ac233123176f51f2d0383a93d16698fa67296e63fbb6b3aca54f8b08562af35ebb5228d4fc90ce70fe5b8bb46f925b9633166272a35819a44054e6e7a1550fb5847f07e9ae580430a7a0e95fc445cf53bad910c141e33c30d11212da3bfef60a7ee260455b71523e17a03bd00ecda6bcd213ee63ebf48756a57d27f9f769d27914130b78c8aa6daa05aaab1cba44fd1d36dd03bed7318823daaf9ab07bf783d4325fe3867ed71981a26ffa77e28871b0fd3d4a1ed6ebbd0438ab6c908901a35da47ef76d898d141c3c7d50bf34d1ed12d3c9cd257823e1dce40e9d96f87c5002b1e79cb5116f83ce828d81024f2d08dc42f4c94498af52e850e1ee9362e85c825d741ff039fb90570695c1512ad9424b3832ca06eabfa905f1a3c57c02401f2d6df0bf1372c293e6aef0bc7a2138ea411d6c287dd7d737d8bd90452a222588c87588ac92ee60edb28063d9e0e585d4355e9d205bd9bdf588c485e0c2bf6799222a7bf54e8a6fc5f278af7dd4b631b3ae6770c59cd9b1c1b08c229550fd330c0f61ce74e06f2d663b26d1e1e71d34e7a7aee05a07a793d43a76b1fcdebfa41f3fd5a97d199de69b0b6a79aea07d709394b3420d3fc1095c72d4a1db960cbf9dcb52ceb0c66c8387a8c315998ee9c781ac93f8b6614a096784b8d94befc375e30c1436034b856583cf7c139a9028a19104ec4fef9c3442efe860009c8cb8b2b60a163d873628752b9301e73df7617f479d285481e7b0036bee21b88cef86186d94904423ffac9b7c19ad80d69c9495bec8df559ea799fbe30b63d44cdc13acad696441042d3aee9639c2668e56eec3bdb89ae9e7c1c010140f3b597ca722171fe05d4e4d3a57157272380ef3134c7b5288f3e7d4f587a8397811afff1f8b30ea6674c29d2daee5e36c792e0d89ecd5f90a6c870000746cbe751e101b7ad7103b28c921e4fbc4b1d954e693a6bb893844c0eb83ca59691b4d15aa086276758e0eb8b5ecbf2235d01e5f92698402273ddd49108cb71b4a6fa8d0a281a28bbe5dc2eccf1181080c20f429d88bc9a0dde7011afe2f5578fc4024914da9ff31a1c97b91b864099b892a90ab569cdd19ba4c55e292362371826be502eab2743d073ea7d4886553076dc12b1384a7a1f3efa8accca8f98b549644c184b2e196e3a871958cb1fa1560f6e1b839adc3b7198bfad1696829999d7f661b2f3a934e2c341e7e130ae304b01ad95086a769156a9aa879a12284c8514105624770044ea8ceefa0d3337eee7b00c67cce34412ecb5fe60a2b9d4f2e2961eaa5dac9350666dbc672056279ce6b70a77b685f851e678135a7dabb836d40e9bf7bb81e502dfa723e6412fd7449d5cb77a9f204ae3918543e0e33bf624228ce4c68ff2338dbf520640f7d7facc1bc7363fe0c46fc80949f133a51f7ac3011908c17d47a882356249b3733d3f7a3f6356feb72405fd8fe9cf51631ace1241a01f83ef73b3c29815e8c74db0d4a140ea01241a826c44d920541f4d961bd8fa7f11f2b04517222e694c030c93ed65b1b2d987d035998c45ec44875709c06f0478e9a8087283c313a8221b424a69713066485f6e69996a5438f1b12b436b2c62c60c6f8bdeadc4a2de60f36d5a24e8f4adf1fa0839e3e1af0f6ee52b9bf6c6ed5afe801572b5b1be43d137cbdcce3afc8630baa9e196e7e56147e50a1ff7b84751f16caa8d718680255c362a15f26544a757dfda6bd53c0b509a6fbbfb68e23bb8dd5bb964e90e54a7d19bc2b64aa4d481ba1907f1084c941bd95e6c8597476bd9ca90aa2d811b968518d407bfd00b3e61e17833fcc9f07a17b2a17f113691e1578eb1f4952cf12977f3e80a85450a9c61f762914c8d696cc42c160796adc209d938e2cd632177a091eadba16869715a9344a0350f820a3d0ce9336ba71f93bbdf72d1f3f15244c5540e7f3d8250a094548077658f716ec21f47acab44147e74ea7676234b335975a1169dd17d37732600007268ffda5e0cfbc56955a8d2e32d696d992a6a70faa0bfbc2e5e2ad944feb7fadeb3e1ce815eab5c9d0103d9a4605ca676d6333f3c9c2a9f083ff6ba25292bc2b038b87ff32fbe8c5e8a49ffc3711dd9d895ca140d31fcbaf51cb216749c9becbb0021838df7183d272648d3fe54f6aa3d67167b17e6406bd732491f06a2f207d3bacde1eb9940a0e42685901b3dedf56ddb6e1c522279307ae454d63c6856db50341926bb3a15a20c96866c1d699043d55372f371b4b94a314149215a87cd9484a22974ff741e10bdd80a59a297dfdf2146382068463df0941b2fd4e2ced3b9a94c29a863ec36aece87ab67c7eb202009c126b966f2ab7a084c962c665b0f8089362b58027acda08ce9594dcc3eb9d7299d52f1350f45496444b9357c386416c8568027092d0774374e20e1579e7ea5bcc95ce36f72c4448d9878aa7ec3897872dd3d30ed0950a37bbb0a56f960184c4780c724717f607942a1d3cdecc13950cb55683b1105af3d1ec5e53d2530705f98620c2d82abdd8728fcfacab2c954d9504f08161d21c00ebe37ff1a407e65351a1dd1ef8d3cf1eb229472fed69cc8c57241ac0aab52d64179564da5f9f59b8b253d584580f0633f84ed4c1de980f8ec20a26bea2b5a4304ace407233e2b130bf3e6976fffcea635074a99fe0f368d506067f21425379289f52a85cdab124df8ce487dbe51ea6e58f51dedde41e1f86ca9d050f97aa7613d19814a65bbee486ff47bb489dc54bc58eb15b87bcebda50ba3e8a0052ba06df10f8ccbdcfb2c483f8681547e9a32e3db959b476f8e4f77c0082a0612c01d3a0f515eaae1bc3b80d1c6bb5c36671994ce85ae41760ecf4252a1a269dae80e1d47b954851fe096732449630600a2b3a628f0130ed6d0153365e8ce8bf4672b4ce17d451fd66fb52b240dbddafeea8c71102287cc7505696c7572d365c98c8c103a7d1e31f574bf8cdee2521c1a76047386566036c7e9d51a35fc5e92e11d5d1cbafdffa9e5b68a4f313762623979ed48dbda0e84c975bb04fbc2cf5a6910a13bcd3cfa83f845fce9e1419ae72543febcf08e38c2c3b5893acfcc5215a8d16f8703b68a4a960edb2a28812a7e0eba7f9f5847dd9a409e002bfc5711da40b139e842c52af9e709cfb627a527ec116460226dabfa1ea795e8b73f8f31416130418ff7e8ba550081d98993ee7f8c30a08efbfc7dd0e2fea90dc2626ec218d196ed5e799d7a728231784507bc7186de651458c6b7892814d045696b1a1dcd86867c2b42459f24bfcf9ddec97766a307042b0d77301046a0be583ed2b714f6b78dddf5d88e0c26ed1fe702a196da88986a061efab9847f096f89924d1fddb18b7955e6686f976eafb44e2fa7d989c4b7cd3aea2aa16c93612f6f1f1c4d20e16d566a48901993d4797a49945b8b85bcbf7b8fe9a2744a107f2390ba67e3b5f9edbc1c6224c8b31b37f2fc01360ca934f384349b344767ceee859897e240029a5bc2323ab98c34e6cb83ab3bdf66511303948b662faf9260dcd0ee5eb486363fc29b8daa9ad21303652354ce7758cd5c5855ff958c01e74bfc64b9cd0db6c3ad3c232e197227099a0456ccc44174dabfeff957f1d818a46a7eb5fe3cd4fca890fd8b538d05e4a7cab10cfa062c8a6f169012946da08417772983ff6d2527283373e894d484b423ef5c5ca33fdcd29e8d5713614ab3cf70755476f976152f7e88d683debe5231e303778a68a7d7fbfea415f935e78126ac768871a6f2c515e60de606cbe2ae4d7fe15ef123da29db8b6b11ae61d3dcf71e58893975c1f6d51ee80795810c47f112fc079f7c54e0a3f88665eeaadebe94f7cac530d0955587ef234ca72cff163e98a2ef51b0a542ef057494be200574e4b00d7d2cfeed2995d795c6e00493b6133b05994ad9144b6919575d0aed578a9f9eef1087bcc4a1a4ff73e093af04995024ac45f597b8a6fd829e41acaa3e2fa66590920b14021b4e2b3ee2ae4666265884b65ed6f1a7096ef1c141956b181d53371367c1bfa3dcbe2e63ce8870f529bdaa153d2455613d3b6a6f5297a10356588d0ab120ca0d229a7f77952c81ba2d9c9a789a15d3cc17da9aaaa47cd62e6df64dd3b48f211c5312054034329165938d2d33e202411ad050b127c5fe3e1d3bcf36fb7f052e822141bb29b7594c74155fd59f3fdcb22c6e1a63190c195ebd8b8ddbdca8d723b683edd6cc5ec4b1c22b6a9286dc430372b1926789068002a034ba8b720cddc79e21e43c7a2f62bd853483c894fc6396596ac459d9f26d0db01ca9d6b706cb59fe1a7cd5a7ba2011f44edc247a5c8be30dae8af6be1d866202a71f3ec4055d35661b19275835ce92a448331a2a8b2ce34383b74ce381a449eba1cb1c2c1113dc4e05f991d9d712b8b4e2213ff51ceaa43d8c918a7596a79cecbad3bd304c643991e4bd3213685ded08aecac0e71b32d7541aa1fca3f8e85d92f37a774f6278573ec17f56e2d9a663094c7ed202e771e08503195de1517d26a11c06801667398c943b90329a2ab4e3ddfa35c598c6f71b4b03e50a93b16a4cac7bd301eb9454eb0d9ce49f59cd77efab6ffc16657e6137c5bda5ee198303aa7af501681d23f42231b9c9478d17587a0e40b0d89145e4f62e1595e93d95952f74dc75564e8364f3305bda7cb51705747f835f50f8e40096b1d05e33a5286fb2a1ed8dad615a78c1975dcf9689fa7d471c1f88b564db4275f61292fab7319e47f23c6625b60ffc45ff3132647b0cc3b04627d5db841b7378c6d18d23f076eda3bcd5151041316b5177b3eaf372c0da7a0e2bef5935ca9a40c5e3d95fd1239ad22c4b888acf90b01236a703d3e0b8b5886984f0eb4104fca29fe18b3f9a5237d11fb045698cf66c9c1cc371bae42991c5feeaa9730213a8e3ba21ed265d5874f6e1b389d58400ee684d2124c283e4aeada4a107ea11af366cd0a901dd56d6a9f06b0097c9c4257944e3a71b1339fdfdf63a7a8067531cc8dc1dea0c05d4a75429977b6268a93547d6412efff71b19a63ff82a3e392ec26665ce4dae683e84a47e771cb3f0e4d44dc07e92495883fa092af1db6fd5a74d121d8f74223fc0374f95ce367cf9ba598aa22f82008a80c6bb78a74bb2b7f8d7e8a2da450b55f2ec98367a5c5676ec88414edd01c5709ddcf4a4ee23255ac196b46c553fd978936aa80dee2322784b467021dfcba8e56ce61b4aa37c9a3aae3966d5f65566353c620188aafc97e1c8ce62170200aaddd06ab0f59923103c13d58583e0c30d4975b0b39d19df8bb700ff9cd7fc3063242e3039e42942be82fbde1087f7efc0fc523bacb45f2d7b59e434164cf661e173ebf72a75d7c86cfcb526526b3f825c33bb71ef58c40672c82074ebcfa50ee84386faf5d83d35351b1f342aa9310921ea0f6d6a06bac2a96442ed1ccbfc1d7f5806f067019d77ce6a4af836cd93aa59be83ad2b63202869b8d5f7411e6e8417760b57972ea6cae6c89b3a9a84083c08dc3e8a0db1f0c905532bf3ef96e2bf5dcb07661cf88a7d9d1695d847796a9f48395a7cdd62ebd4558ced5c608e293566e7c6a6b054ea78c9e9d748974b80571db6af2c46e4f2ee9636588251abf94921a4a559ab390b1d2678005bde464ae5ad64ed2a8b6e3be69d8189d7202a8ca2bca2cd4c97df683e35d47eb3afc775d7be08b28589ef7d5937edd179befd3ede29944b209b0d7f2fe3c54e72a46814d6c6d9ff70ab207a4b2cd360504e204543ec7060a09a2105b378fe0f906aa2235f1c10f4ce86caeb3909fcfc5abef24bfbd50b5588988e3a9912a2348567e7901119b32c450f6ee4b914ec8d993a25d3444bb528e1d4492896969af2e37641b4828ce409c77254a4039789e8dc7969b1b20d17efdcfa1812e66debd743fffaeb222b66c4e3e4f9c6a205550f128416d3e5edbc66358cda4db75b1934e783fb1a880048603bba1bd9c19f7f65f8dcd601ad0feb3139a598a411055c30a9a7535569196bcdbc127db9b5d71b52ce23535442eb224c4913faafd5a6ee6df85f4b049edb6ac5cf4c9946c7b87f436e830065131582cff68026088260dc88d4f73f6e0f4fc1a9f5b113f9ce261f8c0ce06aefa9b4781fb44d646f3de7bf848570662944eae09cb8032fbd4e01d4f593f5d9548325a90dadc4d7cb0bcefedbe12c6d86ab294aa209ef682f2135549ceabdab567df3f34e9d2f986902d257e663599f31b89b5ff9fcbb6242d979b2336ec41ae233f02dbd86fc948873cec1c387694745c9f8d011dceaf942165961ed9b3460ee0c6d7f46bfc018f10230a9f5433c36324e72f775278f3e6b7104674bce2e4d7d0f520198437b5bf342e47efb67870e6d1a67f7babbafea84b3775e2f9673a88482be0cfdb4ea0a6cf9fc00819b344d2fbdab5b20b9a63f0ffbf2a602716d8485706669380bd95e984c1862a6838d95a571ea18f18fe39865b0077b14224558bbe444514d5cc59ad122f872ddef155f37f386be9d764127ea0cdf26e0fa5716fa4cd8a451bcde1b0ceecf00d9a041f6ffadeec4d1aeef93b2881aaae18b27110f4fca4614186afa076196c617ea9949d9168edc4448e1e6020940f4c1dc24f6338977d3f22eaaffdd24b015d5c78f6f4c485dd86e244a247a2af4033b0cb5f6120f5e7a8fadd0685faac5d4ee31aa664df0cdddbe4fef19ff4df3d55e80da05b1249c7c80dc6835a1ad38513ade1f54be1bb9cfe0fd4464857a16e9bd71b7059c6376d118a287fc189b99a8c410c123b6c6611d03c3689fbdc110e8e2c32582fee212ce3e1c541e8fbaad1a9dece6f5627ff2713d4e07e209bf284334dfa089916276a670bda41559cce59715a70f3fb369ec306147c79ef5345c2d85dec56ce7172764a1b09ec0c01fb47304db906cd8ae1f8bc273689961c66121f9130edd2bca8b1dab2d7f0c99282340bf511d55f89440e3345a5f5ff4e83a2f022420998010dcec45f1ee5f3e22b74a30dae74cf8717f7bf4601ed90196ba774c8151379cdad55cce49f8d841da221a2d4fb24c879106b036e23fecf844305fb9f1abbb41919fa7d05a206892c03f6a0a36ef156cb4f84c77ecf8e701d6e1cd41bac09fa04f4ff3cb9c4746e81e5726b5c3a560d6427cbf4feb843043f858a418f3a61b2dc7008943294f664a6a2aaa6407be0f4f9411b42f0bc9dad9bda3d3256bd9d4d75ac086c833c0a6ff2f4a253551dd40548669eea56d24422c44a6f661cc473f8e67893d3fbe833131b2dd0fb8980f240d1f52024a0fa73d74ab005e75af7f0aa69130f8e3b2801a4b4433d26535b0b4317ca9849888d862892367fbac22951893dd94ce18b24a07a08d98b2971fb47d9cfef3333fb3f0cd95e1fff154d1cabe1a33c238a4ae3a7dc12dfe4f07470e44f05490f4c0416c8d4e641def9fce8b3befb24e34b80a7b68adb8734074869921eb54fbca5de4df237b14d87f27f9325632446f9c1199d74dc1399aad02b4a3ea2116f2eea0c49c2b018be921704e8adf0511d45cf42f49dbcc00c4d6eece9ebbe74d1b1d7521025b4fd3baa10c631d793c499c2797f37ed0f0f5194f6e58485307a4daa0c13d81d7776c464b97a86fcdc53b34a00369980bda7e785223f2b2afb6f9e7a34ca32764b2dfbb06514326632c73c7227407626dc6c937121d4ee5f1df4c8004ace6cebe529544f693da23de46d66f5e8737d0d59061176776ad7c5401cf81aab102704847619c8f71f35182ddfefb94ee83d7f6b4350c220ad9af15e0a1e64fb1630839836837f36d609689e640c750550a2759be03d8c4bb581cc9a95722817b4a3d80e293a8e670f7bfceb37bc951082a92029b6a163e0158b38af122bad461ef2d2801dd5a1df4dbbda0f611804fbdd14f7c3e864b4c2e2013b9806da96e14b8db03c75015fe0c96c2ce2b8771afb93b9869d68e615dc14497640c183bf970c41e7773b466e163247bbe2bb1caac2aca2f39efb4928a357e17a5741f30e27940376a3aa7453529e2bc1df65efb169ed07a3859f7ec73cb932636503e7f93a4c4d0e0276cecd404ddd7d12d635c5e1157b656bcf8db71c615f3af1e27277f5f4ddc341ff396a99b8fa70aceec91018245a832c752c0ce91f989f6e2ec9a1744664c6625b288c33d8cd2fe46beb4674843de6b3a2580c78b732c8c7e45c71b87beb29ad5faa2f18d4a28d8e608ffbac88b67bab19fd600fb16288038fa7747f97a20ca1d626084b3225e7b1209a9b679e46e40c1a645290fae52d83dc174b1fad0d156993115e6e1deb20cdc6d433ed4986f384c23a069a061c47b36cf7dc7ef59a8e9c93669e2827646713b701283bb2b903abcaaa0e8914fabbcaa391295fcad77acbd79840e9cdfc103f57099494f521b962c5468660e2a066d9d8ac2b11d386a7dae832255c3c59bda3500fd604ed29bf3b67a405fa0b94936b7f10f5882190678fcc24eb26e5a6f67cc68e69e1e0bd6909c0c99e3267c33cd248a05b0607279e9b1135c5b365b10e134db939afca6a337a252c6803f91e625b493513ea69f7bf9f4ee06633b4566846539f46f23ac970b82d5b2da11daecb62dcb96dd30b53810fcd3d33ab4c3312064bacdf727c6d5bd6c68c26a51d925c8732cbd2d577b17701dba7563c4a982f4dea1e6e4a2188555cc31b5d27cf764ae25699187500617b8f0545c94a70194a43aa816374d71abb951f646c64ba29dbe2a80a1401db2c662fc80b2886f2244a7bc34249cdde6cf9073e1be09c2641a38518b151da7a40163c0190bc6b098703f0f98d2658ee967b1084084a197c2b393404417e9ae0df4dc00b31c1d78c6465f64cbf826921e2388ea1893863311f7b3c3ccf8c277a3c29a97f195a94a5583e7fa4b09eecd5dd39068bb5bf40f6a23d0a0e224dc6775064f52c7a24387ca2a71e0ea6a4426e27bf2b814efc3f1b5f318d63adc4ed603fa8a6aea355a33dca5e66533c64a84cad6736fb5e21907d984d789f092bfb7869e0ad1136738642b5866fcf3af21341824c602c089d1e203657a92d49d3421bbc3ec66f2cf223490af8234c884d2fa9da11ac845b6aa58245679ad58eeaa4caf8bfc83a3e671d061d48a3cd534801a8a40db8842d05ded816b9d1f1835243d90face149b2bd2d2273a0f8e65a329dfc55298e5865b1cff1d40192f0376b9ee717f54cc61733eb9a7623ab05a7061908b3a5ad544b73a5df3410adb2c3e0d2e058b77ee29cf0d1b59bba6feae74a691c29a824fd583d44d3072050c7430b9b22ac4be9132aa92fcb483a6b2dbc70851209b0eb3c4a62ae7f6b8ec8945e6a9bdba2c05361d14e3dab84814e0ed5ff01eef92ab74a154d19768219ae8aa7f4d627a30fb3697c9f302f09e881de23e140e1084d356ab8f1dcb62da15545474ad6dfb83cf89981faa35a0515e9e406a5348f5d472f84e448aa91f437a0a84d35b44f7b9653f9bcda3dcc51f459f070a0304c2a9bfbaaeeb4af242936b68056d6b05a66e546612f90d27ee19c5da53050b43e1e087864d0eeb86fb66b5831bce881d6c8e2f8d024b290a7e6b3637d6dfb97d265bf5858ebf281ee29b2da164a14c4b7225b96a2018909a545396ce37ebd1afa398ef3578d12b4b7adaf73b3258124b3da3775b412070977d1759eae7bc6116be671f06e6eb085ddf161450b75b3b962ada44377883c2b626fc9079c80595625ffaf2231bf600c5ab64c9fe75157dd75e4fd206505b31c73662c4c393f80f581f63e04bfa446d07ba48b3b3c024db35580bcddd479baa9503a9b610fe84cc6187b7be7c82583036907b18e1f9168d7dc9af01888f82a929290a1411ed0f94d350bb58f8d9157bb15754e162e67e53d85893fd51f7e6719e472ab00a7aab60d3f2ab51022a10a1d6b9e51af63efafd05418de06c6621e7bf0104ee97d01fdfba07951510219f00955855ed587d8b6c6bca364f07f5e577465e6f6be3e1ab5791467ed884dbd9ee1b00e001c6803556c1ccd087798cca44e38c2812a1930fac3687e3fc2f96148199a16387979a51c2edea9fd7f13a1d11ad58a8d5bd74284172e8005f85e1042e4d00533e502367488b6b03753a27200d70e3a3baec105e1ba40d116bc7a9fba408260663eb424608c36ba654cd9fb9e924e55f2840bd6a75971f55ddc7f399383369d3f2b2b9670c11fe24a391144b97e9b1085934e3c9d222c6318c1d2b5f9913633eba26bfe988fe8e643df0b3654cb5756463d37a7d526768d38b4e7ce41672acacfe2d14c6fe3f2de159f826f04e0b8ea894586b6e77758c10f0117b274e99cc6d5b86baa75f052e08275185662bcdae41259b66cf3c746f8a6b39bc76b20ac46f0418ee2c0a21aeb551be08667d2a9b46eff01055187ad9cf0a602dedaa5176351d3fc5567c3961568d6cfa8df669d2e1bf23f545162e2ca39dbf9d182032d1a1ee7854c664148dead120488fee0db51f42d506d991aadab48c638d8d63edff067197b3a7b1afba638129f5b3a3454b8106bc2feafdc1bad367b70b0e1547a251f97dd2a8bb2bd9df3b5995c73bf79c61d1d0c24a6c44f5281022df230fb2b12dbae4f3e1d0c34b18c00dc5603e649a923df7e4f09af798fc9396521c8fd45d8682c6c0d8bf5aefe0101ce222ccc6b14802db5247270188a10cfd235faa62daec471ccbde4ef5d533db2204075ab59e89ee5fbadcf90ad5039e68a7f15b513f519a8c669701be9ba048eada26f8dd62346ae67874088b73e33517abb04bed24567d4950fc191da4f829045122b154772482c0aced32c11ce1515f0f48e30ab589a1c4afe2603e8d62695a6fe3447ccd8fd1e01bc7050e76ffaf7b4473423b5801359ae0ed3c68bf91af1c6a70931859911f42fe8e6b4b11a24543787c34ab07dda160e58d1146bcbb3160cfe52f76499ef382d259461417061be44a2ef570a9772b629e80a090740525e6e1ed75770066c6bdf81ca7f4cf031f8c96468281e7a7926112e15a137d3d68f4b9e7f6a4f95498797931077c8dea135ffc09369a60612c78444174621ff91afbe84fca125d2f05d4e037624e75cd623720b6de9b220f51f44fb5dad528b172822ccc74bf13fae3f8e3fad12b1a3980ffe8af49610999c45e9b29c81858c52838648b5031b1e029bbb31cf40bac700521d112afd8ae3d42fd2a63dbf56f7d015f55e69aa2751627c91e6e98230a1fd9cb7601e378a4e409b9f48012d358b6e8a68066706cf70744d5f5d1c2181e1a0734ef711d535f7f3d4aca53890cc78e13e4b52d90a1962fa808478978d4f57d6ddb5377bc9fb07beb85e2d2f865e34025c8b086a1c27be2ef6014d49341361592292f109d345f19a54a05ec29d2fdc12176c45384a41a2dcaf546284e28eea71a9551de25bffa738135f77dd3f196178e8e2313b63688aeb6f14a188bbbcfd9aab998c4996a4121ec8d50bbd6791ba7a1fcfee46b593c25c539ce414b8755b680ea405387e9baedec3f1117ad1dc5a7cc58c2325bb78c840ba4481c9a761ab147f998348bc0d3fb0a9b91b51b9ea5a2a4cdfbfa4d484ccbabe38ca5aefc7615fd169f20ea60cc0628e4bb4e0fea36165072baadea1a06bd240c0ea9603ee768e142d0d47155bd2186f96bbff62a98a8f2db4809e47084852d4f55922592f58e0b628d0ea192afc6a7f89c81c30d7613d21a23ba2389a54963374e83ec45745c5ff35cbe667444ead311ea4d905dcb80fbd0c21e03ab5c48eda24cf4b80403d35b16ba6e21a68bf9c3b84a635d68a56fdcccd0ce357015f2d7a362183b368962035e91dd89bf38c7cb82baab9e9f2caf354105441a290ee45c5569c3904ebbe204d76d6ad33bca45667b51638b6b1d0dfe15b9c1ff149ab908d71281e4548b90f74493d2a67bfe791011dd7f274fd4b196ca03a746274d7c3e39d888a78edea309fb0d412d2c7be67b1f6b1ccbed167d2e71f84732d918b0d220867471af9d23682ae2754be2957b9b9b70031e1805eb5a89942b3cd59339af3fdb32028b1389188714625c77f5c6bd51a2d601e03be1316a0e470b5cee7cec38bf09e05cfb689cce56f6e44320b1f432793d9bec7cabcec99e5ee8bc8d97237a3876a4ef0d6a25603a9e6e9ac2086db881a44f45a3d0eff04b8e2783bbd73f7274ce5ff66047e8a97497314133241f6e4c4db69e9dab0981307cb485463c324800f1a0efe0e133bb49467a92d5a235eeacbd7ad6d2d1aa067e58485a4fa6790748eefa2066405fc3a476bb7a89074e70f7e43c419e82325c1e1caa7f862945016520aa639c2980f64d217ade512df1d191fe4ced4f5174b3f430be16e87ae9d3619b2bc60da2af07be2d7da098652afde33a646d952ec1c00044edb99677736efa438311dd4ad32e176447dc249bac413ae9a4ee1b2e6b7d730b2a7cb12d4e052497301ece774297b7de27d9cc0ce5f2e86d5fec695117c8bdcf783b32f762b6e5f478e2b59b492e24c3b21abcbb87274e2e1da8fa413122fd414533eb3d311b5ca45daef17f11414841d32c525e9d4b6b4176d45047a5a219603b354a36a91b3a68d02af449dd90a2bf116f435ae6d4b1220a3cb73c11d95fa8a5f6848ce387afdd61937edc126a9473c94263d20f03d8c8b2c8307d7d4d5d53e71770ec9c543cb767ddcb5ee5fa6b5f5fa53d27a1ae407513a8cfebf21099dbf6a9d5b6690336770a814d19b2620001e07de89624caa3091360428b7870dbb50c9e56cc0b674e544e52416c05b07add41e7c5f70e63816e68afe58e869041d868cc02ab25ffb63b59ed961edb4027dbc45fa43a110795b85090ec329f2b73521c7927a125a30c5888fbee5e6c1f8257a2073732cc7ecaa67b90dc02ed9b0aed178dfc0c90d2912ffc12dba47802422402e143f86e39333474c954e94cb8872a496d207a34c625efc65c1d6033a698e562369bb9c6a59b45c3b7924e91c60fc0bfc60ef446e257bc0622ce3fbf7e273bd173632e6922872bde16bda14a825f51004f4e71d11bc7cec1d2991b16f4429b6739b7fc4542fff5b2376a44806f0bae411d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
