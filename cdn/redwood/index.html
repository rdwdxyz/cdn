<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f83bf0caa12ad08bd50a9dcb7e8b80794755fbd4e22834fc15c10d1d9f858ca91feeba9b98615c4d06b8b0a16c83ff805390af5a0f909c584f9fdecb2eeb1ef1a6f03b4fb06661d6585a2e887fe1b48e5c33b61afb062a5f9aa15a29cf1fe65301bb3b3e5ffa72d455dd3488bebbd18aba4fa49aad5db807798729057effe0db5e994d4176974ecb4613043d289cae6afbb487ab255bac34f25acf901efd4736431aa50c4813bb690cbdd7284829dd29bf265faa184d5378a07592b8f6d01c0fa1653ff83c75270a41a650d878d692d58d2b521f6b7460c36043c7773bec885b16f7ffa60bd4f688345bcca06a5767338d59b1cbcc807e0c837179184dab4b568fa1eeea92121bdd2d0042e8b0fab7a4a8cbfea72fede925697acdbe5f9e66194fbe02c541d6a696b59056ce99e417b1c1bca9daa4e50f61981c5f2c64131d39ff39605539d4507fc02dac46d9a95be622c46cc31575cac2595014cec5d4c040b7a2f3589ad1a6e936159d60d3f5dc0840d534ce49091affcb5f8246d973d7c6ae71f4b13337c6232214aaa6806685fa14c8001213c0f402b3685036fa12fd044e2a8ae9e102f9d4e3d1632f00c1d7c4c57af6b37305050b7b66fc018f6ab5f4c08a4caab3f4140f0c2001dbed8a5b837aae81338b7fedeba2c5d5158dcdbc5c8e652724d9cd4f1f3f415fa02e67700c56610a3a3c0016e8664b902e3ca3aad683a31cdab35e2cd4ffee42687284bfd5c99e0af878394bb57aa3909fff59d6f4acc9b4e8e2debf66b99f6aed92fa4a6f2b9f4978798de14a2ce11be435858aeabe4c4a099798400e500c6a138a590ebec09774b28512508c78f966419fc2afc365713e66d6adb4067dc3beb1957a8a9d58b654e3a23032bd90181c0c0a403503e4f37a17074a965ed6bd75e34276d45f3672a38b412d03bf0dc6d8da080f9df120dbd6b109b37bd9392aa68165d2169ff926cd3700ea50b65a8d941566e506780afc0180c1e43b27e70460932b9daed4e947dfb38a2c7a1fd45b4fe02c23f6c8f82d686d26c81741d638016fce8ebf8248e3c0439c138f818f7371a80f5ae6c62dfc50af066fcf91738ad174429b21e8a98a978d4807b4ddd357ff634a70e290db837932004f4aeab498e96dfacac39a755cd0e78a9a55a4a844718d95ddd80e7941436a0404efd8a6b4ed159659d95becf2aa7ee12de3670b9ee51edd72cd12745787bd2a40eb824e4f3d3b38eb34d7bbac07ab15305efa2a587ed95897c2abdd446826e794d0033ac1163d9988701fbc282c535f23bc3e1fc52b60e1f7cb9797db9bc440e9e69af38511165225d7a7a8df9dba16a9dd570b06a7f294907436a1f81a4c6ffbd857abf1ffcd218137ba4b577d54a3c0239b5b939f84f976a5ce9a64848865a02f0da85765cfe120c05a0fe74b6e961cb5a2a8a6917217560b25e805047bb875f67d370ed4c85e8e47db11f139a8d494b998e06eb4165e33e2f40564c997501e55b688f84e07e561e7eed20feb7ba491286da40b506dea7f140f21725c14679dc05c26ad80bf421c9e1ff522018d452370f55c49406942f16ebf6de67f9baf4664e969fea879e28ede836bcc696a4751e33eaeb6ca9f8f12f0ff8e6f69f9f0416dd5a91a175e21995039aff15f6195a1c92c86806b03e456fcb87ca1a82ae5c757c747e7bd249da43a2c28ed3746b053a167efd5bc9b966e1fce9d5c5ab53778fad3ad101e23407469289badfde14641d1e0aa81f003006757ff99345d9d32b40fc22791267b6403f2f72328544eea8b49b9f32177c6d3241f3cf9e5f135f77ff22033a66b13c062bce2d6c29a370c0d3dfe4b84da8d51fe9b712cea6ac8b68324a2467cd0349098542ae0a39d6b4f301674afb31ae17fc3a391930821db5c4e5a2cde25834fb849695433b4b1a9831d7b29d00cae1f3409625cc41d6c929c33bbcfb5cf1625501fc4f4a77b242a01afdf78c2eac1f028ce5594dbd2638b15c34ee90dece754cc194fe0e150063cce1831965c417b53e89d0c89d6e2bd722a1caa2ff54cf5f687bb3270c2f1a31d48fc85474c0edf7ac30b2d1f8bb616448717954e2d7600b1c6dc0b031cd4dd599d41d7b797194bedc24b7f9a2c693392086f433a135fa9e90a05a4186af7329a3d6b1d3fabc2e59d1f7adc1a915a470d3c2e1a73e2f13dede840a81aa311163a670ce62744939acf965590df906c67e4144ce79132a38c7279d01772f700282ab29356fb44461f5f887c21141940862f0baaad71a23f7b08374c8b91a6996234a5f716e906d9825fd5e9afe3de72ccba56ffb9155dee3d2cd32ccb23d46db93047452097e33718f4fbc44db1acba7bb4a5f9494a04c712fb6b31c4a152ac493046f0b048be4bf84f0060cfb50e78d5f921f777aa6de3e51b0e4470c1b85d1923d0b35ce38006d556dadf15d418e0fc0bdfb8d28bb9d0f7756dc259e19ab67b26dd170970d5da0cfd10f9d08eb8d83e5f569710da439b0f782193650ffb6eb76f503c2d1b89cb3599305e0fb15b9fde353464612389f37044a8508d1b210b489ef006a8419961af06cf96cd4cd66475f4fc9ce0f3e5da5418c5a92f6ad1d4f982edd6cc1283b8a6bd26728ce0429a0a6c07c1ade3a4e04db765f84b3d1a02ead467a53fbe3964380be56c72c648da94b236b6ae47fbb3504d8da1b1b5c2969d41d32f9684289cee8c403801c6ae63e203374874617eed65fb38feaf296eed6b1552ce66415a944c9e949f79b21e04aa8ebba4d799681505bd224cdb581b3c766931b2403c40dcdc6a831cf1c651ecd39afae88741707ac1c61b614283b52c28fc5e29f1992e3d4f36a7ff8c55c426759307ab80535a3e9f3d9a01dc3813ebd3561c2f0f2fa135d4872a5175e740045d20e95c76ffbc2b47d823b3c7b14807fc05af4969d06c202f958c332e8680bb1612c4d11bc180c20ecb5775a457efb8e43400ce33e5964d4bd0392ef06508974db5d463cb0ce123f079a1703be93d0809e7a4d3c0bfe902e7985b96d7cd2b0afecbdd22595504ea650ce8add46bfe13ed7e535f7f904ce8a60d39c45b928683cdde97017288e2db80d601ba9885427560abb75ad8d928c4dbaeb32aef189a1346cd054a1f777ee389cec0877de99fa4acbad2b6798fd95b522fb674523190b4efa6014cac5cd85137184de488f16f2bdf8cf0e8140855122d62458f8e8f62a7b15027e0a83944647989ab1aabda791ff5822458e85e1ac3d7d05996369e088ec69c7cd30815a4be488f540b32ef821e11c6bab33d1ef1674c815737c9f1676c7493e067f4bdcbc8a4547f5a7ec9538d91e416e0bdff7c288c4a536406ce67d47ae29c0bb3aa3d1617666a1fc9742bab2099e0dd0155f61675d0c3cc0d16b188ff0bdff0706b8bb30ffd204a3df2278ffb2af5c181389d21b2a0d2e9c53da4a61aad4614abdb8f01fed0d28c9e78d42dd8da882141f385683ff0c795adedb264b256b500611c71f167eeeac789ea0123fde1c4048a0e5ca5f1b25fc26031214fe3c3486a2444546363ae8b01319458029611dcf7f1cc795a5fb952a142628b87242e57c8fc9ac480b2dc984d5cafb9a5da1c80ea0d42ac7dbcd385d4897ddf94f5a62b8714502f3ae5a8c082127402cd6303ef9e47a7df3dd81b6c8a66fe8e76d37269e49cba96c98a1de125942cd46e2f8dbfc05bcef9955547bf3731294d0ca1ccff519022027cf3252f6a9625088b226c93fda021daf1d0e9c4ca586d75645869069039b35fbe5f7a2b907006362302673818d78e428e5cb62bb1d92cf07f03cd9030deb8dee335686aa0874169472ef1100351b9f454af1cada39b77669586b4d53909cbd47771a59655ba2a9aff5814411dfa68b27203e17ef0b7caf29b53121a710fedf5af948d45a45390851b93f98ea0430d79064ae00be994b1241d54b26652dab707b6545e37ebc39f197562c00156e69a2562ed4be2df7725b0926833fa16b09cdfcceebcf26419cd7f10a84150c47b9c7e57d136112d9d95f8207bdbac76a414d6c82c4ca79b30c910cb06e927dbc7a2df9206d029066dd3779a651ad4733dc9ed2145efdfe04f6020e4d2a66e8c2ac5cd6205c5888f0bfe1799945e2c3546f15c4285f4c30ce9f936f5f626d7ffea373a3f04308bf9020bbd2f35d7a4a1734ddadd141dcc6c96bfa3996d17a157969ca416d924dfe9783cebbbbe29b7562aff61dbeee083c68345cb9198074b2f1df13b14f196862bf35ae06b502cc668d76aa6624d110d1538c4856195c28b3cc1e36a3ee45ccc4e49ebaacfdb43813f36b3999a5618582f35e21aa25e55f92185fd2a25fe572b5cfe919cb595402d1b6735ab096b758e2b7da52523c73cc887f4eb01f7bb48d8b493604d9b79f474d918055bc18b13f0baa4e4dc8ca1c016c09465d5547c4f8b74f34a30885e2f6957a23c3dc720ebb5dd7f6e6457424a688a47012ba70ebb2c34dc93d76c5cd246bd4d5852db0f813761930ae9fbf4053a718a1676f22c17903ee11dd64ffb863c5b132d6d56a4d3bbd426ef9fd19b5c662e6544e329107f905e0d0eac2bfefa92f7eaa0b02ca99d6c622ae7efdbd1c72ab1c5758761797b64c382024abfacff4c4a6637042cc54446d035edf5a5ef866ac10dd1fc7cb7d00293ea6c907d5ec727ecaa3b17da4ed961b972ba439d2e738052ba03270a8ad48a19186159fdd4decd3709279ed6604e49fd1721f4dff74c6658d214b34da7552bbbd0d5a8b355cb7381ac0df1ef57cfa73d30b5bd25111d7fcc3fc074bae9da8983798f5aa316e7ee42af33cb2a3963ce49eee05dfe5228a72da6721a4d8a8c778d4cc033b014f20d92f68ea2afac4c03b898f187f6f2509f5f0a958b76aee249f5ef1a9eb07a2f164dacf2206f90b41157a7a89a9e62e6d32c121e6d6e0c720c69bc21dd4d3e9e8e90a1c927d0dc123c4f2013b606c845866b6a2eb4540d20926484661b65689356de8ef2861903d0f6dd29bb2dd1562f4a6466bf42d64b85a1a762035b3329980b0f41ff4b1e4af7ca0681da17a9af2825f6164b347fcf1f3031a04e07636542f924d0f631832d9b27aa4864a91ecf6bce353aed2531aaa31d9379dd5e5e8d6419c22a3721bdcb004a8ed35c06879a31a5db5f403c95691773bf54f6f5e133de0015c748378aa0abd3b8aa6c3ac2ea760032a0daf04649dd599e7261a4788fa1e247de48e52bc11e4672df48c7400344d3966e5f202e009858fb0073b2f41416b9209412a35d80b7777aa3653a341490472ad02ed510cfe0e434daae370e4d58384112304362763899f055f64fe6ac622910c5ebcd378da492b80e62b13c82733aa1ad6aed5604d56383f6e4e8c0083c1e4e4f6dbd733bfb779a3c3b93f0865db1bcbdaacf4997dc974408909da23208105f17e0106c7ae3160b89c2128a6a982966cebaae056d164dcaf8b91436242c8e6cf836a45161964de0c59713655734cdebf901e5f0707ce4856f264059100ec2f59ce7753c3324c4b04c4a661ef94a103582b49efdb8ff12ad3ec29cb2f680e58efa3bd7280c99674b3686ab980eb8e552dfacba2119593dfc37b4a3810b5f9394f6d25bb290204387ab8eae74d4c56d5d3c7fa3b5f489771deb31bba3a3d41610154b830575c7474204fad3a09d62b5cb396421bd307bd0a42277cd78a5160746143ac0329046fae40c42951621b31aee18f6193e6cb5f56cd13a5ff2048212c03342a81c45314c7dc486fab05dc2a829e0e0189623435872ec8d566e89917f8186ac70fb064b38be929ebc5073d67bbf3e42ffe35fabfd71b5e6fb7b626bce9838f3cfe11b3ada4f2a3d5a7e16db0d2776690c47ac8f9d1554c83c975157dbb8af50c184897cd322bab4b4b2c29f301f4df0c98f2f7d29ef5c162768b96e40502467e52d43f1562cf74f53213c53fe5c60d9a23227a4073d741ba8d0197eb163f93b5fdadcd12040bd8ffc50f6bb4c0b7ea23a22aa3b6ba99102c6d1a18d8cdd18e659e193ee6b00af929994efae3681a8cafe81ec1d4b57714dab4d737f26582b36b02e235d836a5969079e430bbd8ef53160aeb475bd8964136180c7bc60a33d1edc68b1acf3fec903d5130dd595372d6097e9542063ec81054538194ef9c15b0d37f2431aefb4d6f6d0f6558c6f0b534ea99bcd3acc1f075a058551493bb1682d0e0af11a042bc03424bf2f2605fbdaf18fe4da3c715982055904f8cc5f7347f97a5bbaa12066581f5e1780df777a7e626929573966b40e3508a749372726489aa6ea5b312bdb7f594d8988db907c97164725a904d208043edcc3cb1ae04600842cc8fedba2023de0a39f30add7e42fe1b130ee77b00cf0f48d10112177432427c9d58400174cb09091387e48945100645156cf1b5ac684bc6562bc29506e0369ee7923cb29764de7eb968f6413cbfb3b6680d71d771ee4b330ab4bd94154e7872815a78e51bbe0de45f6bef1cddeac8ac34a187985be1f74489ff30b638f7ba7b64f65c449215ab2a71d5ed1d883febf9f86f23e850fb11110893066f86b4d60b55bfe36689ab74f41a2308e3ab9e60d936c222c872062711594d1e91451e2e8482112397cb0032366b83090fa101d326177eacbadffd0fa963c07794355952ea362e08b2cf4dc1571f1ead59784654571a393ed9481b38cb60fb06283a3d5632e66f35a2207741c5f955601af2f4cb4b0eaad7a30dca7b5c97530e61c186d58204a58d36c9e854cce1477479398df6acf04f24272e961d47c2850a51cbe643ef9d1f88e1fcb4dfa521eae70a4f73f4a68c8fe81cf7b1cd617c3cee7cc53ec681ee98dd3837d5ca0463845779b89388cb427d18d5c0085128f1b31740e78f473d31b4629b993d637a4f8088099bd4824a4e9d4ff0e3d9c8e1caccb9a1d270feb8b16989f25739aca4cda1955fcb637806c9be0cfbf5cb9b09abed50b35f01d4da5db954768956483f6527edf5bd050e26b7001aabe332ec43746db86ebe0fd68894ca74f397d4288092fcd8bf52174a5d2f9ec8a0bb7c60d04bc3bc9402b06b04ced268a86cfd069df9709550f4d476d4524ba28a33116acd1eb28dd893dbdea20e9e25ddba0c222a875b2074965af0f9eff64e627bfb77fcac9ac7cdf04aa6e35054862f5725e64b7ab8e44c0db2fecd6ac2bd558eb93b05264a662e981fae9240acff8571b785cacc15293d162b71c68bfbaa984fce50ba9bdceefda9c0fa55d805e82dcf50be276a7ac2f4db0f1bfd827c4ce8d1e294b27ed8a0220612df5340edd0442b2f5d74c42595428ceb151494427190ad79ac2dd0b300a1016f86a12e9f8775926c36c95934353c80edbf7faa6ff78a5f9386b265735823b20c7d369804c398a8e85d3ed671b8b615ca108d22a42a7d95e05aa0b352bbc4c739b157c6d36e6b54b4a3f6b67d2c50c07f2321187cd1d83826fe80dc4938e5a5392e5a1ddd5144d184c3ebb6983b93a44013fed3603c55dc1323d6aaab2e09fe26f6b75c2408c26886c4b6b8d18e5d2de8daebb8c0c1d5938d250ee8a3e1a41272a201cf2428fbcb7327736e92c1a6cd815f9ce7a7ee7141d8b9fcff49dc8de218bd689f6395cf61f00641daec1445c12b437d9ada7c68d9b8cb1b60fcb7698e8ad82cd7134cea970004b9e87da4fb890b209b4878225dd19c7d6ed684cdce6f2bb65f852d51660a9605b43364912f49c0c2179004ac521591f45fa76781365c4c77c76d3901fc1950435078510530cf8a87efe2a8123dddd25f014cfd7cb5d41df8815ca1d4381a5476e7e915c03b4bd9818414e6c3610788d0af2852a7a3f54e48560a43034c354c1c8a9d21b91f852b59f0868963209a6c061124f97b03115ca96fe17d78d3df2ccf2fc64c7b4061d5dd7d59cc969b6085e60f951adbe0f4dfdba347d114627bfa08c7474ffb2de625e81dcf8f3e225adbd864b1f93de9fa0a45a8cefb8bcc5d949aa6e185a37a8f3054ae0ba07d920813bd83ddec9889bb4e91d16dc24c9adee882b3649c9e84baa1792e5a2d7543a0da107f4988335b76fa72d562296b342f2ad1c140cc9d574d3dd1d8f29d9470c80b9b3ced312431f36a785bb83208ee6801729a6ce1f1c4b265ca4dc3d0f2ce5eb57374dc916439841217193b1f11ae345da7b3fc15de734977695368df3b88bd469473bf4c72a04e860ef3b51801b3ea71cd0f8989eeabfe64e47efff2eb73d40769aa1532caafd695d37e14e45cbcc4c7e6eb49de2b79d38e46d5faf90a0c961baacc84d3fc9acde3c36b4f50c9700755698dca8ef3471ec9fb8b401aaded4eb1ab4ba7e1c6d782b29d4cc501463879e4f4e4a4fecf23120782202d863e0ec73d021569e0c32a845f4d40f4d24ec1cd96ecaeef26ff25bee0c4ae8a2680f3809ef5c3f9969ede5e9316a49cb42f3654ac6f1a149662cf73fb2ce65a3fcf3d073b79ccd19b95a911846d59ebdc4d857b924f79aad5990e6699f170513398d3221b24190689f4f42bb5d10ea49d528dd49158bbe1af85f717c4b8dfa94485eb99785b491585378a2931df3dc6198a761344bcfc8c0bc933a797b52795d976337059b43f41f728235cb732cdc23c170d8c9b51d969df87ad0ac51baa35d58d050f2d8fdac1ba990a3d560a692952f4e1f04659f31d8ff7ce9e4bc6beb4b03ec073ac44a144613ec9878b82216d8a92596609476b4ace2819d2938cf9511b02414637521fe3457b2e3c9152084f4e4675c8942e9b2faec24ab512b8ff9298767c2aae76717a7ece7c6bfdacba0f2935caab9a80d3d6d51637576f50516a1537641aa87778de759297403185bd65f5bdc739985dcf799475729f73bdd689ca0e7ad538d0c4a50074acda85323f44c11a63adea01597a92c74145cd9f0bcb8c21a9261eddb2436a1ffcea50c602ac3751e04415db3c3c2781af1710670e6f0b5eed80b7e7f963bf93e954eb7d542c9ebdbc89a9f7646f7736d4a642f18003e53e30670417d005e3a516a24d8d453d7be27e8110a1f9ca89151d3a4c85736c0a5999ac3fc4e2d6ab189288e5990bfec4d2d0a9f13c0d9897116840741433e9e3e5e2eaabdab818ce78cec580b3ee93b3bfeb0a539e18453988156b26dfda95b899b2f0e87ccf6e997825249547cba1ca67af928839eed1d86df6dadfcdfd14c9d01dd96e55a4bc9fe81ff810e5a5f78a641b329f53fa6b955548f8896610565184ee09a731f36ccbb3cc84b6c92f0964b38cf3562677ee2e20e699933f9ecf9f29abea3dde90b9e8b1a4106a4b4720a45170f568add74d243888576db4fe6d47bfc05fe85f0c32a80fdc6f1791f69f77a65159faa190d9dea795f09fe93efe93d7758fee403f131b9264ef6e89c9e1d1f59118ee09e1da4af0af0bf513ceadac53680b80abbc1c3beb9fe0527464acec693345f982bfef299d079aa5e850edc1ed1801312c812916e39493ece65ff246d0c7fb862083095a109835af4b5e350d76d48d261a3dd2f3ce7426740c894a53872f9fc4113ab5e105dfc9e485b9c02174951a63c190a7db8bb58516b3b1a134124d523057b2fac46e39305750ccf8bf615c7471753d5af5deeb024b977666e98ccc9122f3a924da788a88494299a5f5dbe85ef0b684c29c663ebdb3ca407085b5e44ab450bbc34aa492d45c0d3a0ef4dcecdf6ebd9a2578937ad7b7fe3e31582ed15dab77fd0fb8ccb1a6cd9595a86f0524ad44c5c9e13e30fb46c848803354ea6b6cf4ba10c664c05a2748b8a9dcfb5ad6c037328cde93d3738b024d808216d4251274456159f42ce9568c2dc496e263c598342efafc6b78da90377752a5e40450deeb98f555e929265ac737d747e6249123488d97eeb295c74905458b5ba956408b8f88d627ff869d134a29b0947853c26518f0185f5796b639927797d8800b7e3069c7855c006f9fe46b7136bf49417a10d408c4e3379f9d6ffecfd51c7d8c17ed1d5a2281b77ca2addb1debceccf492fc400d7acdd412fdd42b734b573fc05e23a800b400ebed6782012fe19add8ef33410be3d7bef79493dfda5ec9f2911cc4ac67b5833fb430f84466be708e3f036ebfe87ed68e676873d8ac42f34958cbe1b9c7ce6d80c350d6387db15a8bf56b8dea1755a0f020e44d8efaf8aa418751f02836b7fb8cde8ce03b5d5f68849c464eb3dd45ab99e64ab1fe244fceb31a8943f5c46829ecefb3e734621c36b81c0cf6e3227d88281b758e79fa185786f11aabffcfefcc7837a4ec98346124ec36203d9f71acc88db3390c9799be38678c6ee8b19c62b3d8e999385cead4434433c4f5b2ed75e85f4aa445e646c27de347381776002b4093b6549c28a87e2bb74b95492528ec565779dbd105b74b303e3014d41b061787f88cd07ef5ae7501d5a83d3204559acb116325306edeb0cf81b5ef3b96801f79862bc623621844376e57a37d6db732376e27bc571a3b4b2be0c82a6240683d896a3a50eee72af42e8c2a5d145358206ce4857e9eee9c350386212718a09b201d08a541b8e2892c8e0d7e5d74ca5ba196b95e5ab99e5a7565abc827b9206b5b4b5a4bfaf90100efc38ce00189ff1d80193bd24f7eada333e0e05fc553593d26db3b1792e03945b3de39b36363765efcbe0c9e86262842ceec099d422885c3dc637eefc1c2b1fe8475d3d8bed74a5b901a6d00f24ed5a83958b4427d3c2dbbb1270bdc61c5eeb67930c45419c9221b581ec4f3add48617f39ee822dd4c13bba6754bea631911ba9b094a61fd3b68ec769fb9e9ddfe87874b709468dd19a7722993d22a37662ab740508f454ecac2902b058fe84db448bd8d7f8b3a060656c6f966d3829f81d0b27ed238858f298ddc55ca160248d6eb4bf932e5fbb88779e292c29498e7ea2ff0c2a54959f89f8a43955f3db727487595ccacd5b178deb26d65fd402849ac47c67ba85f0af1fb64620593546f095b8cfebe8fb0023a7bda29730fc1a5909fbc434403f9bad578c6325a4b66901a7a08358370312a3dbcc7cca67be103b8c5ece71177b0fdfceccc0d410d04b25af7ba7b7b2173dcdd0635a2e3615cb6140f66afae8900ccef13f754008de21f19d23b54b73b41782daf9507de16cedd618518e518e8b7edce3a7270df7230cc7a6aca62ffef418c4be3266645c4f5edfeca618d07eb80d8d018c405da7884f09c5446340a63dfea0301d1c748777252c3407d75bec7fb0020b6e80068a92f4ec91dc28b3c5cc5b2ab57ab7782a4a21be064a23506ce951bfef1e5606ca8504edee611c319cd222e12b978861cbf71c45178ccd5ca660ebb52ca4a737f2ac42ffcf8d34ac3eea6b212604386d04531a95c90abb4f3c05ae1fd071d9809c0a5f1fdec9e6d2911d770d7050982a5351bb17f9d37200b58f9d7dc380a5510a21241bd9e733388a40bc2e01e1efba523aa2d20035412510ef696752432dd834ac83632004cbf48ae93f6d1eaf7a3c2733a34e43b0658c1ebba53c6d93d239ca9320fd9ddf2be50eb66acb4e1bb52cddac3e0046c949f8d37dae05ae87d44806f5a917cb62f5e728d91c0deb5659c174907b0dfaf9c4f34f434aed17f346f1481be03e2e271942353f5b301d27c8d2e796ae88d8ba4621666799531de2a934a020adf57d2704d687471b370423a83daaf95d2d55c8a8f7cd664484261b255fe2be66be12fd7a80e2a7aa579786c6789c9daed107f518a83a2b86dd7675bb2eb2c3830752dccb2bfa8ffe4f86d39cf0463d05c4c14a54f307f60d9acdb0b55a216b2bce7ae1766fc1d23274ebb5b021789129fdaaebacd39b116f0f88f86a39a713f7a153cfa4a31efc3fc49c84831bf0d84849a570589d3799229f84d04b641fd172bb9f0b615756f6e529ba93dab9af3f76cb6c27fdf00413fe93ed870bc1e67ec043400e3decac0e92876a1d8fe637e07fbcb215e054806814b52f1c210f4a6758c68028d5d7a8953e10a683ded9be34d909afd07631e5a8709c78939466d1ec85c278cc9cfb4f59a6d070a95d4a0b23f2d1fe6c0f1b762108b655a088d4bcfa04025516d27d85c17ddf324fd2c61547bbeafbfa7f9afae6c3b9f483d7481026fe8859e57648a9b75c823b388b352bc9b6f4adc8b6a0df7ea69cfe167beaf3e85df47a0187d615c14a68b01915cfc5c1fd85ed64b2ef0f8b42f23f28be0456f11aa53a13fa2cb1d2e695ae93a765b7d5055e1fb97ee23f570bc0de46ae902b5078e4c42f74dd2fa9f00d8e22550d89663df7b16d6f2fadf7c24a7dad616e77af1d850c5a27dd7696cadd6a261df2afdb7d0eb620371f47f90473eef177d89aac8370067b2fce45cd993017a1a4a10046cbbce7186b742f831cfca89795150a8af27414593308d6c59fad8ef371e00f21f94b28150c5803cb37bb03dcbddee35cac1f6162c7457bf5e1eb167a0e7f3a5112232555d33126dfd2a7cf6a1a551f0089357850ae89c5d7af18ae99585a3fbc7924414d69ff4c167f8e4f34a9f26d358d8eba89702bb3598f26a1ef0f34db45cd48a80605994e30f448e51ff23090fb87b026f0325f881e1b785a491d106bd97e0f14918e4ae27e5f7e8c1be223083e009bbe00c10f97be954cb536137a413dd57d8aaefd7a5bda7926a418322b18f5e64abebca4a85039a82b641c52aabe2911edda5176e3919178e76fffcd2669f0e5a6275fb5faba4924413947f394b9561b8aa987bbe69da553f2b68f10b6f4fd0aacd135cf284657b5001fd41f7bbc9631ef209a2cacff292fefa1ea67e21e1c8d2d81afab638022c7de4b5b32493f07c6dfda67b6be8ef8fb77e53c791eaee054f287cc5b4f68baceea00b938fd9dbab262f02281272bd3105c843b75f6d2ec80e6fd32c16a7a687d4f890b44dc8f2f1f521c377118fe1771cd3cc0f54b9bbad1939d25432a2538e79ab8fdafdea89b5428306b3340d71896ebcec4baabe6ff4509b2d8537fec1cac942578a8c71699c1c23bc95b0cc3f79674333d489cd8460653db5ea8ccd42c454fbd03ebd9bfb77a2854bb58d6450205d40022d76d3eec5426611eea5d843e540af9ba3b7b5f2f77f9573090e7e8840921d1f864fb60d4f8e99bc8cae9417f69db2c28db0458effaa07222144a2e56a3b966fc63b36660c6fdabf1ff1efa13dc0e50614a9a1476ee3b3adfd22a1ed5ea7540e13fabf1c5a22edf89eabfc89e37a1f63af5fab4d82f952b89a83333a9bfacfcc3bc87636fba8b82ddd0f817309dc792061dd9faa5ef89a30b78afaa95a469d16a934c98f469eb5e246f899a2171fd58016c955ccee10fa74582c236637240b0fcfc6ddd89a17abdbd5362b37e3061b17e8228c3d781455da93c99ecc2696a7a5e372f81ea410971d357fb9fcb8d79870060ee2218abe61e85b8927a383294893a7a89b8786d2f5dff55b8652710d945867994333e667f8c97b1d18605eebfdd39dbfb3167b83299b94ea300ff68874aee8dbd1276c0605f9cccf9a9dabea670988737127ec5fc559617c661e6034bfee9c77450cc0855a14611708deadc0f3cdae89d365137a66f1c07562e12bc12313a150157b6c005c5c667b3ab76df8a561fcce62dbbe64ec404d0661551a5e4a8d7a9a3f0d89964bf8dba98d62145ea734288e2895bebf22fdac95e9e1e7387792aa61af72a0b3446f7d59afa5a5dd5b8cab3d70097f1810506d5bf423a652fcae1051a4b5fa27f1e1107814f5338513eaba8c0f122a6ecf5d5025a2e7dece7a52d5d7d510edaafc7efcc01047791c863fddb7f4f56709b4be8b5a042870e1998372cedea607b0957c3425c9175179a9c9469f6fdd99985b46fd27683aff905e6125aa840d6fc7a21437f5c7b25ac017e1e73754682a68b10bbf52b0365d0e68bbe3aa67c6c387256e7353a6db68d5bd44618fa42eea171af5e6f6ecc6c91fc66b9eb412f64ec2cd928f7fbd661440fc6eb505e6809c75a044adbbcb5074cedc659bd95c726f3e21a7902a07ebbaa74fce0707a0fcd5effc2e708a793fab2cb85f3290e0efc1789c93d8dc6bff0bb609205ba8fb96fc7a0727f5f198f281b06c0507019e589813063400695b8a9376164cfeacfc3905886366157f5e005cca4cc86d63241531a677013bf50fc0867bf1a23cb870a5d19a2da49f74d38effb497d2d00b40965d09a3a88795df2239c3434c5707c911b82fc345b27dc7a2b35500797da91a1be1438151da6e8f7ed93bb80df95e516269a9c8927a86f18a0bcfb8446f89d1c237c536016618f704496758fbf62a54b5598db2ed3d77f042f0815d2dae4ab138f84f1f0d824edf4f72c4786d388c872454972f7e027151866bb3607257be5dac4c13794c72fe928fea6881997cfc54db93f9db65daa6db118a948c9269f064a9236dd909160b841ab46780724aaf19f50e9cea83d12b5ab44de195beab67a709346cd20c33f14bd247ce55cb8fd7f9d6b76094387180deb4fe131905050c2db32fed65a48f10c15629d545f3875a85a6f9f1407ecc87bcd2bc9ffda87967f8fa81aaee78776dcf02884a1f9939a1ff5a0f731b58f312c96dd684c186f498ace42daace127d22b2be9e93142f6ce94304f9acdf9ffb722da0822cf521b370dfe409d639cd486d7e3e73d5858a93974742d2981aaebe19211253b0efa8629101fa91c8cc1f804d9a28946419122207ae3e087fa50478ee836e0ad8113159d4fc67a8160deb60b6a6b57380112c6cbb3684fb006ac82eafe605dae9f951b286e6771ee06314b64e26b5ed93b97f0effa3766d70c474bacb784ea3180398c13303792382377a6590c004bc56a093a82cd863e53ccda7a7605bd301e8124ec2c13739f34d0f1b6c2920820bcf7eb36844efe3be1dafcc2e38a77b9edf71226e11757ced3c866be4a85c572980ce71db754ed52a812f9c76b20306db89aa8178042586d95807dc532e1652d85224f47e20e86273a5fff829c9a1047aaa4ffd46d7ec4513801352910d759c7678fb6af73a5d2ee903e6314b7378da648216224a1c796a58048e64f25d94abeeacfcb3c8cab43b31b834549490afe42ea184ae23837345db544d9fb4af3483d1a251c844e6fa9ecec8c0526020f79cef3ee0bf6cb9d6445ad7b622f2ab8f5dbe9ad698ff2ba588d9f16bde7afe523a231f72459cf60b53b9ec3b0939fce47377ec059ec1b4bb732e37423ba61392284fc8b6db55dc7ab70059c9134dddf5a3b0669bafacc67a9f5316e3bfafe0d5407bf2ccdae28beb571d59b0d72dcd4582d161a4b80292919d23801808a8721de083c133a171258c4a6ad370960ba61039864255220664f06b04acf77e3ed188a1622fb8863b8bac51e6fb567103a3344e4a4cf32ab300bddb83d367f28781b676dcf9cd19f43cd154814e51992c8ad48f07104a63b6cfa9914c0185182c4f3af28f7e79547d7ba55109c78661c1fad4abd838e6731a13e034fc90791bdcee20935e0988a337ee3c6d9748199ef8a55fad272ed5a30d309f3de1bfea200cda63cab5f38b718d23f73153de2aabbd1d2596e03e4239691187ae76bfe2e787d2239a4afebfa66226c04b7559c69243904b1774f27b20306460bbdf4e001e809203cd17c403fd64d57cf3de96199468576dbf7591ca3a2c1004bea9a41e05e01aaca910a9430b8a7c794baff4f5271a7a1a97b87d0717a0e46d51de995bef12eaa3d652c7b59268417a890853b4906652b76f6ba8c97652384fedb4126837ff6faeb3f5f63ac3d4a0c2edf73121633e974d7072732460759bb5fa3d6bd89db9e179f94e1efd5fdc588ccdf808209661afbc4576be32c5bdae2fd468681d4d6db5789291b2f4a80170fdf661811529cb8d9793fd580d8bd37ed56643a158952962b2bd5ec6434e69c6df5fc4c86b19f7ba3d354fa4a410d07fdf88c7711f2a719465c6ffe75c190cd9f41abf8b0d70c34227ba6d50b0a7d3a4ae3711377c0d8e29e60b7774a00f8958b9553cce4ebcf808296a501e2a2ca15cc3a120723e77af61c85c4865d56c6d2c362fec82b2637e8931df289456679d90400bcd96b186e7fe853b403bb5abd1af07da04d97939c8b86efbe82ad4d349552feff37aa49baa277df624a77f1451d6763bacea72378d28309b9b289725c51b639beb74f8740ce7ab9306fbef8dbd82c9f30903b444f6f810dadb5ecc9d48f5176d4aa04ca7f38805a59828f3756aa6c2f60d85a0ea6f75cae5ff8471e5478f5a95b9d6898a61606f2f8554586a9c2ce27ae21b43e61ae782f0ac42f6931e043c31149161ccc036a1e991c4f9c71c08f45102b5c24266c6c0db1c217629bff343e897df8a3a422802dd7c6885696f1519fafd8b2470088d2db9187c677382abcaf4da0a0ef87d57c5d61b51433c49b4dc2512565058ea4a2a4579acc69d860004c51272f0d6bb5d63784f45cd7cfb32c72aa2dbb53ec9873132fb209085bbda784f46a14ce7f687b1932e8fe6d8b03e7875aa7fe27284be6ff7df48bf2350241eb8fbd742eda735a3bf4676d080d13510e9bd24553740fa644cfb1057b855696837b035e6467d22c1fae5e7a50de514f7eb760215306a93f5c12d72764b4a8452bbb422eb349759e20fcfb6e24db16a2000b6f6831fd8daca6965c5f6d4eff979bd488d33a6a676a5eba5c93c731eb550bca1f4b000777515a2dd823082ed6d07e2c22143a0e8b64e5b15f3bf6f7fa2ea8c57b647f3c7518c8828fed3ed03c9e3890299625d197cad0c0a0eb9488e99322105f3a4f82733621eff5ef0888cc3bed3dc2cc7bc3c09db67a8ac4522e8beb25521d1571c882043659ed381507e41ed565b1ee34de807424d1b990c584d40d78d4da5c93fe7a05f28032f05ee495f158485e9d39dcf06db0a65e4e1aab3bd1d2610372357d01cb4e9565c214c1ae8bf760d50bc95ad3e6803baa2ca05220fc6bc4c05cdd4597393f8e05ec19804c6e4a76074e7728076266d509634d73d0b95a102927f3bb225b426c5e6c4ef87c89dd7d406d0f0ce13ff6332c12a031b96b633a5f991b4997b170f42def36d77e9210838d6108a6d20f8846252f16689113855d8d3a492df2318e05ee0016f7e004d01ed8bec43dc5fa2a8318f70fe421919c2a5d370f001bfe2cd1c1f546296c4b33c74378a9669ba5667659d0a6fc082b66329c1e4d17a7e3131dafac0bb55f0627a5fa72c478cf8c82806ad3619d38001d87a7f8e61401b2c70cda59cd05e3ce62ddbbe91146e96802e03373799768a77b3830b5550097c823aa1571f751dafd7eb6f3f4e0ee94075f6b07d42b6a25ac46822e8ff1f1348087b06725080c70ca66a4e50d4a86893fb0025cd2ef4ba53021c13b797ede534fefa0cfd8ca33ee96a0a918b4826b9ecbbdd33fb6ec6849dc953ec3c3a105c1f710dbf5cc787d56acfecc9bd455d7539902c3be27da694c9359a97224dc1afffa8fe3cd0a39208fe863ab4736b08ff7e90f3e55ad93765fc8c288bddb45af654dbf9fa1eaa6c9c52f42e79f56ba8d7ab9db36ce6a85189adc4ed70ee712d771be0255e15ab8cef0fe79a8e5911ab05999edbd08681f275ee78643ff177fe6234adf2e79536cd199f9a96e35b8954b181d954516cec96b25ddabb201bd6c4591d1f3f6b5708709fbfab99acdb38dafbfe28928206d6df418b262a94ab1af962710f9b5e92b8473bb9a8495f1f972c0c9efbabc3467238947e5c771ec891d0912176dde518008737eec0e7d500f6e60e7597cb46a287781f46a6576383e0c674765770e0a3521285e2aa2b029df190c5310119fcbe13ace7b39484e0bd377e5cf3123af40aa43b046457896d21e3285ec7823e1cf5c74b6c4b12aeaf02db941ffc5dc7bd49b3139991dadfcd4fd7edd5dbb37e88b922296a34aaac14ac7cbf3f69b52ae29bd7986f251ceb66b92111e969f95a8b8fb4d24145ab6c12499b96b6bdbbc9863b907c8be81e062164cd57b2538a0e93e96164784af6a58193d2f8b03cdd691aaf554b5f42d9ccbc5f4edebed63cb79ef49c68748ad1b0f529dba2b5a58c9588930862d717e419ce77a29c29a20fcc70f2e08b817e49","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
