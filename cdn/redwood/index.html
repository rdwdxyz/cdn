<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f46665bd2bf00393a3235e701e08daa00915e4fedcc1359598e59b7bc66b84bfe253b28a229ac8b6bb1f72a6db284868db4f809d6aefc03f8157eee8c22e25d297b03a19b4b47563e1f4a7298d3ab6f1f6a3ae32c09b3699fc731982d43d53f736b24fe4a5214cd560c6ebade3ee812902a446e71ceb38c118b8fb09efe97b58e4f566cc6001e0d49b7859eb448b05c8aefc7df4d19b676fd1ac895ab47daa5c7741baf7017f8c9ffe16e6e1e5c204edf019585e7caee262dd3b4ec1526cdc305ea10e7df6114390cc7681d0b60e983aab78e33476ce1238f92fe495dd0f5af0a6599eb0cdc2337bed3badfbf1c291ed6498c3523142de368249c160660b5b0f61746b23dac6979b3ca7c083ccb53f9b9da4eb6cf228d0cf88e29f524d7893954401a000bb034f4c5487dd2d81af653f34cd42f62cf579d53cad856986d22e8f913cebb6584c2ef82076fc7fda8ace51d0aeeedf3fce67efcf7647dd47bbb88b8ed0b9030ce0a0926deb3042f742af32f57c049e146a107a3b7c7531d9854ccb356ce4b596cdfde7bfdf1b2c130e7e2d739bc2e63f52f369b2211e08f3449e88fee52ccc28faa2ed6fb4d6705f8f3878fac12a55c4c6a01eec372b3eb59697e73d48de87eb38cf5223cbf85031b6a3931560824a42fc2c858a4a31c2699f7856889c26adb5db5c29753ef4e1d9cb40641354dcb7684b762b5fe4670df5905ac5722e12f8df073215466146cf96704bb69a9c8ef65e7c3318ea6c8f27b8efc86d035247dcad2df5a23b2a4523cf1d700d6a8e443e65fb93a95f847a98414251af12a6c449734d1305f516a33de0d41caf8b37ad5a0063ba488c3e6c5b4b1cc6c9e5dacd90e87fccac5bc296434c7dc1446126727cc85ced17a2a6727bd0b6815337c884c87b5558f02a596a73677366747dd020e0030acfa430ee551e39fa194eb6d039cbefe5dec7b4b2e436bd5b76ae1202e861669df1fa8e7778fee6a50a842b87b433a4f26cbf725b6c62b494414d20d8fb8e0a3ca96050ff4a6b07576a885fc84fa52b7558340894b3adecba597b9195cef0fdf59ccd53d1ae682f28d5d9ec37778bebc1df91415041b49d290788fd8a1126523f70fa76bac5defd1550c7103aaca16c8e41b9f1e7da9eacc550a666bec34ecefbe4c54d4e0483042c2f56296dc3db652e02243238e7ac75d3e4475f9a48f09cdf68d689c9ebf36981c0c3123dbc104fd9a4f6328f903d079fb5389c4387bd2038e642b6aa53a761a93595d2ce1693aed78ce7ca49a105af49d117f4fe5f674c4dfdc4ad5650bf7843d86594302f99a62a8bb62deb4c6aacc4c80785c599b88263cf34d614314900775e83392644e3ddf0fa752eca9e43a1323c7a313d5069d18dd1f1da3c6683c701a17757ab682f0fc0759ccd7e3729f2f51c828841c8fa06ce053e504852b1c90ea5e12d8a7787cdc93128c680ff3c0c1130f90211efc55d052663b7258023f62242a55dd4772bcee51c2a6fc31ff45242c490eb364f8d51cdea1419f3102557f2ff1e313a12f5928cea532b1f3bc781ff350d71d9d5ebb81fd8983128b7dc1eb858cd74918e87eccdfa7f51dc8dc742deb534f29b1b849c3c1a158bc44b50da803db0cc2e5903826d8cf6333f2ea7ee658435a6bf9027209bc23163f05d80b932d0df4d4dc2b30427ec23e52ad0a02a32a5772757440d883e0c93e2b098ec2740a9f715defedeacc0103d4fdb6405bfd4656f7c7429c2401200c7f8eb67327e1ee44c931b03d2ae19ce694fd75add896a5309287bedd36ce708c77890a3003b1d65545943baf58ff7f744eda2ea8cac4e211d2b379fc743a6855d4c0585437b32c30393acc3bf1aecc47f142c9f9d1638277d4592bd503ef56ddb6f87fabb908c3a76c8decf922804610a599d3cf69d2e98b6988039d8d5d82fd59556c864a32df5c7c83c9dafef81cee3e4dd595163e5b2a43b6d46c36c1832a882b8e7854fd3717ea93d47ef5c62b644f0d35435d471c35ebe9c808eeb2c4f538df5239fe7314c1b9905d306318972cf013772137f6ade72808ff849f819a24b88691241e58fb0f4149e860ac218b3561384cced608e22add40999d2d576d5377c2a259039269d8e1b0aa5c6ca987f477a5ed1acbbf809e85b07bc860303733e95f74eb9a004930f3967bde37acd5607958f1da1d487f933a9d1be94d2f9c7488efc0b5001cb3f1723364205cdb572fc9af7b1cc3677b337d821ca47b38302940904cd8cfeef3886511733360d6b3084532faa821ff5675ec569a56536fdd308b05dd49e04a22d2b24daeded3d9c098ed9bc3ace5bbecc32e182590c9d97fb7c4159b4ffe04cc36bab57c4f5b59244ced09cbcd031b05b0058d3c2cceea2bd0e16abf28602b397f896ab22ef9edf1ddacec3ce8565cf92cf4721ca64fe67d2f9b4f0a1dd8baf76e1f9a0728a40f2dd3a308602c6ddee50ee3b4934bbb0168e65d736b927ecabaef543d998f46a0916fea58c4be36c193dc6b7f55894aa71a7fb767ab0a018b3369657c42d68f68c9f340ed08ca2a5ddc15d5d4de555e6ff22a8a93067394ee76b615b32a2cc7f4d9fcb1215d33df2fb2e9e9be0020c4b6daed21f6a606471f3f38ceb36400f124c5ae5137460b4b0959021b69ce4c0484f0b23997c3dda789be60f9533f8968ceefa9eac645bd8928246fa89e3a0ca4af21f4164261073bd7a300017c76e00b9ac3c26cfd51cd442f359f0e8f5e2333946914e1c81d12d7b108be8bf2cd09170e0c22b6cca5fc1ebbcd59c08b4c3c8e4d3868082e9e136f8b2022be6d4e77b144bcb1e1d4a215a2702f1b2dacd842f51577a6612d4735d16d82dbe41f5bc13f26fa8f5077a8de9dc4f0669570391b0c85d7d40a8ae3d26cbbd1179a83bd0a5073121b01b8205731aa563314c0dda8ca31c9a501b8e2dd03fc9346fdb65e61414e5b38279b6ac9a763fa75e06e9ac79dc19dec270b0fca17e301811e3e9f5b66c9ea5d00931752a48209c38c827399751e3b09371049c1cce9b669b5775fb5ec05c4c8018a88d9d79d445d3c8ca641d8476b85d913f5bb2c52d8d80e4e43463143a5074488f73f06cbae4a4fb8fd6a3d5c8e125e7beaca6c22678f0982b92ba9716fd01542850f3ff91a2824c9af44e2d87346495d62012c7ac48528e4928b4a75f14eb3a1a82f28043f2bba3b6422adb1cffa4573dc4db18aa14d9e4d5da11eaf7303eac845d767bad559e13fce355afbe7b56ce77459013654527fa2166edd3c75054735c9961c2120dc6a792d94fff342bb3adf85825ebdbb257b946970fc0bef3284b100d557bd38a593c35de9d951020b757f7052253145ee24b71d828d2449b1cc96b83b074a6527b37ef810865f0254f92750fc5488f282b4a6c36de5bdff45014294559a4f2d0591d0a9eb7cc4b54ff500e7b741b93d6a29f6865efd7a8e98df4886d34aef7f6e595db8bd16f8fbb12375897b621fdf25e5530287a36a6cc0bad2601cd000a9c0bdbc517d65bf231a26004b585dc801e52630ef604b410acf92586fd6dff920d3558a037d902bda02a03ce848385e4cc5a4e99df654ba8bd82861b90d61f62133a6d4c3e433237703edf154a42d8e0854591367f7224acebd0fa84062e0d98912e1baac5460445176d66b9f92afbcc856286e3c9633e7ed6c244c5de956e201215afb0af27915197a4cb7b657d2d8bc282756353a4f8ffec4e1d7b2e6b5450f7b185a98836dba2fd15c20b3981efce1ff11aba90b709601e62bac8494233b4f31d6e603ca757c0e6906bf3d4e74021ce599caa65e362e62fd382ce7529a1d4b7290db45efd715a3d2608f945e035244fd35656b83e6db3becc88a56506ee6ce5529453db20702258807eeb825a49f79bf82f198ae2b8b3a1dc3e288ba4423b77a4f03aee7adf7731b90bcaaf95488eedae856ae167cc9b8a9e76285f8b16606bd34221c56f22d3ca78f9160f062d73ab77b19c5afe6a63bcb0194bea1d8cc3cca1715bcd7862c68ba1948df697441088859e74955755be4ec21678a198ebe5515284c28624e764f2263ca8ba273284065464c5b4c91469b6bafb8e72f34a80455b73ccb26c2ddbba6f4aeabac850edadee3d13f9439925267692296fbb92c028ec8a6f82215565077cfe3cbd3a451f71df7d2101c9f6e039f6235f017e312e912fea16ad155f2c8b189d35c2806ccc03246ea0f2901b19f51cb3a217c08fc72d5a86e536bc9efc5de47f9af7d5ddf38e350316214013c937c59874b8c64f13037300985a1c6b02750ccaaaa75b2ac6a206883c8f103b23616ce2405364631a5b182dc4ff86f715ed0050869ef51ae3cddf92d30d92736c981b9c93a999ffa465c03b078d7674113604780aa95fcc3e2fcd679d14d7e1225a402fd5cdca3f47cb13e0b54f14f8647619db377b1342c9b11f95146625ebffa4a08630fa1edddcf5b04c99e25e8411d83d4c33ad304bde03085981fd153ab05bff08a30e914cbada220f37ffdf049e07a16996de3d3f2ec31f91f66ef8a72ad29ae096cb400f598ef2fe23593f395ce19a32efb5dbc945d6be0c62ded23c475db727f6e74e7095079d560f22050b6b91f3a14a2d387ac9b84bb6b1e90792cd4035452888551755075b6774e8296c90cb0257912da76969a3d08f2bd7aaac11f2802e6ab5f1a2eb89ae2e1256541dd60788334d8533040950851e9353f24d51487cbb53a886277f07480d2c9972f29ad0854cc7a84a95c630d93d7be59a8605e9a7d3a0bc62e48ee49026a0b8f7654f473516692f27fa7472a30475fcd33a3a1548cde56664cfe1c7aa9c60b92e4bbe6aab232e469b7e2e3baea8e5e476cb3f3bc943b8d9e41e0b6568e4fa7b939d9650e82a923beb1b1818b2220a85c794e50f388a2032a0fe848c14b3715191389251b4a38c8bf2b5efa306a3cf1f48ae0cf8978f248608b5a1e970b5aa03f41704ef23c895c8903a9f9656c05d530a7ce06790a183a8b72bca57b8389b1912ccbf249f55cd0838a570eea954dcbd26ac1ff7fde8626849014355b6f97f3b26070d967e5e5815d0543569b99bd5bf65b63ef148b49b6ee82f0d8c7fb903d64d0a68acd3612d03a9e2fc831ab02e28372ec2c6c1ea1d98a1b158cab0fb63f073c339162dac272e7979320fa2e76644d375425aa715c615f6be9a03e96fdf0774e000100109718e4934ab790d3a45d0993ee9256557477722df22dd94233817294927dd40806cb48ede935731a03f8b57b056c57ff7aa58964ad58bb8c95df569661857bf0965dbcb5d2340f027e2a434afb9e531f39f10e671b6aa52837a4095b4d0bc21e7987e602a0930aaec50188bae1cab6187419338901170acac615ba156b6d67b27cca65e7878f41e343dc395493c9cce83d480e59e4f0184848950bc130cd1955d810d30fc9213975d7b819edd22f9c9575d5a567166da48a324dc407b3069f058a9273ce43c090c55e38b7ea3eabf4ca8e28b1a270a9ecf6118f0f795a86a2539571b8cd1e3b352a2e9ac023066ffa191bb4182a5dae4c6072faa2eef2b6596da7f485eb8a5903f4084854da2ffbc8599f4288513e3593008527198b545b080fa7e768fce403935d684d61cb318ceba80e02835fab2c3fd9b5a942e7bdd22600a7ef3e8e083dd0871bb5620272f491228d063891898f74c7add07ba76254076451306426bc0c9795a2f4f63a93e838cc4a3271dbf6b354210253fe8a8a821eb7631383653f573301f87ce223435f373b836954bdd96c6f8d2c7ca5143012b90c1ec12532318ba7020a0404798c87a728fa8d9d34b956e0e797d254503394ffb9dec7752a6b541b8846f61ae1c09dc26031c4eeeccc36139f1147d7f0f2b145e3ed196e83ef10e72a52a5f07a2b3e02f6f15aecea001e7d1e65962c3a404750de8d3cd90272e2f5eec3c38a10b298edbc9e18d35f5ace543e1022feea18f8af12e4b549a2c27e9c60ce008f51d8c57562c87ecf252a934665d1ccb342669daea0be4f9a6a2d4e4f3457238236273e987e28066d5b23f06b72ee33fa539dec2844fd4648f6f8394bc2343e8f59b6ab64e9be1ff9dc92a5d46e8f111c226c6b908a63dc499ccc6f198a8bbde1ddced3175a67faeebb89452d994efe359e1093b6879ec101f1d6a5eb4955cc41d3a219fbf5aa301df4153fc146a2e164797a753ba2cca9c1ea3bc6498ff6b604762330f5a85816cc3f97e2fb8f0b15151e09aa251283993cfccdda6d9da6f0ac992fe2884564ebbe06586ac6ee923c6946afb0aa7ebeff7195c2e50c1d347ad37f4e40dafda6e98ec3e369963783bf2734b662f50e50e5e6045679e38be3ead5502c65f4e9ad2e57ecfc9f4f63c0cc82ef54a42b01597af87744244290597da978694a2af0cb0980b101ad18384769b17f7bf15f81da635bfeed8a62ee6239c8025989c7b2e399e16480c435cbcad5a6fc423348367169a54fe148cb142fcb67a0a8303e92bc4f348ebb746b373e62254cff4657847f0b54929abef9a6c7367c2395af30802ce48cd7e9b005ca8690e069e6cc2a3c000cbe9e4360b140af784d7ff23ba12e745d3513272e5edbd5034fef20e71e99c7cc3888c38bc8171b0c083575846eec1bb501544703b2259b8783028f5090c4bf92904576de081a92c8dd1449f9697024b5a9ea8827b559682bf4a68637cb3f8af47c0b128358decbaa024536519f5ad1b2b3212cb1cf337c6cdbd14cf75781b08d065ed04e6e2f14137489c9e8c3a12c53832b3e863413e682802a1b4ea9bf4fb5cd173179f91242615c43217d6b608a400405524f7cd0188d470d5177b18c0466af00ab57f13efa527a6bcca747b250ed965940edae7f89d0daa700ed3c85770ea0e574d448f5b2b322d47a47dae0438bdd7d5cd15065c7966b5d106b471b2da2bc44efb0cc6868bb61f44b5027af3e17d56f12dddbc03c0b06c5eeda9116c8370d6b616af5403baf5d0f8f9e2aa5e8db0c61ec06b32c2fc3b5e61fc073e2da2613939c8a0e0e7bf0cb30db4b9ce74c70bc8e4160597c7b69c6942c22e4ab28ed2744f4f9268ab78c0aebd4cf6e067253a7956d2bab386debaac74e8d98a2f69ff5ca1cc60367fb7e7eb99466bbadd83faa9b4054953124fb195a1a38b4dddc476e58288a8797a84603ae4b73de62930d1dbcb385d818ae01a2f46e00e16b68ed956900fea5de453d72db36b2e0818902d1bb6b561a171651884001c16994e9b22af5f39a121a1df8c00ad27405cdd727bb43b2f064239b668ee9778dbb9914afbfa3e66902a609a68a406ab694bdf47d10c6a1577a2c0ce1de8c972e279173f24e6d81787afe8416f5419abf2f6cf5ea322f9587f4ccbf164f780313ec773d011928c6ecc4fdeffbca979e6d97b0f26011498dc2099f9596deee156287c3be3f3ccb496f8fe03d9d850d8b4f9a35df7d6199e7bd9ef0b4337d2664ba8e00ceae7810b535c660a50577cc5294c97b200c4ce7cc0763d555933749175ad15f583108ca8a6afdb171919affd945de8615409bfdb2b7f49215503b2d13ca98ff6be29bce95ebb868a2a7c564a61030b88399c1aeff588f60ecc9d043c0b82616399f892a5a13c401a3916dc0a7fbab8332c60d5f82b041ed0dd732b63fe048be4ae871838804d6fcacd545feac98929bb088b79669732b9894c79e5b5d61329ac429ac334e35b04b0ceab2699fb901f95923b1986b43d8743516ffa8b8c6c6bba1fefbdd711871ba855988c93f2a0c9feaf7727fa9458bc6a1d89735cd990e3673a4f8e2c65a9c300fdc3ca05c152d4b08139eee2428bc4fc10282677663031e64c6b6066da73f774cebd4db4c49de7a01c8df3e2f9120ff56019b7fd6f8d517e4b0245b2a2af3729d0280d03fcf0eb91f8b390c69fb7da7822136f042a9b6db19bbead0d086030e803f3c043c10cdd89c088fb24f1a4ad7ee67e07709c0ef6b782b88ffd3ee1e75c464e6752f6bf46577483fced3f172c52da92b75f41e7d863c1fdc02f7278d835347b4b3da9b856473aae250f43960fa8aa5906ac1c3aee0292f0da9ea7d841ea6e412ecc9983ebc0ded68859be4abbd2a8636e68bfe12fbfa7b142edad3fce1bac87dbd0d333174359dec6acd912cf104e82d9e7deab3c22e3a215ef86ed595b01fed4ab09df4549ba07fdee1762c6901b6f860b8892aef7820f80123e0c408c79601b1c7068dce51a7e953d01ca55b9bc0a694594d6aa705b00394065e12e51be3dd1ca2f346742b154eb4e0850654c247b02962e09879cba9013f25bc67888fa07d06486505c6b65b515537bed86ae5a20fef2e26c630985000ad9f8a77e8dac96e758424636a86216a42d1cb95d3ce6d231147dee5633fb6ad5a4f797e73ccd78e6f4b1394d0d3d5a51ec5fd17e537359b8b20498b2d1581da64f6ca03ec1ad0909abc6176a2faee504fba44d923adedfb9fa2fcbb6053632e4d0b817cadd5a637de5087ff11ee188bad081d1a4271a64f7e61ae3e85f4e9ae3b74cb7adde8e690c065850adb2bd99069f85b8a2dcc07158b99b826a3a4c82420a4c06bf07d24c4ce8395232d89bf7f74f38674634c4eb8e3f02ae59c5d805a91f72c9a3cfec8e9051da3ec2068e32919a50b6cd141d37962684b2fdaecea40d43f6b1d636c2a75bc3084e3c7ee65d70f249bfdc9fed78207e00297b6745996d770c82ba661569a18c59581063b374fed6349aafc341bc0538cf62cd8a28940d210db5443c72a8765ea0fe10aa1b8451f0110be2b3fc32bf7a63fa79a4a547b424b9c5037ac4252f4424d05daad3673c69914c8b3813dd801328ea60afd56ee7dfff408b057cde579ab889a71385c7e0fcc49bc7d5ce63104f5dcf9174309cec64f31e363c432a69e8c18a0c2bf7fac981fac5ce9765b45dbf6329044e6962bf234a4a1616fcfbed50cc523861550c8a1511396636c51baa9e4802a539e8ea1701d3dfe188c34c5d5285c63f49e6b8011afd4a5d092cd179ee8285e6bfe025baab424d79872791b05c335251e289cc0c3862d7e2c7373422c42a6db21da6f0cb173a1810e9c21261e992b48b912dcd3bc67b83a8903eb6b9ca3b854c43bb8f8bd80c42c4582b886995632fcebb16744d88494f15bfb704e7ea773363c7a0eade819be4ba3c6e9658af8d6f94f42e6e3eb9590bcd0668960967a17e3b01c0a5a6274a470036bf28c2ca7c1e972879a8611f98e096f886c12926ee712a1d56d5213e0bdde7cb1e57d1ef1a92f3b2b5ecd5dc7487be0d35598ab3714a42c4ea783e3a97f15949c26366b8621b3deb1052ef3ce5566f9f8af9580b0534cebb901483f749964478447b82971f48a28cc0a2fd1f2ec17c66fd44535a882cdc132582e7feac2948c5928d852233537f9b18011e02efdcd36431fd401432ab8b376ac87f00e09861aad01282d26f32860241396e4edfca649f7b53014e97efd940f1a6b259d52c3c1e6900495d9d401535c2f9c5c1c8305902cfc3a780ededbcfcc9e1229c9ee808d11e2e3692c2cc38e1d7c99c1dab3539e392483caffa4f983bfaddb170b5b6dedf6b7fa7649661be57e425b4493163b0314f9a0fd91ec0ff922f8a8d2fbd92347615064b45cb8feda0057acbf3adf47d43c906d79aa67a59f62fa19148a972c2a09b09eb1e2a059415684b5398c9d5470be0a4e180b97e619e40ffed67c82a8c2c7316c27e28182abf68103cd85a54fea7c8651233608d219e32042a2b499991df4a469dea52ae0a0020206a130c43d2ea3ad4cf38839893626e5a7fb8e3b1f67c7ccf5fc39d0d9ef93b692053dd7864f859cd89d125d38769f5692f4de67acc3ef4b1115e8039a090ab19769a9fc59c462f7cdaa22b0a225e4f25c2a8a65737a21cc858b37e9cb2089c9e48f6755a8e1a9ec656e0f05706d11986bcc1f2c343bb551ac817786aa11aee047d1ce6cec2dc367d704bb5ebe54d898c415393cdd487381151b052a9130f41d24a2e4b68308e4620d5a6cf437171b17b9b966befc5953afc8e30019abae096d9da02712e5f6435a99d26d53bffbd53a57dea265ff11e756fe55eac0b2fd5d737b1de2b1fb86a470365e1a060a9ab0970e52f63d7aa73e60a46536c1495d68bf42465dde060fd4f59450c9f02f1fc60e24c93c1f3b8083d74824bf10cecfb6b7c59f0d63f74194e4f40f3517b2b1b8ca0e5d46d7640c5588afb2dab30e6852c8dd5b608830787023c82e980fd7f3c9af61f6a225bdeda200cb5ff97293bb5b20e799244e30330fe1ed40d027c2580ebf1a0c35dc11c5fade7c2e7cfb779654e4a05e13d0d14d6292eb6a5bc8d1c025fcbc461c9772e9a65c98f3b271d727bb6f71c225cec14272655cb0e93364b6a9311dafcfbbb248ecdf5c295babda8bcf623100a65dfe8aec5ffd139f0076818e6bf26c31ea0265607a730c79aed09bd85ecd6d4bb7ac8cefb92f31de0ac693780e56f02d1ec1bd72a1db489fc9057c98bde03719108ba2b1e227f38b387f5a8e6df59461351062a706832aa1cc7364202cbbb0f8a48643c09cbecc0b58239316ed63f4728f28fc9f0bd289147c0f5e8f95fe778a7ae29f9f187415d5b2f2699929ea473096fba706b2c2b0eedc0e5e452739b5f2d7eabc96d864fdb7b6ab51e64e105954d511f85e9b682819e5c287d5e90032ffe60924422bfd3fd9fd29ca52d2440eb06bf65ea6476738bd0286b86cf45a0a0df89d369eed74def9208428eb3e6d69f105d8ae1fcbb5bcd65f5be3bc454aefb5d90a23313366423848f448778d88bbff5dde8b993a00395ff9f5a8d7c5bec6702d0441215484288579c16e565373a6cca877738b401748e2794d1af51577284180984bd0774677d4723ec01779a76ba9dc6f9ab488fe9dec4d59a48dedb25298a962a18cead57855fc2a29b8324fe4f5b890ba942387cb047dabf2a625522117d7789db7ecfef1370cf24a6d863ff976c355c25c228e8140ab030fc04157f19ebea88351ef13d79da6b7905a0ddc19121f8a92a4f6b996446784cafe053f7fbcba2fd0d47698ccd5bc025804cdc309cc5ed8f17801be62a7bd250d1df88963f69d13378d9a91d9756482a9af506266fabe15c6ad339673d5097ffc3e33f7d9bd09a500280eb264ef0cc422baa2b23bdb95a520e41958e0177a0baa7306f662b40c94dd359b6d0d48ff6898d1c20ae46a5944fb251e322a042a9eaa6fb204bfb06145bdf7e4f39a5aeff3c3be0a8bdfb19a2d463d02ffbae159ed8bcba47e7b7fddefb815b0194fbeaee1ac82fef1ac2d21f063e23b779246f80eb1ee5ab3feffd8febed06f0199f7bffad8ef7efa86215404653ed1c69f10fefc2da5e2ca742186da3e3b34376e0b242f590f1a10c01bd645bc28665f8e35cbc1aef19126b8c223a8243d232d9185c6dad7e862cdecaefe90d0fc853e24e93f4b569505b416061fcfb6d65be8bc1657d87756a6d48b071c10026cf768b586ae11f3a303156b5eb2f90d68874bfc013b8ffba3c6e5572324adda95b940ef1c8416c6b1d44841204529e64adbd974777d43c08e388aa3f2d8e009e7488c591595367b9d2739df3ed9f6e4d5f4117d3a36e62357091921b2f086211a74b098f41c456cd132fedcade90417dbae61890ce313a8eebe65e622015613c40e07b851b0d9fb8ab4d80d9fe68070b9c1d36b2d79eccad724671f27627c58f07b66fdd13d4538b37776b3a723c13c7aa8990b80eb28d6c1ae736445bed88c6e1675d745be432916d42b1c49f6849fc4e6a01fcbec8782877f7f9ee90dce4ae9c60bc4ecad37a6af8b5586432fd2f04a38dd1476e53432d880f383f2c4e2a099bf44b9088579edb791a5c4ce60eeb18b97c20d8cbbbcd21f98998da7874b1cd6179790c062a012d0be5eeadcf27c237cd83d5350881050ddfe4f36d2f3d4c8ce65951a0f2ecada55cfc0775023eb73288728d798279506643d283ba72c4e39a1e214dfe61f2c7656f1f841ceef1ab4ae9a06821012033d0da42c871ae74ec21f0cca1d322759775d07864ca7e91d7804cc0711d58b0fccf93e1f2ad9a369fd01ac92c4bace3ea8e0ec4ace4b35f0c68a4ea9f416b3c878048949365cf1ae343d45df4495d8d2bdfd7e96fed960d573b7f7e49ba14db95072de75cc8215a57d20a4b8c5d87194e61f4be7aa7facc0f3329057afbefa87e3179c4fac2c4aa9194f9bd9aff6ada1122df01dc82d8af96257554517a1e9d1f17648f857fb1dade66e0949902f51ddf5368ea9642d890603ccdcf7905b02ec6424d431b5f47226d3106a5e1ba3ad43e86a05261190d0a8e6ce63e20e6c08bcf39b907a8e0d92deddb675ed39c0d618cc819fd1957457509f41b086cf645d35d71a53e8f81f7ef81119a1237a966d8f39b4a508fc14b9e1c328c2d2775ea99bae83e557c002da520b5ad70e18388e2e71d80deb4f9728530bbf0fae1349b6eb7ad9c153025c1b3eb806b47f0c65826029dabf760cc9567e2354746c8210df568962311f4b46dc18ef0ea08a3434c56f67398f0197468d395748df78bfe574bd06c09d9dc9923185541e585e2e53c4efe7cb41aea7667f0917471abb9bac3cd1a0e219f18679e0394afb9755086ab52101842d258f037b33f06227ced396a3f671d03644883a6932d8982de5a2f8481e857dd153d448320ef6c6c72adb96b96ffa28dd7697d9de4bd5684c42194f70ad139a3f1e08fc83dc4867ed4a18e336d373175f7a7b3cb6f4ee28d65adc918ba245932eec696f607849ae8bf9e8bcd79c892ac236902ade77e02be2561ad04f38e9351d91a1e032e3e1aeb3867a59cc61ca80bcc8b89145ed0a112c3c431ab4fffb12421f5e20b8bdb8fbdcbe9cfcc6a57a47095a0bb02425b944219b0c2b62b1b06102c88fe7556f15d6efc88ffa6ced70fb767d55bbd1d037059b4eaf2e8f767a0dc8749a10f18eb01f906c9349daa1cc436c8795c4f505a9eb43e9be75c71ef67788fa8e1773c0b277bcf5233d7d3acaf093f0be907dae1b7636a0308930339c0907d897200b95c6b2757d9304d3186b887f5920610807f8f23710e0fac0c882304cf25d740d0b68ca3a84522d501565625fd4919d56f9d634baa9c3deb0ade7602342e028b3d9a4dbd93df6535fde27949eb790ed4fc29042209f63f6daaf260e044d8c2128f27346ada20d50476aefc40fef3f36c70b3164963f7c66fed5e6db91604527d9f4a82fd33354250576c1a6a00c08621da9db5410942d3663c87990c69160b59f23482cc4d0d6a4141848cd069ab805ef9f7df2846a12a50e5e13d38a789588d7d1757aceb36d51ea39f964ef49b986fadbb1c58de7e1fa850d9cdbd976ffba35d9a77eecfccbca1cdd15fdd95647c79195580c93195e8465170d6c5499d7d7caeb6ed626ae1cda5513b01344d9d44cff0699149a7b2d47d626153daf24e59b8f88bff97589550bd8accc64f6c1a22d9867ff5197e0e0e32e29a618267158ede37bf62bfa1f6ad8565faacae30ecd0ac231105254a81e25febd100a57037bd92253995b3e62dafe20344eb956214fd9e1361b018e7ac6f82046d0efcca8066c1517c8dfd63bef55c32c2273ce14ad6060cfff4da925a7469182ca518d2abb4cc1a6f1a69887958169610b48b4ca4bf66872aede343fa92a064d705d4095250e6772d0d9a445a3f9473423960b3e6c12a9bd49843dd08646e90012554895e026c4704d506eb83f0bd1086e6f0b4ea68f611c27a76f586d05491971d74dcf8654c8166081235cacadbec105dad8ce9a84def71367b6d330ff32d27ce99b09e483e023886e2a663eaf82244514685ca4a896aad62045223a4b40b66589681dd0b9eb65e6c0551aa253b0c24f1ca67c9aaee434f99964947ae3694f65bd479976a89fe935c01af195a32d9c08a18080bf905f4b51f22a15232a802b2d19fb5e56728c1382396021b49c0384183400d99c2b1a73e715109dadae84487b5f7edf1b6d098e3d04b416e8c7d5e3696899b067fc335e893317675cc45a1efb8036430ee47823d1aea2cf3505d88cd73b8f4d479995147e3b77bac0f25c55d3312801284fbdd8a2485f7ecb8e3929fb205e576a69d6c47d8294bc981e49fff1f8dd2c4ab164aee5e4ad4c666bae87b5b3e8d49adbd8544804dab2d6050bece862fd89e1aea31bb5b8eb3bacd9ed95ba6fb18b94cc8a5f1213eb4417eeac409021c50b2aba613571273de0ec45f08ff2b4fe6edd900b4da5d58b2d5adf9abba80c0a9dcf158b6388f0fd9d358d4f824a63baf88197ab783412a7edf4dac730130e1d1a47d797d585fe3efd7c59d9ca6b4be998256f1c9f2d10fa822315a4bad6ab1a76f1ba887a119805046ceb938f347bcf90741b990c345e9873599086b9b7d6c5d7ec9d1e1dff717ea6df1db40d5f1a0bfbfdbba980f59990453cefb8c551893de66b8d024ce98254d08c63308be1ea7cd7758f7667fe98d69c45a62025795485c8b783ad39b8274527f5e557ecd5c1df4cc881acfa17550a2ee535b3135f40a1c9a800613956d5db8e79d451ae97a706dcc59898c96a4ee3268b520a89c7653299b3b216e483d8fa3f59c4b1b970d39f161e26107301e08635e33a376961ce298b971c2d93f10096f52f6b7688811a5b1f4a298fb3e2a8af1fbaca4629b104832d67ccdb9c6289fee6a3405962cd5f7b87798554dc8d52769a317f8e13e71a117c07b6472e8724e1afc563c7b3547b0aa5a2768299ac6b235b58714d674cb96674de25016bcffd8ccdec889ce79e619c21fbd62cf8d6349a4d7f3ae0f3d3bc1cd3443fd0d7cb256f7987b4a8b5782fc9e4b9030e8bd24b7ed8146454ac6e42a929d5270ceb3e62845439c5b29bb7265bfa7291a5d1fe695517d46ef1b0171ad6d0ff08f8057b8e4801389cc9018fe340bfc5ee93bb5ab05be679843929d1cd63eb17863537fe5c92265286fd07b48c7889c497ebefe909daa695492d1960354688a41f6f6e2fa5860869fa9248b5d3810d7c65ccdb88faaff482e50c9b2df4d9c7ece89a8d34d5196a8d538f232e2e7b2219f08a95cfe79885221a72c950aa071263d115bf6fb2e794f23538166ddedeaeca8fa8303abb5eb9eff8c53f67a09d1751b600403c17d124c1dd9ef39907b8389d7291f37b8280db0c33a9448f521262f5ecea2e383e23a2eee98fef74c2430ae6cadea4a087ce5afc28c4a0ead5ca0436e08ea227c1354447a16aee529118c049e17e44c2c5b69bebd87b28cbfa70dd87e6e4a190e7853779e7944514213711f7a69ccf808a6c0f9addc0d2df100806c23cff61649aafe6ef136f944ba5fbcf8d83cc6a963871324f07d38f1910ef9b05b57fab49a2966c2dea0b5fc1a85941ff0dcbb82e13c7c2b48f44e074db4037600fc9d18d0a02eaca6d988dae363d647132c87e364652f0a8d2f9d0e4d7a8a4090ab9f064f7732a60130f1503d7a5c1462e08024b238a34233a5483e17ad074bbd80c2aca92d74ca7aade2145dd10e658e4580c5d698f13f0bad7d7b286d412980059c8252e57d4391a9c9ea700fce4d09a7dd0da9b083eab45b912d4b22feb358a1ea9dcab44d3d3e251d880528e2fe42f88016330365b55c5cd644b26171e4565f60c34f88cfba4a770da6db1c06850b568c137c59e4c0c2279ec91bc3fd8a7f4594b9ebeb336730362f975a4f430549af5194d87970c3e4906a4f9d594c46d80a3ed05377e7a2267e35ec952a74d644a46fac25038e72df25830c419fd2f206d950f11bbb55f634e8c2fe70660efad1890b286d2bd600bed5199166b3aa2067ce0914304b09f5176fef148f4ffc5c15ee69641cb609abf54bd3ee1c0cba3e4c4718c8b571a6f3f229d58b1b7e5486a4b6af69fdf2dbb76d1b4aa4e63e9513d3e34418c58aed978f6541b5445ade251e4b014aea1b3db367d27547bdc7374455f0b8d2b3282abe373dc70a06dffc38b00b1308f944b93bdba61749c0980b1bbea155229757f00b0de1e9f0080539b58de55a2f0177c6a09f26f4b8dc9aab8699f2752d9ff885d4aa4832d0091f69a30d87ef37185be55e8f61b8ebc00f9774c4ea55f95e271057009904f1dbadda85ea0c4017b0c479b85a22d7255fa6671976e4b783596228bff7ed0c721f88bfd01535de8d4577a09c4afd39927807254e670918a9dbc1d8e827aee9c59c47c6c842f01d3b79ccba2f1c80b12074ecd341eded5b9e2fd6d2efaa35b7c52342fb1927964a8bd816c515d101c188c8b7038beb3c340be6592ba589a69e56c7a5c9c2e6387de3633289c3e08fe87a0df75cfb2f711e21ee2f56dbc80a9ba2581f1f35dd642a1c0bff53befeab2831d5aab6691daf98c7fa815fa357654a0cbc25bb7b68413334b896b6f7d89c2f01d83d561a6a3782271e6c65fd320a359e247e9a2ba3a3de626b199c062f219679cb8e13be3e14f190724481fc8490811904893e6f14ccac3d912d5f295d634a5ae7148c4e28501d4b398a525c3484a91c410bfe4674f6d7c5335d3f28885ac101d7ea930b83049540217ccb0f299cf2fee6f4493742b81367afb0aa1d9234a2fc0b09ac17b76363f2c5b5c73764cc81f852e550b973ca07cd182782f44b5818b960cc42843fbd675f3e96d6f6b61139aa9d6d3e265b246e4811619a7516185eed34b716380fab84f0b4f1541b2822675fec3da90bacf564d4eaa1f56c3f44b3400c05cdea2127b4a18743a874e364e88cb602b088bbea5311869e6df1440263a99b239c060b568fe97e3d9961cef8bc96907306f640c5dfdf55dae5ee8e640f8d1effa83987b3dddb64228a27c7e24a51dd3d508dd1dd94528379baf59cfcc9f8debf7e8bb4839493e46a483b747772217b5d8dea2f40c9baa9d3874021872189ce46f26262f66e7cbb3c068b078fbb47c4aba6596f300413e0b850849166c6487b37ebae85f88847e41df3b3148bc378759b414d8cec7d94abfd944bdab85fc729bed8d956317fc7229e623352db580a47e8ab80ef0e9202812d8370ed071aca71d378c542e16957cefd26b3bea8dea46d87d5366e33810b1aac83172b052d6573dd3ceeb37b3ac2fc0ff512734f9fa0e576632397b13289b7bdbcfd2c4ed6b051ff8cdfb9ee98b0d1096acbc0b73799cf33d3d496280c6fc1311f00cc71cdd2e4642a4dd9c87d5903c5df856dd3977954dba26ec4c50b79c3044bd6532187898379645d14058e6c1c8fa2f1d71daf7b7a1d9921023b5e3bd23fc6d482428cab252ee34a42a0d1df054cef6192834cb9e765a7e91c29dbe071c256c300c9f1a6a848663d15c9b2ba116732a19c7d4e972611970c915bbbfb4baa52e394803e853fafabcce480c58e871a7e216279848ef7629a59b6cfcddd1f894f75635261961baa262e4ea0c326bdd6a17d7b086bd00bacbab636e4696c007be4d6caac40df80bd06791eb97e341372d337cf4837fbe230d447e6c8f1ed46e0098ac65a3dc938d006ff248b2e6161f4944ba4f7d104f6d0f8220a93e53ceca5f72bf21e7d0985f9ccd0dc2ade2fba1ad59d44a4e60240315176a7f1a3ea081855587ef9af56c50c959d7c52dfb2c1d7fed8f013f7ac08b178740d458f05636ad2d4e52100a013c84b5207c7c29fb7420327d6f2b6094a1989b6506c6a49830c4d820883df349682230231260559f87f68e47a04407c1571e3265d720a911450d170d4d5ab6a8603528b0a29ea6e53403b56259656253644c9e8fb71d22de57ec74db6c72c84198419d9e6e0c1bc9de150e12f2ec1a5645c72710b2bf2b05b6588fe068f5baf35aab731df17719f9d766c02024ab85cdf7d9d72c02079e80c5fd4cfdc2681819891a174f7d9c83846d4e308457bfa5ab38eb38ec1806ec64640c4fba2fdee38f2438f8061cfa87a2e4bcbac2ccceedca25274cdce9ae94c1ea9140b719a8bdc3900a6707d069503cb7b5923e6ebbc3e449ff9acb85e5d49ca748d7880e0081f8758495df0f70caffb5a1d34c007d512c1a219db3da3552ae00386843a9817f3267807698ff7113aff6a9574ed9bab53af38d22951c0978","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
