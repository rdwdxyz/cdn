<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"406248191b5fce50b4951b09d4b4abf827db2ab11d2ffa7b8006e0ada48cfdf723a8dcb415d8dc23c53b8ab13939d6909130713cfcfd9f83525f4c8a16afe7c31bfe868dc7b9a3f925af9fe94c995d2465ca2af27bb43a7e7c79047702744572612550e94bea95e4f04b1821adbb9e6c9c002a6e159e080e4fffff914452a73db1706c111799d44f229cfa1ab941aa9580d459a803b2c40a41b7c7322d2371b961b6da9b002d29babdb656a67794000630977c50e0433f0b52b5c7668a5f902dbdf9d2dcd121ae3afbf2667b9347eed63e1d23f61cd09f6970c860175c7318396a268e2628a706cb9199f01dde6bedd9d60a7429ecffe1c6abfef39cc9372e6e4d653f89871223993702bc4ab257cf8de5ca3c97abedfff736ae86a7a81331fdb9caaa23cb875eb2513c042c3283b06c5d73d96070062673a04baf353bf27ef0bbc7e822e5f6c0b4b5aeae163c44005cabb10ecb8db7486aa8d38589c1a72048832183f71c8c04b596602ed89ec3234dddcf1d601b90ec9aa3c31125910338134a85df56d7a3daee70ec3b319b51be90374c985ca3e8deb28c3497fc0b5f48f99702ed70e4dc61876fd2fbf28507822a84b4e0a9bc8263f748730e77f2ec54d9d3336d1fa08f727274c9dd54da037846a8096fcad8a02cd9e27f68505b4df206f88519bedf14f0099ab593e10f4b40e2f93e263a8e6d46f12c4fbc437b09df06cfa4d9958b9f8b530d0dcb2b7fdef7b91fdf6e4c428f507187a49b4997c6292936a9de020695f0aa5d6f0ca95ae94b721cdb3d9a9320913140d52eb2bd2ab3367299e69ed12cea1c7bed69c66eeff6356a1d0f66558f15126ca80ef550b9dd4b57847b0eb7bce1a98a2f0e7158eb5e8c69846b31d7c2f5b2b9ca1fb317bf8c9452a59559e5cd28ed294dc90f83805e1756105093bfe540facfd41154b19611ae2fbef8729c531e4e787e4c05451ede516f3fab955ccdec922a582a4c6c5a5c007aaa4a11aae94453f7dcf95f84875a9a2823841da9b7702b522913c4678c5adb54143da819275e07733980476cb324a45d10d8c82e69c5741ba33d3c029e1d54c606feb172550c2a31cebb983fe1aef0a4fab8682c24e09a88cfb2d101afdffa1cec2704a2c4e0e4907ca151fec1b485df50734727d099bb8177856d2b0fce7d2a6c8f87573daebab22ab6b9952b70abb810f46459f3913bfe1d2ac5ad57fa1256d61290a7d5bde6174f5a8f3e85ee7fc2501bc5862c34716ab3ab5f4ab52a8c92ed7116c8667307e54b3257a4b03949fb386da448bb4d1f4cbb75e61fba1dc3f7c5454aa6c30bb991f861d367f0ea35864f5f6bf62984d6ffbdb4df3bba1cdc7073acfe9e5f4ce6ac2510f91dff85487d18680d096ab8b8a54ff0ea2a888c553546149ef69e793ad7b978c5f38d3f39b59bbd75c6ed9426443def475c0a5f7f5e8e66481f9b96acc88f65899cf193a82fda357b1d92231a4820aa9eb1254331ac5ff5dd2a9913a959ecae49c62dfbac97545c6264387c39f3670ce229f020230c2fc0753182b20bf7b0f255277001c89ad84a73dcb8206dcf8499e981b6ab14554f4fa056b49dde2e6b2360b4b6f53c366cdaf8719b467b43219dcf80526ee49b3676260e701a97073df884d687459cbe3a1457bd56eac20d4780e7943bd2dfb48e271107a58d8d0510fa37767c0fa3a0fad41a89b7abed38887e870e37040e4dffb13b7e0f0f014cafef17aeb09d4b86c01e1102011b2a53c3a581255289c8951a46380cb9f88ab7929e5aee7bd6c9cfa9d9c51aac9c0231067ecbcdb33c03928a8a5f270d7cd6b1414716b463746aa779b54d3b6e6855519a83ab8f343f569b680fcafcd11adf2da29b01bc93d0fa3c85d038175c928a8b5b104a78deecd12ed7b47639733f20152766d584d49163ff299c68e92938dee221050f639f0cce7e8cb481cf6030d69d6790d2eea71fec13836fed70efd0ef1ad6f3f484d6d36c40eaf9f95788d9b03899a67b0df4793625b188937a3d9b706fba12bcd4af3549d4d621e048b6e106c7543b5b1a3877937bd893e9c0310b537f22b77e4bee22f5bff8cab7ec087d34fd30a86c991da427d9f71f499beaad73d77072490d95466373752505ddd1dd44635a29a72acbfe67554cb932df51837bc11c9f6abc67e1bfa636683887bbe94f874509f1d01c6d54c2466883e733e7abde78cdd4506659ec776103e68c881e13dc1e16cb2372226fc7ca0938226ad6082b469ee6410d07a8f1e994bc41549ea8969a3448db8d04b3724c9a9b0b0c061d04fc2567dbb7e8759b424bd7d7e090b7b380b753dfd211a2519729a2d613e719d708985ec1a616804c478df90f8851e28ddef990248d90aac89d4f26f44ee268bf2ec74b15abe21e5a55ddcac27c4153f8ae4c24ce521fd42edf0939e1035cede6b402f1f7b6b48dad648b83759407015a42d76c96a891a940c54088f710508b56aa9c50b7f681dc06a7c4c56a46e7f32fe4994021c6281a19cb868c60bc88caf1687266e8198441f23cb0d39ef424efdab33203d38d04367a534f9f3dd5544801bf1cab6ef4ef4d58599b23204fd44150b67ac67971162605a97bb724de6fbe2a29470318ec94e1fdda10197420265c72423380c5584faa0a69d2bd65c3c170387507931f210f57dc2b8059d74b95a35f1c810806e4fd375c72dcf3d8642502200c44e576d63b2d8d535d1684b4f175c0056681bc5bd5306c80df98f91dffdd46a6fb2c53412b0c518023d462acf40742644580e94b7fc159214507bab59b95f422603138a6aa0bcdb7b7f4b6deeefa1329ccf1821ccf398c47bf8955425023ce7d50c4a0e0e5e7679d2dab2f95a771b8e9f2e348a0fb56ae4163b4b22790c7b5421dce3c552a60c3714d0732da53c13570a81e908dbdb494f6488b4777b7b35ba5afb89d561b30aea01456e67a2ba652c984616529d12a096a8569d0d18276444bd4770450e710e37306801bd5e0fe0f293fc48e91d3aeb0a8af8469345802df711e2f195f600dd32b33c6ab8677d5c4654e83212aa5d6ea9bf0e634691635a83b4eea6104a5dd6f86220fa9f1db20b0328fc1c0db44e2c8e15b96025507adb0f1f2c8a0ad1f1527931d2de832ffa2d32745a6cca2b3c693ab10fce6c0dd42b228ae6f8d0ca24e9753a167718c1370dd75d65304c2462381d0e136f3a5385cbfc04a1f5f56e1c11d80bc0be1111cac0aabd1fb0603212753e77dec87a476c35fc352112ca98fb3a811acaed602342a7306e6f0f96597d3c7f5ee743d8be8a81c1c5ec11331d1af992e09cbaa56fe93ffb24d903320ead443577cde4b60b51972cb7d52fd8846f1604a014338f8872dc685a0f41dacceff81c2456c2a76899dd1b93fb1a1ada327a66be38f018d15ea16e47f0f2f94a016453feed42bb186ddc1d2d6d92310224bf45dfa2ad6c89a7c3892c0274f9b1e81b220705b1f321816d20501384b54a4c7636d790517ec712f843b5f8fc9181ab61a0dea10e63e6c1ea36d9d16bb6bd19ce255fcc7699a64f613af15ec848211f5190ac5f268dd46fbb1eb2c787f0beedec1fe71c03b2b1203bfcf4ced022fb7f5c21ce36708a02fb973dc231183591082c4cd68bf83f01bda41124cb8bc3b0b42dbed2c346959246d34f2024e684ec8f8de435e8aa8416cfded03fe9e366538efa52298f9a2307ac6bd6e9babce3b50a7dbe4a92d8fcb583b2272814d141525d369182e1bc43bcf9c774cae9a067593756439ef9efc445207e2fd748f044a456c799b170fec90072f1d8d935d6b9c4e2df8273267ec372dadff643e858a718418e85ea0bf25f46c3eb55b59a14a5b36963535a6f41a5908581f1e4622d52d8013ac16dea4777f7744d4b5d333f6c9115d149baab38a5570f137277eed7a346f5f85beb348ef8ab2b05e099d6e8f344734b450c59056c4484efbbb3250c01048135652c8a5b47b218fda249d606b8c526393dda6b8e72aa1a1948c9c2abeb0dad6c5d0366c4a8e471b95616721e7f705b5319c11a6e3d23c20bea489658a93592423fbacd2f0f7408b39e4f2be1adf10dd37d7415c4b1bbee8d1c7d78c8698c98d0f54f7ac4b07bc14126acd253714f4580f3936cbba391ed437bfa19c6cb027fd3924d43878a05fbd6626bc266cfc4b4c74453c38b6988cd1b499d8af1e3d368a8e44db21761e0015a7fb16e9df2147704cbc1544f6a2b71c5e0dc959d7a2546f51ac178518fd68cdcae4e9d2f6c868ec2e556ec7458af65587c09ec67e0b97255d21c13b803030956822f4acf64617691dcdfeaf6b11a1a59d2f94c8bb093bfa21fff9cebb7b6c1e912a878d79e5afe32abe49d903544ace6ff292529f19e846d9814b685cc4d9efbd3adb613e90cbd31e843e08ad8fcf132fce3989767c3a51ec4fd3c897834664dad40aa11d8faf2c0b54e10aea5e79dc6d05f5f337f5e09d621367674ec0462df2cc80636bf0b513900f250666badafde30534562e2d637c2079db70f1a207da6c327398bd563b42d0168252eb5e6273716ba21c1abf89d7a3d6f1541780240a8f70004b1d69f8c4232efe38d54dbb4be414b7ca534e4a35dcb8ea45e16cb11fe5263fc5e18d800c3538d6cb1117cc8b5c270d07e2c2434cee76fe75aabe81bd88a5af56932547c37f88793a96adaa9b725178646e94e6d27b8990f262056049c39ccd8a41f8b9defa68cf9d0e66ae0d918ea601e23c77a4f6f44d1359c6e8242d9a58e96b7750e68494cc13e9ca854b85ed90e58d773853ca7f0910f6ea646362e1e41f6df502982bae32e339146a232199e4d0306159d402597d7118e5c7482f74d1f4a1e28a9faa32ffa0e2e674637a00c0005655351b0c451ee980e9b9f69f5c756cc744e550234adef95de65f5ab3d6e9624cfe26e4083ec4549385575e135643ea80cd11397bfba384f61487f77a468866ffd06b4d64adec34f597df58be5076774df995ff124e0bf63465b1299228df4a962c1854862df67286251b625a78bf4ed9ff18bbdcf01efc404a8511b1dc50551c24d4df33d86074e2fcbc877abcf4b22c7baa324b515f4a5e05af5a177f2e2b13ba6844cad01bb90749070117171569eb919a254bcab03b1db725a9c06030cbfab680e11152756ac37e7dedd221c72574552e0e5f424447ef524b48c323251b9025915ff1b0c4f22f16da047bfd7502eecc11acbba4b8e2d4c92ac5a64d99bf02b9de2bbd69b78c1a209670d750528b3c639be1aa164ed74c1c298411a99d339b47d15187ae8432f849114db0704d62a8fced796f5a5c255fcf97a2eb0b926974f7f0539c7c75a30f66e0e3a13f9017ef1ac5a5990186e34439af70068efba17414ea6ed73392ff99d47554841420f9af2eb5c1f0b9239c0eef2adfbdcb4cfcd9ffb03be456350d0ff0bff5e460ed2e25bf5afe3af7dea898490c966ba7dea907a4bcd34e661b22bf9e9bda7bfe980b0e0e521806ed38f5bf61536f0eb8e555cb2cc3b9b5002282ed864dee065e80100734a994cd2d08b2bab45fae1bad32488ab3cddd56290208b89af6218ca5bb2308155f8542cabe6138ff907b413991e16bf0ff513f37d5e72480b303782e2c0a5a94f3881b0b71f79b03a07130f3c61a435b6d765e4065978a67b75a0ba0d5d63d004d8c0019a81d9b6ab3e1c28ee6d8652ef0cca9e00206852eac41d3df5910148101197658f924b57ec2f0b98a517e9f9bee30221b82762c65e4a613c15d0298823b91cf3818325bbb5ad2898878fb7b44ab4940d2cf7a379579e23a04ce2dd7df37183f4a92f36f2ca9a7f6d32c203a0d895637da936b12c5f6bba219cd090477d68893ce5fb6d0fd1d13e91fb8da6692c692980b01ef93a6a214279c955886d7c9e97f930335b8dfa257ee56f851c8606cf09d76dc14dc5dbe94561be8bacb36f8f1d38ffc919ded9e1aa88a06a4e570e84e000294e05b19d2ad7e7423eb7b53d08652a5cc0c1447f21b1af0a42d8540d0ac822aca1a8f8b822a49902d8fb862cbc8256d45f1264c9ffa6c4a6f2d9d4ed63bd6ae4ab0c41d889b35e299f8265648f31af10ffbf291f3edcbf69dfce3cea2983343444723dd1e7138f4a36bc8ae9c08e2ed3c4d579495f54619a5424d8ea6c1a5d3a72342ab2e60d2d1438abb18240af30419821bba9ee60eb28cbda93192c5579a72fc1931f59685001a031f8fd36ad340b25510aaa31cb4cb27e17c24b7836d339cfd383ce112ab92a776446e5a8f0ccec8ee0593680ba5e6668fe3f369fb9e97b93b833838d2b9779d753c03875bb3d965549058f083da5b5e95315f0ae434aacffef85666472c04678475949dff2e98df8af6dd2699578b317a43c130a5b7a1931404b1ae7fdf974f63bc60798bbfe3bc9c3955a83c809794afb936aae8f09e42905369081d257217061bcf66c989a7562b2051b1be99737b6b00f08983226e693ea49c45c4f7f112fe36e1a90e779f3f4cd82effe324ad7a39df11419d62f8782b6dc7c87758d2e5131bbac210318b6e20012bc9ab4940a4ab4fb61546b67162b27af6927516e623f4227d95f9d03c61bcfe71a0fbe05130a14f6cafe10851712ca319c3762c6e7f1551b282ee3ed5f966e1273aa3f68cbd346bdc97e7168019f66450a8ecd8d77d539ea3499498ed26022f71a42a95d0916b684971d5eecd026b1b7e0dfc939e96ac6a5a54985588b0f087f476f3a4887a6eea8640626d33a16f62e2021aa33c2b82f9c07f720f06447709c20aa818df983d2d3b3b50ded9eb19b7e1f216dc6a32057e9e30b8bec9edcfcc19c12c8ba388be8f9841014e653848b79989f61054b4821ada9c3f36c00b2827235f6c460058d190044b54090e4b2f37bf02388356d06c38695ae7cf81bf3caab81e382bdc739960e61e979c7565bb9cc1b28684cd85b094bdccad367c435f809e9796b0616b6900759829ea7c2373b9be1b0770399cee9f19ccf4b89ff5a5c1416771a32d4dc906288bbbe336de9db1ca6a8fe7874501e1cac5c5e263c1b5f22026546a574a5ca18bd655b8933e631023f56de831b37902bed4bc188b4e7c5c99d0492bf6533466bee57824f7ed3f1b8a0ebb79c6aaf62db1edae9566dd664edb301cec427b4458cb4db866a14078c449fa19e3679b5eecd930d13298a7fefed3ab311b88e5011501b3c97fc4ae1e7c2d4b932114d99374c22c9e342e28c8017158660643d0c1ef5ca7c19bd2a51eed1624d868dab7b7e98651eca44fc72f1e92e2087696ae67ec89d8131b6c5da80f106bd2b3387727ff5da9791a22a22446c6314ec7d76ff5891a09dba0f951c905ec69dfce39e9ad04529a80d9579972a0bfc8ceade0c92907d223bf1dce5407b1b145f1558bdeda7f4fb24712aed76012ac3ed1d0b8c4076d99ec4383d1b8cec21959548f6e7235f8417ec8c2d6e151ccb835f5e7eef1c429fb51da99cc2c24057142e58b989c5c4db525962191a71973231ea4b29c1149b5bbd01421f7351c6c42515183e235b16edd3794e285dff16b911fd48030649a2fe123afd2fa21a60b8d75d0b69e4da6f1c2b55db3307c83cb4c24d6b20732c2b2e398f2765747f69d9a98687f8cc0ccf7452534f94b53c6e04d10604f674bbe16c499d6b91c5e75637cfbe9c64039d1e17963b53b43bb046d33f63a6a23964b4d27582464462daab693d9421dd8db49fe202fc691b967ee7db420253a87636bd07c8e929a0b3f708162c8adea21b735a22c6c9db7ac3819c682d89450142996d33a256dc64d20ae041da6a3fadc7e042ba7d79a25b3ed69f1f0ec0d88d0dcd27f9af9d41c625fbf20d149f08f239572b501a340370d4cda8144e1154d07218158eb36e229df6a0f42a14a74f5e1c7c519ba555a57ed837d59652a8531188f49773b5c1087a460fe7081e2ac79a21fe99533c7ca99d5672d07ef1891e252a3dae33db0f3841568dbacc150e5879b422f1644e6c4acd3f31143e1a3472d3677eb13b15df2d8ae6bbf729be92cf34b98937667884f466aadac5317d11758503e4b849ccbbfdd3a729b6f5facdc764ba5ac7eb6f029407e14543a7f1ef420ca17d0ff264bab813d3d2a7527790dda9a6a71cfb4ee12ecf7431c71b8e37f3397238f57b8b73a81e0633d61c10d53ac6d16ec8933370a0f6b7cf70b5436087ac2510a8fa10f8e7f76929f2421c044307d8fe3d0b83985f6b0f595a51ab6ea0bff8e6fd19807845fdd722cbd95d48b6bec71d169480a75e5d4ba3aa29da86fb95aaa8b90f5d0f49b27584251cace3a6aeba75dc2baaf9ae4a93dec05d7315c65edd6f1a7ff9d82e4c5acff09fd5f3ce891d902fea85ec671828ed85771c79500ae2f680ebc2f3757808d20c8bc7ecf8cb533d88e6bf98f00dfc6fcd7cb399fac5c2303144cc1a4de134b529933e6883c9b403745dc74158bf550d7401e160be708fae56e89696fa01cd361090284fd90d3647868da2e00428705ba9857c4e0a7c3ce352673f458a5eaea9eb1ca8737e66fb933340a84e8d942e53c46d199b94afad2e5361cf7946bb748d1e4dd2cf284306a3ffe78bb7dd13076a1b344a9201145c482fcf4115e38fdaf9cff8f2531719dec52f0640e66c8a6b4de6ac3c259862d1d71cdb8304db7701b64afe5af89ef122c653e89442f35ead95deeea27a537a564cc067ebf239f0b16b406be112dce062bca008a5f55749143ff25f3aa12c6618f7505e7093153beaf72c53f2774d6368ae922dc1f06e0655e6d5ffe723a4eddb5050b9676381a309cf5491c7c1b4f3f4b555d013d7751e6d70e8a605fe5faaf7ffede333130e94be028e56c769353e3cc3c9283d548472cc4900c2633ce9e8f1d6696c85f1fe55cd0584d5b51da4eb212e213d845dd3309afe221bf778fb6dc73154c5aaf38aa0092d24833cbc28c3add24cc964023047b5447519b9033a3f47f068a15dd525b940c4b83fb26dfa9f705abcec6b95e0fc45695bd96e73ff75af5919239b556b6e8ac01407d3bc5d3fe0af0a701f5eb766f64a1ed11867d0d4e3c8cee1a32d492b6f21f70790990077d1e24ba879ed95f6d565d1ea51e97f4a0732277330caee27ce86794e2c305c714c31db9b9cad653ba6235ceb6fc1a500dddc369aab205d54c24bb147b453434a743431fa22e1409c7ac8b5b5a790f57499fd0cd7f750c968e91dc3fbbba190226ad38c1c873f07760704114fde1d71979aa10360e8d3c5f64d706e89b992e0e45fad8a507596b2c05dff2858022618317d9fbb91001a0c5d6a3c2f655b885decce172abccae2508f0fae9783abd1a7c26a679e605e0e960801dd2d7b0921439df54a8ff4375c6a48add2a906a72714cc421b81d6277151835a116b825cfd31eb9a4383ca8076f1b468d2e5d8bf06184de09aa1251c9f659ff698a0f163659ae54e46f0acfa05fb882cd2a9be43b70e42157341d75174ad4c04764a2f26abc324d96fd2dcf2dd5a7f4f062a33f7f56957583c53574aa61e5445fb37c7335ad2da7eb4b7366612f8caaef61e18beeab36ac32ac5e65a41ba7e890b293b1492c297f5e0bc9285efdf413af20bfe6abbfafc80f358b5a84aae903789035b988c9fd7e11f3bcfd795fe39361fbb74060ab33e930350a503f68d4b8474e97a3b7a5ee9a254c6282e0ea0d57161bc4c531c5c19e2e5e8c7964e111f48a75c06093c848f1217bb921190a1945d2ace202fd4541bc4e144435897770a6c9121ab824937ccf13bfd04d9fc88634a5e6b3a3fc9ce89b75cc4510e8ce9141ea4ee51eb2aa11a97a7e7594d4c46aa75bec555353f11eaf8a6fc019c93c3124343d4b4a4662461741d66a29e09560b3e0843728bf6e88b034cd374ad2dde1738924b86f24e73a677343398ffdb913288a43473e0c6f72efcceda8c44eb43513d7579b06dbf4dbe312ad76a16bc08b8180a78cdab77b55d173d627743f64e5756b316816b07f92c47b3051c4be347dfdd430957d9fa7e0a10a4b35fe9c61429e959c882db7dc3d5e6d6da488e32259f954f502ae6524aea91a2c76e252fffedeecef63e2e9d0c801a60128d52eca78e36f776c11c9679150e41ef5a4e708724eb45df80436c65ab542ee8e97d30ba742d4edc1d66bf71bf5d57071780e93703eb308f9039a8807eddad776344d679e007e42a54f19e281f860f103dd7ed750300981fe032163fda743973545b0ff0f858b6a7d7a5f663204d59dd266e3ecb9912ef5dcc9a19f345823d53ae8b674e2c7f0485f32438fe05980f2d54b2828d5cb12b484f410cac77dbda00f70a4262c5ff1f1ea03383d1ff1817522abed30d0cb4c88ee3b5158813fa9bceda6158c625e63cf818099f868a46b1ffa2152b03b67e20c59886bb2c26af8d986f01108b83e82cc2f497a9abc7c987290edce3b42692178b651a6bfcfe666a883a45e077d8ce5bb975c0e20aa302d226d6f2bea231979f61d39f3897ae2716a0a338b78b21fbd8d171fd0cba116ffa86dc0afe618fb736a986940c210a59cf712eae6aede03bba0713f1476a2fdeb1ada55b61ae1a071e77ef1f35eaf2ee76096c85d98a7893e67ea8d967e2520ce9546149e1e0b2e089c8d1bc0d14974e5182e6c65a7c1c68c9e9eb6bc83ea56d732baa75d4215a4f7e18c412e9c20315ecd02c22f71216b18702194759eadf4bc2172cb471e2400477a76089b3e46cf84bcf735405b5fbe5abd8584e378d090b67ea94af7ad91c2eb402d0b70699a1bb6ff9fe9449c911c8f2a392e6320758d747bb66a3544da75278ae71d104be09dec6cd03b0384e60efa972790cc9030306d43df95b06418455b8250ed0ee06d4d8191546d13eab1c6d8c1bbc56aeeb767322e29afda0f9c3b9cfe5a0419137528c92a8dac93e6a144ef0001d40d21dee6ca09466204881fd3a7dd8f13ffde0932e8fae06b8c7b5543d882ee02005e259f3dc40d94a2cbf178526d399ba1cb37f6af1c96a7ecb96747a5d81161240cbacdc5b12f768a727e93ff7d7dd8d5b79c28ccef3878fc8a7ee656ea87e1a985f88e314cc3038194c19ed66d7b8ebd9d78610c462eaa42d95192b82b98d9372fd86094aaf46c00d502817ba1614b5aeb51347c4553c1993e82c0c6f1ab82d5266497cb1d50ae8645cfd99d3e3bccff573defc299b51089e52343a7fc448643b1e9be8f440c01491f97bb8b4021b8632a99ed84461b62260179919e8e79533d1161191d597b390968a482468170c3a72f589c6c0d0839cca68630c0a3cd72e3804e68e12807263a8f2c9a6579d57c15c529cb4fc2fb735484c5fc0b3ffdb3d1fa030a649946fe6291554782a043d54837a48c4fc1af9f471810ec70f0cb531a58ba8e202b37fa68c05ecbeb2c6f7b879e2d1cdebf82023d55be3159bb69dbef13f5d086d95b57a3c3d35d76a389f92bdf80831407dde993805c8131b13a2922cd83a9c0ee3f8b412a39216f99d0a5f09185983edc4a3d0d335a698069988fd3c0ae648d59b300224d92e87f586138c1f90cfb4e15128861b827337d7153d9cf383b022ef80bbeb8b20c455282906e4f84e7579ea9e49930a62a5fca3b86e48dd57d44abd0fd7ab2d8d44028389e330360f8ffc9d4e5eeca7554fc9c2976ac2bfac1f66b1c298c53dcef98fa7c683926b0bce72260bc6e79de431aef2bcaf094eb137e3410b4efbd6847c82ced7ad9d5df03a3791bac0d11b0d2f855251f8ad62a97176b5643641da6ae4dcdd8293b6ffe9749aa08bb3d2e374a0720b73ad83c990b02fe93f55021bc5df791eeac74d6f3ef012ac07962a3dae3d25de9e91074f479c1d8737f8632e835ce4ead688795d1d0e8874b7f8d1bcc683652b6e1eabe55979b0a12eab6884c70d01c26efa1d46ac79346ead139e7bfc39fca09763e4280f5933ce95e66bed7e629916553187a01fb065e4b4a6b37a2a721d48b392ef254b4311fd8f3af1c488119d0fdcc087bed04a110ea0ea6f3e65c8ab4e3a1cbe57889fba4ec320b634d8ab7e04829b26fc52d87b26b45e1dc6a8a6ab161e919e0c441fddafd5b7ff0bc074e39a11b8a691071864fca68d4321bc6c96eb4b5a92d14176ca064aebdf7fb02bacd68ea681202c0e7608a83369db1b14f7c7149e06fe0c600e95e4808bd803d4755575504a9d13cb9b15c4b9aa70203a56059ed7ea92122f2460f44dda0f63ce9b765e4c9652729b96822bece2cf4feb412869fa5459d4552dc651f807835235177fa7721ab46edd07564ae7f2bd64cd2c373b8264a94e7abe5fd48a79b69d71e6ef033bcbc982dbd7ba1f7d4b15c5cdf0c0813564de96d61957fd12d093cd1d60b8b16b0e47fdc08cccc886f551c7461ce57aa270ecc7616b9a0876e6615d648353af3eda520e066fe6fa6a86739a2588b018557df69c18db3c2c7f483371f028f3a842b4f3f1b5781f8958764fd124e069e82cf15e19deb0beb9e2d1e69aad7170ccd0d189c7de0e495c056ed20030f1b99a2a3b6f15a423aa76d62c81b00ff220d2ca57797626391b325624a2b972a413321acb92b833177bf3a0d8b01f537d09900413d2d32443a3654683c03aa91b0ff8ce71317fe8f157f125b10c1484b89d2d5058c2f4a63b9dae95365c5477e2557881034b82cf34dc29072ea0975ebcdde54f155c40efaf67c37373c74eb19ae856c1db24b6c4d6aa5bb8e77d30de556504ed5ce4ce10e02522aaaa88661c6c7cb136e079f788eeb67960d36b067ce98ba946c86f2fa5c8aa596e38154f2980024c6c5f19c4b1973c8068d87a0258de6f89a912d90198a89f1e5244305e75b59924717ca2cfde31d3ac3c179d5ce7582a103345eee37e948e35035ace7bd0071723c8a81b79f8b0179e9a4d734486d0ad456e13c026e5abaa90ef1dde34aa092d25b0564c046b761df77aabd9774c026a6c256b9d8a5e4007b06d2b28c500fb9dbfba01d042ef94b5e63962b8e505aa9a4853c3c9a4233fddadaf4dfbcada8eaebdf17c75b8260033ff0ed8535d8b06663085ceb6be6487947a5a84797d1395731c025a700b0957940c1554cb65801a1dab9212f2b88792194f4a35fca369fa802e3fd65eb957ba754eec813e27c5e7b173ff46e4f9142ebf616ea24ed3aed06d310c518285d315b2483f8641e945d8091d3704a93600ed257098d20365465a718bf654e783a66aa7088506326b850b13bb029a525e436236909e44087e0aa04685b148fbe402e5519a0544de11dd9f5437b9e122d540eeb67a7140b196b9d0f6cc15c851e56e405b43f9905f97c66ac69fd2fa1ce25a9d6647df62a337ffbed0170bde57ee1e9dd489451d4578bc14be8862c9ae78c6da033518566f208e4d6d6133ee681dadf0491b86545a2f535c96c23e1183f705063c5db565bcea2a255f0ba73b5d9e79d0a79997df5867bcc1337b42a35808feaa411b0af374844ca539746ba472e35d90c2404eea7d69cd9920cc3d48ef77a3e1fd8a662dd5ca4d5fa2df95fe4b50b5f83c6ff225e6750ec3448a134d2fa13c4a8d1517b4d4d214746a6145e45627aabb4ecf32c5e2d2c4d6c24b8df5c29aa1b97216227c60adf8e7a4db4bdd2aeac622ed7f527f00c973481b130d1d73a2913c2646bd240f1ac61caf972ce1dd840696b39faae8af3d42c53ce655f929441e4157693f81546be18d55c1d76aa2940ff1155b7ba90d2b0c07b4ca6b58feeb9698fe164aecdc1b04e30546b616704a3768f641aedbb470a6484bd3f5a5efb641d614d006042710194bde34574cf5ae3c79fdf1302ec98a3f9b673d74b15ef47fcf43874d08a9cda6370d924d02c36b4b3b01a86149c26fdfb713612139677be617f51860e52862b3a2f675c7039df8cbfeeca146f3bcc9aa0584118b8f1abc2ff85d7e7ec4f623b85f0013433614d952c35535b89b2d94a2dc47edc86d8651fbaa42fdf709e9883b1bb957c749ea5477c55b13de4725f87f79b1348d1a70fc069ffa8a9a97daf2b99caa09de99427284d48e2f44916bb1f89642179f54d25b96644f1ab499131259d3cf70807da065515b7ad34e15733fd7d0e0152f9f68937eca527bd0925dfc5b049abefbf9920fba8c2f2ce69e52e190448ad8927fa26ce2da545bc0a229a74e5a5c64726676ae6d5710a3a535c84c389cb3334bfb650ba66adb4438812c5217527dce1fcecac70611eed14c34dcbaf0419bef259259750441aab384e42d3387287d0683aacdf84a0251f6ba2d2a2fe1ecc497698efe4392c782d8d375b7400581f92385e0e13fceee656a5ca4caccf30214826edfcfcf868207d5decf046bdff23cf375998ce1cf0d3fcef279bcbbf27f6b7c539a0081dd7b15c2fd8225c14a68acb440bd159f2cd2903f3165dcdb8350e85f6dd0f7e1cf9fe9abd8ac411f4fb9430f39438db1e68720ba057f748e094e3c4c21ed2fd7258a6342516fc5e88c8be7d37a0fc0d12b45d8818b23e95514659f5c2f69b733a486584099d62ceab8f8935f6ebe0553ec6a2c47bf9bf538ef6092fd082fde19d18afeaf02ada313e840dcd22d3f2549abbb52c22955369234d390cf9f719ae614757093373b7ed3135256408d7efdb54c82fe7fa8aaf03c18047fbb6ccfa5afb2b2de45d3ae706225be8fe24807c18a18b2c883939e73266612883b56101139ad8bca685f6c10bf767b41f38c6692e682628aa49cc6c869f021ccba01cadbeb95823bea774ad51c5b8d4585c4da7f3abc77c4eb6b88f04b1ade989023f8ae9992b34158da69579761297a61f96c8a9c9a6e09a12d449e59d2e307c370cb7bf39933ee72bee7c05f22d6918742a5cd730675788840b9646a5e727cf64c3a55f176956ff9c7ca9dc1d0b20cfb01702346db096e9fa073d888f314cb2e385d35a2dcfa23f79f8fcb61b8cebf407fa0ec3d3b129129a1724839a1a23e2d30cf7ffc0877b46002c759cff247e4dd7b0fca25b920a33cf05a7671392ae1fc7f89333e2286aec260b167a830e81371d760a1734b4831589035cf031441df92bb6a0d6e351bdda88baa4388aeae3029bf4e03a4a9e6455b3bdd0b872c2a6b5024406151889650792e8ba9e109554328c8f2ce93bf24f0075f6a4c69fc7bd485a79f7b77e552e45a8f756ac7da4e9bda3d5377b006879bf4dd163596f84cab4bf53d7cdda0ed2b1a1243ed4542c86fbc39137b143596fb4b10b3c1884af01cf54cf0fbe0008242bb79f3c3f6654172b226ef43f0c166d0024f43ce81c21a735da9f49b4caaafd4fbb73a9278e3f4655ceda39614ad63f88bbd3e84820afff58fec2836a32c6aada43f3f955abd1bc3f38223897c7e3dd015ead5e3f543f4a4c7d2439a3aba58b2e32eb14b841f56543e54d78f5e666ecbfe64e366b374bb33f236f7f93d319c99dd065497771741e3e3cc9abcb6ba01cd9e864aa288b9104279acb30cac0581c49dc69792aaef65e449465a6edcb6290ac4be04dae79eb9b026fd6a5048d7b1207c796f3ac0fd35ba9154e6c231c3fbc48cc879a202be0b69fccef2e405e7f5662dca800d6804a74a4173a2b066b6475b7f00ab29ced80b10a91e79098dab399978bed40d3bf5c1e1629f8256641847ba555ad079123e4c1710a5e09aaea1f29becab223a6f73690b8020af0e1e4f518a2bdd4d6a2dc4f49d7fdb18be47a1e10c0a3cfb646fc0bf3b467ef50e2644c9bd451ade4e6df7ba8c5b8c3c931fb3b2ecb475f2b19a2014f5e3a2f7683600a7a2715024f09f980ec1dc05bbd7cca8bec9ddafb1f3acc21f94f70beed7f34fbcfb9431a19e42c646ea5e5f0135ca20fdefa50915b3aaf94fcc586960a478fc2171d71d2d4d56ae631dfadb29cb9dc6713ca4d67d94310abd821bc255195c9ada55761c9fc7d025b5e0a8b712171573dc1031aee81bb7b6e1b2c496e15073f4e82e743c8477eb5f7c915319177594134446e85982a4e5a569a73d522ab0fbd81e9c12a825ce3ec6d7e104eadd7491ecb2e0659547150790b044199b7b1d2fd3ac5051fd5e8173b6c056abee48471defe9abb6e35d0236f280c13c5939f6ca3bcb6f9c656a7d0c2109509c62c72eda6696205bd59f4f99d4dc13a37ab5f5fe7e06b77939eb4cff518586030cda133d144362af2494828b6cd92890a40792117e476218bd400299a317c7a71671767f059573d9a54852f527b089f81760cfd4d8a60159e8e9fcbd5c8bb882f3822ecbd8b6b1b58a69c3e4bc3879d1766449bfb17311301c54a8a250a620ad69a49a9c49ec373961c5875b9c4122832d1b02f628775b403547bb02b8632a87104a9facdb24a3f71f00003a4bcce4c6c185bbd98d34deae3fa47563e71153a7015d1b3c986b1a0c7e8688f921551ccbb9638eae1df8397613f2c1de5820a480771644c236ecf2817852e3774e4cbdf69c27e2d2d6f9115fd7a7d4fbd16cda1492d332ee3d472308c8a3d54f24891dee2a69c268961a87a5841c4ca2c35c8a44640c7fa97de343ea4b655dee7d15e7aa9b52b8e68849c27811088fb514b6ddf333bc6cf0816a479b235602d8213c930c5ca23a94d60fd78c44f590a4a927f3883c36ca2a4907620228eede165a0c08cbcefaf9385ec173ba94f5d6463d9a2b436c87267eb2a1e2e7835e940fca3c5dee2796366c9a6cd0f0e543c8138b71168ebc5efabe33a78bc0e294d8e68520641e241501c2fabbf70f25f2c673e5b29ffbac248200d0d8417170b5bfb9b83e400e346fb17fdab89776b716c499464ac9eee4edd76a0e1a37d759b2209101a4197152044b8099221be11fec75207a2093ab6ef4256717074ad7128016b9e3550182031b31829897cbf7960da055c889512f80365d8b2ccb0c88751f6ffb61bbc7b2e296e7bd50d88ca8db5c68878dcf767412c35c435e381b14daaa50d6bed4515e49cf6317b72fc89d556238bf19193665b3cf8cf4704d149d78eb6d3b5145694fe9b10f360680405436cec9011375bd236d2cf80a15692e7ac4918c36541c379fa17877c60dfded01a56bc5fb26d7d2060fa505fa7ff255e46e5786f3cf0cc64730825300407310aadc78da19dc7fb25cf4e3fb5922ab9dcaac4acb3f099b57e7fe36c76c31bb1270db6dafc1c776307ff9c05f68315ccf4b77e18f049a3d20c33d8d9ff8179dc37c3ca62a0a5b491ca0a0671164c78aff1e3d36f34d48df3bccc8f78ac378452933e323cf0b5e8ed93f1b217c2bea818719b4261f86e3206c538e0191ad3e35ae9c494766a840d8b5da7fc1f6a2ae7349189a1c07b77ab410cbfc589d674a044d8daf67127302919c26d50848b69979383dc35560b5a859a7a8d9016b4e4a6b65f07ffbd6af6f89bd219d1552dae6f778e0245a0d2f41894db00b6d6d53bf099fce075bb2e9984f4476335ad55b47bfb82e4a483568560f732f877681da702a00c1b6069db3762750ab51b4184b48d890199eb960f191133d20ce556dd9a1a4fb1ce7cc356f585024644bd0e81a7628528588c849e6fd1c6c076920e70d6630440caf49894651c9e74a116043f41a6e188903cac8d06726445dae94a644664a070415e4dce0c82fa4b3cdb6317a67576d862888d92f6af6afbde0a575869dfe987f558a3710a0dd11d702cd28108ba344143e5788d87799c206c7bf5163dd92edbe3c80b97a86f71ce9292ff7bb96ca35fcf75cd7e41aed514cf7d881ee743f70f9e4ef3747ba19985bdb628602ca9f675fbe7d61e2e67d895e9d593f13429578501c31940466d8edac90214e08cb7ba03ee95f1928fcfb01032b5c2b49266347bb652a0cde00837cd92917cd3f5243f9eb83c3ae1062200cc5539e11ebe4c50575b5949e238e3a75f644eb6bdd43daf0a36f170fb1ca6b68497f6a231c702da6a82b0999c07e3d4f8830400ef3f998f1118e476f41819c23600493515e187fe48a5ca75a7ad8a507a2de26bdb7e83c53edfbcf083be24dd0af14d117dc50aeeae11bf288b4718f74406ca1e52066b2838656311c0cde013d8bdc25b5d87e135ec1ff14a2605c7dc08290cf93d8bdfa4c8c216d2d1e9c873ac4b1fdf52e953e2b40a94ef36c6e1f905bbb5743e206c0ccbb2d04d77","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
