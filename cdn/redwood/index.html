<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f3b5c7ea9a1c9eb11f4a6ab18176dad965aadc8ff9d088b379e759bee0b382284bb6b0a462f8a41f9a59476a911371216cd8e0c388e72fb55d3f47128b3300aa75dc32d7870d1b4558f3ef52a914fe85a8ace65a2644db414b1752121bb8545a939bb812a07ec31d9b0eaf5450a1aa3f2807839f7937faee5238df14b99e1ef6842abd21615662802a6ed84ecd861e6359c153ea2f3f8b8161ca1c043e3579576a92d02a0af1ac4536059ab5b7cc5c8bacde65e2e2e05f6ec531233a627ac0aacf34a76ec0b5de594c831828f8af8c9a548f4a88f745fdf48e0548d8e3dbc8f1fd17c152a4568e4fe56af7e9141a5952e6c0e8821f3ba6fb4a9b23a39ada5209d45c213e4cdde4144af82609395eba9ffed38fc0e2b9b9b9850ba8469e14c7a880c93f784f4e7e4377892889c2e73a1af68141ee0b2736cbe3336a5f00d8a2e8768f6a7cbfa025ae28ea659b2ebc51f737d23209d864b97fd2392c20862bced66ec6f52d6476d1f2bc5f5a9cc83a0dee10084dcfcdc66384ffeeb14e7e3c1d3af5e77418c80fef3fa52b9db33fb0fa7a4f2999ee6c6fd6a675555345ee106c567b444be7e1ad4e81889aa7acbe3c62a823f9f11b9c0860056cae253e46c5c687ab080b1a14d74a1155b5e45db270e404caf207c4afde96ec89688eafbd4b8a051fa17808364b249294cb42f1a40562dcf382c0628c7406abd86dd5d1c4be675e01f133b91b2518535e8a7f6136245aa1e49afc371988d56ab5cad27eb0c5930b6ab3b7f40cb9ecfb9fb67ff1a9e6a3d37ea845817cd174e138185e5102d950e1b3e678929e5f7b4ab2ae52c52ebca46eea5add51fe9c90c34203aa490e60d9e583b2e4ce01fef6514bb3a00a90f33359406c41cac76e0fdd09f54976de8dfa7476c03e335ae3175ebfebb9e0a6cfe2839b240c3668472a647bb5399c93c519358a5fd2cff62e12477f5118309ee27f82b08ce1b2aea75d068d39b92f48f4c8c97c9da053a2534e68ff2bb353f6ed8f218e4e65b938e2868aae75d38865a6bd642d9011dd2489ceb79f9b9fc408436904139bae33a416607c2aa5f38c3c868b6f94bbfa648851a1a4abce4f8929771879c40705aed2464bd8d6b86b5121354783247429cce06703e75f1374866f21c4cc6570bbdd307d8a891bda8651767cd308960a45e0b974f37cfd311eb33b1f3dcee233f6feff9b57795479d0a768e7a746d35c8c936eb827c50a8e566d1c2b5cd2be38626c824c49bf2af11ef6f2b1fa4f450e2ae31767bd7a7e1256ccd9aed769043c40c8a9fe15508cd093676ee787ba3609d953ccc18da1bcbf5d64aedc33fedc4663e8dcc4d15294afb3bc979fe9ea1a80f31f62e1e931ce0ae10c2522d67cbc6fbff723736c63cf0531ab256db68d59606ee32f4963bc2153a396ea075797a0643bb7bf106e24957939b2a1773b3ce5493cf116b9b0637c47ee1c230848639c7c61519d2ab41c06f8f4193648d386ac86f76332342b85b959675f8a397c9c5746a373be61760e202fa1a97ee301a1bdcabf49f002d6cd334a9c7b28048c5ee142f21c2388eb167c2ba3953e0f4045d7620b8d43e406eb4060e45ba45c19287b58d7e9260708d7b0f4f61a29111adcdcf78e20d3f6fd03afb16dde1883681d6e8b691a840ca99b001fc96e05632ebd0653e96fdeb79728b6f6d13b4a53c84c72e824cec3f54fc29dff7fd2bf2a70f190544b4dfe12928f3428e9f026a284d5febdcb45c1fdd51b35798ef1305800a93d5e2c0c519a187276a0f6679dee6ac88ed59e45f66b520fedcb856c1820887be804e7f3943826c36d24d1f566b9adef5e06d2c33ca49d13a32a08691c681e767665f4979a2c9ac03a0c1adc7a9166af99a5d582d84dfc09385fd18a14668b87a59403bccbcf21737b683ee7f70c563b2e199ad419f12cd13827dd5d43e8bcc70db336816f94f0d1656a5ab66031c9d55e724e1d47b7ee9e11295ee52809f318149a59832940263ea990851fe5552d80deea1a981a0f32016e82df7264d4ba5a8e7d8807dea6558bcebfefb86e7f065c400604fb9a0cbd5bb2ef124548de9683cda1d46b3f46843d558bf947dcd86574b84fc98867b45f080b1a672ee68a4f2d47f63e07c4d2d5e6b4f48f0eb20937348b74716d5c9a37ce79554cce90e690f8a467b90c744f1b14e2f9260b010d3e83992ee1128a62ecb5fffda483694fbfef77d7c16ea82c0eee8021ac8b4545af52c2d9fe3a4657cf9064fdd376781db050cf0f31fd1bd936428cefd5852fee1099dd99e35b4c6d7e4bd98aca6f5680663bf8551e91d08daaab7d576d9e0bf7d7db3eb61da54e91b1329167f5665019ea3250217dfcd02ebc5a7195e4952e92e02cbfb945db5517cd744949653bdec24da61798e818d8fea7e7580ac43a5c324ea583aabed07594361067c3f3a29ed0e9c356f6a36295f185f64be00cbd08ea98d086c21e58d9e38a923b6612a14756bbfc413249aaf6cf6b213e2fb8426af5f188630795442eb2e156163abae889799cbe6bcb97eab655f54970033f933be75dab4e2246c9911446570614f8998e5dcca5f7a26072322fe0210288fb3c0b6e5a916a00a1f170a402db97522d894de5ded3e1c4be26d5bb00cf90d1589c81ee70679f97908ff89e1eb10c42c8a39afdfc1d0dbbd359bcd7bb411cdcda1dc1e1551091da9bed0dc65044822397873156c1f03642d9e3fb773a434ba6ec2158950a403af13f4e35fcb9c76cbbdbcb13340af7a6796aa6195d953b093b7f2cbb445fd3882c947262a1a4dcfc182e102624c924368053715f442c7f773cf4c05d742898483e540433e4415bcf9d7d79278d3cef9bd6bd03b4a9c70e9908c1df305d93147ddb98ff84394a269226e11e062a870e7d156facd24543c8ab69a7740242022a80e3591a4490116a509f508cabdee00f430f5c07b6a84325a716c0acc5beaaa7ef283e80473ef2ccb4e61359dae1c21b26fe7b887e8bc415ebfafd8078ba99d9aa863b07057ee0c346a9d25b0138f4c933377478751f48913f004cf9fbbe626bbb60857921a5d6da2a029b0984be0e90d6397ca8e67912e70c19595dd4bdd43f6acd850f4fcab86c1115509b1e864ec458019913eac49457485269a7019885f0aa1ef87039a088ad0ac7c8ec1940c99ebd54b4b220a92f71a75de8bba6ba53e0ece2f64c625a0bd01fe7de4a857a602ad41117349d0a8e6989efed835dadb9721d263d306fb870ada9fa1f2afd5764105d451aae5bf0bc46fa688d0b01ab9a59100022ffb3d0f97b5e3dcb5dc23d02d026df488c98cc6fa52f0428961334e1705641960ecd0dcdbbbf96f8512b3e6d697b7c03df1cf3e95cb3be55e6c9383bafd5339422f3931fb8440ecc6022be930c4b539e5866e8884de548a79d826e16dca88607a05496fe7ddd102657809132efb173cf9003a56531bedcf06b714b070ae5046008c5ded63e11dc21cfe800fc6fef065ca85ad1ef39f26cd3ca07c3bb22906c866045a5de7fbdc111616c07cfe111568d2dacb5c53165c5442ae1fd490a536e3049a389c9b9b694143854a54b377bfc529c66b616815ff9e9882b72e516ccc401ac99b1bc49feee4aa5767edf42ea2fc3712037b9844e4ad5bd679c12d155fe5d11572bdf1eacf3035dda982d1234e3f298fcb7d80a39cc2fa65d32d27b516f7f29e2f9f560674b61698f844c0738b6e4659f7770fc7e27c18431eaf505e27e5d58687795ed7ec364ae9733d01907f6a77fcfea688fab027b1d5d00e8260082dfa09096f323f674fd6ef4bbde476c3fde43b33b6817d5327dbe9b41ed4cd8f8474cf0f9a9806c2df5c11ab9bcef187793e2628b3d57458b1e120bbee4f180596537e5e6803a6acecbde8806bead5d0ed191c7688174a14551e8b5c969fd500504a649c3bcfae205941738ad8a350394d4570fb15d4da64ed1a9a335177accd57b9f3f0a392c2f7fb6e5c7859305df7961396ed5a2c526dd5028c7f9bc4533ec6aecc7630d4f635a3be44787fe31ab7a1da13a52a86c2526891250cebab58277efd9abfdb1a3eae51e3bc31b85ec674ddc92526aaae203f14b070825047ea634f9e912701413a52f870df84a3e2bd2a3dd02e9455a80581be14ef09b86e1f69871cd249a933580d89348a84b3cc5a7cb259404fdca247f9d95d9027d2c5ec66442bd00df2d11683b6807e51912be6e068c05daf72a9d17e507da2926a4dd503716005ea0b6465949ece8c2fcfdb06c70ed7927114dd9cd50aa3df44188e8dc77ecf0534a740c3ccca00091d6335e0fe0fe172dd22746a1e7b839787e714cced3928bec77ee958e82f67f43e959e3e5ec6826afc8d24a2b4e859390b731c6177b06207ffb63dc6a9e50063a26a9bdff138141c74b7f0a7dafa52e8a30f9573c8e1e65cefc9f1890999e053c9b6cad3774b18655db9670cbd1ea1488c71f4e952d3e137312c8ee4221272a34c6ce9d148e6dc91295dc7027367a00633120bb03a396853006a7faeb615ed0f8ad9fddef45aad43c2aaf3e08df0625da68f8a945407c0efc3c6c7b0b0f35c802a5ebcd96457f3dd982ae2e777d9eb65c4965d7ad05cf50d53d0aafd81044f57685f65d9267774e9c49defcb06c33cb90a3f2a4bf2d71a58b2b7e9c114e4149bf52d95c80dc11d8123e87c7cd2d91b9a2cc9efc137edcc5f5b511da859afe114be23551510679e931f1437840c6412f767a87b9a46af0d10cf2063e383625334a681100b30456127a3cdb8515a57c962dd4863a3e654d79877b4a8ec04cec5204d280d77e22e15663e90fc85fb709656c80b1eaabfc5d56a58153f6202dc9c480e0944fe50cd2256ea73142b8e23288733275022e1a257d50e071e3e22dc00feb775b9612bf5c696dfc441c947a0ea1b13fe2b6c4f1aeacf637931e0591492742bdc086da7593fd3965a4cd9262500bee4aaa1b3074cb0d6c76f4f8aa0c2d29a8f3e89596d55e0a197a17657af8714985941ed38539907c131394d480c57121a50d080e76ed1cae629a19d9d723722de06c12684ca64f267860a6321705fd2631c540b1ad9ca95b71e512962ec7e237eace514d9cedf70b1c1c90b668960963ba9fad16f3b7e829ddf6ff63574ab86795c35d46db7072da0dbc15161c143a5f8825e063f0011ae42273d65ad40cfe4441dc98cb4d902b1512cce1ac23346cc10ab13dea1456506b3dcc6598f733c6b55f52ba35ce1f47ddcabf987e500415aae900e427aa6706c4cfd29012a0d66709cd586e6591156e7c7455a0f55f5461e3a27f4d16563904cb00d4cd3bafc41b3069a59ef48c74278d201732174ec32b562a2490d90cec6693486b1a6c68398d6d036228701d906df39e36d53a7101913d49d9fe36788d7d2befa80fded4418ffd4a176b5f1333116619acf12351a2c0b8a920741f271247136e20fb9c112f94c41a70520bd924ab6b251e4fe50a95eab0ebd53ad6daddf0e2b04075f06f4877f6d98f2ab2470527bbcca8860eadb9a6443b005676b38aa82fcd0a5f74d73f62ea7518ab4d0f7f1329446d14a4128040fdd29d9a6f41d74a4d31c8660dd19589e5368e093081b2cfeebea3527d1391d1f1be1c8853302b55746808737e5709e671550dad10bc43e7600eebc7e452d65cd0af3899ecadd1b16e6b0b51dde169ca1cb0f13799cf251e440781475753ceedfe72e6a1b987c47c548719830b6b0323cdc11034e73d31b039475451c35c32ac40a9d1d85359483b94460341ad2c1a4fbce03ef306ed03f06f2b6977f580058e8483cbe0f9977fe88e8a1607adfa52030f463fafcc904e807743c68e2635611a643ebce5571f34ffa6691c6aad2e404a21e8a1d17eff9c6d859643c9c5f7b9c67bbe373a404baa679383a1a11aa6f857f9eab2dfebd1d3ed09322855823086663e060f8c33dc29baa6e9a6f6309bb3e9a0606ae6839ffb0429c9d408f93ce8c09683907d1e03b5e05b6d84f9f3307a9b007df0c77ca6dab6b38a48c292854c1d1f1b72e72a4a4c775aec56926ac7f1b75f48672282517cb46c56dff3fe930ff11f127b3aaf8ba60f05cf5597b77a3bbe287ecf5327579e7024a92493fa64356538361d9d476a21cb94e338deffb48a3eaddd66b7565c21acd4323c0bd09da740d3d740f6d137c50e1e19fefb70e19087aa73595a01113e72f7ecb5b239bbd33ffbb009c7640806bd0b9df88d7be54670462e93220d71aec0b23d964971542b02c789410ef62bfb0d95b3b0103a722f2ec02325fe5de8b0b0f0ee30c81bff84738ab4a5df004c0b50b31794b874ddfb7de38ae0e54fb792aa4ed7d27983c72cc6f9c984f1194e9789b043b13b87da98a3de7d2b99454bc1ad87a6f0d09efa3b7aa91ba6a5ed3b1dc958243c50896d02a6239169b1d8760d3948ade225f68e519044b4b62d0e68f0444682562a21cebfed60f540e025190d69421e2ae5a560fab87511abcd68378e1fa2099eb833e4d849614de8565a06679350ec44a35eade4fed149c0bf260f7056ad45ff8863bcc0d7cd7394ee91f792ec4dc08d79febcb0cc546ec2db983b4bdeb656d09d665365941271ae11105d74a42d5b46bd6859eda724069eb4d175c78a47fabef46b119b82ef46faf2baf93fb1953ef1c020173ad172166fb50712fb6c486adc8dc6466b1b350612264ff62000e3f50709e2654bbd2c37a83ae50463100d2cb6540d592a9fb89509ebad1b949ac27b6531394300ed9d4526c13e54f0211ae7810833a894690b9f57ebb8b682c47b1adf977c0f1b0755a162f1b273a163712554493ad52ec118c50f1ca4d6b8a636cd1d342d60b925da0a77a8045c4892ca965e0a87e4deb668bf05043e6d3eafb71c93585ff9c5402b0b10de6506d28bcadabebe5798482392efa2a105fc658107d9c837563cd6aa2037b2dde081db3e2e08bad475b2e8e6b9415df66c187865c950a9e25959b6ee332fbc7638f7ec8ba1cb2ea47dd8248bee835b0f97235b742626bfd8c74b40a0cf447ab19a9ecdb9d138137f24b00ec2faf20de86bb90e26c24bd8e6dad958f88b2a1414e3063bafc612375783a40e11a2022bdee02d75c61ee6fa857747822aba9ea5f45686e812a9bf221334a7a8b8d4dbb4bf66f1340aa7040d9a6e0f30409532c52077e7d2c299456eab3bfac6186cc852d86397127d88c1a9834ffa89331bec8aba1b697e9e7264840d250a32b1ef35ff8e2129a28661ad4d015d9f239c4839b228f01522ab5c80fa9031a1699a8f67748cb4ce5e36d866afbf3fbb954c5ed711fb5244f52c1e40db9460bd17d9b28dbcf2024466b7952b985c54fd1fa118342ed6a9343d8b0dc5fc6cdeb5a2f7595adcc6f54f364cdb3ffb0555e7f88cfe19f1b8e31067e5b446acaf115da4f8dd8861ce79702f72af186c7b18bc1f01995153f7e79c81e3eea94a4b36cb59c57f04d5522da4543ffa3963f8554ff0bacc70be7338308102ab9a5c58bc64c855a299d21db5f783bf49a1ca6e901d5672b8e2fa19d4d9aa21af1bbe877276a6af8e26a008632b534a4dcf226f804a4a4385231b238d5d436b3367607e42f0c849bfd90d3ea0e327308096f80ebbb974a3436f04552394c80e1590a3255bfb3e19a54d8850e54562066bfc637b54097644cba06713b88473de7f0a7dfeec98e471fcbb0914d26ecf5ff90b0a2caa244ac63403d9a7cb27cdbca0797d1b99cee1f5729ca3aeef0bb57efa2951b062d9550e6554a38f3e771f81fb523886d5e4973d73a6d700adf28b420a9d31a1bff12e18707555195b933eeb4a14b07321d05d96279a37032c500254ce4a1aaaaf7a7cf88fdb8911316df320e3ccc329c4b5f9cf68b1d68bf017b774024d3e6233cce1d73b5d2103dcbabaa9dcbf129fe9d55a922e7f9e9a8ea2f6c9d40ea4ac3fe19fe601217ce67c85157bcd326d3598a1a5eb5d19cf5bfb435f4a2cbdfea2451460d8777eebe085a94955caa884a7fd6c1f9a0d016740bf3ba73310c7e7dd36813c6cdbc2802bfd81ec5add92becb4ab9825bcbe3135bce15caf87ca52e59101003badd31c712179ed2e8317c05cbe018634f792ca7f9a3aa6aae005a6574f112d4c86b823c56727ab063585eaa28508e13b23c0dd65a8ddc35016957d06fc739c309938e40a5504d779c6c2c94b829bd07c59c8d07a6043cbad86fd8beb2631dd40bf07ced1ac361d7d022392f756945a38181a24958baa7bea47d040d418ec09c86f215a8ca843b98f2c838120c90bf1e1c00a9e2aa15cfd0b794df7f1adc561e4f33d4bc4a65e719f7c6f624d11645467232a495c3b6ba87603bf35023bce09d7ad3af8ef447d321dfdc166e2def4b0e9ffe951ac0e4035c3ee426afd5c4ad150d2077240c10789601ff48c26c9b81c00d433b92c000a4c606c95ec5c74c8b2790d6fbf149b39ad80c4ef178ddc9f51fcab0cfb8e7a53e1ac65cdf02b9f3bda5a83d54141e6ea61dbce7628675f6eb770e9e018cc77cba877f73020332aadd3a0dfe74b7e3ad7419c975cb35a685c1552b0722c375a0b6322769e5429e408abf91073704dce7afda8cc44476db740a53d2cf02abe46e1a248e1dd3cfadd797254d210fe24d62f65d90b71562b20a1431e959d7cc15c0d288573a17e26e1f943dd1c6250b0f2fa641b7f68a5c10122310300b8b30a7969e0ebb88a513537e143e524af35b6c4a06ea11963fe77b13067656acd76fd56fbb0071a8b411782d44540ae47b1eeef12a2af119b4f536b7e65adeaa5b3266671de90bba9f225a6583beea4cf22a150a50de62ab6a6b8e413d3b47f9da562da36c4a5df9f042e8bb7db6be421fe3b9a19bef0b38e0b899cc0a705f661f31a223e9de182fbad565407612521390c94672458a635ce4e9f451146965a76b7913a81774200f476e2a20788c4d803cfa5a6d3d279cd396768ed3aee4dee0c1efbdaaa3e202b2c05c35447ff6ff23ec77a190e3c8226adc020bfaad28c4a20287d5d0ae95fc67b22aacb08368623229fac2984eccd729120fbb093bbc8c1448bb052ecdc98cb71abf8a61918a85fbec359d3ee1c737630ad1f1ad637c6af9121eabf29db7a99e8151f209b8affb3c0b955c806580bc3e606c5a46fdaba1035e4c3845664bdf09485ce363104c272e5442a1afe11db9c05aa6ac8b570d68d3a6aaccaca377900cf655330a07e7aa851224cf62c6859d483c84e6c6fe258d04cd8097ee8a87d479f744d90c65c18ff6cc5291901e9759c0049cc578ce138a726476d48a9b9ffbc8e7b3720190e9ca6e8db315bc9bf18aa632ce0b2ccedea6a0443ee53a60174cd0b5d8b37a0896a348caa8107752a37c9939ab92856919921d6fa3d4552af347def001efa2a280bbf3784074d5ef7a9c9dedfa28b798e3b3cf2fbe7094cc49e57445a4cc8648cb857555c7278d3b37f8c167b81f1813a7e07cbbf2d399ec46e5dab5ef2590ddf1110cc0bad3c77a4798f017f33e222a0093341d7e7d906a178fa100871d8f2737d32103895b28e8cb508d9b2d14d04fc8c13597d2de330a1608ae106f90386ba39ef9c03bb1b52ab306ef23e1dbdb42ae13964682bf24ac2564fbc9d575bf1fbb0267cd345e7c09b99567d2e9f011a9dcf3c8e3daebe552ff200e54164beb170e85b5325ccc784be07ec478e857a427c8d5defd742519a4162134f18461c9c56bdc6c5714b2cdc64705fb5f663dd1bba5c612cf2f97813e1c6247a20ac6e2eb9a70a75b8d418a8cf90db573e075430a1ee2dcfec0f92c0f42a0d32625834d5ac3aee41920a4473e973366f07171a7c1a6cc75a795069ad56b9c1ce6e3a12cfdcaf622b52d060f7d9827b64ffcc1b474a1a45f719a9316c2276e90efd6cb03ed7b2f5d74a9a6d6e66d2109d6615a45f152bbaadae12983f44d169e6b23bbca979895e5203f5d453da5391a4b88dce1cc3ac893d1158bff5e6f858c25a64f8faffe92290a16d0ce75e4806fd4c195be0cba19597e011c21eb0a6b8c35d14005b13fc7c0ad177f172fff884b5d60de4d4f6648b9d9696c9d512efc1f7754532842bce81f6028a946a31b79ad011d08bae279c03f93a6082d5ce55d409e149946474663a4b208c1d5e57e6872add2f1c627a96ba309dd7136ce2314b42de4cad6a4b0b5f01e85b71a5c026fd4c6270c0bd7b14ece95c17312ee6d4f6195daec784d5604ac5ba4861ac7f899a1f68424c9720cc38b05acf9a5c661f845e1a0b88d8a9fa769f669fc9279c752b99d7ffbb9a3708a03e8d81fe06286481b52144ea8b02f0fb29d678cdf6f419f45afd967898cc6b9a467d5a9c2d2c1847ca635fd6e99776011c57fdfd7be29785ade68e85258b9898eea3e691782458b27f7f29473a019c68cfc7c99ee1f61a011af2dc93ceca4c9a8d7d00ce6b2ae4aa389d50ba948e901a713069c31e1dccf3adf1eb06cff158920b48927030565e77a46f0608470d64f153b9652151856e49da4e97e66f06bcac43d5d4868e8baf9cd5a0e1057c48193d42a80f1a8a7dabd01defb5092c2d37c7a88d20cff798479ffbf05109fb9f9b2871e2496cc8d8a531b9a57b7c524f01a68eb9f5b0d6d1a24fc056a42951b970164d5ffccff27788f9ff0474e3bfcc6ddbeb3b0f8fc168e764ba55f2f1d8c070e0ae579b4976a3ceae3d3830695893335531d50eb99a723c45d7837ca7dfdb25e5c645e67a632dd13ff39cf2c9c9a1d4bfd75813718d370acaec4a418bc4d535e7e6dcf2e4d6b188f80ec0cad4a391904d777c336fb256b2c1316d581aad1368f04ea31d4541bcb9db969d26d1a0482b80f7a1fd1c5513587da0c4dcc22ec6f7af256b7e637d688ce908251fbf0c334cee9a608616b0aec4e5e3c987a6ec6a376d1079444092cf5ca3a2f2a1c4f83d989a106ac4fe3ca993ef1d3c3a4393f935e127179a0b2ba01c5980f10685bae113e7e5cc61bace61abd365c544c4abe74fb2dc93405931ed2a7159ff9d7b2d11ba18b7841acb9ea0fe287f0ddda2ac8377ef2ebb63ab4916b37a851f5ea61013858963de1116fa2894a188872fcc31108edc3f1f59edb6143a894e74253cee50555c16bfcc0ca386f5672d7605f7b5840ecc2325f17b13fb6db492b6ee380c16f7645c8fca16f4b5179f00eff31360f8d07dd841e2c1c112f10dc68c95099a59ee46b76eac8d21e8e64ad26014d94603a4db13a275faddf6557b00b6073123a091c065fd250bc262d23a72c884781bb78c730bc91c0f678abb6c304af8d2b586b5589dbf5594e3051d2269d5efa3f479163816f026cd3cab47815d5781f27695754a05ec4d7f6ef39f6ad8efec0ba2c173603c320fd4e2606acbd1fbf1af0fd0da112e8b0650fa75eb5b0a9df439d0da12ff43a5d187a9cfd2831f883c8858c6dbc0c36650fe937d33dedebab45a4bda6633441fc5c7f9ba01ed0da9a741e4aba456798c309d6e97875d986c32612530647f1ead85fd645362e1ba7c941a164d8c272d45ef434488fe1c971403ea27470a959771add53b82b3810c9ad4b9d81a58323529413e8f23dbd71dd4fb2024a8822fd55fc30f09103d524408f0650f5d0bd40d06ac1d0f3e059bf0ebd1fddcee581203e372be01ae2eaab1f06d0f66d70e72eddacde172af1807353ac6f28d9919e332a71f476d530839568e0e2225a8c196574fc626dc998fb128a3efbe340e2db6af6c043da362ec886725838485d0dbb17741e5abd74905c549bf6e53ef7c6ee0092508c633e38ef278c7da59e4f09c591befaddf8670654621d31cf5befe42fa46fc3b5f2d0221b8bb4900a6c40d1c53253ac2a3f0d43f77cd2f05902b7931c93a512d33c13507ec112331881b61c192afbc17d1586904ad608fec9342f197d357b313bc0604995123c8a5374ac2ff2decb32124e617f8b428a1aa703c545a16b338d49dc48826e630a45647ba0efb6d99874de6e992682bca6fc5a8ad03011d80c994fbb073e4eea35aada3767de076316faa47b11e55d14e87a43f3031aba34945789245a352a279d054701af06d1b62b0ef37a0c1837425967a6448322c5cb05dc02d1e0a85e1f867697c2882b86fb3380ae51ba91fd5a1cbde85eb679122e0d4c34c310f977fc3e89166617854459c15562d03b18e6601d607e07b595dda13b7cad546b7f2ee0f2d29d97c44ed1cc1fcc9af4a734a06689a70a4bb2d388e839e9e4475182b2fcafc1b75825eb22b08c11a30072dc0d2872c5107c29aa41845ed3729c104f594c30180ecc96ec1e04a9f7e286a831646e18fa3bf90efe3d83cc571b3abbeaf6ccea16cb2c42e2308bcd0ad02a99676d41186499a4a7c79b8ba4f45eed48dafd43433c6bec65f993ee1b96bc39eed278bc262d7f316d4922736ebc5d577eb322401b35755a50d31628d8790a16e1df5dd10c757b2d250793d522d0443aa5928a8a1967a5346357d3968180c48456409bbf6745910598c7bae5c542cbc00fc743089ac6755ec0e00b40e404bc2165a2ac7eb0bb600e638195cf2c45c809765579bb471ae0f5fd78109f9b09b9e804917300fbe21379b19dbce6f8bd29a4b8f92aac635b90cd653002e7ce529839183d6b469e19b4602d1914562b23c8c74f841146adb7702c89fe2ab1f58249b5364966d0e42f7238a7056f0084860ccca95e3ba25c56c6cda9f58c1a754f51da2eefd5e61c82dafeafb196e089681ff35ecbdb89601094997820d4a16cad1bad4918c5f834070561c71113f8a7f36c7c9c73f417da78472fb5dc7db38039c3255e1372202f4b95dc5ba65c020243b940d30feb8ec49d31f85da5ca898440fc25c6d59e589e0e7a8aadd5f2fcd49038bc5f6e704ceb25e5bae993874954951d6b4a4d817a7988b9cacb524174f810280ba0f94aa638270c9f82a9684de928e713e7abc085a3792c838e875908bdabc862fac85bf8be36927225fb0d7e1f63598f62d651e337bc00b24bca070ae163a0245e29902b9bf5abcbb49d407c590b25b75861fa6448574fe01f315d3cbc9f49009b9e6fa5859f7656d803acc129c5ef3dd4fcc761cdcf8525e61403cb1c10ebda727e26f4c4f230ad51a98387df24a7a66085a8a0543373dacc1aff4b36ca0971ac537de80852cbb811eea098499b36e243045f93e204a7d7333aa1ae585069e955cea6496f57e1b96f190eeaf1de1f6005cd91e6eb4fa6a9406f7a7d9afa68176f5900c603793868201e039065641a0cc6eb291aec88b5e89da7a02d00089de98d22046aaa6a93768f57a3d99d44e2c7d46604dc672a236366c119d452a68d4010e594173fc854f259a0a72632d58aaf6343c1686ee9ddba42dd840a644e5c0924d9661587c160015c0b30ca1350312cbc37949cd8937b1f5251504dfb8b07563a7f6e94444afc27e14525ff477f775b6d0e855b9ee4484cd71a5fc0d10a320e84b7fe1a7edaf9d6f07e44226f8957d34d80d0a4b790c24691c5744ad99486f075289ca6d3fa00e986c2ac6de19c0029663c760116749134163b8d04076316b5da5c40702b48f9569c8ee7685398353076dc4698eae534a89347334a84681399d19a751204eb8f01e2ee0232ab6be7a3d793dc031ed9a52d7d3ca415249df57edc165b82c498ce1b078f4bd8e3022ad177d284bf2d266b3eeb0435e729f8f9a95f9cfb6b1b4ce0097fbcb911c86c330b95ee437dd48bf5add958f2e5f9873eef6d986b7fd9448d461e6432e508ea3b3cb26c148055297faf63b777060d8bcb3d8cd045830f804b52e51441a71b493dae44281db461f054f2e3cea5e98ac0b31e0899d947f6054d791359e6ee711f058f0d7455aa51312fff46b4ed1f390630b27e08267db9a54eb69f64897333ac15a3242952df7185f2a9d1c182c44d63e08c7a053a9492381d21c5127a4263f30514885d6b574d2a0cbe2c774456e5bfe7a9d701c2688d2064c8f09da2e8a520f96e297b19510e74626778dec5ab5ed4ecd997d436ad9381334eff3835c1c7fd23d2d37572a3aac45a56e2935a4f6a946821b79f856970686e04d689a028d7efed17518223cf6170346dc35a446e5aa2945fb169b64ac935aca9f67f155b8514a6e70651f76dc248d28d361b0a81ac34d1981d44a42675860c134287099c9e18ee98f0c7474f270b37abbf204874172ee1c69d2ba3113cb9cc10e1c18a61510539885ecb1ea9c7f051bf6addbe6d17f2ba94de8fb67801278ed20e271ef143087f3405dbd71c6a549b7680841b1bdf4b8d71836237f60f29147571ee598565c6fc1c713a39287a2fe60c9871b825162b9df7a9f6b8ffec62bda2ef10a9c13e87839b2fe88975eedd2ee122e999b6a89f2a0b4a75f161e952d27dd3e17fe22292e4770dd31379df98d0f93ff3fc89170831ec217a39e3d6a5ba60bd183a6c5481dfd5fcb3aa0c0907075f3610c95ad6872f3c759ce94ba5fcd97c946d1024acd1fc0dc2c2e680ec42ae09df62724ab1f6e54f9e37a10755f73c92162af8224ca4b57fc8f1298b0afaf4acadc1813409d3d606792f538b6b1be2aad303f932be877cf6bcc05a4bd40bbcb1059de8a95e8a062c1eaec04719ffd5310b1b56b2275e6415ba0688542c056b16d76779e1eca00918aebf07caa30091c54a8f575c818f9c67b74b805f2c6b9bc60c2b7c091fafa8d10f372babf7c15333197156487391e883580cf23aceeb7213c6ba2cfff2b4bfc8b0f4e694bdc9f14a3a302b78236d8aa333cdbcf166ae3201a97b4c42991c02de795d34d497545c43ff848ef4451348b3a0665e66af05ed36f68729c352271e9720c385cd151cd22cf8eec13aede177cdd687f7ca529ed00714fdbf8af553b622dffaefcbf36522902a1daa81def75360318b30874dcbc5cc950374ad75c041cbff5322a89c3105a710c8646932b67c322853a08afa4a214ece834c0855670102ab2d829c993ec9346e78201576608cc75f4d5059bd0305fdefbdbd7205a715dbf2e44856a48a45bbd407dd44e9379d5a28918bba3e908a411f1ade7e12289d5a1cc0cf6ee277cb3a631c9f779a7d87069d7068db42b9bdca682a9ce191db441cae00793b3df43c932d73dc8e5ac2567e3ff4196e235ade2b39166866a9a9c8018c0d03f3e9a50f9ec3e1f3abe38a085c6502f8a2937e2bbebf99c8f2eb167bab66040f0617e78b6f7d0b97ac9bd0b481110c4c9222aab9fd5ce9198cba47af6c964c0adaf169e45d77f7b5512a833f6ff5eb117eb7dbbe036ce7079205c5dbae91a36b376fbe31e3057ea5715f1ee15bf5b03802ee390d5588ab251f50fbef510a2053c81439b0313dcd29054983196e5efbc0fa7f5184b24d2edee780cf27ce7b0dde8e8a6348a1942ecfc854af0a6789f0be4f5cbc23a7ef908de7970ac8e52e2dcb9b0b78f742f4a8a17c31569e1fa260bf4907d69919826b632731be050b30cc9e3a109b1aa85fa76d9b15474d2e249917f971eafec7a0d997d0fbffeed3635cef3f67144a5bd1d023e3fe46250f21791e529b61775000ca2b7e81da5c091264c26696c41953bd8a79d9eadc93ab3b04b5507c8f468d979781df188dd485fb3b4f5db7e3ae0d4ff56dfd14a58ff4a6629129b470b2852105067d7e8a94105d92676e2128617aa7baa794ee706e5221619575b30cffc7b10bf378895c5657aba1346ba82f0141bdd335ce348fc6cd602d77164113edba352f370156ada6d89499de7596faeda81aadc77eba38b27dc9acd08c579e3ae6139992d5fc386924bbc3d3975f53783146fc2fb4b9ea908f9faacf6c052d63486ad9e13f2c700cd900f2573d6868df4e829d83b20acce8a269fc891c00885709444cbe02e7724f7078056a1aa2c8f17faaf6b49f864b2526bd70981c16ae46f7360913417a33587e5cd64040f634cec8f4a84f95a65f3c5c3a4c3414aedc3ca58ba99ceacebdfe9c53a1174bfdcebd82879701b76bf9a9a605f987f008b9215c395e88c137fee8f3f8fab28029864394e263ab987bfe542e33145e3186f6efc0ddf16cfbac61f7c04151a3934091ca8c8a7c4d20ecca51318354983fe550424c333b9b80448360ee522cf0e67a0fddcc920b36841de66319b1f4273adac72b8c2eff18aed418fa0ef765cd7b95780c5c2bb43a8bcfa9aade7dd38b54c782b5ce72a9e39d2250bf13babaee3a047181310fc11a640cebf41f3a9d889c4754b3c4032336c4270ab811a298334c970cf2700069dd84ab4dd966f4717ec2597e268b486bb6f11f17f611ba73e5c40920ca628906886dad057f078537b4c931cf5f6cc497802cf65d7daf019a26808647ffc828e2177a7e04ea5f969e00c13d27f3fb90d6d7a06239edf34d048d3d987beb4a58a4554e8183ec8c0b0b888723d0eb69fa1ffd6c3f02d2828fdbced5d72b29da25d88375389367b7b04b79878b766c1991a56af0f7f242149545f6e5e8c04cd160824a743f2ed5b9f50ccb61074d0441f59d59cf1e07b0c5f908467f3c07a05fb906f4a1345615afc257676b9ea7f2b2fd0148130b719f1dc6c6683ebbd9543a3715f78a25db6777d26c372710227bed2ffe92fbb6ed60de769b667aceb7be8584dc45e489c5e25e33cb23427cf1e07b0f9da0ec0dc27c0dab16e2c49b6e3ba5390f0fb03e42ac3d58c5efc7e9fe866c48a919e3558b83ebda96f24aa0b23688534b41365412f6e616377de66b49cf00fabd2c81bd6c1f06a3a3d62756c3b0a9d91fabc56afe04ddec407e51cbc148b0dfef150730da034188d4fd760c2c3c4822364a8c03e9f7913856451c48bbf9baa4f842eb29fe02fd887ca62af1b9e5ee750e3ea98b2cc9ee3722e384cd853226a2e74b1318a6835dcbb95b23c5dd941878d4e3948111f9c4ec51beb965147230519aefbef052a277dbcf382e54cfe18affb6f89761eaebd53cddd336586d6715981656d7ce320e07890e12269aa46b94aef71d68f806ebe43212dce43e0c98e51e8058140608ca54540d4c0b81dba14b14990c5d362bb5cdbc93d89053610eb1845258d80e18af584bae8675d73e8f0db9ea8b2584ae96ea3970627a5047273d6966937b0632d9e1fbdc9c75704947fa86c18ba93b8a083392219fe2b2320033689f17f3b93d724206ee0cf59b65b4fd564eefe4315480caf4bb587da78c88d89d579256ec677a2e8a78456c568ab84624c86763828a99f92f91570300a2d3d45a59b1b9febfdc1b7dec7e6b64b8692d1462a8e693c31bada6ac884d78a2faec352650665ef2e96c689a12ad57d31546cd79f83a8ff878f48423abdedc22eb132a250abc9baac66602576d834ee2fe12c5068371efd11ccedd145950d1dccbbb97709202bb7b1d070d8a48e15a4356259623e234bec6d27b77dd61085693a2e2054067e4d33bc7f208d70a84c201a989cac3c680a74281b6e90655fc9a9ed46dcd1e3d35247e654f1ecca360483c728861b1150f33f21213978dcf79c29839486d3e5d2d899fc40b5e20eac2293e335f78f01d6b15edf7e00c4c88ae7214e2bf8432c5662d83048e8e81dadecc973537133db36f9114b95dbb6cfacc3b97884f15cb206f4408bc14b118d650908470ea4a3fb55407d31eced1abf9dfa953178b062a8541379bdef01f9d8cbf7644f3203d4bb41a931fd5a5dc8f0791a54095c498b427d973787e514628f42b2596977ecff9bba11b5d1d70a934c7e032515b0a8c71d6f151751248cbe5a0448575a7bcd1f79e2bb10d21892089e55f3defa9cc0ae437b280083034bca8fb38ead39fcb371f74373de864fe6cb4d139666ce609fb1ef88356df50996e5ec2e2d5d1cc081f86323d042792ea3fb716351097ec0f529aa68dc7a3be0bcb76210a729703e9b8d4b2adf982ec6018b5e6ebbe29f6cee9b673c0ee4694fe49a25a20c9cb37e25f37794f72a33d006956624b858615082347ad6c7da61c5debd6427a1b9945a8e63ca9d3acb1b4aae4bffb5e7c2035782958e54ea5220ab3cfc35bd82c37a48893324b81b7d898d75181767c05f94de76809c6f950b04b3a28981713f23480c8138b56b9b57292f525167f448ad401694475d304807c1711","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
