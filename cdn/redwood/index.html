<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"79d35643e5c8ef76636ccab7934fe4d3418429e0062c8efc62f939cef0a950578b6defb02db126441b8b3899b375a0c8e60eccecc36c6dbae80276282a75e56d7a7edaaa4d7d59457a21fd83360be694a26423a9373f6b0c46150ec12a03654f26e0eba14f52f21660488bdbf90ca67ef02f5e8a6311dccd46f74f48ab2dfb10d4fa2418943edf09647269cd257d5f159b206b0f43f345c66118664b90a6e73ca01b23cb70ce5145a26718575ee4d6022036f01ba3056b24b2f4157d9134b702af1a1eae7bf67c02a630192d5126086035248b28a5664fde937927a200901cad1b01a11e88650262041c2d5495920b1d52543e44ba015356b2e67d8e23f53d70fccaae4363fa0580e5247d06fa2991bd6eb42abeee88f382817d3d74724c3424ea2747f35cad0a72232042411b945c6157f86bcf89fc17499e6176a51ef9fa8c853c95ea030e7a4ce7824f15a3cc321419ebc69d2095a7bda4bae23474bee3076806be0e915275e0e9f9c5c8f13d69538e9308fd9331061f3380fb8901fc86edb93e7058403e11abff26597e821d888c165d04a13cf7660f6b59d849580cd2dcb3b2087d13b455191ccdcc85488feb6a80f02ebe1b706334d39bf473f2d4bf1bbca7c0143fd7f20a49faf67486035ecd1b30bd3f98e6a94fd7ed768d4b1fc46886fa294f28b1ca890ea564b258e7b751290c3d248485b86c6d20574cfacfeff83087f9fc1b006e63ca43d737e13e7245e4be7cafd7493ecdec81f6e2917960e5659df846292e3a45ef01bfca265caa2b25355331e7f7c696fb8332dbc9956edc741edef11765d3d8ad141012bb9385ef46fbc8f7fef92dcdf7948961aba78f63b552c116156b3bdeded4d67a774896765839221f238ea60be0b15c006b03f3279b259914d07426b09754cf9220f26d9c1eb858c2923bd10eb7fdf49b7a11fbde13447d7383df92cf291cc7532c02fb2966b9a0565de43b681a4c2d187fc659428eccf3c094f0ea67e4c06a2396a51a248772250648385348091e4077a1fde86d1df5de9c91d8d3728e35841944bb1b3911c34da917bb12e2749da89d62c2e991fdc6b030217586e958a02c435b2871717c0a3a7716242b12f7a5e097d6263122b0e361b4949bf61b350bb5140e2bdaa1de122f686ebfebd2fb9b496311e9517e270b3b7761262a7b9f8e6cb4f91affca2b5d88f4dabdf43794f531d47cc1b2c04252dcfdd30ce412da52f51b4d759faa9ca8120138c058a9c8f2ef41443c897125ce756c7962c670b51c79655cb51ebc197ef90808721222ff32d355ae72362a9c5bf65a013664aceb86429fb968cb956ba327b5855d9d65897431285c79e4b83a6d8e2d907697f3f4e3f814cbaa18781a4c9e6a113431ba1b0306053948933c7bd77ca391fe57199fd9faf7a498b7ae8e65089401d6950a88f5cad526769b2d5f611a228f0e0f75ce228a051eb83f923178234bb79ccacdc6b338802eb40d785870310be827b6afe9462caaecab737c7c01d6fa12f03ca872b721497b4abfc116b72cb29ee8337a0183e8cc753305e2ce9c17186f2248b3b54075cd1b1d199f05652a31151cc8187d846f367519578f863009816a54d80cc8d49632844cc790990e3aea5af6d75835b1300a679c7b147a0687c81446044828b954fa98dcb77c5755bdaab7cf820a08511f7455a8f3d98470052a639d1a1ba0b780688f05007fc93ada5aef606bd3964f4e544e44a59b97ff07642cab7ae0556ffa369896d6b7c852ea78fc24ddb82d987f1d3cd8d18eb0a3a62a148cd45c579a1b45125f91a609336bd392f77b990ef37d177fe83b2bf1fc4d151279f6b5b15678521427917126e7929e727b22b88e24e56025160ca6a7cd7c1c1d600fb1d25a20323ae5f8d45306354472c8154ed2004dcc8265ca3352eeab08de18c314595884c9ac0179060e7f1f2160e694fff6df4188e8da95302dacbd0356a07037e1291e917efb08b4ef86ece2a25f322f38c366792afa1c651ce21f6071f83757651336d6e0ab0567637bee2f874826892584fb665f6228fbc6967c233dc7057d9348a3daa3c88ddbc8bd7a365eb1bf0e4231a0f875e50fe38fabfac8bedb4ecccf5ef3cf915e1cdeeb69240ff194a921e800caedb6a706334884e41ce0e32327b548662311c501210f88d0c197f14b54ebb5addba0b862133237fd210c4212032b8d2a6f7b35d45c00e1dfad30eb5b1a0a9eeebe9955b13af44375247a8072900766f7a673bdc1712d639620f28854e503d7064a8191189f041f1deac446a3372f55ab2c5254e284e4426c438e1be04b8d9b552b403a089b594476068abd7ba4df95471676979a524f361abdc706ee50c71b5961053917968cec8f1756d00e56e349e8dd7d55e5e44d56586f4044444b05c88d9430a9fc140bc9b470ed34e6057db329ee7d6d3e5569b198f08e6e28f7b74ea9cefbc462567257dad0f2547be6792cebe95e0842545a5ca2b3d09fe47caf0d9a3f212872689dbba7a68edfcb9eb6f81840a0f968ffea912ca0f035a54c418cd719386cc041f8bdcdb49bec9bc1e95993d84c452c66f5a0989d621045d47bd724b681ee0caea7d88338f358a5e958112ab653d94e8c6646403b08f85b04c1540e9023223770cd52bf466f2ae39c77e0610b62069a4de10f32bebe9359856541eca3d971b85781f7dced6db2d591cc13a78a4565fc4bacce212cdd068c27ab922ecd220ec4447bfb3cd2f6106efb36855014e6d4c30f902993e9b76e9016fa193f1e4f6a2f1b330a5d2588eb3dd60cb5fd1a82b10d9c4650ac1e5a778a3ce8d431041e9afa74e8c1decc53b2f99eaf4a400ae93c25a8478d8659bd9d647b171a982216f09317a236d9cb2ab16d43a7f70c901d3e71c0b7ea6284987b556115e4378aac51f13b913a8108aefbd3521723007e68e6ec18161e2117a582da6ea9442bcb1df237039b3396daa84c9ec5016af1bfe11eb5cb941c0f412c08faff094d0390db40a60be91bb512346e199a0f8d8dd9608924216924405d7b0d57262e76658db4315600919aac2f609c33ba964d10964f128aea825f660ec65ff925d4a524e2be69a01e58551a24255fa73bfcb717b75a44d6e0e8bd39447f5d5edb2bb0585c5ca36bef41cbf3c20e728da7516e34ef45d68ea60333ab44be8aebcc2b9581cf51ddbfb1df35b94ec2ffd3ae63668a27562e49e0af6eccca772b4852fa3034fcb8b9539cc79322dae1890a2b15c29b639f5e2251d202202a217308f7cdd3bd64cac79f6d40de456a2f899babe5d7cdd29d7c521158788442a113bf6a9f77b0db478d48ddecb33b569f3ea984f1b83af6cec9e33d2bf5bfcc9ea23b900efe94cfaedb5d9088474be19482ba617c8160cd872f803028e91005e327a2a70e657d6d57921d476419c307c811784eac148f5f47e6dd2894d18e20df28b0e01131b390e82bed2e8f267ef0c43a963a9a85ca3d14db7876da00ea07869b41bf57363ff7cbeb02723dd9ecf016f9413b65e82be25388d49806feac48b196701a49e5dab9e98a94138b13b348f4672a459383b989af93557f70d77bec6d3c6580888acd1dc9011df737c487f089bcfd5c4bce8a319cd6f82c2ce2d42ce093b59d3829938d04353c47a743aaa0e4c9fd318c451643766cdcd71349c5d5c470edd71f0316a0a4f79a3d8015de9a9693b1795cd2979c46dcc6ee030131f9214c35112de9f6ffe1e541ad100591a144d894046b4d09d59cbe9785ae61d968ccb70b654874e904f51283b807613126dbb7cb36809783036a73b90f76406c235592e17b23342f7a80fc048698e996aee70552fd7556c17b751e9a86f9183e4b0dd8ca9b8afd151c9938287a4c2220ecb9e7df4429a18d82d82ab211f9ee8ea9a88c6220d4cd91f596ffdcc8968a7b03155134b196213e1308cebd25a5bdff1b15abdf4b4a837f04cd53b4c57add58743e4ad59ffbf7b569627a673f4c5b24e88dc980807434ddafc78e5895209037dd4786544810626caca377f9b7b5664068cf2b0f1fb978f1ac6b54bf1fe78cb0e3e18f94e205e3e1afd8efcd4fafb878bfeecdf59c264fef063b178063603dfccd4013756891b0701c15fa765b44c9561f2bcaa2aafe5908e32393a9861262969a5f58ddf04e1b19ad3eddb208f365cd1e53eda6b162392f1f7f06ada9231f244e4ccb73309391b542a0f1d588602fb29ad38be670c2cad3751dd3ef6d5b4c48470d39bd2f5c7f5ce2f1d55ca9064bc6c70aafdb4f9c0d1c0f13c22b4f51b2d4cf483f55d48f1978f67bf444707e7333c28588d0412381124179ff34490670e9515d42431085b6b1e55b7f98ef28046f5fa05af77d73451505648cf0da2fa5c269291865159c7c1d3b6b1db49723b4e474ecfd19e97a7296d97d119f780eb7107a8a520177f14579cc7329106f030b9cd1827ff25fa4589c56b2a30ca106a78fc6fa45b75fca555d165d4e357ecfb677d75fd34845497bf599a595e94cfa4c325af8fe8293203db3620a61ae5878e83bef4f7deeea1738eb370e0952ba550b86cc4622efba36d7c6e70b812d62d65f89852aeef0b32ec5a60ead41841622769e29e711aef3c783a67afe85c268917e0cbbad9f80a175d076b08587fa67fef704c5e578610946c0b1864e65598218e87b24b828f5fdce9f4fa3b972dd56141b7206953debc0265604009bbe45e0d1b314b3e6b599ebade5f8acbe86141b6364840fea30a3e5baf129f6f508a7f402223c83b67eda9af0784d47b3c7bde03cda54a3a69554fa5c3bd8cb5fa9ccefafbd4f24e168bfb8664f0042683b380b171acca3bd02098ae0b3035583eeb27c037b6f037c7ade8c3084efa5440405313557eee7644d1c6296eed53ca51ed538b7092937c8eae5f1b1acf2b3095e215d604ddadefec65a21897198863e29fef811fdf5976b420b9b28b5be804e0c2888465e2476dc42b5df936b59c26354909541d4c43a8754a353d6063c8c20fa2618661eb3d4bbba6d580caeb5726db6800c41b6b2bb6683e8294dcfd21845b5b0a7790c87b5581b7ccc9b9dcf00e513fe72baf7a7e25af92460ed8c946ae4e56e3bcfa2c3c3454d2f8ea48ce850cffbfaa058e3b73248ca76b575c0426ab6991933846af720a36612b80b4a55a14a5fadab167502bcffb395f2e018ed6117e3c29241e5b4fade3bb7ff0d746eb3c56e2ccd625b6d0dab96b46d2ee7ae68ab77585d251c2e8a0ffee0eba8339d05c9de453c88b20c13a2df9d4492368fb785e45f1cd59b55892f5245a6a0fd9f2ef90af562ad1988d0847c4ed8cb287392f834256629febb423142e4672828ddb21d57a8bf3b480656f1e6afd037f0d0ff23d3cf4b63287142b7aba33b916459f05f4829b0313f5bc27d0f97e3927b030001a5df13981bd7355641caa5f7ac3362a8a7e321fb044cdc5e480c805e7316774b2d1d4ae241081737362af12b1a2f6671f3bcdf70d52c1b52f8125b90c805b64db45d0f4ed2c8b98b153dfd23638a8d292bba539777a0df7d6c587991b4ef703692cf3b57d89957c7691510831421f698d5f93ba9a6a282de5de70983c690029204f3c956cd040c2976520ae10bd94579ab2714fcb61f6b403eadaf1b65cbfa0d23ebc88db591b9b6ecde960a368cd702c7aafda9423bb004923b6fa54546b124df31d46d489e92e1ef493cd84a33a683a466bedfdaa3f5f1f69347a1963727313cdc8cce043149becc8c16ce7b6b8eefd8b71d2a2750189c05e11f2533111677a95717e3c7525b5446ad2cad23be63f55f15ab9cf1a33278e2ab3ff1fe7f9d1e6717fe9b2e3f531021b05c941a1f07fbdeffa2a00cd37352dca79cb77d399e574e8f4a786ceb97c7ee29159eac7816e24f0d399c48144676c3a0f51e6e2dc555cfd872dcaceeae03ebc318e1d1d27d86bf06d9bab473e2d43403ae8db15e2fada3a8465cc6f294bf0f489a398aa77811906d3d07c1097e08c6385c76290fb6b8a7ec55aa93727ca76d4452dde57065638f632e91b44dbbb18f15fd867638e8127407ace903bc7f58a5a28022f4566ea9634880f01c29f89fe654d5842ed8b62b6454c7cdff8af70b16bc17fda1cc54009465e2158ec2894c39deff0b36b68c28808bb777171ca412391a623bd0c40a9616847b426d5807c7e5cfa7181b4754ffe6e3591942220a542d2263711755f683a6abb079dbe3b8bf41f3eb48dd362ee4aa8e5a892ca533328794466162aff1128e67f98de13a4c3f2d6e5ca1e5d3de6633aec5d79aaf54903bbaae1ae8215993f0f000aec7258ce770a756f5d1728cb7b093708f2310c2bd6ec51e057f83a0ebff9ca12b09c8ad980edd343ef5ae76629d3195529973a3880a88738eed6610a45c48274c71da884db37aeef2d665b291929c099b6cbb38c6794f16cbe1cd14ce1d27562a10a2c8830dc23854ad97425ec015e653016e5591907b1aebb8b832a507c01b73ab662d3d16b6933e36e6a42a7c6aa8eca0cf462a285b6209195cf3f2e9e11d5a901d8eba59770c6ec4ef1b79079fad18856c6b69f0ae56f83a121d403ec6d0c8bfb537f4181dd9993b49e573835e291bbf7c8b80831a33ce850fdb744322d152b229097493dbd9723bccf3547d1c1a471d5bf2b45a3937cd086cc8de1ce6cac492407b4d0caf061c9c49971a0b9de75d3c9633d064589581c852ef8d1ea7908eb3a198fcaadda9734d32bd3856ba6d7308bfcd2848be32215d79f74c8af62011f1ffce7d8cdc04c0b7bf9d423e52c795f617b94c9f34294ba9ed82c09625ec663c60643bb1af3f79441fca5ff26f16d1869d84ec3ea6b40c26a30a6a6163fdc6822b051a7363d0a7b17148fba6520ab260ecb35fb24a57b17e6b6a9d70a886a08883dbb3d82940c5475156a763972041ecbeeb624e51afab9eed8fdb950949c275f82cb49d6d8dc345da5e15986e5d1b750249a3c172c3cc884abcb540f91d10a5307a52633302caf76c216213c46600f8ea5c092c71546ea9fd549810b48e624add0369fddb9cd215d1dd2aa03b5007ab7d9da628f2cc583fed48ee142726f0481de145cd9dcd8149254291ec13bc09b6b91a1ad128f132e271d18b9349c2b7a082c189755c87e4b5e916a1c9edc458677ed2ab0569c482c1ffbce27eace5b2cf2479b60c0d685194807e75d9d18d4c7c8a44a870772e1bfde1aef1343ad4fa09b3524a897cd4020a8a6b51ac835ebebdb02c50b786b3260e89864c46dc9c3a9765972082659e0a45cfd1f1df17bab2e82585b05cecfc1a88006dabfd520185a7114ee37cc22c0d95b12b26eb8a3a672b10a34b929591fb5fb74b10555792d3738b2ffc7136128776bc2685a1f58ac6742f933db17dd9c515f0e8b6d74898a926f55cde8b5d5c31cbdc92a4a609596e71719d2367366db3fbad5c6ebae89b48836daa13a74e8dfb916a0efcdde106239d1588ca7c29d1b2d3a6344870731268ee9e80e34b828ee0c0fee3a16cf53d4ce90f531c8ac0e8df4ac02638644d1b4a40e2f100f4941025cdcd5e18995243f91f9391997c164a7239e3a936e02828ef9e1923b9617ae83bebeef51a5cae06d6ce9dae597f29dc0c103257f0cf58d96ef530805ab0204e1094a2e1af729638632e0e72f3507b4a45191258d6a247ef65a4a70ececf53d10f447bd573164b3f5d8934460757ae5cb3068fa4ee39d7486e1c4de318b178d1abb39a599d9b2b4b526344028b2943d086ad6b5b8ae67577a7484a67164fd5a39b6328f5fd17b72d5c86122c4d8bb54212e645e5816e8fc8447f22a9ef15430421c6a55ee6330d83562c30bef3c1c8d79979ccde10ad74947066a061b8bd16f3ec701ef96aa196901a36dc9090882ca83cafa5f0a1ebc32dedeff8990d76379e2e7098c118511f2b91eaf7945e799c4dfa924c9ecbd4eb67c791d712952b8f65057b280ac8c6fcfbdbba4f3756b8e52f0e6f039e9ab3464899f76a53058be09310ed9497e843de7c3c2116bbd0977cdb8abb5610d9c696e352215c6bb035dfefc314a58cb08025ad008a773fca999d6d60b0f2ce765782f04015aacecf6dc7e6da1cdb611ad9098ccd9c63e2310bdeb1b42cb1d904801f786f2ec8176e2a2ee3327c40695f3faccfbd5ae16f228ba99c1e4dc93a5f98faeeb42fdd432dd92346c9e2ddc4db70a03a28797d24b5385c3b538a759ebc385368c3fd08e6a13b639772b488b82f11004e31dbdc87b838c56f2386fb381c712f90334cd8f0fa1d5ee674cda783b0abb88149381a0b305e97b6587181b6ae6a5186942d0a6664fa6984fb652075e0819f48d4c40f5191f8fa2a731024da5c869214bf57ca04dd425a3c545dd9f6c98c6d6a5d9bf7e19eebe084266827d219a1c435e905783e9e2110916d94625ce72623721ed10c51f17161e6412dd562634874fbddfa9e2851aaa53a6a372afc19f6735b781822fc8dec71f4f27108d3a142573ee9a7dea1abc509b2acdcf98815b4fae63c1992bab322f606daaa944c3f656fb5fa7476b2c52c75086c9253ceae2fff4b3bbb97c41bf6a62a4922d63b7e389be925d06316106244762225872024301ff46b9d226182d4488642b9d6c8c995e84685ec91715106f3811cbef283b922e9e9f2fd51faf14444fb113459a056981f88db8da3df5f5670e9d18ce0edde075137a6c3187ac2b1092ea5ae4067df5e95f27cc3286c73e2bdce6ad31d8a9a5e54f25af469ba13d73ab8ed233c90792b8ab05cdffe1714f429f65ea7421ab1f1172336b4178f2d91b53c0da2bb24a7333ae173ca36cf1b827d6edb9197f685943aab300149483ddd4c66cf3c0a47c3dbe532ef03a98e0a4531f719f81e5df53a34b8670191b585be9da0713fb1a67b268beff6fbc61ad51722bec83751b9611768995cc6b5235c4282167de39494f0f45022ddca178f4103e612ad48d66a90b8317c879fc881c3e4c238c025fba157b26904ee9025e492506c121687102e0697de432a2f6da11cec2bd439ba84830b9816dc0caf2a05ff47fe8bccae9b64375bd9447bcda23f1ca9d728acb1eb83870fdf5dee909fd0a78081596d9060b928fad7b6b0e55b3c4f628721f3dc204d3e516df7c9cdd4710182c9b6bfd69cb8a5312ee9a28c55aade7a0dd9657b82f6c8506e6e7dc04cad130dd4d27deaacbeacbb6194db6424fbf2cc64af17719cde914e1a4390b43e5da8ca7896a6ea14f8e5cd0aabc5884910e9d5c7d281763cd29684da9e74d65502621f344234678d8ecf5283a60f96202f7aa8c96b50354359d3d6991e6c806a7543110b8bc4b44b2e0b4798ed0203282054fa22e91a6c7917e0367de1346c4ba0e2a04146f5b51404694c0d2bb1bbf25226853ca186c042a97d477de25e485740cf887cacf5512be228bd0ade3e610334708748ce7bf7c0f1ad99e9affd02e6f44d4fe2b813a4586f5f526aaa319f6fdd1c91e53df125f2d92740d9e5c79b414e7b561b69133cf8cdf7d7997376048568e674487aac2ee05eea51eb126a1d36139c7274ea03218ebcd290276dcad6cc96c1dbe361971d02f65aa79bc5944d148a2521e0c590477df5f5d46f682984130d0bb71708d21ac6f36eac3198cb5bd458db4d8ac64248d95bad8846314d7722b97fd733ca66da8aaf0dbb8de0a4c08575e080750ae87d5291065bae4cf7c20b10be42ab7640b0b9a29fe421ecfeac12ec08bae0531baa8e5f8335e7244476f8a3af975dfb9d05ad0d7eefaf8c69495a49b250df0e1f12c1b413f3f6091e9bd057ea9fee5f5c2524df27464d8d686a0a08e52d796b426b2dfc7b6d1b1e1e699d8bc35aa6893f9d5c998b29a442ff0148bf0370611f1c0f0cae59a3877ff6be4a0bcc6baa69aa034fe349cbbf2502ee94e4b18c03591814bbf21007a00c02307305f772264e6c2332c8da18e2099f2382cc7104cb671959ca7d259287c9740abcbd4ac912a9d969293447a3bf944e6f26047399d088e936f5ff99d681efeb598cca7eb98fff4cac4cd1e7db6c72eab2bf95e724f9552144851fd8b385e097fabf3b9ff89c05d6946dc26f6df58ff2f9e34c2a20e77c151905ad2a6de4845e4f081f044ff32698e25c6eadcecdceeec33f4df8d5ab372347bfe9010bd91c7a9602d34b4b5546d672a6eb9b3e5df50a8a9117aa08ac96c45c35f38dc99efc579f5a98cffe1e8ce8a14b5edbfca7f538286eeed4b2c5ba5baa5d524258cd766cdd35c072b26c498eb1ff56c97c85d0e0b2ca5d66be66621604f6353b0fa68bca63771cfbc1b1eb0bb152f69e5588867c07bba5c957f2d76e8c4f14c79efb5585eefd92fbab1561e62d5ad02a6d9566d345283b5ac5e5ff49ebb9c836212fdd68e59ba499eb5a0caf9699b20d516821da5b1af74b14cf1b2b2ebe245a7437ac622c5f10051bfac57de674c0c71348388da0b666dda09d42969a2b5829135e9e44c1ba09395ee059102740bb52de25d3c14c14dbf4ede8e95f4e05a32ad05501e31387f7f438272865e2ac27254bc9e14fa8c05122656b25fac70e00a7d79a4f837058cd7594c140a46e2afbffe475dedeca675657989d76b4e94b7e0cc2219987888d901f8e425b8774ee80a97f0d5d8dacb2c122e4cc8e128e4333096286395aa7c267d55763462ab5ac5a787f529fa1198cbfcea234f1fb786782f3454357c441f5f2452f051a372208dbba70b6c3cdd8d1a910c92311ed857a00610b5adaffcfa22b45c5eb3b0a6ef5653d2d62866468f552533fef6b72e90424f8d2d15eb4ddcde5ff7112d554525e21a7cb5d15d7dfa03ff33ab30d12274d788fb645cd2f7f696ae473acf45662cc3b5de558831a8c4e79c8dc94a12ce33cabf77b3619b5998cc0f9036d830e98cf45f1cc2dbf77cb4203b8cdc371e256edaa7b7dab066c6cb147017311f968b9e6ab77250d9cb3322b07ac12eae9b505f48f476591b7dba5e81a2088f6599a440236206727dc17d78c73becf52eef4db22b42a1582521303a3b0e4aec9cd3959434d1a577f74a427435eeeecf826264db885ea7ce72eb4bf0c7d732a7601bdf43684da9018a3713f14c77a8d9846f73351b30e64556a2309d2726e02daf3eff8ef7efb7e3a3f0d51300bce6c9d330621a24822b8d8869c9954548790fef90132e68b8bed5b9035d07d1377e21f9d1f93bed9fb383266bcbeb69c9cbd644fa3b1bcc3dd230e10adfe2a6d6df547c86c7f1e88b09c230ef3d02b24158a51bf5f5c224338f3dc093fe385c803f5a4f3a1f7e5d8b5cbaae9cbc94f434d26c18e0740f41869fb39b492a0d44de8aa819ad1e828c80116c47379c6ba8ef931c7f9201ca942e27294fef69ab4153822ddce3464db5ce771a9da2bfc36c7756ec0de60f9084ebe61d289a5ec18051bb9a1849248ab1a530c7861cd6f0313895a700d2330d96ee489eeb60448263e61f41785bc34b1e97b2e2ade37884490515c29b40941d39c3b9b4a2411c0f4d4bc3355506366dbe0fd103016c6fc444a379a4c7306af84a95647b4eb989941bbd9c7d133ed932b84af4edff159af69be68c4b1200b4e30262f52694bc448b3a3a92238f92c270cd7e8bad6ef5f480beedf526a91021fe9ed2fe52340aeaa606a4eebd436da66d7cff70726e224cf7495c4684c4f12dcb286505e511f91753cd1f4a35204b1312d1651287ace84b8d94b602f65fbd97de919fa8ea3d3499db30e7b113f690bffc934452b01eb32899c1a92cd85307d5d9691a68b2767ad71045b5448f37ab6f5c19463cb84fd3d1e06d3291d6a13e34532b789d45c509f3cb311dc1e79e98ff875553de576a24c8754ef5b04cbcfe24acd746ac0e8b5706a862763ede73a53826ee3a5ff7d3bcc45fc89903f7e4a26f71375cab623ffc53e3472ba3d8c15251529af1d7bbc43caf40d7d0627e0721c8c5eb76946ecbbdc15e10f5e4e7e3d0184e3a9a2d1192804f9f503258bb970d31dc0f3faa3721a57c386b66187000fae30e385395fdce8cfd879fcc25341eb0da636717003fadb028dd9622132cb2cecacb0257293eb7965d8b0f7d620d00b4481bea194e3d5c8966225d63be80aae48fd59a24746a53a8ef252d6af178166f7d55e8dfcfd7e8a422348aecf5f30b4ed54caeb2376618c430dff67b18ff26443a2f8140e1463f6358c91f7a31902852fbd4430043a69a91e1dbe1ef74a7e594e0d924f7e96dbdb9331044737c490542207f6aa7639d7713a85ac1f67f94c22f269832fa7b962eb4aa8612abaeac191c0b4cc755c55957a46bc6f2231d884cf01aa21e999b9f0ca073a2d07eeb037d3ca92793f3dd3dd90c9c600c0dfaebbcfe8c363536949bd189d91effaedd245a17cd0491eeb59a3087881581ad048be494fef35dbe669c51a7c8166d1382425ed26ee978c6d42ec504d26d093c9317a0721275e0acf952d94b5f11e0048f18ea7d1c50f732d419fc3822178f8424b1d0b6f0148538673bd0857925d4c28227716cd1db3c8904bfa1e4a5ad94537bcbfef597337a84c939ac5cb7a7a873dbf7e80457f148538eb4d29f3c221b243f8bff9c08504a5e3b31649c1399b22ce343d6628ff86a15731c4b8a655170a77573ada4cc84fb5212a89c73719225d0ab6eba770d9381c85312303bb0ddde32041c91e4ef96a1807c38f2eb8fcc7e3226efb518b7c2f44bbadb3464dbcd396d19cd84216630431f48f21ba40e6afb876749750140881b932d1df892e7a8f577fe3c8ca4d52df7eb7afe364bc7a091101d79168de30ed56f2ba121b2e8bff75fcce9131a9b2df383db6597869a9f7848cec360fb2653f4a331fef38b12ebeb6c4cfe161f33ea070bf17b2dfcbede598d99d27568b6aee3ffc4d9f48de7873bf51b904a83da138d72b3aab7022ef806682b76026b0dde167f4fff3f3aadd8557a53c641d579bd8691ed25f9e85b3306836e3ee6402b8c9939c8be64f4aae750ec015c4455e52c640229102879adec3c1702c284757b94005d0d1557152ecc8d587754a6ce2536bd7a39268c961cbbf748baa0ed4e6a48b18be4c4f07fa8e504bef4101f18111a482dd7c89dd23c379d19ebd97dc9400771cc148ea15f2a0b14134aa5b4e69206b5c0aba8de2cbd1a86fe1d488d76b12bb725e8b115afc6bdf46babb987da90ca497a7fbcbc3fe314777d3d63806e15400945ab068de36a610fa5cac4d86e5f0c9d1882b7156ee528a78a4663970c8dde4245d0b0c13a2d99f91fa34526bec502b3d1024fcaeffa1efad742952cbef3cc2e678f8714a4fac492a7a0894a98398b9e731ef9adac273aff7758dbcf23497cab5139051d042423b13cdea088c126cb7e5611549ff1fd2dc63703bb3e1181ef52dfed694b9a00377d089623dcb18b99899343e1261cd1575f05dea6c88db10c0ebc26b9c13d936e731247e62934d1f485a1b102f28aefac505ae23faa23f790731da923b1fd09e39bad543de92229ae8a00e9ac4e63518d91adb697559b11f000ffda8da875072cd4abedb766f77657be36b94213c807bef5492bb95fd25cef459e1f8c7d175cb0e74a30e45b40a83d2edc73a1bdd9f49a64c28b4ea2cb184b0f73a2204961adb19e7e80003cd74646a3f205ab0fbec21f87a5b9c61d4882eb0483ce4a3aacfc62cd00e2734c9ffa72ed750e04dab0e838fe51afd3f2bfc5a4f0f9b66565981e24fad99cf451f5196e1c6ff498625844f6cd67fa3f66d32d40f92378420aa9a10908dfa6aeeda2000bd9d65ecf9ef1e5ce60c488c4049bc52085661e1d8ab28618d01dc3651eb0e513d9fac8f59736bc0f3d487c0b85d90091dd54cfbfd678ebd70aa97dfff09333a2588d1d174121f9047912fa2dde015a0d97b6bf6050a30f69f9a40abc890a51903d7ecd12795c949901f7ba5ab5ab27962c70ef48c83d46830db87be26dddb1d3273f591e8924fa7dddd441f1db11e90432d3c2b3c814eed19d32da08b15564ec589fdc5311e80b390c61eb74f86506889023843d0b124960243caf845e11f4c3f47f274f0b4062e021c28c8f0e6aad2318f8a25177431ab8bd64559e4d5813d102deda56eb94aa89cbc39ab27324ddd06df19894dcb33700972b4124cefb0bfb1b3032be08b5677a82635dee1184489cab90b33078383b26b51bd84e49571a3b9fc7d851558fb7d3b113b3e65315f15bf19851d66a757737b7861da43f2312f3dfc7bee29d499c8b60817b40c39f40cbda9e05cd30d628db56537b74931aa64450c1763dafe2eafd0cf234318cd2babd51947c3f56f31dae8eba4e5fc84367af678d2bf7fdfd3c574c7e85db7d8e5ea38301f8e0e7707d8cddb113f92c582b7d3972f2a857d094ed893bbac295e717999990b8b77ecca1e909d995f074fefa9d12b6839dfca30f5050edb3a9f8afe2b2f84ebf531e7b825d8fa157c772b4f5aebde3aeb09b74666cc765bbcfae8fb290fcf69d74a12837d1dba9ac5da135573b463ecc57558b562ccd78ef6d5903cd5432d98ab362d4c45522d4a61dc4a7b920d45e18f90d9add8329493378b9f1398cab587d462b50555a18ef6429bdc97b6c73caf9327a8532ce230b6d152df0aeb38e2ecd38cfd6343c9711ed5aeeaa1e7de0374cab93d999190cc906e078beda116cff949ec38c26774e1108c16c90fc7b64a69c5198416a93fc995f4a8cf89d68d014f48b32605ad2aee72c43a0d5e3f0144739185a2387525fcf7922811b01603ea35169617032c30e2365f75792960035bb40aa808cdbf98a6402cfe14804282c734689a940c632fa7f3219dcb580f25954402f55354058cca77f34969233b0ef59130ae7dba702bfd6c7729b83a93a86c25824860c665f676815a4bb001757e85cccf7b9898c930c40b63ae76a2a6194b6e5ad021362e0ebafac5b2cfc4d7325ec864d2b07630e7bf36ff004f86a3ff3f894b8f6fdc3312e4218d4631590076e9e283f33379a549305f24abff4c9e3f6316bf43bb803819ac18e8a64a0d4b4720a3f6aa56c9fc886bc256afa0038d096c6a5321cdbfb621905b332087a7ecf32ca604eca5a992f9fa84a9ab0b5b08ecf19616da39d4283854de9e46d83845869fafd8e042d5fd35016f75679916195ab9ca4a888e79e1a1895039dcd1a088e4d03e8316a662eb00b97cbfb1a7754bdfa2d03aa7da0d678fe560683ad229709fd452591738310d640918c3d10ae28fe525b363510d558f37e45f18eaceb3d1f8c2cc3ccbbd02bc431e5a8333355a2ac92ca6901233537f7836ee116fbfb02d0fc4dc140cf6e9457e379e7ef49699e1f9dac9eccc5e7f9cd85aa93dd6662451fd6ade1a258474c34f79e33143666274d36de0eb7e9e8b68cde16b56f0548a9f37e3cd1540f2cd09333a38fd917fa36329d3333a475cadcfce8ffbf7ae8a5526bccf87bb2acf0b8d3c3b1f6bd394a906263ad7ac28ed7d9141be3443a5f46eea4abfb5d32f3a357716b59c615ffa7b3649f1a96fef8ccd88a01839211b1c92c3917a1412980236be0204bff2128f5651b3b02ab401a90a02d814ed113eea36b6cd61ae2ad5fedff043a3e338be28cb0a51c3df7cc3e664f3c7ca2a1fe4cec77d538f304e3a0ffb413a30929f9915a1303048de64c0c73ed6dc245e1f7c2be84cc6e59a38da4be9c3073ef619fca7ef3da616758a986d58962faf4ac804c23aec7faa90a2d8dd9a3175eb72d1a4e1bf641836d65b364163a3ba7f611effe013edffb4655252d6178d7a0c92451d6108cd10bb8585f78fce2a89027163bbfa9fca65f4628e6f3a27ebfd475ae9761c2cec9e867144a32bf975068e1f54f6d090342b50cfa20eeeab808f022300160c510f3dd254f8510ba07527140ea17f8a088758bd620fac90cf3f06b72a2f9b699ac1e9f37a1fac3775cf51929faeb0d9883c370cf744db4f3559f47c7d2f3d7671353fc3ad3a980826546e9e83f7e658eb4f77c99b4a36ca29f3c4b0b0cb50ba7f632dd56759444255be8314a23d9e9e2a038990551836ba32315d0420bb09686dbc65596bb4a165a67a4263435602cf42de6004e213616cfb4a78af99fedbe9feba78a7bdacc342c4eee9935359027363459351867c10aea06e56f5f4efacb40eb6a6029c3d361cc2cec6ddb6147e43bed8e904dc7f572c2012fc23ca3a7c5d2ad29a141d524415539d52f0e58e7c0fa70f1354c41b4eb2e9abf5f796cb9401d02f313e9e0363d253d10b3791013f5bdb86f37fd54aff922d553bdadff3417dfaf11874745eaf37c943f0688874da35352cddd39449fef51cb827be5004799a5c832754fdc4c046ca98c511c41cda2515a50ae3a95f87711d636870da820a92fdd75650c329509547c80629a4a0d718ca1c4c3f4ceff1acc85f8ced64d0271a8e35cdbeb340700285114618c93910b47d1e143d73765a3b9b94d621fcd9d22931dfa048d7ce01844e2a95b34d06faa0b6bc167b17cd5b17aef989d56ce1321e2fd40ed552c8a8430777185c9373e6d813a8d045bc50a53d37ce05eb56e7c02a318d99931a109265b232271404baefd69c6ea961b2c847fdf38c037f9a5bcbeec0f466d6d19b5293be66922185ac91562d7c66d24ea10213fdde8bc037deaaa0e2435ba005d9e792a86a8e587d5b31ce93445c069177b322ab9b25a1004750eb0293f967fab7e99d2cf4ce0931fb8691019812df92c0acddfc10623e59742df2a16106dcb591208be7476ad7a437ab7fefc31cc220e7079d5d72c8d61199345fb068256edcfbce221d1567405aca35acc9b1f51df5cdd96a7ebdacdbec54156f30e744096f658af9844f2af435bff3a41f65ba971b8c4978a56cdba03dfbef2759aa1f3b02bd5b6403af80c516735cdfad04fabf1f9ae7e4785edbcdebf8843d9f113f101cffb03a53b89801bba928c05719128b894c9d61f419435e1bddbf23ef6a6b849dac8481377b09f54f191ea982b9fc53c5270fa2fb9e704987d26f4f3f4512457df6d17ed7060c157e0db900be40547a9bfc78e5b16ea3ea89e1c5a449693aa2abd9104be3d9f9ff44d05f83736f04352a7e7d9dfeaca26a61afb08bd6330b658bbd81e228d5dc382224a5b23ced6f6e23902f8107daae2b34c25beb629b6d057d14e7f30e54bb6413283a7698bdb7092a4d54058075f34f7f31a1502bee8c89914c8455d9639a8ffa9ca3db67af34a3695694b3636de77b9d97ed8b2661d689a7669ff9f87b8c213239636e0368f05b604d7da6623145be9a63005514cb87d4ad92039cede0137f0c38fdcd34e5e860daeac49cdb42b779cf897aa1f886f3f0e7aa39af8d277b073d5311322c69c2918388142477f16bf2413fb576607f021ecbf087a6b0220ae57ae312cc378648d45412213f3a1f2d4d3fc0eda2cf9a94a7bbeba6769ba6a7652166ce5a2a333b0fd770655acb59105dcf31708cb9cf9b293d4b1786c4ac3d2724b5993a59fef800a02c5c07ac7203b9dec0dcf90286be290b43c85c0056a09bab1773f2cfd0a3152b7300d81da2caf734ac1e47eb6a44e748c25ea84d859c55440ba38d8b75f7a2c2957c17cc0b8604c9f5b5d73eb6a6984f46a78b4d9414a070b629a22c2d9eb8b76d69c9bb97b9dd8af90feb7110c14b7e4a0d36e5313e47600b74fc64fe7be968401951a52ba94e9688d65308dba6df4326cbfc8f3d3a080e7c1276f834b389a3eba0a9b38e4f55d2e8902ab13056366fc42aadaebe71663521d0703c1e1003ccc8a7b93ebb49f0a042a3e89e754d0a468d3cef03d7509fad4ea2a9b3ca3ccce6613bca2f378fcf4614569b84b7ffb76863f4775b16ba610ebbc7862e0255989446be703fad53b10ece8bbf685c78b47f32fc94f7e5b6cdc7f984a6164667397ab4110ff2905ea88e0c72678e1097547c070c532af6e43d746fc810272431dd07055d6f1ee658c3e79ed5c8d76abadc8426abf08e36f1e56233c7f3b40796debcf7c0d26470629981520e4e602a5df517b9a1922986d46711a0a31d47190256da5dc547711d5e0fa043ec419335b8bbbc0b018374b28e305543de99fd6f80ff724eb64f38980991074e5d338d9217b27384fd95","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
