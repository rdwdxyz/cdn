<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"21a1daaff9140478789f7ac5efe7ea85b1d53b8c79147e6c5b715485e4574126996e22044b986e26d484ffb024bc8eeaebb9e374d3b149b3be52ebedcb39e7de2232286ba196d6ffd1227434c4d0587cbb47a079aa380f9734e06d6bb7bae5ae6288725c6a21cf0b620304314ead44aa7f7494d1581b61c1685c5e96891101081efb2648187d526c88e73c1dcc62119900a252027afd435f8e93726204b63c7e6141acd18410b64c5f5753351d6f061e704ed0f4335e5f9df05b76803e1c0ecf662c8ec2dabe1d6a3956ec20edd9813fcfce2bb2016afe3b2b5d4bf9b398cdd46056c32a99fb65a6b23b42a405a07acc756b8ec3fce929c6f61d1f472da91a4f92a9fa8ae4d191306332eaa75a1338649f17feaba42f0323897f720a9ad84f4fc2b4d9ad23fd40246127b0e03d83993a9fd2a751b08d9ae4d7dc4b0954265832bb03b7b18528783020fcbc2834e8419db7880b7718339654be85266214cfcae16800dcdc824aad8c421f590282122cac43d8035fb4ca77f172105a5f66c221bf18cba59ad2e5604fa37f90abc52288320afc9efc0deb0b82a3a8b9c1782408ef36e02e670ec8b6b8f7a40be8baa5995220cba48a16b1363adb15c08971089f90e76cfe15e723e8655f29146b07622b7faf51906dcdd14568c525c6930d869db260b67be01c1d294afa016bc6895a2274b81be7f1b4f5566951d9c2252041179fa2e6b091b1541c65a9e30ab82592245dcab973dfaa2e086a7a0f0560b7e0a924be87beb08703a76e23971166d4ddc5d123d69119e533e0e2c8b3cc0dff0310c6867d89d3401d40f814a84871804192a217de854bdaf2ed6237d256aeee3946cfa6acc6492a6af78fbec0d533d35b972d0cedc290560198a7abcd2d7a058f183f71e78903e2e6f5b7f2286019f3e11683427c748e4a951767f73a42039f384154dfa3afa9997c89ad17b29abe8013adeab9b30d1c40c23554d72734fc9193f4bb395d8ed1a10321a3262cf47860ad767600d2ca74d170fd53404b856646be63cfd91c1016ada5396c492f7f57c63a567f9c3ab08b9654c154cd53be579d60b58d20e8cb9e8ce9208a191bc34d8e38cfd13bbcb1b38e7370459b68c8a7f12be6dc5fe005b083e29964daf2ac8ca28769bc871386638b2e7a57d5ae0e2b6e8d826ef11e8851bcb0fb1bbe5ca4a25b63c034eabc28a13451aa64cb1c89a81cf75d09e0603e2c9b12034ef2f6ac7203713473cd3690e43abf5a24dc936c061af3e10564b6b03bdb0d53266e029bf58037dba063a245311221f6a6b1bfee4eb12dc24e775075c68c27db939e87189e595af8ea4d38aaac882836fc7570446712c1d06f08d708b09f6175286f403ed627e4c8c2f9e4240c9d5317301886a75b9887845fa37bac219a24e1e0aaa942faed35bb61fd59424525b2597d1ac0047006db848f495e9a3f69914311ce40fbab5c11ff788173411fec3d69262ef8f8ce6b17df57d4bd3b1562d620ca4ca2beb9633432c475a0f3aec51235a6b5f18b2f617d4c91dbef343f43f1b043a230919b406601828ad6cfb1b0093219185d7bef5f0779288b96227b0e9b2dc8cf444c589bf4673a54e2ed6a67d2abee44e82b95718baf051787d61a3e6a50120d4b353fea8e4083f33eec6865cabcbf31aa2c13125ab57151fa35476d8c52e9a39a081eb32a4ea6b5af3ec17e0f7b9b1d48375906d2070896b8d41b4ae89bb473a22a84e79f470db3ffab0e756965d4c574043b443cbef24639c1632c34dbc526f48558be37545c743e614ac27e0d7db36a09c0e02b98b99ba1ea552090297ea433034eb121e6b9dbaa2528905734a877beff50bcb1ac0d89c06727f70cc6440bd47d0bf7a3aa5836cc5e03c7e8da13535d41f15624373796e8c172eb21d5280d28b0ca05c78d0dfc31f1fa739318df39fdc5bc9b314f608cc93df0a5f30d884a52f2106ff9a72bba2a8100befbae160e60904b8f61cded81bca3af2cc17919bb1bcd55b3301897759770f9be7326ed92d0a2f201578a45e2bc3ef1139936317acf1ce89e5bdcbd8bfa49782d776a1abe548ffa275de6fde972bc3fcd04c84459d5b4d9a6e86745e102fe90185fd23820835bac1b2b216ef62dd1c8603792b29149fdac204dfdf67923482e66fe9e1be7e7b4ec90912c4c9e43bf9f04860f2a86b87da7073ca2a0e99e6b3b0783b926bfabc47bdfa71c8308e7cf8d97002d8fdb942930b0542e02ef38180fa67b16b935cef0111db3cf2750696a28d8ce58d368ea0655b0517e405dac350fcc53dd772677349fabd77d63bc77f3fdb2667a1ffc3fc18590c7057fda24836df0b7a7e251ebfd063d833d0b9bf114e4dde917eb628c31b36b0f95fd4755557ed54929b139b487e38c54de503804555ee762b698c7164293dc3b06760fcf6751682327bc8ca4a9ca54e80f68b4afb40a9c5b972fb9da6dd80bb483f87f97323ad3e8e32f6cb4a0e71a0d3388633ef8df55fdcf7de3a2984b3ac192086090b857b5bf07fd3f497c155a87d3ae2488b8b9ff668a60b3f521a07e9f51ede5b0e545fbf4c3d0bba8916cd53357c1368a03b3f223c2174181fadbe0a6433790ef5da5813813596e568812ff2a9636f803639463297e1824d0400b0299209ad96c9fd7cbab3c47ac1ae5fdb28153df6f27114fe9bc46064eb6b3e251db0434cb7fbf61fe3d27da90eb6086c2341eb4245a6ac1780b8aaba2ec0faddb5dbb744031d0bfc57219ddfee230375649535e407777cca12f0ec917988576f6f3f6b530598fa56ae7ea7bcaa15f29e258cce2cdf2b5b5def8ebf6c5756ffb76c232fef02d51ae7cc6034a3561140f76396308bd19145aa178020501c285b4529e435abc471ab8f097020cee074504e9143afae430bda178bf9050fa4900ca3d633d354d380037bbe5ce6a3ad31f7976bde646c3aba21c7775961cafc1dbd2b027ac558496d44f6acb4bad24928c26a8a9bed334051408b86e3a5260192f9b2d4d5a0259508ce5936c6c3f6759f8b915ae06d7abf989b5d6465228f0314c946523e96d9ac8dd3d2d01f17b4a56503db357b72338c2a6aea123e1871276a6b39075bd588b1a0429e89873d39de7e19aa3ccae728de50ebf626d688c6e3e1c2e93daf4c6b4c3e67580acfd5dc0f515e545197eb4c44bf494df5ef448b0b76d8253210346aec5917509ceb604b7ad6c63ba6fab09d0693fe18a7569a8699cc5e6455add149d90102e3e5dccca10ddd934daae17c9705662ac1e1b9804f343baeca2b5cc593fff027c71fdb79a6f8f7e1d215121c611d24da6b9bea1ef47f56c0d8e0e1b27fc18765928f0b4c74dc6f5400b602d38796164cfa63614cfb7ef2e5d6026c0233a7db3838429aede80e602a7869331358bf1bd41e6b0281a1d5d2a94d5ace06818257eb2c8b906195107f4300d011b832e9e544dfda2404c7864d8669a63e7dbc8fefa5982f7a2a1f1c96dbde6ceecc9321f8aa0ab736fa78bb05929d274a972c82b80513378d997c264fe69fa708bbf8600cfb36851e9b59d60e5f228cad251db982d6022bffbf179e9d60bc9d702b007872ab5eca35f8011e7b1b7e000e052048fba25ca2e4f5b9f249c67eb87b41f0967c5fa1a761ba39acbc1de5ecb0fa3f5538d073fc5d47af63d2a9bca73f5e88f8e2793e763f4c0253439462f0c9601ee6e6f9e22d5cf4fe8ae9ef34e5c1ebba4232b3038ef4417f94803ea67d1785a662af9452ac27fd204de0e3c70f81f1730a93e2ab34cc38fec5e2e9a55ff5a9893e9a34c67dc7b9d6412515b8695a6ff8ea960923459cb179631a3f0378645c4089586dca542e6bedb9b52242b96c4512816739a078607d29c691a7c297603643a80521a2e7bc8386df99fadeedec0acb2e782201480ef7e7faec75ed4370fa508cfe6ec659b52c0dd78647c2e43a5414d6b9a456937310037dc76191c450abc2d36e22d80bee4edc48d2130fc75c646426d826efabd1126a7e8c63e0325fe3a2af0dddb5dba0b421c785c1d1c011be2267ace59d0d065b5483e39f0bd7a2fcd754f5cb8e6288a43828f0dc4534bbbaa9d119af6b2017d1e545106dee0425f9e09b8de0762d32dfa0d955c8f15d76cf7b333d5c63857f9646cdab8d7315bd628f0176cc1e389c7bc4a2211c59386d1fd7513777b2fe5007e2e9f50363591750eee4a62855e9a1a75243aec33b1a6539d7aca343b9173ed740e152a4e1b132f7490e16475d12e0533e7f8383474fa8aad98d14d3b6746de0432a6f3342a9efe4e0703b3d84bbb1558759a99d7981ecf6c069087b19ba6f787b3b9d5162c9d8c608e0fb3ba13b411103d719cb6da4205b6a19427aa84816b150544b95995f6f49f7db804d9f54c3eb39eb30a8cddf6e6ea2388a8763c5119d9f8c7a054c82d8089e381c49933257ed2cc7d840a3964e171ad0b07c95ccd00ddc03cc3e0d1daae7e9732d690a47b807389281a681133c9a18204015f6215a387c6020fcf5def883c9a905658a7b5501b2d91887440138cd05c09e43b777701be304306e17f3881307c99343b52049ada26b04cadd5ebc72b07b26e308147a20cc62da22940b2f99b4dfc5171b9730919fcb43aabbb2e27b7e20c90a5c24d1853442880d58eff26685a3e8632aafbb5260b75f965f1f46671e22782bb02a04e54bc4b6f58fbcfd5ee6c6a29cacef4f352d0adf70d5e95a18209492bb1bdda7b5447de0f65b4258f98b93b066c7dc93e8a20c52ac013e734e5d61c772cd65a524f1b1037cb04b576f92fbbc3e97aaf871d98d0883254a795db09062814ac43917880e71d1da175068e8dc2219d2fc6f937487a0e904d011e3a5e460ea5d81d64e7ccff8021065c6e38c77ebc140dfb5839f20a93f70d0c82af2b37a71c60a4e823a08e6dc5d648cc09911abb340525d01167c18d0c5f93d096c23cb87c3f28f28cdbc50b6d77d2fca464150db2ecc8a7552eaa656e31ec09330cd9d727f471cd8cdc85f0a185cb874578a96977d981caab1e62cfcc31aed4d31067af4d05e85128ff6da219666673ce7e7e2bc9f2e265d38f744d01372c959a3a80b027d33a33d91fcc6ce3c94fafab5db417ef0b3dbe204abe76ddea0a59f6b5ec74d9354ad79ae5a3684e8febf8cdd81e8b528d619733adf68cbc1c5a935cffa3187185a1e27f3b5de02c3d0064c228cb378227f9401a55efb89d25455f5d03e28ab1f9dc41f92927696abbec4918319c6b99f05db92eb371efd3f3d4eace12b12f5de24c3ea1638ac06c58aeb80c79527e4bd159c509a7606f2d10630152fbbbfcb1f845f5e43073badb34f22f126b1fbc7ca712da917a4e075232cbe36b183d2a83c601070802e264a6937587babe4012f70a36cc3d49a606f4026b8f587172ddbd788dacee346ddeaabf1aa831d2ee498f6b531bdd7f4af250d0c2840bc53b8d6f05083b7fd35661667c1d35b00c42c204fbd1d3920856e3d10713fa1ab0e6748ffea76d513a4b6d6ece576ef65a7e1169c43394ab16216a02ee49d1c49857c85ee42d6c2526f8f823d6d45c4c71a49ababbd69474a5c3ab8ac9019e2a8cc0447acd8069ae6c6a9bd5c1300d241920d310638c9683ee511f1bc2ede48e9a17b129d7620741eec17e8ae0bc190c2487b9fef99c21695415519b898c252497c1b07ad52c191b366761e081b10e5f39850c2532845058605db24c4ae830040f69f93dd99b6a4cdd5ff41a2fac545639999be7a846d3fe1a56cb2c8ccfee3fa5612267faeeb4adad5198bcae5e6e6b1e8fcce46d1b0db769a0efa9f515827d0765d0dcd8dcff723c72ff7f750a862e09fd46d186b5009d281b977af95b3fabbe95602b7b45aebbf59406717cd4ff6a8a7abb6d46f3b5e824f744e4abc31365db8a3018ac3e998238b1300d0b03f3574adaa8876e315b17d371a0d3bc5f592a373eed1e3748534f78836b96fa1baf20bca409d3f94633355db3d0cbf9865bbd34b6dcb6405b44f69ba483c3086b578b5d06e3afe8d3fabadb322a746e94de640c45fe4ad3028e556167cd42300dee55d376c14ff272f579a31fc5be24ab10ffa5f5346f6718451fc3630e16806d0edf2a8a36df01aad35a1d252bf27f87d2db58732caca40354d9a3f55a514eb72e6acd1e7f122ebc0e0bf41be142e04b90eff0041c5a02975a7aa768802619379c00f0141b874c32be8425b2a8f341cfb485fef5971d460c76033227bb06e9989cb4d4c23bdc316cdc8c07df3d82e5161b6810c1c02e13942123cd52dbfd03817d9dd196c34f1b5c3f01bf37108b7fa6d4663a6cf0d9929f4cbbd122b5c7ecd25dfc0b9efc3cbc7b0f573d9913f0b5e83b27996aa4e5cf07fdb8f59c4c5067dc12639bb284326dd08ad7a3a148fec10c120ede326fb4c740b2370dcab0a9c8c2c9e110f3a22ba2bb725ef3e0a994ac1b57ed074c13d7048fa4422a19329825612cbf1d1c9571a4b18e168a15dcf1678801a56c72d436b82b1c8d27e575fbe1c7f9c908528167bd7bf178a90a6cb83bfcd1723888636b64fc924bb034a57cdf5caec229b9544ddf0db4f492ee9c55383f8e8cbd70375a737b3a74e02d7d9985555ba3c1989088dfeb4923295257a673be41faccd75f6121110db1aa452823129e8dc26e707dc21024c04ed41aa127d6b7ff7af5b235202e51bce9f632dadd98d8c3f7e504bea8a2a241fa9375fbeaca1aeca4a791196f318991f50fb7653d315b321d12bd993469555258921a2b773242623f98de6bc5101bf9eb9d348adc2a93c4c677480ec6817396660939ab427136d38d258c2ca617e69f4cedd64568737f9a8dbf67e2a382058a8889b4fb04a1667e1525a447c726764bd98047d3b4dca51dc41e86acea596e2010861ecc48460dca274b46b940a8740b5b176243ddd806ba6bb4c53e3c6ce44acf629d4a10659cd59f236b8fbc5da13a94e29d35fbfd587e11a7d442f8da7a86b16c2cd2356bf5a26e9ecf838742102d57014e662637eef73f797312c272229dbfbd0ab44647dea799461cdd7d8d7a91fee2b31d14040604f69e8e1ca3e165e30c0f0f263d9b122afe9f9f7538bc142db349e6b2632b10ee4197ab6cec668d9d797a4b0788d2673fbb83cb2607f0898802c74012ed69671899c215f46ef874b7e0ff63e6bbb5f09fbd5e2f352a4afa92221361fcf0b7844eeb2b64fcf70d75392374a22b841a4d85aca019526e9047a40b14f6cc9575291454de25fff01802c54f0e31c2da111d75948e66f933432adf23d976895afe02a4cab0ba803c56a4a9b3cd7452e56f34593be3db0b9e41a3816c3272bbdcb1a8871857aa5df5c494a127a3db9bc60c543bfe66027aaa48685c28044a1073a960f509d4af115166c8d35d4555fed2001b8df328441f5d2b582d5b7a5ec82f32352ddea91ccb5b1f49d235808327ef50d928798c1bcd4ba5a19a7c2e577b68dde97626b8d43210db2272bb5bb4bfa7f57f37d72d79782b3774acd1e41ef9d0391f05e8e2e3e69ade41abcc900d1238fab28965e29eb0e7c0874a6198b8751e1e03d760344eae546922d615dbad14f2a89fccb0b5896619bbc4ca2b419efaaf26b1fc2d9db3557d67ceccc2166c1fa932887f9cb8c9a0904882872db242828baef2cbbfbb53862f6f69846f62b9b29aed8ca2854d948756e4acba28434fa880a6a4fd8e0ae2f1403596ed5bf094280ee3abb65fb3f3ed480b5e27b1e7e8f45e332f6b02f9b100b2be49a1f15dfef87dfbfa50b3f688cd77824463786db2c669b1361e57ca4b2abe47784bafceeac97f5bae62092a8145ff8da2e939fb202094f37bd40d80c1778fb2b1c74e9b9d627ba5447d506a9d0d6e8670a4cc7d5da5d90cfe955edf48ed097b14948862f01ccef357f6f27b2b19274ba1a4ce225bd9a5c5aa975888dba2da7bff4cb806ef0a5ee62a2ee13eb4a00aae5f5b7bef9ba1e212d363f493be5e04c7659a77f0d7bbb8397a2c2bc95536dfa02e97941b75063e139f32e1254713562c0290aeb7471ff3cd14aa2506d8fa050777df4d47e94068bbe4895847e85609638a45236a15c9f12c78db3607adb590125699903fd840e3ea16b4bf087bbd714bc4a2f910960443cc94dfac759e90c6f7af106d2ebaea44d609b48a6a7f20f24afb4869dcc110d3589e578e7fc4bcce1d170985c4cb5b7d3b2c9c0e914bbc45529c6e9996eee0822a8c15bc460c40d17f9555a889bbfe886ba3cba22f54dd40449b5c77a6d724af474bc37ac421a85f5209e33d96aaf75122306e9104827091206ff0e93da3b9c9d57f187359eecf8fdaa6aae43c09dd0a780ea576f923dab3c85b131d005c111309f1036f0321cf6e9b15f3a9856fded73995edafeed4b94a44d88c7d206cecbb776dbc63a8712319b709ee8fa52a0b032d5a3d97395285cc72227d1a08de9e0b75f14d1b8c96d67a6fb53dee8fdb0649e6f8214df9eb3a0ce62e2780486b37a94dbe0e2ffca88cbc1d42ad93c8084005c5b08f5b0ba69431878b95cef48d44ba2349019c449d223fb1e5d6f62dc0ba007f3600dacd29854cbbb98cd9b1e6ee005f68221e2962e363b8140298675ca5de2c48daecb0b24b3213f7edd6ca69f84f5fe7c8ee2c3cb0a6b68000b07811c4343b166cc49fc136d5b2112cf52d3aea9c7fd7e2873ec9ff49f5f581721422ff9912e665ac0cb1694430bedcaeaad61c5e22e7f0906ba9ed05d1f7ee5b6160852a82c8abaea94481610f532d3bd7cf152cbbaf9c27a716744ca5d15db6937143611d2efd5ee4ccd0395b9f96488eec287d9f26ed4cc518011dda1c08a5a81bb8430e34b38f4980119b6d0e7596dbd9470c540880f78ee4b75b4996c8fbb6f1fa829d6701319c9afd1c18dd26a1f398c6652326920769931742a8e147cd088cefb945d299a79b73f003aa65a08d12b1ca8b615c3b02093b4667628bce25522a280c7aa4a2072da95127182c6a855c78c6e151d606a1770a4136444fb474909e67ec75b0e2f25987c45c0098296770c38ddf551d3ef62507912680b7ef1018c96c91c0c6a75d42e31c119fddfa2f02163a9f767f6e0092a6e7392827a6a9ad4877a7d738f1878504738da8c64f05f5e84d386b58a358776b34bc3d0cc8df02c0851be97edc49a200642baf341317e5d0e31e7758531521d63b8c07683838c1ef6206029c564893bc1a90f4d2a4d989c6d5a3172980a64126dfbe1d314eb3a7dd11b1be8cdb5ec2998ce1df9d9c174c6cdf921ab4b7fda7d1c2c1c2e06bd646343ec992a48a3a3da3e53dca8ea96c7f48922216668d70865e22b02e287674d9480ca899a500218be7d66d3d9374001b7242e2206745df97e155592d0a9cc0c173848b26b25f19f3ccf8a210f7dacd3a42622ece09d9d51cfa7eada9ac1cb15ccc287e3d721a924d553093c8836a5781568200864aae5c4a554b65a9944380ee2b77f8f6432e222c012ad6a8c21a5b19c74e639609b251077967f902b852607c34badcfa8a4d151c06fd7c3caba75e4ad192072182e0a888ec715d21ebcc2badd2f21c095cdecf80518d7d9f4ac9196c8024de8643754b30d8e326f5329a010f5ab68c855e8a43441fc9a0a81f26fc9ba9c29b8f71aedf6fdbaa0ae435bc6bd173df14efd177553f64c3367d38d2a44c1be1bde42e92df698476dbefc47344771289f9db8e2413c0c7a0253d583adf61ac75d03ba72a318024ae78647d6a2b943cdb4eeff6f1e4afdbff6174b2dbe6a265f9592f940c8e3d42ca2977bf8f6b95bc44823e94e7ed74d2fcf221f8981da3d2267cd50547ca71045118ba284913fc16c7ae695b417acbbb70db8ccdcec6579cf8b13cdfe30ac98ae9de64e2c5e9762e73ec3e5f27cea33fdd85671128189123ed762bf2c0a72eef8cd1ee4ca7a0d9cc03ece5bfeaf9bbbf82dc4cb781970671e02106844d65b81d5a08de9336c1b35f2c20baead535aae5b16d20ef8bfd32aee58c3fbd002d4e978d1fa4ea54034b85d6ff45ea0c87196d2baad38dd80450bdb649421546810eb90b1e15cfd089a5a062f775a59d941f48e1e2d4eac2554fe27a6be0c377a46484841c6c268c167c8f709da6cd5451289be55055f16f2223981d0cb60e1a21521c33b55a1ba72a39c6851f33d128a4be62376e42601cdcb2de5652c1730f29f81c93271c0afb5fd4cff935ae165cd486737b880be407e4172e97d1851c1e752613116438cba22dfd77a281999dcb31e6f528684a4399914dd4336bb5f8dc82b2a065ac1c2161427a953bef9cd5af17ed80ad0eab0f0fb16b2d9cc4fd609fdbaca971ce27ece73d66dced3e0affeef5cf72c6c24b758a21665917a68bf7bbd6b60c0bfc6b9a6ed4af384867c0222645676f7be0bc5f8cdf251d00fef8792ea572a081b35bf1ec50dd20e64d672fcbd54b2eb9025f10131ac8eccb11f63cbb09e6b30f9f068ca892b4f2983f4c42f3e16583e65c9a6de6fcdf0efb3d4ebff5bfbb6e386b974e3541c314b03693b6b8d5cf0bd092c6defb14426f2f2e3518e7f7917d3c831805d0167ee886d83927baacbfa234c3de0bdb419b40566c58e90bacb7b9df681c534fd499da0e320ac8994fb1bfcac16ac3d176a515bcee476437b86c6c0dd47c6da99725e0016f49bc0891eca35c32f0f6b4b698a4d97d3af4d716fc6b01938edf21ae6f154069c71689e2ee18c378f79723e14f8a27ff4df17d99317e110f6e992b61c86487683a97f412d272a5416adf4e1f02959df2655fd7149cd557fd7411fc8b507bc5099237422b1795f6c5d1ff67c16c0860f66e390b17dc543fdf682e66ed021f840d3b32fe39c5e2c193b4da9dfe0140c36b7d42090848377dd54ac2be0b4c91aa17be23f11cf49e5d72f38f5090d3268ae68e192f449dd59f1877a6135c5a143faa8f329cbbdf05a1275be7ab18c65aa3d6bf35baf146372c8f6e3e45bf093e27ed11d840dfef8fdaffcdd87fb66c5160bc38a343eab9dfbba51cf73f8961b31ba4dab056c2d2dd5f6caf7d9feb5282b6daca639d2b123b95e1a60d089ab7cf26dd9f795087f421ab488e9a1ac4b317de03c811022ea979dcf68e8a79ecb27dc9524c2acbbfff52381f98daa1788e22544bbe7ade9bccef0771fed1cb2c97cca6c91bc054391798bb25ac8b43fd9351f3c67239683430e2eb67b7a058aa110393e5c743db5af497699988ebd0fcf99ee9812b09e0ce6f753c5a0f63f323017c8f2d35f87c9858336faad4a8f8f40220100029f87f52b196049ab5c54fe94491a33888a3664e8201c12bb6f4cfd1edb346ae070c85d69bbb4dd890db9954fce8af3a7b735bf946c9f522d51461345dfadecc66f754972621b46463b80f7298aba88b93c06bbf6cd208fb560990c4793b3b852633778ea623f7d9d511a32aee8c013bfe588e1e4001ef721cc57e547499a7d991ba2777040b79b17b17c33a5eea8b9467b6706f9a0287dce6d625f248cdc47606298a67dda8be7e12ff324922cf70faf3bf61e41b3c24a198875c9abfdef90b953889ea624e04f9ac357078520cd1f528a98ac5d55921c5445bfd7d1dad9bcd5174971f32cf32eec6bb7fab995bfd743ef781bdb0f532a352d0b4b12b25e24a357c952cae488bf36812408c41b699e67f50ec575e636ad5315bb664f077befb6c29c54170a8540a03dd3af19512c52cf23ce226e5346a169579bba03a0c43beb00c283b412db35bf549ec5a60c506a370c0ca713a3187cdea4ef39d374755795c441e373d62968d22e1a6fc98e8062814470c366cc560ab3051810a535371a762ef3210284c74db64083f20908ec4dbfef19099069d025e766540f6536357179d07c95c9b73c4f596fc1c07253146d7a10cda573c94d4eb1e22e5aea01696f6be8241e5904e976e6d74384834e5a032f5b4749bcfc5e279e3defee6d7350c02e0ad81a9b6854829b74545e2774bc97f5d45523e00c580956f081ef688ecc65f7abbec5e590675dfc485184aa6874d224a8f4e68e197a6633d25eead410d4fa54c766f40f2ada042f5ddb1be9a468c96e4d7a524390e5e4dbb46692245332980efcced67433b06a3daba91cb5bb4ac2a276dcd9bb46c14673b61ce783519e0035e9e351ae6d2e5e249599e9f65253ef8146bb7b3468974d8947491a342b099e599d87f7e021955dd1997a2900b14181fa169435402fecfd1feadfbd4094261a9414d7f09c0447ce84ae40d2946dd7fdcf9af8ac7e54bd185ddf97cbee1a0e12010f451891a816e5bb42fc3e39d3ce285e380cdcb9ba020fb90f7c9eb5fff42ac6601386a6d2b50397234e5af68a0a16a1c7ea2d2ed1933fa4f33d625747d63105fa9c3333ac037ddafbd24e9d6fe8a8a7565e42af8577951f0ab37d0bb24764bb19d2f1121421834be6712a1435eb02f1525640639df2193116758a379eb1b31f8148896d6624b1a5fe0d98212b1014b6c3ede403a1b1f6596e9b59e925f1086241a4c4a875c3ceba67c3916eb92a9eb19213341ee2bc10f9cc253bc96e381d9fc19debd92e7bbe5463d7c8b2d927eb6dc44b4b707d25d3db78804e7a9b903bfdeb0f18b63a0f609305280ee3ac6e978ad164b71785f755a3c937e0be37a0a1e29453725f6ba3c502efaca021c4f10736c028c612bab1613dc2cccc247c1e6d9f40d9eaa8f33b2400816f13edb950c9847c2250ec6e8c4fbd5e838f2e4ebb962c9f7878df038a98350fd025f8d9deca22cea17f4c9a2a04417a35775c85d15e821965f0f6901aab688e9807d05c921875ed2de1172856fee9da093e8570c3a3d0c3728db380350af71671e8cf20efc916c5741ba61974be30c9036d6e6c04f7bb0adfd9ee5f05601f7796c63a857bede9b33d46864852d04cbce613508fd90cf73dab74808f1f4159018611e50baa083de8e39dc9c62fe2f357fb95d5f4ec5f2fde9c3a15824574d34b85deca73f4836d414100cafea4f514759a76979bd7c0310dea9f618cab163bbdacff80ff5f5cc58cb689a84100efe541ebcc34c24f34e970e89791843a8c91d5ff562bab9fa0b0e604ac55a41190bc44b3d511d5fd6d13a8394b238b4a2ef5032591c1f238f0ae6d93371487559077de17ed61a2f06284dcd77ef0b2a2a85d52b4fd2e05d47de07c6b001fe1cedf352c1d7aee138a3d9bda57a163dd7f42f0a42ca23238696f801298524e37283dc05ae795686749d46bb8405f9977dc1d167ced376ea35fa238dafac6e0e79e3378565fe31d2a85013707c0400302813557464e346fc09c84cf14b2917b46d0a1b9e10658c7509f89863ad7ef3b81617fea702d80c487c9ad0534780fda89393d0aa43a2a064b3408a66af216a4f141ae97c6db527ea94089ac086e574aeb791fbc7bae43758adde0fe9565d58463d1cc2c4923491b6e1eeacdbf3fcaa49166a3a22db74d5aba0ef28bbfa67818ebd43dab6f9e3d005b952bf09d77b11ab23a8df53d2f2363ef4eaddc1068e8d71a4421746f339b8d3c01d8b8279686bfa9cefb680ae55c3fce6affd1162ee5b2cb3029473a137a8afc1991393b088394ec7bfc1496f92ccc845a29463a068633f1864e440f7f33f40cc016bc9c018892ee75ee05f06731960022198b2fbb8ce9edcf8bd3a1e145a28f976f104f63d5f70d00208993bb410a024afe1e09a183fb1f334a3a4e9e93ee59d3d314a257abf71d881fb8547e95c2aa574f014569195c9f7f06680af7b40c9efb379a13091da1bc00d6d053cc01860be7cbd5d28ea8416f55bacdc36fd0c4952f4816a9e19caf88f051d6756fe7410ff01f9be11d4e10f0aad89ff5e7b2880909bf32ef0013e7eaa6ff8db99a874d72ed0d50e71482dd955b7384f75c6e6bebe73109bc48af70033e3b51bd7eb1b80cfb64e7756d864ff48981adf966bbc9ebac33575a08e12c0e2075a27fd98c0253f73717b62bd5f85363f87278657622b6173ab55331ef00e5f3c8f6e7ba68293a44fa70fb0b9c629bca6fb7fdc278af3a43a5f95a50c3b47f908be6fa2234e1aabfd9143192e932dfff2ac630044554966a6f70eae5c2c9d66925b41f2c7106b0dd7ea699df18ef5d1941c84fad58406c7ae1fec2f5c32f07f16f790c356aafcea1459b78e6728f954fd101c903ad4ee0ed6d960cf306ef81e53d476b56358471c7712ab16307977ddd1c0ec3f03406290f3206625e14e27d78b025857895130fdcb470babf0b59215d5420eac7b4664670dfebdc994969550b80dd1877b0dd99cf296c99d111cb7cc21fe959d8656627ec370d1a3d3640554fffdf7c93d71712d01627326ffeb70c3764818dc18de1ea7dab54c0b754a89257296b6b9537e5f14ab2765a853083747a54d22d5b644411196ccfdaabfd053a4c78ce465b14ee9a7d8713ae6cc6769678e64940f7b0698d8ec56f7601ddb371a73d26bebf5efe3b33fd6dc8639cdf1cad4564555c320f3cbd8fb9f03a2be4a7f5711ea07ebe347bf1b3727262db63dda6d4716c8589907864997e7ea4f6bc6f7b3323518bb71b9e7a7e3b23bc84a2737fb54beb186e1519b576f2db54e5cfc339f5476e33466ff7bc3c56c1b180a404a88746253a6aeb73a8c43db2bcd05fa2f6d1ef8ccf999fcd735dca97ff5df32c345c8991c6ccb1031d66c45ce0a0a0fee696df5a94aa6d8376aad5e5c9283148c362fb81e37cdf14b344c05ac951cfb7cffb5b36d5d48cd51ab1c47bdbe1376fb43b20acb72874462817876868b3d7cbb0be7d9415df396e2a3ba56b661b87b126a21e2476fc3c100c4445c4ed87cec233a301aef2e361cc9c9b80bedd8ca42df71674372a14e5a5f895d36f8ccec4905b4aab01a2d1a9419ad523bafcb683326d5b57e84ac625eb8029215cc94ade152b0985096e16baa97b14452fd5a0ac252fa8be6e8989b6006557933aa0e8a64ec5f6c239ee4a306e0d5d97d8896532edf90c6a60d15961db3abec8a7864247b07d09d1e71103e3f1a36a6ea7aa446ee31d9ed270f1eeab1f6bd557476832ea53044d01811cd94f2a950d6e33fe24df29a2202ab1b476f14b38e727c3025f22c1317d8766c758ef38ced27c16d21685eee470dcf8cc7460d0428e49464e2bd54ea48fc4dbf87474a40486d83f3ed30f8ec9ed70a9952be15e100e24ab6741e99246e1b529815a6558132f8060730192bfa5cf7e494ccd2c60ca0424738d9f3da3d9850d16fd69bd6de1c34364071a4431007c40f7baca8cc35b5326660277065c0b6e0d83de77bc86998bcd3ad3ab150ef3858ee93ee8115b4914ae7c751b00dc766705f7a0007a65d0d456b492a1a8827dc738c007520e9b5acb1076fdbb7566f6957342fa451f505e62ba0dc7f53161f2f33ccf6358f6fdf5acc9c41df752e22af7ae81affc2e858e0dc85ee84ae61f64c213a5339dc2f49c4a9423f6b70cb31b3d0c2c5d08d0ccf1e08fda62d3a41fb4bf5a63a892a7b62310dded60d0d1000177da18eb04550e344d31691fb29dd4276f30c29f3672e986dc7fd80863b2a1009c3e1af92712bffb435643208b3b286a6814402bf209ac6b6835bcf77e48b88d4ed2b2c341d839b54d2f0a79333bc260bca765451976f296d114ce4ac2e82b282bf331ee1c68bbdb077c3541f8de2d765cf694ee36d1bcef303fb6669b1bab1d2aaca9549bcda8d3a5af99ae033c99d4dbb902869bc68c76d2ef1c2d34c447fab6c69d54509bdec14620ff38ef9a361e22c534a6c45ab1c6a906e63c52298e7d42911fdfb8a183691a68b71112b7656449e01b2955ed8b5d90bac87073c9f5db85bdad3fc42f958220974359bfd1c0592818d1b91dd685ff64a4001a3b057635cff655be68616847e7e9feada0b76c0f413efcd7c212a495b12f994dc1b8c1106eb4ed0696007f28eb417bdc84c5ca6aa80cba7353660023779d305f24876354cf52bbf343f497b58a9ef6f5612b3870bf5c7a66c3b6a55ba4c8a6446ae5fbfb1a301b25307ae1d7e6a78a7ce3741d285cdaa8cf9a97ec42b7edd3f0d54dd38b33b2365a782e46786814fc4075d079868938027efe650240de3a139cdd359065242a5ec2914032a3f065664ee816e55b84d6791f59393e6689eb9ed8687eb9cae1f96513a30cf567301d6125cd575f1318167a091c16db52425c34d2050f107a127c8120dbc3fec2d892188d2cc43a8e3f2a7d5c93e7e4a8d26c81107d5b1a9bf365eb6173bcbf095ef0b8cdb49aef17d7b823e2c736b13c7435b9f0b991aae114c3976d9870671011b1650dd57a2de67b29a812f2de51f725666f6ed807ddf423ce54e86e5387d56fa067f96bff77cbb85f2cc91e31d09083ae0b14e171ecb53a6258c75ccd270e9f8cbf341ce91bc47d8e3e969ddefe20fb3c1c09148401cbfb71d57dcabc06130913262f172d1147cda8c37e5404ff483d6c39ee73e9a6c499968a9c1b321245db11b15b6a6841b68448542fd33bd4acfa3a70b71cc7b7770a81e56b2067d1d844312361bb88ed7a4282cd38d2d24cf1c202d3288ae7f020e994f71357ddab510038c185689a6686ff251ac0e75d5e0b4ff66fddb970bcb12688cfbc96dcffd52853523c90ba95e1bf7ed3d702b85d2a3fc2241b0b0a35ba3ae9b3df5fc033f99686c49f244f9efd67315d1a2b603c66257b6e71874c17330efefdfa2e3ed02c7180c484ea2fd65b917a78753fe8896eaeff9baf2aa9cc23fc2ec77e073cd46c07b506faf0328090cf3d07172214fe7c7edb122b4b5b860f8734a4126e53dc6ff4ed8256ef1660d560bdc3688d2a983fa97e6b4b8403d01a38aff39167a4f9a278b804711d7220e521d88e373ea76486f219c57c644ab5b21a5c2dba8227618d49f41c353c19d55d63eb81b4101fb6d9087d7f93e93e937a154ddf77f281b7a7902d86c79bdea8b5c91b42a625726ca901bc62d274e2f6c15d3e9ea56115ef4d11c195c06587d23b879ee57602304118331830d5396ada2f70b77c12419654022fa3007bab7b37bc0019e274b6e9e2784d6e84bac2948f77a5a2b6e86d1a87faf97ebe4e414078047618994cff2546a67a99fd8470b35f248cd4f97affd0156167a3e5d917f51a15668cfd2e8edf3b3a18b96cfc084f2829ef95a9afec094ee942663dd87f1044284a792fb1930bc0ac8cf43de7e7bf273e575b0aeda4efa5561930fd97458919504b35b391bb299a393c50014a266188ec040b2cb83b5e76df1c1575627cbb12d82106104a2c6c99743403c67867b0bdfc49825b1a0c2dbc5b37ac266527b366ef740ea03b54e8db8e10a61d2801dad0fc9c3ef08d90bf8b1e40c98f9f825529f6b521f55843fd461c26de2e4a5f6e63e4dfd4d78cc111cb4b3c1ae2b288a9349ea16a020547460e69c782cbd81682d11df621cc2044d90e80a6b25aa2d9e353cd7c6a0357f0c2fc78b2b32e105a384161a8a38a41148182a0e420e09466f1404d4d110716d41967d7dd021b5a3eb3b5f5d98abfcaa400eeb8b5103661c688204f485372177a427b6d85d6541d0e667828bd831010cf35cd2a43ea366693d95e4a359c137557adfc485ce992ed721dfe6b1311782d9d5f066625119b97e6138052b197ea7491053105772bc6840eae313175adce17b42687630da0e76c4f63efde1c86aae653d8b9bb4e48753807d73d4e268407fc7a521988f374adc4dba6b4af685cd7a933190fdd118f6db5fc0ac3d4f23be448c30e2c2a592d5bd83ae6e5fa4525773d120cf40668eabdedc05d1428eafcce80b74471a675f66c804964b9e70ecc7b52c86e0b25ab89ec571eca4fa79e1a1128158ff3194bcd585edfc043a7e1ceba99d2471d1cbe4192d83156a2b2f4e30db840a6e0f9852d3576e5fb644cb8dca8b8e1586e64a8afefd4a85ec97a0badf0cb25bdd6664cd52295449501a751a1ea3f8f52a00c29e3423fe610b1fcdbfe0c4003f7dccdb5ffce3921b11bf7815daca9c9933ddbf4c1d4189cb8bb0140db3dc56c26a48ee344025d8e0623b84f41e641a0aa58ddfb5047f12168715fbfbcf9012fb47ea69332b355538b63b0d1b9cc9667810883218dd4f615b50e720c106d2acc3e806095343b4165b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
