<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a43a6a818f215889d8118e0abd89722a9ff562423bf3a70fbd90a6feda38dd38d185c531b9e0d4112f3406ba9ea3697b00f6a152852c82b0502ca19ba727dfcfb3e08197c992e166db2c3c85c90345586f0aeee9e81396c81491e5ceed2574c761abe72e2a29356d31019fd7cd9978ef042d2af00f7605e1e10fd01d725b641e5f9ff7ab610bf07dfad6324aeb9619523dbc18d026719afcf5b95d00de32eebb3bd8b6e53b5d9ad012efcaf4c048a2b3490a3307d81cf5b45123a2c6c1cb58ffbe86f369ef3ebd69a3a84eee991805dafbc28a7babf327a4472994405c9769578404340a9ae730e812dbe490cd93d38e467ef64ab62363ccf71af51e5aadbe3745535aac4a3c31f30378b146839648312fada65d5c25fed683dacc52305a086853bad0838eafd0d205d333ff402b28581b3ee55aa50420a20d64046fb3569b9cead8c047d38de89294241334a189638e53b452c523e5d33a755bccdbcddec485dfe7e1647a71ad117afbd4fc7b6f1fa7cd4127cd608945a0f1aedb62f52f924e735ca8b7f9e0e16e70e985cfa5d4cc9f6e4d33473cb09d0bd80f4197b77ddb0d78b619f1c6c1516a56cb68a2c89d3a1fd8645669f504f493483b550a4e4584b6bcb7a01a355e81bfae8c7540498460f1abdaa29749a4d1959e78c273cfc7d6a4523d8b23936bed085a71fcb98017e550485a765343a8416ab62354ad173d71a8595618939df83f6cde6ce2f72b7cbadb5af0ea5bb710b0ec5c158a71e126826995d5b9099d94e1db7a53ac6444886b769742c9a8e506fbad6ecd976f148d23e68a5c3f9068a0cd157828472b35f836e723b07eb43e7cd9ad2749f740ceaf7f042d30c609198f94ddd115b5958c8b71ffa20f1c4d493741e095b4f029ad1890cb2c46e006097194c3a3ff7071ee4ca59659714d348b646d213e34ba87378b3f936f87b12680849995e22000db9b5ec9166a3abe462a7fa4625712faf9d7f6b26c1adfa367d00cc0da84bfd015c131abff1184027369dc868b3b145f0d516ffc4072b69a662b85be1ccaf40f54fcd6380626c63a3a8f4a144fea66c5d1e74c3a8822630395f1377f347f0399639c8e956ffaae43b7f30ccaff7ad14f257213df48b902edd895ad60080cab92efb84050a1709163d057dd8d03b30a083b87e7a807b277fb183766d36f799f1c89efd376217dc4c18da28da23661578db22652a88345f2d875f024e23820fbbc17cdf15f1096be4f4e0c0c818c7ed9ea3d8b809755e11dccbe9a449d64ff0dd3f576912e0f1d48786c6975ccad89f8ebd603c3ef425aface6a845be13652652f2e53422df436daceca679c347fcfbaef58006c306652e4dcdc1f60a54dcda0f55b121da87e70c91934fde669839aa54f1cba8722040b47a1549bb348a258ee4132a2192ecd5c540df2214aef2d8d06a2e9d7ae6d70cf00b17d999f3c9e603202f44480ac62970e22432fe6e98ee222f5c3cd9405efb7797e4881538a4ce27e86d6696aa6e861e24be145739603109c7aa04c2cf0b23bb8a166a57327e07cce3f27ebfaf1e692da74b48da25b4f39b40b7fd49a75f83285cd761bb18ebd9673306385e197f1ae76da894c740fa4636533fdc8c0b9791681ca935fc3db5dbc9ceaf71fe1fcf1474bc0bdd60e418be0e37ad847bd2ce1c84b4b7a5fea700c416f9a8cae0bc3baced1eccdda5ca09e3710ea88719174cfddf3fae34ecfdbd2b179eca69939eb76b3163ac31bc771af83155b980e17bab032d14c8417962de8b0eaf70f08e4a80f5d76862ade03b8c13c09e3185611bb3b30907d9cac6b16554760cfd838fd423f4fbf2c3f506357c8507fd241230275163fbc3efdb81228a16c3ba30b2bcd6e672cbd6e67d1d53b5fe0a7757f94a236a492d2f914cf0a0e625b140817339b927de46746340f8b658b975146e95d28a9a588d341555699e7718017890cac55c344bf497b32c143c907847e5a933bffcdbd35ef245dd85abc4c1154054c679d4c6aa4ef8d4b391e49e1ffc0291b30b1faea550b5d12c8eb8245508af7a0966603c4cf60630cab60da32dc22dcf2f1924789b5bfcc6dd8533c97623d54c12886d1fc97c5ef4109ae046e6c84647622230ab788ed66e09fea5eb233293b6ae8cfce67d06ca200e9e8b9f7dd98ec4bc7db5d33db29bb61d989f62ffb4cf3f023f31a2b3a347d0f82c25417590665a9cdc0837849f05f056625286a907c96525bdca338f13f627b63036f3cd80d15e42ca94962be911a2e9ee5b15166d1d9213c581385daa4cf92559b00b14e1cb50b572c1b6f5781107080f47933e23c5307b9792ec7103443fd77a779d78e66ef21a04a1fc5911d29beef2601f7858100bb6b8a37063a28d2b097412f59f462d852e0d7e75ce512487d20f5145c2f96d235287bea21d34a1903515410073425451469b2ee2dc7af21af77f969387a9bc4353a0fa5cf39e8189caf956bd7927f6609c618afef5735bfb366e05fb031a15bbc52315a1377401af0afbcd2d24ebd1561341da4df20b10f17adb2c6891fb13daff6d6f4c6be92349d958ac929015feef852bd5c77eab0bc6c66d51ab0b4a7e0304d73578ae1c9d79e4c10c252d416510a88a3f83fc0499b02238fa2c63c6102c9310f27c551cb9c416ff000b7ecc285af4edf173f24803519778d35ddefae94655b503abb1a7c7b2126b1ea75f8f272037728be31544f05ac18dcffcb9424effc03614f2e5a5f3be7bc0dbc98b79f04a6ec651ebfe271cd5de991fbd9f3394898a061afa085ddb86e42fcf77c0a506102c5863c7c42dd081098195dba07b21e3fbdd920897a404ff7ff278982ee9915c648cf0e9ffcd6f988c33d261424b9f920a2b6c22ae937023c14c38d151ee360ee31526659e69ac7f6687e1d1138d10c703a0841b8be46dce3dbba68793211dd67225ef4bd27776be1078d5af6157875504245953b80d2993a754ec2d3bc3b06a78cc6321d3e3ab0165a1fe44834a476025c678b1e71f22d616b86fd914701455074d7ac8de26ba9cecdcdbe4db33ee19ba01c3199587f3d3000751a964172b16c8739816066c55116be584c1f54169331c4b5fd1af7f6dbfc91181d84ff2d1ec49ea2fce2a4cd03e0b9a7e3161f0f5c839e194e00365ff810535bfaee9dca22e36697d5dc30286dcfb68195b272530dd9c24e06842cbf96cc79e084da6c2b54816d63ea9c91aa017a84ae489f9bfa39548e31b27de063d9cdad91dcdaa1b6d1294c5f6fe48489770550826f7a47be69991090ad75d60438f1702604acd5424ee61f11f1c7dc665e159bf2fa712d2eb8b1047f57542225eb16aa8db164ee2490e24f1fae0ba2c3bbc39074d1346df80c29533dd350003e5676e68120e1a877ee76087671de0d4ebd01ffce47f87b2bccd4f0462e683239bba245418afded3eed5f8e7af605068fa02646ec9de83a7d82b1e435992171feec10eef8eb4677c1b4cae6155e6485a244819b09e4d973f4c88ef96927328db8b398a7b5cfdf8f582aada0cd73b9598f08ad266452d43087cc0dae5d0a622bdf5102aa08246e3fa7f3ddf13ba97c915a813e61bb85526e82b2839407a97349b53f400479355ea2adf7d2d20c547ac67958145de1678a61db6857f094b312d9fad757b632b810ad62a0b9b215bbf8d086c2465b128574898f728f145fb9593d3bfc9b945d88150653ea6d3611e2f3c19104f23ffd741064171bd747ce7d813ad1eb5a96926aaea9c793461ecef5ca418b83e009bdf15295f2bfbea8859e0c28e94205e1460f58cab2e6d7effe43eaaaca60df5fc2121b66a16fb006c00ac91aded80d0e390f06bc86b165fd9ac50da03a561aeb0c8bff96327a6539dfd1c99e1e89a703e4b631f6346c33359fd065d7a8a11b5d3f8361d20f84cf00fdea6fce4623de721ebe0e77bcb146eba51a0125d76277bcb6c788243ee846b028a405eee96b86050f0325549acae8f083a3eb80f48f433d992fc72750e977d70f9f3d54931ca19a1964bcbaa983cc1a1d33126a2b28b160c3f98ba8a8cbdb384253a231d1cc779110fd9c2ec83e78f69524e96035e2c6103eda1b8d288d0ae4d5e9e483f5d505656ecd3602fea5eb8a32a1d3498bdf865c8ece4c40280bf67d667c55ee03543aa4201e7c2272e74285e6c30d9bb7dc6e75a2f380bcbcdf295e97bfd286424d9003a9551dcba0cfd9a30be68634c5387de5830f2112666c465cd351179e173ae38098dd1ba43ca7b8016ffb797e6c7ccb14938d75379631d0b3f48350c45ae35898a93d28f068699c3a5ea8abf02ecb8a479bd459549cbb253345e8d562fba048458027659bfc1b93adea0f271cb4c04751ad49fc90d5baa22cbf0d109a512a669e2bd9319c39ad970a88afa1654f3e3e43451bc23945eba0983576a83f7b8049c5e1ab990000ea34da9e8b302d11839d6decbf313c871c8996e96165d4c105e4e46eb7e5fd8e16f38475f6d0cd4cf80f09214b921c68551881b67db239a58a6fcc372913c6ece6bbae8b9f93677fbf01af4d5714263897f0a60e711376dfb98203356627dcbee8c846c4a76e4aee770c9541872f33963aeaab951c7776f307cbfc705711b20fedef6fe7e9a2a7cfa3014c73c7b3760d3f4f63d5f6a6855cba2f46c1df770d6ef1b177d7179898800510e9b98e2dd98f737ab120e75b4e5becdb3dbde406cb24dc3405de3935b97b0928f666079fcd1271bc553fe78add2d74a4dddcca4d56a3401ad94ca990a522692b771d5934946f8f587f075b646d6ed2c698ad18740a5712400f68f5ec8e7a3001a5d5bd92e0167d1183b05d3f34dbc0c08900afeaddf75b1a565ec396e2655f4c32a131ab841b6912a727e07f35d0ed19ac3f0bd46281bf2c1311c9899778bfc2a8c40ce6735eb5f9ab7657fb945136d0197fe90d7f2142bfad272da1fa3be1a199484a9700fe7451563ca6da158da27abdf1c1036af17683fff0e7132f65f18b5c32be0b916ff155ad266f2f6241142c1a0451d867e000be5222b3dfaac504f699fae528e08002c945f2dc7ae51c069a8b70f0da0c74017ea41a7e43ae51a31aee91b52fbb0fe7244e95969a87e2afd2abb7f98f614d470d88d5c4255e6f0c687399848dcb4ac86d5606f67d4186b3bc2942d2d3cbab0820e754bc0dc4a2082974e69e26107d36c39375c26bf2efb7aeaa1f90f599f14abeb74a32bb8709e2c1481a5f0a4b7dffe9eb586df55f5408e804a178774d7598a87ec1e1f38af731aba3ea1fd559c0aee8197d13f48a52d949c1851bc53110e8b56a4e5fc163858e1ccda0e49b2ca85446d0d6d1e0a191a3cae06dddce163dd9e835670e9b4b6c21b38bb486a28b4831a5a6e34df99d37c1507d3c9795f559876f35ebd00a3ec1196ff4c527328dcf52ead4ba0eb83072dc5074026166d86c6205907cf756b7c1c3b3287e07e4ce84b5ddf5433a0eb8fae7d922b85d87d2e0ccce89f6fd593c8c9ccbfbe29961888b8c84dc7410c1e0a1f187474bd2e0a6810a9f31b8a6d0a1d9618b6de825807f24be281be75b35111f649773471f6f9566cb0b34dd029ea2dfc841fad8600f7ba274382d04fe63017d2946842b56298c2bc37269f6fc06d8648730306267879475d47ab2a19ff78281a1a795c10d0833e480ef7791f6e72b671b733d01eeefbad5824dbee576abe0eb83fec77af33fe555cd1a642f98f9c8f9ca6d45f273a7ba31e0a5ece5dc2a675a3702fd7ccac82e7b69ce4e8fe5b9ab0144dac49b1db86a5a05b46d4c8f58992f4ee59a8770daff15e24a80cf51cddd2599b79489a515cd5bf90610babc3064c3fb0ac252104db8bc0d2e66744f6ae91d4a4c3e953bf06600099245ee77940df61b45843633f1619723389b18a2d8a56523d0308bbd5d37bcc0e51029032dec9c276155a19f4389b606c2234fe27fe0859a4838608611b4c853480951b5af6de60ec4606a16938fdf4f80d5025bf6e6995da983a6a68656ad3d79d8a4a640d562e98da7c7a98d225e32bd31dbb0f077f16a17289162fdf2e07ce9516a31386feabeedae8a42e25b311ae8c6a4cd484ec35b975e502f00d90d54650135f02f699d55cb6ee7cca3a171047c06212d84395dc4ffa8b3fa2276b3db9ef477de17a2fbee46b6ee807c41f4404d588ae76afa089654bfc820023b6785b15d5e2cc2676a11ab300ac31893116bb957b80ff9a44d6206f4231ccf17f9dae5d06e4c1eab1a3384d5a901ba8f678a59b810676acc63e960b294ac9b760f47268cfa242f569b27f0075a5d20736a13c28266470f8dfc40335fab6155e668c514c546ed98aed5265d5b4140102005a309085c3cdb992dcf3b3c7a53915abc492789cb6fe9dd0f47830413af1f876fceb0f2c2d517c7f9a158c968755fde195ecec01b1384d9ba98618e53ef29fab1cf50bff68b44042054e9febea1a79a8bad16e3929480211a3a5ae7da82c2d35bb342dadd2a74685e742ab57b6d3be8cf6c835bfa970f074a53f274939a10808a054b6a44d5613058db0f37235dcdbaa8e8ec940e1765d181e85f86446bf00b79f2c4454114139b002eddc72655936114aa43bad7b4cd7ef114bd5afff2e0c8124c46e869919503450a59a4954b556fee6a3199d8775f6e01829d2513a14e3d24497ebd2d08d4c8a042c40a65db959514630dc7cca872514aef9c3a5c100e62b8127e8ccd87a6c4a517f984aff3ed3a867e9dd3de039176af51677869cf28b7fe1b21ff1ac4b9c3433e10a429d3c5f293bbce4a9d0a1daa712ed125888435062ec3edbfe54d1c73f1feb7d90fef8727dadc165c28589780815ab609e7727c35ddef68907cc240807eb013b1dfe365c590648dd63d1ad305f522fe961a0425dd3269c0b183267b67091a75b35fa889fc9d77908721e1a4ccc8be23c8c7a7aa23eea77052b6b5e2fae580c7b3e38010de861e7a985d756f809f930f4ac45b25acef27b20be2d56c0b89314a0751aa0a598f89b000919454855918219e89f68e395ff49af5c7da0a37245ac6345f485a5723cc602f66ec2a46d49a1b8c6e08d91233326fbf04c2ba0bbea0919be197283a2c2011bfb0e9083d9ad14e82f3e08ef3cd9018a5de2b18441f2271354b613044004202473d65d7d6ed5d0413b43a75917e935368a77c812f40ddc86051b7609f8eba32a3c25c42973c3c572f6e0e22569d164ecccb1325d66e7a33c28676623361c374556bb635f332a69b3bbacad232423c7c069e7ddf550d8628887186c94251e58c4341f8450ed26d938472f73b00931a2cd6ba46c075a08c0365faf8afed46a2106cf971e0c42e301ca2634fffba623671a7cc5de221e22357b62f11232546fc5fde85003e2fcd3630960508e4ab42566747fb640aaed1916d8b32b50464c7d98422d319e1d9e0bf8e6d8528549afddae9a84b3f3d9c4a6f3b306245b3113dedd5f1c56266a7bc1d396873d32f9f9736b77078a63a8787b26411ac0ec71cf3b0ccd3aa3f4ea25d95440171166c5aa2fe20de6d92d813e3111f00a80930127b59d1554e6b65ced0d8946461c589039091f47db725e67560d7592fed164d97435a5b7363be2456a13c8bb7d5f27305ce699d1ab7d69a96db60f1bb5435bfff5eef36ddba5ef898995077a39e7d27a49c8836deecfcf3e79fd5abddc4acfe7b9bdc557706450fcb4f828d15311588548f27ed43d5aac1da7d5a6a86ec163363d589f54a1fee9f495659995f050b5596293d930a2682a519943b44b82055d0d8bac4125385b2760640fc4df75fb84617cbca7a5532293faf29bdb7d9b8de43d77fbb421468e5ac71df853873f865623fafa299a26cf485149d5396eab886160909f1ecb6d39d4bf0b971f44545f16b0143c91cf5465b23ab9f91a05945feb87e840d74c660cc49131701392688d562a58d8b2300c74a698acf2e551856aae3c2145ee8fcca8f1dc66eccbb6ddce596f301fa5ca29dbb1717b0dba071c1d34e4783c194e40c5440c1e4d53d863e6eed74dd9ae397948a0d9d93f2225c2946cbffd21a94b252b47b212d55ca28b177b7359bdb7cc12592e4536b1c35799332e2a5e761e630373faec8bac277865f461b7b576b787132ea7017ac120ee5ff79c75805fb7ad462a4602872e1d63e3a33161b5b96a5cb519ea68eac208b96b285275f3de4acfea22f8f9081ef728b4a523b09aef00c5420c8100440dcb3bc410ed894d17ab65cabf334a980594d1bf2fa886aa0b8dacc49dc73c766d7e3168a9af9af3a710ea8f074c296eabc2d301a3c62255682c4bb81fd562b916921b3f0c3133df9fbffceb89cc2072b3d17a9b04efca684ac8c51c80b468f916c37b5dc4d454bfe04d4acc2c5e3c4c2404eca125d97c77b577961325dbdd023963035571f6926dc5a3136c1c20ff3333887892f95a62cbb81d8d5e016921509d75574df265679080858d83a4c12eaa76039351bf7413bfbd861af1820ae08a1168be565c3c3bb3c13ea7190e30fc5d123d2cc2b1eec69f16b306832a72b2746d4999f527fff6d06523b2037e5ed755f571b8b7f8b46998dcb43bbd81bc2eac569b9944a3fb539505a5711e50414dab7a0ef896faf7a9820e56fb91f6d65097a56b89678c99aee40cde366924e66b5132394f5a1790b5e8ab3ced92e8b0a4a99a7e110191aef5235f97583623c5ee4a22b8706120c0690a10cce20300373afd99a020aa9fb1838a6ae877dba180607adeba40016cb5f3cfdd05728f0652b7b00ae6795f22ebf7bb9c7db632c0400e9821e176dfdc938be62962360c1d03028a2dc98f5ba972a4161bb0ca51b3be583b8e9712aa04e4037369934e481e289e896992906809c3e399d290886536dfd95f549cff63912f6077deee922c6dba5d4c3fda82ad4b0249ffaba6f55b7de905a4b3e5d5f38bfb463a9a2bcd9852abbf85d54e0e9794dc009ab8ec62713c446eea42639717c45e0f997dedf4f9021dbde8cfcb52b4167a06008f3d4d579f68d6a8c9905325daa489e23657fdae1cd23c12ac74e56ab5e0989635cd28cbfb3a2babdffe10bb2b605acf3aa823c380b39cb99e7f5086ab282d18db43841e837a4bad3d5cf112837f5ce9366fdd3eb22e44ea57e63990f83385577f0bfb919eb4e9cb72c7e889f3c13e00d3e6abd5589a17dddeac8c7084d148191670f95333ea32b0e76b26fb4f2454d10cefb863667094228355f8d090b5e13a34adbb8824f785cc293eba612fb92f9ab43918660a241efe7b2ea9305e5cf5eae25bb50d28c414ce1a728e18d53a96482b30107d4bf9a6d17d31ba65a991fe09d0ebd489689e726a74fb53926bdfe2afaf4f5e0ec63632216a6b789d82f331538cca5bb5bdc111a3448941039db9365c83b905225ea63dd634021e4a7aff27020846e0b5317905d964569e1128f88e1820651f2e705c0db48c030e6f8e73dfcecb6bb71f897ce2947cb986c90b452cce7ce5f6b7b1462cf49c8d4cee8e79cfb7729b2aa901c894bcb8a068b27b4d46594cd2b70c40e3c22237974a1c9f5dc651efce10e76f71d89291f4657a35602d4922fb32d92872c588803554d483a5739aa27217487c78525288e22aa54a858c477e50c76985bea20661316cb9658577e097bbaa0aabdb8f986842573a42143cf1d0dad272e094535ae6cb714e817625468f4388e6466877a62f3ca168a36dd2e5a128ce38792ce11c4b1116c1ecd2efbf66a32d40539eb1049132cca9acb82e0b62573aa9a11c3cc04a629d3db897331e85af8b3aa22c03fc73ce2e03a90d5a1951b5ce95e8700d4119d60caf631cddfe8227b3510817fd7d2b426e0a0981abfa95250dc876cbe5c816c972b58e52a669f0006098b296ae5bca9d29979d27e1d9dbbab7ee1a8575487d3cfdf700ca7bc44642bc3bc43ec9b5cd0fd4d6a128f9e37df4e552b4d79b292e49ee38cd5657e02ae8cbb697e7fafd91b467de60c2ac5d0217c5f2bcf59a967bfd219801139d5b5087d322a40ba16f8e7658b66dc7c0f2092ebdaf4ae81be10306068833919065861063727478279ff03a34af26a91d4562c7f343266e18f4454cef48b8e0f8dffacff50a3476e48366e6e08ba047ee863d5091287620bd457bf5681973a302f185d84ba6ce00a21741b34ef8d7d6d8feed751a89bd806fd61039f191481785b435d58e7c64e6bf303d492673f3912176ecd537632a38ced367c439b8792da7cf017a6ac8085f5a1482a1278aa1889510bb877dce2fbdad8cd3558345001c052c9f93ec437d78d139d10f90197673d0f5d2fd23518e6e7099cb6bf3595934af0412337a755bb70f4f4f6c8956594b1a136700fedf1930cf2e77145b9673ab5ea58609ff4aa84846b2033426669e04e600c4b03d34db650832ee6230ba78e1d3cd79a3fbf7c61e77fd1b5bd6e31c30e38b2ab2ce096117e06d324eff663fac452c473309629c1ab8b1242c6fe61b57cd1d051663285c3f3c4720f1fb028554b571396473be18a6e34715f50855658fee67a1b0a8a0c2003b7f54260c2edfe7b1400bd1bad83c38b89eb8c161b142b22743911122d509fdaa4057802a445ff48ca93a2d326868046b12331285686f113a2d2a28e0dccaf3952a0f5ef2208a795e244cba9231b110dfab8d421cf181579cdfef4e0d7da24f50e32fae6f537b1cc82dca39de05f7116b795712ac8ad5c300c9302d526b2623d4268355cf6652b6845f5bf139205bf435f45d9f7288cae3d46a3599e538885d79ca338f4973b0a15fef19b08522f6f5d0ddc4f310753d565a1d897bb1b11fdc7a442813628943e96fcca8288c63c000d8af84a58bfdfb793c1898c71259ef06be1ba518c7b6441c2a5d567dd77fa3a01a55e159fa4ee588f8ce12b68aec18483f6729e8f7b088950427083df334dacaed203e5f37e9cd780dcaa7e4d1c9cbf4b43bfdfd58380739f6938be4bab969f6262fdbdee7054d39c31eb8730031652a4d33f5d8c23bf982066c214eee404f081f757a8fbc78746bbc1e578d9493466b203a2485ca3f1d91fb2cd762f7f39b06019fd8efe7fca1ad2354527f2e8a73b0aad8ecfc5cbd73b93ce7210ecb8bd60745add87cdd548629f73665497e6ce0f2b548b1f5776553dcea50ccc652c9402c7dfd2b639c3ea6c73aa85e7a3bafed85bf1e3056a8f8523e405c97c5606923fc9ada2ce14e7f642a805f2ff4badb5f9c1cface8f674204ea5313b262d0383b8788a83be77eadc32c1541b3224c729c30255d1be81f10e160469255e0864358566f2bcb51821b5685402fd69c00c42185cba77ac5d3c83b515abdd1920347c4264d9f1258eb766744f62708950b89e0dca12232dbd9f931d4a2e7065934996f8f062df35af9dad32b456dddf9d11891b84358786e87c9e528c1acf95b61f903ec70064f50031d3109fd6ea2ec8e62b78d68ab061edd519e7c54bb07422391f2321dd128e848d8e80a9d205ff4d45c0367a2399f21b0056baed584d16f73cc140abac9dd76dd8cd14aab29a41ca1f37899e252e64077cd82b2df20c84573f53135e20b90f1f977802c527bd43d30409cad1d738c0c0732de69bf950172e598261ec06c2f997dc36559fe6435c3514a9fc12e6a5adaaf546d9d7d7a1f3cb4c8da3d96f92cdece3bc8cdba6f220c372f492bc5c6635d0419b1752e9b30c908af8f97beaa1d573b7e1a5bb476f021f5085d71b4856f04ce2fa8b41169f0995d1306aef918de386d82f41e30b72794c8d3e3a3d12c10616fa7804ed2e71e02e04d0deb16bd8beeec1fb85b1d32106823f234e91b1572ce84435c7fca4ccdb886265f05ae814db57f5a17707e0fe4346b30df240ea62fe47f03ea36397029030cf7f43c7b43423807bf0c6353fed5701e402be7c45769319152807e3826b319adcb61301b5a5b41fdc46db027572f28eeb48bd23cfbb72eb84b2e362b7605d7462b6f0b06a1bba101cff534353891c4d9fbe3c26e45c050bac6213d09200a901e55afa4e466d62f0fdab009964e8b811baf4a65813b371251bc3e5f3cd60e5e6702f236fb558961606ef4a4b05c8947b730959ebff4e86a6c69d191b7bca846cd15212011a555883abd7e60eb9992b051a0c192d10099904f22021490106b448ab0cf401193f2847e6a05f7d346e32bb29ca8d84c109348ad3824ac59da646ac03802f0e5521cd88a7b9fbb7c943d1cee183637380e94abdf5c965b5f014f63b2ad40f9ed859f806064707d3c78c19fdf2c6007a4eea2ab39693ade50a424da22bd7d767b7dd4e1e7140cb35b55aa64e5224415308996375308aa089a18780399490152f8ae3595e4b980b779e060d97ef408735c92704be5b902366ac9682669690c797fc33a848c8f9c5d2363660c8bf1b935870771c98d31bbbf7c303d8456df660d45c32e9ac9285814076ac78efe3a3ccb5aa06df62d01da22be000e8b8824227611ad0d7dabc22d79685ffd5836f1a0f3266986dbd71a4d15a5864c6c1a5308aacdfc78b7b32909bc79a527037262c004feec484905cdff6c8b1c6ddc5caf4d36ae7ea124ada68ced6232aeec4c2800bf82e5ccde5ebc4035fd1bf299ec9541c5edcb726a87a45cbbdcf2f2d1317cf357f1830e623b7cfe2e1d02459f41f6f2e1f143e00c1dfee22b77cb7033db556e7885c731ce894a43bd6ff67bd1856fa4bab1a6aff037c65331b1fc7ca62dc5dc9e47ac9bc6129afa6f082bcb97a732c9291d0093c5068301bb865605fb8e3109c37155ffa50306ab0dc32c363478ad56a13b3d84c2f9027527702e6df34f5c618043b8582647bee5c210cade0ced109c1736a171bc1645e0494fa5f2947d6a4c02e01c00c299250b47736f5a4fb371e3a2c23d8feb4551d0ddad7be746bc5c57421d08baba2c2ff4331d21044777ad7ca2c452eccf3a733f023b99ceedbe6e9e5e8d82ee940043ddd6fc4c182d961b4ac467daa11d7e348a3952a376ff6276a7e8303fdeb90d556ecf89c751a83b49b540853ce862afeaf021956f2b0a8bacd5f7666d195d18bdb580d62d9f58f55258c3c7cacd2505cae8b4b171120d25e48244148a959a0dd6917564a67d92d45280d531d0d15b019bfd01a5cee04d4dc0a671e0b868791d64aea361307685d71a35f4eaf57466dc762d7ff3aecdd50be37c8de047f3f5e335c9c03224b8abc84e6b5cd936640241971954378ad48fc893f9836c9dacbd55a5ac549e208dc7009f8d3b47f1fdbcaf5f6582656e9ad4b345e56c6dc0d4fb39b1f1862f3f21226ac962a99655e5f44080329a08747871066ee043f9ca41863f115bfa02542eb7e31896abc373831c99b8c776618c857dd67ddba89c4e9e2f3f91721157cd318fafa47f6540ad2766edd0ec2ca445332e42568e0ea5e44ffb94a574ab387f5346172433db8efc2337eba7aaf92b5c0fef4d5e873785bbd56b4db15005eb92291ba8c7cbbebc74543d8b48bd740dbe82bb42f16de7ee486349e4767a40078b06395801a756f1a6618a94cae0eaa6e56d7a0c4fd8828f97ec3f3c039c98000b44528b98bcd3e7b39bbaa42b48633c1c8db6c0d28a6fc775dd4452456612b69f52ec8c1474e3d4e92a7210298a6f0c617130659c1dcca21af97957605bc0a370a142d19cda440aa483be811933b14fd012f0f520ae5cc020b75793c024954c0400da85765dd3a1f712ce44e77194c1fdbb2ed4c5a44035cfc2dfd4af9fd0d0a0489d13cb4765467635d415c0264c2c5d72c163ffa059915b8c79f0ea1352e3c960040c0ec47271ca517283459d2852980faa24542d0c184f9979baae12b806d4e8fce336c6af50f982af6603e22107f42392303ef03003ffb14a0a1cb67cfdbbf21baa05f37593d2f44f0d0170e8a6d41ff25e96eab126e3d63c4e33ae8ffc4b45a3bd2d3751237a695037c24850550439a3cae2843523393f2326b03faf725a64fae0635971de7a46574ae88a7953445cb98e96502a27468ebd25daeae64ef666d6677d1675618cb49159fc5b67ef8f07307176ada5497d2f80d22402334781704bdf7cd0f4863115a3167e45e71dbe47be8df80178b4f9d7dc61645b56eea05a3119d5a8f190e26ce4c2b4939fd65f1782c71c1d02fcc3df028d2be1678f616053bc50e266a4e9e714cb0b77a597c21034adae195bd1c694195bc06deca3ce7d354484f54f1f2b082a554c44d40c6f2a93f08e3b0792687fba66a170d7428fcd19f51d59a0c2ccec80e0878ccb6621b02be1138696a8c4096a754f687c5351e0dad655b21bdb5470a1b3128cc3a8bd07261ddadb140bde1f9255414fca07a5967b46f736e4f9ae906ccdf9fcaf297c2c0b7e45df5af576aba02fe72773a7eb1b6559b407033215f5acee15dac64a83c03ee1a3962b865043f65d0be0bacd37df5bd67004c923802d6490103876d9a6c179be58b32c64267fdd499f9b9c1c15b48fe61ae81856c1a791e1531086d4ff39c125e10fd5bb76e237eb19c9bae860ad4a8e6a0879063886a7cd0b003bcba108ba466d0a73f39b6929e5b556cb847eb13de92267f373e84ad7ef32a2a033296c99d89f46f3ebefac84b0f80cd04f8420f141c39eb71d16fdac456185ad3b00886a5162ff16f725491d0dde694f5d19d97926652c2428b9df315be93ee2fdca8e0218f36fc7b3f1e6c20d9c91ec4c559a35e121126c621e7047237e3c2f2b34a80795bb440e28e9d6a7a5df354f597ffbfebba7c0d95aa5636de0de7269f3d620ba4e4897e4537078cbde90222f149300a453d64984c09c17b3c482c407894e1090b38c47404cc94ff4262ead84db934f761aee1cb1ef6757a514059c848192bdf582f2be8d533f01333978ed396f16cf39af9be4279c2855b6d09f7f19e8de719de1a758a263d80cd4625c9974745a617f69794df7f1c9e9b38127231c1efcacca3cbe58839325f7f1b915b7dfd4cc42499fc3a32066bc8d40705c3d05e36af803cf7944a30b4d501af3b05aa7f8bd9ac8034db4a204b2bd18060b661a99cb2b844ad5ca532f2234a965c36ca524df3f571dec660e3d8d0c52fe8707a82e508477ed6be3a4b91b67c04a5ade795e7fee178672bbf5194739044d3449246b6493432d00312cee766d2a9f709788fa9ebc40e32a7df1edbda26203394ed7519f83e415843125fb65d7c04038b0f02c7830a2061d3c332b5a575d9715fed6aa9a5042ad4e76cff92ad995981ce5aa4f90125cbb6eec90375eeda5aa876ab3f4a893aaf696a3e3aceca412b7d29e5b7d21d392847491c577518469927e14c4970e4dfc93c9f2e4f74a6ffb608cff0f6cc657140013a6430c127e643a1a0e7077571e78630ae7741a76c278621e4cac7db0b2687afb29a27bb8b95073a925381f8b547011a7a779a8514290974e4cb72d2e418db50bf240c7c614119470168b8231105d3b69325fd5c6cc20fab66a8900358b5613c7b53de91e5420c98902f753868a6dc59c8cc3ceea68992317ae72ff04674bb481bceff17fdbf33c6cf1abcfd16111a02323f166af4e6266aaab3ef7f7008ad90941ca9ccab382c275587b87535a068023728d2dd38953e9d685176a416a905a730fd6bffc429dc46afabe37c402a2ce213d42c9a95b7152feb48f33c4bc48526a82e0eb5c10e44e733b441ec19b1c8d1393100b7c31962410dc1cab09aa8a3de85608a8a6d60e0bd13a53d18ea90bc4cd0a26b1a3c2dd12d03ae421c02761b6bccfc0eb4190d8848af6916ffb637e537fa3c64d6c90f8d43a3c3f058de8ea4f7c30193d4361906c3e2f89247327092d6d2e77404cf60c034a42faa29ec88fc691debd7b9bdbb7d2859cbc5416321bd1e3a722627a2ebfac2ad7c0cc316395b09ea13e81b3636100412a8a4b00754cab901a92373ae65f178bb337c5ff4738dfc7e2003c2705ba9feb66c68c44719fb5bfa3998cbe28e7ff0039ab0ab3d1731a125bbccb63ea874aa3a37e20ad7282ad509a254210141c08877f8eebb37c391c2f667adb2da5a23dbe5e33c697789b9ced1833a76961612a160ad8570975a4d5f906cf309c4e9d9d32f0fb011fadd7917aa35e03d8b74929d26144d6be22d7a1c9fe72eea362f5c99fcfd2423d088d44cdc164c4d07542aff58734d6736595d0626ab9f4050eb5909d3de48c524f4718c101431a2a5f454a4ed98d1ac76cbc0742571d2272edc99b98ff5726c9687e5121581e1670d98c88ca914f9b8b7badbf7859597d862276da8ade6a61d08f125045597afa30a7d013415c81b4840fa94737114b49c7f5c09e5b58cb39f367e37ff60d8a8c99663a4d97de0b46ab7a69f20dc374482bedbe951da156240a9e71de96d8316694f8e620c5af5f1ffc22e86d9b0f38037783d480cc8ace5d3bd62512e5aef7a05332605cb1bcdaeffa536815a283a0f375afdcc2c85e63696766de0468c1807802d6b9a83e5ab4054d5843c1a98564216b047fef214e0cac4e95ed519eebd7728d0465b9f269bdbafc3f8e9222bdcbc1506e2ecb27109c6b2142b17781cc8efd337a8eaa016ffd2fff8395d88c5da90b9c0d4929ef0c0775c02dffcaddfc6826f7b7984f618ce91d490600732a200ba6ea6de87de45bd71fe8b63ba01e74ae685c41d0995244fa63793bf4139f80f927a715bbf70eed938a118b0c58032a192b3505906627ee0e03144e02d51c7999011f896c726dfbd394d270015c89bf3ef0ee7b6215d1ea062a9130fa40eabbf1f307956ead555568be2d73f87272394c1ea225d001696a31665d113ff989855ff0be8aff3a9a2b8de884f5911b9f309cb5334809db32cffea0259474128845e3a69bd69919af9dfe41fe01465960c5ef4343d39e225cf082b3507c741e01bb09bdc7621dbc442090e9c8c77a0fbff0089a329dbf39ba501c1929b95254265da0f71e20671b679aea52f4ab55b7903ba56bd68f29fd22fee059d8f6ebe5a39d6667ddad3307eeefc128a01531372ba42c53230e4801225cfe1d7331da39b21df42d29a1e43ffb87ae0a58d69bcabaa3e9309fcf4b825ef251c58b3ad72643672ae16b600f1ac34a93a5e6937601e85e7ded8306cc5c774cd11437fbeb0a4bfb8363093c4fc6b03ab291ebc1b27ef4e2016d3249c46e61221e02c1cdbd705b538e7ce9f19f1c4afdbd0b3a95138904184c7fb95f8703a11844bc08463b02c446cf9722a577fe1fb2447c811535cd780083e867a879c0f8c0b804f9900ee68b9c35075c5c7132a21521af1ec0bd0b22772550e7d21511b6f252e0be50837dcea0131a04f1c7cf23213b3930b69df933b335270a3f3e5d449d82533bba99f28c9e8aedc8abea621536500e0f6a3e555e5eb579c084ee86054293453139552e36e234a0f68b263deb53dd2d448c79d87423c59b83ac8fdaaa99c4aaa6ecf98cc27934faff41e03bfb11ba48aba0b4b2af69b47f63b8b1e27e3705f9905477dba810ce2f20c21717767e2469c2ed30deb563e6ffbeeae19926d85955a43a23fba08cfff970965d3cbdf1174e157601d7ac9191ddc09698f72b375654135894a22d80ff70a4a1e04197bcd7ae830d0f96d331aa02682e67e95a11708df70a31a1de8ed388290190a3eecf682b8ba0118f456e115142744f3b39f7f2cdf00619b5121c2c9da005582eb2e196ce35254b0a2c70471825ee5a195454a6dddbf6c2107884f813b2671b9a14d74741362db713e38f014d2210ab08efc677fd31acc526c863ba19dd8b8b1a8855a4dd4601902f09997a767dd7fdcfd896f05d87fcdfcb45c4423e1ce1011e7c40c209409cc0bbec4d42f62789d1a6cb48b8945418b10536bf866ce045d0d98e34d95885152f99e5c159ec231b629e4b553f10c2fa28efa2dbea590b071bae6201a8b18528a17ba7c60d9160f072960c0b3f176347fcf1b93c31c32ed402bcd89733b10809388657199c5ce74aec8e0fab99d1ccec1908a4cec041af1a6684f3243b9f4cecdae5797ecdd6ab1bc4d203cf90e170eb6580f8e64ad1527288a816b9074ddc8f0f3d1e5d83f37f088e2f63798b5dddb862e76d4fbebcd593f1554de781b0c8142f89d008be","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
