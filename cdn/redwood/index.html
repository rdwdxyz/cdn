<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc139cc20e6476401b00a705e3fdf93a8bc3e2a208b3c67af665dc4d75b82d8a02d1912c2602eaa3a1670d0e18c21495b045e7b0aaaf11cec7917fd975850a6e7fcb75e617aef13d10624ef0a3c68d229e5e49547f16d79544c043579c43b093ba30d09c3138c11bb307801aa7089d490ae7a1aea9f52186a03e177bf8fd617b19f3d18768ed8b1fcbe2c0c233c774eb9b2895cfb9adb3957daa56a67c510457bff4e82d1f5376fe4056c9053c6a5ad85c31257b9d39b15f3abcf6e8026c6b0b0595e5c30ad037b8ca49fead37a0ad8ed8c5b3d920b51823d516c74ef1d22b2a9aab1480139e3a36352ba4023690fe478d5d63d24f8acf7efa2a78624e27c81672bd98aba3a54eae75b87611fa11e9fb86669d5aaca1097111ccfaf3626af35582d18b8e12da851f07ffcec57197636b447bf6a4004537e3622dc1cb0209b2ec2dc21d82c4849cc084f3045ec11d339f8b7083e642ece9091210abecd6a6015be2f61cf2d24427a89cf2b7f3ca4a4db568af19cfd17b15b2a5c7115e3c4ef3cb448f8efb8f963335a73ea095afe97f7077da17823ef50a188de3dde18522b7a981a29ea475bdf8947cb06b235b7cd65f2c050e76c08da3d79d7cb5881c817649d9ce354c502a634172c37a45f7d82915ac2ac5ee2d8ed3838382f4330777ad3aed1aedeca68520283259bc3d4c4cc6f24ba92a645d91f9bd359ace17b8b32fb7ab8a058e75d2683914111f9982a5146a1250b45c1a17073f144f4d1e11384746808069284db3fd4b2afbb5b4e3b8348c5a149070e29fcdf748fd5ea9d73a0cac200bfe70620ad18680e78b25954f0f36425c31abecdf36132e7caa66326bf1997d219249d7abec740c91605658af1ef623611ff94ab51435a01a113b779cc8f86fb57812407040b4f3b4ac1d6bbb0f06a65a296476f69af380ff7b53784063bb50e9374daf4f9a5489263c08f936daddb8159a862a0b58e4ff376978ed4d1a71208bc5796b602697c9b91cf1aa3b1f2bbb95faf01c0a49c231c24973874c35efefba479ef554e13692820e0960cfcdb3eebb83491e75692b507778aa17f7e59dd3dad3f7132dfb41b7f64802d8caa75dc074bf13b17f837f7de79b560e8ba9ee43f5de1ab6d83d9f72cf25c405dd48395b8f7e9497c716267b6be4f53dd5dd8ecc16fddd8730cab000e92150651fc7cee1c5364f55c0743b4f1217335d5e51bd5bd9f561fba6e9eec2eb31c6a265e5a5ede72bf4c44fc01f30dc4879c1c58620f214733d3a230701cbc01268e50106a04054a521baa71628a7c36076004e6ff0774d2442775fd808926317bec533d67368265256aad682365bbe5487341c82934f9d02381f7e4726792a78a8ff12e055992ea7bac36057ceb01647ed2cbf877aa4e54f2cbefc8dadad54cf3d9001c6ef2a4fcb624fb4c04efb74c1ce715c69714e7348b565545b73a58c52bbf5bcc41bf7575fd5616831dcca401adf02f08b0b01af7357d5ddffcc5db8cacc8639ad0d61984916f18dd4a1b0c4acf20e70c3fea50d04f9f509a059cabd4d6f74927ba7e369af9430c182b546eaf411bf2bf0c92a560cd1e73259fe6ac0c0b22487b1db3c2ae6163153b163e2da85470b7ef062d4d51359cb1ca383f1cfffb49b41c033a4c73ca86c9f82cee0d8ba74ddbbf8880e2565d28c21e19bd33351e0ec994835a4ebf57bc903052659608c78a791e385e928a6664889c2929dae972da5e52f9dc8c9b8166f687dda7d3455d9af9f4c76c0476ca213f8b2de73533d1e7611364357b38c488bca5d4446468d1c7f58032632f64c3f6d6787458c658a07b9442ff547e4ae2e5436dbb11eb107a97a5b2ffdc339ca5a235bff11336fcd4247b48f6c46c952006bb0a0acd79bc43992c0414d326dc2f6bdbec67fc0a67c2f5a4cb6f96975cbef77223a8aa83302f03294009ac82316ceef9a84afd2319b1834801c470e05d3b6ff2ee1944613da1e12f7d0cd16491dee8afb27ebff9533a21ee3555cc165627fc0efa9ee46ea1b8c67eeabfa7da1ce15baadfdfd187aabdcd68941551dda259b90c9505323054a35b4fa6659af41c710bf121467508a0db0eead65d290d4553c1ff6b4debc86cfaf26e6ae98e9515b932165c71465936c7d14aa081de81a5722f88ebb0b3b26726375d9d9b34a2b322c520990a8d57bf919dc3e88def3098af47bea6df9b7210926c7826e629e2eed3af58adb447a21df947f2b8bd948d428bdce84200640b6abfbd45846df139516208fd2caa0abfddec48df09436ead5a0d9bc6f95fc979424b615797bd8b6e50c1f890769f30dffaf10b8a2813734d9f3fb73c15e57f954000cefed70f82b54e81e265cf355ea025e3738591322d0494aebe7b9e8387a4d978f36d0258d98a00cf195a8e00b8dea04662f2bc90037ca7771eed3f072af4193cabcf85107dee64dfbc9be83776d7f20c07a93284598b2b3133fb6b3a9daad7934b12b60576666d8a01f8ae127d244390008d9df7c7b443a78b593ac18cf14328b74b7730f5f6f3e5119e8a03d2fa1a750c4498a2d75260bdd2f4523f2f99c972a4f24456248902259d0b4b1e22c4d70be8247ab4ae6284f72519b312ccc7932ef0b3bdbbd77be46e75c6b49c866b3eb03c6ed29abdd0fec9386d8e0a17035c63eaf88de8db99fe8f18eae3eadace70195484b47d05f1e4b078a606d79162e545c87ddf2b6420595090918a5da16908bceec978e5ba294ba3af6436036126c1bafe78e5f631aa2f265a0a8062e78e2ebe4853cc89a3159dfe30662f250a421f3c3f7455d2ac77b63b380b5aa383cdf3ce3ab126f6db1f162197f495a3c21a10ac3c9fafe4eac6258af9008f3f195e129fadc915e02b73dc9a7edbfadee4329dbe8d4dc6ef4248c538d383f1112a00bcc2c9c850e24796e082eb88eeea24a818b4f0f5f9e98c9c7ecfa8c1f3dbb30008dabc0a6943806dab4d361a6394d30c7315c0dbbbeda08c44e683ecfc1c445c391e438da3d6dbffac73f889f81687073c1c01105d4da747dd44f1571ea36f068d288169227625e6d312c6967817984c03eb1ac4e9dcf64f8b5145b24a3c6162b011667cafaa9ea2bf2aedadbdbffc5e99bb1ab6ce96de7bd5c638507bf1679e9a868e1672447e17e06bf861ac14836536050352f653bbba35f07b088b55be3d9aa4b1e8e91ce7ffa2f2aa3df3b31610e30f16c434c7eb302fa27fa05728f26528f4815185012f33d615f818c53b22df6a62da00b3b4c5f5ed33153e3c8955acbdee540abe4e2e2910b1b53ff4afbaba130d4944d041be5417e44ffafddb1830af0507467af6d0d55c8c15bea9f49f662ed5b0b3ed7c69741a33f40a1bdf0a95a604d0d132fcd949589f84c4016e8fab88e47a223efc77b076382d81b88933461245abd9c60073e95ce49c0a0ae2161c04d5cd76cbcb83470aba5f3f155b1eee862917fe475536edafb80570223673264034bfcaadc58745234ced399e6182941a3474b978d163ef7e9e38fa44fb09c86ef753de0864d5e5704aed08fda569e782fcc97bee25cd3c0a33db50f91262340c74b8074e9bd9916ee28819c9ec0d044b9fc639ee00c0d373a44f2d3f46cb258a35bbc5c5f627cceeb30982c737aaa7f60c7e8e7c218339114ec8523cfa2a6c92c25c3bacb6b6a794d050eeec53707014218da6379803f9525988a34eeac881792e96d8596af7112ac76be30b07e1feea77786eb08a78058387ebd0e86e4d491661a131713474d12241fb28fe0ad51592a94c89ba80f14f89cd26f458b391eded1d7b8464f48f38054861fa54fb08e0ebaaf4ca906de38f0a093a8fda1c657d55d140c6e94588012b49c5f90704b48610a149ac43da7db3d315e413946b723d0cd703884e9e51643565c0aa9aad14eafac50ca54da604120ccb05c2da1e785bcc61f34e66775eddfe9577e345d9e142ab6e88297f443798ca79353aeffa78289e5c8c11e4cc214939dedc7f59169d93b67c076a42dad9a2900bede811d235c6aeaf69f058d4c29ab0d5508b13468cf4ae0b2576c856604ef67add4d6a53fe4c1993154957e82c000571e52f08dc288d846feb12539ffd099c9504813c9d30d56d33a4689517e781976c97a1ea0365316620ba8cc086a23e2fd67c958b9450fcb8264d2a8169feb566b8fc43683d3b975e4b01af9e8867d21d0617fa63794ae649db98d628377baa5555cba7e8af0121ff114dedfa5560787649cd05a5388f2c829789cec7c2abda8a4f0f48c0524581481b7c894b7f1e5268182f074892fe0e8e18a6e88c5d743e87ce99bff3252c06f06af31460192e4b17d5be29a0dd6c6758822cbc740ec06a3816978c2d5a548a93896c27d7125e1f91edc6a38c0f0541383bbc6c5c68f28377d45e8f5bae7724b76269f1d1681226bb2127180ca73ee1c99c2c44790cf9856f621a88aa7765c26140f88c57d8633d2828490c7222c15f7f964ad0a67f9ff2b95d6e9bfdfcf0137bc95f4a90ca76dd27d859d1306dae3ab399c7abed7c97c47d74f0875340c1918576e7b75b4b443fb780ed83e066cbd7c85981bd7adfc3f369b587892a96627f4ce839b5ff0d594448073553f6b82a8f0ba0bd9fed9aa394f9355eebb58cf51496743af900ab0dd0372f61afd79f2d9d40c969b3cf3ae8f2ae661701dd9cc0ec6394ca5d59402786332b3c9db2d024d354a138421609d359a063559350794d66f0146ac82967c18044f009cfc679d6d77cd9d92cc6630d39888013a4d853976016282ebcd8dd5c0fd2e25ca9e9a22801f992af7dbeacb3b216ce3e6f406a9da6715b1dcc2c240c9ca3b13b0d0fbf0139f4420b3ef9f175e786e8d4b3a582334f5287a6e25f52c59da22da8117f07c59a78aa95c2b79395187939533f1b8da393616d058dad2b7a8e0946ac40339759611d5cf8c6ebe20422611eff1ef1c9e6ed2b9479af59fd17e9098f00a9a5cb082c85666b8eeae08f1549dc6b858ff5d4020c375b56578cba65a4dbe809702f28fd0f0a2c58932835dae8ad98c0b9f6c7a70db9bcddfd86bcced064fed73e3105c442841fcaec1c6adb08f399e39e003cbf7f678bf51fb2113be17905dc4f74081bce1fafaf4fe38f0d13ac97486f1cbd4afa2314d5047281ff5137b21a14fdc4671cdb4ac7b687c462ac644c0019261516d5594d8c6edd6760276cfe1d5abb4b7e6507084d07f85f31e55b46e1bedf1a170c0d333f570e18495b762c145b09a6685a9eb2a0b50c0640dd7965b3acfcf52b9c5c0bef6134d7ff4ee403a15240a850ea9ebb721c99ca74dff34c5c650385bfc4002384002a9858d261fd8498b7463708ae49f3673d020e086f8d04fb740b434d5a5677df124f194cbf466695506a15a9f33055bd9a41e57c15126f620151c4cb3ce3e808e0f7988ac0139314eaf430362803a90d48d47121b8fd8f866b1c63a4068828f8e1c51d565ed964bf2bcd347e544c95e79fc299eaa0b2e4a6813ef92428ea0dcfab8a4c47da7366c71d4b22e486be7363ad72aad17ba9b3f75fec3cf7180f2839cebcd7cdfe7fefe7505811b84565c4d56ca3c8b9dc8327107dccaaec405674901ab6b35c4f06f9872dc0be95dea312572dfae728c863808a1751f8e9432a669c2efe19521e5c0582e3bc82a0f660d3845282476d02d20b3abe57ba7138ec97d2dd2911f6a084232540e60b573949fbb7314801169f70c9e5545fc093530aca05657157421c9d708bccda32f1f5a6158c7f6d1fac4953d4740038441ffe76710723054b94d599a7956b7b06b2ab145537a2f95895f5abbe3219b5c5e4bbdc3cbef674517d6a58637ad2b47f1bfbb879b1a56733f1b9ad8786ff591547c72c5d6c6da9de240dd713c50bc46f85f21807b8caf3d1dd4013cd622117cbf817ff9a1d9df9fd6d775aff5db9b38928731d71c5de9369902d0b45acb17ef6e1e60f088285a84ab45f8c2a757114d5fb5230c241e45f6f7e19762e067f30c6fd71dce3d34b329a1a6f6deb31b6175024f3dc983b11360474f0f6712d86efeb34f357028cc6386f51c899b22116e8fdc52f69e18a6e7162bb80c5b36081f77ee544f0fa3d36a3d376a924a99f5ee0d347b17f6eafdd637595f1b5ca2371e9f04459106c5fb4c5620074ffe6ebfdd240169139ccd773f394b9af326334d5c619b987daf02f915c0aba9e9ca52def07ebde27e6592db67da4a294861c7055aebc1b1c9bc4d7f4c0736abc6a9e3fa735f59808ab35787cd235e6371c0a540bb56fe430154476a619979cbef2de799ec1bddca88379da31bb38ee7dc5871c397f88124b711640020aa26b31d884443be002cf1e61379d00e5be925359537f6d785d9d8a0671dc97c017fe76a8929a9c6e94627773a9c701809ab41b13b05eac83836bb93211abed00aa626cbafca19f06143ebd8f91c1534a0e28bf02a94999c360ee7e0613b3ae3c526c07cbe15d796d3d17b127ff59f4f0038b6eeb81fe7f3e63c77b26c26c0ac247279760afd90fa058d60b30cb85fa9518fc975b3a75aed5b12fdd7780de5cdbfefbb7641baacf5098ca284c80d49c191ce93dd91e674942e3e0e02986f61df8add44fd7b978b151cc7157fc0aadeb5445ee77f7451c1eeb15abf88ed2ce0f2ba247a4493944607ededa1f50c9c61b96e1680bb496b4a98883d600c1b67e7835c63a4e0279cb75c0b50768ee4df7d8915cdbcea3405e2269993dca18fc389ed933a9c7923b9c67894c0eb2a070a91722c329c868d5f5dbbf84a1cafcf29987e69f6245add1009b1f55c48aa3b74561c0c4569d06c055a7cf14e6a384e2576a79655dc05185bcf2c640b5331411ffd546080cf1c518aadfe7431f105e85f8514e248e97220ebaf74c8afb52bf474319cb08b497ae85e82b6addfe95fbe10e06a518578b419b1f0ba73b626a5cee442691550b753238576aa702b12ab6a0f34208f0c567786468a1d0631260b9e1c2390e05a25971867f2eace612d5f746440af51f1737e3d1efbc9cfac71535070cd9ea87fbf6709befe72fe6bab2a7799d0a535c59e97e526ced5ee76789165bd5240c156c202c63632c018d41a719b4fa79c56df03307200775480fcc6138e9bf0b1ba77e2d57845d03733b01f0b56f641c94f8aa5ce2b6da6be15377bfc52c0199cd856dcff7630d517f8180775c81ac8868b4a350dc4fa1503976fe042a99fb90a3fec6c63c1ddba1ba96490de214573a910743872f6ff1ed2e2122b793593586bc9be25c2ca96bb34f20405683c2fdfb0b5de9dd64d1dac1ea9136c2f1da39295e9a41e4d1a1bd22fbf6015788c9aebd693592df44634e3f8fda172c4788e6acc3134425072aea20419bff7abce952d7fb79397c6323b65fa59728b6c44e51ca51e1631bc3f6afd846ceab5f857a692a3cb359659fcaca61bf7e55638546182799fa848e2226af45c1f55b7c7b98841e89dc9892834341320339886cd0327299c536c85e0a77522f4dcddda50754853380b0029507b96b4a4e5f0588007d23509b33b9a08a0d0d0424c86e5ea38a4d4b09f3b4123ccb4ced6f169baa2f46915c9dc0a20f29fb6cc8cc43eea6389d413bfbd6eb372efe86832107aa416ac00176a1d7932d1ecbd7b1f3d54738101917f3c30f2c8f4018ba33554f3b9f0d27ea43c70ff5970057ada9ad9d462bade154150e9f7887ba739dcd36e51c50717b43461515a2878becd6e2f8b8bf0e0579b3ac1813a7f9f12bcc3ad818b8c64d7caba6bb2f9b15a6269023c3ace79648b18c9fd83fc3c252a281041ec0fea109d8b0ea31439362412f8d9cc2fc32a147740169dba1f8b904ae7090dfe9c4e581f50e8cf2f18a301314d3c1a4ee5440bb208133a5065a67b287e916e283d6bf079380e9c4c01a88853164e2cef247d682e231d2384385a4ed82f93523bc518ca0d259c0bcde96494d884105c6413fd236fdc87496481daad559ccd9a6de0a67c463c81ef97bddd876645cb6588324619cf19c36470265d34b25fda25d69e38ca0dbb1a7e7e8e167d6e2190f8429f08bbc91bcaf4cbb8d7a4ae686f7db20dc9d870d19faacf30af87a0c2538ed276a94065709145e3c36c30294fc6b3286614c606ec936081e2d541c608e577eb36ad8d4c9c365bd897754b2ad1afff683658465f6b51d8c14e57f10991170b093d07c55d3839a1f42788374fa753ef6f3c2a915fafbd85786588e2d8b916bdb12502f4bc21d26da7e7e7b482c9b7ad517438b8ebcd90fd09fc7b23798be80056f65713d40ec92a5e3390f369372ac28d4c44fd1c8e5b8acae453436ad8b7a47156238fa044fb0d9f0c80ab5f89385272247c6d90a28b0d46c56b2e0073c20c109b87bc766a6888fea7222e5076d442d677715cdff2c1179db211c7f881d9d109b0ffca30cc440464fbc6d0948f446e4859b5db7bf129120380662e6842115930b97a3c6e882f8ee28e57d7f1227ca3e7c4df6e464faac6c62366e49f2030679dbf98f0f4076bf24684af8b620c47e11d9946cfb457d877cbf14746bd302eb70581429ae97253ef16e73856fc23826a4665a7d654ae779abda317bbcc0589ba0b7d5b874aaf385c74a1dd442b529922cf5d0268e16e6932efd7971bbad9c14beae206cb436e60b2c15586ed4a23b5ed339ee2c8818d1cc2425e8b74537d98464ab385b5c87b33ff0f18a63c99fc0d63c3c7bb761b5579d3b021085098d9d3bccbf933a7f8df9a0137b24c6ecd195a2cc4a82fa4740cdb8ac403612b17edc496fffa2f7bd96b54a51c21e97e2714b164e1ea5a586613f3737e0bb6252945573e539089ab03de4324fd8899a7f8bc16a0e6eec220685275b0666a659fc9b94512352a18f7bcd2572762cf0ca241922b2d168b82d1e504ac4892920321a043bec6d8ff74511b4b0df51bcc0ea6d729222a546b2794793b81b8f6542d829b1ef2bc6ace6f8e51a908affd9b71dbcc379234b975cc079068e75d59c07099f638b7ce6631b3370022506e0d9e2d5ea4d4c19bb6793ad88f8134fa918d81d6d4856d4e7ac5b1d70ccc14bf6b66d4f1a71fcb20f48a34cd8a7f695aa9cfce09289a66d78df651c9fc0952417cc2f54ba5fa2c0d411a40d661e60ebd1f0f6b328112acc5fb4b718b6f733ca8c6dce34bea3716242937a6f27c6a2bab310dbb6d40c7b8d7a8cfc1baa275a80061a27ac256369955d404226bc2f074f2468e82891671dbabf768aa709bb9627a9e02361ba65e5d21c87db3987c68fd91e8897c954fafa1509ebab0da9b253a6186cde5857fe75c884d34f57beb4cd3b3da4da308e4c2b66ad02569ffb9a20905caaf8cfce53f447cb0b0a623178057ad67530d1cd9b13ceafa667e97c0786abbf79333ebd5fd0b68b8350be5eaf3ac3cce6707abbb2cf66fe775376de372aafaf4a19b58c57f96bd04d0b8dd299c6ef582dd38426460267140bf0d837472a92560871052fd269ebc1cbe0ca80deebf1acab53f0892483f801e04e48130c590f8f55fec395055b83dce772a951a4513d4354507e223b8a3673f5f680b72abbea7d90069e42ed100acfb4847a466fdc0a9d8c5371027c0780520c01ef22ee9b0d75adaa92e7236a14a74aa95dce4d83e3bcded64bdbe9b5603d9b9822bcd4a2a863c04bb79d48f5d98359db8f29842468a32dc2fb436ddbe05fcd90241f782372492cc75cc29caf4391287f45de06ad8456da5234392aff02fff1bc9433cb0b607e359508f2fa9e4a31010c7ed60f670b74b67cec2e9878978c2af3fff720e00c08c541ac664936fb82be6c4d9063df83fe0a7fd8e2734a3f989247daf7d4ed85c864b531ecd73c806e0809f215970ae017b41614fdab041cb3bd137862fe57bbc08135f7af680f44f8f419893fd702aa69898347ec19cb623146c47c41bb48a45ee984ff1c04f5f6a6c6c9be4fb5ec77c54fb9859a4628788aa04048b056f22a16dc89f8438e6db2c0058f2d747cae27d3088ff6272719c09471766950f7310271d749192bc06fa81aa6da14a31b2c0d44aff4d6901f8ed9a2f7aeab27c2aeea9fb39a7c14acb8cbf685127cdd892ecf78dac9a33f03956e862f31130b2adf0430334f9b534cc388e778a343088dffb8a926bda507694255f9b8fb58e7c45bcf7701557e857ef9ca6da5d62fe8edf7a537d0a1022a4465189ce3f7dbe34939639cdcae7f2270b782cecbd9b924bde7d5cca03f9c72ace625614b247696dc39fcb2021684ded06633bc7fbf5756c9554ea556cd5053ce81ed1423ebcbe9009d63255c5a051748b06afd9b9082a124d6b96c1afbde6ea1e44f9cf2d4dfeae5c5b44328c1e71280f687aae5344c16203c8646e7f09d8041dd0826e7e0aa485b665a27739c028a64a2304e673ab4290d1908d8239218f0167e10e150e363a884d9f277321e857d83262e58a42f1dee2f625fc1ca1db4d545ddd6d61e9c1daca84ebdf55d0057d7a32d1641c639ecf4f56ebf9c551add4a2b665a4091142b281dc85841e8100deac3658eb2cfb173fe009e67282f2fcd4fdddb5872b945f2c2886a4da342d898212be3bd4799f5d510908724a21f57ba48e33552f113b3fb0fe7c448c863cc7a06f4cb3b79e7196ae351492f880121413f49101b3f02e7ab7f9337719a70838afdccf257a90a85ca6c0fbcc62338cd898a995a7a3cb87a9b9ae09712c90e24ac18c08b6e1c8c19b8902c434961bb607cc5fcfc3368037ae88c610ff5936d2edc9e39b33e7da9ecab57bc5c2611976d1dc022435c49e51aa3bd8006be866dd00a05efabac9d54d3085cdc3637a8c48fa5957166233e24fde2d4bdb57b46e39b12ae406bedf6ce5796eb8fca47fa82b60a0efca3a0f966f6462c1e3164da3af8e61235c3462a66a3aa3b6ccaa8a0daa63e7c6915cdfc3b7635e8a1700fd710d70d229f9ada54d543606ada2663101abec739c33efca9391c6832148916b94f3c2e1227b64f9001dcbce612af31b4c1b508d74935264bc7abccbc17e8e19cd736846abc64e48b8fc8b694eb96d05b8dacf292630688de29a486ea204f219d284eea9b95d293b53d1c08ea309020787b20a008182ecaa7abe0e26301f31e90d2826bbcf1d7901e051abc5c9f6b618d442298734334a075a07d564d5a4f1ec40605bb607911f1b9ae8e462c6f3650481a9eecf8ab702b24e3643213effc661f7d830acf9e2168402075d18de05e9adfc39e227765ba49a58a04caed5428860fa5303785a678137a5afaddae7fb64a283306e4dca74d423a31e1a87a77e5c6b897d71615c129cb1a9a2709020e79811c7a9071624d7dd76a9cc88313d2fb625b02c2418fcbed83a05ae11cd01cf617fc46d68a1d64d677bd7c9627a44afcae0828fd1ef0fb04f9faeacc87e97fc346ad2fa61a06a140378d6a844daa6c121468182bc8bcb635ebd322e5d5534bdb3e65b1f78bc96e1fda9dec1177c73737e3b2b28f41854836886adb04f6ac64bf9b38ecc65fb2d95f0a4d18e5e5de626bede12bc4727033e17484c7141a23dc519a0dc5e3bb6740e8f0459831b75dd195eaf6ac78003ce60865ea751c80c1ab0fef608703ee600502791ace2de61ed6a3ea687146259414d2c144dc5e87ecd95bb1ea21a3bc7616fe1c55df0df32c1e597de5ffe9d32dc3d61c4a47e823e093844d988f2fc5c27d1b6e1194312d03a29edccbb9fd03bdd4460c67876351ac02c4a1dd8dde411c1535c8de8a5a6e9640fa0cae3d4378bb0de0fc8a2cb7f9e963e8fded8c73076dd85b8cc9e9b8cb4912e7928d2a8bf4af1cf834f5ecc427b7c4530b8419a105a33378f6060fec23efa32a609427ecdf738e126234fbe4c17f7794b98789ecf4300269823da9fcf424611c5010fc4f2f994345ac5b3e741b5a8f37b257e08a2a61acdd24b371888a1d7aa8fa27d06ff18f11884d8d35b20f487c9d800a1ebb42b68b2507f7d87ff52d337a69d2e9ff41210b83a4c39afbf4941a35033109bbdd2f02175bd1a9f5ec4b0282abda54c3acd598cda521ec0fdac10ab82797698cac202c0424eca381e44c64b1774cddd18d95108988f75fc65cc1d00209915eccc612493f516d71a5ff16b02815de081416e1cb57403f1adeef22bf0e03f28590956de8fe11284b3a716bcb17d951b4d8752beb6c59fd41c6f2b9b1aa1839d6e200965f07bef014330d96cacecb6a6308e0d4ebe071099b26c3480326763cb5b73a1203971e88e37bfabe348eba9c573fb8312560dd4bc3043af16e68a2c187c473a96eeb3cd8a9b0e93cf3cc35b5b89b137cf34415134786f46cc5c0782e6f10c12d1de14cbfc089e8d6f285552d6ad41bd04cc78a5351da43381160e2f91fe0dd32a88a7b6eee945d13dc9c81df41ca9cf54aee8a3010d90c9531570b503d9238038d9255c6ac4b4872d4b86eecf99ae52340978492d3ab7bde616cc060cdeec66fcf2ac8e15efe3bd7aeb4211af26fb6d7a116e10979fb4ee03378a3cc7f97ef860141c3918fbae1750a6556a0844e26529a0687f6a4d2b2e6a89dc00056fbebaccb1b0d5fff62dafedb3daf3457f812d596932059ba77acdee1d7da90fbf89f16302632fcd9f67a323619956644b02437abee0b757aab9a51c0797564f6708703cdfc6bd4e13c0b3efe2885d6578cded211ca95433a8e6183d02eeaaacc11d6ccdb5e22526ab4e79ebb1fb182a2a731dee3a5b4bb20864b2fd984b3248a0d86723d56301f52f52a5b79e4d9c47e4fd39aa2d55cd5708afdf1e4b204ccf8dec9012780485b69723c9f578038d94a467cc2b7328bec74cdc36120e703a111d4cecb55245f677d1b2d0acf1a1832f673384e5865683b18c1dfc1562fb5a93132ea326c758b193c20840081f309d228d1feb7655f3b58ef8cd8f75b908aedf5dcb9e9df03028a33d91d4b37848842e264be2da6f697bb222210e2a121f63dd14387752719b575c672ee748c3b79e5b5f13d93209d4af4a047330ef00480e66bd62eadcb88d1c33a52644133b85c3a4284feb4d9831eb5ba6bde4b40e0249e60cb846a52057688e639b34aae444cd10b7278693e8e5dde18f99b2bfd439098e95cd6a7409040c42a5a987bac743a7c129eb01346ebeab220b949a175771f7c361395bf4111b9139845f83b992e6883b4c318f7b71020e61890b084eb539a37f32ff24015112fa6c9a2224f790b0ddef828bd6e7e2a7a5f45dd0fbd036e1b576a16fdfc8e60b03cc2d79ebeb8a0b72550eddc678fa5376b2d5603af11d5acd53c2e352be0bdeafda2f943dd5e1bf5504e19b83141e4c7ab112810d5f984ed3b81f581709f7dd5f600c6da52e0199a51028a4431fd3d426d6306c56804254c169cae8605b6614283cacd113c3e51ea6c5631b2dc0cb102199680ffd539fb716d155a0ab7189cbc7c01665c3f5038362c48116804905ba6300126607b7e36cf2fccbf311a2fcfd0719907e88768b9f04df1ffc33ef4430b4dd6acd3183a1129bb58ee598e3c1d97fdbdc3ad9200e20b5515acbcca43a785063e4adb899f79cdbc678b897e5a0b3efd3e2df61b18c427cb8276be2411570c6493a2ca34c6dc499ef852779aaffff5eb67eb73c61c2d21ff87acc63777048f8e5e64fd6e2cb67f2b4feec871305915c9ee1d3349df3081e601cce6d7f54dc9481b9d3171ac72825817c219f596573d1226e95a40e7e0196b4c1a12eab93132f86d2e5f63c4edb3019cfd51d5f15081fbb274fc86e555bbc32399cbd01a5b00f58279b2b1b451babfaae3628c25343c6664306da229a71319c08bc868eaa3345fe607952e24dd1c8c1a06e6aae8484d025ef9a20d724fe0d8e2ed863e308311baff82fe9e9f1a5b1329ad83c3a886e5ebba56b7987fb0a0fa2c8116f9855472f565483679e745de821b90d2a32f0d35ff1148734f8488b0980c79f739518185f56864a0b95b91f878e8db1c8a426c72f979d518b16a39ed441ac2a12e75178e86730329e6dfec1d4d2d864e51a2d9a0d27c7bc48d4f131282fdba7a8b20b8609c853a65ee4ebf90bc9fb4f5351c3651947f06373ce7960f25ffc03b1f9526f4f555676767d2d841c0707ab0f1791fb368161f4db515de2b385c2f4cb71080d68dad255ffb5b5663726f681be7f446be0f2c15418d9f388b2dddc27781dcc2a3cc211abf0227389172763b8996b614c724c09ca536c2bb0bc488d547cf49b28e0aa30101a290d1d7d26624799b0a8264b87ed39848130f42d25a2655d4850829cf7145713d5629b0011920e09e33adebcf092f53978edef206041a7138927675c1ce08ccaf30b86516b59d2ea0d0cb7692063df76c9211a2419f75d4d594c9f6671055a593852b60df39d6a9aa5e18fc208806f8cfef6244fb50a121f4f0ca95b1880d83a0a9fd2baf90ec62c01d781b6de2f468f99a628d4f55e31485e7d30b9ffd7628745f361e9bc91f8ecd58aa1f0f1c6852d5b65dfe9a340ec13a7ab532c7dba453b6186204449ae5247dde91c2678f07d9011917a04ab18c6a279802ba37feaa1b2b433e5c4a76520f9e63e5459406ec06581ae32b5cb764cf0197e3cd5b668a59545e134524fd5d008b9fab881a6835fb9192146a059833328d8e7147cbd7e18e80940cc4baf979ab4f8a4f2f67c97c8cd3527f214dd9030cabace95781346e53cae662cb79733b1f07d048a386d1bd18357dbadca7a69e60e531e6070a5a27da6c9bc6d015f99ea1a0f3ac80827f20f35bbde0df1933ba2998c477d238da51a358725e0cf125f3e580899fef919e9604387e94eb62c34d4dea30f38f9d0d93cffe49c1ec1a0a25ac4b92b1664947bf01b65479b13d9642945c0d6412554db5eb14fbd79851a4e87f8ac6c53eb376d7f802a40194b333a07b150df67d585be4181ca5f441c83f5ab4229a079633d46e3366567114633365a2a99fb56d2b356e37cc518532ab7e42bbc6abe1bb7804734c9ec758c60d677d5dc24c35e1846eb874a03d6ca56834c01646f11b3c178a0c7724f0cbd94267ec338f4f034240be88d04fb96a7cf0d553361774f86e786e417d509f32e94090c9f2c441546cf329567ef9978f53940a11032c43d4f98f6400c1b465d35dc29491b12b794aa64bbc39f32839b3ee6aac131468092d021d9c6d1a76414ee5b2499b02d3650ec69dd4e0abd59e80ddaa8bba29be7b48a1d3afcf6819716b2ef9dc567fbe246c5c8854fe6a483dc1e408c4d3d7f68db29673ee26a6f62f90266b3f70230c5fcc78f3819d79f9d4691e19e61a3d8e3047a925e54fe690a6f1cd586192de724c721f9b2357d98a60d32e44a8c505c50c83f7f702afdb5023fd28844e5289dd97d1e26b0ef3c1914e38997e884a2c4b86de2321ec1f4ad5e6506373bfbd1cef70d8442730aa39dacabb01dabf51e678c4bd2c2163dbc63997c3f0ac7788f3b1b05a713baf56ec9c1b929ae2b5be7b4eae1562b1c69f8bd95cf59234788cd370a600c8f3f104639eff7f2a383fbd50fa3901b2b72b85f98300902301459d5164e4bb7587c27f831a6a2a4337aa2a65f339caa3350ab2e1f5fcf3334accbd0d6f690efd83bb4f702f604f01887fa5a71ab41661b78e71fd302497bc4597f78dcb45c450ad29e8ca95da0c169929612d40d41640b62ecc4d7cbd4334f0306a3c245d6b6184399cf2ba9a428cadd6040ae68269e49a59550cb5295137dc8452c617728ae3f11a287206684fb9cd7d21758dc9441d44783e1de0ebcb70b589e54767643c9c4d30898a417fbaa8711d71d785f17e5b26b8fbd0a088e07e83be8e5350633a2439d0c56a82e48876412a35ece324f500d36102b4283e7e51ce891dab773f11e8a58afca7471869d0d1a3c439a19660b710f22bedad8008df48d46d96bffe23871bb546269d69a1bf04bcde32c2d7016730d445f8c0ef379648a77144f98ef27c78abb3482ec204b754e10b7683c39ebd3617473f920138ba765b5b95409ddb281ec0abfb21b8d663f4ae5c87a10e05b30ee212966a367fbb25a2a0dd7036eeb0f7b04e5a70d696443282d22ada9258b61a65f51d427bc67c4b2a37c88f29ba8c3c5e00bcb83474cebd358415d4414be4220ab6811d8e66085b2b52bacefd03f79f8f1ab4bf9b07e82b58c86c60766b9f264f1bbadf6cda962cb8eefda10a227503331ee5ea8043df4848b191a1585769bf1e0acfabf4b16acb5dda3fb477a189fc75acb6fe2273a0e291d99094d6339bdc1e4ae234111c58c742ac7dfa7ffa1d8cd8b243e0156dafdd66c2ae5d7b4a984a04936fd2183b4cbb22ffe96f11afe9ee3bc274b6190e9188aea9a0ef5847da4c64441e9eb9b1248ce228e59f44e793fd3a5c1439ddec405780a02b30c3b049f8c2e59e017711f2f082195c8d8c1c136dedfe006b359568ee0a7ba4403337ae17f2f3aa4a5e1dcbf730b2026945f39733f9199e58287be341b7c421a1f7446926081a84c3adaf2b3b4dcfd1e108cb85a42571564fd2c07a5d3243e3fccabcb283ab356d3cfe05c5fa6c7e895a67b644e9c06cb7790dea53f64683d584172c2926af92e7bcccd7581d37bb9b57b7e72d9f8fdfc379bb5e89b00fb4a30b5a5ee50a0552a2c617f5ae7376403c8d2223c259db4dc215bdbe3b7f57b53630d079c669910e98b40e663ab75a3f8336e99839525416c7f92fb2e78ea7ceb9796132639a33cb38dde3bca3ad383495e766c007ed8a0bf59b58025575caf1a3e97492c016a7f828bb433967baf32af1b10c6caef05134a88b73667a4c6c1dd61897d0bbdc603bf3425f08d5ee9a4ed99d15e6bff28e48e1dc96d5cf806a586c1cae50712d7ab0a8cc1442c2f282839c95e97157668ab4d7a671a6089ffb5291d7beca58953a441e1bc59666f1f8e506f997fcbd5be21c04e0f0a44c32fd5f0ce06383a50ea3e5c99563a647fa75bd645a8f8926e66b42b625f3ee2c3b14a8dfb642294327b348f8ca04345b509dc143e96c277c08231c51299567b859c6ff8e089ca34c06fa23e9884ca7f7de14fa2d674e5d0b51997e00a86192666f873e3e5b2cd22d87260e0c559cfcf318700159ab3e29871997860982c4aff101c0678ac1e14a36eec56e3e2f772b409bf65d19517c7dc4d52b14a56024b772ee3dc5dc887e3bce7689806debc115109d1f80796155bde157b6e7bb1516609c89664aecdf9ba655a408dded9ea70c20ad9bf821347bf00e6f19ae425009d882f60bb69621c0f45d6575954a4cdbbb67be060f4a97d71e66ef20a6b40977b472e3b92a29cd8eb7e21f867a6a308271aa9e78e1583c7f1cf3c81be23982b06279802c2f28ee391a88b23cdb46e7c3d4229f28d687b3c42e673f4e42599eb46fea02f1de432f515ba55b2954e96ed4f2f0726b2bf134c49f5179b32ca7877e1169ad2671b60fb710b82f748f9067cbc6dda84481432213aeae5a0b7a66c8df6f6867bebb9107110895e28ae74fce6daa2134b7613ada0ead38430ea439f6a16042623e055cb65a61f31d8b24756a440a03804b3d3ba563d63344d81a11cf1be1f19f0baeb324c5363f2f039846873c3ca8fb0b10b670d7d27b5763dcfbd2c01dce78c63e74f807fb71601daf139f2d171a923b833f046294cd35402b28ac594888532bdfc474560228fe3d29b89a54c08b61835e2e28658af4822e9bcab1fbfcdee38711069d556b020cf8e70bcbce14399f4591c20788c02315d89b6b86d06e427919ea99b9ed3a54f9cf8449c6cece15f5d07284ca10b44850481d54b6e8ad60f2c3298bf4f416b7288038b917e58125f6500cf3c8b06053b228b37f4b466d9c2e0108455c080b0cd892716055e8dc99c33018f686e7bc5b3e087c56609b657553934c94c0dd11b45e9b6b4d4389bd09ed5130576bf62446c46ecf77397e79aa1b4391bd04175293956a715ca85f13677e6ee014eedc504c0437b677da342ba00584ab3248b06a731ac75fd2bf56a3b132b561636c5e196d1702328890f9daa6f430da3f133b080b3a949cecb9cd5a69ffdf04e6d63fe3e31e812de8c3b438aeef5305406253ce5d58967d33ca4f83f0a0c4e25b48a65317e4ef3ef4e35d7f71f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
