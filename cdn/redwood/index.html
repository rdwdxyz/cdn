<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"14e38b2ee2ed0369073a5f323ce54b1827601be26b903b68ac028a908914acad5b289f6f0ad8dbe27d3903c758bc1d751284a246f6a65c8ffbc596d799aa50b1e9a85e8b1eda796d3d54993b1776e0c0b63878274cd64297abd67dcf423d9eb9edc62a24bd9573f8363485568e4a1b5a16f9cf1642ecb07fcd12e5004be999f543c8dbabaf69cfb68d1503c33f823cd290bbe9b8d1b1e92d02a3807075a9d105ef761d8b7be3f6d02c9be82914949706a1657b5eb0878a7fade9546b5780332f0be58aa8bb00bea6e2799a708a240b003800d34797bb1887c7d898e4074093bfc41f7fae2700f51c8031eae786ceced4d0e3514db39061065694cfa680cde7da6bdc12f14e4a6ae21e478570b4ec6249ee35dd7b9ab1bf19de0b670bfa8284ad9b55645ce8657e86a782b73a9457b3ba73a9b0ea61640638f56a90e73556be2bb4059bb8a9019c371220ccda29766e155c0f3d5dab6245e16b2f1f9ae06dbccbbd39307cec0fc1dd38b8106d0b250044b73cb67b994daecbcd2b3f6b6b46b177786f92b3c2e33b2eefe24a8e18019eac0e945a8f6bad58fe101612baf0122ba51a1a2e9712bf9148f52551db35f18fc10c1c105fecad97c63e9fb5e225517e55dd12f02cd321da2fe674b6f1ade071b644d4b9b5f4a3e41ac77ea815c750fe98e8f589a691ff07dce52802690df6f64bf2323d309a0ab63379765951e2d047920805ae895fd5745da30c5b1113cfeba2349f9cbf7ad3cc553cb4645276bad0235eae77412887b643c3eae7bc6a96217076792862d5d5ca83b457e69cfc6b98181711d88fbbd4df7fa38c4603b77b2cf47fa2fd1cd9855c71d085a45934d0bab1b465ad2ba602ed6694c4a338288825863d005cf3bcbebc7892f7063db32590f55636f0bd147d4d678edbb805cc2f18e4f0a20eb595af4cf7b72a7b477f2963677eccd0c847584f6f71d2f61f3e34576176dcb0b10448a0ad31aed5ce93b6aa40c97de23d8a6cea8ab835920723edda8bec975c1291b8ec33fcb7288c03affb2382b7aa80cfffe5d4c47d32161685bd96dc9e14b60af9b9b2fbcbb744006f03e0a3d9d44ee8ac4b7181951ff860c26a42410c2455e8b8acb95806aed013f30b3070c950eecb7db5ccb2a24921b4cf7597d66b0691e80090fe80889cd38926efdeb8a6abf25fe65a32fe12bae202be63e11e414a6b6e57a0aa839fde44ffb6cff8f1a29be23db99df20f866ffbfd88b98239b822a1383ec464553bc47a7f1f43490553b76aaedf8ea05540ca6a05e5a76d6fb8219c7c03fb90097bb2e3fe3edda4be99ed1ca93dd1716af39d67bc93d1834a09ff07169a2b1cea25ac510e1f3936528718f9edf5412abce8de5cbeb9af3a2b8f814b63f266db215b0a491d0deb29c44ddbcd6f457d0564061a4143604854c9041e5bbf03aa611612cb81854aef88fa7e201d0ba6fdb6bebd93be8118024cbe01fc6b5e7d469abb206fec449f2be9f26e23608c67f79f3106f64fc6b2cc00cebc412fc316bbcca31b2f0d5144dad26293bfde686bb0ab1cf0a78c6d5448808cd653da7871d8abd10aaedb389d95fca1349a88c0cf1c5b0fb07dd7676a871db1faf181ee1f60f742eb7c2635dd6fa21f74f040eb054a08ab31c568e7d4151e9ab366ffafaa87d1aadb03bb78eccc83bc0b15787180e209fb61258ca88731d20109f5e8b7a2139a8d562d48ea48c90c2393419f830856dbac83ef7fba54c083a769ae3bd70b4b763197c07919f1d2614ae60e2ca16d5ddead717d95dd42a7ec636bc59cb36dc0e09cadd88cb99b322166dd82b2367151527b173c8b3c58982f6a9f59a04c79871b089d2037a5680e278c57654b4c463c2a16a84072ac18ac864c5aa6f312eab9a357b0e59f1bad90b0f56f1e9415583d14b38577824317822511150dc2045625ce413315d077dee0e8cba78ec2ee79942a9ce16b0c3493228938d6bb4962c4a8ad5c7d62eaa140d466bd668bf0d87d7d551d5d8272ec53f41e3912ce1d21a269cc96b40e53a39098458dffcaaa2af22d1ab37641f9a67f4cb2112d5ee087853861014368445cbd355aac827a324ccaea68073d7c92069faa9fcfe0e3c059c4d3665d2ecb71a1dab0233438d2be28c8b5eba7896accc46526ce70724446c8b01dca195e5a177007e14b47f43b0a22bcfa986e09fa2fd094820934241a9d140f2363cbf260d8ef6276ff4035cfe31a1f2f72166835b21e7c245f6970d40cbf93d0b74d00c1de69d98b35a82992ba24a862af9d827def8e793e3843f7f7e3c3a288df08c8e949e6529e6ec87baa80117367e026e4191241772b9dcb14c777709f0b40aa76d8a65d8cf37bd8edf1acb864dcb048aa0a439d03c8df9ca3038508424efb8512bd945695e372c0078560f02d34ceed61cf0f11ae2eb44675e8a5671bff738eae654d807d88a5d9a9cce083284be690c944e4f4c47e4c2d08231163fcb280ee5e14138d0b411e5a11e69e6c40f06248368ae0a76f02704cd8ad02d4c4ba199770e7d2da973a8bf4a0d71d5e545e4eeb87958d4ed79bcce2ea9f6ac13028e643179130bcd7c77deb3e4ce2f6e978f5bd2956ffa6080b72d24c1c96f8c2a7b84973b0b4c39b362f54ddb80dedb2a50902a231f9954250929b1f791e6f1b9e98d652b109253259f06396909e74dffdf90b52e47f331976150b9ff7a30765df49025681a9dd433bcb163d23ba58ed290e82d981da45cbc1e7efb0b886a012230a4ae247ed63aacf666604b4fea68321c50ea0b254fe84af0f06c6cc8e8a08ae04dd4fa2d5226cc4b8af6997435bfdb3888bd01999a78e9626ace86f13c87bbeab8a2d7f0688945bce42ddf06f176b2cc8e138975967f1778d4f06e0a76b979d26a81ff7b2c45b0ebd54a4686405c2a270920343917c08288e29444b8a52c335eba0f2697003efdccdaf5b0ea7e752e1a9f710ba0522005b06ef2decea236948d654e6d98112caa261d16c3a663d6fd3d71acc3a0195f15007afe6915e02e4adcc31539915b83d7073502e0a703d5851fd94ae78d9c01f049b830be0e933df00e7705db3ca9eda41173884a58226f5d0eece996a132f6d3ad31d6fb40dd66e40002edbb9a0413333bd2d406534caa7df373b878fefa030b0d55b6a36d6a87475fce7ae94ad1be98205f5bd9a0c845db66d658dfd4d02822d61a23f4c970aac124742fad1df77e343ccc79e087888cae52ad8a4673b9c45ed18c55163eeb290cf5514fdc85a69d4323ed61baf123e534160ad6174560e3f76cef9ea0b18c0ac12e23d502c3f23743b4567b170d6135ebbaaa79b604aeb3e6ed680f6ec03ae9376225000efa798895b68b34251a2f11ed3aa2f7e923eb2e67efb8dd38723e0a03788139b3760099e80828663d442d0eca934cbc51978ad82aafd8b8acc44af0298d945a5901d1f713627fad5368f1fe1d0760c50516a72eeb379642e6a8dd3723e8c398d26de63a0b91b9898e178079eacff3c2b5f2a86a7bf26840c3d05ff665974bb376ee37b2427ff9a09ed9a181f0ab135f849b6aff19a7c3668e6a2ad3d35f680bdd3052036e0e4b6b8fe14fa7235e59fff7351c34037bac343c93c8fbf0a371f0ceb9100162dc724c28e8bb2e10a56645725c1bbbdec1739ee32211d6d58017208c2e15b6bf81dec32994992a3a1a4d70a770d656828f4c3f6321ca20f592f5cfe2da58a09b8585422c75017d666f9967adcae7e0809f60c662ea8e28a0a3a24b19bf3dd21316dceb8beabb30e37e5f11457317bd4787bd62215ba5c36af04c4c256a2d7199e75e1641925f2d700442d253994008c406895b0dc3159286bf5b2aa904fef2900c4617f3f05aeabf8641315ecf6d2cea473864dce08509b705dc462ff8c8515b03cd930829af1cc8d941bacd652d15345511ee546dbed0be062010ed95de87f8f953d94bd84f46edbaaa4532fbd067258a54a25ef1976f7b5a3afbe199805396cbb892570380489f59966721c2149d941a8272a244af940fdf42f6c73944ec0227f2d411670a48d2ec40645d023c7f302e9eaa551eaae8378d38e689b0927655bb9986c177dc951544687b9bf0f17d2d16a8dbfea95276d6f45a013fb499079676cb7123812c2636cae7479e8818d3a3c91542195398dddf67315b34f3e7612cc460a0be92290e14641ae11dc3f3ecf576eb87a5215705fa2f3a72ed366aabda63bb82f656f33bd9c208656cc541edb805d744423bafbda4c8c9a41e306998263e4710c0dd5080a6ad4ded66001ae2c489e89368ad61b5c067ceb813beaaee3b0335322b67f06b3beb6c82dbaf267b81c0c7fb653177d701a69c0036a04c6f17b5d77c0672ac44ed4945cfd0b1534bb4fce5fd938db5752e4cf7097c2b91841be847e14edc04a5c3ff40dc94d503ce7ce4d8e4d94c3013e80b27f3382a7ce1e5c36d7ce7b2bf8900e19ae7cf917410733df0ecc185c62fb3b21a1c65fb21e95d8dd7b6005f362fbb85021633a619865b497080511a90b4b98519c2c864b0e82228464506ad3d844d38c68ecd160855f831a3ad4cd84ce0662f33a47f4556f9451ceda989918a32f14e01c60157e046fda1e60a8c2e086893344312387acff76c97a8b51da47a10c880f5b0b1bd6843064768b39c717da76c0eec37be9a9e38f0def1159dfba962998c81ce06000deec6aa3eea0cb136d48e66875e53006bb4c6dad46021c9413ec52dea3dbe919c4c7c49528a35937b62ad7ee362d93861a8d2cba41d7a7c48ac3c5350c86302445672d6b0f1a5928b1df67311f4ead9adfa7eb1b47d8e8f0ccc09c241c3c6221082613248395c82d10bbb05c78c9aa6c850d5e134d44d4d82ec4f676cba87fe01bb10a1ffb477e302465df73baca53685f16ebcce995a2fda2b9315495cc9be32b85f4f5ee67a47d0d6e328df9dbd4efd268a096d65ea88d38a3006c25230674ef905934e5e500aab43d2b88d678209d3cad490587edd79cfb36f2c527949ba06b40942551a960efbd7c8b4b0fd41f1450ae21a31f9f935b09dac87be5c95f803e5ce308f11cd93d723a1611d86ee7e80b54cef1a9c68067e699be26f0a712deb996c4b38b289efb39d24c03fc75fcfa1de0f180a27248e49a82325a4bec3273f83863d4044b476edb0eae4d07e42ce093032ac31a8117fbe584c28b12d0b1d9890850b98c484271a64f32a7527854e9b7d57211aa46c06a0b3c6351d74eed945883128de0841c94613b88dd0cbdd061f9469ce04e32d23574e44706a25e32c4b1ec71fbdcd8af5d86fd82f1ec93fa5e08e46935853858d583d7c8ed91495d10b0439ef4d84e6538a936421c3e40253190454393d81b7d7cf070112953a1c199727c078796266d3d2e4a9c2be4fe878e7736e1fdd07646208db0ae7803f42f08a50968770a3f8239abf3ec8aafd2bd1946745b292ae31964ec3c9326818301998fb4ecc0d12f205d046ea2a0b9c59c3abe10d1e39fcbba889ca50fc45020cdc1fd913b8ddd6802a42bb93baff5c12897d1e88d1b0798cba458ffebbec7545842d35efd5dd267bec45675ec8e8c2ebc236168853bc20adc8b860081505b44cf2f86bfdeb34d2aed5de0adbd9e35828f4927691ae33f333b9f1d421fb7eb1c26699bf8f6acc7f54661f56a2d2aa7eef93836d0b8bc581135004cfa7913a1d76d62e133ae6558bb5d9c8e98313756694efc5f98f738324ac61188772e18a6c2299b6b9fa673be0f8a332c07af88cda3a3f5a5445fab06babac3d2245cabca6aa505da95cf51fe0975a9c552a0ebe3bd943c747b74f65ed716ab87e334bef0da7cd687c60e1ffb5c01ee922cfb5308385e9137d7c8f4807f4f710288e9290b3f511f2e85b035417d4cd53eed9a341a9419bd8721ec041241660d24c01e9b51876860f7af8793be5515537b332cf9ca6f341a6e3b524379736eea81c7049d806bad214ee7dce5db192d07e2e7f43b7a3c5b6390d78610f92ebc10d605e228cc224b038dc24dd02af3905d2daa7ca26d1f2bdfb5ea7809a4723c9064f6774c10b9687841b691fa15b6b2f227b4ec8ad4055a91a2213396821466e3a36c5c1b06729c6394beb89fad1be950802b254c360f71b4947e96fa905d069f52829a2edb92fcb9851fd1735ae05c8c017e9b19b388824e49f59af4235c5f8e539aecfd50e0e4c5410e3290b30339a2247a4478f5af019dba35464b92cf957eb77713d45c114cdd83c968a8bec5a78624e1cb6725aaeff41929c6aff99570129d16cda08c23533f991f81873b382faa0ca17a75eda730272e326aa3c5701ddc7611e11524055fe05db62eaeb7df2f30e41f4f445878a2ad64e41f30ee22fef3e051263783f360c0ea1c8f1c31334492c479d33f91631c06f7db3ed46b658a937f7d9a854007ff654fbe18ba3ab5fd53488d920f3f5e7e5a3c7a14a67a3840ec00f4621b844e250987d04da8c13d5049d330e0ffc69455b6cc0a310e17f71cbc96a7b59d8a2d1fc036d1135d0eb14db99ccde42b23c620b6969aa416d2f120d7d771b995fe97ea32cd3d434133d1eb4d64ca4e0280362a65093cc7e4783fbfd1322dafecbd80a57605418e7f613b48d6f25744a5f0d76e8216737ddc96b4a7aa3a68200197a1bdce83c09a9b769db386a072a6d8972799dcf1d70b328084ca20f704a515ddbc891e3847d6f0dce37de0fc0f7de517bd906b84b1ce87c7836efb4ce78d6129d75439ad39cdaf595104c83482057e18c4ab47beae5bf8371b1be03dabb084823edfc02c174357d51c2f23ce2dea5f0662cf5640f6f7ade2d8ba9100ffeef5b3264932166003029a4a4379e5eea679327d55ffd76291f6af3c7b70ec30a8397069131da7ea5967a0ad7bb15657e8069480cbcd1db0e1dc4efdf2ae4a7b6a4177733fc5bb38f6fbd2c5adf16f51a0bb7eb5c89202a639770fc4432bc8bbbc60b38c0fdf2905baee338cff58e3221bd323089b779ac9463888907b7b3f2c8ce1e5b888bd8f0a094b39bf26d302177e5468b4aa5a9328ba62b60522cd6f2a72edeb6a6e5d0b9b97c57bd45b0621fb799f0dda8aeeb09e53663df64416143fcf3644fb6accb3812f70383106d19f99136abbbc127c4e78c67bd859c4442e21a9b6344c9cc252997903f8d7ba9362d0018a11c5953da9e639aa5eecb9fe3d3717b54a2186e79b19fbbbf9757e4ad19e622efe0d40a99ddd2d36de5269926b209a978f383c668a171b3fb172c8238f9f65ecf9208193b5cb65a16c7b5c21a8630aa7d682d53173a68685438531c72df483df4353ca9aa00eb24a18c98931426875c46a9f2f206684621e1d91ee9bac8db7f392b13f159e81efc80ff64dff41ba65498838c02b4fd62f317d98fdb70643585f010676202f29390e127c0c321b22226b2f04682454d655f414c4fa36c5bca488fd63636ef942de52fd186f573c21ab517ddbd8d3b55a381b5e6786ede2562b93a52de5b383e973076cca3ec7d7351623d743c5ab4f75cbf0e68ebac5e2ef374f85830de46d650462c593f73173a0fa7c718917cc96d9bb8c3b8a9edad31a448bb2674d15761a5f37117b8f98397f880ce2d3cbcd1bffc35a0e15b9e9c47a6aa7a0a0ad6123f90724ee4107d60c7148026315187c9362ace553e79fddde6e2270375f31a6897e1f529c9f31021ef0c98d061c90b6dad5285ccf256192541982929f5d03d490d83eab34604f22ef78c3bcda5a8f63d921181879dd92793cb13fe0d83d7f53d62cf56be68ef009c0e2edad34aa1be3d31c01584f58aae0bc4f747aa6b539803906fc51ae47f6c94f5da3c850c3f1b4e48b95272b57a6f35c73bd0f318adb9545aa84e90b27acca70ac6d68a27748f993eddc97b0bfc186833859a1c892235ba36bbe19f77a89a48369ca6db8e033aa00a54aa13461e7d0cc89f334ca3bc3f0a61d2208a20209165b2dfc9ec50f1d3cdb44fbddd5ec30a6eb553f04ce52cb13f8989f3b13de9b23908280724eb8939d5897baf6d259216ade0a1e28cb78d459ce5667301408d85fb6988de12806400bbdc53e623c7a590ba9e608368a20c24f4b2c8edd36bf1ba80f8fcc34e7a0ed58c1b46ee4394cff566aa71669536d2ea5d9b224adb5fd45059b3ab9aca9d78ce780c16d6b6b2538b0c79479161e42dcef0c820bcfe46bbc243080ce12f68b1ce9ded5ef0072409d3800f43f398033631b2140a3aa30eed15eb86d73ed61f2e392264ae77df07ad2e1a8f9ca2bebca73e3b7e02b1f47c6ae91fe1c14e9bcbfdc19d2127b4882cf47a5f542d6906d2ef4501a78e8fa045f4c721db278a451846e776b7614aa37d988fbbd0c376454fdfe6b9d367d33bb1947bbcb1cbcaafe9a82117dbcebc9dc830236bd1b413454da1fa48532b5eabd766584f825a3c5b34b28c88e62885c6217990f1f3193c783e20092f422271270d8877da419e676dca2f50e555ded0d199df2bf6bde4f2500dc5ce1d7931c9fe56760ded0cacbac89f5a6e11ce796726a43ef238ddd350cd7e1ddda34899c06f0bd2487102c4546b1071413b4437d1f058bc416a8524292ea14ad55548e5e0eba1cbab8149f382014618272a1576abd12d63776d880e0f3bc5f5c823076ba06e27fda67d1424a91033a966ae31bcdfb80ca16e4f6b95765a891e3e020eb632413c9662a8584a02e3c272b03057aa89da42adc63aa7c74861055cd5f5f094f7418c7c5c355f7960909b4d7b068d8433a99b0c9aa1b2712324584c710bee6431e30ee5a6ba0034d7e3d33f1ed40d208ac583d40bf4bf17d837d8dc643a01da2c1d7a954297e6fffb66689bde044e6a98fdedfba66f61cc43456d7e5c45469a3f2c737212cca6602ecf7918782047c098f45d4b4e29a07ba18d0e421d2b44aae5c3b9a4cc8a66799b834232eb7fc1b119709e073e6e91b6b44ba68b54d9342d3d32a090d92ef0bd459e378e3d70c0747453ddacc3486f6dfcacc71ca24087590c887a5643144f1a76613dcba5c83480b58312463256d94edd94accaec51cf28b1962fd4708e391310f8ca9ec0baa000d960df3be56a26d2f6cddf923c1679b0cf100a84a7ba742037ee51540113f92ecf877cff1b76eac9c5b9ded609fef134342eb4588134a2ac8404a0dda69a7884d05132694ccbb94f6d4e3188260ea7b63c1f941a6926f67bbb1b824ee20ae93c905c44381bae36da19900710b8327521ee002a58a897aa82f8f3a16e5f8081020515a14c1ca4b4ac0e9607d6b82668798d4eea8550654c50661fc49c8588141fd345d05f80b0853b147d10a2efa0c04758d62c17f7698708588294fedf97da1ffa07e9a47ba1fc6decf5b6112cc0ef8f59d91d1adc64e527791f3529b254ba0a4f8eafdbc56a2a8128cb34033794e572c0e93d5d3cf9718db65f7bb243195b05775402448f9cc050f775dc8755a420ad582800ff4213aeacdde853cdbe9c7fe090b41f7fc3694461a6413c982d7e694775188595b35d8867dd90c1194a6ef3e3c40de14ac57e897f709bc5a941ce7ff4d321eeae947776594c304e8e7a751ad49437a43ad75635c583d89c48a1225e0771f8b393be25348a4b972052f7d27b4c9d0b6eaed767d9e65dc5c34d727984e6f8eb45f6d13b5c8fcd3809c7d17c6bab1c7090141c91fab26abb8b91684c5b8fe4af9ef482a30ea9c4aef549892e6bdee914971e08365ba96cf4effc01a085473c9a8526c50d5fe1478496c78a6da3f07746084ed37876728f0f6aa86ce25a981ae780cf8b1b069f774ac6d8cde720a5b61e5efedd6fe5ef11a4a3f1a762173ff9248e122165e205776aab7bda30449708958ff33f706255b546413b1dee3cd3697b1e81ea6256606ec8931373f2761f0a0ec7c26a94644b9153c22a56ec00d990d4d618771342dc92909d168faf76a68f396848de5962772d7ec58f225780c814364b0886324bfc2e76a2ffa59e51878cf77a7d281c659261a629de1595a397ef6238b072b3d7d32c36d7e229df26a6388fd5d40fcf8db18f9eab5a828ab0a003ee40c9f80423a311a2acf8885b24552e52b6dcfb1b855078019b3d4b7b40298fe2580b0826c265983a9a6f730477bdbc20a63f9c7e539370c3aa39751e15d4629621f3c17860ccca104a1663523ddfbbac0d5a251d462788a46f70e8c588d89f10dd8dc282fc3d93762a1a02b7280590e17b293ab4be74e7729a01a716853067f4b58caf2658d615792e18998f3286c7e373da6a7581c1f1da0d5602d50e6ea97515d0fad4adbe6572b70d3aaff9c0cec01fcd377750a4ed411584728063f6db9d77dfdefc1fb42366cb1ec571aa23f96af58842153495168e51c047a7525a31f742f115cea83837062014f61a0c6ae21500e2bdb6e5096f89bcf020af648d6d874adbd6e34d656b829f0fc1fcdbaef7c635ed506464052a719ac75a6e161743edbcafb34bed95d0251fb5a3f2c657e0203ef04027e1a9bfc3295d73e10459c021f51f910aa10b9efbb0cecffd3a077134f88d6996a1edcc8026338beab88aca8cdc33585f42a84f3ca2a34eebcbfe35e7dcdba5bfbd27c612d10e50fc1f9f79e1e304e6b2c129fe2eaa3e8ecd64044a00881c75377e82d1e9885729c95b89c7a202c595a95f9f9b46a65ce666638b8a853847818c40d0a48f140470ef2c9de723fbbd2c20bf1330ad9a476947bdd3ca8af78fdf568535b31e9f25e29c161eed90cb773c8a37c54028de12eccbc2aba927fd2c1ffe385e0df3510b08ae640a677e5964d5a1533d1b7e8c77b7776a4b16832258860108d0559dd129305245c700fe13265d45666a6f7fa2c5fa70b331886c3fc2a129e78518a9e90ee8125ed61e64131e104fac79884392bcf0f2b5f9e8f83121693729670b151b763d498edc3716fe21d75bf12bf4e6158853f946af76d203538e9defec2d8c5f9e6cec22a484b6e53ce4a87059259e1f2366e27c3f9bcf9f9dee1c1642887fea74d9ef8a3637c84d7811502ce6bb7960df478187460f40da7b67c140072bab12ebfbee5d1a3d32ab6ee6859fd6500cbb98b84207f017bd1a172bdd0b969a171e2fc1a7dda805a7cece63e02234eace7b095e6ccb98cec472eb7c83f4396c132ffd19f31fd13e088d50014019ef9c93682690ac8a16cff2f1777ddb571823dbe3a35127046180733e709429ee0d2578b2ceaca5fb4acbbf267f076a5916b6ebed6369c4532e1bf64bf51d02b7288f0660cae45558bd90a1f3eabbc09a55f75ea64bdf9c0cec707c93d1620015f15f8fb2c7317ab121f715010b7b169d389259fc5efae3d7738d9ab27c097621a386fb675a62415bc9ac50b328d357a12345b22ebc4b01e3cfdf49b02da9965260972b3fbbd9f9771195a6932fa64ea5444987099cdea306b5377dec495970c382b482821bbfab73ad59581e447f20f42fd413fdcde4e41584b7be34b7730f177ba59a77ea351021ce517f7f297e49aa118563bc9f83814f55bc08197f4df466a417021b3e705d3740c4ada1284abd4887cc6ae263771b22069df353942b3b220c75015b3d7f53c4f86f4b864caae3dd24e962261a7a397a1f335dc4e8e2a59d9b93e2f884c68f033d53cca4bbfcfa51221dd0dff37f114a92078f79cd47eaed0b10ca1060b527a101a7d423b3cdbe17ef6f6b7bbe9d848035aef6a3e764f596419750357315241607e58d7140df09471996396b521f9bbafcc2b7160a3918139bc87ebc28119804ffc6bacda267ecd895253f8a981967154cff5ee20707a45eafc6653943e64fe5553ad428aff69a8e75e9b0d54e6289c6ac3b31a59f27132f5824da44e3285764752c48aa5c02266d476afa0a17189cf5b8daab8aa771d4ec6112fd567aa0712eae340bfba0a4dd6af4fa547312e268d9837d615a1cdc9c8b08b292d946721e95f3477fc01e925b90f21592709dfc9b97bd008fafbf0bb7187912f5b96d1d1fd64187badf3baba0f7b76ba4c3ed14f05b66d1d3a735d9e339eddaf545aedeea46a364278836ec84cf448cb6f20239b32d412ffc5597097ca3fcd21ab57745b14d959d91747b0b6071cb2802a9a08546b1b31ae7ff2fa0ee168c329b53d26ad79a0dbd01e0e3a525bbfb5872394a5391dad8c887fe8ff1a11519c9ef2c6e9b58aac3b589b4f2572e5e530d1ca59c33818a79a020a964a782235e5e88e7ddaba5b05d0496fd4b25962d19ead5b840b65c1ee96d83d83ed23ab43191acb1e009e2abb397f229cfe989e8600ea4195d6bcaf506e40da3f180452c7008ed14778ce5a05bb51a266370fca5fc7ffff92aaae7e8bf1851cc04a3766f63f963c692e1ae3955f857d7e2c91cf2c5a53f83e30ec487e54c1871a95d4978d3eb1941e47a65b48a7a8f195b822ecaee1b041e8c57eda079395d010fa4efdad2915f4456bd978398904425a0498b92befb5fa25805a1e55e2eda4e50fc8bd0d1000bdbece84cea0301610275305f9c066ba135cb6fdbc97d85fc05d3854fda7d0793a4ef157cfeab3ec4ed555d43ccb454ecce858f2a1ac5900382c2335d9594d804fd291eb33e825bab93d9395aa46925dcc4ade6051c3e96c8984d86eee185dfa55e193dd524df214accb85e21815086d364e0bf8b5783149c6b6efcbb568ebbabb1c26f7880e1fde237624f3909150f4beea142a9fe2520e3a3c04580d304458b8ab3b5902f15a30d421fe9d4df5701a49cd7cda3ab02182cdb75a931be46b60fc13070c7b5a5165de0e0303d5451c568223ab4b50317895c6c8d7e68946843d4cc146dfc708e8de1b126cc768ddc11e1423511f0ae15ca9c2f34c581bd2f5b84247291a773fd5fc2386f5821e8fb41fef3d3947e6f499f373fbf4ba0fa3e1ec16b9a2175787275fb447491ef48ca0b4331b497e03982b6b101609c57335a8009149d00a007fc53b092495e11e0afd429a76e3031ce0b4d56c2110f5a91a2d23e6f8da4f8ce92182099c0ac2e14f6ef3743ffebf97050697ca2be415f44b97dfe15a54205a8bdc859f93ef3e0abe9b64fc6132440088dddec490ca8a2d4a594967de21943a6e3e542eadf5de3a3f3554d135e05aeb61f6ee378b705172c2e63718df0296e5e6f3a44be31b2fc0e80d8ccb84aec530677e9e3d31ec5be38bfd810a11dc66020441760b1851226536ef14adfaef2bf1aeeec7179a326b6c6ef5d81e3c7b2c0385811f88c151ad0f098bd7b54cfc4f6fd30df16097262f9ce12a16376716f17f97d8e0cdf77e652581d404f9e594af3ae326dc81bc3cc3fd5d311bb6ce445af411469fe821a1555551124688f86c8b94b885c408493eb09daabcee3f17da1d0e296d9d1f6be0087bdf30259d8efae5af17eb40d37af3213da771e752ef9b5c758bfe97c9e30b79c889447a5476a2cc291253e700df6df9c57e9ee63ddc1be254e36df440087fc6fce19ebb7e37a82e6bde8a5f843aeca81b9b144f694e1d235f9fe982c181c586a82a49c9d5c5a320e823b79160b9b680fc6fb1ccebc38724f4d1bab0a8d8ec31b1ff8e8d65064086d49d8468a0c3e734b6351971589bd26823e4516707bd19cac0fe7f600829f6f21f4448584b9a082e9507f0f0df1636e104299178e6e632ba9b9ba2deb837ac6752cbf968d2d1ebd80c05b78de1f431106ba6adf1c2717bb99e85f512773420514e3512492cabe5f36364f642baa0e6868c064caf223bba6e704b92d0a6db39427e5e0ef70139728331f594b7cff8cb230dba2d257a9fc6ed6200364b37692a8d057f2d3e1990fa229c48035225489077491c01d7784885d626962567f112f294cec6281e9cdf9c43910fdbd6d29c917a1d04daf90f914a97cefc73150b1f3781e41ece90f2260e91d1dd95093017743cc73814954c4a3203576234592b1708bbb5657c018e61e6ee324c730c0dec45c6062567a97da34b4e71ae512662e42b2cc776c5bbf92bc4bdc9298c3c90814892d0001754c4e3cc83752ca19a617625dd5ffb2634243cc3946408e3e5b253a2284c814411400ddd5a5de3fd65aec63d602001053c3b76aafc1c95b4985a5ff4f22f39864bb2d98d739323e1b35aee90e260bdf28a618654b1a312490cecbffd2490ff59c0f3c4308aa62564d2df7540cda2be41245dd2a12827ea00776ea51a890c1feb09abfce0c8fa8bd552c893483bdcecbfea021c6e7d0810c657be91922e60aae68c7d5cba1f7d9b6a7da95a1714995f050b4bd655d2232146bcc15dc1c9357f0b995b4f0f1f90248a05076e9f92a140536382475b91b728caa9aa56231d2c2ffdf0e04e5f970d56e5554710ce397afbb19c43a61d11c03bf23dfa713b8838fa7c21e1aa0d28404fa458830221030ba3db920f61f43696becf5d5bdebbc447975b1ac03e784648df9c205785785d9a3b9dd6b66c6eca58de42c697db6d3ae85ad1a785016b25461aad1f724a0ffd137d0b52c4db6dbdef667afc72790d9aba102732be9da05bb429edbbedd0f40263880a4f85a0abdd30f7200f8c407a6eaabe56b047f2883ec805d4599b228897a46dcccfd87c4879601893c6a6d45fc6f797a7bf0157df760e8eecd61bcdcf0422cddf6eea9a5f01b4e70d0730e044c267145a86a8f5e6cd464a83b2351e86580302416690abf370cf6f5792d79a94e0c33bbf75d7c6f867f103d0e1e3093b9140b514c18c54fa167e606be353ffac90faba9e11f656a76aae70fecafa53d72010a2b9bb0e5c03cd94ae14a39812d46e79afc55171b5983cba6922a22b5830408e3a65fa3992a2a90be810343198744c6df5b1322bebfeebeec68a1f3a33707eb4b202a3507ff865d2bc69f6fcafdabec631075407774a335f85c4a3914a67284b1d5749d96554660b2b51bdc9482a30e5f7969cca49399227d83f033421eb6cf46bc947e99f3a11f6fc2ce64657d7a9f2613e586fa628a2c9497b9f448e4e50afcaf36a8d1643096c6ce18ba99542d8eb6a9ff1f736954efe9d76c6c7c2b06f945958da86cd93d46d744bb5161c4b1cae67d30771d8895b95b0c0a92e0a6f711fa70d7a09659650aea5c2a7a63fb6c37ddf84ebc2d05b714884cbfb0bb5a42386625f4a7e0a6108e3c40b5083b56eb6d31249c8919ffa3f597ea2bb1fb2c2f6556f175965581dab44be70badd4c2672dbef406ef9170ed50856953948c1d67d21fe766b89c5ef45138127254ecb288175be0e96bfd9c499fc0fa1d5afc267cc16d31ee084c69e10dc0264ffd03f3cd6b318043c9bb2e446a4ec65bdf520177591e8f0cc8f115117b3632cf93855e15dc658a9e931918c746f9e1e9c4d7419a178763cfcb2c49a20c691c6bca27474d5e9d97daea5604af2b3fdc3209c216d18d301d4e95f6332211666f42b65d05d9c72763884a29b4bc110e4d1042e9d1fe11f50a20ea930351309e3581eb1b80e5f748b9673ed6932c36de3cb64694d6658670671e433e09691e8dc9bcd0ed38e016e2224904b2edae3a69b4465d97d53c6e54e72d6245eb91a60b33254e54b727555e29a74cd50105a84cddeeb2577ad46d2781b5f7af9ad17c38186053328b1cf25dd5210f0e4a7ca5ae0515c68c8dda9108fccc988382982c9c1a141b800db75ce3e7b96d11c0c9f955e95bea3fb1df1d2843daf3e3e3f266a4001e919d2f5de499e639b532d98c3f7bb0c917d486dd475700ada303ef2d9aad60e6cbdc2f1998679df9372b4a5eca19ae2f2a59d99c8f8ffbb96dcf100fa05a25da363ad487d1433df747c00c45af055521ad59cbcb95c2bced5f1377a9a3b67c40cec8d17c175597b4f66ed826f1b057739f5b7658e9012c3e70f88cd66fb122b72da859fe509db8412ceaddf2e936e022d5f76d7978a2a015406371c15d7c8a2384ca58cb166d6f8b2742a3d9dbaf2e3d26f1d647a23b16536afccae6311e9513b76e90f7fbd56c2891e375709f7c5b0c7258171ad7f56efdffd36c5b3e385c9fed4bdad56a99d82ed1fdb0b5ba404f081879689a822da76dc0f13b73f7c72b5d593ef7f8f06b09f38ea77afd5a48e32e2877c8e49ff2e88728639afdf6b02e7a8b1023e4a709eab395baca7d5f901b73311294cd09428791ca622da1f70c0f5ddb24594d8949d183d8e22881553ee1837e02a35a7007f88ce9fe800daab6f7c08c96fee29ee573e7415692f1627644be32843bffc5bea5c29fe310b96a61fd2bb60c5f1516bca15937e531ea2761668588af19fc69eced24e78f3792dc4872c7efd12e6616caf0940508f633d488349886627d7bcc8f75877c37607cb3973e441356720a8dacbbe75f20a29c354a8603664afc8306cc7d10b940a76809f0e496d4775b75e8ca9b6de83f38b75927f242a5de068cb9bcbdb1cc82ce5cc198ee7a09633fb31e2df690553b5a899999d575ef65fc2ed776bed255a44e019393bcce4239aaa2a9557844e545ca23fde41bf3e1d32834632ba2422444c59d1c196d27cc1c1f2870a2b15aca96a69f1eb96cc216a0157dcdde4e5473fe331b38f55af781ff209ea548d88ce2114b25ebfb6dfe3945d41b2fa37c309031f965e5d3479e88fd0858be519bc7f64f3d041139989f9737fb09d0d4c7f44dbdfd36d15eff587f30fe4508b1657f3d1a5da29096df85c07454539a9097205949c4d58dc47c74bbbee4c4b16e2a5d3538205760c80c7c90c7a92c24ab74d1022b85c6c80df32b59c648f58729175f86ef4e38dbee7328024ca88defc9b61a2cba9407dc301d6780acbca42e3e9f6689545fe6a11bdfba6db9680d0090a3612afabb883fe6348ce80c7efea32bca43ede6f320f99962d0b8e0a0ecb0fce52ea83ae241fa52b68eac0b9433830159c64239b47001d6aee9cddb610073e4bd3b60863ca63f952411164b1f5ee765e6c2ebf9be13a946e4e53b12ec3b8a4d7a0f74849b912d73a3b2e681da4ccfe4ef6a9e18a368c7b11b6d78c6099ede337e20697b0adf9559c38cb2ef8145f9bb4e8db2b37eadb8350f00f2428aa6776bb3a98b1d3038e71949f483fe02422a68f47c4c69ad4a69d743a32c26edca2d41fa7e5249db5556fa2791ad24b75beb3b67c593ad59fb735b88d881c1a2e615391aaaa575543b34273c9f30ca8983ba408c587fc6472c9f222e4f45b3ba7b650c7f111d6e5fb7781226032a3af255ee1b5d50bb95c393d06c313630156be902bc03c7624b7a74f05ca425a9bc7439b55f2a79ca35f7f33f90507a5f8d0d57119fb6233ecbaa47006823fd4cad7b5796d4615a6a63c74c6050e30401252358e18851e38c9b387a61ce791fda660f624cded0569b169eedd93c745cc4f27de9a77cf968e1b852cb9d6806faffe7dae8dba5766131c7d544d781c7b39453c35149d5b2e572711614c0acc58339912c856ae02d9812c32b4395e279cd7cc0837ff80b767170858dc2e5b4b2903b2f4282e5945315156a867892d6334e558f0bbff463d0cd944d8fdc9fd1418e90d96a7719101229159224ecaa5a2006839006038be6b3ce299d8b97db00713fd349c5ba462a333a4795dafc72826608325fcd6bbceacbbc983258c652344473162983b15f6a54406c819a57d4c5274470ce0861fec7054a5fad694f52219ea4d75adb18f6dab7e0de974a5441b45bc450f22c60cc9f53091d9744c3e138b2968e0a7fc939d8103d83e5adf2cc3e88bb6545ac732f42015847a532af0f2caab33b9670ce1ed67f2c853fea631e60be47a1bc301db9ee2dbee9c8664bd49f7cc56cda7087efe0b2fa952b25c98b6045ffcf078b6e189ba0f03ddd4effff70718aa3b5b848b1b3ec0584a8fddb2eb027b7124fff870af7363962f571aab45fd28329b73f960fd664637203026642c29283446a26a40fff7a1967e6df5ede902c52bf5234d63f45d3c9d267e82f794b6d7ce489874e7ab55231f92a1f8a6389cb55a14ff7824020d70492b26f205efdff9a51951b59c60a7af7edf1476dde2d3f09593baebad462abffb08f84bdac521142e72a7d31dc2819ea27b74c805adbe45af3e2b149a24c1ae339a67a767eee260f21cd449e63c2526434107d6058afbb25c425b8c91d1b14d7e9938c7620b5e99dd33d605d7ae869826","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
