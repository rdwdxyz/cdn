<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a82b4b81db7fccc97b108089d8d59f476a07664adc05ac3c47c902f748deec69b502f4f3f5e9b8187cedbc9f7b59d1bdcd1fa839f8460a8eac38ce41a2f39aeb6ce75d93446ceb05ce8245be5c830670353f4a1111a69b01b17781b99d686406e43f303ed1262e4b8a902dc4e830323fb361fcca0b949fbef48c602899c5b1d128620cceb896c3842297412e64cb8704d7f1ef4022a4dc4d20624b4ec0bd9b09042474f887f20e8ffedcfbb42aaa5e70468e5ea73da5b8c45dcfe1fe806436b1dfedce44dce833f723eb5fe32bf7c7eca5b5aa127692ecb4a4fb3ba6b31be7646a358dc69dcd6a103cba118cef3451c4785878fc70691af47f9f93e0486f9535aeed46e65bfeea8618d06229328e11279bea86fa81510b54082a1eef3c77c9f562ac6d4c649573fb05c8bf57e55b97458efe792b284f2b47377626c141b0eba0a8a72702d5d34cdb5f2df107983d49dc3bfdd47141be31d984273f3e8b28c4c5701a33c418fdefa5e745d283452aed83814654690e462bcfe8b33d3b8ad5fe5e24b21cd0de8d15029a89e246402bcf307c9102da07b1bc46d3e35693267ca643f39305db53f341b2d72bb1f05e8b99c1ffcd4b3429b1003c41516429fa4bba334556854d48f92c000d3cba5e6251fd06396876d4ebd739726cf2526c83b78b51c804f45025692dda58f815c6af64c95e4fadbf96fb3cff5a3c0af1531a61725a12dd2169f4216d613dc9f8ac35f40e6be8344806674ca5652b56673fa292c032cfca3356915f85402030e1dd056ab611892955ae519e4539299f6ff3ca5b65b87a001d6f7ff084cdaf2a404bbe308cd460668cd736fad88c5612a64a033a3210297060d30e8bf9bf3dcebf3ebfc0eec76f22159aa42cbfaa116d90395f173a6b8e2548c6ca28db3d7d19e6de39d1884fc075f2d5dcc7963e1662c2982c5e8b70518efcc4b8afb2aa6d05c4e7f18ca5ac6d71666aa67c5e752e325868dfee161b987bde47d1d7eb2037e9ca4dc4f08079c80e1ac736750d87743f545081bb04bb4e4af4dee2c330ceb6da50736f9a52dfa5109e49e690380288e6793acdcbd8e0b7d4faeb24ca794691cddac738e1f5903b86a66f5afe952f4408dcee00c34565cd1feea5dec9ae2875472303e490ed0e67b19235792459e2f65e4193ef085596930dfc7de1c74b6a360fc15bb00e718433cb44f2e999abbbe51b7b41415c3db3e80a11bd8b769a93f738718cb6bbc37f7818b510205b9d44d34526f84eefef4f1d264354e23a0cb05043b612a675c367d4ca3029281b9a4c0deb590decc1031a6b05024e024a0e5696cf051a2c44e4417ea49807a17b832875c9c65cab8e3441f3ca1cdcea2ee874d3f44c409eb3575bcbd36a679482573633511b0224e5164da4a47a75294c1239ff1a09f4c76c78cb5069523f208673e8d764dd50749b05ca67c218bd4a5c6d09e392eedf6df3e2b20b87bc4c4d615f47db3d2f3c0a0943f1b14ba04f08905b6deceafbcca69b5ff3fc5e7511643142ecc3b6d0e28d50d3cb9f69f42a79da0f47257b6264d912027b684e78baf51618cc05d712452166a4e7c813f3ecbe97cab34ca57f095974246d785a3a33483322d0fa8a6563572edbfedc712b9caa8b8b675abafcf6408a7951b7914926564afdedd48d529600111ee7b2cd7ae8c86900b610633f4e19639f9397788536febd7df238f620fcb26803ee7614227fb94138b3e492383988097836d6cf4b961de0a23ce43c6b309cf636499abe95088832d38b1f993e9241d655f33397a1d91c49063b91020e7bc3d4ff94495519541ab877ce2dc0509f06a87600dad7ed4403c093c5010fd6371165c5beba517e03ff35ce39eaa114490ffd4133d962be33ce0afd627fe19c2dea9643f719cc787e3133d93e933e695271ec2c87980847f3169bf18795dfc070b7da4b909610365cfa14401b4ac8f5b8372524b86945f5daa318987dd6f9b35ef6a6a6ac32050c833af9cf8f18372b8b277dc28cc471b8e88a5b94e75659f68a4acf13f23891683c021f7241bd647eeb1e78d5f1dd371fb6d43a6fc687c90c4b8d27bce738804bd7ceecda8bb65bde495513a64265509a6693a590714d229ac3316314e640be4c266a6349618cab309be71564d9e561bc167d98c687ebff33efcfe0528e8f928bf5b09c2c8d7ced320d09a91373a65950800c6fbe7bd5dff5869ebd3a8e02646015d1a8e9e3497a5a0cb9062e90c541d063849dabfc482c7eb809988664cef29f41957e5b44113b28a64d217fbf04f748fbf5d55e1f833b0abb45802311a20458ee772ac7f821af8e7d831b8ad0926e9f2b5da7115eb601cdf7f641e446ab38c1c393539dec010c1f6d3dc92283919619c482f97d96b4ac170d5bfe97f43c6b67860db2afbe55dd5414cf4cc8c24b1f6e4b384705f5e87b39131a92d98475c6e80c919fd22fd657f3cc7ab3d564c3700cd0d536c0a6a442acff19cea2c494824cce7b390f55b529d9e832582ee03ebe81badca11c90e5b304d95bc972758c83236c956b2c0828637007cc6f12e9c87dcbe5d50dcb67a20eaa0f8a44b36a8c7a5d77249d43d957eb7a0384c83ddd3f7aefa7658b0073df40a701c8fcab686fa3aa245d06041e77de341c02f1e24555885922111bc948c9bf0e5f8c3c6032f72b949ac0b46c2729192d6024349a140172fadfc98abaadc78fbb3acd4427a5adf2dfceb9fdc5ab54777f22c2c31f47a5373c9c3a44a7d327484d844923fc25acf2da2265767d36ee5033f40e09c6477f793ff1e7c797dd5a6dc097a31cebe38f65f58c2c4ef00cf03e62f3b2c807e3ec384ef2d1b230f532c8d7c9c1d8c7ddb2b50801e1772f64048d80afc2c738b2fdb14183f5999f75e88fd85564531977315d94e092ba309ffc176e722cc3eef11fe026838276fd520112dd0960518a2347c7665183b02943e99392dd5d231677fb54d6c9679515d87ccd154df1c1adbc729b6b4aa933846f189bc7786235f8c0c6d5e644c28f603bca54e35b47c7fa8aa6cb8703a994326bc0861671671bf04fbfedc48237b91339ce684bb0f63bd95836bbcf5f511bfd7fa8b9e687ff0f8c8042948ae93b7e3feca8b41435831dc3852ab54f08e9591435d33f0240056a44a6ab77ab9315364831fa13daa8bbaff245969716e0022813cafaa838c296e94c3019e9a4b4784124142c4d04b34c2e91510e076ebcb2a04a54e13f2163a34a2648fc69da84858ae1447e76ba03195c251fac738d08a34e87e61cb3f1ee5265da7acb9119a7036f12405e42968b105fd0b4ae583e95ffc9f4ed53d91c0160a7618f5d7e8d3c167f1aab252b70ea977e63e4416664fb2039e25562a77cdb07f97818482643f0ba184847bd06dc9a60536f850915898ce7e0bc951c6f81645c1d237c12b1dd490914b064bbab078d65490fdb95a9e58bfa9e42cb3e5e3c0d7041c5d56e2bd206b1d7fc8b85f293e30703102552da40be63de81088dc346ad676a7868acd5efca629f3467b21def70d3b7c02bea94eee077eb1fa855de794cfaf4d4bf087447f28e4f677d7e83878c67641d18d4ee6df5a69129ac1e77310969bf3f6781250ed993ac9d62c90eacdd7b913ac79be2ce27fb733a342f44c010a3df1fca966c1c82372622163ad0df6336817d2abc6a748171ec56cf7a82284691a15b6d4401d95285597b420db8d2bedba38241c9ba78cbc6fb7bff6974d496bb3a2eaa0ddba82dfc176e7eabe216a50c25b136a4d4899c97b7827c6ad83ffd85c3354745647037dc52bb4a484cf9753748bab3bd9b9fa33d9cb4f50c6b659dee00f58a9bc019be3602d8daf12f85c971389f28db3add877d6b6c7df672e07f2bb4a34692f9b7fe026592dd561d7488c622384c63cdb3a138052969d7d7d021f60679546d85fceb485a328965f7bda9fd2153bd9618001e91edbef0a63aa164c2b9aac5027f0215ca84ed467403a30d8b079b342b0a6f751af0f9910ce1964d315ae66d3c041b039eac508e418a3985723425804c9b04db7758bc11a85177e00f28cf9308d92b92edec975ae36ce59d18420fd1f39323324d4f1d659441c9f7aa7c57e38e6536c67ca066586fb2a21313c1de6104793a8b7257ca12aefe1714443d0f797c9d8e368fe17dbe4566fcf054fcfcba25779808a1cfae7426b929ee65841c179a7f6772f2b4526e26701c8b7caf7270bc092479f3f24b25300e527ae9262a063b876f173a61ef6ea69ad9b794aec0e03ea798b557119f72ea50ef868bee677cc5d550dd8a742abf17dccd64927a88858f72e3dc90409ff1987d0da4e3868ba4cdd56ae3fcf82a5a28931322403a569b5ead6f30134716eb77685a560a18e8bc361efbbc734ae690a5748258c640cca59a5b16d1d7eaf954583c43c71aa19a101127bbb94b95e727e15e61464c2c450a4860dbe474cbe4d03e2c50fb010bf8a487893359edd895045c657ea77a97ebf63db2cd4b26a89dcad5387042216f2b4cd3394ab4f7c53d47aa5873612b14eac0a3c6c54c42d6442dcded5a605e01ce472bc614572e36e1499593028ba3d913b07d1cdc396d41f3e66dedd949769fb7ab018e8bd5530626e01e258d64da7f7f71f35cc1eb79742388dec94ba24bbf5259208227034f6b3ca53c92d00ae09ecc620cdcbf29513807f2dd573a11e15b36b9b31ea1e4069ab6a14d0045647eba0ca25632127551964ae3087af8364c1a5fcddd01fc9e2f9b7b1cef16781675814e8786eef38d050ec1c975b06defa7312e077555e8cc75dacc3ab003788d10cec3cf5d51377f70dbfbf5492d4ca4c70123e7012ee37077ba293cf60838e2a0924e510599c2da58ccdbb90f7434b8ffa6fe24c0696509ece9f1b6d158d7073a1e706aed26b7fc8035b9a9e4151984aac1301106dccb1b888e1b60874c733f536998050ff941598ad8044e91ef82e7733818553736ab4b017ce3635279185101cebeb10fb5703c0a51dfd74066938e67765cf29ccc8d2b4b2ec0ca229f132df4f7b25a1a803d19458cc588498cf51667e67079d0f1de7f8395449269458f2201d67bdaf0da2a266e47c8390fe0954c2f7b428f9144f68c17fece5c36c35c2588145ab04f10f85451d7f18cc89439cc79ea9045f178aa31db6419cb1372a3e416cceb842bd05ec0a704c4d5807d38b6b010cafb53facfb23d6401ca55c0295709966b0ba791a36b6427f1a8e88b180f4b8e5e90fe76a240a8738be43b7e8f9c7cb0304eec18e49bb94756a73a221bd808fdb788b4105a561e95d97bd30a707f067b333133cab9fc4652c1444ce6fa6f7dec88d24a03b11aa290cdd248b065c99ef4b2f7f591ee50214ff9103450afa826071f8254834aa4bce5d1bf8b4e5f0116ced7f08351a53b571280942d2e4b2f61df859718d730046e77b69d1a8424ff635524d6eef71327c69fff3dad8045988c2b84b0c51f5c25d15fd688f471c7889100cb0f96657ece2529f8859e6200dd47cd5d4ec7412df6a1847da40c81b25c934676a508ae665267466b6f82956a352d63334b251c8e767082526c4bfdca76e6bb2b06f8748dc76e11b141aa9cd98ae48d7c74483b370fa58b7292457fbf5880f069a39edb29b2e01b0d55cfe311bdb5f6e3f2d5da5baee7006f9ccd2b514d04186f24ed425737301f6b67e2d0bec74214b91d7f2f3fd083ad1c8c04c01f9139050fde70a04edd769e756603babea005689f4d470586a8ea09ccddd51cda95a6e15c524b888fc0105bdb956be78722e113e3ce11d7e13778f868c6eb9c34cb5ff9aef0091606cf570bd483e166353be7d890a91c6b8a9e618bf918caa1e4a1ca5bfce5d6178b4fbd21def6224fedd40f94c93e6335c9e06083ab45afccc6bd1799c3ad93bc0691e6e132c8b4ce4d1bf05fdf0682977b97dffb49060869952c0d2de6411063724c71fb97abe381806abf37271c7cdbbc674d3ac875d56b908892f4caf32094604af5245f616c81a16d091779ce31a0aff15f442d4f09ad1586e4f2da203ec89f6c2584487a172d84c2637a588cd5a2ff7fcd4ebe18ebbf408dcdb7d23eb266199a419e26dbee966f0140a3b383690f39526d76e24c98bd4f7f7d65b7889130e5ed6c09724bc86f663f6d5d321a0a05af84690f7e8646a7252622e03e1f55057aef0cdd7f5910a8a5eca39a414885d13cb76f5e46fdeed53b54b45c7eb7adf52a717928be8e7bf8020b1581281e0a6e4305e06cf993ff57471e2a0bc6c88e55c3bcde769a0178955d7df8ccd9579d981477be6deb4e6a7884e6b19828684d90547e05964fbc74faaa472f0648a4cb5a45e911c799f3b76a6b2b9a9765faff98a669980cfe18fd35834c0bf0cb8345e6a028518111b82e6f2df06356baea12da2fe1dabebc5fe3723c54488e655c97d6f48dd75aeba38937d7d203a613bbeb20f3e034d5ac75eaa9746278a36b27aa6545f367ccf7ea2dd6ea4db4bcc3d8b79d470443493949123d2221771c707815f53567bf3dbfdcd4d137bcc64c94d26e5f71d8eb41f6fbe3cbca1657c007867733c0ffa87e504706c2b0973d093903bf6e87327957c0b7f9f743e52ae8da1485cc793e60b1db740f8b45e58970dd479eadfca25d1aa5b455430609876b16d4f10d15afb3cffe7599321790dc6166315451b359261b02e1fddd5185c3766ebafd98b0b4d34ef4f65390a08f344c2c7f88707ef70506046b5f3151d8c1599069e0fece774ca946474a35d24f630894cd22fb659104645dcf63dd1c78bba1a33613a8ef7f383da21935bc6ffc468f938d7b4ac54cd7dc792ecb35058635125974211c01aedf033a45fdbaadbfea0e52583208cfae4aec5518d9730f4e815241db05f4f7d071dc78524d8ad17ca21594877ba6048067c4874d2748b9d7b66dfe5944185ebf8ef0880d9755225e0c6e4d01e6a0f2f84798d8259cee42c25315aaabcb8661b55139d9698b45400a79c0543db96f019f90c6d7b1742063d43150542fd4a514fd9ae9b4cb620a122eec9d9d3a266395c638e24ecaaa4c0eff270b1cb86e59d541584d861264261c756af96686ab49757788d7942f46f1e932aa4492427a731917312994812a87dcdebf4ddb596903f48023489e6872c7a2f67d490c563af1eb4deac1c0094537db79c812efd90eb026978ca341b44fcd3e41dd60e8e6adaa5c809e8e92c9b937ae930787a6f09078b083ce1bd04573153817de52372dfc6bc41f46a94e77b7137118b7d3325dec7193f4af0731c41281fc85d7c7fe298be6c68c733147c511cbd4d97b7cc52253b2256b5e184e5a162babc824834d7626a305a1d2adb5508410662c24d32e97ec0516c0d5232ca99ed1cdbd71b2556bbe4a36d27949966d10c628083820ac3e66c1cea52c9558f148de84d06a6908784c0473316b2891b0ab7b149c279892c4ebb3a2f8b57fe8ba01d85154c80261b64018c6a81f2a02bb63e40cb58ac2f82923880f4ad3aca444f3037b0d143d4c72b9920ba29ddc4a6ee48530733396a4dbf3b20edc7f83c24e0c901adfea0921ea72006a494a765f48f71c45e5a46b5efcd04383257bd170eb070ed6af32ea68af0cc966842912907dbd1af53fa0e1915e71f6ce9185def461c26d81a5b1d8185bd9391a78ea572ecaee0d11949d42a0e3311d49fdf2ec31e1efb44122e70406094e36b636d74e1549b09e533656851e3d2e4f783bf02c2e6bcfd471368c2b1ad426564edca49e2c18817f0b43412401ea5faa102ee6c32b393dd4fdb95e15774aa6f0cc5d15af718caef57bffe1867ef0e9262a4add58d775d695e108fb9e6a3a48b6c5e1c1aa49e2db1f27285c4ea208e7cec955a8442cf727478f88dda341b10346c19b7ad8d8d2d14d6b044656de3395b40c975811dc5d80be97bafe500de52bdbb29e65de8f4a5cc4ed5cbcb21f29285f93b608d41aa9c25f3bfe2dd6005f3b1c48152f8a08fb4ed011c061c61d0e7a1ac9b09d4e2b88529300bf3d56bf265901ebbb39284a6bbfaf1c11c97b5611c8e3eb0666a35153a9e03b1233a4203b71da2fd2a69f73a304c520b581e312a3ae6fcfeaeb669ebd7d2c70cd78c50a0a527d98de0dff6438c5bf05b1c879b85af2af08898202dcd6a9a45e26c5a568e4608ee3d0419f5d628c89850f7933b5a0d6eddf48adb48cf915b344285004d132e7bbbecc4597db307800f8dc55b3739ef2e6f882fce9506630673a68c90644e67791c1d016bca333354cac8427a5f31f5a8428aa6a76c0491788e7267538a535ae4c78bcfbd1c8d2b8bcad7752c6a0a6d7997fa44343397c5d5290dc9cf3fc583dfccae72840992541dbdd45873a97cb38a768a5cf95f1a90659cd9a92fb0ee329eff20d377b43d7f8332154677d0d0ab44867fb5d507f026cfa8061c9f0147e56649001bf55f7c20579a0b0969899f485415122b82750b8a5b9701ae895f51e03acf6120bdf12e65ddcc45cf69482a53f0052fc929dcb858bc2a57b6213eaeb113edd3573bc11074a4f39fee3ad6896bca3ed9d47082a8d6c4ed94de5a541f8a30b32fb9b4c077ce9dc174b61c531e0cd53c97f58bc553490e1b3277d698951f53ab0de187e98b3a987c61fa3ab8cce3fde10ea77984ca3216fac790eda066c1e7c82b3e66b167a42a05425c3369b960aae85d390c8e4d775d6ea2794f4c03f299db5ced02b7e2b7b0d2ef8f4f71dbaa0f87463b8532aa25a0516d6294a8e7c492b3a847fb1e4d66b0e659cd771bb75c5ad60947413acafa84cbe5ae497b77a6c51026f846697f6622971a17750ba585a9ac8ac72e2b72fb5e4c7bd2c4fd85edc1814c570ffa7d49323952aa4239d27cb15e748c3f6ff0c16d8adbe3dedf7d0743bb5367fe90436fe15447eab1518eaa4da229027891f53b6ba7aa2cfb329e3425582ad78883fd2cc4f07c3f15c65fb5adf17cfb1c3e5e190d613aeb752428150d75d34ece0559dc0ac05b0518df4d7c4099f824fd1ea5db4c04a88c4c3c456d3ac893d50498a840d617357c3c02a431872b7213951ed170cf0f05382752542b943701262f3a2370a443cec2b26ea2bfeade3a77dfd776ded69a174353a3ddcb273a4c81643f8a9f83c7820d94a2fbb966c160e2bf36b4ec518b530d83e089e366a9297d980261c570545a76575bab17a5fc793afbc9cb82f1fee8de23d659c34202ef68a68059c01be824f45c7052b371f13190ea6b7652f0aef67b135463aaea1765a5ebe9b72af9dd4ccb4f54fe4c206f5b5f68b90fc9442e85933e345a3ab05e1f19de2f7cfabd3bc91c211d0d30f5146a7858e69ab2b3bedb6f8036155edbcb66083599baf5629ce660ae62afad725bb15f0b25b752a38cd736124136260b1ced76e5c403d8b87020bec5bb525ec3c0f6cd68a3bf88d90d7ecec743b3c9b8771ef12954938daff72fb75c09eea1cb48a328f88943e7baef9920e26c2983c5e3683a795646ed3ce912b732e2280df1e58d68abf9a3cd00f5e6ec08da52a03ce8f94826208a5023a9373b35cc97863de1369bdf240a4a8acdd9cbbd49437757ac35216d89a9cd70fd49a05ffc243538940079ded85a74ddbdff9a9283abc26cb4d4820d34ecbc5590409f5631154721fa7b55821d37f792628595bfaeeb71bd9c2f037d41c22385e45415fb056a5e19984066e1d7247fb54e220c29e3417f14b65981778bd6cf306c9ac7b2f7bc9bc888ad9231b545306655163bc2364db123c09f3d597bc73b88ffb0b784fc9f91fcfcec4d1328a8999cb53dbc830cbde146c78c8a5a67e9d7f806667ad7c326bf836b118eb4cdb2bd4fe9145a5c450cacb876279e96b716066f72e92f400313a373049b667d3d394f38f0a0c51099c6d4dab32f2a2691cd704e1c76f3b27c44bbc0b591c139bf03a2b0cb6e7bcb6fc268dc8ec95dd87ef552caca8e48f248db4b1d9239fece7b50a132fdd1ab8cd57b03ea9eaa378c0958ffaf2fc28248ab150cc8b4a55bfcb78575d29933195f30bf17c36831032725567419ed27a132c8f9eb10ade92168cca603e5acd975ab43976e4257d05043fd18b902ca2775aee49f1ff1d68faffea27591d0001c2cbe1175c9c4b144d7856600257c901af61fb4f964b8c4dd2197bb5a5606c834a0c032494f2382d04d5c37e780a8ab7d6b826f39189999e9d62e6cd3c07fa3a7cf93669d2d97a832fccc918ab85eb971fdba5a2ed40abb60114d5459e0728aa059a544bfdd1a5385b50ca84078e5257887c9e37c0f6e7d0269d5fd70ace0133b7ab9bba46c58e988ccc6d7889213cf1d09c97a50c3c42c57ebdf59ba5858748c9639507534f1cc076434f942a44ec5a86bdf2acf350740e82405cf2444859f0cfd01844aecbf4d5c0cfc07666069a266706765bb2a568b62af071e38bc6e14aa277db0c8e172cef6b28a108a9f0e5234adbb1dc1e67038157374eaefe1aeb18ea0b9f2e79d94e20725b24c11b49656883b8a983228705f149007cf40a62c84b6e320075a62ac44e30fba5855c196e9701d624416b639bc21944f1b5b286bfa9b9b27cae83091be59018b737099ee98cfd4a1dfacfb77a3ceba2ecce4e30b80bdc1e045890239f44668720112553d560b1ac4fedc04273509de939f155d45e85ee999e4c6162d516c683f2d74ac2b5051a6802d1a48101cc86181934ab0838a206c99a8084dc4f6dc8898d027f7eb66ed7aaf6b2ba6d9c2e8e3a6bc9db1cab0f629bfbe93ff17b23f7664420bbf7c422ccdf84a09b8fa7406c22d4734b6b20dd69abac0e4b73b93eaa774c962806386f26181339a07b8487d7186ce309425f288cb378dd7bd2aec931ec4d0ba2341ed25a8e49be601fb188fc1ca49554762b082e5785cb0db18329040114aa24c642f9384edef0a7077553964a76b934cfd01331d568a467b43c10bec71dc8c4fc5eab31eaa9435fa0757f28f250a5960fea692b7d5f852964f0d241936e990167b9e07aba2381d23353be509bf48274b24ce4ead2565f32a11b2ee520f55f133f3b3313998244ca63ced774cd4218c77b3b502d2dd39d89e1d9e8bace3003df07db9f2dd9e31e1af231e36b5c9d1b9568ce4cf27a84a125119eb58b294bfac60c1e9f7d90928bc73bf5975af4c09c311257557177598e1e75b160f4ea4a2d9b9b8916941e02a420a44da58339ff28872cc317852a19fe144fa5b276ad5f18e9c53ee7c8612a39aa0fa47efcec45bd5b145031b41b86f8fa222aafb58e6eed7f2323ced7eba07bef4dc8073440747717108ec39691b9d0e6c4725a8e3486a40be12261dd705f916c9631112d1adb414a1f161b11119f255b5b8d81d529213d64aa9c2b1da2f3a98479a97bb8849c69c1377e7ee80ba35b7572b328cf3565fb6cec42cc6a0a56d9e4501e94b4f9fe7f95abcf05a927e2d2c0a8d82b81253ca72722e744d90c684d0b755c0af8a77738d1a5389ad2d87293ee19b8cb7d0f6be87d0fa7ab7d5fdd1e289b5fd4f5b0a60eb12334075c1d13a97d25a99f680f2cdf417fe2a8dc9af504c2768074301780ccc6f2757f1a8bf3fd9691c2243c116fd88c72610fac4058bf3e223ca5507ed9e61f9cc9dd46bd4039baa5b7e0ff27d4c12db9ccd0bdff41e8fdf0ee2920494aad9784f1c41d135d0b5fc2b5097fa8f5e7041d6fdfff7d390245661bc7b6aeaef380aec06ef7f22fd655721e726648624d02c4708f65506f5870f6322d6f2444a00e6eaf0ef8b9ebb99f0a4ef9a71918fec03e380eafceef712c2fcd116291421be3ae01b5e09870259f9294f239e91c5312709090fe250c1d294663ebcd75b919fa7bf8908f874a1bdf0856b84ea1403819698dc2a6a17f80cddb7bc2562a12b621f0331a2b8b9a5aa13583e084e5aa41970dc0f1ebe3dc4b5709d06c23ffcebd2c003e75bfd0e7b82018aabe8a087fd4f959fa2df8159bfdb2c68e4541c9a9558d1f3007c8359c56e2447c1cbc0c602d7ac9f5de9d201c3ad062d0d3fc510faecdc6c27273760c2fba51311dae32fac10db91d3ab28c049d876f825f8fb36d08f95e2e237ead6c24c506a7d1485f2b0f141ec6ecc5e0b487825f320b62a35eaad1f0d014d0b3556186f923b83e844e820d3bd8bbe527d4e4b1863bb5e1d48ab583da78bab393c57ca8bb110517ccd08149740cb1e8629b6d92ccfba98e7c8a7115eb1d518edad81ce5c8206a2c049104f3f435abdda64d516e8018b1caf9dab56cd19f8131c1e98c1c0a1ae0da62d724f01b2fd490b81348a2e9dc7d7213d18b2de3d8c2189ebe1cb324397574ead52adb00c22a1046e659c197f2f493b996c2f79eadcc2ff2993de36928f8762e71088c908506f1032abe165d40c9bf55b0e8d312009b5b0a2f4dc4e4da4bef6bf99b8ee6665136b72edd2d852ecb83b238cb1aa11c13c035f41420ea3346628ad4e2eb6a967c5051d8b9a007c3439c7189ada14a9c8738bd1db9a4f55c40908c23d66200d755831aa7b538cbbdc68e4ca1e5cc69a9f7d3c06d77eb381a06434fc2e473194e4c6b1472db2ce07634eb24b32c2d202d98085173cfe3eb5d0a3ba939b5071f2589d45a51f865eaed80537fa0279d261abf12411cdaccf0fd04d8da19869023ee8111c444111095a75aee8807fae1849d1214ced0bcdc72b82c76063299fbb5454b907fafd93a6b34fb885bcbee95de3b73aa0984a993a4714ed433156e492df39d6ac39b326e75ec206c62c2b5257b8c3ae7e3b1bd12525bc493a4d75aa8a9d3cbf02e08fa6137d726c8f9d44442893dfedb87eb9457e60b410e36c445863267e09c0c5499774a68f1ed7a9c557ecbea18ea844caafac66ffc783a8fb61465bae2835ea10b157eee1537660edd234d1fec6faaaba03521a8e305db47b753d9470d5f2521f88abd122e9fe1a8df4b7b9b1417de6f068615538cedc5298ac8e0575bca6d7b28a2928218fedc99a1500710b871679ca9011d8c680312eb4d11cec142cb875530ad7d90677f18ee5fd279acb5a81845d2de3caefb8e81724d589f33e2fbde4babde8e22f683385f2780eb707dba8ce79504c6b291579af2186096abc88f7717830a3a7843b8711a51622b3fe88ba122b5aaafb8d9b8c3fd04ab098db42482244e852f1b59d6ece4f4ef65fd495f3c0d50286da9d2e7f3ef292729cd14a838b63057365cf52d2dbe9df9f4871fecbfa8dcc0863726d4068ecccbb54dc39e904842aeb7b936337ea54931b460aae52a92aa6ca3e761a01a6f48e397461a32260e101b3626e5df882ba1d0c5e42276b02fd1e95bffbe240628a839047485ca6181fbe7bb123fd7b0e0e75afa5301be271059fd9ac7de4e928dd69be0c42b4d59febe5aaa151c7ab952a059264f0fd505d875faf4d229b8026ecfe063a19eb93352eb4846d535e3989761d70594dc6274954de1bf81d5c7a292f9f55ef6c7a4e8062d8a9a8afaeaa7996ff0c1b6ad9cae55c6f0302a0800e310ed81473a9584d18082c74e5150958d2a13b61f86404b957323ada5ff536eea1049a091c00d9c8d29d689583a1bcf3f7c9e2c14ca6f2b74a527c3fdc2921a13c81c4176fdc8531fb7364e53650d842d349648464ef46dec85347ef91ed47334cd4ca236e798433d7f7cff5c68dfb74c9cc6ba20098d2a53aa8e713829cd3d25987b6f0ea1cef597d63b4f502d989f5978cdf7d14f80764204c61b8c1ab81d72f9a85f599ac5d3ede7efa9e9f529a9c474642cddfb36266948f761dfa44a49dd091f05319b3bae8cd866c0ed29ebfc640a6ed2e145cdc4ce343d29d97719350b0e8eb4f6343ed5169bcd07ac86e1d65cae398b6a799bfb389f9da3855a85a3a7f9b5f2fe4a5301046f72330227cae075a62ac531142a2db582e67c416aad1f9c37c5b694ff56c473aeebc7960d5d7df8ce710836345af30871246fd38ef753a9b04d1fc6266013d11f722e8d10014fb0e280e11d9961df2ecb8ea21153bea8d509d25a0a5b406ea6fa6ec5147e5e20a039ce8b568e686b61b44ebe2ba87aeb844835f8d99064df2dac24159790397218f96918bef6f88f1587fa53569e9f0facc93fe8367a57f88ae56dd2efe034a5f5283a0e7bb1b2fa7bb433d0b892c6ee1a1b30616dcef6dd50af9dd82e81f6b7310f55fdae4437b42e8c04f42125c90e071d5d0e3711aac27901dbabace239d8e146cc27446c645f9b4ff4e5206cb80d915961ddac87906e267f5ebf32f3a956cc6ab3a1c747d7e6931389522fbe9ee85eb6be29efa8e296d3fb23be0d43b25052c935b26437db27a61cb10f7cdd1f4e9450d796bc18663429a5ef17563e942d6bd879ebed223ec0ace0e43eca8e6b70d4b8189639bf7814446ab52183aa60c06cd253d5cdb5571f3189c4620f6443bb5de592c4a49fd84cf2f62dc43f08638095539ed69c7466797bfbe3326e3e16a4edd2e7ffb360fecf6963b40e794e06258e3dde5dccaf9b6cdc1f35ed7a2d1d5caef91641eabceaaff01f36067e1be62b6ce13d157b43c79f6c7793d99e2990371b8028dbbad596134a098115f81e1fef069ca314bf42794e74afa030d173dfc5c6b4ed2adbe6c99bc611d125f7cadeddf7957e6e61492e928c1e9f132ad2402d1e30746d874ad563504566031e0a6539fdb8591bfe0eded7640f2672f5d798d28b094ac9f5b7638a39c9e29cd6cf7a680bea606147b2ebf4529acf6e4747087575d7be01f36b78fbe6a86cacb667a1276b09988713400e2dedde4e1feddd82bf9682cc38b9838535bf4898ade05de056d34ad1bc376e460acb68b1df497fd92b705a50ab1868f0500c2892469cf19007f1b4b9b869eb71ab74b5167ac16095c31e92e1fbdca824727e9fcbe7150209ed792702a9073f3bb7767f6f34c4930efa73c4785638abdd4179b8d53d7d3d1f26dfe978e663ffedb09f2d0f05504616d57a1286157c56d11d4ab80e04e7b70f1bbdb32a65acefe1241d113da5fe0e795ab0acba7c2177fd45118d1b63388afc84ac326791e101ea882551f17540158681e125b877af178b913aff5b1f1d419eb9dbc0d9cf0427ec74bafea0a3b92eaa7ed55cfd4a21acc01a3ec8b382e2c0e3ac4e7024d06aa905c758881c7f206823179db438594078a9d22cf5e7d269a2f5d68668d2175159204e0e723fbf8e1b2558411c5df70b625982e9b0340942276cb20da87532a0104c0b8a535bb1b77b405712b77a47a9a418e0669a29eac65a79df572222aec8633afb78f27058d0b52da978540609a37e560aa4775d05e0e60cab5b861836d84064ae02ce63b11a9aecbcfeb8f21f79490b00b9b03e8686fc3800c7243ffbda46fec1c8b9136b6fead2c0c61febb4ba00532ed80d617b3a5c33d948f15d8578365c276cd9393b870e19147656a93df5ec206eae009eb9b64eef97fddc6c7461795974e8daa823f161f668c8b8f07994740b5d4980b9ec471aedecb18884da7484ecdf5a192a6e74285832f64aa01596ee95a149210bf917bdfafd26a781559fb334c45e6a348e6175d8df147c963fdea5e5994cf3cffa97abd2d5a709b56252ae252f791c52ae4610b162b5adae85ed1fde9d2a1c450bdce81df8bd7ca6cb6787b8d866555466cda2313266bb1135bd5d96fa187ff88dcad13ddb131ef07ff53ad43d4f33587af9321a054a6f74d6693398eac8ba960b20cad397e965c303316fbe0b67c8d34c66ea8a92afee6c94fb7521f506af72eba719626fea5f229ddf2c892c70a8409fea14462694ffc8ec469cebc0b29368ac90e2fa07c66ffc0412d39c7ada91c7b6f4159f6e0c49da51d6ec5111f93c5ed6bcb394a004e1b138bfefa79c4a7a3f9a6ab390a6db78f5e667f3e3a8318a7ac43ab3dd9ef3d842f82b4423f24587933da6d6cfc87d6be32fe502649e124804314fcad51c7d6bd165ef5afa7be917b5448c065eb495b6acc44fe99556a06c359148283e12d69abea7ec76ad4937e1cd35f06bb5591c4b6246e7a30dca7b07fdd10be5e9cbcc56926eef00db591fbfc42e6b9110e97f2aef240f02a767b0e0c2e3e7b334fbedd0bdf00971f8804ecb70482e2de5b530cb98adb7025ec9ce19125b6b2764c217f580a5afd8f41956ecd6c911f4b5f3a12f6f4aadf7c6084821e10283296bde89384e27007f61bd44ec3081bc5182298021155f03c295afe94608b879cd6a5003a46757c69d2029ecdbdc1d44facf4feab6fafcafcc08b9cc77191f9e11c0c46363793637f46792f9ba1275f07eeb3f3892ce03c6a1590478c65394e2eeb4e3a11cb6ddffa5756a09f4c24fedff028e551f6ec0785214ee53ac67a15cd8efc98ec40bb9a1078e301123f5f64829fa523728c254d972ae9c837a7cafa8b05a53528e807f6d33211e3566a0390c5a89f8f619afa4db0808cc540b444dac0d56d1221368ecef1022a0d0ae2d5689f56474c8ed8d6d2827fa24db513bbd9a1a48713412994ebb67da5e61dd0c2d548faaa4003694d77fc25b754a3901f978741c1cc9adcf502b4229844f303eedd0434662f1feef5511af379bf7dc77ba41e624a5bdabd7e135fe8aeb3af37dd98a91b05b99c6a33e926e282496d7be3cc0e979c31ae33e69c3053a66e9c18adee241a494fd4cd5eb44f2d22d89b65be722405d4be30478140724027dce0d34f8142d77d265581006bb8f876fafd9c7fc196006c3bb54c26196fd2523c8f72c230b703815b82210fe6e87e24b7bee34362df155438383cc1ff47ba430db478de31e6bc2f9f02997341ca8b929d20a1e04eaad4bc72bc959c878cec4d7b6db2aa7a3041c5ee4e6817bac70c67465baf97b216020a45039563346ae5da2e46da5cc9e9bfa0e175ea94cb4d5e6620c97db7452a775c01789267c2f129cf832943a5152ae6e78b1b318ebb5a3f7ea6ac6f67654a642446c2241f144fb9c9227696e328324260a17e96a89ee98a0c2ab463fe1423152f8b86d46e975dbeb50c621a85b9644d8cdc2bb5613aab4ecc6034b253cfda7649a6a4b5419e6823c2fc8cb6f313c074e38e1577602425a32e9e81ccfc3fb82e45f717cbb29a52c3c150735146ec773c31e700ec3ac012e4a265deaa612ce95d3f1143312f98dc1061e3168fc590ca1db2b03c060826dc412d3037c2d12abeb2c46546dfe450b29998da1d658a61e21f66fdb49ab84515b77a1eb050254a11b7f28b6e9c786faba5ad60573f64d1ff7d5568ecbbf1372a507b52f717ea079d25a48606b26009f35bd26baa12a70ec5906b8490817f71206910a3a77f3465d83b608f41b0685259b9bcd7b361a8cfd2dd3f468ef920109d3eeaa17d84acfdba12a4df7eb11d1d9f0030763814d26fac651832ebea684693516274025986daa06dc3e6ed3ee1f0db5168d8c3cd035a338d936a65b4c74f78392d537f1e4b50f57b557477d171e79ed4bef46dee4977290a161e1d253070e2e24c8bf3a7091d34f308403cc967b12e5d20dd8ca9573b4e9df75c4a816d22baba29feacaa6ab345b2c6dae88c6171ff09d9d954118dec6ae4c09b7ff009ea3cf866dda59f0a95cce7f0691be140e20579f6ae1acd1a16c8aa9b238345ee066ecf5ef70d3a3a41ff53da9aad3ac6fc1ed5237ddd104ef51bc57c8a0ef00fba200dfd585a975999bfc71ae4c795e130e9529abb10b1296832310d64f4b616e905e516cd79bbe5861265a2e6c89c565aab3d9e92ae47b7af5183f10f3cef2e2843aec069f0ca109ed58c652ab08cea1243403a4bbeb7b304c13b35af35947ffc33b43d725e6763125fc55be5e1d62a102a3a0dfca434b05e9f83c20445faf177fc3023f695d6cfba35f78678f0c64e8a13e5453088674b905ecfda2be9ef3f25d8119d63d42dca66f1131803a1ee9ea916de58393256314eb2998a05fbaf3b4b2df8387c658e96a5a45b1dc063c65a2b4ed26ddeeb36970896250add40a144d8f4392d9cd9737ea68fc80a0df5ff5e16895e01fd5ede1a267fc836191982c404604e7a422c1c9232a985f429810c5fafa91a640a3bff2669c847b8e92c142342fc2c115d31203f5f66c62eef8dae2de101b90a84ae97b16609418ea4d049740e696c8ef9913b5f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
