<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca28496e2a304a54c0c165922b836edb65e1da4007d3020f87903f580b4f5e8b52dee140d6c76967002176c57e1ab8cb367fd157f1ef5b3dce5593f4727182c114b53af2bb86b58345193abc9f8c335c25e75886dfe476ad215a41715b829c03652427540edbb9164e87cfbc25c85e145440cd8d46113bc7a7444ceb8f0bac7cc3dab852003749a6632b39295cf2416f796696c9a8e51cfd9f85b408f322a8c3937526babeda72215d809206976b4daf1c7330fa72d686f8ea5a25a2b775e3d276afd909d44d21402e7ba3e2fa14453bbf6eeafdc6e5cfa11779c63fa893fc1eb8ea8b42dd2549a70a06fa96f915beee09e878aeff5a1e923da6ffa8d837ae86743761502d167605e771bb075c7d604ed0c84c483e7c20c46ce8af48b35330eb8386783f85305ced12c16e9178af8ba047280ad4f7e295e7afa44e5c65edb2beeb20708dbddd99f3ee1b12e2e91aefb6eb6a2d7cf08ed72ed219e5d199ebd09da2621bc3722627e0d46451ecf904882b3af1c51d30b79c64c8f8a9bf1f29ce2f60fe4d4acf54d6c6dc0c63be24606a5079f179f1151d2e118ced163f80aea2a3f27bb913050bfd99dee440a671d2cb0804cd01cea64111a573054f7dcba2a08ab3a02a6eb66d3b9990b021667a047675af6cb98a8cf5d22702f3bb393068c0e2c8d9b452bbb17744b5142f0edbb28bbca7cf40bb2f35b07001970a30db417cc7d6366e5ec51b38e7e4072130e620d1f6da0c1529c79556094b15241d61d08601f3e91887e77e0ed4895246ac03749eadd81707cbd53882d8213ad0a23d10257b4c65e45982f2662c975e953e27a3bcd487368fa2b4ee2654dfd226fed2464ca0a9b713b39af6d5c2c598335427bee8aba9d3621451a622c09d5477c523200fd097f9fc4d5c1ca435ee8eb44db3c91fb557bb64854b073a1bc85f4182dc38d2a0312fe313935f4a7844c5642e3dce0ec163eefa06bc31e13b25ab6b5441e52604fc4acd0cc5d3c247bdafb20cb2adccca23b7359d8895f32415665ec2afc9e99c813577e6076e9b1dcd918801993689e78679dd8cf6f853497cd0c089cf74a0f5ca7233ff97a927946c1cc2ef943801a25f4ab7ae4d1e63b800b2cab47a1175aadfe60b18fbb0eaefc1e751be5d21da07449ec8cc863f5739091bf659a492c1917c792aa0984c9c8215ddbd158063090fd160fe186cd92896c6954416e8e2d0690614e149193a2df4b412874f3a17db6281dbd5f42ce9465010a9fa015f1feddab92ddbfc69abfda4c0f3ac13dd5f5f51576b9a5e9c7153a32b56e95522a78be44fc44399d3a1158334bdc41e213c2eaa731f8fe0c3c99fa35ba06968283b7da7daebf39b168ba29c6cbcfb5a33929587a02c96c53be2951265e3da27c3dc62653e1246c3d33e3f2acb47760cf5fe87971e6500e1ba520e6e5d891db82dfd34d2710f0676746d7271d9f5fe4050352455bae9a2f5fc1a1361c21395f46868a09dd97e85882fcc5bdff71ad931c11cd62b904338b548667515d94f85876159fae34b5f96f70c38f13681003a835117d823b5508da05b8f2a9bb0661146aeaf9ce31d320de18790f2b2d760735f68c5a348262ae95270531b8aa45085a7978ae89529b3470cf4fcf350c79500254722bfaa12fcc7ab3f16687806af6b70a0d4ef6dc7ff67f23e6ca3ce6aeb54cd42c727df32a9ee55e3120b49494c38274e2013c6da9e9ed8c1fe5bc598a9d3bbaf52b6ae7629a682c9218742ab1bd8ef175d4df0dcc79e5c3ef91011cef20dcae7e52b7189ee37f56f42e19db3c6c2d2853024a4349e86635ec510d29c7ab6f3cb54588075782deeedc3c66679212b53c52a523dd95fc30b7bff571848ba22c855664da96daa94070071497475658d3ffc4c37c4ef0f86130972ef00cad76d4db4cd946f03bef153241abfc0de20049e7b9bf7bd1eaeb052e5878a1b6c996da354a1dbda4170b098c6a4d61788ee90ab692781ca743f8fd9173263ee5723799e969ed5a4e994aa88f589e6fb0e99d4f32ef21cd9816f1402b47cde0d54182be49e728c790dbe73890993f98e2e75131d7b89ae351953a6b77b04ccc4b3e7d6e9f84252e4b76050b8385857cc664c1bba7a64d0a98cc09a5a60db706596a6ab912aadaac80d0bc5464eddab27dcd3b15b66c879fa5e466f46d0032bd494caa6f9cc2db8d1017092a12f842e9ffdc11ebad525ba1810725124756884a9a0cc3e34be154e72125ee4288f854bf8031d1468a8ed9b67a6e812da2ee0d863168a16b8ae8d1fa5f79c6d06496d3cee04605f056ded82801e84b7b0b62213c31f0e9f1c10afe0d0c08aeaa936126a54d14ace6577acf781dfba8fd31289298295ee03e8d340290b85f1642bf5c759a82637b90d5f8e23ac37ef10076961ecaf906e086df1a8808ed0c2d388924bc94565cbe5e7d9c864f6ff28309ca13d6ce751257030f7852fde593917e35bce3279a232ac3fd8789d0954d14877dca5a389901b5ad8d624efaf91133f93de28a2aee348829cb2759f7308833b491d9dc1b78643779ac1475e814d7faa5b484b8bfbf4fe03c1077bcd6ac2718893e536126222d70d714686fe8a0a2cff53809c9eec734b02b3c465a061b606a140311f6e9488449edc2124f1095fb2e21d401137104e2cffd926c0c4e20015c5391011143e92ed0d389818a652ac47eeda72097d9b4df8b5426fc0fee37c31e66c3cb6df5d2664798b00f147def91003e8a6005d2f628d5c35bb0e29ad9e4ffa7e26de8301a74e434b94ccc8d2194de19a77d578c17bd8917677b46360fe5c800644a70a8e3ae529ff1a08b1921b46ed1ea1ca70abc4ec9e2ced7e4b9bf9ef1aa427f48244226054e6cf39fdf480f469a554c2c98067efe000cc53a009ed42261bd11f4506ac833a95a98af4ba54c8f7b2cf644e0b5b8a84036dd6439199b12be8e3425063033166fe3b49a5e395d1a3e11843be1a258dacd79a400cad6943aa9d55aee27630338e5e5e172314ec8c44f850c6c7d7116a56c12c18b87683f19488acb3a8473cfd844a6f0b1330741e0fe2847d31c5a61c733d1baa3d0abe0771904383c4249d5ab983947371a6ba15e9aa6782e60d4e0d703d8de1cf4a11387366946d7a8f4e33519f1d3fc57a24a17f797caaa94e5e1bf67056a000258646545657452226452a15ae5813b33d4acacbf184d8a7397b126e6ac4c734bbf2dc8cecdedfa47a1603f483e5b7f4d99cc7b04c9d2f158c8926f2cb03db184a5ff3c92da264c11136f3e3695400192a21d69c28d0d615ee829fc2f53f9376ce5df16409a50ac04ddde50450755d35dd1af74decebdf06a417bf810d58397cc5d70657d7472e4dcce10335deb389f15ba1fdd175df2416f09b33a441ef0e8724cc077973790257bad469183007194196b31122d277dd2954c802796494cd7cb6e9d731c45d51b0a9d087387f6e563e9cd3ff34b5467bd1e34f8e360a45d2375620c1e367b616aa49d2a0b5a7d494cb878b3f5f63810eff4d0d1a51e37b9d1639a922898475bec4c4d29cc7363a46486a33597eb8ffdfcf9e909bf357c014fd00ea0395f2cb73e99b35cbe0622a6e669b86c58832d9175f61077357df51f83555e949f1006a1d189efcc72075da354c3352d11583accaada7dab5f053e1867ed2661b521a8c8c6ce459edb502ef1c61a0e3997b7dee27b329b53e93bfbcb48fd7856e1d67f55f364a10755e8709a21fa4ad379a515a1daa0061d0d443b98cba61f5584138ca63bb53d922b6f98cfe7d60dd0d3071d0b9bfa009e7b5bb08834815d66860b7adf4bbcd47c9899e53ef5f23d20ea4fb1cf7f512c5c01f3c85b71878c28e1ca59f0f471115bfcb654b7a41a8e9a8d32ecc41e0156aaf6688d2bb4948eaaf5a98b1371b14eaeff1c2bab873f3e6dade429824e81af37a24b91c84cfd702906214116fbb9c7911024733d9db10951a9d7b66cb8e13e2677ae97cd20fabf761118d8db259afad7f01e013b5337fe9ac815b1a7ef08271a5516461302504815c0050849a57a8e7d63c96dd5f832e5590aafcd735c1ffbc48a9fab9ca71a3b0a5a1a43565d5ca179c0250d0a21a7fa9f5ed6320792456747b54247b35954842a7ac8097e02308435413eaaa90c34a888fad89195f4ac7d64801fbb434ca6afe164cd6a319423d2c3c006c8011e3bd236ab7d6fa1c6191ac6776219ad86498b32f7bf6af230f3bda19ec6c33994a56352696e85856765c5eb4519915da955284a0a18c17f16d761f7a5969370321723ff3bbe4c185759b8283ae6c1aa685dfa1599eb7aa9fb824fd1a323374140119c7c794d84a66a41443c3efdeceecbf81c3e2e2dde51436521fb2bb32f5d38c96faca7f772218f94ff7f1c83d30573791df7d7c70637e5dfef6f2a77a49caa76b9c7c4bcf2f52e16056b6a1c8c083b4796ff472a09984e2f2bbfec9f02d16f5ed5f80b07c501ccbd14bc90d0c284b6cbbd107058e84c16bd3c355dc45351d5b38c2c702f1ce23934cf345dd745d5d87e8e3b9c2838811a2b500a041e781e94cecd0da9bac8f8635523b938106b6e5a1a3b3297fc9b204f21b0171c107e11df1cba56166ece455a2dc6061e5782b1828d0584bd38d440026aaaccf61473e0d6d241c8df6b8f85fd7bd52207a73c2c71693a5bf9df3f66ca07706e479a5da3bd6f312a4c77298e92a57ed613986d5b2988f3ed7d8d986f3b3328e0f313fa9d8ef64f4307c275e8b7fbc18f573bf2e19dacc8694107b2d05176443af1df1b7eb96b61861e94432228406c91f4bcfa338e41da379b84bb1714cd41753d85df83018cb65c8f9b8a4b74a0dd43711b148e179dab116981db85826e3cf169ee704b54a4ae68de93e755f55529ad8bc4f1a753cbbaa4ad0b35ff6e0683474287b385645008b7f8a7e0922e376212ef472117e53dea2bbaed184841da8b6b923644e6dccf24d6494a658f3e3b2e5582f26438982ac2023197ccd7887e9eaa0d052ef4b5ffe6c448ea6edbf6ea4a918379386ca9d53fd23c42093dec7654456586ca344bb564d92325f77738fe7327458365fcd9128905c41ee4a9515a00a129f9ca55db4c7c01bd553b5a2f58f48e9ff785bf47f1f65442840c0e0f0ac91c5ce8ed5604502412f57a35495dec975e5abcdb6df5f46a0e52211c4045abd5285a37bdb8079961720289deea47cff60a26f9992a1584705194f9dd4bcd242069bcf798c99e477ad77b3ec43e0c001e812fa71866eeba23265e58a4d5f4416b8e3f6bfd7ff6236b3f3146838bf5b4484eaebc56ef78e9a4fc8da713546db495106e4d67385d7761203c81cab084aae5d4785595f25735bf38287edc6ea783a49345634f58beb749a666cbbc0fe0be652effdbbbd4d2c81593b862dee08da038a9f2ae362a27ac884d598b23fd06400fbbb20d518c026a7e3fac005e95c1ef33b4a61878b68c74d11523e265e3366480c97c95085c87f18c72d35e953118f58b398a0b816b61dd709ca60dac4f4d1e5fb11ebbf6e5f896be57662b7be9458c53705c1840e0c8c02654578217363eb40219f9ae05b9db11e3f99ac7b629cf479a479f6ddd7ea4e751d8ee911090b9f6b39f61e4d21ab485136291a11f6be575f8d8be5daf9de0b60bdea1fecbec37eae0be1aff31444f24da56608833fbbcf36824f1e90bac7fb0b5a258b5228c51a89120bd1cdc9c8b0a58b83fb3f805024bb944d14ff47ac7165f1cba82d7c03832f258ebfb3f8a8fa4c83062a5efe309ae9ae820bb8cc51a8a3ac2d9008eeb0100423c0e1c9a87656c33aa181dc04ed99977011e392fb290d2e57da66ca1a83f75e4061b240bab7f5357259f49ff33e1c5e993005a48c4bef0218d52f87c7907f5c39ccd6c21129db519179e861cf7f4714d9375a842799c18a2dce8272f22ab19e837bc817552182d76ac7287560a83ff8bb1bee6d39b65602f23c0d9a7f827ac519535e01a14ee2cd6692f50109e7b7c507227417f24d02efb081f7e9a337ba4e8ab2f34aea702ad0d104997e4bff2bf26d68d80ec7f0236ee40dc3a56792718974abe91b737cf50e15e3eaff9b37fbb2861ab05023866b6a2214b4d762250201061f6a8829e07dd842fc3e19307976a74964e3cab8ce462c1fb074764e8c342e0262449f31d93b2ac7b5fe22b1ef5cd6d1cd98f63836da979c79059df40b367953b69073f30afcc260127f3fd9d6f8dec492da6cd76b96c1d7ad7adeec558c63787c446cc2367ff1c7552f413d1ae50f55b432a02eddbcb9e383ff1c8e76690ff8682fe7c6e2f66d24bf4f4643714a33b111dbd4424d7adcb68801017a3e4c57bf99a6a03b62d61d77e03ff02c642c5027167895d6198b05f42031b847c704177edebde7e8e29c09826ad907e213200c3348acf1eae27e3b3217558f9276cc11b2cbdcfb698f0415396444c6fa143242a5dd29c0a682d1b44046e51c6f5a1b2f6e18b148dff866d27622779756dbb5027e62ced6608dcfc5dc3ba605cf83b92e88e855316f49ecd4952f54740227ea9faa1dd629dd9e3235bfc16a266b04e17c4ba643ef70b4b16fd5a2d479e761b476ea89782495203f18623c7c893600bd754ab1d71b20a8de2a6681ba97f6c759b63cf8b35a6595b136addfee6515f8a47b44306364cbd7d4df22f30a67b39287f95cf8ce24977a0762bd480fdd8e1c588a62373e9ddb67d384469095295fa660f64738adfc54deb157addfa43e0dfcf325bbc498894126f8c701906b1db06f9635faffcdb58c06c4b4ba5f127783dea113bc3046ec63aa1d092c3eb5952173b197cf916868a336543d3bcf0feac6f44c1f7d200f43ac0f25e96b7385d38a222f5091e13d5b4300dbb0dea663745c032d5f4b8ac498380d02d5a37d8804c8854f67655c4956f393f25c31f779447a45e39aeee7bdfa429d01a6a2e9f8903ebad46fd13a6475c383dac4675283bcbcfcd8eec569b99b04a6478deb2f2e280c7442d42754c5dded22a300fef269a63c99ce6e80ad8b8f50989e5f2fc79186bbef5bfcd4dc33351ea429745f10c93d4e4596ace8a04503ad2976af0445f9c25540e6308f47ed2ae21eb182d7db39412aded54be59880d81f2d204fa851e808f6e1e6dafa4a995bb9a6990a96e8f45e084060ca4d1156589b76ab178312c35d25e6e1010c8d059f48854ebfb163e7431c49064b392f21a6cba27da87b53fdba0dbc250c7a3742d1190d834e558f66c22fea616bb1fc584537a1ec55b7dcc805670f1999baab809b156211d4551c08403de45783f72d7a07d58482995a260f3f3b0b921f8b8041cf73d7fd81eac748a3eb760de7b956c59e0bc2862593e2f5ece938d198c6469d5efcbd521d248689f35ae0fa54e2e552c9b6f1bb9ddbd83189815ef272666ad507bd0d2ec874b62fd7a0ddb725c9788520524a91acdeb21ce0d98ea65b76d6c04abd75badb695e5fe838b426c2ceab2bad48edaec9d48837b6922840f9d18f7fb0f0bb72431457e8eba215008a1706cd2904090604ba8db74491c8910cf546f7a0fdfcce319cfb0e7f96f233f1659e30feb89ef97118c0a41ec7ceff56bc46d057535d60364cddfbd106302868f0c0d3b619071609981d38517377ad51c5ff97499c01fdbf89d0b4150cf9cccc247c522c81e780a3ddb63d4804acab118b023353628903f380aa12b98db31074cc9349dd2e0f69df420c888aa4e5a1de9b061925dbe8ba20aee6b36a35b1907f33a13f680ce8540daeec3e828e58c5e67426d515bec7f605160f68bb64d71c2ef8222222771a476753e522762a6e3eaa9085d05a7b8aeb30231ab42b913c409f90ea4e66e5bd14bdf7b9f3a6c9979e9d47698b29068edf7237453a2568cb334cbde87786ab2679e703cf081f0cd0d3ba096fdb68efa447b59d58387cdcda5ef378c03e5fc00014ba9c0666b87976db782fa10da687786f5f525622fbc10189a183bcbabc1a63cecaa939d3d952ed393b99578fa7a5cdf264485809fac8b0a8c4e13e6b40859f00b651b369e126a365121f71e5bc894cc35e346a8c2e55ef20f9d571a022136704bb5c1bad8dd645ae7a0e9acddb83e62985536e2da35b08246838daffa41de235ee8b35ae447aeb29b519bb3fccedd94325f187274b7d17d8aa22b083435208ca1ae2e97441b2fbe6ae68ab0c5746866e873f34f087eba4ef88fe634bcdfce2724b8d60dd9399ecc5185613aff4a7cb1d8e9a63efd966b4c5b83deed74be562aa5963e2ca07b4f72b127033b2d976f9060a07dfa75e91c569de0435e88da21fd503b96e60ae17a1be8bf2593d8e1cc4f70e692e930ec89b379e9d5bb81150504dc0c23124f71a280a5ccd9d6ea2e6dc5645440442ca3f0d2542bdc4852f1877c5c1091573a99c8ff69a1cc5b268bce1c9b9cd8323bc7442d0bbc14fd2290ed8a60eb72eeaf9060ad7fb337121a1dbe8fa03818f0be19518253f23e84a707cc6edd4466b098d718da5c3b6e4c1fd228389b77aecf0aab64b632692f44c27db8d5b47d8bc2c2fdbad2fe988be0b0005b77c8922b9327fe88ed7f3ee79da48e90fa5171b5552a38704d0b8d3923b5ab2974ba4b119d887435d94ee840dba7a3fae6e4c19db40b2d6569710583ecf6156a7e909683522d7a05d4038892f58bee8f02be2965102a182f0817860f46efaa604c8cd8874a19b9c25421481664c34ad2805ca56f7bb0650ace4ee26f8fa4954f2cf6c20ad44e6ae9dfc36720fa592174ffc9198b936e728d0b77731e300d6b58535d00e67d2bf061305d55658641e30132ab064594d7b35051d9dc2f6b0c898377443eadf72f9caeba865b79fd8d2ed0ce932f79adf81433107e54f1aeb745fc1cd37200ccc32c31c35286b9d5ebb3e2798b020c6c630e6e3674778bc4a5a61a44ecc7c92201a0e4375fbed01135c5018006d13f0fad28fdd28685ed6cd775ac7c6fdc72da61d66edacbc09942c3d0056c2e27a35287b4a2603bc959f793356da47f5486b438b48bc011de6b3974f0b8587aceaa18dc26c64dc422cc9308d7d6545ab67dda361e600ca4e76f5da40ca6afb115806afcb1cf32ea1ecd525ee4031c04e8e95d58b5207665a8aa5d1311c83c472892ed3e62d2214f0d2b1d78c1211bd593a797cb4924f0edf03eea6dd203804f0174958a85aa7be8fe63088e0102cd27455d7cfcf995869c4fe311fa0f6bd0d3853db41b738b84da4c7fbe034f5c2a6d97643ac69b96030892c1f5c8bc8af002d4d7ab6012104d50b906593c303155bef05675b0bd701eef1710abca338dae833de532ab11d7a222faf88371d228f46e1b8aeca22422283265789866819dd0f4ed2a79a5ff7594f22de8549d604d2a9c26a4280a1da43e154a1b11dee997b828f6623b9ebab55b217a66ec995e7576ddcd76da8cf5043980bd5cbf35d13f8961dbd939dd1d8923341ceba39aee44120b45d33791afec458217c0df7a3c053d3d73e3539ea648f907395929d975bed08431883ea9e8e7b2a506019c8f28398656f50280162284781eaebf1e46b7b6add0f1315ea180058b1a3602c55495c165093b758925d36e7c3c044fe2de1283a7653096b5e5689a0a19e2f778a29504436f90578d6074d7bebe2cd1d8af2316295a282280570248907582873f45e253843364c9604c6e04f155863d771eb09677e8d78ef2a018526044a6dc5ce622ef96ace791b068f1520e9ddc33bac0a0ef123f6b0ae967f24e677d85e77f4a0332ddec1110e715f12936c5c325742264e631094bafc22eb68d2082753d98dce7b0bb020c5a5c2fa29aca4cce2dc42b3580e55814744803a59ac8c42a403d46b5cdeb1eb4b160a46fcf215cc3a9c5771aa61349e060282a6cf5a292d7e455e73a51cdd528a1aff659296ba57a763a42d2e70eff51c687648eaaf5c3fc0e0f5e816e43640f7295050539e9f8d94e655790a928b51b56d137d050a5ee1023abc5a52f54cf1822959ee2aaceddc701d04bf5968beb63a82f0c8e298b4a61ade562338a0439a2565f3d6a01571d408d28b2ccc06b8f769b2d56691fa2f62ac481dd8b3708e5fa3318d7e4beab39b2308cbf63038fb9b352fd6fe01e923e6f5aa6dd8380ef5fdff48870902e753342b6ba8bcef7f8a03261e65da359b77ccf5f26a87f850a744321d6f5281a42471444b335c0b99f4a16c7176574e0a33c0fca81f41332ced1b50d8790f6a408220f189ec7c77c2d1663509e0578f76cf645c352277c1664eab82a863730056e87f4265c414fd36ed8dd0367f6577fc032b3a62bc8ce9536aeda2ab71e780bd3dfbad55cdb8f1903e2ca6ead923ca3a836c1c0b24dd25186853da2d0f5564c77c6055f375201e5f55fe45a12b7f256691f04777e56e7d0d17ece2cb0c6f70274b4f6c2426aa2673e5755a10d01935b5ac964a67afdbd2b8faede4ef15c27d0ca8b1ae54378d066b324c29e915a2644c4ef4ffc3b7cd51feb7cfe51fd57fe256090fae1a5046b2993f9f40ab63f66c9f511712abf132c9fd76c5ea38cc8928d2ab12065fbcac0faf185c114cc1fefd0ec648eddbd4f4e43a3610894effeaa118d28afb143c252c507b39cb7644bebafc1c1b573518e9be5bea412dff6124a094b8de71811ba3d3b1ff545c5720c552f4cfc0cd5f4a52c6b59bbdd9c7fcda72a539a7a44391e4ea9c3427245af7b4aabf0722c238e315ffccdb3f0d6786fd09e0f1fc0b44ef94177b7c9cf2619470ae3a89fb78efd8d0a0b52536ade9aff53debe12e2849e45005e37b2e745dc6c163b6116d9cc1be424b5cb5bfb19587af4a9f837dcfda468deb5200ac6f08787e9a89df152b5722e9370edb493947c69b4b7ec60dab394b24d2ad9707a182a812492d74e8a069887e9ce4af79c3984bf0aa15075bcce9011a73f91d3ab0d7eaceda08d980c9163d4870d66552afd5392d4aa794618e5f3aca5f96d57a061912a0e627bd38f25616f137da4c98d9ba7b9d24a6312207e4fc8fe61b172e0742741fed6e25f6c7a039aa1af9f7638786b3a65e726ca5b51f655980e805fcf650b0d1ed1029758df6b7eb008ab8dcd66c0828d0855781fc67eef5c37800cf3fe5f59fe78184aeefb2bccd806e555de561435bae9357bbd12169e7a8cfc55ad10c07a9f9a6c6048bcd16a1e0bcf4d8b0d3d4d6de741e742822e4e8a0ffb445567224570e359a710f860cf91586560171c4ca004612a291269fe0c64ef97f4912ec621e98412bce18cbcbdd5d3e2941108be9c50643f88ce9dda1c19f279338223cc196d12db4f86f23b85c51680bc3f6496cdb37a2dc7136f891f5cf3334d49d120d5e3965ac51947e24af98d1c33c4c36f29b16c4d6fb8d1d6d4959521576dbac41089fdc36f0edf8ab70400dd7c920df7a2500de5e784f6a8c4a5e20d74a19d48bf0c28b28b68d0eedc76ec9d42fc68d43704b06cfbf4cb6439b773771f037ab17c1d0e994c1e2c49cc7574ccd278b96919121e8ffc4e112289da237b32ad5d5b761ab2fa1dfdfdb3405831f3bbc49f7dd8776e3eaf1e934dceb22eddf25f137db127cb966a1c6671eccde23610862c061deae3ad8ad37ceb3b86850ea448f468f92092153eeafb58ce13e83a7d9341045259da6ea9a6504211f325f2e3cfaa70a8c479cd0100b3268daa8afbd3a802ba72164226a0f7df3e2b1e37df82bbbd5eedbf2ae550a0f4a6c0ef9610ebcf238dec3783b588e481151de313849dfc07f327789f0752f75531efc245a82dc9e1976f8d249e1cf105be0ffa2fb2b5a56553405f97ea6456f77d25f115fd44f324eb4aa88881435833d33df3fc21e09481e272250cb2901085131fe5192af583f73877d251fe8d651bb7c86437fc119f98e5e6fe7a1329e0997afc96696d73de9650d9ca99d36d34a56a41f4dc95fe6dce756435700b54a27e34404c742683b3fea81990391669327bfc16065a4b699d895ec22c3acbf521160a2c8f46e74bc6880d2bd4cb09cf9adcbeb3f6073885e55ff0a53931fb090201c7dcf2daa5f087ac3085be64073618ee49ca16265423259f5b73d707905d52fa01aa65039c51c3aae2b7e9cfd98aa97b624686839ab840053fcecd69c1ee7626f32ac7c0bc22fb9f8b9a45b6a2486fcb81e2d8df6a9d674a82022dcdaf35f714f10554bafd94ae63fc03ac71d14e3215e4d021fddc35ba8d2825ec3be586dd85a98fa03b636d57ddcb58d0d2115ba0dce433ae316c52972ee37bc0a3864798f8f2cea6f886683652350918a8eb31032714333e1795a5da8ee935fc550b44c8316692e34793f6f2ec35a3281ef45f0c3d9d25e1158f13738127e04d58feef70f84cf7040ff38e759d1fd7de183733aa7e3dd4ae50564183e9dfeb0caf7350de80a978eff1d2a1f01c301920736a185899d40c218c19e31e7442f80820f2406850db0620021a4f97e26ec08f2bd11334b5c3634d9d92a157557bd2d9e11feb4eaaede4d68aa5b4b9455383c32153269b76f683072177dd76d85862808f8246f27b5905c502361259f14cffa3db7bd59d793a9fb3cf40828d906acd162aa66a717bfbb5d81774a5323d954e7bba580919e23afec2af1af3c436b5151c9417640ed951455dabef0286367b5d1af23ee52501a20e9d06c72e9734d990712118e9ed56ccb350b517a00ea497646228f0443281ec2c32b4b7e50cd14daebb4789f91ba13c385ee1b2e5ceedc14a6d92132a6bbef2e20e00656bff6662c8fa457b9af2ff6afa636dbc0f32f9ad79f5fa14131e5012edaaa79ee411355ca981e409619908cfdd27c06fc07da5fe50aad63cce671378197b96539db2b0142e67cb5a566a84584ab87d962532beb694cd2befd4871ebfc0e0c21b9ab17a6345e7c04335bd580ceb08440e6dd880465fc09e0db980e0c7eb9a521e6cb0ef19c4dbbcae8df2db95297b53091e46292d4c9f9e3d1d21c6a7cfa29680e744f67608428b0357a4a4bd5fee12d37ea67490fa3b77d30c9c71ff1b996539d5a6dacdb3da5192ca957388a740f08b04fdbbf89b48355015b59aba34b25fa0f9c0f55b65be5df044c844a617333ca5b0c15670860249375d1a906ab73aaab105f39e3f1dd1f7d236e4362da550963c00d50869890ca3fe1e25aa116994e0aaefbc2bdf16ed539308fe02b2f39afa58cd670656ddeb5f7c41237ff72139c2f77a3895f1212aff5b0d23207872de28809bae63051a309f9ac998940983b99a2062c37ca93452c45e4b004ba4266645a781e8c9a94ed2f7b7ca1d86ac5d7f96ffd2030715140f94138553e98a6da70abd1fc004b2076a47e2e843ae55b534365bb5e838520f2ee9bc42c201254cf831fb1714419073d1876759bf82a9380246a4afb472b2ea0b6158cca3c079f9645e18f28c3df2ed8ef53722fc22ddbce1d8dca6236ffa9c17bf6d5eaa3d102aeef1fd95f81cdc9751aa8a926911841f71c53a2a7e17503cf307a0a5b23941660c9d5adb63793ca627551d7d404c227f63dddfe92aed2b93df12a0c38d6a1e189a860765addf5266179b6c5507a1d57f974064b7d42acc33ef2268fa4a67b64add653f683bc72f479827a689595ec0b349d570a61596eeb7a86705d23380f0addfebdc5fe6d57b97acd92655504c717c238d625bace8c512e93427e169e4e14e4941374c452889cf1336c2ceff7eafb4dacf3d8af492598759a005f73a8822d85c24c57aa8ee4794a338908024e74bcd6db308cc1d6bd1cef0684010b43ed69f7ef10d7d096d85e4ec20a23b1f4e559ee77910a12653e327b128224a535de72091ca51c8c3913dc62c55545caff2ac49306f810650c15cc2651be34c140237ba90298cc5727ed2fe0bc051940c6f08598b29e39d6a8afd0cdfac3bafe58b2a55fbc98ba0d64d2b4518bc5549373dfdbb7a7585524f6023bc5f7c20172caef59542a2e9dbfd0c62b2f81134296cad37b19b3cc888926fcb59ffd7e66a09554c1555f48618e284f4a90dfd01649c26fafcbf03210533224efba36a40a4166618992cd67080e72391f1421e2ceeded792fcf863ad3726da33827a6a5e6a5e48a2df6b89f54c36843f0a85ab7aa2a592143ec89ccde86f0957c887482191c1d5901dbab6131fdb8f052f82fbd0c9d004c73b4e5fe4526e69db71f5b2110a1eda6f69052df62c5454697a267debb86d3cb08a5d6956603c06819bfb87e09faab40b303f1b553868d82bfe362cda5ceec066f25278fb54d1d8f46456d918b69db475b53118f1da41473e96ee7ef36fa4c59b2bb8b7a8ee9d4169240a60e4d35912f505e264b0521af0bf96fd38de89e8ce8319f300f35ed95761fa52618a5ee02ff662fb2f17f49bccf6c69fbebcbacf4290276a6041e2469d88b8d631ad0d70f5fbbb1ee88bb33cdab68cc350c832a2dd03ca0f40bf08f244713aebf0440e212556fc796b99056dddfae8e4f86828063a87ebcaf49e48cf357774ccfe8dd9b165920e0db452d31b2d9e676b67b092bacd7d9ea769652dd7a9c90cee5e676c2d364a67d6b39a2400cc09627e9dcbea42b0bb5f735bc0d2dd25335ef7e51558b0846fef7921b4770a9fd865f0e6c848bf2291e0c98cd7ba627811bea6dbd06687613f25008d44642bd7eb2ed9696895f7dcd87c257155593e03b781bf0b1c21144adf6b2b94d558341ef830a7cdc6cf40b04da8d1ff021addbbc0dcb601c3fb75a3b7d8bafbd22ce6cb13feaad9d755a619c0f5ab813858bd1406701d02ac36559fc23f4471d01bc30d3c9b03cb27201c0869db1d3fbc361f535f63de134ef5fa4cd4a688d365e257fd6a7a6e1113dbd24ec0afc43f9e9137452008fee90456ecd6b305d866c86228b6fc10639826b313401eb1b9b98ad8262d852f91191bbe0b640ded9037ab7da4e0400fa770bdddefa8d4a5b1c8374b654bd875533a3b1df61ecb0d2760bdd72e3e1f9b85644c6b98627abd5ace7f9fb70571a079dc4129673d02e36cb6877dd7f5efe82e6c2e836c27535fd0c934baa577849b2f76aac79cce4add36684b6c21055e109a825d7bab48b205eae0b5bcf02c0956269a26148cb22f627add2fc186585b5b860b0d7f90d6419f48fbe67ac5814248c5c4cb30362c782a150c83e4985c7409982713d8632e1fc2eb35749d46553991a63e46b9868c3ed1bf230f8dad838176819042dba5b18c1ab2b6238a6cc27aa29e2c2c9a4e1a035fa586ba6bc9f17305f170f93f5bf0d4e5ec8bd0b4299e01bee77164e864d3169efc20f4e34642e8f0ec4c84fc28da87b6e6b9482c6c1f46e6df027f66a4d4f1a6654473ad3b9e2497d9c41f3ad1821b3445110146adc0bd0a186d246fee795638450283bef6246767646682e5176f595b42e0fc8984933a785ae61ddeb5ef6e8317579274a29dea26415c2290a5af3124f0c3720196e4da54f7e2c2b8035f64f24a41eda21bc18f3aaf275179f339eefb28babbcd329aab11da3804b67b2cd75990a7e04b2a8bbbdd61fb949ef579c6e9d7f64a72e4182259f1b406b5e4bf38529a6da172895ba0b84b4538ebbf6d17c28833d33778d1c3a1db4550f70e6ff8e1bb157b3f335af6fcd42250040b55b638aaf27ac6a00bae8c3544ab843ed37866462fec9876b22d381523684e8e3d48b6f967f49d32c520873707956207064dae6cb7a38eed81182425d3308081e2e7f86853f000f14281051b81c7a4decbfd30ebcc44cf56065747f176c58eb217042adc6d78977c405872e10dde0f2c4928937a0c7674b53760d243ac99fae44dd857f4f0c04950dab302ee4479d5de075aae7254002b4eb870d4b1817bff6cd3d784bf75b4d912080c214ad66f60078ba4bdf1bf46cc8c2062f53a5daaacaa410116b001bc2bc33ffd2bd559d5f38e6935c7da5badac980dae2e5c914d6973ab175c3307eb849a8b55afdf10d0fa03c576481e93f084748ab6868536cec9dbf08d0168ad0de83ca1a9016119c9fb15f18a26946b18511136e46432797c04d6df6b491384f837fdf359becc4fd5195e60b22e565b3ad7100c953b209f4009ee308c9ba6d4d38d407ab480c192e0ce640711e25361762f98718acc6b9450359841fe785d85f1b7f54aa27f398905711efeae74c41877f7127829172d2cccc0c9d344db2a9df8c532700ba76d3e927efe21b26d59f54a129111165207389d12f27176c714520123a3d5d0cf9efd145a41f214f6ccab3adabf2497015e9f060179117f9a7669a206bf77f542bfb5d49c6f3bfc655b13f7032bd7e46127d39a885aa52211d14c76f34b535743bb386302cd764a6aeaa094efa414e3b74a0eb9d2c44fab041382d1abea3a11e91cf7a53b0691660a9e37c9214a522d064870e715bfa520ced3a6b4167aabacb1bb61713cb492a02ff3224ed3605740a233e221a78a6f9d4880fade2500f4dfeb398fc911a2afcb9c6102db4635f7f843d77cb3aee3bad7d942490f4169221c7e2c1cd7553b84ae9e55eec347b84448414f47fe74bb71f57cd64d9c39610756a124a07bfaf86e41253b70a9cbef107cd517e45aa3839e7e92a7bde6b73b92f9845fad41d78cf432e89cf5dcfd2fc58ea3b00e3510dee8a94506f266e410a71d71c496806ed010e6d897b908978929d8caeb299e75a66fbd6a19756fe56bc0fab4e81d30fe84d55e1ab4f25667aa81603e4af1aa84058b3459f67fc1d62d2d6077cf489d55e6410d0e3626ccb8f102903c945c43b4a438141316e13bed148eac6630bd986eae32aa679ce9f5317bc757d9cc6c3feeb561331df46e30e2acf296b317cbb3b14d33e37c7d874cc411280cd2a583d375ffb489791b5e04c1ddbb646e28558330e0a7bfd343c03a2309f9111b2842ccca6d613a574942c5b03e4fa2cf118b2cbd943912dd9cd25212a51a3520c2e5ea7b47f896ddff6ccb3f78e1acd1f2059baea1e402a81c27f4057f94ac15f918e43d60f01db945c9812a08cc4b220b9dfa11ba9e0bbaf96b0e14df052f44a6d7da71fe5aa01bdd9c642dce9d5de2394d92b3965a93a58d4bbfb0c7d3849c85abcf9dc2fcf218867c1cac287015828c08921e0cb5add49c4a51a21d495dae78676f8540be64cf02f702543643721dd520abb279648b0925aeb1b78724a8652db26f954eae4b6dfaa6597db2c44f6541aaebaa4c809a4996f8e845642fa3747d3763441afbdc71ae37d0356bae2ab55ab4f04c143e1d1978b334046ab61402cb440fb45f4f4a9bff31d6edeba9552ccb4889ba25e27147e3177cdbac9764f378bca7bed5c10362c6f7c9db4c4a7adece705ad684f3bd7dec6881d3ed63ca073ed07149e2e3c033e947a1bb617b84245e9427bb31b415a5f06850e4a4e556a21bde553032986d105db63a706c2256d0e8afbadd1a28d6ac18004d8f804cb5eafcf4d18e84da2b1cb6d85a0b6bee9433d2556d91e05b381b3874c8b6185fb5cc7eb0fc2c17bf2fb8c5f369ec846def54df833bb92b34e72d6eb83dd1efc8e57d1bad71b945214b41b61affac8159e1aad8b9a98749707e3d1d3714ca7988605a2144097e2f04f07e484535741d3e09612c9c9c556d6feb0621271f64195350e1c55950018d69b67eccd6024f6789277926c97a357af30eaff62ba490eb12f40167ee22176f02f4c880ee74b69414745ab2b75c6c93a5e5714808d33d1d409df8aa378c246f02789592dbd487093f9942b9a459ae2d4945b5509cf8fd910b42669983c9afc4c953fcb8dd9a57ccb8c3b7ed2a7c5cd7523fdd41098b71d17b25746d75c4ef9973d029e9b3b333cfa1a89b11fe79783d7686568eac42b6d2760e7483727d0fd95d5d75dc81a3ee2bb172afbbddc7b213c765ca55e1b4c154a61398942a9346b8d7144aaa9185d72fd4ac09b8fae6e6aad915d7731f69d5759ec4d242c52a79e09cb02d164d096ced2326fc2159a67b081539940ac41beb39a30c4ad41d32d89f92e6c4db2c9cf101ef27a9849e97f2eca2f48c3f1ab05f46f4244c82936885524d3dee35bf8d826089d2706fe3a3377d0bda202fb923597f7dee385b583c5552011efdbe53c8996255a21edd2de27c830d6230886fe4901","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
