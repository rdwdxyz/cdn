<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9c54c9326ea65c927455c9384fdb9689f4c45f3f8a08f0c2fa79a34ab6f7d78826bef469ec2a9b92aed8f92e233184cbce794333ea69c7bc1d859e19d34010a0199e8866223791a0e2b0a1bad6aedd287f3701969ae26470226954c4ad4504821663dae491469d14b67da8414bc9e30fcc31c9d61b838ccb9265313e6972b963849fc694a7c07ac7b125564a48480c041a83fae3646a80e3ca1652e9ce02f57d777a3dfcbfdbb7aef94d467418e1ace079fd22d18eb5f9e1a3307ba6437475a75a6dae0c2fd2df567376f94111476a83180f4ba3c4a5ebb7df8a626ed76b70c8189fb6493a8561e189f00cfa239b51d8579154a58a54e3c7c7b40160389e9acb675ff1538b172d4a784b37023e5f7742343b10c670e05f0d8781fe251fcd8e1821e4e9194cf16fbd1a53a6debb3126a77e04060537fbc125612f374f3b0bf74932c106fba0e031663724d9e170d8fc25df6c01b9282a19003b45da7e4b7fe509bc497b482ad82c69794ea9d6bb4a8b02dbc49baec4808252e8f25503d2881108d0aff5e89b2884f35f791c25f1b6ee73d87e9c4a11300c4737abdb5c0bd2c51c9b35d322769fdcf4742b6e7a2a3075c4f612195182aaa7d7e7395122d875e927efbd04ec6caf2c39a532e50124ae57bb99b047e9b9ec6c3d8fec7350f704c55d32ea80d6519720e5326dcfc245dcc60c0352dc0c6a218a9ef670a05e8e285b97fe7bf2e3d7d61ca088fe4781c8f2426ec3c590563246663bf0c548172a587e8e70aec3531948c1bc7c0b277e5bf1636360d7dce0991918961fdc0819b6175b3460463bb6b67af8f21e1348a03c1dac550c28c37e944e7bc29660619efc677b767ff423768ff49258c33fc91f86a4175a5a298b6af3367b4b75f8f19dd85ac20d07a49500902dbb1d9c0d9220ec1a878029e77ef884d7537240ff08b2426436acec66541541dd07e1b2d7f57f2e0fb00b1254007c54c49b9b6120712b62c81e2e4e563b7b719ecc4e4b9c3b6113c284f43501483d6251b863c77355c4782ad562c52bbf3194f7d0e25a9abbe9b36b2a6be665da1bce01c4c06d33dd40d88ef9ced4273813104485312bd76d9600a02f8110832c54ed17110a49444ed4d6fa31552b337aaee69233e6b14165973f80967bedca5984ab426081f548d1f96f445208d9cbff2fe0176bf811907cfeb4296e050dfcbade120509bb5822cc9fae92db7c6ce176ab4451de51b702751ecfd733e252e9ee8f928527211fe6e050a0714e62b85ec913acab9eb4d679d36e47d3913746cf1b7cae82cb9fb12801fc482657ff8efdb12a3283c83c36cb3cdb03897f13ecd99a73474dd66bba488c23cd30bb4a3b5e6342b037fb3763df2f776752e639a98a54a4125f9a66af364e173a7b0b890b61f13b1d1671dacf5c52297427294f2aec45041cfc61d00618cff66cdac872c12c55a0f3c2038e1a9a1cd2977fe409a9b7977247fc7bdf7f514f95c4828279f668244356988cefe2679f8ac916a24a0d728dd0a6290d261c639546fdc8f997fd62e24ac76e047561ccacce2bf1dd009a463a9d81ca37381b1583198b2ed2165051b76df35003a814e146b7a6ea258e39e1d2e6e86da90353170e8f0bfeda96a9b80ee39471c83386f0465a320fd7942ed757a136f70c59b607273204a04efcbbcaa7900e4166afcd5ef234ebe4db82c9fe41a22429067a97aaca3b07a184b3abe85fa59b1bb8a078cb8ca84f618794ad0b34a627539af8d49fc8a65f34e957a145544b1f67016f300d68c870e99d0faf3c837a963e231e2ddc635dad954465242a4deec93d781f128cc7ff27a067a65281d6f151c36b5508018342dcaaf5d9287d0916c4c54956b8d94d80e8322951ff8678c98f4de800c3500481a00f6fe3f28bf626f163dd89ab151c637c9a51e5d201af2a251fb9784069bbf906fce98264a14e53d55c986a60225d9931fce7361cbac9c60273a30687f7ada737a70099283d8d46152c5b71d312398e1c46d407a6b125f47db7a23aedd05bd76b5e05675b02b61f63a8886f410ad1866ed6a86d88ce1349aa700717c6053633732f8cad4462b86501b2a2fc8346c0e03b5e969c8898faf8e87c4c009dd9cafffd4c8d71970c57e5d33601e7151f1edc9989a41cdf032db48c8f4b129fb43b751834b819029509dfe7ba1b8053c02df8cc92f601f1946c2eec84359164afd42d817d43f2404034b4a13d66d0add18dff37c296d7817b5594a72ec21666608de44101405a06be007043720a92d40330f39a0501f24e61246da868e111565755c892365ef0a15954e29c6af15d44557cbe779c7efeab12d342072238645c09e9ec05b1d31bac41f3172b3ed55842b0cacc99e7c72164a062bbefd0df93497435d69c0b3eebd18831e5da0ed30264e9348b117615ecf0094336f97c088822d5e7120f99565e538f0e65be55b2162ad3a522b49497ceeeb8527249430141572dc294d72fba2d628118259937b7b9bd31dc4c747e830c0f7446517d647e61abcae0550ce03a83d071ecadcc94db35836eb5fa795f023c4f0900910cf301a947db315bda8b72d5b76bcfde0830fb4d1ba8f392c35e2bbdf3275983aabaaa47959783bda9514f773dcea4b8f9f1499728c800789e8bae33fb575a81065c01b016b4521afe26a1358ca2419f70883d4b696d21b81734524c47809909c922b9c0289c4f76fb1e40206a41edaa7eabdb29d22d6520ab3a0de3c4a5689570a34b4e5df787b8eeaa40743949d3c87482484b8def4d7df8e7e13680ac2bbf1393d0c144ae6cbd5566728b1f262169c4e6ffb093a94f66c31944364baec9151362a1580f991ced2df158537e3ccbb124b6eae29bc184b722f08aefe800490a7496a128bad61482508bf91fbb2f20fb189c41bd7af5cdb185c38693aef7cfcc8ebac1d570f680a77e8eb16ae82f7ee88a23732a61a3d8dd107467812ad162361a27331a305135fd0138ed224466db2f2244a612fe0064e837f9eb2a1e9a9b2a7e6216fed5659ed7617cb39d2ff9080d7083958e854961f89053bdbf3d51a40d2eec6be8533ea7cee4f1abc355323cb0d1d327059bbdf280736c5a412b48f4905dd67579a94e51ba5ad1b853eb8e5b7bd4f1c4c7281b9167f36236474525eed9f28fea83d06bdebde8a3e3f9656ed38ff13b1223241a9378fbe5710c24aca20f0bd37433813ab25231189ab1e6cbe00172796adcefc651e22751386ef6ec127548cc2533bfe06e6b962883aad6e3e6dcb421e41384f93048c643fada6d8dffdcec20b7d8b1a90781d82ba1bc698bca7e38635097654734e3b453426f030ebc982a6cb2c2bb1194b94d2dc89b13975d38fb60ca98ba430ee84f9ab5cf991b7d21349c05b3837258e806789a0eba4295ef167819102d7aee92443423ef0dca65bbc5d83a1266e861d80cf693310761a5017a055e735d8ee0680b19d34728df422f6bb35eedc488c3eb30f28ff91aacfd75f2890d7fec70269b2c1ae76c802473121a7058b0f246cdf0d0572e48bd9f88046cbc12a592b49ceb199d1857d5defba1c7e2b15a223116c5a677d05c750f795e360dd18c73deca330890864c54cafe7fdc1282700586c8a5b542392a08733a6f7d12ad97fc3e1654c93cb58cda9cc269f29e8a52532e431afd2c402db0048778c7f70d3a1e165011cfb51087d5b47e46c47c1c20206252c563b4da56ecf545235efcb5cfeb3a14a6fe82ed220c66fdd547a17ad76b07385cbb1275d0ca6e81426edf64fdfc684b99f0e4a744c61348685816aeabbaac08cdd5b12d4bcf498385fe53209b208548fc201a3c0c448575c0ece23985c3a8d98f6c013c6e028578076c0d80f61aa331639c4f17b3837dfc5d5dfbcc2677ad322ebf9b85fbaee1371cbd9abfa25881170db0453a98308682c69b3df9dfe0ba717741eb0d8c4d989ec180629d6d3b8b051c97897a9ea6e293907c210169e9a1e1d6d70d53b5257a78e5033a4fedc0c1615dca0321ac3e503b0196e793f557d87fbf0e83a311b8a9f9bc97091dd637a7de69b83d9b14e65645485dc7b161831cb84352dd0c9e88fd276d67bf0a9c450f492549639876ae7eea3cd41d29ed17de5d2f77b17fc9e286f20bc22a08cf5f1cc9c526f2f6e8f1425fffda0293a11fdd0b8b24bce6e52c0e7dca9064ae05e4dbee0e7c9bd80be928f509691eda637eea8138c1ce6c0dff5025ac85dbe453e122202157192201ad2cb7edc74b37cd781eba87b4d82c84c9f87590c34e228ce1a4290bd73cd734a3d822a2bba57e1d24d449311e5e92e0513d28ae9a7fb8b8853519c7b25a74c0258fd52bee640dfb35847247de5f200d947b6abc79ce6a6b4a0153140a62b296ee4e3c41df520e313ac3a41e0f190b70fcef101cc8bbb1a43e5a906680004776acea444a02f12591f8be4d3a7c2098942a101e88c0437f51a6cff36c7db1cd3bc2f7c706894a25b18c493df353d7e7268a311c9fc715e2bdd950ae805d23407e027d1de82833e65b5b1670b65bf1ae1d2d8ec31bbf35fa23bf163e53105f730fbb2e29a5212f07a233d9a4d48e66b5b82c9f5ffec16b32bd5cd99907dfcad29c8b3e9a124cfeb8ca9ade62a7b3c6b698c39848dd9526642ae913ed5dc765766489a057b2090dfbb8f66e697aa880870bdfb6b0a70febe4aa98ae683c06a54cced6b4486b91ec6df08bf43ab7f2e2f0ca30a9361999f6007d4158d0d573fff0b013a0ba9da9ed0fdf4a1882ab12213880b67f6c1fdb413d63ba3b72c6d9d5ed91f9c4b737944e364f444de921d881505f7f5c69763a502a5a39d7969f4dbdb039c6d63796351087d5b0a642d2df933d2ba1b925f7115b678f44f2d9b5561032978a3f1a73c2c74f559413b7971549e54d2362c8156449e1b410f4e38facbc5dbd40a642761cffd7bce06b4c923a5325b082beea4681d1d2c1603d3d8250c9c58b13337a660e1724a0bc5bd7779a2d654ea4a15895064b8839bd5081ea0708572adb3c2ed99e7be8440454c1e8a56e832a4e9c7ecbc20f2ed450e7b0a81a755be1d8a7bbb1e1ea6d23521f1a19b7c2acfb2d1e22f296b6cc98ec6dd88cf63e2142b9997d3659fba609fa41923f7aaf6587ea66c3b724eb4562bb6c50c8a9941c3db39d6b2e31f57ceeef245b0559a464656f29862ebe5ecdc438edc82743348f764fe635c1ef30222151fc9276525f9a2c5c74a27fe7d5ec4e826d56fbbf590fa01bed46d1eb82e378aa516d2fa23b0d0ed49c85ff43d0929e094cbef2a80ed8d07a7e8268a0e4281dc6fccc884b4da905a95fe29a28d7fdfe20c52d95f06c4d59611a1ddb7afbe9d23dcbe14c2aec3a396cf0d56a10a1295cd4dfe33f8e7c2e3d55abb2ebfad40f5fffdcceb7ace280c8aca654bf4cc9caf5dce48e68e96e6cc144364b7b72202aac6f5d83dd94bc9737eca2c1bfa99c9caf4b3071136fd30ea8c5dad210feb2ce5000aa055dea4d9396c7f0239352f3d6064c36349ebe684db3fd7b61c954a55991c8486450a924540707d28141db0e1d72661f96ab66a77d832fe31c963ae251a0afc649ea16003acb1280e5fb5a4065286f7e8514cba0d90ca2d9e372f36383fcc66da96ab4645eb60fe486fd770d0323e26c33269b084fb10c6127763cc61d1fb83a78e1e41c174ac6c29e19f07f876319305718474a5f395442ba3a562cea91e287d75bcf68bf0c266aee5ddb99cf7f8ba2ceae694253e1d33f9fea5704992275f0180a20cc85fb5402760999fbd76181ac190f445f007fef1f1f5001dd5b18ef9c032bf4c2048ee06545706ba0c940869ababaa4a2ace91466163c18ba971a7df3ad7746ba5e75d5298fedc173a68fc62eb9dcae5ecbf48546a6aaf4fdb3bbecfc84cc973ad5360d028dcd02767dce1ee501cf50453f198b74afdf4c7d5b4ac892fa90f3e30da24671b36c18819d197147f7623798318b77ebe3f0bd93fdeeeb7dfdcaa0a984639b2c46fbf3544f5f8413b6a5bca8f76e62c9bc369953502901d7988f285d6e260bf829f02247207921ba17a311331a8fbad9d900a772e4e84af57c4b16ba90b509fbd5c8a97168ca4acb95ce16f6dbf5b7e77be00aa58aa057c6dae28159e1791b45cb23bf73cd869df0b07cf581895979017850ae2b618fb0544e127980137e0b6e2d75036eeb3073875950d3510e3ca98e6b58fb9d3b646261f2ab345c90fe1b59c7dc024544c55f12f356078e21d59d6319d8d3730bca33348849b03d0866c89a78f75bb41ea92f533b2913d13457eecded92bba1f775b8e156481dddde5d3e9107c0109e0c2163e33184a5c076b4b24003eeb76bd3feda0dc1d5b3fc1dda9d310a242e2d860ecedd19d29a93c364af546cc3975b20099d7c60d430a8262589c38fbee797b780c82d68266a65b0145f4cf021dab5d5fa82ce213666185a7cc07e4159c675bafa7da37368b51a5e5c0b75399a5d314bdcf1050631fa8f4d355285579b7b2c612835988b87d5dd411055f4f0641e81bf347be53b20a9b1ed71bcc6b93147b2eb39555edbfd76ace7ba6785945e1a2e26534c4f3461c93e518bfd2870512c8f5133446e53331c56b43e1e99f32cdf4f2dc5117090718a12a432e87514961d6b35479c41c4818d80dede7f9cc4a4b1291e78d8899324349ebda16a1338b676646c3ad61f813178e9455d170fd9fb044828e9df38e4123cdc7733d5a14cf752dd1bcc3184469ebe5ebed9355ccbf334b46977b857d620061395f595bf432256bf731c2d5c513a75f6a5c147f0b30a54ec891fba44b0f7a644f2d184046da2c0d9c0029dfea023e69a0621a9b39aa5a74e0058d1324f93db53edb3ab5a0d6659286efaeb90913dadf11c3f31d1e9ad84ba25bff4b59f4cd17d203bb0c6c5c65d9ecff61fa4d49761dc1e6dee6338f51b77d127c7fd329fb660738c39d77bffbb6d3e5db3ecc5842b81420eabfa96ef1a4090d151962b456e8d41ec60a5cf6c34834d79f66e87ac4d86b1a379cf7f588810a2e937c60f09a60522dc712d58245d5598237f5410954fb8a1d60579bd55b0b0815e9a91703e43878e6a23558b222bc73038165be7da41e46cad66310b931e7dc262d5d203b983138419e98e38a8b3b2fea5bc8a98ce954daaaf3875d1e592ea654031b0a26328708f94164575d179c4785938b0187b7660fd1c47439567b125e15e9787c244ea6f4764ebecefba5b57439cc268d5ff9d92a769f266f6b84af9aa10064293a7185b67334712c17159250b0f3b11be54f55a97acd527c462e9ebce7e72c531fad59c774c04300b1aa710dec91f20cde0728ad69476cedcf70b1495c5e69d26430fcd10ee566202f2165589e4df15f6eb2c2b9a07a746f09379257976af9a0edfe3b6a202b01be207b6459bc27a251e62058c2d7ce3da10c7ac6812a6210377fdf44ee451f6b8ffae5ea18cca00abc76dff1156e64c44b11b8f55907745aa3397890bea73242e63275a16c1b249959e28a74fcf8c0a383fdfac212e75d0e301b2f55bf7eae8db2ac4cd2e4dd38a9a96cd5ede7817c2ebc1c60247447c7332e638b1c42432e5b7483909ab1267ca0fe5d3e0109f4f08accdf5c30c84638292fa88da16827c30916be91cfa072828020a26b4bf50b601c7c2a9fae1da319aa20eb69484a5d9eee7cd77226830b3e99fa71a63e361544e432a16e190c81f95cdcaa705fbc861e8027775d1afecacd50750ca7598898b5481cbb6790284a477b7202552ed62f44f4a7d9a152dacf0dfa1b751e57229a584848ca63a3579fd9cc1ff9a43a799edca204b4306cefa48d2dff562ae495fe617c3494988537300ef0cd5167055a022d96beb78a38cbe889011fb11efac3d6ee43bb781fe7edd61c3ff8de0a9d4e25deb923352fe1944a7070787246253c249b18d995d64a897de55cfc161fb7a89319f2c8ae7f04e8ecd91765962d33ee65eba8f24c4d06673469a0282d5625b51c87100cf95475394e98639b0c7843af7604f483911687418a081ab6cfb50a3a249df848d6ec13be604e76272430c3fb81661690226df982f8d7bdf36e17bf6573908856bf5e93a251c0e4d89e01d0d9a5a3579bb80b3bba4ec4daa800fa329c5969ee88c6c5a77fdbc69b9e5429672689028720c8baf889510a095aa61b21a44596c9d2f04ed8a4ef4a26fbc2d15f9589ae49368a1a77fde680c10acef1600dafed7dc4fc61efaeb19f7312fdfb9ae79e98b6c4e05024392365e5fc457b6db6ff3ae4a5f1bbb50883bdae831b83c8de8d19f8e25929c07e044afe910ad571659214e7af1eab4a6fbb740fe59337bb58cfd8ca71f1176e912960efea2a22b5f1c9a96fee82d28424e69942ee7383822ff040dfb74dcc3a0b711cbadd6b739baeb6f2ab7f283375aacb492a55dbe508a9742985330a486626037f835556f63686a407de32380a4e6f4a5aefae75ec46d4777aa49f31b9f46df8b73c8e379b63f83739392508837747cb33c46a67d150d3e1837fbe94f2d8a272c0c830f3df06b494f788a07ce3eb95dca0c4c2e793ea5e5031a71b0a2ae72659160b34db937b3bc15175c236191400696e14ed143114c7d709a8cc688c368d84b1bfaf461f1c3f6abbad0308b4fe3678bd0f042b3b1ea29e7d2d48b4970999b61fd1764408e43f9c4622b27137c72731481d348c7815deaca909ee9473f0f65d5377375f312c9459c9000640d5caa50f0510287da27448bb1ca0d11760089e196b789a08fb2dacc5b7df2ae8e31cb368d9db5afa21f76298acec75f496d28d84996d7b7c8391c599ad096c0b3f3d8772665bcabe1de88c87a268060f557e77673bb5112195aa0740fe7cdd888445d6e064c8acbb912776ba7b5a54b965e9533c21f646015c7d2fe66cda92254dd091d73780b6b810d3f9a55bb46c8e9165617f77135a4a3a11eab605aca1d57da0227e459362680c86d6837ab34e319a04f80a61a8a123f0d37c8f61da59979eb95d7f1a6b2983e3672ed46e92df4d7afa89be86a412d427f6c465f5e337d4bdd97f7673e3dbb80b97522327449cc4fcc98524de69e79eee5ca56dd675776d701a7fc4db97fd93033d26ddd8465cdeade5c3e24b47411ba3fb3de55f32c7526db06e30c8774ced26f3bd28bbb4d13d13f3a066bcff85ae6897be10a86c84f9e7baa3dbd71d2210005f1006700d6ad3509926f490b3f22d6d2de6c03bc2899c644a2c32c09bdd069c1cc24b9918bae139e5348ab82ab5d056b759520318a37b7b83c7860b3022758a02072b9ed04102d58c72719ef78c3bd8d3567248fbc499447c58aab5ef77156c6808dcd675bdc720c7beab9d621e40cdf42d9a46bb91cf42b09dbcae0794021f64bd436afece886a956486985ae445068459c45a53d570a319c6a55041393c76780e74a13499a64c3cbd0583a8fb470f471b538f397d2c1e5748d1c0efd96882072e77a292e41ceeda331fb5635263c64b1a2c24f983cdf039b7f322ad86ac91dbce3536a56cd2ae87401bc77629f7716f4b648d0fd07a276127972e8f49b5d4186957f5a21b0fdf61794e4045509d7372e3865c48a15e6f9aa33a3b844b74e18aa88ee33a06a31b6685afc3efc4222e35b7ee56a228aeb795d0a8d10d8f05d966d6eb0d0127ecfe415a0566b5421ae1bda1079fa07fa5206f4a7700fd44fc8fca94625e76f029936e33af13e668b4ff2c0892797dd35e1f1464583ceb7a7f9375a8c7de361378e02da5a44136e00e99ca6b06b045e2a6be7fcb807f2bc31f20acc4068d877f9256847907386e22d60800b424d9ed585cb2e631ce064eb1925700f24205309d39c3078eef4eaa953bbb60b1f47c537075b359b17820e73e65562fcb963eb518bc31c48b7ef34094f9a62b2bed074392815eaaf778c9976e38960014e1f532f526494219ab88cd52e88578376f5a8171fb825ef3373918e3e220d5f9f63e199b42af1cd3c7cf393141eb70b35fe66f188df0ff93391561fc39563af0c919dc620b8ff931e455609c1ee0bddefe4b8acc83fee910edef51eaeb1907986d9eeff61455fe95124c4e48fd39bb006086af232a09fc399038f99cb38db6643ac5c27a0033116036d6dcd5c05c032eeb6a7c7eb6197022c8aa971541bf2d18a744a050f6c4283b0133b60555be17b3de90e4c476f50223c1e2402329dbbda69522d17f9eac0401d2d94861055193bff2283cde89644ae3a4e230fc79a4d421227a99bf1697bfe6003b725b1b4a9a1390d214a6cae2be8f261c93c2d1d8b3f3bd797c66bef8a32635b5fa0bff9650b5e9bbcd6e7a1c67af70c1f64d46a0c626e315ccb921ce8f3dfe7c9f3d55e641f20990855e368a83e30d86b49fbd8caaa92f527f47c5a0bb8063405b945ecb045118c24e985a9d2b0a8093397940c44d77b74c2eb40dba59e2013e6d8f31ee9477fa1db5f5290cc20990f5280ac2900d47d80a9ab4fe29e3613919f09938aeff3c814c76a04001929f18a05e11be6522a5947d2c622fe5c85c7e97fd0cfea81d32bf233237fa5fa7c7833144fad3c68ca6c8727587e01d94df3ff8cbfa13cd44019a5accd77f868d1cb817ff1a33a3ef7e519fd2b15787fe614dbaf7819bac5ee53b658345cc66028198183f0477b28220551b256da7de1ba52d5bc5013b1f978d4b7f14fecb70b1a132b0d88e376754fed621b13a6253001793254763985b050ff0787b4da5016181d64d40b4c7177a7621edf9b47e2a96b067b3f11b845ed9a1ee9b027345cbc589d84f45f5f901bac1a4289960f0c3adc1991660d373be75666345965c25a94d94030c68068f7653fd5804762ba7a0ab5b80f88448e0ea2f8056653887bd9c8ff6d8262b6aafa5226064923750cb203b7158acd990315fa5e2ada8b8f77d78d593c8ce4e0836d8d476f82061d09a62729ffad33d5b6e5126df83a061b1eb769f0c4ba6bffa1a47950887f85f35a1ccf8f81ec733fb20883fb568dc5ccf55a4a01f671b3b712b995d24d55e855075f41b02022c4711a5146fc9f1d5e788891a9fe69845668c9a846de3682f49025ef4ff58e277e097911ede0755c36e2dd7575517bb6aa9edca665a870bf35fa56238be325b82b539234414f43837638fd7fbe06490e5b58fd12d592d59ec2be1cfb08bb4a81f0c72c53c3a899e77a8c536dfde08e9764e61b9622357a9a52bb9f1e094c776449a0a109ab1059eadeec4b94848881c1f722ff0ca395ce8d961c7f4db56ba079a8672a701f6ed46875625f9d9797537c3d4aa487a989d1553c89f466c4e6e953cfccbd9e3c6ed230e724838ea497f2681ce1eed73cec8020dfab4f511e6620f4c0ccc1decb0527fbc8ba9bbe25286c33dd417edec605413e46c149b9a6ec24bfd635126f0293b036dcfd4f1d51d16f256faca519513f1639c38f76d331465d2f3952d505740ec1f72843329ece8b92dc50d69cc9d18c0aab911431e6d44e54a45639382bcfbe21fdabd3fa67bb1727788ec6113a1845a8caf218ab1889114952e77d82592800b78fb3abe0d3ab20de3943535eff0e5654673329cf9eb0816b895ffe2db2d0b5e8adec0aa4d0fef8ba5a148594aadba9c10077411b00ab615d8f7a4db589b434fdb768ca632f7820a125c2536cf39e6f1eefc296fbc88996302743e5cf6196525b980489b0d4936e4bfa87f38b780b8a5d47deb181e0bf67dc0ea74d85347352d15a79a4a4d4317e7e63f72042dbc6e580a34db97c0d753a880348d542852ebc87e742a1015521d84f054e4015d8edd72aa99648cedf278f010d57c72e0b84d132a36ef64d3c23bc7779ca7acb1894c2fd1bfc490128f6edc00f34495a83e07e39ec6cc22c1cb2ecebb705c613a48dd811a9fa49836732eea725cc41fa508882884dc79a69af7df34fdf495d6b679008f3070de30ba163d2f1a34f6ba17dc84b7617d1d07a014ef535ab2af380fdd4b18454d026269d83ea90524896f8cba22c6f7d18266615b59ce3bfb40759d72db6030b622ac9a1fc9f4d3cf29721a1a3cb6f4f1befd4df177351c9be6df89e40a408fc54ca0b2afa180cc1013d841c2d14acaab05a3669bdc0033c9d3ab54e0fd02b799124bc2c306e41b3ea232a4a04bf8066c4f1acba0601c59170d0105bc8fc1730ed30fc148e83b783adcb0d9c3bca0db8ec24d32b62dc2a25f939120d475cd9bc8d77b258849a1fe56e78731a54867ec9f654048c99edd8e5b6114616a430b3fdcbdfea1a25d298c48c58d9f3dbfa9e92b2f4c2fc096ced1bca8650425457b10370b76c92c4dae86fbcf19772237f63ced460c452c8a5da2e11b1eb159ec93e464d3e204748d0aa18b8b84a32cebcb2b01445b9f7766b20c90c7a065cd32798fa3e1eccd4c75411ace31ed8041dbf0d54136c1175f4ad76ad50291af0853363d49d4ad76eed6074191f24e065ad1c33fdc69f120eb01b081d06a9eaad3dfe690df2f558276e2d70417bb794346b58364040c3aa2f8df16ec20481917775f49dc401741d9523f147e9572066752f18ff09cf45042a3cb5e6e895c2d9b1df72ce9db470661a89cd444a20f936555cd624b4299156ab3973f04282acff1c4afbcc7c8a43d572558e29b64e792a3505a615b312e320eca460dda4562ceb507bbc4ca2298ea873a854a5464500959083bc4c7c29f9db220b999305ae055470afdb5b57367f6c09c2345f2047fb5dda3e39d311943beb226fdbf968a90e55c0cbc61a37c3ddfbc686388eb6a1e5ac4b1b377e9d11fa6e80b99a99be8b81e66300e7411f197dffe742d78ca89999bfd89c4d12e807219a2212248cb6cd8ce114c60eaa8657a4aab4cd8e76ffde2eee5f7bec9c0438d100df6c7054f242e529d819374b840233f9bb9b5ecd51f33c386687386c5b59d2dcc777c47d7bcb458c5295e5b7f1a5fb2feb95eaaa9f5a3daa88ff68c02da1b302f7ef7586f95f7bd3203549a7367b9dff0948bdfb91fddfb42cab90ca78e0299ee2c2037bfc8182b5a3f6c9046bc047a51a28a35866f226842880f3f7676788d1b6eb9bd0b6116e20fab12fc164fd452b382528a16eb4c1750f3dbe1aaf4ae6407c1ea1bc3cf93cced4c5930c261cda2de39e7a3df83189e58c10c2dd69dd6ac76fdedd365256a3577cee432787d7086a03d71dcfb94c94dc4123779275fdaf26b366d6a134c7eeca83fee7bae6aed4d315ba15efd778266a8bdc3392efb35e36fe5c6843244087e53fab5256eb7cab861e6875f64477a66fa200d9c5d06427322b98c5104f58e672c0350188e3096bc256ef52370b658e06bfc55e6c1bbf554c116be3e5afcacbc4b25818172b8ef8b6ec151646c8c74af3d866f6a45f8d23ff464c385e5e47013dc920a397c165e9c18ba6a4253fe40807547684b7b15bb78cc1d38afc2fb47fff254e6f9a735b80248c1450fa2e49920a0482b0097e8014291d559d579d73dd0e6b209035c4ec1f644fcdf25edc85d3ee8aa2923659f9473629d6f27303fc8a8834a0238fd01147d949ca6d2201c507b9392c67f0774f44efd2d1f0f204f481ca7925113aa0719f05e5ecd6ed4cf3f295bf1b37ab10fff1a857d75f9d3472e4635cda204bdde27d9dd4599e0fe03ee9ac667577f56022c98a3340e4e97dd39c35914b5b8b01c555d375fe0e54fa570898b75a091521e7461f9bb59bfe073c94329706a309a223df82a925bfbcc1d3545ff2db66b2604a93dd7ac4634521aeb894a71d14223d9a79532dec3abc05e3e3c3a22dcff7723d0af5631d105dbc39032ba079430d30f1ff7f7265281e05a2a9daad46fdc2f8c9d4b3ffb7ab96270803e8f0856e647454c6a19083e7ee9c2d015fada8650aba2b35bd100115f6fbdecc5f6df2b730de401831cbaa129b9cfbc180c50f92a9aad6a4abc4be7c030243974d357a776d6482e097353bb94ebe122128518a1c554da296328dbabd469376db8dfc3f8c75d793f1af80c277b604ff852f3b5ed63ddd818c7c85767ee6fda9af628c5b95898d0eeade1fd79374cccc089555ed570307db0e3c0430b5f371a88a76d7e5edb9285fa56bfb01172683ccab6e4f34960322a25bde34a7be5b0f780c3767d86b9cb275fc77286c844158d6438e0b2fc3f8233393b5ce4cfd7fc6b34cc2c3f99b5645d676175385bc0a6510b040d46b790904202aab68c7d8ebb29224ff1a1129242709c21367ead0da4f7836a19e2eebf80d15dec61d7e6feffac5332c760c790ebcda2a41640287431c8bbd06dc80a2ed0f6aa4fa3503f704ca4e853976f1b99f2e03ee35c676dc7eeab5ed018e8bdec1e924a536c87079bb13ae500eedad5a51c3a8d88b9bb36e4504a5079c94997e326befbd610192b0214a8958cac55085d25bf93f968c9cd552d9109d594bfa7fb14a37472c055fdaab31dd4cf0663d459b11abbeca13b6a22488d2f9f76847eacd345923a2d4d8d12aeecdb126f10160470abc663703029c255c8d69c983f4a8deb1aa66be49c08d8aadc1da43926a64a4181f33293a2830858f0b25137d3b08d019b7aa8ee0a03ff432e7d7e3016eb353ecfd350e5553979f08e5d96b8925f6b46daf8f0c18fd3b5473a2b5d60291d7c27f1d845d16995245d74c311d851e42c4376b2c782029f21e5d96428c6469fad31ee97f08599d5f545346ab4797afccd394352686a59b149bc4df5f2de30b2c4d374ab0cbed4e83f836507c33527cd04617f60a78a69c89894b1612b464fcb9b39d51b177b63f630a3660a1867733e938b3c7dc76f01bf29dafc37114e965018c99ad735c9ef8ce0c349c06a2a5f52e222b937a01511b33261e54efa71a0af88e489536f9d6ec2eeb761ccd52715c2a3a29b08670e636560e36686001afaa9724428a54dc5874f4a2e4c47297753df9a6196fbd8f30a2f5754707b58eeb4188887780eb29917a2b4ff2cd473881cab7dedaa472d82a5e9e38b9544ea3f128eb883d9deaac0728ada0e04ca770d4f10d6645e875e7b03c3997a56c7f188ae5cd1fefc4f25138981d41773fe4424330b8475ae18893dff6a9f251c04f0b6606d6579ebc251ba7165da30ab22507c9657d23fabe4dc69d2f5437bd43463bf1b4dfc4865d4a389788d891f97a641bbe32029ead7a385362c4189cd3cdb9e1e6fdaca6fe375958d50e3b41d8fd81c09f57043dd742e43d48937a0c62895851503b479babee0183c5bb78651fdee4beda4bf3990a13e338da6368a9696147d07eb3a7c10ecfe0f22a84022947df57b5556a52b8c8c9865ebfd502c5d909a2b3a01a00eb5c489b63a1e609a38306f8661db3661f13223f91f81f69eb99b2261a8a5056211f88d6d73e414d09295d0de0c88994eaaeb773580bb1ee60d31e0593ae3f35466648ba8b365c694008557da42dd772c3c1ea757db743f8497235b2dbd4913302368d48209c3578d2ce7ff42c05ab1e4116f1b8d4178901d71d1a908dceea0d44b210e1311617a1cfd19c1559b833a252ba7352efc21d86e4daac2b9a5b150245d703aab0241007a63f7d80c16459a8fb7337ca1554bcbf4477f062f7d39091c70d39a78678a8591af7827755b1dea4db9a29ee192afee6acfcaeab195e9b44412c9d9c1f40b52eef98fa5143fde2f1ed7f0ccee3c77ae86e9fb5ab6e9e73be7a98cb870f0a9242dde931a8df93428b3c0e507d257648fe364040b5fa308e07bad956bf2cbb1f78217d78042132ccc299397b31b36492a217f7452ac3315a08007c8a5ac700be778176f0cf27e43368a6783068cba2d08caef9e5fe86515fdfbf950de639e0b95b84abdcf0330d967551d173743b27d39603ad52c879d1d06ccd4b9fc50f874aef36e00c4554280e7b10f747c7d2357a5f5b0a48ae24635d848197606ae0528c651ef71bb33d7407c1fea33c382a63c4412d77a386b86cd6d76d982ee230d6b3244a342c923abff775ce3ea6d1f1c0b0db0ed610cdaee38ccf133d19c0b3938a4d3d29c3156634ccb505c847a46d74bb2a470f6bacbb6604079dc0ad9416a37982fe4ab46bf6cfc75558ebf138c4e138c1add906ffcdaa17bcd47fed7ff8d996130b5bfe9647634003ff9e2909965ed783c995900029816786f3f06ff65ba23636b1b90e25969e2874d378a7dd2f10e8245ded88d39424a39ad2cab6080ef2957d2178fdba6c8ae3678807cba6bcbd550214894890fd02fa3b2c8859ddc9937b333a50f865f2c71ac424a66195973c393cc29e8c6b34304ae2d3e57426e33ab6facdcb57d71b0c030346945ff05f7ee64aa26b9583123485016c08f94bf498ad8ed322d34251dab0a1540a3b05920fce03fb26927e86f3be34b76cf4c1c5a74a3240da189964d1e5e79c3e0610df6c4a553176291abebce8ed0badbdec3322714b7c998e2e9c5b7bea00d6c59cc741a3a9c1b570361203b1f3e064ac171167d145b6f44c67879dd5e3f14abefa29618bd4ae4fae35c363b3c09c28219fe5ae5a564405ae625f9e235bc2b13073b39d0e3eb2279e3f0e1db4843b50bbfc3230744507d323346d92c551c62b6531b1821d39c791424ac16705f4799302c781b72f1f18e28c1d92e19b20ed174e1c8f05ceba3310afdd4a1dfef1e2b6315a6c0cdbd8573fd8c77749506432ee5479d7cdba79419b85dc0f62852e72a0f481745a1b822c25812797706ef3508e544d29b9ff814ab5f0056c855b66ca66b4b02fe7c6bff58c45d88edc7d860b95c3f7f71128383291ba297521a907e4120f84be5a0a287c3863730c6152f233d77c56741632279513acacdf0c335df98c1ebe928ab88e516a53c657ab90e0f87620b2d44008cb1bdc2acf3693d72814a4c89aabe965f9687a3c6b7b77bf6e9a7ba17f65fac71e5749f206ff08b6d20e22866686b9a4769be46dbc86e103400f69178248ff24b0b490007f9b940e14ca1f1f928c963bf80072103896b1b696a719b51188020b56c369574aae54069119b272e731816a13732e70a78ef7076ee5971ebeb7200b42cd98c72aae991d528bf55df85259571bcd6e9d40b867059ac2345b0dd8479f36d82a710b27400e09f2d777ee3b65ea9669d854bcb60c71ce00761b6abfb60ac960abef483075ef4bf997ef0c2dea3dc63806c350676d49be1d657aeb51c4dc2c937adb490ada52c0f13f2f0b87933199b6cc0bd405f0de752bf3803f105a04194203b771918ff76ef71619bb5565dbd12cb55b1d76193f4fc69903c896d75981d11deb6d86cf5fc23d455198e70b4ada2fa81f29ebda31b92322121a3996d5b7cfa65c39ac4a61b3e572786d3fdac826ac273b9529b9eeaf0019b5b785384fc75dedee7c4dff8a8e85c74448dca9cb42f9b7c4b8715b3ab3b68911cd8f54fd8e4913a2585c933a6cad24fe832842ce1c13d1572c1c323710a13cb8c34f2682b6ed93f836a5f108c26ded2ad867623572f2b51e84a5a4b36748b32ea1dd5342be5733c3e52b7872ace314cb8199acc6bdbe6378e2d9c5e50f34a0e8daea2b464454314ba80ea781a0d94aaea67928b839530555d357dfa9d7f36df571f5057ca7e861a98cb958bc28b575062a04577af5b515907d838f34707ee5995c788d64ce8af81b93d4e7f71b128d8185ff5ddb01394cb79e86186d0811081a9022fb1a70ab12e2c4a4065d159aee18b00eb7d65d9620ec3818300bc658c27a71bbd8408780d18aa4b0d94ff169d717658eb5d2c012127c812dc9559e894c59ff610fa99749dc1617eb2d830a5b6e135ed6dedce9055bb91bbfb5983358f536433865215ba205c444f3bf8b2d37fd255629de4b92f77943924458238e4d49ab63b793e43e1a668d3ca537a58c42cd6bb00ae7e0051329f256f07e48fe31ac7858f54861f1ffe46bcfc4666296b807444da676c3497bdf25eeb7206b425d63e17dca83f5c090d26e5397e4836504541032bf3d7b2961e247e22e8eb154ea2848a88b158f46302f4a14068233b9f1db28cc6f042df6a7c32064f3c537d08afa124172ed49e59bcf4651300811c4f81f488ebef90cd23eaa7b2fc7d155441a8f57b78b0990e77344e27cece66f8af086e8191cb87776a9584868cd6a6f00ea6c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
