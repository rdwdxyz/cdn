<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f40e2e6116d35fff7b5fbb5a1f63966f643a878a265c70f821754a3f7ab1eb0c36468b7ba4efb8dc4ac87d1752e1809464e0805b19e33df5002583cb20555c67ff3db77f3eea02e6f4461b462e920d2915f3a6c6502fac3a1f74339f6dc148d4f02a855dcd98b4d4937fdbf4a05083f421e52be4c4586c60c774cc3dc6176de68d0f4bd35469480efe4c967e213933a7715d6d9cde0ad612aa29ad9af16c56aa504d7444ab4d04df9c9c7e6a5beca232d216436673f19487bb316f74175597ee15963067ce2ea7d2f76caf7c357e54bcd84a829a1263939a7d597087b390c2a62e81abaa48a4496580d88157fa5640082101a2cebbf72fa01e76f7b716755172e6a7e2ed8a98783e413d0eba563f142f94a72befea3b89e51a5225c1a5385c70fe9a8fe10111bee72b77691e1b4b02d465d4640b5543fbd17bee4866f90937edcb3f29d43e627b4c7fc2ad8e6d72cb8fd6b6b51f0609487b861b6dbc274d9a4abf42774cf196b0b740c6ada9a4d99dc36b4cbc9de2a08b4d35a19dd2a5b3abf66e74b6c5e409780e9860df95f0e0f238cb82078ef8c1274ea275f4e671bfcf67d6604c3278b1c7f559e08b39c74d0aa373580287c8a2aa4a807a1d2a4a0585ddae43286ae4fb5b92544928b27453d530a6b1a410c126e26777f97d6baf5feaa0d4acc74b4700ad50f27f6b2a0665fce71eee9252abb1575bae29f53b5686be27bb3653b37697f51438e196b948252f5bcd0b3702ab5df3bcdaf772145bfc42544eb63d954af02446302e7861d052b8e65cb938fb4a8082c4d962ce960e40d62fa3bc2ab8858c5d01451658f6726d565fd60335f46699f8218ba8b2bee2a482c90e92c6240c16e8a0075515ab7c802f4dd139377f43c413ede6eaba7017c733a7623ee4cfd4cc314b989df44bd2736c01ffadcec2b54d316aeb3238c70a843c40a02d0555b8c651c59f13577f0876e4eb2f15384cc7ef1e5343b6c1e428a06ca43335611c0e078cd91c7bb50678da93513295114c4ccd0f782018e6138f5c239dd39227ed1c304ce096536c458beca4d1d3b9b0fab2b2d8e24fa3b0ab50c54be838f54483dc2881ac2b3e45c2772e88138491eb68942acb80f8cd7e17d49b355a4cbf3833c04ac423c81ab1519830872a66324184892a937ec7142c3531aa91b4f831a01bf16bad6cc15d75bd1c93a435cd42b75c848e12fb303727b4afccb2511f1d073906ef233e2f46012a7c66740fbc3b0aa77de89085065315cde108d35f0e3b4ee94084dc85d898320a238eaf30a6e2e4beb00b521201763aba33481cb026fb340631924bb1dda8db65a8ea023bc7b4979ff6199abfa09e58fa77920757ba11c0c4c952a2aeffb99c6f47eba60a3b3482d4ff160048feb69cc179286ff49fd8012f7062c383d90367af582f8d024e80a5e67356d0a0ff4c749097093297d7eea205f3a72679e440479a40c71e2993c7fc093fc4dbe61dbb33fdfecb54149843397ca0c188e2b0b0068fd05559455529b0f9ccecf98a17418aa1d1b0fc0f82c1f0962cabe13e7bca2e78b815e8b30013e399d6366a6ea5431cc6d7090ca08bc6e891e868fed3246a6645b7812f643d7c4afecd91c502398d7365ef372fc20829083365f9c7e3834b9f9ad22ac1bf33f88fcbd90f0e45ad9fd1b3c7d9ae3cd94521c0f7dacbb16293c980cd774827104f4dbdfab9c85b8b18fc42132d535a426626f6996e5828a0d05f971fe06931803791fcc4211a9e197ebec223afc393685522b541c296d14ffd728e47913ba1c8e93fe0112be147a7b31d6e4de4216bade1b477f73e874927e7c46f6c34a08eccfc45228173f813014f13543f6d8e9c0693d5830c84ec981d42edaf081732175ae8ecb2abf130619a558869a721cd08ed548be4d2456592744d5b97e06063bf8c61aab4914620b147eec46b70c8dfa5f752468dcb981004c389e7e73b2adec2ff749018990517d337fae909c7cf52e61ad54cbed0b38b0f584b5bcb5fb1391caed16087df11e8b5eb64755233b09499ce1606dac914aefd34231ff7a136a7b684c6c1d69045b65c489928adc91b34741c22f917ab8dfc666a37bdb3cfc1bc1a82fa37842a39e144c363b0bccf393858175812bec9bd3570d80712f7cd2320d08d9a3b189dc7cd45c9d9b8793ab1ac0d41ea98a1b4b7cd59e066885109763bf3e7a81eb016c094fb9c08a46a569b6b9d052dc7877cd9862a7fc7e54e231a689459b95b4e6cf0ed1ef155c029dc4b858b4f0413ede1918eec5ed477fc3871e47214696c6ccd6acc1538229e0a6bccb0490729031c5d1f86e25026ec13d6fd94668cfbb8bbc944f0d906bf7846acb02f586330b8401cf720940fb35b784438010f8ec2207be9438a09f8018856dd1efea106b592c178785f130b0c6528bc9602eff880f9dc71824ba1578ef78f0e7f4a6147f6e940f2e224d0e729e282a7c2123e77cca07bf50731aa059c06c54e799d1311fc68679f5abe2a17bb8fbeb64325c0367d1c0d7ca38f0009385b285fb23572e0a3cd6b3bfb6b82823b5ac782d11ad45d90fe07dcf96bc0caff56fcb0d11613199ee0182d2fbcf234cf2f11769b0be8a90653aae105b2cb0980fd64e6a8b597459144f2f0928c235a98e0be798354d36d923ff2f07988bc0cc8d8ad9492484492b9e71ddb3b8191f4d635c9d601ddb4027e143f8827693b4676f9585ddde67d6685b3d468526749f592d5361997a30319274ca6bb59014b09c602544257a80ce58c6772070f53b3498ed0652af33944717125cafa3c326fbc528750c6387543c907190963a1a9a3ee5d0a2df1e73529541246740231e8b1357e81eb92fbb2c0827e302d00d1a90ffcabfc1bb3b14ec1135c8000006dd56c5bcd1892a1fe5d980a2e6697b7cf391cc26e033bc5a6b36c3ba30875c78bcc7177d8982628e11719e6a83c7ca712c5acb59756a8a631c1674e437bcdd28a625684f2eada7c9112a9bac897921fa93f786dfab4685f1d3695cf255f81afdaf563665a18c55756e9871b7c4bd0eefe91d945b285f51ec52b6a000204fcd288ee93fae0c8edc4af305f621021896d645d88cb9a98facf9b01e4f3f08679b299ac70059390bf43512409f356559b4be72cf0955270f7edc859d6b626151d0db792509d7540c56abc18a4796a0af6985a8fa745cb2d7a5d370c8a2594ee310c5fcdc9312ceaea52329d6aefb031adefc3255974efdb6e12f6d48571c6c1574d5c12397e3a8e5e1db133e35c2f6f725cb0d75d0dfaaf44b4be5f1b2efe7da44e8900503943460e03cd3800fd30cdca712764fd7015fc39b32bdc810547244edff57629c505a7be02c358fa8c01009044bbb77fb13cd2f5a08a8f3817f336c95b91579775d40376be2732cdc6e43292c9cccfd33ee823685250c407c8d330e99dc587cdc872cfae1601e7cb1b1bcc6b6f2e68c15119aa261ff7b351c9a12e83fc992d3c7609f2a7df75e610a9bdea58a7809144df0f73fe0c0a8693c38a635122c94b35779b483b5322e1013f9b0f75635c8f3d873bf9c51d5797625abce7eb6b40d5c077a36b27eb5e7d4724f8bce4558eae3709ea7aa100c08353c0a1e1248f662c900709f1959e244e3bba47fc6f880107a1bc41979483ddc72626f18e89d1ec384f2fd71baa4168cd54db291a6bcc419869977884a231bb051c576bd46815bbf24d46b9358715bfb6f2cf385b040664941a829db2b1b73998964ba0e6bf837fe63681a2e0be0c363c55dc03ce2d05a72cefc9caf0bc0d5f96a0a81c522b225f093f2000b96875259f0cb378d92a9f574a3406d970627d2655c30d935ded3794633d9ba8abf1d854e30b1fa5062d050d96df4ab82563b8f411d17b1783564a6ce82d2508e9f129aba35349f59402cb324ff18e793b2603d9114a104ec1624aad1aa213fad3b4326259aaf71b32265aac356b2dbed6e706d197bc8ac4d1bfc1b32f50ce1b6909c0264411041319bcd2879355a5d00e76eebd0c41211f607423d3353394d8127d3ca025276562ea79595fbaa4281d4db46f65b9d73fac4da7ae1a92dbde6f4a9573970e070afc3d37516bd266c3b60c354b5746e97b03df536d67fc8344a3f9bf613e6970fad0e0003293e232c20e89efda5b40f357e62609efd5eebf236b85f5ab82dc69aebc281323a22ce7cae2581738a87a6c1cb4e1ddca6466462ed6015972370f86a842861f411bb60a6cbb7bda62ff6c8199ccd3f36eb8c88b98728a1af62b8867aa909be402a2b1784d3cfd1ca1acf62f0af476b51bd70c25798d6b7e16d3b712b3636e5b4fba8c9b587166d246e7399095a9c967f4321f67ca4409df0a442cf02b9338ec613693d400beb99de858e804b5545eaca7ea086a0b79b2971c05191ab7986e4ab61835b6710091e2c97b3b469958b0618ac4acc5a4dde1e9c2c99cfde690c2adf6cd18978ca15294db0523dc5e2de456d50236376d5b113e4cc7b62f0a8fa7f39b4079e1a9904f0472c2cda10311c72d635439bcc18b7dbdb057a58fd39df0faf59b38768129e9f2fce9b72ba6d69cf514d4eaef24aac310e8ce5790deeff8f5466aea275fea4e0bb8c1941a4514a6bcb03baed1625dd70feb31a8f57c8d8ad64fdf1918b9c02828e1a350c81ca86c5be40bad85f97cadf1c72f798a7270fbe800f8b0d2ad9c1310224795d0b68b370100aa9dce2d91c9247cd71c06fd7d96a8bcffa4406e64e3704940ed20440654ef04f7df6bc9181f91de70d24708221ae126bd87cf833fd65da0de8c53c46dece24f7a35a17ba912938efaddce736a3d46eb6c490aece993b742104d237c073512cddccb9af8856f3a69d9c25db2b117acd0f5b4d0c1b33095ffefe0ba5337211703c9a6c0152bc72bda9a05a65b96604223e821922103a6332562b76939be98c902123d334bda1dabee3850425bdf8cce65d2eb7c46b1995797656664695bddf7d22c07926650ece46d1de8c32ec3f2965b7e40ebd139ff2e206632faa8e3640bc7f30cf122562afcfc37e588d2fdda50dee2f29204784d44f21443f1247a1055c301ca01c84fcea2329576088630f18ee0906cf0e17bdce3bfbbc5761a585c778ecd0a201e6a9278ea31f37c453c7e9a6d524a5054eac15d06f6666b48af4f5421250d9b4a1dea6ce5413db4c9cee499a2d6ab22b3b659540846ec6f929f4e214be7db062ad8dd417b2565fecd82e13195b7a07ab966ddb46e859c797ff8fcb9cf92edc0dfa7bf4331a88abea1405b0437b447043e8f8e1035e2fb68a0ff630159de237138589dd3875c0cdb42c8bc6f5a8cbd63b96b2ff3d62552eb0d96868c9867ec36f2be7499151fab21ad9f1529eea2530076341f9db6775e871a3dc7127528181c64df023ea6fe459275d8bab833f73c21a071c07d5e2ea2e54064fb5da47fd14d2b39b25c4e1b727b1bdc5634e854cbe1c6da5a62ec98bb0ace79dfe55a244d43c3e7396a7779662abd77b9fd250894f9d4373cb21fc3063c4d274a1fbe7083762576012cdc3adf1e438601e01ead1c92bfa8f3224756f7a5fc630491889f4ce79c84fdce9e1ba127c090f971a654b185cb5ea758cd7189ebfbfa154079d69468dd632120dfec1a84c78a3f4317de6b8661a3ce627768b4d5150ad179ec7af842c52caf56ae8351f1f58b8f5758c13422df6e18f3b97970a6bd092c2951ea53e6dc4298f721c3c672741887559c9c56a259b432f02fd4dde8ca686fa0bd7d335f9ec04895b09a34a0af5009c79e175e7e49391849b0a5473280799b91c2c59916ef2920060218ba3c87014f5c1812b3e719400802e7c07591cec69fd186e06b2dac6656c9f0b1cdc925b9a1f3fdc9e007e90f0f5c08be01bd973958a8cd4fcc234ed0bb5b24b99d9c8d71f943b93f66195752ca8467e187e54207b3dd3f48b7754d6994ace1807ea0eb5aefccc6d6f87a1b7d48eb2812ec0414e2a99accc01bc36508a632d9938cdd2f7e96d5d2d5410c8466151b1b07b15497056e70415786596e1dd27b190ca621b7209583c5708b9bb1b67cc3170c7903fb8b254dc2b1d68b8abd56c3e17e169f6a18c868108457a17a5097a44b02ca9c4003d12a4bba784fcc33e92deaad8031f600645c4d9aacfb4681c0172a4cec2e818c9b6f83159d7860de294ae84dd9de19b14649144444701d458d26bef6ead63c204cb85bd526e65bcc696f7f3ab0557c7b4f2ae86943eb62ea85bf63a66f443771961c1b28661a9243c100298bbd09b848f64a16349658332a0e5defb870b325b42df89698b84b4c1ef3df7c90b2df2f3e3ee8f0b80560bc18af493761c6a378706ec47d537859ec8124a5f9cd0d529f4981c7d8b64783ca650352cc3a80001d8f1d0127183891f761254b34205419de27136f6c6609f2af37aaf7a105a0ad660dd8937d6ebfa9414d9295244f69c07d600490b73f6dde3e390fee3d9ed2366a6a7ac00c33c50efb38666fc064d7d5cb24fbbc9467c85b95605ed431b28505bdba882a4e00037cfda9c067e2d6ef9851089989b8a3e961f386670aa495afcd1d6c42921a266f67d7b59b331364535999cc5ba0aed9755b7f515d91e0cfb577b45cee01673f80d4f18ab6cc779431b4b9bfab166315aedc4ee3d42b60a516b3fe5f12baef8a93e5899bb27ab38a516405edc182efa57ba51457c3d9de10eaeac43a64a0a9716f58ce9d0ce5dd3ddcc8b8fa1200a016285f74d73b210735823e6464f4ef7fde6bb8ccf5e175a35e8ac3284bea42e20880e22c97e01a0692b196444e6045c71f848a248405625542041b59a75a10ad2ccbc8e447fa21e5e01d474d960907ec42888a37c036d077329bfa9a4167c952b4a4c43b3c784f85f55264fa3f1fe2484bab5d3b3f2f9ca4fcaf3d5bcccba7feb4ea1a8110bb28810514b235b3bab44a52c334a1b865ffb2e70084f02b81185c3b125a56227dacd21c84e1c03c461c63f45d7d6c6da7dcc222a6cd5a18ec05f16b3838a903ac74ca3213a0b876a5b91204a39e845562489262b4ddd44e589443a9c2238638320d6b51089b31d3d59948e843fc5f0c8a133e7159aaa465fd6ab39b79f25f5548220e8558c21c180d59217dfb19b7262282c4de3a5131e1ba421e601835ccefc2c793a651eccf25613bc1e067df03f3b16613ce5a98a22705b3a2dc67e4e6ff9f9549c39712e40e712b79f72c0be38153b7d550d3072c0b7f428a991c51d2dd65866178841360b1778b35bb1b224c366e57e61964fb3305dd45cc0a7d0fe2b83082d45cd3b4d6ae28f57d4d89223ab56490a3fe438c397a4c3d7becc386322a4a9bac6af09e60e7efdaa0dc868c46ea0a14584ddf6df7bf7bc76486955faf6f27c09f4fd7711504b9168f2a709690a6d02ad759ceebf696bd5641bbad86fde3d54493d991d2e6a8030fdbc713edf8369a52405d430ff777c44ed4df750ca1591a3bcb94b696568c7e421d43957085cf9ad36f75ca9db92c6099d05df37f5ce60e45198ccdcb509d7efa4bb9d431634dd26f9bf462862af2bbd5f018a84cb9223e8e61d4a65e6f64f51cc219daa5c56b4e83720154d17211989e098c85fc57675bd924ba9265aabcf699a0ec488b4470fa1f5d52a98e67695a5f330a57244d7134bf968410a000fafc6eef81efc217c29bfcc1cf8ff4bc1ad157984884fc679fe24cd32918208949bc1b9aedc9865e33241c8c18dbd38745d79d7b70fb5a204c6efd16859d3706bdafaff3003562075ea7a377a8a75fd84d350758240190f024618e85d8e28aac80425bc295be60e1c5f2dae9a0ff2739bbcf2b1f7fb001a6b7dba3c8c114cf613467f56162c387d26a52b0720b7ad6e2455cdc55d9c989a32d7117052c08c1f89f0ef5791266594cb8e20458066eaa9032551a04fc66ef84f5e77886f0bad997f14942ad95906ed68abb8d469b43cc2b141c88952ca0e7641c6ce9534a8423e3215b8a08a94f6eaed5dfc0436c25540e3a4f9b1001e0c892c95e0666ef601a6f6e346a981e468ddc43e66654e9f3b2c0d21eabdc7dad92edc3e5f4880301f4b5c4bd7557f9f06ad5d5fe06fdfe4dfd5e06c080b31c57882a42bc880e7a06e65faeb81357a41aab43e7a45f5a981badd0fa3ac53d436fa57c281142d0f5faf6aabdba43a0ba9b5c558d80e3755ed30bd54829fc3fa148bc9ee16529fdfe89c99debea6341433e38291cd3de2d19b6e7e8122a7c49c3ee4d32dbeeb247cfefb8e12392cfa7c23bd86c08ef8c4fdff209c33b292ded35bbfb45478a5927346e6059ef89afdbcdcb8d4d3f23b01e0c76f765eac174e800aa7cd489c001849167ac79bf3b0f50214eac1dd07f53ac695c2b76c318e764e513fae0a856ecca68b26dfca2699b6ce0a899f3be7b6da299eca65e3f9318b7f589c7d2b35272830ace6c608eb7748cafc4d75c15e166e139c93506eb3bb1996f12ea0042e4154722ec091ebc4091521302a817531923a6cbea6339eae8f1b57bb27d4226f1a1e858fdd0390d25e231d85eae30ec4d24364ef0b0700a41c16ed5df4d9589f6f51e18f8781e8d620486f7228fa48545aaededcb485d584c06452ff074b415b046db5f6ed0bc617e2f6b503ead91b3e5a4266ccbcbbd81fe4cf466f0fe8c16f5cf58c05408cab021777b3ea281cb40107dec14ab83a4dfb43174ce1cb48eca28dbac8798601ec63392c09db9807e70add4234cdb316656c1d3b16272d0994175e0d6aca6805ac803a92a4105f48d90397948901a1f71b448db815bb829186b44ab4223582d8568bd8f6f49d5b9a246aaa5940fd1b05b3dd0306a2d6f9dad5c88cfc599a81cefa95e125092e83af53e2ccddc2df68bff5539e030587b9cf8592183ba0863a051ad55cf7ef353d68b050705df57d0e5eb05ccc893f242d8f91aab01cc265499e77a329586e07db87b3654642d131d44d58d1efc4bc64353992a9ce47518d997036f31401e9c93dcc6754c517d4b76a7cf5e392413fe9b43c810dafa4acf9a0c998f4d0e0599212ec37f1c4131c0a3ac30b4a68edc193b2f4334425350b84e2e992939c603820c0e652da9037e0de430e70904cb2604df767fdf9ee546f740918ff3098e911ba84f13d4e8dccb75cdc7f8f022f2915a227350af885bb2799696e2dec996fb8798bc56cb1166929f19225e950cac9a41c60a613dece3ff249980a00d5c790fa35a8e058ab58ccaa03caa7a32e4e483e409febf86fce4b8cd0fba7f37049c8e8ccf2855181f3c4b8e4b27b8e5ef7e5a18717a9eb7e5d54dceee329258f507d071efc2754cafe229ecadbb70040b3e70ba3f68061c71753c1bf2d011f3165357f0616cadff7912d3565af6827aa44ba3dd76182ecfcc211dcb21cada0c50fbb13cebff3852f36f2df9753f40aa729038801a84898af76c2192b39dc912d98d670bc1dec86e8fbce34bebd1cd26428a5ad4c4200f4a86e9a408c944f6ddbd06d0a631ee239f95c3ac9ae36fb490b8fd6ff7795d7905678067101966d4c2dcdf89f145305fc4f00da1534a5393d0e25480180abd0ac291f745700cc55181bd2d68add913b6a1fd1ed144ea17525e188009dc5322eec371cf178902838f7296fd890c3ad1df5af2aca3b3911f02ee4bd7212af0181f4bde22fc4df10c2fcd26d0599b6cfdc1e83a89608c963a2321847150e510a0628e0138d9a459ca57193edfcad27dd5f21257e3ba57cf312ba5b8f54f76845200dd8d819d1bdd46d9c7e9b6364a24911fb4e8a5e6300668adbbb0f3c0f3187323b8993cd6aa3c2d77f25ecfded805552d24bd970126da347c05daed966e168ae9d4e9092df7bea83c4df3c25a85f057429c153afa87b04c8317cda4a329224ec9a325a5167a823365325f8be90f75c9c483bd7cf69c8767162859e6ca6afce0117175be8ad0587e7068b599164e7acd556c9a9f0fd7559284c2aef425d136126ce5e53665f48ccf0e8585053c376789835c38c023a977bd44856472f4a8b7a75659b57ea4febde5cac46c1ce92fe6950cea534a03cfa760c2a7d832207735259964c2d5a0bdb22df2518cc1075fafcfafbe13a7e498b933ccf80b7d666f52c5da37a9f42129e8c3c65c599f1ba57dae560b99ef6ac558a1cc4b72e1a514ddf12926eb71375685fc4f8d82388887b245bb826ef5f9420f0c653821a6dfde0b48b367ffdc0e3b0ef0b2c0c6be4e249f5c3211ce44bedc5143efa57a478e0fe81da67c62633a4a7ff3e53341b82a68a1e4261d3d94ca802ee679ce9d6906e3eebbb4d70334a88f526bd69c9f8032d1c8f06762ad4d5c5935ef66fb9bd2684bb452acb0f1b38d105ef00d1b1f5e3a288b116ee3411826cf5bb273953f64136b10ebc7b652d0947e86961843fcffd524a28c52a56509050086386d209258f7dadc43b5c3d9db1c409496f3a714af65b17176671a6fd982821f6bdc2b8be3a4b4d57cf6dcfcde3a6eb84a59948f0c0c5362fd43898de87e026967a709feb69815b726e1ffb5abecd06bb4bd670bc01a2693a076bb290fcc18254079d68f48daed0d9900d3bd6af971eb7632889fc1c9bb2db91d74b9047229c15cb0f2613004e8d43d013d5bbb3a599d1573be1989a5cac91bb6622fc155cc0230f43d0648933ee0243eae8c282dda8994875d491e00aff9237225e8972fc8f41b95d08a93b93282d72145bd9cbbe6d27c482316311fba25c15b4a24be03c461424197d744ecfd24b6eeb25bb13d8214eb86d165f1fc0fbf9f0b88b4b1ef7d041915e4eb3af32847154ab7728c056ff8dee66560681e1ad45b8e1f65bdf81a2c4e6a8be2b8d6269fd9084b785ee53ced94d8645ec37d531c19008758383d83b6ae379fc758aa09fb105ec0c02999998f8673e0d7adda0ad1cea1e347ba5e70a2441a163b207fc92c9b9331e6184d68f1df5cb1a972f578c2f1442bf5ed4a78c761978115dc8b2409e49d5dce5be1409f3700b03ce4088041d7018e5b943a71cd8a0fd2d58d8a041ec343f3d5916117506f632606b577fa2b9cc26fa5b6bb53d28ef83bf1e2f527c3e9e3c94ae881b464333ef5d1906d1a0b59802f60751f4eb14661ae88db0e34eb6a30148b79b9fc1547cd1950861cbdd970784826ab24f9c146012a28cfe08cff25ecf6aeabeb1998bc8e2b93d1a594f21d1d0274d45955ab8bd4aebfa1741bbd81d0ad26fb89812f80646a584866129b8b82e83c04a861b9f7ecb04cc9b63bad091aefd0ab10c311ca5d1e68bb2b46251d79d6d94ee9f409463ff6b743862e033cdbc9b2c83d0c439577a041afdef96a9dfe77da29ce85e437088e3340c15f3e8a196a0d53fe54947b37452250ffec0299e9f2abc853ab45c2a35c2bb69e119acb27e15f65ba00a0bd96efc6f4c347d91225dfaac99cd1d08e5c4c3806161e4348b336b1850caa68b2124efcced8c5e521cbca0aa3b24af043236f773b170b41a28f19c349ec612377b12b8beb10b6dc21d67a1fb2fb0afe487d902cedfeebe201a2a0d24206606a13c8de46bff1f34402eda71c4bd865ae4230ae0b598317bb524fe0b952b5818116550c1d8c8b3192a8e7ed906036d51eaeebbe9062f94177d7c4e8ceae34b20e94cce2e4c953193256b53c95699d9e770c23b81919bc5ab028a21ea2ecd4d6c045ea7a3306371fa471823f7222824c11f9d9d4dd16396efca136198c210618ca867eccad76df9b5d1aaa0cdaa83cb090f4cb626b726fa48c42150320f2038dd8ae23d690d763bbca8aa83c344435a37a7dc474907f1352b376ded323e464e6a291ec2ea2eb2905b98fb8849b576475efcbdc7048cb5f639e4bf42a2c04fc1e55e815550c4fef0d7df52143dd4e13bab01716b6ec5159daaf8602a901ff0612e264598f0bd5b8bc7031b5ef46b6f197e14002692034f3ecda041a5cc1b4a5a430657c8b9dacbdec6ba77cfd0e1171f658166fe9cd27afb81b5944047331922e0876cba052ef1bc1d5fe7d609b461b339896b02dd6256e23b50e0ab824fc97476848c300e98d88c8ca7010905b531d8e0a4a350de35a79c17980b93b536e4a09270b0befb766a85f015c5646ce724347c4c0eb6e5f5c0697b810949c9631ffc60427dcd2e49300f9da84f1e1d2249859614d69a6f4156a4a6bae2214513aa150583e61a8e041824dff5a450f1bc5007de8634973b265bdd5170d33276637d09d6203d6c5c91d9fb0aaba1afb267244170351040efda573a007679fd395b42ad9f54e7b69e210054f7fadbb222b6121acb0c8fdd767fd012c2ca0eedcc0d7bc7b35e07c69d9ffc70be38a1ecf249e8fe39aeba82c4e5eb736b26f8db8158b35cc24afbbf6904cf43eae4d104901d2baf04a2724c839720ce2be98accdb38bf102d133871109edb8522dfb8fb9b257e3480929c7c2f576e24f8fcecfaa9aa96146646de1bc40f244e3f2288e969a29a2044c14d9c8d7035cbc72876107231d7cd8c406988347bab8290a25a8d9d026d436bc556b68f7e7fe359aa6fa8752791b8bcc2c1eb3f8fd93f860b9371544902cfa45e81c400330f128597acab7f8cbed5a12902afe6b45c85bdff6c8950345730758e0a32ddd15c7dd79eb041ee9ae4eb0ec4649762374a5c2dcf6318e361a692a99775b5c4dd2bed370440df0dcd4b542dd3db71b8185bb45e949a18eeecdf4ba2b0bd14e7b5c9090fceab91694b6ff9c63cba292e27e62f74d3776f6fee85e0dd364edd4d3c1d0a17da1dba1056978d87b53e1c87755d7b94356c4c3056d12278364bf0aba18d7091acd068546e517722ff8766e1da39d2457ecd49e42a5f3080edf3393c08caf7e181e9d1ab2b07795a5230433816ac86b9a0a61547c249070e296568b3443883b7e27b479ea6f4bed32ba521ca692b90368cf87bfa35cab629ee3555b5e5e4ae527f4c601ffcf14547f0624598e264bc03a68f0e8c048890fc9b373f4986fb173d970e8e1ebb9d6c6947387cb488cf0cfda14d2556b8e2cafeeca4567aca1055f34c746d7cc61963496f41bd9db2f4838a9a47b3f1ed606b3f6a287cbe09c49cdbfadf74660e1b23fa86e1a3839e5dbc1a10b77d9ab86c3c60216365d5b857b8759d230b476272f31b6c1c4806c383f587fb43f33dec93ad7f56b43927f8e141a607b76d31a8e5f0a324931a238f8eb0d9d58f623f814864fafcee968efde15f826f3c5a27bc9a5a94882f1651e5c8edda83d10f14733708444ba0b829c2d615d81ed2f8ad3b651c0a08fafcf57de2841b9b3f442e92a7f6dcab253af6f6331099d888d1e12c3096e70f806638efff89d2e4be52400f68a8864b7ea190d48d1675f88e9e248daf08f2490fb1931c8ea8e2c86b3834baf5b4e1b7f9277da3ee8a5c6bd2e2071691b669b4b8f9489ffe72f79f624df0ff35b4fe74fc5e859e407800119f3fc2d0f398049a08cd89d19437f3ad66855fa9e349a642af3da7272142bc4d6d4dd6cdc4155c0274c995029b80f24b409cc35f73e6e7f8c729144ef0c05a413b7a210752dd432f7f4967c2ec03c14221e453265df58307a4b1bd6c4daa03a0a8186db58c19745784b249471eb25bfa6b91b483243a1b1ce311e573a246c7b0696db063e73a80e2f715a2e4b60b1c0606ecfe249e5787bf0ae96a7a5ee876b62f8da6496a456ca9debf7c05f50aa34d083d4fc03d42405be0b4b52dfad752332eef4edcd8d690a6289614ce8bcae2167db6882353157b7ad4b2e4f1a44dde530e986865f1adc364ab3c931b80073bd95928b13ae6af82305d4a653305aa5b6cd998b917acde018b3ee5569dc08a73146bfecae49d3e219f5d80a8d93fb90f78926b787c6d1c94bc305980fe928be0f52bd2f14b1db7a8e7e9afc5984b6e1f827bdf2b64424b17d79335f9a8865e982def7247e3792d182a24ee38cb0095ab507edf9883346453a45f179553b7e1ee0e6069f16b23f4d9b6eebf59974e3641e640c7bc6c99bef11d03904d86e62c0334e8aea8712ce99d21eb6c32232d7b245b5b313a37df2bbab2b880ae509d57edc23165083a8cc15deedac7203ce07fe24a1a8f686397e0a19d9d78db680ebbd6caae56a2475da91a7bc91707b3db9f391ac49102a480765d3bc019195f2f2ffa9a6bff1787ebc35ae7cbf7a2664de1a4e847795dfeac49338a66fee3ff0dee31f06e7b02de5c09c7d1ec4494dd761af2c43f193af156b4bf4b82c114a2c7f60b22f74b0e6c4466689a0ae73ddd27be484a9027321106c9781f67dbb592cac4356e575a138dd1319b519f95cd4a45b0caa99d4c68d14260c8aff4fa5c466a285231cfbc3cfb4b4f527b33b37c8bfc85cc26360c357c0f78cdd3c4a21d4fff3628cd019d3f5771c59670df3c15c8aeb8e2ddb14f29d9a733ce0c999868bde88a9b56a31aaadfc97bfd1652459e2d444d730898350ec03aba259d847623d15f53b0b3686c6cc398a14e77ebee39cc30032fbec34d229ae62a8500ece0600bdc0fc9bc9e8055e84caa677c7ad1fd98094d8390b6510f444afe8a671a4c0b1ba642fa377e3c405d74da6acb7fe591d68c5d30c18765136470d3c85eb267c2ce42faf63b602139f21a9e5ef3b960f207f19e486106977d5d0448e61204280c0853d70c3671c31431425954cf0550611d5b0b2bc293e475d5cfacaa61fb7a0fb0102ee7aa18ed53965fc02113c42ca12b1835ea30d2945fc3becc38e2f04ea110f3178da6b5125c5074cb2e05774241b25fb7840d9d8658472bda3dc64d236910e8a32d44561981f8307ba0ca4936d1e70f12f15f8972d2b73d5c15b08b964b0b279f1eb48d58ba1abed4e331ac0a24cafe27791899bcdab016cb42b840f8c57de508f4f0d4a855ea6122ce91203a968d718588ee44e14d009f3726acfede8ebf541e97548456fce6197d873da1334d3d0cd0af0c584bbb6f665d3c21a58903ff6bc59ba425d1a515b0b23c5810089e684126a4aa5ef660de06f6a69bdde12c7a63cfe2e9af9134af085ccdc1e67575831cf2ad86177f636a60aaa19762306de984e842661a0cbda94a833a884bd86d189640db1311e5534fdfe0e5b8e5f7cdef935247f5c74e94667ad4214fba0ae0dc40e8020f527fe8fd56b23d6be2658ad19c509ad519f7ce50eebba00508c7d71f55d8a953f3610a40ca12f032dd532dae85f421cbf21ac7f1e8bda7e4b3be4a2cceae7b42a6a2a8d33c135406d267bf8910733bdbbf2840f0d7929a29b1b55ca21f464321d6e38350bfe0b1952cacdb763833ccd78bbf46ecc877ed886e4020282e528ba352a7f28923537d34d0062fc1176477bb1780d60a125073194596b4dc3e329c20a2e4a78c1950e5e6836c08bbc6c975f5c1921d49c923c89a7fec0476b4b3741e5e729d23083cba1db28c674fe6f4523035940b422e4da721353818c0c92c716b33c3aefea16c8b60db554d57c0474f5f8ce20c0c288ae4e5ca550131904fb1ce4ef58cbe37c490f4c1e215e19bfde39b4921ba71af909f54ca408c60b2e9d920164db8806042e4341710b03c8d4f977529640f1e6ee5b6d05f8316a789ade53364412cf6f200abcbdc8f6f64775bf532583f40a0f3e831b1c85f4933a1538ac89741225f4f83186df10d4a96715ce96040695a3bc83e4bc64ad5a916d29875d30e8fe7a177540beb0269d8c42c0fdec36441483f0a3797425554648eb5d26f614341fdb4702539c672b2123e176c3a7e2e9e5ef8e60f0b985cf9570ec6681b41fcde7f183440764b70cf0560423a74ad60ff5a5797410b91ea618cdc71efd3236c250bdd0b9176a228b6e7b6290dee9f97928c36bb451fb2e8d46fa7f2a842b8213c399d9b7a154a609859a1e1f179469e9625706b30211d04e724d9100efe639089b3c4d0190b9acf8d1d15bdba9bdfc69e874e12c479711a3a9f2235a5371704af4c45bd1a6ad9fe0d21654a373a6fdf61d263486f6943f0cccaeec8ee69d305f421a3ac3780df18330033639d6cbf30554ff928b4fed74d28634ff2fa503d7e02d22f343685f4886ab5f750fb1afde2a9358355afcc8cf8f8a3d24471c4b09cd22599afe3cbef1b7f670979f73e881547685f2df0ae931c0864e8588ec4e45f66f049e8ed1a24aadbd81ae95aafd05ed25a3dd9c037b23d063158f08c5c0d56661bcac704ff88eebb456eb3f920df6be3d3f1e6eb6589010bb24b6fb0bc9e363367ba7d4eb7a6f7eecf8e9bdfa15b45ef608ae1454f43c6d678082f4b7d3225ad0d92f4f71073f090f90d0a5236501a2786918a6447e05cc12300b8eef05b84c42c91a2717c8c9b0d4dc1c8bc73e58eb2032a7535ae832c42c029a29eff043d6d0edc5b2935217b4924bb4d35d0b5b49653a8a74e3f43b9737d8fca45b9cc4da733cabc68113f07d452c11b3240f9a2555be6a915a9f9f8d686897258d86c01bbda03bfb50d6d3a5d556f5391e77b35f0571adffc7c312f64bd9cf469e0dd1bc40e660d01f9fef8b098d782bdca3dd6de796598e87e44ca7c692ea32dde6bb0776dcbafdb4c3d250cb49e3466587ee10bd253f4886a9d1d4febcd00a397102cbbc0e36aa8deb53dd8f90853ce749157fe4314e245f4c567b145c6dcd2e1aa7a1d9873dcd850e50148b648bf5908b011eb748013c734aa3766d4823aae415a801dc3441a675008ec69ea5ea30508ac7f0fcd8afcfe054f15c89c86ca132fdbf8f7a548970f56818f26de40554a97fc0656b2cbe8d6a5d6f82908dbc1584f63894dbfc1e895a11db4bb4b2b65ead64c24fc2714ec233771611df040d25347f4fa2ef59c856196e857f46fbee2d23d55d324b312795a147ad42f165c5dd6967d998542d2ea0be0eb95e8cea3848550d3a07e82df9bf6738fa43a64fabe8e7d1ff3f1b343f27fd1f2fbec7c9b2f5a1c58b57afd8f3f5e25e5aef98e852dd10402eb5d0ea553fb9556ee4e95bbceaa636236b00b1a73d36f5a3c48f6636f3f68b75743677569e85dfb128765daaa37cb6751c27106f142b42a6692f5133654cd06bd9da9828a733d5d0019b2a8f267e7bd2be080e9632cc9c3472a34fddefacac6670c99f04c687421f135da0e2123b73de1770609a820f4a70a116ca05753361a8f325198a40b1cbd9f9706df75429bbde806149f6392b90051eb29724d17c20247533f9db7d0b0acf2c39716a5514f2bda3a88d2a5d8f3b5a1edc2570f84f62d0d20457301489fb3b54996fa84050cc94e0f7eba36ee1460428960298930cd0fe0c266f73326e2f7b5fdc31c86aff76b774c0b10c785b8b88c959ada0660521913193978325ca09a7adecd5aac360bc55d5f657f55ea65ac18b9e3e4182593793fdbaf24adfeca36c9aafc53f54cf8f436a5ef7029991edd6b439991b333e66846431da19f3d74bdca0c1d705f8ad81c49ea19ffa256619b915dbf5f79adbea0ffa33c1bce8f38a37aed74db633b0b020fe1295f5970f02478b2fb7233b6ce0f8bce5b957c5fcd64403a26b6429fe164bf1a903c8c9497a314f6cf63b3ec547776126d8f008d865265f4545a879f0718aeed8aa007627a7c8ec131a15991a151e286d0014ae62b60d7f3807df3386523527d716641f7fb7fb10302333296798ecd1834dc6cbfa1acfa88c2369779ab1f2c633c5d2a238c14f061df7be228e3f64ba712d18715a283b9dcabb6032fd263748726536137b0cf943f58da57b6471acff9fa48e6611bc3e9ef5b1fe114692728f9410a91538a0a7620e09d9106c40c8a10b99b18e8348d7cccdd5ff9533793eac806663ba3c155e76ac1bfd7077976366e8d36433604f101a65a53fe1fa45c007d5a0bfd5b48ea871ec8a6a538122dd95f4963501f4ac47e344bdf3df2f6f8d73b73e49dc341b56654a45c5315e6bdb87b375cc9a975e1b2639f5c48b4f691f12dc74d6bc0417746aecd4fcfe00e17440f554ad43ebf80bed3d4e750db9e70263bd3cdf8177c5c54cc4379a1cf805f08c55019feb5615855d5f668d1dd21edf533c902a22272f579becef12a8aafcbc93d9263f0b8f921f62311d76474087577f5f5e726eefe3457e65457c96d3e29b24656ca7e5da0243f98bd321b3738f3ba6aac04a05842f30","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
