<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f9dab6f1fdf165af88d6070fe5d245fe13c43ba931167a7729ec694f7016f92cd12c0469090ea0c5eaf7d61da9c8048f22c37b8a95eaef37a0e69e11681a58f974564d02a33c9de15c40b55f8de771a6e4fe77b6274dcfb9d91dd0a39944fc47e155524fc6f7210f66b618270774b7c20e7c02e9c08601c9738210924fe4f9f57c7266a1d4ab93ab9d3bcfe740bdb591cb2c539d311ce9b5e0d4c6e7d2fcaabf2d45df214b5a03851733daf2e71da8de1e20141d3150c497091f886cbf7d9485b7678bed94d908f88bf1767f7a20f1404cb303f1fe40aefff1434ec19af2b9978c49946da33deea69c1860b567b5e78793cbb21f1cf86369c1d9c6ba16fc9d05e99283f9f8c444de546c903f5614a6ec210d1a45ce8c93aca8c4d5278c6492835efb65d71e3ee7ee4b71a9a9b4a333ea35b126aaedfe39084f4a5c733236d11498d5a174246cfaaf05ccebac43fabed50fc8495f834b07fc4834f55b9f89f85ed2520be90fa914ccfa733eb0288af65b7fc8d77a02263f9f9a4e2e861d94a767e4724c0b4228a2f3fe417981ffd0d5167824fc2d71be11d2df21e10a3ce02df68239d02fbecdcb5fc19dc16a725d58941a78523f145f737839ffa323c641ff197eb91d25827ac10f0b4b7f50296869708a85f12707836aa54417a2fc396e04614a1b1ad9e5ea182e91badf89f586dd4c0845d3c1b1735eea0d2a5567014ef5115853610f847fbad489270106e01afae6105378da13957679ecfe7d32c5c32045cb61d2c8fcc077f32518dc330c710fa33c656dfac8d6e67eda3a48f3f07322cda9496bb6409e4ce88224d59ad63079e057300ecbfc9789c363c72c5b2edc589f96e47cd15b4e6c8c3c717929da06aacbebc09d27dcccdd6723319f6edfe3c40a7706e160f5b4523e62a8df2d98097853450840e11e9e941fbb94bec4a7db24d194f4ee7c054c999610137e8cb00e11614696edc5f3b8f458ef2adfbc1d2fdefbcfd5768998eea1349f26a98987d695d431f00ad2e0147bbaa065d71a05305718dba23f01f2d5e3c8ec20e63be730d1169a53bdaa1224ef6595a5fef9f8c7e6e9865db88a36ad69e863480ce9b17b519651b343c528a78b8ae05c38fe031829b0e5a6034c872c682241582a96cb64501b9d0ea9fb5e5dfa7db6b1d88c5f88dd96985fe49e87dbf4b6ce87165bff0aa40e52b7ff01b10d279fff13e920f8a0a69283ed7f9de3a2d29d716bfd694a16422675680e55a2e2c03f2e8b94e0e7fcc24aef4be6d63d4fa33493ca67d17691ca0bab95c357fe4950e145c29255da34e66e9637ee6a637ae22f79e95b4f890003034ba8f75cbe313ff7ba72dae6f2fd47c076a665139f4b16f17edfb77ffb3cd89e42c3d4c3000ff4a5636e2b4288a7cb136eb626924804cd718a597533f88b77af7254d9ab6942c74c710fa68c9377eca0e61c3f21c3ec1ade01d1a3d6a8bc25ed816c6c129fc1d9d9dd54fdb38f261fd1babe0ca346bb76d9073c551773402a016b9fca85bddf5a49d532ca14c009e1ff0b47475465a02d654f98ae28a897dc891d0529a440ebd28a87df99429942b8b1e4c32c471c0a48069ff779af4231e65b89920d6a5f891faa8cefc55197c7eb418edc5b01fed02654732b125d8c7a4460d0b7db83696cd418276a025af17e38fb67d86bc07131b322381256dd63bbe4c3128a47e78ef7488f00066446c01eaaed6de2cbd916afb6ebfebbc98464ec148feeb0ebc5de3d364f2dc61a0e13138d13857d32d52028fbf4a387c19bff8d9e208f5313297fddc39186ae020f576bead9adfac4363e0853335378bef1a54df57d215200bbf699d02711a00f572dfee6c386ed5c005eee4babefb615fec136e19c68f5e348be9913db7d72c083867ec83f3bc37b57f44175c462f52e23dd7fa7a57ce3d270abdba20da2c5f98a79ff90666296a4546b3834ff26c19d6987514284f3185571b6d3f7c039434fa47602b3604269bc854194e4f5ce66e711612e6aab96fd966b0b80ae324e1dac341b1454ebadf410818fe9afa5a929599774abadde0c2f13e84a719cfcb0497af05d5ecbf05beb9d6d82e1d5211409789ab1eebd77fd8a82c8d2e8b313bc10d30f2d7ccac9cfc7ffe588d963eb5718c61d5ad81dce64ad3a48cddb56ccecc9637b8636bee402e3630a562bd5a5e4d0dad08ecc3ebb5b0a2ad9550e1eab9fd28f2a570af6d42fbcc13e37b0838fffc67bf69d06895cf441ae666f1a54df37ac81004359115abd87e84c8d5fc2a93b18a4dad2c1a9a8b392da68f75fc775029d08876a69ccb6c2019cd259e40d3ea5ee4d38d8731992ac02e2ba9e22545765e7fc140eb62efd60e3712eb4682136dbccfbaf9d3d858a379f60c1d01273174fe125c529143669a31e13231206e1e72384f52820d65eee0edd6de5614d0d32196834c414295bce076b072c4a80030b8683beecf396b5d7e4cdf059abae314693a4d1914e041f17658ec7fafcfe29204560d0c4be4d1036d830c9759ca2a550613ca0d8b6016be032566fcd597fcd89ad784ee414be942e7f058b81d321fd5f514f78ed4bbfa886d111350d205db8fd1bdf3f5997ab8ddb8f995a025cc7a7a025a56712a2d57c099bf62ea582a1395f12161399403f890204eb91867ca9cb990881a7a94d9f9940bbbf7ec1cba69b0a996a57dad680897e57f9bce460ead66157e1ea2c870057c97f642287b0b055677e98a47581587b64d4338b15d04d2b854ce99afa950558d6149ed7a18d1d72121a402b096287ce3c005ca37ef7e036a2a97c4085d80b42a80ff88df0724c99e74f2746f37241f19fdcf7499059a396803a71955aaeaba9c7535e80ecc63ee41f59059e767e5b19f3c81b26e43f0ed5618ce2a86166c00403224dbc2319008fa9d9848c2bd64623f98a2487f49db81eee722a6dc77937d7ccf49404d3f3bd43bd211fd0927a041fcc8ba40218ba4e4bd4d55fb03cf1f108b7b23665a6a8527d36b8d7b5e2d0a5a4d26e651859613faad4536346b662e4606b55ad19fc2c61eb6b157a85d5615cbdcccd602f906002798a314e1af0c20d5cf8e5fbe9b66af79d09c4137ddd93f8456eacae16b931b90f35c48887dd4294b362129934bf770be439a90d31ca18edf087ef27c32f5aa8ddf5cfca1b4cf6fb9c21d341dd1fd4d535d0969c6812ef80b4b5601077029d118e379145ff1e6a2e87689d7fc53870c3a4d07ca1b7a34b972e38f42a83b37d4124ad183ef23ac26925a17ee6caa762a821d942ef40490f29d8fa1fa1e95ff4e2279d2e3c6b9db779ccb5da22c9cd8a10395824fe30c8e392c76b9d07b9acfe1da7bbf33c3da78f4547b216559d72b4c61dee7e1780960d003c9d8fa83bd55425cd02e4fa5c6b7c088f80e8b37c0e42a9574a628466253b9703cc5940d0eb9fab10d3b6ea0b9aaacb38bc9a7d6d036f86b601847db5f1bce3be7ff15a262d851b40211dd533ea6eff887808ee6fd2a850b078618ca4bb1daf571a4251f7d3b229a8e724b34ea065dbb6f70195496dfb0a47a02d54336d261d664d5fa22eb89ca5f6bc502d60fbcfd9f2178d4da69b7dcfb82f9aa85331b98ab70b8f388d1ec5c0c40106045e390e3e81000a7a97aa86f68b941b33da6980cc36b7423d11471eef81da2050144383a7275931bf123d84d4daaa2acbf59d22ac555635a0425714f4767176229bfd88fd8f13e422464fb43856eab2466df081020281185fd81fae703898f2d04b90a890a4b342c27acdb3f5e458775fe65eb748cb9ae1667f818430593ea16c69787075cd0ac824d5a1d371476263df37b3aab728d31bdae31bb04437732afada1713c8caa264242510164b5a46afc688ab021e49d97f903d184e7f5357f2130977f04b75737e49971ce02cb7f3bb536541363786d19a18b36087144791c71ba8498f0a4ba0d1a5938e81ab73dbce23808f70cda19944e27b0647a5d97800198c36fc3036392a32fdeb3ea15f8586e45306af3889944bf94e776dc79dfe199944fa4838db5db978f7c9c66ad0447493f046a85ae18c385cda644a4f5f9cdf637750757623f8d7ee383c1682c1569f907ee7de92dadd78fd61a35020ed7a225e5cb05a10e76df0d5d3ccf9a9ce70226d98d290726137b76ba46c569b56dcaf4898fd0ac7db63d8876f0b06cbfbfe85aad26e0da839f1ca3629912964029bf722d4dcb6341a6df5b81744cc3ef62e2520646f8255e6a3b980ba0da22283dca0fbfde5275765679c1829cc19042902c021d853945a5d2461af1de72f68c769ee7bf6b0f628bdcf3005c2264eb0b116c35092a7ff7529540e192f4c96d7eda19c4796c1e1a685690cc674e2863891092a48211484a0d5889173255ce29595050978e93e9aa6fe74876ad04b5f1daaba0d824109268f06dd99fea48f2cc2bbc59570e4878027d796bc874af6dd5f2b69c538119d40049b35ea04e78155ea7088ff5a08182fffcd46af4d86ac502f1aadabb8c55de9aee57782207d2c63d26eb567fa1f32579dd672405f7a2515fcc4a975fd164f924ec66566168d381fef49a9af9f0705b47f630cf3151a1c737e6003ea9ed52a3f7db34bf05381962c73a3f3639c993172fffa4d1cd6fc1bab19d52632d83504dd1fab5b9f87725fa89ce2cb12687933264dafef08fac9a013fbd243cc825b764dd1261a3064237950d6ae6dcc1ef8d1ecbe22d41a8f868a5adf6a5b118dea77bd5324560bac04ceb8b95ad0e73e119387a23491cd030fa6039b2d1335611938a961737675e6b84fb5bd8b997e14dde76dab3a571eaa6950619255cf91b40505d51926a5799eb8d6254b00df6bd7b34ea01729f4c29767684b8f892dc24a5e71eb90faceda375170daf7c540ed2485e22189724a9b810d03b9aa7bfa063b3d0f20b9c59441edc602a83ed2745763c273944e413d7cdabb2de612a77838b513e753349776830d3521bbcf622649e3f19267a8f2fe508023a3b032fc29183cb43ddc927a706e57e9889acbe495008e9abd609f5b7e3e8e5e1a61e9a1de1b06b2dc318d7a9cc32b4b85644ca7365d7c7684d0a5068f1fa9d3083d237c1005e1143c4db7077512c6ec8cb77dee03a2cef4285d71fb2304567a78190b592f8718cfa692c2ef65a8db4bf211ab3261154c63deb3c12ae88542ea1808fd7daebffc0ca59df24b567f6777f29f160cedce15e20d414484dc3f431a73cfba8b36cf73d50ea9d1a5e65dd945f18562f107862b9a3523a5acc2be259cf021d03a59a5f3110f66784215a43d49504286b20f982323b394afe27dd69adf84b31f66cea84210ec06f0591cd40e6c5bee5b5e7263ba5cc031e9585b665b91f1fd855e26f762377edf1b896d3d227644a5ca739bfc321db4a55bc78d5d845fb74338f72454c7e47f79a64bcfeac79be6547893e8863455659560bf0f75f0b1e23250ea7c5a68f88e62716effdd2130446eba2480f40ad2afcba7070cfbb88d5eb150279bcde65ecbbe71ee38e05ae0cf3e1bcbc07a1b8641dcc2b348ec8d47dc7cf5340076c07e528e696166b64270728706709db2695c5b907f4056111d62b5c369f88137eacb56982c5555992d1adb1d873414dc3fbe41494ac59c590f2484b4d5fde213dfad0389ed1c8824e1b0b6910819798963202f38b8c4c6969501f1c6e49647940c8baabd378968d23a946b6b0807487cc698b078d7985d37c89b3084ab72e0a39affc58c5e1622add1682b73f1065b9ffb75d5dae4ccaadebf21df343627f7d5a39ebff9d9fc2ec6aa037babb3eb459a6a0346a040c2ded6d8a4e1cfa2e5f415dd9ff54b6e242174e82f2d721fcb547434a453826d8a5457dfdd97a806165beb2afd69fb5176763620062c19ede6e3299ffd622535778214c5eeca29c9355788f01d2b85d9906d5304dfd3c5a458ddc60eafc773f9bbb15d784b80f40ef24e2abecf0096419d2a46ae5604ba5868cd76bae1f3bf332ea08d72512b200315426d96ac3645bbefad9a6047dc67d4f34a77ae1bd883bc31b743eec71a0742aa425e77553a431fe9188fe665f94281d0cf051c8377998026f331f04a1fbe827fbbd7bd788cd3c9a0d6292914a20f675ba1e6c6b83e326ee1cbb91dff0aed5824fbba0320ee4648ce4e01c21345d5a699bb6341f925fde8e536e55b5cd58a4c611dc7f02aa9aa815398a64789ef88cdd7002083a5cd93fa198ac7ab26b85aa4af60915726f65097757ca7d799c82b2a4cadb047ef626e3c55acd13a1cf3afad75d07167d630f9303a3d619a2122e8cc67fafb93e8719fbf7fa2a9f1e2ce4a9db6ae57cdaba71138232447660c5d62e9af11dfcc948269fdb67aca606e4f64fe3627f08e5b53c05cc8d3f862842b2cda446a6e2bf496b129c3320992e20039d239fc14f32849fd68b75970621a01bf48ff8e28e0865115088697e6010eb69b81568e6c2ee13c0c7cd833e1aef0ec60cd794c3380a4018ff506d8ef7ee1767ff0cf67e14fbc6e948082c1b7d8a87925d1c8a72d88d6ea855ca7927b2b1a188f2d68b99409dc04739d058c5336de725560dec9fb603a047b803fb8fbb508b821d828e72bb19e2c9cb40f126ea35c2dc1847158b5529912d6f4298d5d6b5acb67407546203ddc95ad1fe905ec79e519423e9e48041483f0dbbdf73059f138a75c6846a7aceefea2a7cb2d37caebe811ba96e66eae99e326d0388ce6f25ee89a10b26eaa1aa2abd3d4ef6083d1524b8bb23d9bb04e67f2211174215dfdbd8147ff4d3bae81cfbee03b42b09f1e8329fbbc45d2bc7dbdc759ddf6ad1f1b061b0a08838f4ea490daf27852d8a655cc866afef5872256cc1d377b43bec702129987e636bdcc748a4629aa25f96f2d4c48323c295333507dc37b7fde0ca5dec8873b5f78a85bcd7275590a348181f5d4da37ad1bcbfa193c7e43cbed7b8cda5ce516c4d72649a411cb1b18aa64242b594e006288830bb1bdd5ce4e4bef0e7e991f5b0e2fbc5378c11626ccc5b97d0dd5e0625e2058fb59ac3b72b09749e6920cc346b3e23fdc7f6ecbff440a4af762cf4951569ede943b91d1ea46f01345db5715632200e4a9a4c1d4b96fea0ab56334e5e19ad5c80a89e3024ab1333d66ea1412f21674dab4f5f5fc71ccd1d5ecdb2f2a9b29d86bdc90cec0a190e8fdb263f345630b4480d9776935308854b8ceb90114ee0c4e6e3a8d5797092fd726e20f09feb794e9c374335ee0a338a7e55f0a719a8b7022f8fb419a5e59f88b4366aa1ae66523629d0b66e32171196da9649a3ea0b94612a3c5de654a5cac5478a45b9a072a28e2df9e83470a45cbed39184f1b381ca7e338eb4de321a28bf90782e584ae8401685daf5f3956e3c209ddb878bb3628925a2aa4b196be0610a0d8692fd0c591ccd32e05df5530e14ae481020a96d5cc5931acf696dfd10c7409bc7e0efee8821f5eae8d1bbe7e2d1fbf7572b47e1ed6a2cdb48845a28c080c87112fb638de33b8084387d5d0fff3c66067f8ff543888972f748564153b34a3af96b61aee1bd498fbbd0ee779845968be178177ae3bea1c8375ef73ef986fb8c1db27e4cf76fa7d7a5592faf31150f1e49c23a03498074d81e6ea6316d3562c87fc498b401fcacb96ade0c4b8bbdbc80313b480a73fffdf514cd01c6eebe5869a46b534e27d5078e476079f892bb46234db3517d92df06d5517e8c77f25fd2b6c631d61e4b7f6ce381f43fae288dbe517c80f5a1b3bf3ee56957dca36b6eb6b3d45d8ea11f1b728eb665398eb4d8eaf36bc669c319315e9b6801028e267fac3cfda5c933de784599d56c0a3f6a63bf9d908a6487269da151ecd66d25eeffdb81ac9e34634644f29a2d5ef155b1a4c38f983d9f7b3caa6a6b4ccc6cdf9ab9c7de15605e6c7bd04bca595819e9c04777bfe956ca375ab8c5900f37a4e9058c4cf595997ce354576ea066824fc8939dcf200a3fd023f2145d387afae27e43e1493d83c7049e0b4234dbf1a09527ee2a9227029f732c6929f5428b7ba7d5e860a025d888383963dc94bc87a9d46930a0410272bae0e5f9715978a434f1e4dc352d41a462303bd9d54c63e0c58d30c6d8c5314ba5e553147f5c044ff5f34d05fc016e15d0c724fdeafccd0ffe06918177401e504fa864ebb84d59ba67457d106799541d6488d57c829f8e5fd4ddc66f0574dbd62f024904615adccfca214d3cda217a11f3fc97a1e218dd6d4693709a57ec75065ab792e7d95d25a16878416ca3ad49c4d263f5299deffc8e0a11148e699d9142d375ed031b48a43b6987b2c7353381156a587a9266968d79fb307ebbccce72eac705f5c3ef36a1d453637402aed6c08d1122b7522170d85cbfa8c0eb271b7777b1da9e075ac67c2581dc73f62650aa25cfad54dbc55d903d6a04a73d7da5e707ab5f28192486dee7a6f2b04351bd4ce274842372e5e5cd6b4497e351b3818f229efc553e9042fe05f1f88c622dd07be94460bda3090a9519a62159d8484537cfb7f534246ec8818313cdf3c2eeff4feef3fd91da69af9dc413069ef95a5aab7dc6bb1c7b1db9f5dfbeb8e1c675a4ebc1df95fd5d10f3ad4a53ba67ea91a93f0e04970963862d9983f3e0c9e58f5a4d4f4cc01dd0b51f722e3b75e076fd9a2548ddec1a22fa49fbbfb0a5f79f24aee563b64e3680677a0ef3474232eb785d1cc9454d683ab7bc66518d3433c59180bac901885f8b78433a036f5114b591febecbf104c3bf2827f97284a8e109319e0d31efbb8e4c8d3e56abfa4853811ceda2582a7a68f1388ab96df90d5a4716d46f088d7db9da9c6921bed4bc7b433fcd1f64aba5a7e51db6488ec3a43b8364c7ca84f20abfe357eae7082257b42e9d36e32e72b702daf90c2e01406b20c89bd9a5835ac141a70e407db223fa9c06a48de865aaa8a357a496c7bf8f969c8731e1e5c8f9ab1415038d492e5d6d35930e5830c05da2749cd73c25987bf63bad4d2eda1ff5fa9485d351a52c844c1ffbb6d3a820bbc787205b70e3a7fd0c6f3f1c344a6a52adb32f6049efa51c83e38a65221b927fc7f8d6f49df7f57966ba1ebb20e22a923f26ed95dbd4aff5ed0324fca5810d94e341fce04ea9f6623a4a4d322200c55bb4e9ce22cbdc33a6391ea2b0bf85492c13cf1ff2b7b1cadabf11e2d565882fa160250e45144b54c41fd6d60c417a0376b6afa8890e9cced209809609f9cebf8cba7285f2fe1e561d0c02f10c2c4ac931b8bd626006da1e7df9f4a8fa5004ef8fda6de4520a7dc1e458e3375964d58e4ef6ff1451396e79f77c1f618c115dd2f6914b9ddaab54b1d4a0fdb9ec7f3b2658939ec5049c2a3e4cb55a12afad6a4cfe216dbc60bc8d16cbb721b49aaa36e6ac7f84b00abba7773b697a505d587e7d5a6ac3fc8faaf722a28c3c59d15374f73e54534231392c7514829e9a7bea8a4cc0c7bf5d28654c7fc4f2577fa5abf844db3a61cfb701cb126db29dee0323906b28e4f2d14a569ca21dc82a8b680e10407122c3613db3b57fbade08b1ee08692d623139fe69a27fac2fb8cfb9ba8db8ee5526ece515fe445c780158232d72e2bedf8999a1f24f9b4d97cf99d6f42ac6e300c9542b6e53f7e78bb154b246452c56f2f4ef8d98f6e8104af0ba3cb0a3126cee9a1ea4430abad8568bcf63b10e5ef1386250e33464a627d96eccdb3093d8ece0bfa310f88e38477aa2498faf4142e57549f065504e3e8834ddbc485f767f2a86e4b469059d105f3693baef2b9886d912454b8661a02bd229563b292c87c2f61b44046b056e37929c691eb9e61cf850a1fa5a48292215b30ecd7c1b722332e99a9ca43c92f3740f6cb05c1c118c9fc88c56a9401b63c7b5cea588fbf8882617dda6e2eb1d023d972bb5690ec2ff1f4ae75a1c50c929e8892d4341795bf1be1f38f7846d0f24226772be5bde499804650150b1996fad5f64015fee05bc4294ae17e61a7dcb8c3177d99729722237860397a7ab2d77d6eaca8f9faa3647544bfbb6c25b4ae9ee9205b3049330b70ec0a9a3591f19e06fccbb9b7f9fe9abc5e51ee474e68895bd2c8b35fad2c7a143fa407666b07f3af820daccae4b9261175410ec6f5b7da78bc9902658d5ce2e8133aa580590c6cf059fddaec65c12f8f25f1111e9842bb5dc15685443faa53ee71cc6e014fe045dcd03ae02fea20d2a128296b4ae1f22d11bc13384353bea20e1e6960e7075da53c3c3a58ece9daea12297b390daae65d76bb081a2f5289e0dafec0a26f026cb95f7f9362450d9cedfdb21fa42553d2818c2794a722cd3ecce5fd6ff31f70884625db6f0290cbf30f699835ff1732aa89e6eab0fc5b16e1825e8aaf7b55afe92ba17d632c12d8498d0ffd448505bed61e6f8f2908368a0abf60c34c54d22eaca4e814fc69486c3b6d862337df9fdbb746a37bb096cbe062919c8f3b29212d577c59486ecf08553e14a21320e904da874c1c459d97a14f9eebbe05a41a1e8a996e55165bdc5cd63697394bd755bad6da3e83cf1eea01365b2e57e96a43560d1bd1ad9cbeeebb9ddd2695bfa9a9e272555117335d328567d46ca6b81b52b40940173bbfdfafa903ebd306fa05a8dcf0dd1bef78507d79f99613b01b292648112f5f11e2417bad2908f8c1316dedc3500e5cda9cdd9337baff4383b27af04b4a7aa9d38b7fe55f89c0140cbbfd6864e634c1d74369a33f68d2928d4b94ed1cbeb99f81fd6ac7c3bd87d119dc19755bedcc379e2a6313e5fdd6218e77ad68a8a683398c1b3b194441c423cc86c54bd53c3fc96ca32220ea56b9e2637ef5908d9037787d7046ba07f08e512644ee89eaaafcfd48456ba38698c631aaf47b5ee3f30242fff162a93bd8064e0b3143dc1538c0a31b7b4a4cb522edf37751d54cc91c3fabc1055b762adbd042ff0d751723d42a7e9764b353f9c2392bc687b48d0286ac38208b3ec23981dcedb6aae5add088e14160035672845c21e77c99cd741bf0a83d77e91c29250e8edbd0c8fdf7b56a697ef68a0468ddef79dd6b5c9490933b270443413c04fd2fbd06d1bfcba101cf9900954202666ab94534ef09551a9fd39ae359b8f4fbab89f21a33ade422a4194536dfaa1ee57e8c247ea1d6d8701a8cacd95537ed9384097a7d9482172da253fc12091a01bd90fcb5fa2a2b38944da620bceb10ced4507593e37a6ff8d6fb1446182118015ce2847b8afa03d0962bf9876c9babac97bb346998e2b605ace877a15252430d3008f6ed2abda12702948b3a799a0ef14cf90adb467db9ebc45072fea4fad76e27bc8bad712b2e83a468bb0384fa119ab73c763730b38e4af28814b38fbad09c93be8a1267b0826a5e6869bf5f9bf4b8aa5f80181c61880dfdec1cfcbcbee9c5b907ca71fa7ac0c6dd38cd6bc838a44c71e2a4c87f70351da0e149d5f0d111ddfd2a06a281d1602bcf918c779476c646a97a1ddd376e7478be5416dce8c9167852002acc25872935fcaf20d873bddfe0b567c266b2dce5c57a0d49f5ffd776653fa270175d5e00b68aa7bb9a51a6500b53db4a82f7a35a49c82aa8980e0888ff667e8e001d685af37b592c1185dfd1ce14707ff28962b653a487507fdd1656ccb66da8ac16d18ba2289769828cee7c2e3ff2cb25866c31a837ff77f52d367ab617263988c174f72d2282870a0dce4e368110bc5355c7c1097d9b952af40979dd8dfe3e5695f8fccb6870b1f8406aec407d2785525ba5ef55477fcd70a540a222526c9ad0802339b1d2026118f9f7bec27c2d376059238d82aaa0303cb77ff13fe3c83c138531af06a3b8c384544811741d56ea4c4090a2167727a8040bb08f40d72227f76e4fa26d9c5bec9574e9306113bbc2d39021e3e4041823c3809363a543d30edc922f49e193ff26fec082d96e791cd5fdcd0e75d18d5a97dee9aa9c20bfde9c120f06ce40f862e5c5109a44dd73beecf1551377119ece374221045c8d9a5bb1977befc90f4163325688cb4e8d0bda797584955b49c258c11883d521f12b28917bcf3c7362411a57cfe1078baee550c58797b6a86cbcaeb9ad1012b81679ee201f04c877f994b1f469fd275697538f346782a93bcdb2710d24d59777df218cb4d283828f08c9297188bfe9bd97365e7627b2345f96e4b783d45a8e07fc714ce4d1b7d0bf659d6326a4b17077ad752305045b7197cddb9f24af489e8f06dde326f5d8f199695ec8ab7fb1a60c723019e80865deb4c8162829dfed535df3804664d8e25003270254753e62daa9ef9186b489c4b44f67ca47cd89ee239f6368e2fee73c401cda5ad793676fd10810f10b58bc970f5183f81b8ec7969d29abbbbb606b18f0ff4af2881381a453fe3c1b81e1e8af9b0f35a52b8ee29c24f0ea1fd6731ccd829d71c298bfb1ecb651d2c35fe5ea3c42d7cd4c21583fd2def1b60507004e28353091f40dfb33ea1907545a2c36bdd4a35e819f19a9c9788712d5bca970f11378be4297a31b9930b7a90500c9fe550509a4740d54eed948d47f30cb2fc07eed543673fe6c666596fac460894729930dedfd42701fcdf0c401752fca06778ef6aa12ff0a79fd9cf5b42e69971572353b5ed01ded514c776ec87a8e505a4ef77ffbe682932f70dd9e7e698ee726c00b057417b8287cd744ea7ce916fb34e240d98dc37642683a2f3bd09f13559c20858c6c877565e055a3706530ca6732a33b50ab5dac84ced5b85796c33875bc5d7097ded6b85392081b26f10a988c0328dc94ae2fd8067789625339aa2e1db303efbe40fd991fa7f016f39b7419b4ddcc262e8ce302d211a0023efd76605c51387ea172d3f1252f929bbbbe6aa9035e013c59d5581ea4e17f58176cb7f410a79f6230efcc192c360a7b0254f943a79f5e23bbe959bb7bd20a4ce394abe438ae1c0e1a94fa59b4f53c4785bda2a3d2cfb17ed53e11af20292b8602a2d322129edfca7c0aa76915b7cb5399742b2bb92d95a670b5325be5973b33327336a00999710e7e80a9e4426b5cb21bfa349679071c76ce93c2753423f4d73ff988f97a83af3e93a68425d0dbaf41237b43168aca48f11fabff6e26872e477f33274d40dda93318a2cc0dc0187f82cbf6bce7e5525ac7ac9fde31986338ca83f7420556825d7712b9d12e67f6e1ed757ef1f904a7a21bea079220b6d2215f32133d40a6056d8c221dd588da280074a6574d9d67ea7328dade1becdc3781f77ee43e97492e39d1fe58f730dfe78509f30580b291e5d176963cce5312b27a2fbf773280fa11817db084a145ad8bd763553f1cb07468075f4894cf3fe3adffb87402117f6bd94e061e7b89a568e74f28f63efc671f7d21ca019cdad46f1830039184bf2882b62f2c65ea1a9cc4cf899194cb9bc8bc25233f235136014f42aa38bffe1d095822a297866c95a8ce5878b3bf115d1fd0f6e2df6aeeea06c49201b6321306d069777a71df17c4c5b3df77f32d45a3e66464298746caae3e6923f21e4cfbc6fa75ad9737abc6af9ad80f52eb9853d2575efece7f6645f69cd449684c29bc44ce14f7d6e6cb1af7fc83087a71d26e4ff5a3ad71d79258a13ba566bd39289a5ed0ecf37fbd2445c8aff7ec33644fb1141e297d4f29588f7b70b8037b9f33fe74460605d88207e98480fa4235320152fff64e41007058e6ad105f6495856e95a4245906b9688879ec456772197537fd3abb9a2f79e67912cd27ecf697b23d7e677d74e14f402172c876b62275c3730f9072091108998aa520f49ac9d687c8ed263bfc656296859003e939703b268d1b3ad8f53a73a9c02cb9364d9d054952f7e4024a68cf3e07c46512fcd58d5392042128e6feb2a3f50b4af1c20a06ef5c9143b0d406763545bff1c2cb2fc17a3ac3b75bd4c94a9d59e7ec562a30846a1bb0367e75b3d44e41282f38be27a41d72ad7e3d1110d7f3c0a38b33abcbb1706a56cf04bed77883eb53d86505435e77306c2ff781dfc31a10b2e800d98dcba7a8d243c9f4ee72b0f256accfcfa13ff6baedb496fd44dfb11cf62ea3b9aa16910bd9998035e17bf0f0acbb5eea2200d845c10dfc271d1f781ab15eac4f5d3b970ff1d4c381459a240ef86afd699da03db434a7970de988e827617b03dd0b735cea3a8d52ac8281337e38b118b80fc9bfdf6846f13bc4e86f79fc147d945a603bea026f007596813c916c8b71cbabeee617ee427edf8905db5bd48630621e8427f1dc244f24c7294de85c51933112d947758de23c09b070b1ee026943e6d795291a94149965d3cafc64474b8b1eff5ce09ae562195316392857418c113c6d778149c793ab6bd9af710add253c5d15623ecf0f2c41f9bf1b60e8f331a0a4b901f96fcdc04a98650b06832d838275817d0140e4566a3c1f69d43875f1f09cb20f1f73d4fbbd43918805cec41c1be07a3e82cf6525c0cef74f3241975f94a7fa68fae5a958ec437382e27f17653302037830052a8161d99447da55b59c68f74e761c426da16a193d2dc401acb71a6499abe80e66a7f8f2a4cff9204da1d75b992cc9ab28a2f671b5ee89455af48a8772d25610f0a89834cf1d2dcedbbefe6625b537e4dc3727b7ee5aca9ec665b57b18d71bb3b3657db272c4db555be93b52323265a9b8d9039fadbd1ca46e547b2438895ce41c4889a3849a8e121c2c73ea7689bff5de3d9c25babfb5ad33ab31400b2979ff6655474813b4833c39e4e0766c771f7e070646e58bdda9e281b62cdc8f48d0e056b5a224b9a4de4838ffd162ef9fb36738128492f6d055f79a6e20670838b4ec0f06689f27b1ff0e0763b62752dc958e01d77d2ecdbd507b64b40ab5689536340468be18effd627e2b9807bb28038679dceab71f0469a48ef43469a9416145246ed71f97fb64d90a34578a986c0c4dcac9fde634ded41c75f6afd2116a19119abe23a2de41010d60596bae0017e16a4cf561280bd4bc1cc560ab57a1b86c881e60592f53958270d4955aab19570d2e751fc6cf910efa2c338a979a54065b372afb4223b57d682951327a036a194f0f9eee8070c05797a115857934327a63b4862034b2de281ccf8b031a738635b1692ee7f1faae032edf3eec479cf54a3e317514766e62af92386f56ccf689659357919ed4bac503668f4fe81d503d5a38fee19ae11a08eaa350136dac33500f0d47e36632973cbea5cf8ec0646ce197b6d02cc01e7e45d49a68e24887ea46f4188672480e2ddd95884cfaf7ef424fdf924fec2d7753f151facfd4af5a7966ff66603adae97ff21bf4b5d1b5ec79db12c23de5bd14b0de8e678140fcf5dcdd2f61ea00b840fb6a63d207ce9cf973d89307b86d8c30382d407a61bce9d36704863f84a45f6c5c6e90a7345c8e145736f338f8d1d774fc4adb1bcc25ae20bffd0d9984955038c35d97af0bbbad34ec9491f33133744b08bc3e1849e026ba4e018f8544e793bc29c6e56123abc5830fee03e062a5dbc528f23046a758339f583d4624ce1c37426c615b5d126dd328fa87e40ef16af856332b8a59b415fb76b8216fd090e43382364db30e36e60223a94c326eaae61a0ea6ec1570093b822f223c61b1bcdf24cd56b9c53bf6ab7a7c754ad3bb342bf0e1ccfe0f860337aed72d7f4f39512f0a18cc194250fe59a20832b6f517231c77a12a313bf1aa657a5cab14e52b84664db992841a383285187d8abfa19f4300551f8b0a18a4533913d3e477e59d4f3ea18f6294ccec7c2aadbd382de15e010dbf90c01face30b44da48506a9731bf13d1e63e52ba061e0cee70e40f0d6f2dc097ca1432bc5682783f77f49aa7623b38db76715d25c849c4ed7f24c1fa528a1197338c68fdffec95840345c22102c36ebf6c9169693c63af11d5eed3a25723d355e8be344b4e2ad526211ca4ecb2c2971196c8434c3bc8a4713872f9359e546945f6332ca82982fa37ca0b2de9f1a78a695b175e71df63cd34d76e552678228e7c4a7640770c3d0a09624563cc6efd1bfb144d9de93738524edb6185ac0207f4200096ea9b6971142200bf30417aaf63828d9f01da410b70a1fe52ecceb44406e6a3612b8f6c383658c3d4b30e4a234d90d187c9df365e6348802708eaf2fa140c4e4b33795f2b8acee3babb076860a40294ce0688183f5cae48cd9f987cc0e3063703a64902ef286085dd65831523e9e005530c1f5ebc653700c63aab43fc3bee2954db8dbf4423f254dd847953de3e94e98efaec7633a6ab6eac1022718b18b961f7828d6db10a04ea1111ec31247bd4fa3c8ddaf9e87f144fbb47be94b4123e90062dcaa98b1067221016cc89f86897a594cc786978ab0cbb4a8c2cc8b86c07e699f8c434d1af2d9e69f1fa63e1fad3dc5973640cce3b28e098d6b6b7e6eb4e6b35782c8241fdd5fd8c9203ad1a30711f5cb617c8d69d16f09b6acba395215d07a38c33ea2898f95a6869cd8455efc8307b84603616fb06f67fc4143ba88f18b6e747871b082c7b3e561f9cad3dfcd8a671c35053eb3e09b1d5fb027b0e3c0f463735cb1f96a95d96dd9444581e4598792d67f487e5978f44a51ed30ba261f8b7027f257b8924da12865acbc1ed46a1ec67b1a29d0d12db385bf55a88b64b73a98e5a4a6445b678bb304f4101f2fd1cf27802d7e0c15fdf27059187b09aae4665438d42f9ff95344442969db15e95ee2d10186a242272039a47e2a4e3e6bc9106026bf4972251f09b90750a66bfe33241fa68707fc4f3052fbe3e67e6d21f2b8280f0851057ef959b1a2bb2daa6a0457a40a94f2225ce6c5acdc3df2a68ad392524b1580b64e00e034cf353edd972cd6024d34161dcc9717a54f41e4bd791b7c0deff99e808a52d684db4c922af842caf67d2629b7ce4dda54e7837df8c488db3279df397a28954ab233025b50d49e5f3abb24d9120a80c58b7722980158527568b1a498b7c367ef846f19a1ef66dbde36a57f12d57512f3fa1180fc783bec10a2cfa2e1ad1bd76cf8e8292e07ea84563cf803ca6eda0ee5a66f78b96ee31d87bc6c4c0a96fdaeb2e3a5f8b0b7d4c0fc4121139232a783bd8c445c391e3f5661cf9056a24da05e9b82304be59d3241e6126460becb607044dbbdbc57c66918b86b600de001331641eef134a0982cf974b2494bf6e87ed80467bdf639e226d1f7245b999e2c9088f8323acdce3299ec507d6b9d65e58ef8683f3d18072c7c1501e06f82eb093b441636783f11d9e650e430b3401c456df1d687f47f4ab5805172e1272cbf6d63f3acba7083b56f75c40522be9f0baa2f5c3db7152384fa8c7da8e332ffb73adf414a840b7d52c68ff6e6e79158e3dd08c48cada6db455a9419104ea5b5f47156a0646910da836deca9ae1cde38055743d8d92726538583b8b8e098467f9af983f551fb4b1b025a39e7bc7976e6d0a94d35c1e76ed5afc1a116adac34b6967af790fe83f321806ceae1577f1e023021309c99076bfdcb997181e0270c6cfc3b02d4ff266123db2853e11475754f69cc655ccfed1f94ed4bd0baf35e769652c1dc34cde68172c803930f1ac09855f1cb1be39c387ee7d455b26d4a1bd6933d553894156bcdebaebde9e431033b851ac719e311c38a95e85a1508a21adad3249a316923461d0e3ae7810bc25df04d606d45fd39b2cde34fc7d8721d0c063c2117b0bf5d7e6af15656e08442e445cb9e740a146c431b436ca8726abda22c3bf0a70323b1607dd712cd92c73dbd89c9b5fba6e434148c87315902e465ef855d300d022304ee5f4c88f46c612e94d6da4614d4c8e12bf10417e7d060f169210e501c39b6755cf2a4e75662c426354b953a21edcbcfc9baa6394b3967bea2e6f5cb861ceef8aa61b121780d383c0c9d48730af25fcf544a8f67998909e9830e617d289e05755de1a5818f011cdb1344716da4be1093dc2141ed8929cdf995fa7ac72a3c691b61267230f20fb2f1ef806fe83f98aaebefd1483c20b9f380c27999df4828e85197045d92fee20b4a916bdb2f0bbc50ccd543eb88917155b5385d41ce9d63d0df68bc874a929b8f606d918170ce8682264fe38ecc7649be03fc4016ffe46f31492ae2772","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
