<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e7e961361a1840b0641feabf79478647ce87c431968a9adff2bd152c2e4b00cee182203309028d7a4999a4a94ddda5ad1670438fdbeaf679b81cd3e32a8db6b99fe132c80063b1f5012d63ebb3ae301bb533eb5ce548ef6bdd0bbf7e1105f6bc1797a6371ec5e805897ee7b084953eb0c0bc7a221e158f3f311331f5b5e57b7bf67c2b567a8bcddc5ef38664ea88ea0c4c3beda259cfcd16e2c22f3dc2449e1e463ca50c925170b38ceccb638158bd9254585f084e2698fa6e3bf1da741c2bce8fc517c9b76a658b20f10ff9271cb2fb79accd269d3b33cf6a3cc1970d2d264493deb3869f8633705e9b9ba50b26a7f44949eda138cbfee4d10fb7b920fb1f2708d360cf4b0ddfe8635a7d2b488cf598906c91e57c61eeeff11dd1e5e1dac97812814fb15309cea10a50facc7e317ef132acb384afcf21c711f2c638db96b9694c2d983417841c4d6117ea138c87372e548254de23c0fcc98d3085ce1df9d641464f65eec036f3cfdc4c3b96abead100791369c8ccc453c9e0003307c6ca5c2e21f91ac2c333053bb4b67e19f3711dc5ea1284a7bda8669967a819dae282ea8924791a93637eb0df0a058ed0e80f35811d4baff711098a7d3ec285fddabf19425f670b46528b7b1145566a2bed312b11f72c14d188a47bca2c6cda6672a289f8f5ed0fe599fbe24f0e17d46e583426aae4c140cac406dc64054200d3282a988d6577cfac4b5567dc10dc29a3a920ab9fa645716c7eb455fc3f211c894a5e520c158135c74f13a3e1e6a05d7b69662eccd5d77f19947ac3683e8538c7d22183c5fbdf131e48845453f8a2a8cca5dcc4f21e2044ee5a3233df0a8a214b12854aa64b0fd9234ae05acd996b103d800d13e1d00bbda61c2bf349265c80bf5edab3f160395f00690939d2d807729b4b01e5c53cbda611721ad44acab4d945d4bf1c9abbc0759a0f8598d391caeca9377987336151d3ecdbed88ce9a49b09c11f7b75bf016ec4d57c010ba76a463bfb99bffc09bfbb84903b731964f28883b3c4a08f5f34e352e09acc9df06d83c74df36426b3886038304d880818ce5a9cb7fe1a2e9987fbf69046e6ff99fbd11f48cd373eef25cde55d64ea1c8f74988757e7f2199ec38a404a535ceb70bcf3b63fc978fc803aced2fbd5a211e24ac8b4b3409b4423b117004ce4e93811e6f86bf40d5a88c2842e1a02e3ed4d4c51dfd60c7bc56aca7c50c70b83820f53d6a10f9a588cb8f5860097445c903876749e31500da22f8b1359705a96ffa1c495d7cb001985854b3b150b3f87d702439b554076a7d272c5d367d59a7f0c218fda75d1425ed250904b2c8abb6ecf176ddfbe0d9886752aafda663ae193907db9bb9ad13c85e47770f5ae815bd569cc658f4f62294941f56c3049cbd355dbd548ddbccbc7fe0bba916a60b36f73b821d218607518abb03d113c172a183f35bbe72e8ebb8b3a3d80a8c316e84c9e1d8684488f5c078dfcc419b1e35c2ec903c9566e76e02726d3feb5dcf6550cdcce724982a32b93799c442ff057b5730898c680e24566ad7a6e64ec51d4d1540836c8e632ba35092232e040668242917e2148e934cbf8ace5135f8c5f502f93dd9751b895812ac97887f4c68d93b781b237c9a0c186d34e8dd22d5b6d7e9c9b7fd4b6a6cd584a212e7070c1c9f566eb1a29191fbe74de12a47ba544b6cc324844b964009517193b3f69b2c564893b539952574e41d3ecd8d141ba56d5883a350c8f01c523169175753a08e49de4dd4eee03252dffa591f0099989abb39527eabfe61c415fbd7afb4c442cdbaac65ec703dd2a2461a9f47f1af795d4b66a85adc97c83f4e5ae788dc762465fbde1ac6ea7ea62ed29542ed17060d2861b497104f97b3b8774c46a0c8e5c988132ecfd695b5646af0a7527eb3d99964d9ed6f56b1896bd1e7ad26f1eeda2d440cb93a70de65502c92992a6621b3051012ed342e74403d746478d10f0625a6ecff480cd597014447b5a68a571fc16fc161de0c11299748eef045da21032d7fcacc1cf47c86de35018016a47ad7d34f9b380aad1c2724760e2a47e364cb4fcd2f4107117f5ee012a24ca94a5d8be6d3aeffba5dd440724afbf897c13885dae5cbb8821e70bc6a8458684daf18200cd5a7519b7dc36735921730485a2c45bb2bf0fa927d5c107eab573ffd977e42f88a7c268620e508e70696bcfc206436d78d79136c36442692efc8d41f9e1322169c9ef9d05e3bfc1343b6a23f899b42d80d8f011ac51f5db9e2f9d4cc6b7e999cf696130a4e89afbbb30a4aa1053556928ae79135ee2c19e484950da84e7635b607f25f41c71bfce6891ddd709485a5ce55fe44cb82637cae89fb4da7afca9b2f9dceec9ef7d287ce12c933f1ca9981dd74f00108756ce5dfc8e1a39db1008e368fad2dd84d08d2928f528b5bae72c539259ad32bf1d4b131828a882824dceb86e10cb2e13b3a7ac2f24179f0dc528beca3e630b1be384262f766d1be2181567de024fd5d1aaba8df2f9c313ba61a459cac5051b8c2a555688ef84b2891e70e3dedbe9471f7eade5cee2c2f0832d2b6d1f36fa083b560ca124efe08b4224dbae9e3aa0d09db8bbfe48dd69cb18e8a48ceb52b62a5152ca7f161839ad39fc065d772b4b486ee08db4818160eaeab147b9716d662bd80d5926f04d76be1cb78aa48d4926c538b79b00a4b6cdd005c69d63d8e6fa14acb45f8f5af2cb35390fe4f9df535cf8e50afec9f223369a49854197bcf1630645e5adde1a704e444f054cd4ba11c92265e4fc60510ffa5cdb7e09f7edfd3d4a8f5fca21ed71fe9787fb2e023a565f8fda4113ef0af0a9b099ab795d897f82ee1ff1fd81ccec07f32a010def26ad7e91c75cf3ca25a47f6ef629313d4dede6772a11811dcad36e383f4d3e571fedbcb114ff46cb93419e9405ccf52e433ec3df874bc4aae161bcdd7a99a07b86afae29f17aea1a8cc522e5aae25c67c3bab8d44926810d81de7768843b7cbc5e431e1fd53defa55fee3889a2a7e91137d71efe02d2edfea8a36d706db5cb3be150a57b063b8d8c3a8bd67cd1cdee096267ab12e83b26fe53ce582c2f9aa09ba4fa23ff94793d1cdf7e3a3b800a54a5812aed27a880b67e5567e003f5cc2419f204935386512a79fa543a34f401cc6a85cfc443279626f258444368ae3e7512d53aeb72f7ea23233243732fc6d6586906a47d34c6b260c05390189a56aa0199d35d624b985a08e09ccb5e83c78ac9884d915d714d9e955aa747536c9ce9b75f367da276af08f082a493c56f3db6d64b3179bf19bbaf7e80c5997ab91fe26d5eff2c5c06c84028334719398f560940454d973f50b4274bbc261cd3f5e81dfce1adffa5e56e3b3a65ae3bee0b4f6dd04a6f0026fbd584209fc18b50995e6ebb4bfbcd3247ce75b13dbb86ffae61fc9ecfb78712900146a5809bf26bd0a7a30e6ac47aa8d2fece649f88005bcafb2fb990b91e5fb18603d1a145b1c6d3f28754ab17b4ed575bce29e496369ea2f89eafae9f94efd70dc718130b2d6d1f55f37bb22d463f8f318510d79447546cabc18afc109f8a5d3d4df59d8bb0c4f455534d00c0096f39689dc1cf48b367562d65c67943c169b0d3df72ff7b26c2e96c36289741f6b42c8d505db73327316400e6943f93bcfcec2fe50f1f36adbe69b1e35f7a4d78bbf121209213aef20a96115c8d813e6351cd5842f233ac6a33774c9b988e137d65717fb9d55d826ede5dedef4dd5d6fec1602c0605183cdb2e8ea0b54f85285710d17843bcd83aad557845ca97ee819a362f5f27fb88ecd934b9feb48d9d83dd6ca65cd6ec621386e1ed992220f99be80c0cca8b1b4d9aa6581744ec54ae4a0a7f60bd745baa160ba3b15f68ab2bf3328eaa93a177fd46bebedd5da468ca16ebeab04a53b2046d7c07b8e4902c3d80f2a18c568fcd6c25e06a62f3f08c212b8366a895d5383f432ce83076ad29e939acd5a374b673466968ef27e2b4310cdc16a8b198386789d9dace7a47564d4d3a5e1cfcf040574d5dd04e1279d47ffaaba44fa33a120d72551001eda1374735e77217dd8cb89f86bb5b2542013044c2b94df0baa46534cdd638b53232c8df6842c2542d25f9706abdc72f1590a2a67435374f7222bf7cba78204da3236440a06604e8856daba208443aec7bbc6b142b2a344070138fc116433ed828fda3ceaa41ea1aaab828fa812b06d34dd517bec479adf04c82fede8f00c0e0a5a711ab976d0d667a03a2e8816c8cee3a6821694b9865eeb418a7c0fd2fa80aa73931557689233becd38451219486b612ccbb85ebfd9c286c751f3a77dbfecfdf50a1ec51b8089f85bd083e1fa3b642dca5030d9b8125eb118423138e63c1ddf327d8d72257a8aa2b53121f07390429e0c603bc49fe0bbab60e8571ef5a1496b0e6076d5d02e2202446a73fff83fe893cd384eaf94b67a01c21b5a0ee8ff884b6867fc135de6b195c1c2371c3f6c61db7ae2d7f11126a4290a9f6b044e2d53bca59e393567cb8ab920d9810753366e772852666eab192988f914d0e68604404e5619d1a15f1863b75dd285ab1684f0b03341d987641366d68b0a3c521664518bb1a4ea33ac77d29cba5c3c528e389f23c1abc9cf1e24491d27d1e2b7f56a0787df28917dcf390d2a170bf41560da354d9d9a1152c4957875e207193fbb8120c13564e55f80dcf85225eec5531ea56520a7b7b0b15b0066e9f4e98bd5c8c3ea9ca933601b2bba6b1ec5f5e5d88a29c975a9ee997321c6d646d9da4c13797f1d0bb819d5af366d9f37a284fb320048ae1b984afb09dcddf7deb87ccdb64c134d7f6d23486fada86ee52c48ab818c673483342a9beac5919b08a9a38c092f3a768bd58eb410994382e2a0b3e106a5e119c21d0bf597f205a92fd04792cd1cc09ff862117dee351de40c38059168488f34cca394065394a45d1b923a17ed13e4f7d48f8d8200f43829bbebb4ee9db173735b35f934f4a9ccf27b4a990645e04053fb9e3da62f70e594598c099122fca27b03373a942ef471f97f9ee03e6c0ff804f1eadb843cfd4fd2bf50575cd84aea5ac563a815a38ae97ab2dad6062c3e2c77d4f25a1147c990d57ea3e31b666418fd4740d7637d1d57c1ec024984b7ebfc12c620582748ccfe70a1aaaa9e55f94c1ab5d1acddffc78cd37ec4670ebbdc6b3708752cae11cab437ffb339fc669a43bd97eccea3d57b8d42ef4493276eebc53af8772dc0ea93b53e2ffdeab3fa2c675db61feda2e2aabbecdc82d92c667d1c19ab9b440457986786fef6d89e5748037c82d08fbbff83ed59b910526f4e2f4d249d171acbab7784d522017f931e1c8eb75a1a829524a07b8cebf8bf9ec7b778df0c3d0dc8dbb33e569e24b20c138cfad53e672e59eb1a2c79b41b98e64777c484d27f975a9e74e5845253e8a5e1853fb0858017a51c0c8e055d10b43a25aac1c17904c6307e503def2d19e8f36286711741ab56e43fd3d6b9ee77306afb24a7f0827d1f236cba7d348dc77d227a24cf79b8819514e352aea6558c6e0e91db678208f7a7c2ba5420e1477a0371cccfedf8dd533785dbd48c34a9631faad925674fce9e63ea5dd70da4468414c19b40c3f8c8aa56991b429ecd01f6a7b88ce392b462e05c87c2c05b3ccd4915ff2ff293010ddb60e0645be448abfd828d610a677795f7036f32b2ffb4329b2e6bcb3f5abde8c723077995d4780541ffe1b32cd86891831e37f8ae637d2d0ac83d993d15062b74b3da40ebe68182d0aea3a54b500597bcaf6f53410b00d358cc5f1948b24a12d9d6bc40fab8f0cfe0e4ab42a5c7e74c9b043246957ddb4dffdb4cf350a28f7dcb9997943811ef8103f995c406b715519ed5d8972d12bcf34c6d1b9f9d04e0d7cd8b893c769a1e5c85424fb828ef6bd961a74b8c5ac8bd47344f22bcca87b82a30fc33ca08f1a69d2f969931ff7b810b420b9d8030fbecf894ade7e9387dccb9379299b75e4334a312c143ff3e9327466dca80e7ccb3ab35b7434664bee263eb49a58f30fe878edfc2cdea085a45ce439f952a721fbd42bda540c70cb72cc37ca8a8fec7caf7ffa749528a64b1b63de1df6ae583040e11177d0af375fa05f509de6be3f5a050d52f60cb6d4f911bcf82c5bcfee22b488b43841f1a3c801784615f70ff24913c9e4a19f80141988ec34a5fd7589d5b78e1b18102270ad5f8fbb28ed4f223d643663aa7e26adfa939f99b63171ef2c6f84a4d7fc627e6696ff6171e62060e4ff67b6ac10a08adcdd3213889b64113be7c723ef3853e8d70ff52910ebc9a2187c475bba7b7f6c62d296c14e8826e4158329dbc5615c4a5e55bc8dbcc96aa42c39601ea93538b6b368f213c9aa44ee9da9b25919cd91f55f6b5539fe5721ff4403a3b9e794258bdab288800f532d3a449f5f82ecfb1f58fa0e1efadcc159f801dcccc3d75690c68c399a666d29430d88f3c364844b7bb36a8371e38253c9590f41c149720b6ab7fd71a2be07c5d50157f6a12770af498179dff91928f74f1f9f1810d3bfaf29c82caee5eee1d0546a8708a78974db922a57cc06241ab1c14c9c9332c324b8bbd2e9bc78b65137f68d9c774e6feb5033b3760356c4d43e17271e11236900b1ddf9e6b87f1490b062581cc9017fdb7a3c389b86463dcb0b3cc0bd902d7e6d1f53f171749d8d08cc6ff019851e190ebbaa92614caad6681c4dfb15545c1c0e6782d5ee6e807f5ff16c478f389920f22139b5ccc93239121c9a3fb4237d531ee732a058cb654575e7fca9ae84d1a28b0688fe4c1e7bc2c68406a74317b2658b38b968524c3144545d55ed4ba21288ac526bb924a0edbac7848939748f10b4e9927f35521dfeee50d894aad95808b7873ffdf7c86e8a0cd87bc558b2a3e27d6dc8c3b0bbdc9dd39c7a9e9c8cd556e526360f31778bb927ced9ff40aaa9c649102532c620039d4b6ca4c923d78cb32d27a8e4f38f8d71822d9a64854500930abdc406cf3f5407ee7213c4ca0779763b3c39e8fa42eda1edcfc740cb3bb92fea9d5082218c1139a18f144b570b9f1cffd32c10ad252a571dfcf239d8591bc1feb307840ceb42ab2e4d208fb78c0908d499e256380e34be049cd26b31b0415df5f0ff1929bc3a71167736ebf4c4bbbd130c81eb437f68e1346c05601a67d4697447fdbf030bc04c599879ca8b71aec777e1525385cd404de0d3beb9f9dbad89bd48ecb24b8f84dd312c6d09fe5910dd4022a8ff1cc37ec7d3d67e8bd8948bf2b251039d2d68d52dd7902c42128e92c4cded2052951cf203f68d02716263d3a23b75bcf9424e4067eb81297258785e1b133df8ff590da1a0a420d6dd52a2279f915e37b9d167b33d1e55dbc6f98197427035e8dcfdebfe219d326486e0fe4c051189458a53c39a453fdbacce2b529902e1f22058fc54a1a1f83c9bfaf0cf2f22e6b8052e321b51b0c984063c9e1f2dde49bedb58213d3c9a923c36adf3e8d4e5d89565f31fb0ba2df06cf642cb3bae0bd108ff72e66770ee24dbcebef9426217084fd812e02e2e27fae312db8fd7463d2b9e7be05ab87235a7d2d3b522f6f5d8567242d099afd756b9561c3513d8673d68db27061a8e991928bbaab2cfe5d1c174296698a997bdfd1630d45b783b3e7f47ab1100427c8fe583b40747d9c73c9def65a82e86a09ef9a7602f4df75d0d2ccea5d5e4d30c2c95c4b7f17ee46007bea6b7c9694a8432ce985619e1ce4aee9c793aba107697a59770d5d9c873a69141c509c2d22e3969f22cd2e276dd23eff558eb4d05191c072339754a8b18a15ee56d0fdc707602dc5b79d2b7c72aaee3d1faafaf95a3bc62e62cabcd76019af62ff63cdd6d03bf9a011be02db02b3e3ad25e2b0d20317ec2f342ec6ec40c58733cf01b467c68acf9c285465368f51a2e3a28f82e3346b43c5c0c931786dab3e5ac08e6de47e3b6c2b62dbb6a261399667cbd078aa5db3e917fddf9af45dc128ebeec2fc5a21a01495fd87cc309d4a9653f749185f93fe8661bd5d26d1777d9e9b1c83469b5c2eaad5ef8459b157fd2bf249178bfd92e1b1f944214d792b80cfbcfe7849935e21379134fb78abcfdc9257e71034273aa8167b23efbedee85f10d6c3b8f75a7329ac03f11a1f1e5e840f43718a02fdc7f45ca1e9bcaf8bf8525683c61c9c49479f9110d1e3e05f07e9b920de82911c3a38a76d25b9b79b258f1530ae10b964b21dc825570ddac2b700b001de765681140267e2590d3362fd0b9f5105cb561efc6aed230c9e4f99321e815f7b3799c84217cba278fb1f3b5ef000cbcfc66c2a228a9b618ad48f9c9d8983fc208a6bbab4a35ea2a5292bfbb16cc12bab843c399fdc2af7edab36933df8fbc50033d30f00b59af0c2e641b06890e50f8d6c920230b7d7882147ef471c27fc4e118afb54d2de672a709d200c06f59a7bb21411cf08359dc497a68f8484b62d893c112ea6ec61ca73dd87597eb550cf22cdee335225bffd9dfab2cf800491987695f7f4c02367711607af429404aa533642a5e14d4346c3ebd42c22cc08dd6e967d138003e89c2cf159397b54cb620598a593456a9a55b50c055ae115db3884aeb938890df2627da39934585fe18ccfb3836b38cec3017c9bdc6759b7fb711e45eab65bd1674ff924f5f7ca368b57f24294d6cb85ddcc8950394e2ceb6808108b4a713c2c214ffb49beca90f14becf76bbf3fe76c101dbbc9287f8ab7e929964583f949f36e6157c10426bd485f2ca108dc93fa874bdf2225147898f8a1b170a7ede8150ed72b6794158ca27f994da082fdba87c62c658f1dd5294778352507dcab863f111b935a914a89af420c9a3e564c80b22c2f35ca5305dc55b6646d540866ef22ed7a8d18b98c49765c0c0457c67edfe789069694884b65746ca2a52813f32f84a3ee753bbe2638b7b93e55edd1b17cfba847ff8d29cc42c3204e6d5246ece0b394d177c455c7e966cd2d4d494140c65eed0bd94d189d74cca2d75fbab3395f2024e4dba2abfd03f419da0b714f57879b3bc2d96c1349fcce6621f243a2a112daedabe656fa1554adcceb12d6b8381d98d54a3de14224e721502f580ed0f63859baff8dd9bf928a676a9da056a6db54a151eba3c9b03320ebd482451d5340ea1cfd06e79afd22be5008445707c8613f347ef9d0bf390084d8d2f17bb5772daea23859cfb93e473af298a6befad3cb65414557a5671acbb56c8622e6cd46c495192e3438d88c1f9ca3f0a164ea74e5d9b662d0c4833ab030d735c120b8bdfa8afa3391b9fec20d70eb32946a4a69ec36b4e4e2f0433df0da09c70cc585ff1b4e3c28879c93f58d259b1a4ed4215734d63d05bd383aef86e668365dc2ba6086f43c0d0bf7d5e89416702d8b03630edd0a69271c3a430ef2e68cbd26e0a4c16397eb7bf80d2d3dc8402dd522311bd14da08f065e23e714d17015bce348bf30940972b961125990238a202c9a165588c10f5333d1e21fe16e48cf3a3aea483812b349e8a4a335948aa678247d036dc4e6e0e8c2488eeba3da0f8e44a9d4d60c0de57804d00e191a22008c2d15ff9c3b6eb5bce85c2efbe3482956e0bfe5e00a032aca32615786257ac45a493058d519db9cd760c25cedf13bf1d038f4fde1a9c0e044415e6e82c6751d2262a4066503585656d77a4ef44b5ee704dc4110f0aa682a43d46f8c0e0419d8376be0354efe70afec04a9600da95cd9b13f5cc92265f460bd8358e0143065a30c131824e161c9395afbb71c4abb8a1c0b647e3d53debed9bbe10e399c1dc084131f12de147f9a0e83c7e3cf4885c2cbadfa4192c03831d46af568043e17994a8f4fa7cd6b63612f1f67831b877e727e70d3e488aad326609fb3244dbd004c32056d2cf0d4f1e3e793a157edab3e91cd5abcaccb7ae9eea46e17fbbc18fca1aa168eee5f785b59b4448054bddbc50ce8c2c95b5042d35ce45960d3802a589da41b9da5b8ce220e1b40382124c9ff49a769ee7dad4cd4482a1310e9f1adad473f0cfaf9a3001c93e868eabf4256246b3bea65fb22a4761cd93e8e6392d0aee86a14ba06ef6ef3a717daa17538477c589511999c52c810e92b6c7b5049a2cfb84121f211390763360aef339581e7911e6cb1a63230a3f9ae23c368e6c4c0bbade9667269c44d2b95f748a817cec44df21d7eb33d0f1093e7f155254f0c43ab2e884c415971b69a13b2b7cdbd805bb6de729a70ae8226b555862241fce284eecbbecadb24e0c0cac46147c4612456b4cd2e602f9e218e16e4473242d5447c0ee818de952c355f3c0951ee3048c06b853b535ba86598d4e5df9cf12dab5426a9970271a975492ed931e217c355fdb151456892076aeb2d599c6748cabb5959f9ecdb2cb0619b4ab9b1d19e485d62d364528bc9245e0c4e04b8b7d68b37f18cc3943c8d513732c909b35d3a4a34d2027e0d17db2b73ed705596e68397c3eabf4a758f64e0285772b760ecdfe6d67d0afd74b09cfc1c03b8f4f2df8361ea03e984ae53f42b6778a856200f927e1e3cfae8f0e6eed6cadcd8f70a5330d788a1d3b5e0dd62fabfe81ccd9fc193ff4c7cc162db3bd8f27f7a87f15545b51736944c2c33867695f736d977902a305cf10e414c2bc6fd46f1fe0768407f97dc82d15e8c62d4db1bbffd767ce9ea1474b275931029ec487aa0fe2d34244d107112f248979cffc492217e720dad358631ecdc0ec97e6ab0f9e1ab068618ec685387cb203595ff2cb4d59e59e7f88ac8f92919029511f5eeba24663eb7e5189725571f77715bdd586bf937b05f0d8cab08e892f6e9f91b9e8d71091b8fba7abd2d6c0392ba3a701590b4a337d650d7490e14766c2f3dfc7c2a91c60badca32402d8565a076e05e764c24a255feb7fdc747c8c6790c7f2c41a866d301c71d0b173705f98dff3745eacfe91a0622a0b24cee09129d944fe8bf85b9499c219cc446e100976740c2d9b57d9f1ac45fdcd1310a415d2a5270ce3039edd0780dca3c460f147f3dac1e6382e477544a1df271aa3069b702cc65bbeed8f39f3c71382ec9e2323295ebe3f2944a3033cc66625566cc9591c034899d781b360092ebb9082d824cce7f490b91ccf4deebcd31aa68731a1e236941551c7fd40dc3c1b0404d4f28ee4975011c95792a25510e6eec8b99487141baaf58c63c30b8026491df57f20aaaa1e7a07ce44895184c83b05dbf896d6187bea93fcfa27d008b5dbaef6c9802d1ca5ca4c58307c5a19449087f3f332e182f7581e10b9ddaa12d5edac80793d61060985bf38028d39311c576f54317fec2e6cbf7e39d344134161208c8927e8c82712046df6df843d0ee529a1d3fed189412c1e0350078014c0b7473d6bf2670149d6d46939d9e7a6e1bf8da9d790a3c08dc0227c94265c3d4d1d003c07966452fcdf88fa36c4b13b055d404612c0a27ae58180d2c84a2d3a70fd97bc43225f122767b3a43983d3885f94833b28c28af0ac42a64ff937eda6e8406bb5a11fcb4969306f4f1303dbe3748a0b8a322f3c4972e0ff1c60229b688af86b093bfa81e23100518545f4955a2010703c9bff8e82cac6d839f09905b752944e4e62471e893af429166ec72c24174b6508628ae62edc49cf68d918860fe6b591448f37e2a8941351b60419baf04dcdadd1dffcffaf8e383f5f6088191fb8eb55f450acedb0f80935b17ee2b321681655764bd2a786c8efa5d55a9d5b330c8b53b3362082659ece8c2342fd31640b53a5562dd8aa93330a4011909147844a36d83bb113f0c80e39d99fc05d9a909b27fc3dc4a51f69602f9fa9c54a19e14ba227de9cc625bdd1804bd32e614015c2385a81edba7ac93fdd473b27fc4075b3c2eed6815f6870179dc46d5f9b0e342077a0775e8c0b642f28174dec4c1005ecf7459c4db4333c032a15fab9b140078e543f55a181faf77ae3993595e60a628598948aa0114480855eeeb21c9bc81bc1acc8cd90371ac4b370f2bc185348c4391e34d45e0287059160867f3c3a2495003e6d1f417845dc06ba434391a1ef751ee087f0dde7582de72b5664bce338c290832fec410d4b7c718e3474a552e2224582bb6acc4de4f33a2c48a1be3887e3a9b57aa7fd6202528c1a4c893ff527339a46a3853d72ff67e1efe8da8fcdfa7088289f287c3b0ed6e3b5891fae8b991886181cf46d69a38e8245f4d42749b3b0381ae2c19585a46203ee05e47f0127b6ef16950147996909239449673a8cb8def6fed276c7463ae6ba07e74edd120ae3e44d94d0443acf95039ea3908bfa9d9d324a8643d53c529516496a7bcb698cde56c465f84bfb2acbc8917360ea56ccd2cf4521b3ddee23c3622b430490b02ba1ebe5ea776856f87a2805e843c6595b8023b822c8ffa4d4d09aaeea62d4801830d40eee5c7fabd8892338eb468f03a015608e0b413f2a3d7f262fcfe98ae44b3391dfe5944e7e8bb3a851790b4f313fea8e906946dfb33a7001edce38eca2f71cbf834783cc28da45aea23e25c0ffb574af29c1a22b4dc1620efc6806e4740192d0501f779463ee06b16319948cfe76829dc1bcbfda390e213f4f9de64254ec433132c3c3b80628e717547b84be3aed5495037a4c428c0084cdc097c42387b5cc019c7e2312269849ef3bb05fcf649c647d9c4b11c0fa718cb356b93f54d2ec73ed94b9ba0d995c460e92eb5abd926eeb6da5e196aa7c731ea97a5683fc68fe255a178aa7f94408d4fd71ca07e58ceb228fc36ac5fa822f70816a1935668b5e963886ccb299aab5a84c9b56a5cfb75753f1c6079506ccca8fa422528c04b90de0aeb891b8d5c83b99ca23fac732e5c81110079225a97348cc1a8569973c9e5fa879dea9f3a1e0f36dc93e154ad6c974d7c6ad2083c85083e260f36b1fd161658fce4c3317cedbdb243daa2da43a6df3193148d40030823ecdaa6a625f9dfaf1ca35d48eedfab68988f0b80a2a704bce916e2fe0cc8b6291bc7e3e6d71718f5ed5bf2cc928e5487aa917845d09fa920951d29fa465119546d08888719e53cf7fcee0be66d492866324960dc91185c7ea23b0f892eab5e008b9e1932d325599783d7f4f00f9684296b22e1dd97e72471a1733612fea84ec16056a393c187402054fb8ad0af56c3de12dc6ab4da119e8176c9d490a8ec3e221be05c452910e66706c378c23e20a45a65b95ddccf30e76f38d469eda0d9837f496861e8f847cc56fe1e54874625d7062613c12bcfe2bf8977da9758909156054a20d58675b6dc2f357506211680de749cbf63f2af9e4affd16bd300c1f3f669ebf919de0a8b46efb2e78ef873609a2e985c186c4edde19476bd78b12e5397d054583a86d899f717b24d7ef0ba1a40933a786898b4f4afaf396be2e800c27d829da6419a514ab62f064dff86b049240a5106ca767eec443206b2ec3c2a9217f6212d494665dd766c067d7e1968d03497c190ad9dcff1384233a734e75bf4cba2f44863a22941eacb21363ccbe7f3df85ae737a329f164ca82e73c1e5fa4a5d207972ddfcba5c183252818814e6843b8c3ac24aad1330b32147ff61410fecc14b3ca02798dafbe898cd46239ba23b2e85c9d4337849996866d8d474ead26d4a3b098b1707e2d7baf25e6017f863d82895e90c62801cd712e586beb1ac53c11cbeeb6c166deb9561a5facaa736cadf603a4240d8043c6d105dadff1322948dd3a1e218122c62025c2c872f9264cd442fc250476e227307d33c7167e8ad3a4c508b96b6612af943f35ba929fd6d2391284961da24235763846c6dbc3d08f868fc8831d564d62130d3e8650ff7e4026600253058bf4284ad9df9b8f74b9a552150e8a7c23ac0466a000c4b3c28f40f1c693d5bb6ba9794e39c22203480a2775387213ae92be56311fa8a915ccedd6b5d73e4bf51d575dbaf4ce18d160f2165bc45408460dc80d0b334a34eb58711785e85d4093cfaed42cfa710daf67e298812a6158cda34266b3e81127e66efb410fdbca66dd2479d3b862cd3e36755e9ddfa2acc18e0ccc325a9b2adc4454ff4e1897fec476eb8c00681a999d8df3da17834be7f436fa0e2f71b170bcca6be0534c5870ba64761c05bf129f1c1d8184c45e85d224102a4b9c7c27b3330f5b9563740d22d014271f66360d8766b86d4e60b76375dd18f1ba588e66fc3c3039a4151c85e8e8c555d29dccbeb1878f59998e16668fd69860abe7b9b2c323935aed9cd8126607c7dee9eaa90a9569190c26d6835a77f8a6825c1e86e8bb0e8664b071d411499d2f3bf3a6832faeb57b060b9b2c588e7913cf27eca8d5dbb6fae5e7abda0a08376cc1be304d710049b84868fca4a0bf955c744620398d31babf12e350e7ab854326a580e5e10b034f555e26c26838968f38c831aa2e0e62505486be17249dc6cb1f37d1d44f4bf013ab0d383481685d62f46b1f266fc2dbb42155eebf6152233a316fdf9affc2152384de124d92774914de95891822a2fa8e0d927f0a1be3eae8e001ecd2e28dfa3f252413618a2166e9ca2a815bde5c557c582dc142c78a06cbe1a59db7f36f03ad4bfe7bcdd3d75c144fb6932ac45efc1a36718a91606bbe67dfd70818d2ef3099a4ec52052fa920ed75b8b17719a86f610216990becb884f0991dc57b9bc5267e0d2f999dc0c091fb4cc4fd60c1656836e49fec4f4960f47f18bcd858079c51f33219e393a9354020058dacd25479b8ae46d4b34c72b533ae456c5a348acee2ae6269016841f6541f9f8bf1cccf06e0448efa846e09383e6f450a9049ee0d7cd602443dd1507d03a56cde94e4a6bebb03a2ccfad59e8f84f2a11a532260258596942b5e32b51ba630d17239043b15c73e05fcba036c490437aadb130096af7dc26c62e5a1b04c61cb932cf60a38c79e0dab1ca3dc684fc6de3942cef8c2b50de6c424d1da0b6ad612a8aebb3c6c8c10425ded8e6c8888f94ddfa07b99f614739e9b3139d9ffd9b4c0323737cc2fc86a3b06c6363ca7ab870d56e1e64ff8e48d66a2a057a72ad3670162c2f887598abeaae4e94284bfbc078ebe3ee446a46be3c9c64051c1e38bd703ee945b3dced20d804a5a92c1e762c33e31f25e4275c28af63ccdd58e6420c29795cf3f838bb12650f5bfda92eb7cbd1e39bd4b90e45200ee9ce44a0bd8b02dec0d585fc5de63bbfa59774dd8b741033c7ebbcd145b3a62634235eb1ac321ad3b13eb3d6894e82c30ef693975d12c4cb05e47123d582c23b3156b9bd408656cd84aca3e3d0fc31b6a4c846aa990bf053691b56d8d5663441c85867c9e33c6ba1877cb29edd80b8d79c6c9be8327a2703ca1d2bdafa83b7f909ea0b0e59909805448b9d4d60f60c6587af154896ff011620c152c7e6d2a3038b9bbde8091ba742a9a4058dc42c7ce282a5dab91bdc1c134ba839ae5e20bdfc95268de273537cc83407d066a2e406b4ece0238163b699c3e94f513978ad656c9897a191dcc66c58b4009c44b0c9decc1aa34833850629f3418f95622f470f21064bc840d0dde6098caaac76d84e949d7e5b479e7b0c92aa3a1dcfd21c2fd5d29749fb67157f5c32a48a10d08c6c9a3efeb0ef2a31451c3c8f1beb80c64612c155d38ba3768d2df437749aca7213559671028f1358c7a902c04712f2e07bb1b528a535d6e4f04df37e605bba9b778a3b87e76c86ea85267039d3be047f19d9760c065936774f4d23f524629b3256bb4484c68eb9751e8bc879c2bd13e73269608bb4845991493ee68251319eb5170b8d8147096e7f5e3ba8a787b5f95ba853df4931623f457e308d440300562c90aeaf8e395e89f9ecab0553539deb90475101be5fa27515f15fac5b232bf21c1480d2c33fbaf154be97ce7bc7a6ee708f059b56e2f95ca8f207d2cc7103b0c642a05f1550ad2e6c754008a3d0b8fae82a12c3b5f5f6c2044bdc0b717b550689c9be87437fd1437328d86f7402c84d410a52fc87ddf4e7faa4575618d3c035d678ca2aac087ab4319ea986383157e26eae92d55ccb2de78f38618b90d3842f9801cc52df77dfa96eb73085837f63d0d4f1b9e935c53c7cbe837997b07377ec7c55841ba362de13b09dda7a7c7a2bb3ffce5ba31d9fb89bd0fd76523bd610ac1125767021c8d84073309a48d62110279d77755473efd0875b51fac600de74636a460b7b677563aeb7b57ed466aa569c2511266649951aef101002160f4885e8d0aac423b091dec22eaf7cd1261f4c12c175e3a622140ff4d9a07ee5186f0241b2130a6c1c48ef5a1e60457fac33dec85b0517bd04c9ee7b38c5a10be1d273bf38a4fb1aa23b3398f93557b1ed9bcb73c6c69f8cbababbca4219194212bc8cdee280647a54a7b163a48dadeb02bfc8573ef8025d1829e72d92840ee43551c5fd3e04ed547e7d4b5e1088937a97334e2e2aa5c5847146ae2c88e853d83c19be53146ad1c7cecb7f665389f9dde65b2b0fd216160f8e1bc2f0f286c85f6b906591e3c31ab8da3f15095f8f297927819183b11727638f76bff69857b303c1ef5f8a3d26da510cd21b7a517815108286d178787efe7c296407a90c375947ea095e5392a01424066b3af325fb6be0c714250eefb0486522ca2ff16050a3ad54d8a03da82e72d658d39ff0ad0529ca7b9c40059688b74e41b64a3316df0aecc7ca2c538a05c1a07e39ebbf073f63dc80d95c53061fb9d5f9497fdefe34e80b829a14dfcbea3ffc04ecf22351cd0c32c15d4e7fde76f1a297338905f9463ffd18320555cd46fc4b04ab6673d11c1761a1dfa64a6b5e269d8cc59460770fc06a038e08a7c30fbcea0e49bb9b172f45c872222cd6a03ea440f52a38a972e3cd25f9f96943d876fb7fdf0a18af3abd0cb5bc808b4fc5a0974ed2e1947fb6bd8cb4149e972e09103240638f8221405a6ecd4010c40623fb5ee823d3cb6e85fdfacbd5aff88ee4ef205e4ca52d83b3218ca822814f1a90f1f4ffa0fc2674844db0bfba3a51dda3c0d400f63698ee50b0e8575d2daa61dfeb52820c97440b47b07a0bfe01bee106b3eace32f5184c24354cd57ae4bae38bd4779024d7c8ee73fcf7abfe11e416788bdf1deed0d63fb417b5ae002a55fa47095207a87d53fced31239f31b7cf5b23d04f8aaaecfc78db88848649f3097761cf9b2251c54e89a727ebcdefc6aa16129ea11e75186ecf9d3e3f10b2d23bf1b3c081f5014e6ac26a84cf9703afa8e92c7b5797ab3f7ec27163fda66ddba7bc4b7fb54476e5c2a82abf4569734d59ae9ea6477ce8387be76ce4bc40426b15c83f143528d72067304ba1cf9af09ce337de74bcfb001820e3adc7a1602fc7fff9bbc422f6f89515a4caa43e04a9d6f37c7d63ca4e5dd22eca68165071050cce4da37a978a9f07d430ce4b7b29ef877498aa9143ffc0e181d27621cfdc9d50ee507efa96c69de82a0f777b1e4335a28baf4b998d9cb8395ce47ffdff55eaafa34d151dc9b837903b800789762e4dda3ca589bc8812d32c49572548692ed6bff54266f744e587a3e098b31bf75807405752e4025f3cf8597623dcc397335bf6ff0a6e4b2613755a025fc0453593f3d055b356f014d193fd3caed3b9a3f32bb0c7f3dd7374768e23241db06a7ee923bd8ce15a1b6c4d7a2c762b600ed1f835a7f23de85cd5ccc4fe7f66a58b942f502ccaf2eca3299bdbdb5f088a77d906b8481fcb88b076941d98df89a741720dea2a5f468d94f94c6d097fc8af06aabc8357991c6e6e5dd678071dd5898d75f6404b4294c8f43d07376508353835301cbd355eb0e3d3d5be189e73c8d0ebe410460ceb420f1b11c0d47ebb6f9ab381985a51ad40bcbfd28a21d5f75258a1a746f9c052710ce3970a144e44dc0962a9024a2ec642e78012214aaf34bcff25b568ea2250fa71e8886ac5bd41303f03e60b70b36fd14184c134dc49d45b7f31f26cc744e3c131015eafccfc8d23b1798cd6263f0b3c28e58f1f2d1dbcaf7b495d6fa4b2ddc2aa4272dfc7261357623eb4d7d2b6eb8cbaf07a24ba11d13b8316ff7deb71f44cb5fa738a6541799aa14b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
