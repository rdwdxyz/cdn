<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d189890b5bab00b673c2284972d72295b177a824161ac4ae417ac1157099ae91e7682215417d8def5afdabac9e6ef71a03fb89c1100b6dac6faa0a702b60fa5d04aef406e43de27217c776a0acf4ed3cfe00f5c0d1fd9a79d042c909b365e01a7d379714a36cb9629700abdf7e659ae47dde97fe312c741739f0be8cb53c0f9003482280e31f1154facefd749042bd50083d4f93ae6900f2f02ded83b46f080c2406996ebad05788b37120dfb8396e85c5f894bd428258ceac1c7ae7a2b569592f86a7a31b54abfbdd8e44b61fba69e7160be8fa817ab5381f4701ede9fc9bceee0676f252ade0a073d6d494d0655da97aa112bb7b5073e6f9c4fd7027e9563e3026ed69220fe09018732a15fef47309f1d2174d9ec0de6bbb59147703ce4b57cb110cead233f4032536ddaf0112db93c27bfcb0765703f726caebd91e9bb1a97df2249e33a6915c448a43ddc7cc059a082b6f0b0a26602b4f72937a82640c1691d5e6da1ad7418b511083f1fff8a09fef248a8b9907b768fe4bd6a72b9a6a95f0533ee20928d0a6dee42cbc84a8a7b063da32ac985ab9fe8d732cc32b93945df92479e50291fa7417d7edefff1228350027a019d85b8b81ba3a7da649635c78904a1d5efb2e3411c769c1ad4c0eceed4227401c1d09aa4f7814fde16177bf11198f448c4761f31dd262a01f40a06ef1144d03d86628a84b735e109f239c053793c8c72cbd61c52ff993e09ea1d750a3dfae32b2ae5ae04e46e71fd8bfc72939541249a8a62fb3f9cc62efbf97f8bea0794958acdd634331b3f8a5054a1ca9074a1f15f4cd889fe09b8403a7704f7d54999cb92e38af3e70e04eca080ae2e55cffb4e1d092b98001902c570daaa6190b7c18c5f6c5491aa127559124278630fd8c55f8a9cb6bb6f15987ae3d868ec5bc8662c6a3e92096decaad462f503d70b63f6fec2c3debb1dcdf961d548b9d6341c73f614ce6ffeae443987560f2eb4d4c6e0590f34c3eff4868870180c116106c98d0ab472e3394c552a8aa899eb652f11580f0624a3df380a8318f4098d9c23b4fd1f106134659a12f6fe643047e65ff8f640efa4a30b3a00f84b4ae9fbd1344ef03095cbb8b3465b0fb58711daf67233455ccb1aff12ff11a313c9a218a399af279e7bdd2471efa1ddf6f86af6d5dc8d406f900caf533dd1ea62de1541f3c22c24b63aa5ff06106718a877929a580f4dce11f40ffe06315e02d82e84ad09951dd89a55d5d9aafd3f2c8a972c7ee0bf0434e468470457aa84e73cd4381042510c98b20ce4d09df8f86e770257508e99388fd6c4fac36cfb8f353cf868a00596fcbf675ab1a4183a998b549060e88095afebb56e8f37f1832c9437e1e707507a7b05b097530b350ada159af6873f2c3dda6de56538667ba83d158ac4b85a88bd81c7407b5c742ca2704a66a16a41e801fa4237ac9913536972409cc13073b848751dc40731e0ad3714320b316e9c1bf3cb4a41075fda4746fe07044d3a2383b9c7ab45d54fd3ebaf852903d4125a6db6dec6c89d28e724b5ae19dc17cd0f1777ddc45ba0362a78fec87561651ca3e67e22d0d4265272a9b52143c8ad45f1de53716a351ee8ebb9605f73af46380ec71037fc73f6fce15aa28a0acbecc2f66bfba12266a92071514a8f908eb111394f3a22ed914a75026a7757f47c2f994caf6bff1648d83970d8983b7247c9ae495f0c43f794c10930dd2a71ae0c2add7798ee88f7a8fb41d034d39c2a620e7b39d0027e49d65f630a33f2cc97ee66713405e39fdce48a5470b478a329c5e9eddb74757d348ec597087762d27eafbec388d13ed128a5dd5bcc02c53c0dd15909ea8cc8a630c6d751c0c0726c55d6c9d413a3ebc42f9fb264966d14be72757f52721a61a9afcefb4b213a02a3c0cfe64659a31e1c2fc5280ea76e03aa034078e526ff34825d7e96660844a6b1f96cba2bdbd58974e01b130c7b9d6d8229711046b99eeb9b84691862ea8ccec70dc03aef9ac980bc44d8e7b8018b551fd9cc7fa82bea40954392e92258bbaea8389aa125d8b1ddb386e7d99bc76b5cb46064077e170e8b9bdef198bdacea53df656233c84a7ffc4e055d50ca9063a985314ee5bb8a6aec121b0f9bfc95c4db108203fa000a176b96f002f26ca080a6b4f3fa4072ed8c70069124a80632c4d8a866418dd7d172ff8c7fba9dc0dbc4dee0797b8750af48d9f1f59a41485ee495f8f05e40958ca61ca6c434e3e7758204697980add4e88d469c70b624820f4e99217a5b36b04d2429de114a21994d79d6d1bd083963431674a1026e87afb33ca0c9513532a5d17260125643b1069789de01ae815e6771f635bf397db1307bfd1c3e768a5c7ec4f2a008da694374ff2e8a8c44880d5f259cd3a69ea2270d0dd813f5e9e740b74bf7839cd6c047dd55918c6397fa1adf7b8e7e2ba18a248f922b8feeee80b34ae9deaea91219efc6ad9b8241c4c21e8dcab0ded8ea459b83ad9de8738407193e94115b6fc7e31e26fd3530cad15b08a30437b53d2541e4e8ad52260085101c8901cb7c07166e3266c92f2f1ba934653a86d8d164dcdc282953809b946a3c215b1fdc4b75725bd372fdf707d668fcab529610ef6b1d90b5e8eba2022758d10cafcd36f97073ff5215979d82662d4540a77507bede83e87f20f220dae70d3f766d41721f2c27aa49568a10f94a53ed2768a3b0a9cad9f456d67d818b7546c375a4cfa395a65495eeaec3c231c624ebbf1eee8d0354eaeeb84ac64461bd5c73f7a3ba4070ab2624abd063953cbfea6c323d08d331adaae31787f99a132c99a440b9ed16a63767f379c256d2d5ad255b5ea6c7150d2bc9a999244679fc69b288a197f3be3453fd32fda865471b6e3893e1102ef86e9451b75b3d29f093690171e38247e9813538a0e56ba15e67ef572494b18a63bc9090a6d081e2669b60d7142163e5322da72e477ede56a41e69e56a4265d06a060898ed9ebe2a017f2ca188790846cc9650311892878903cd0534843c9d195882dffedd8b0ec3211b2c3be72c3c19502699d5ef1aeb224147725356cb87b95946857182cdb645f8a20e264556d84e8a5496939845269ddcb1f667c265279c93921c7b4178a63106cbd1ff6153a7fed02b5b5129899b0cce90ebede0bc7b40d4a2ff2196e12800e22b5de62a6b693d847e8bc7acdf06f1f73afc72d262bdd376ec48b87d767c6484c518b625143d38b182b31bf143fad4eb5c56b0d95460a2d9439c4d48471c3d0093a9116c24655744dcedf02d441e09dceaffede53c1e4ba1b20c40541d13ff668f524f134b2884d9b29e1910e27ea76e32cfdc91e9fcb9b3f83ec8ce110542879c1e04a9a8746c656c9188efd004e4bf53278355a3e7ed633ce87d7c83a89ce49e07326f93b32b992547c80062bac97bbbe67ff203a6f2444e059ff29e821c0cf02d840e5be6666f78d31036f92067cfdc4ed483489354b8a55a920079d982563d0fbe7ca10ede5ce6cc91147125e8cc98951e9223afc1829413e7247646111a1158e7b5a919f1c614cc5e850f9a0b4a35ca67cb5e230c9d3cc392f53ba6506c5b2e7210ddbcdddb936cbb5885c122627b2320e001a92ae07dd7e54491b83dc2df231d445cf833cb5492c64a558b4a69cc52c9962878b3a4214bdaf1df14446068ef68464f80f5b341a6a70ebbba0fa3df7c6746e51c8e9480571735e612208fd8560302f0a43f397d994e51b5397a5f995420814736176a6ea4e7b59a5113d1ffd803506723d9aa4655bf5c88dfdfb035ddf68fba8a5db87cbe9473c198f06f55b9d4a4962478051476d953446b2893ff62cdf5e0b2754fe5000b09aa920ea81a25a542ed98f3bfc3df7e1ecbcc38a0471b7fc457319b6d297257a7c8b7e4e58ab4a567882a5689682c95f5f855154908498c7c3d32daed8f54138ced46bf9cc22a2175198e4052fcf1355744df33460f75eb6b961c6930d47e62da8742809e31dae7b7e7f57b505385f33831f1f80c510806a5460265ac3cdca595ffaafa21f0628b4783131d87071ee40b62ddd3589799595684354a9c0718844e618c91298b6aa8ca0f237a123bd721d8abb246cea334a9e5455d6d08de1531a4710819743414b5478c2c879d59fb74b5ec5b6ca2a40944415a813b0d3cc5373ce1b6bcfa19f200dc2a445e6d3b321219335d9ac401f3deb165ab6e12ef84146ee424a7ad5cc753afd84edf23b8abe4dfc6b06c4f755b736e93d28ccbe4868d53be31c863e8362f2e071be377c3c6044f822bedcd607d5caee61442543add2ec0bc33eda7db7299b05e40d06c341c4eba91a1f5fda9841d97205f9ab6082b27025d901ccb8ca55fa3c35934681c973d915b1455c2dab3d41d58849bd8df1dd08ffb2fbb84faea14547038c0a95a867c8e1d33081df8788c60aac7b908da052dd405660fef3301cda87c01275292113fe6d2a55a7589d295b706b64e50f92c725495ef7360bb460fecebce2fe90c3bc9e95ecc1aa469e5400734c0b06f00e3508cebfeaee179f7160012e9c8ca46ee5ac7425b25e2693fd48e31bc11d88afc629bb30a36721e4de0e0cf8d5f362fb30b77fdeebab1bdd02b710d6b8f4fe9dc9518cd002fbd393626a9be9f76109b1a98028369fd0e0cada7ea12a2e2beae1ddc73c8772861b2f2c0e52739af3a5bf78ce046c465d8493d42d2bbd8b6ac1f9db3b758f6c6475765f857c5dc0f35040e998e8c45b50ee346ec6515faeef938ae4c037ebb48152222ba00daf4ba1992632aadd52ca9bead555d7fdffe619bca296f477f728d1570e46363d6379fff7511ae98f0484082b1d2581935d85796c2c7f1d3856254e2612361bfd4cc83d37a553dd7939969f4410a4b6882a17b5a6751a3dcbdf8aa53b1464dcb016c4543dfc739d73c219eaa60dca40ef69f3b31fde08ce3ed1dcd551779dda99197caed41b556677b933cd087c0138e08c863b919bc595669d8e1b1b40ccc7170d6bed104cdc6d60fb9036cfc4c5a328d0e0f4a8fc043cc1d71895db5543420bef906cd930f523f5499974e7c943585ebb469b608a1960c49a6a38ec681084106fdd3eb61f5be3ce3c3d2a4c308b61f17b8e06de5e683cbb22b6bb8d455b3e912df5361003d0514fd1cc4d00de5f6cd954d8cb847e63fd516cddbc4333fa0f2615485272f484728ca4efe7f1f3488ac80eadc48845ffab9dc347c0af8cf9dd7308fd15c675381453ede9ce851588404ded8cd5c2784a49f9789b5e7a8ec83efc4103531070c6e6f72e5aaca228484bea1dd64e7074dedb9bf38fe8c6117b25d249b71337d7f89399e2221143e773289d18771073d0b96e1f3b44698ba6889579dc990a2ece6f8b7d87c60e663ceb610692199b657b4c6c8ceaaf9b08441ede1092fae924344ad8eb1b953b31afcf102d5929dba30540abceb0bc373de18a611d4ea29b4b7e35c6ee1322b5c064ad5fb340d1e3981cc00ff8cc950014aeeb8f8764715c6f58eab5e182b0cb6605439dd8fde25cb67f4d8601285482b581345338a9e5fc84de1c6debe5a4eec6112cb561292a2f2a13a560afe2409809bb9a37b6393a4a059e69f1835b4a9da9e4477ed4cc52671225cf1ec68da6b63e0b87974fe1a294a27534bb77968955417e43c7690ddd81945741c373f9f49bb73f1ee300b813b1e0d8731d17749672578934a01df74d6cacc9276833026352fb4addab74a5644b7074221a849e0fd9b661156361c396dfcdda44c5f69d92e4fc2972dd2032ce460c92621997dd7fd41c53c61577ef3584fb0a254d913d98ed66e8e9e9035357a5c5f75ff331fb5543ed35ef6c07b564dc1470e53f366deae89b2bb0c2d17773fb5f8390fbf4745f3b5a6fd6d097b0c7b294cff5a846a956272500fb9f236f42f53c26c1d7a1b827a3ab94033dcc01b13a4df5e270fdb736c8451b654d99b836b362a180171bf48390ca19538bf29d8ccc0719597f75bbd073075859017591fbd6e36300168f3d8f806c4af12e9c288334ae74f4de505e73a43bf639efcedfd0e85168768a28e24b183d8632921cb816bebea6bc037229251c429dd26a5d6257f21b4a66aa21a73ce36fe541105933378feb0244b2b23a1798cad81b501bb876e7275995a1605af0147bf2634847e4e551d5e4f18bb3753b952f7609112932d5b9d03aa38739d49e99093864a6f02f06808dbf3eda09eecef5fd4b31fc03641255c9b47e4eb292abeb3cfed48c0d2ed98a0808ae0b0379c81e7b7fee8ba8a233d5ae07f58f08430bfc5b578b0a7277101742a2d2086f44436ca4ed73c32558689c81f115e0117e742f171f4997bed5ca1636f2cd1fc01608b004c44a2f943c92b1b32b7cd30dc024c4955e459de044f41a27468cedc4d07c91404207291a531ac01abc1eedb4cf06f1e3de60ff74c6e75b10bb4ff6d1e2835de3d11c7865cd44a1324c9571d6762997ade56417289980b482dd909ef61a2b75699fb348d9d4057d0ac1785d739da0d8322542b4b489bbf034eb8364fd8adfe3d75777e0a773876c882e534ae23446195438fca458205f2e53439c80bf001c777a13f07ba7c34e6412e585c453d81aa3f20b0fd6d8ebfc085954436f521b87779d932de4ec98f2e1da20863c21cb9ef73d5156e1e309a317fb0e2de60757d97d7abdd1fef58de5a1f46a7b8d21fbbbcb0b5ca2f43e3f875e5687243b8f9d7fb20a500cc4169b0316b2483c9bc9ab19502ea19f800380b474c5edbab149cc758bc7f7592477a22e65e6694ad90d9ccdbc8bac0b932679e88be2789dc5c467551c4c3f13565ece68baf0199f8a36bcd4bd1200bb8b40fac8d07d689b9bcaf7a196a821356745f579145a653f04703b01ae323793776f87d188ed6ec26655fdf356d67ba6728e0cb5065be12f761855a57f1b3b4fb8ddf6137e8c06ab19dc105285a5ffdf86a7282507f33c4965d3e6947da07bc178374a4673a88659057d8065f01af0bb0ce3d4affae5658589b98dcac7640aed781ffc987375c631366108d77994ae4d868ebb6126632b696c802d31a4e03c585e0726e4d54d3073bbb2be03e03e96aec87ee6d10eea4511057da8a3c99f249cfa9a368619405b7c445c02d6c32af717e41f6fb710e4ae986d173b5589505cb8a6a3a5bbc4cb7525ab9f4e6951d192d8c690e240e65288d2204a6ac0c23b6342fd31a066fd96aef2f711a8666e489bc4c9b491f8c064566e8c471ef3c3ad06a9325ea3a743423529ee90a2e4bc2f4c6c1682f99bca6730070428de37068bb729fb891b1aaf1b5d4374ba7a24829661c295782a8bca6f702c2c875a421760d6505cfbea8948addd4e4350eb59f0cb53e72268b04ba84fddd7482795c0c20a374ddb60a2c6730f7ac05a496683da4b5ff88b32a98280ec09112d07ade214f961960eefec7abe0b33855aec0be29989633cb49bcaacbca08c31d39d12d366462f0d211d91f32e7c4991451642dbdd8888b459b7accddd921f2849c21281518dbaee717b9d21818ad560e05ff10a063c7f1c42c8b0875df997f8e9fe619ee9b3985439d958a10bf7c0964e8783b0709310f4a1ae37f0d133ba07952173168e17b307902a1cda7e4b0d4cf50a0958aa1f4caf9ba023d802a66d80f0ae62b51ba742b3bb8a143ea591c2ff2fe56c87cc7e8210e76ca02195e21c498fe75afcc465385ab0c2a87200c88451fc4a20ee8a5f2fab572178b48ecb11b5c8aa404cc0e83b8931f887e2e648dbb3971cea966d3b164e21a5d8904effbb8bd7a9d2b00bf953b24091a31a51deadf6b61b295b123126a744a861775636d563b8968af339246676f5f74af611a62f37cbcad8b1c6f1c43ce4e8491ebd4cc3bc2216dc44e63968f71576f09409d3d5a857941237eb7902dddc650636789fecbe049980eca5f09192b56069528a946a41bd8451d944c085cf9d01c31553a477bb73f22456ef107aa963acd386f8045ecc841a5ec4ccb8a176f0a612f572ff1891a93e6d44c8c5cba0a31a365ff509bd9b8bb115781a135dba5ae7b69a56c2c2a7fa9270ad4ef9dadfd2d04f07932ac941173d9a1fdb3320ca7fc6c142ae7a34481949931e910c3beca1b5b32435ea3d4001110bf803a61729fbe08c124f6924240d3da276e59ace18b7827705cfbf2702a4d3cb94531d2de017a56a3bccf1a88764016b5fd66aa45c31a8666457332df265e9d09b533557feb5eea2e0469f989aee2c608329b9a9926a413f6644b5611561da4a6523f5c9afaa840f8bc11ec9656a5753e2cfc419b1ceb95024799026d752148cf58293c1081cf0bbe6c39bf89520662e6af42aa6e0a6a4c11472fcef79f9e7d48c483897ee0a9abbbe510d677b2821189af26028662fd6d05dc7b290ad28e9b4d1b4fe527d26c9a96e9ff3bf2f6ff324fe6ecd0f17e8c52c92b346f20faf01ab63eb85aece1c18ee461b4785f7504a08a3c14e926f3748751af98a212abb0c6a7bc95f0af09bd4b2706dc884ea583c5bf72491081683b0edec757747732b58c9c228fb416a9dbdbbfa4c3e7ff1b5ac2e4aa597e9435dc4b152ba255a95901515046f7de0bfadaefd3abe16ac5223d1e4b0c1607159c8c5f67d1a8e19e5c9f754eb285074fdbfb6103c15fc2d6e2ee17fcae167f3d0c436a88cb6f16d96c08ff1956bcee15d1bf6c88c4bf640a5f2ede847766456be37881e22f6e78247b349e87ecc9b0e125561814d474a35ed365d720e5cf6c6f0f174a11f654e942edeca5e1a3c5a5fa57dddf41eadc48d92893dbb7b052300b14f10946d9e1cee49808eb48a88ec1ba700fb050fd3d3eafc48332fdbdb62f149d7ac9d911636ecb4923733d76dcba93edda90a84a28bb4976425b9a09eab6527dfe020508a73a115c5b114a91d3c94e389768d2b692eca2fb5727a977b59a9efde2c041b6d21742730037928a03213e36a609ebebeef803a6dfadafdf5e16f44c8288236ef318261aebef971ba0cd4fa8e41b53aefdc0fb30f56651be547c3d2b0f2339aa7dbe9838de03fda0656c23d2e39970b7a4fa526dd4ab183c8b883a3fe283d617a87b1b33e867947cddf94b6bc7c7f174ab99fdfe2e54d381efb2603d9b023028fe3a190ae33021b3a4b4e35a2a80bab7c97ac558b985eab563d7d2cc1652fec771734871d31c2b26531cb1f0b0c369e393c63464c9a4aab8b9a7b856f3b12adbbf64b45e4bee94db0d91e82fd1bd845bf0b5842f0b52392630e876d4fbfdb9e84c55640842831e60a5b81769a1e4aeea19b64f5b36443e7ec8ea93ac0882d0c95f85eaa7141cbf922366c91f6d93b3d13bc42d9f6cdf87b1a1cb449d3608aace5404417cda3eb1adeda9f009fd18108c20c71a0afa929881b513da17e40da77d31e30d55ddd66cda97f2f331d4ed037b7852716e3d637d4f75fa817155f44121b74dae19f1cf4d1388cb68169079e73bc6eeebd529f390d5e17460569130bfa85de9325c684d6d087920b2da29a85cc4b3d18e7393cab86771d27660f9933d2a76e66e8e79a81b057e34b2c99fd0ee84480b269f2955d178ed408f97a6056820bb5c7fc64a8a4c0532b6bb1f107cd2e7cac3791ef08c9bd94b21890e0e4fc23118694b53b5192c5eda79bedce8341488f1294c2f23cafa290a2b811f8a28f237a1ba948a470563b0a32b36738f0b1cfa0cd5caf14f82ca115f7cfaa38857dd9a318f553d88ea446734b860c89d245b6abeba04361abe59556cf60e5e3f834a49ddc667eeec55e7d5faa77734fe96d6236f579292143ca1c3ee017e1141924ecfa879dd7446e49e957fc75a084c5cfe594e0a071139244644d7aca2baa2ea827675bb48701e6def2c782fd958972fe8d8f9797cd4e2d3951704340379a44253f542c5c2b1df8f2ab8216146d839828dced2e815812811739a61062bcc572ce1e48d92e090c2522269b5955d177367d0ae5368bf4f301fd65c0e3bce2cf47cc8642170cc7edd5f3b81522662e8e4465a7fed78f2ed9aff31bb6c2039d08fcf9c66c11b146be347a9286822da96333c410d5ed576e70a4c2e8537739aa725e9385d467ff9b9348393f3750acbe08a05eff30f1ce72daebc6d030afbdd3ae06b610ca5487337e9edb224b6995a2f074c90ca8b5e6fd96918cf6433f554497af8c5d900e2f3a33c305e905b6e8f9eb5d1daece155376909ef39332f183aceba7f1420153b1befd7bb4eb66dec2df33ea587ec28f2f40a70ba27d4372884f74a9eb179b0aebf8ad2b39ac4706031f50ae87b7501378538e5a03e8b58b9245ba59e99955d3ed947e83a63b79727f1b9a9358915d67a0b12de7c7fff38beee06ea65f0779a552cf59675136e38a5ea71b44963717f3b8605931a4d8da123a9bce25a982b985a91b6779a7013471c0e9312253f324bf338026025906b0af557b37cf71e67efda237e7c54bdee0b8ee967dff8d61bbed4a244e27c3947f8e1dddeda2f820c0f138bca99e96ff874bd84c17b9a5578773b456bf114cd39743bc745dc574898c4d0719b46eaecea7b1b0c998a4a4d29fc9a04f53a113bcc090b88faf6966c94b2415403dd674be46888408731fb8003d509cdaa7f98eaf14fba6dfdb0e05203c3649c6fb9e52e8cff6642dea6223a753b20697894e952c0939dfa2e1c73bd3400096173ddbc2c96d0fe932606e8ca4c56fe6cef5ddde020bd1dbc0873c53a9e5fe4416c34fea0ff277c514c1edd1a9da0a6e5fb7636a15c0dcae7fbcb03ec62bb743064d47499b878818791e3b469348b5df27dfa581e770c234c8539636d38cb4551928219cf9f4d05171307aea23a0822577b0dddd0e21d39936ce53c44eea0e4f0af367e1181079d95b35e1e8171145d76fa7149b7c1667157b15c7f07500ab468367ee12d85e9f9cb7fb6235033469828b57669dcc0b8e9e109b7f5824206f35415ffefcbfef77bbb546c54e55eff9e3218de509cb3023e096a8b02dd300ed54f1414d2e73b4d1714a0a8ec6452e1e93a5b3c24670b33e9c143d77ffe8c382ade1ebe7d9f6b419a57ee4a33d4b68dba5957f4c91dec8a20e59ebd292711cf9d46e6c1eb202deeed110c38e1e81dce16c4a931cae178eea616bd96618e9f8d6fe7f724a1da11aba6e4c988b5721f34bacc35bb32f9d9ce746901f2c895ff9e0f56222282c8a0c1915b36eeb3444e1f3b73d27a7683db5ec13c2ab5667dd6b17110c58e9a61ae55d5a431ca6c51be6abac532e1c4541a0bdaa9deda33ba771ae7129b33612dfdc354a0c74728b2e76293617dfe4bd3ff0bdc97aae56a094819b82df715a4d26df34fa5f12597ad9c9d048a91c38d45cbff1aba9b76d2ed677f41888f5f120aeb59935daa00daf2d562ef3f10504bd38de8f737248e6fa42bd2af8fd81adb4d03c8d2edd96512a84e969811939e4411bf5a36182fd653418bf741199c8c2adb1a36c65d7b8a2394f51aa2f2cc4c4f76efb143ca89dffc6e5f633911576e91a85fc0e6a204a57fa5351d4ca251f2cadaf139b2bb308fcbbf89b7c02f2f754a2ebbc763d1cdd7760caed92e2f9f5f3373a7f1f9854f6c870bfe526e84e6e2209f5dc4d30827735ec4ab7221114d86175b360710577d02aaa3661ad2b1705947e9535dfc3776f348e38bc025f8f63821c844260205aba26ea239b87688d53c90132d838d91ab9202e264dcd008728a20319ee0a338c1ca7adff82f7a9ec7030d20ea995676bac57139d8fd80755eda1fb51605545b4f9779175836e872d0b52c320f413bd12ad030894bfee4a03982a8af965c9ca380e719667a1f1c196f260a8d972b4dfa4f702cda808acd70d7672a1266e273c7b6a0ec691836167ee43f2b1a017cbdb7e66277c8c16d1f7a97be287add44b107ca2b3efb06c2c4009c64e3fd3134e2e58afe0b8f223203b8f752476c3c6d949eab1494c123cbead920685357242687372fd56627cda67233895a928dee51fc09a50dbf62925a6abf5c7efcea7eb174d0ed4a4d69017f9322f13f1fe881f6c29feecc97591e3b9e4259b98f6ef8bbef3de0aa8cefc0e34b1f42c8fac03318be075b60d2ce6693fa0094e117e9c03428be083ba8894c20e643a5ac9d410f982e0ba370f749e9fe39cb535540b052930c9d6cd66ea7c3484d4ce739b9899e984cd6ff350be662451b80d985a9807d69a114e6bee044412d299c1302aa29be63283cfd66fd43de7f597c8dcfc5e4184c0678284f187f300c804755d8ba9eb8e3fd147c78906c7018770394e292f8df642bab54dc2d26e4d1a9a4e6c89f9b3d036a55022395ad27aaba973d48167b9a90d9ff62da7f7f9254fa6a4ecbb8f5aceec758769c81e4e963a160eb9c58c4ae6e2db3191764b20646811e6ef7cccc41db57b7977e3422a864d7b7addc5ef6ea77bd621df6d5f9c7bf2efacd14d52fd23d01fb62bb0ea5cf5fb51da19625d660d16d5870e77391452d66a38db045b68e231dd99a952a4aeba26b4993631fdcce0504d6c3d2ba24c8a95c53e7d584d5973a4af1c55978339840d43777c7bdac17d286600448830a52cc3e054e7fe279e74bd79daa78c1afe37d4a0b0050a4586859597d547d80a83f3e48611683dbf08eacbb0688908328df7c666cfdc3de41260f822c998223356dee3f1a53e61ed3ec50c63291e21b6b90fe16e39574a04cac532ab9a4227b04cb3bc05701a4d0c3e6b92f2955695a1858d8b7978a2297456ca24b1a9f8683e2fb35e6985a3ff5d058413c63adf3cc5bd9b55acccda6c77b0f6a341ad30c7c0c3bd42ac75eb9fc8d1b3ee4b0f597fe672731c48fb97918d50c2f05788c62459ae64e818e86eb6d1de51d78b246952764ceff4d2b34fd842111b5901f4913d1ea99e135488c2c6d99d9436cf8a249d93a2339542d56c21604aa584b2b8b104bceb8aae400727dc51cd75a2f3963889dc47933f7c5448fb4beeeb8b69feb5e4f510ff6f8a2ffe9d104af9686e2d987ccecb749e18c0f773b1854960a4ea8e5c2b6eb4996fc4ed07c7e390a8f97da89f293e1e7b7b8dda97f710eb6475ac31fd398dc13d4de0b85fc91b84f4e3d7b944a50694038d544e947f988e8b7edf0bb45d84b55d543cb54f379c587cdf5ae4d6cdb097b7a46e3eeedecf8701048154c24fbd51621851669ca2086535bce53dae7cc9ace4847124a3a12d85f3e6fe2aef653097a6b9200563d304c47d6fe8ff833b08288588cca9f56961c5d294da5556cd9ff27f33cd0d4ef835bbb1ed1d16246b67b4255f74b9679c37d692b918e8f60e464b18432856c6ec054e0d75c570eb05ebbf54bdd9fe67911c58aaff377c19170f5ec69b81a37c716135822c648c3f4e6f2eac60fe05cdb430288da60389e5bcf8a18581ebbf49d6a0159d50c8e60aab008fcbc27b786840de186e2e62cacb1992445cac01d0b6c087a6492beaa18d895e6c0a4aa19ed2382b34456098e0ff9eff0c21aa73341e97152f0b4816b7e23bdfd26d20d70c676a2d7005e7a53d65a978aaba612d8217637f31f41cd81271dff9f242deb48ca4b79c1a69d7d3791ca9483df99378446deb2d33c929946c162bb51319a723f3e9ba9eeac1b993fbf1c341144cca5537854e44329c5c299d71385c74a7420f8fbba431a001746a045468e25fe8eb116d786cd57db4a263e41015aecafd01b63c79de4f68378b144b1d2c7608b7517ae7eb00d88a2042d16ad9b3478fe4de0eda95d488df9b83512153c8eddb400aedf42d4d9b448b9677951d3f3f1e148a73974e8eb154b202059a06108a102f621460e17bf40be41467344aaf0b82046aa49e63301fcdeb51b555d3c86fa09e54faea713d67b372421dfbe0a6214e864f61af5b4d01fe37f88bdf915aa8bacef6a96e28feab5f6893b65a61c41f66c44d37f3cae06046151ebc39b136f0d016b675012562ae00d2fc41a6493c89d20ea1e19f8b48bc62c08ec961ebb8a776b3fb0b2a988b686db988062c6b2ca267ebace24e40ff5f00ee409872a7dc402dd242da9502350c15ba05db20b1ae8905b557e2be8ff6bd70a2e1ad390c181a091f3f8e9da81a110ca7b5763cb89d7c3416595bc12a4621cc8ba3fe8cac26f98c86191ba46e8fc604608340b674b23ed0dde80c9a8a4d9abe3d4fd01f44ad5a24781904312e5a602ab59f71d21811f25fd6046d135f3a870d31a640cdcc5c2ac7ba593c1e0975336ae00b053c7f28c34471bb8b700d362a56eae6a19f5856606a92cb22ec31f4e18348501733f859bbec23e8066e0740d2461136bd3595c6a7ce2591919aa5966e9ae71ca62ed7e07dbf6658357d0ee0bfa6ef4768cdd80963c6477972d147ee0ff89e9521e40a31e8aa9ec066f71dcbda8cedcc3d6f161bfad70016c2325e7d40b38c1a4254c4b644c964f632c8a14b0a419a17acd6184a437e59ac6716a1a7063bd7feffaada9b309ee215021aead6ae4d5d159abfd5a4b473884584e5974aebb563ca1ea316d8271e972f105eef61ffbc10ace539569ee613a7f86c0fff1b2c9e461aa17ba7a612a7d0781c024163dafcf4224057c953f8f4548c0244a40ca1fc711a2df892a545be77bb1872367e08bd244359fda130f4302566bf98ab1f08ffb21fd6f103785733847ad35592af9668272e2569680276cdd20df207368ddd9dd928c1298a4bc5e78b20ee749d23da11ad6f5f8325dbc838103efbad48ae271c5aad9062ca2b89f4047c35b45ebf6d7acd640f990ff5508d337a6e66168224ccacba9dd4b371487c717cb252879f13fa647a24b76b886113c9f3be45d31ddad0bc4fa3543636307fe327f387a1e00aa437f3f2766a167c9a464ed6773928e4aafc4a22fe86c45a501c4f632bed2bcd5162446a9159f2a109147d83c19ba3dfd038c8cbf8c31f5cea2633c5b079627f16236ea18055358dfa981d7e76dba2c4d1a5cab3244b5cff9131c6cb14943b0133a50fce6c55dab7212460d82cb2ed649b72ec0f450f04ccfa5766cc30c2ec3935c05275b763fa72e3358d19a2b403e71d2e793c601fe4fa688d6c182acef836b554ffb94e8a1c7afaacb8d22f1cb603218e452dd17eb933d451d7400363bb29f138ec5d1de785ac38a715ed3acbb112c4cc18a138b07ab4b7599ba319fd83d6a25a6a806f1109bffafeb7d359c44ac69d8a0c03504a767a830339ea357810dd6c9f6c8e1faeb627a8e5a103611a6b56bf77c2c39e80f32359cf18aca73e9258e40ffc967e8e6d9ec9f16e20dbd72e7390a835676f072397011655e7e19ccf9ef2941420345420d19dd092e177a8efce187933da0fd4803d530166169156d875af190538cc7841ea07f8944f3c72154f96d72d730babf93d345121d7640e08a0f3495033fe1c40fed48783c5d88d912f85b9b56f3391b47a84b9fcb4cb8db39d5e5325d0520673015cd9bf49a96c9778618b11a8aa6f64327de0bd1c72baac74d1024526a9c4576815e013772b503628fce69246fd8ce03dd727e3669782f32309460591812a7dbf952aac514c01d0154a4760eec368d2e0369efb452b1663d51c6906a44a4753e0ad1c63fbef9ffb785a8c24e116c99fa6604842e6539b300433863d89d07737dc9a15b1b6e3e692b4b5f3d0f7b1335a63e6a3d440bdf7cea0d719307d2f4434e80d2e3c2779e7fdfe63912238040a70950323ef9d1a3fa00772bf7dd8164e71614cd03b62d893f1aaa8517051d738ff2267332e17086e493613a38261deb7dc5dc74ac20244c4647e72e602ad6fdcab915edd55611b2c5cf2b2d16585abbd43df03a3b3b93d537697ae7564456e25fea4bd68d163d64622acce79573aa30de7a13b3dda8496232ad998ebba2a2bb1d519d2660797490a89e31b1eae63585e67f74781126c1ae79fef929cd60b217a0cbcb0c697554dee06a003add87e7e739ac89f4e99921a374a711bad44d5efd4c255a90bdae807593290509ab003623e42c778a3fe71a683e9ea2bc9377c36781e58be04bb6506d0b89bd76043e535b2ee2fdff750ab273ce3b241d8d4c8427fe336c930721ac683fd71073a9305bf8d851f0b7ed90748d018de8bc30bbae79c2ac0900dec12b7a3dc9b1960c918903ee4eab13080e43fbfbdc5207dab5d6a0cc6ec607513c8038a63f6443a5904e24f031187fdd775a92d84006704466aed2f8b64585ce77aa866ee8347f043e64240a4615903ad8ce836925a9ee3fcf01d31f0c18bae8bd4619867d6f93d6ca19da87cc3de3b06ee80005695d8f57e328049d26aa9ec00491e9d20ea03d77a1870e108643ef77b2076120f1d435df4f5bf09528c2ee52a9e69be955d1ee346f347cce7280c438728944dd41d7a9617157a6bccdf806576e0d8930f0c6383dcafe68ae160a9b698b40f1a761ba8aa1daa6aa6b008416a6e37bc5298f2f74c0aa218eb5a88ffc36cb1290d2ad8c070ecb60985b239b2baa38cc1b7ae034939a3716c895e55105c285a331d83387487e5a41701ec814aae4ae224303488ff19ccd39880d25328063e48c6a04698ee92d6e8326cf21bd43f7c0a94ea6378095190a02f76bb23d8c22788d16393b9606d2aa58d90058e718b646d7eeeb317eb90f012a222f121365a470584025a4995d8b3fe0cd62ece959be1d74731f0df338bebd633231236c88b9df303c3158a1bb01061e0dba27ac51da0cee38608f89d7655e4c857c529e698507a9c47f75cfd8c7292107eecc33a9c680660f0b4a57566352e3024c71077cdee1e71adb1d3ad9111c2b43ed919644eb8cb637e30d92b8443fc02f4b91523ffa42214559f53ef30a8be9325f831164d1d8a57263fcd674af56cfc53b3d689f62e27fb9192d97b4fd1d49c6302bad39f18c649073417ca1f64a6260bb5542fbcf28721c7004dd5d34a56f92126916c9ce6048181947d869ca26e0b73e05e64f77d41e23fbc8552ab4fc970cf1204a8034f9dede0ab39f3a9b9b992c968372109df5bd7f56a525c079b89920addb5ea91030654bed28a6354dafa51f6c688a6aa1ca3b13fc2b577d3b9bdced12d048269e8fb584b110c787b83d59d9db3b80a36f7faff655c22dd437f05a9a1f2aa44955b73b86ab24b244b5e67bde41ecf6dcabafde7dccd96bf809d059e92cce6c54d170036e0a08b39e146633a0f900c5ee2642bf98f9ccd3d1fce73449442a7b64e187f6358a1d54b853a7934cb3f37b508d6ff1a3cd89b8a56333ec757e33116ca896b6b94c843eaf214cb43cc10515984874933085dce0d0ead919087ee48609b9cde5342b8b25d82336ec4183ab991991632d7f46626723413098abe2c3dc8adb3ada866344f73a94de5e08e742b4c3d20385fa7c2cad88ff0ca07ae2a477421b1d692cec4d36e6b805e2f53a4af298916957ef202b755cc03b88c71c6508c923afb960a2a7be23c06afeec93542b6a604a9f888c8fec082adc5a2d524b099666053d57a7b2cb4d8c68670291084e48ee483675316e4859479d3c30727ebd945c068f88cd7a1c832e9e4bb5a8f5a3883c8d7903e9a84860ebf5d7210f2c04b60023e17f82939e96d0618ebb0ff5a70b06fbe051f44a8f6832922a9f9a1b33025fc76e30223372b8f8c45676900377a95d8601f29457bd6249ecc29bcced837816db08cf0a71b7194782c5f293ae688b1d5ef3cc982f580e8d7c2b2de0065fbe720553c168199d3180934a7969271cad2b0d3328b3e3fbc7d66d4a0868aac759c08b591b764c2d79e130cde9f6ae78aba6db56e0e370da3f56a375a5446105f52b993d62ad431d628eaa9172efc866a4de218f5fa5826a9974c1ca3034da349fb10bb1b932240f8d34f23ddcf24cf3fa23b30078a4fe6f73e735b7bc19a3c467bf0b93e400a1358df8b96fa4d9c6ff5c1e3d62f7a68cd757950606c89ccfa399e614af322c960bd0867b134ff88856c83882e0a585ce88efafefe4b5ff17eaedeb44d584484ab05a63f2eeeb106a0d9be5ba039bbe2d32cd8f6982a64cab753f1f391aaa89ddd131a2edaf392adce7d518c25d37c033d54c7ebb45239edfc0beb18350a3591c44190f3288451350a76785dfcaaa8feb8a398bdc818b0dd13accf6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
