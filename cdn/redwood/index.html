<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de82660f7d5facca003e9d626793dee095e4807399e3e1e70999c58df3db38d82ee4c236ca1502cab3979bce136c6e2133184eb8b5d49022fa0c3e4226c6c7276d2cf89108968c72edb38bb0f6c79f699cf8896599f14675dd6de9e3ce24d9a7720ec197d34a29f4080c542452369374bb8d2c26d91fa3e64c4e7693e6a7065f517d863b89e9f7ce64e68ed67bbf86ccdd4efeb934ea5f3a3c04134fd1248806adcb5bd380ad64ab827c036cb125ba61b0a8026d4a778fef3488e3f78e65c376c34ff6106e36913e03384b5dbf1923f09a724bb4f33a72e8f6fc7e981346b0faac25a42c873ae5261198879b5ce51d3ac52099227f8333e679bbe1f26ce1fa024b52c66897e8a08b688f024e9686cfd2c1b474cc5e154fd60d5ae7885315240969e606e2a07cc67e9edbacc83e58ec41b2a0e6bf615c335199dac0199cf27bbdd51539e2c21a3b6a6d59c448c46622a6c79c98f462a3cb7b9d7797ba78b5ca1a070630dda9297ef8f2470c4de873bbb8b32111b781a42896f679dcb62ebd0f2eb53085291568b94a026b13d059a522734a91c67f6700434973385be958c2a75e926e159e0ee09f0dbc2370e09dd04395e3567c452c6d9ccb76b12b84f7f2d3deebfcdc41c3deff29df00a418971461444c7bc8bfb9b177b8725e59ad13e652b6aca2b9181b56fbabb8980838c54fe7662c004e43e57e633cd4fb444bdcec9971b5183f3d164e8104266e664d8647363a2cc0df4ee9a5137894148336ea44f979a9325285ac0522111e99fc81fe1734335b610923c9ef3187235f5a642e129d51a8e4862135a5907019e5fc2381340fe99d7c412043a89413cb3be4f4e2198e28713ba8085ae97d41424ca029da6c4159741bb349d41e7b4369bd9bee8346b540ceb298f6aaef6c422e835901bfdd947fa8d366a8780d6f8ce9c8ddd4e8c106ff2e84d36eed80d8eda97eba095f31130773c9b593dd6cfe9c43892a9a226e293866154fdd3be11f3dada0b2797fe0b97dc919a7e2fd888fda94904438b0850f91927c87ef8c3489157347b96c8d292404aaaeb40896bbb2233f314f83fd63a5b58fdc28da1535649f2d06d23fb9a60b394df5081a5f28a1b20283893c2f8771e2a26397a188193647eed466ec9165cd5c7213b16225344a75a9284d62eadf96eb3341e2fd0ab5e6dc6275d7062dd484a51f153a8b237700f07c4c2882fb89415dfff663ea3fceaefc350da5f5129e856b02c47e59bf3f05fb362c232e1848c809317d2a686e43a79d8156a89182a92b1d06f933e549e669a8d6ca2900629aa41ee979c2f9caf5357b265829059e8d074e132daf51bea83779b0de060d01887220afbf03881623901493d593bf510d4a3e8e0d71eccf653d6122268a84d1a257a887e0b7a6083ff431c206e7568763cf810d0b26b2a82941488dd0dd4cfe523acdef68db8f1f9a8d5beae882402a9d02aa05b3e74f66bff7f3c23b51a73fa201d430211158bb678c69eeedb45cf5d00f0f3ef7ab3c4330201609597c550ea522a53713c61e61a3fa4e665e0d792e1411504451a847afa574437223763f16c12ba7be486fb2f0af8ca918431cdbbcf07266d483166e02f666fd85f901ff8016f425e8999262e173324d662f81e62c8a0002a5e7ba0a55cc7dd97607fec1c21a7a4c0afeb0516e622aca2d5e61f0ce6e87394869b27838daa3bad47f668932b86c1d5fca722572313ad3c191d9f0b4f15972a7c4975d13675eb58cdf2eaabc16c14daf181e831deb3ff96f68421c545d91a15ee35ee882fc3bcbccb16c0c0eabd4e3da2a75f347838fcd9d198bb69d0e613bcb3343a5a2b44915e9e366af4b8a767aa1b6849bba47b67cec21b5cd9734999912fce87419a7b70ea2a5de5b4aa0efdb05df3093b7aa61f4484d39ec6560f82051eeaf63ccd36c7c0e81e85210f8517ac1fa7af2c2218af6b563d640518cc3ead99b8f070d71a3e639cedfc6881304199ec4c781a3565b5dfa8b38cc56847448bdaa4c77f58bdef1aa41dec96a8e963eb065d47fdbca3c8afab8d7cd178925ab60c235caae07e35706cd2dac6a20d345c0ca4e3405f0a7aa793ebec8dba5ed7747a6f2c09bce1dc3f50aeaae3077a5da8cb8069bcd25a3b4648ea18049c670689efd5aca0c3027980c9435d60cd90e1e999227c7fe73f2ace0dbbd1ac82f7a41083cacfbe0f56745a49edcaa33c730f97b4e8bc82092e6ea6d5788ddc11973c98b814189fed8f20b6c6a5e697bfe6dbcf592712fe395f5f100e79bc749d8f5968c88f8dc716af75aef43b1fea5147d1962a3a852c261fac627596136f2b1cd797a82ad348b6ac9d7cb8d9a659f35f9363885a91e852b4c11c0787ea962a13045a5882183c3357c6f383f2450489b06423b57bd2cd4073f607b7c591613d29f54af0c4e341db32162f6675737e7802ceda18e346c96dc365bdbddc01b03e538bcebf49b216bda891285cd13fd6c3081f2ac81ad020a967239e789a57d33f6c7670f8c9b8bf2b54c94dee4f6e1aed9c01383dffde3bf8fa901e734892925ad8742bd4dd314be9251be759b21469fdc8d3f68ecb96fc280fab80523c7b185284a59cf8e7968b362e29f6af3144088e9fc92b8fc88d683a92b5321057c41624dc584c37776805310fee8b15e0d2fb50921d6071ac57d175123c3703c5cc1692177c1383439e73eda53194293f75e282afd93c4e99e16408abd08f8bccf74ef5046d93a72394664814d41abde0a5dcf192b03e8b7fd44cae2a9da54cbdc86a0f605e4338ac91509679cb33c7bb84c393988c221688045ac9d4576febe19efbfff6a5c2f456822e82e1c303483bf7145cb6780afd512f9c22fdfe06c661df833c707f2ceae60fe186d7f21ec95b2a3e22ca898877bc3b1e19f69fb4709fb710ebfba439d866573c58e0703c5a242278ee15c03d58e0900f850204810d61212acfc829e1c3af986aa1079a76656d27dff756a8229d0326268934ce26b5e20f91581feb8f27ac3f9e87d17272cd397fdb071b4a1d8a878fe2c5cf96530f83f1d4a2fe78de6ac2d5073314e838541322966173e86188508aee7975935c57b252244fb1b40dea1623f551a63f6c69956aebb258ea65c6bbeadb66c14a36b0922a89eed8d491afb89531c0f8edbe23de801c16ab9b4ad7baf2209f1815d0d2a75760df28b90effdd876faf26f68501eb946a5bbb47332371c4f2dd3e30f8e3df46ed8d39ec49d1c7f373d77ce1fb06ee96bffc830b5b83116419d5f87d359e282d2537a62bd946299dc369936f125adf44e4d8e05e319e502198c730ef1bd622b5231f9c0e3ebfb265bc745f2727e0b849a64353cb4f1df4adf6d9bc213d4c3b2a243214ef2ae91388fae9d96654e080b31bd36da5353503ec15b7d51fd3bc767c6d16fa7af0da8a84cb803e8ce1dd0efae0ea1b76a921a82d895fc1c29589db4b0896d7e889aadca75f9c1e977bb9bf9a08ff831a21b008d7485b533d69866ba1dcf1bbd89c6e5818f4f5accaf86511c8d61450204a6af3adb33fa0f06e66a3b43704e320c1ff6c8217747686414d668d7d9376c712f053b009d0ffb88be85df694d36666ba3f93b929b9b5cbc530d5dea3809e9cd05799b9749bbf0a78b14dde1da218f4b5044fbcbcb754aa38486b49e945cbb520ee22e4eb9de438461fc993c104ec1c819c03d521f2350d8b0ec0d61ca2b3b009a0d8fa5d61d71ce8a161ea21ca60239161295ed98321e62e6d3ae6bd06fc6f6845b03e6ed29f657ad2dcb848f835d57dfd6cbdb6df3080471597ad6aa06a4788c650674e279153cb1e48f42532080ee6f941e89691acf5e60bdbfc458afd47c6af23ac97615cdf823492c9896178c3e883433e751460130ce8e086f3af484e3c717c5247d70d484d065b87cebdddc80de6f7e25591f1c5fd68e5291decffa422c7ae8006771971bc30f0d97e65d19f2ee32e0a8e70c615f31f4e05815df5892d2bd266a2ee3a17fe2d9c17e66581ee23561c5a256b91159819fa874790eb40d672db824da3837d3fc8abe4821a740fa611eb6bf279ee290ad4c46ebacc3087bbcd9eabe8fdae016c58865f4ae6e39c36e366d35166f10cfc6b74288eea6c44ee3ca056f339e9fc5a153ab19b626de669f5f46d9e97004100f76cfb27053048eed9ddaf7f37c807993c120523ac198b9c7fb88a14fb4782f11a270533cb49a71c285b9b46fc944eecef0d82ab7e79c67f72e43453d58120f598ecf36ea05e989f36a71acd3c3b3bbf9279add419d383256be8ecacd06acde49e737377f2b46f1b28c35c191f4f1bbfb9ac2bfaadbcccd3a1e5326d12fae06bb1ac91c5f3357d1af5fdede9e25e5364a87d81ffb326177e1dea91ea041e42341dda48026d608c16ccc16346aa34e650fe5f424941253a679e62e1a2c1b072048f49ff828225d52cdd663b2d1d2540e0afb966a6aa6221c9736364d62fdaece65cdbf274ce5f3fa962450c7580001f03f5f5c671fcabde4925aa2f31120b52185ff063e54aee244b3b4b423e136e8b8ae1ace2a37afb25afc3a499590c10dfc51daf28cb6789d911b4afbfc935bcf617337024fad1c2d7fe38e7f0b1720d6d40d661b601d29629ff01034b7d4c3313a6f6cdf7e473d4820ded483c3632bd472e58248702ec0c2fce4c00aa1e8cbb4d5a309cd1832a99a5e045131ff451b676af9c97caf811f44f0ec4cfedd7045fcf8b97908b82ab45effcea6a143d21cf4601adfb2f30808ba2b049172568c014f08d299d67b95eb4262fd5716242b0856ba673fcb72283c2464b479ee756f57b690124a792023416523c4c5737a7b14dac6288d295de3f8c69015fe8a4ad4b10074033b60a8fa52943c72755c03e134f1ca32d214aec2ad2958f61bee803262e41a2c754c4e5b8766c02d9661fffa32f1cc189b0d1367dd04de10cfa66fc013cfc34fcde301a78163ca3e58e595a6829dcd9acaeb695d7612c5e472a397d9ce96379b7dc78e9759ed7e4cfe5cb565b3e876d0a957bfc1af94aa285047c55ce4c1a4e0b33732c9cdbb5a2334ae6c7c8843326c676c750209e2f820d85b2e4483661ce9d2890cc308bbdc1aeac1b9d0ce185447bacbfdc611a0d6d956b8d12f5d15afff79c10b5df0757e5ca10d7193b1f649e16b56870e4ee0d67f1f68f5273ac07a82a8cece820b283bd7699ac2ccb1fa6aff5266286766ab58af6049925cbb2f9d292100289278282600eadd7331776d49ee08ab1f7084adc3d6c5621a58012a51b2e3adb313a3be75367be23d51cfed1bc4112a3b89496a5fb893b86f6e0ec91deb180ec2ab3d1a676b18f9b08aca8a6717edd9ae9991bcc9af04d3944363481a5810317f35d90cd6f17e4c2eaf7eac0eef97042a6d8325d0b29300eb3549d38406262b76735848f582d4a85452e390e95107fa998bb3fc23ac21f1f5d7dd7917d5ae5abaf61b42f63b260f982baf1cb434cb5810e9d4b75f83bc8d501493c28c567bb76a504e66802049a88cd711d9d906ef7b38859570c37422d1347b3b88fef63b5d8949f9ec48adcf4174e843f4a738a50184fa82ed268fb0f2bc4bc66514430a80c069d0c47959f40065b4752ef816f0600669f589416d646885b86138ffe17cf93ba2d6f1a59e94a506e2d5ce10e37f7359224b24c9f44daed9ee0d34f72b8b04eff1f7fd5e15f6d4e63be0fe1d2696966e8a4fa92948250e43808ec756f3cd507cb13c3e8ff11c41f3d2482d95c2b190738920cfa2f9cf723b5ae181bf98787c51bfb35e5c3932af9a55a438e70582930908298b04bc8436ee9e63d12cba2bdb7850323e22dc1a56f6eab368aecc3f77ca80aeda844e7bc2e414b8fee66f7def5d3a40dd1396d544c208df47779d1ed712641674dff5741e6a050d9e61b9d5c2f042d17e76a434a619aee0a905358158322d6f0de204c536e09102ce235860944c776bf40fbf2f547c70b70e3eaa61208b9fffd3d0c59ea820cad8857cdc6848bc9a10bc6026dba774a784230c1aa261d8aba39ad5f0598ba05a751f24d641ddd17d8caed2e99c1d52962a3aff177d614465e46bba2d353330ac7b6cfd91df5f6831670a3daef92e0092e4307adcfa5524abaf4dc13a418d2835a75543e4dd252cb3fba7fbb71299f8ef8df3b45e92862f1e815149b8c253091c7a2ea439e26b528d1eae5d4cf32a79d788b8acb27d6df35d3a61c651fb007ededfd8f86845a221ff73632c3716d6c84bf3a135091c67fb7bd737fb0e16d67d7117c515f9e17d438bfbcedbc8f2e6adf56f4967fd0ac016095a91f19b208523586590ad2fcabc004c585fbce1fd37cc6764dea47f47afa1a70ed84c5c0335cde19c792e99ed2d3235270e70f99f107e60d5ab1b32697afb9dad35e5a4e0aa88cc791430c351bac0098d7356643a138cdafb5c606f6875fb2010f9226d7bbbd284d59f81ba06d721fc58314167d2d28c7864cd97f6a828aa54e335db652430dfeebdeeb38990787e6117430d78b21c3d404840c2df960b74be43d771715f7fae131b06b5bd471c650ee129cab5fb0009d6034136cedf3fbe3588dc44a64ba5a07a135269ad7049ec113a763943f6c7b57e1313414cc034e4499776d9f547cd63445d9b708e3328719b5148bc7b597870e96beccb0168b945d8860e73085c07386af5f1fa7f236b39396aac923174989951497abd58ecdfcf3b85d443070af232243ed1a7d75e0d49696671bf46ffa337b15f54f0895d369c659e328fd1a3dc12080132ea4ceb9a44d2a23c108399acffbf857481f5cb6a8f80e8da8991eeb03911968bbbdf2d51e2f31a4f523b58fc23669e646cce19b913bcdb93da851208c58db04c08b97c431daaa357d29ad411c4f177c97054ad1de30444b256c71465819addfc5e6153fea341d4d7cefa3a6229c022475b65fdbc094fb8339f2bf6932409ef9fb8b82d7080817393c75570b193625c11583f51f046a95f1991516bc3b54fc0575e80fd1c4b68187369e2c740b97eae093a22e3cb4d875e8c19306842d9573ddc27306868a734639b3702806d296b89b482afc1d1ad61255f5d6144151456a7ee4b83f513e85fe98b0a94706fefeb8575b96187acf74d3e004f6a8a52158f14c505a122cdbd253a1abdb275611d034c336b9491f95aa9b5ed7abea24375872acf76c71c0dae7d6f6969676bc9177eb3a1865e1ca3de14e0b1924b1e16b6bd0598d5e4444ca1a20e8316d07e17db0bdf4545a466566cdc4aa9e8e3194a04f817633ccc0fb0e24b707ee76e478d31dfcc82e01ffd0bf8b501d815941ee401dd007c0684fea2d33b9b7581545600958d17d1a44e7f27fe2a4993594c961e00d76935ef25c6cf0cc7871aaef7d7d05bee22cc0899f30304b9621e9a697b9843f7429b8b684494ce38ae6036daa0e8aa89ed90b03af04086433be05d310c92441fa4f6decc9c387140dbccc48cbe940571eb80fbe5d657be1e5f31d47aebb272cf65470027c610c775579545937f4b6a4e3c6fa4140aecf16fda9c730afaf35c4c450a8503665be69cf080fbe659561869cf5c09a996bedff93c562ed9fbd75c921518f6ce814e38f08d27ed238f9dda0665ff5db2a9fa5a3a8809aa75597b326266ec66069f7dd404d5bc125138f7631cb8f2d6d9f7d61bf0d40fbdb89dfb480c2f5a0def810fbcc6acb3b5cecd2ca30c7c0681c69a059a8aa51342ba7d3559968749a834416d57ad3e87f347e90e184f728c52c4ffd5fa9b0a933cec96cad837a640dca1576819d41de99ed2d19eb409838a7dc87821580471c8f26392e19dad9fede5aebca4bc918e6d9b9c9e17dcecbbdbcfefbddf5faeee9c2ffe0c3913dbdae8d6402e8e5b7dfcecfd7cbd45f42296c5266827099553dfce33d2e7b2fb40d08f2ac7f0084d306f4c0d89f66ca5b65999915616e6e389df2a1e1aec6a233284e7fe5cabf0d3c8601d06eb0695055fdabab4adfc1d8087da8891107ecc8c3d37f78df3768478fc3c8c8acd1d5718ef5bee13b3830d54d6ff9353e3b2763130f59eecc1c96abea16d74c94b9465dff68395ebaa0e065ce37759b58b791aaf577a574ce3b8acf7f87b34a4886205308c8cff00c439b6d0b9a09bbaf1d7e2282f9c93868d73cd582d8d7d6c2a4ff6f9bfa82aa262efa29e964f4b2353eee1b58c88e0f328264bc7d9947534dc70857e366dbe927882737b8dd3f4e9428fbdd945961191fb5f9a5264fc661eaed319d42036cccd79884269791122091702fbf0669a4a9325796471ecf59c054568ca680d7d1c3be6c3b540f038fd44505d488da6762389c143eee8e8c2a2090c4e58cf94749bee5e7ef5b478b33e579a911d9f786bb578561a8a8c9fcf0f5f2f315efc32ea45fabc16280b5a434f7b9efc0b5f188e84ffd45e7de58c35e24cf4e8895761c776a9292def0028c78f535fe0dd4b279576575791a9b4fbbb79527100a598b56f45d560c92306393f6e59549b3a35a2c6515514b878e3f643be8db5768d9338196555073c0383af6e624d3488fd5de26da739679c8b1427234567b1a57dddcaa626870ce62c6f49fd56dfa55090c4a8fcaf27d4fc5dc23a09f4f6becc929de464576ba4a57be15907227724646e1835bdfd2e12ca97b9f278c5cf0311f8f5fa145ed16eb6b203f98ed4afab4c4bb7e2c8b572a6fcb0ef76504fffb672bda630febed50d51a77b05dada087c3c3cf4ccedaa0bf70165986665a2c1f4fe7f4355b6647c2c5539b75ede0fddcfdc4702921c165e88487d8fd03f1eed14351a4c5d923e0b0319ef1f4b0db55396b4664e9dd9d2ff1d6e298f89c74b15061668c8c01848a8105545f2bad1751ad40e0b0f7fca939acd38c92d7ca346617b52d779ba40fd28126735647d9815eb7133be52619435ad17620640f72d7c260dab33334fa9597ffeab3c71d09a4e636386c33d5cfff2b803be8e665b36c1500187739d2f635a92c23b3b4379f228754b222393ef48aa87980059054c88d2b35813c7facd237d91e1ed33661877560c7432fe3cfb66bfa40310740caf5b4e65f8ca742ae4047bafab277fd667dbdf5f47fa9f6e860a9c7df45e7a7e45064a1421251107eb94c6ddd49852228e4dcf5dd8dc204a31e52bed8b972d923b194cda7dbb06b4b7fefa7ff54a674306e96fedba3a64ef2d62c3daf06b97999383351f001c972c977ad0a47b82172cbd1e9c958e200f22e35127fc8df2da700ea4971a97f483381507e308c6b5e47488d3fdbe55ee22f0b2534be5ff0d6752b96f2bf07fa11a28c0c74a788f1f9ebbb48e454d57bac372b17e13d319f9fd12d6215b1d5544ea41a0fa05efe233eb72b526cdaec4e4c1f41da19d1e194c3407a0f82fe4c4b322d4d4995546ebf437f0ee15c0eba2a06bb35664ff248530d79acf7854a8fdfe56050a411f2ecc6d79df175b7cf229a921e6e8346796a5c9905f070386ab8a1e7e6b640e130fc8e1fa3988777aba9115f9d81959a7854c6495ac384d8149062f65c9155fff07ac53dc09588a9a37ff97c095a7836aa09565b133d9eb0c7987fc9fe430fc368f262ca38f69bc7ec3dd1fb4f15fa6d35f97be41834fe75b8600dc6eec6f7839ca205ef1f14473e2a87ff31e9fc445185e281fc719c8ebaaa144f714ec3061b93ff4a25ee80d70eaa0bc7a815befe1f5b1d8d805e47c3d8804970966ac66d48d1ec6dcc000cb3309f31fa6b3904c464786f36084dcadb0333e0ceca9f4000469714dea53125a89bd223bfe9ac19c46ff8ddbe52c90832514b20a2056490f2e97ac614ff8407750a598b25c61f9c278342fb32d0cdee25d4247e58058a402638c466f42d93b65e0e8e0c374cc99a50ac37723cf8599ee3c70c9444fecbddad24d663cb0997b47e98fba22f2794eaa46b86fde89330bda5d41f1660bbeead348e6482666f251954886dcd52428543a68a2b0b387b464f501fd56698fbe693453afd8cef71e2183ea69e1ca6cf36dc0befaa20bd700ac18d9234cb2544096ecd4266050952d8fc41e93a2facb670f2bd01da2f6d090be1a2c15247ebfdfb55e5fd3555eaccf802930ca4beb690cd3b3f317bccc90c82707e3150c78e290eedb9e27db96032cd740faf313fa64a27878e97ea8e8bf340c0f0464921603350ffe10a2ca90e5912655c2d32d977e79509e2ba509cfde79fd9d5d221e044e457286edd243efd36b46d388de3523d4bc6761a49f4422dc7ad6e9da91ea0d059a1e6f89c5951a6dde0590faedc0fc47ada59d3898b8d7429507d54ea612b220ed0f6e2af20075291fc978113fd408bd7f174dbd9e8a8e5aad2b0e0d4c6957d29f9b6e254c9a37d4e0e81137a804902be9830584867b382dfd06d79124d85a97a3b5b4669867a45ec9ac6713eee11cfccba7367e3e57b33e199cced47919861f59bac570147eac37b4ad86eb5e235da074a772061a53d522bc5c674de186ca0bce604065e5643ff63020273a7c4c2a08031e23be7ef48139360f7d55ec7aeb07494fa8eb2b4a7b2c6a0d9ac1df8abed39d9939e7a5fe082fdae253198d5801b70d30587cd222e877b1d0dec7bea0e3b35234d12f7621086807b1a445564402144d19f6e96ea6078edd413b3342fddb9fd51ea4a3747817b947063b7548be0cf28ab8e0648b0fdf63ed690e450396ccf396c2f6c5684a390558f5547492924805b37615ec776eee25463d5a3ce0a978ca032b2db27305d9430031d4e8034b00da717acf47dee88ca4dea517042fe98cf3fd517fed3b0f0c82e1064831f282c29492d2142f5a66e120715e58e16dbe9a119d697b983a3b0646cc62c94f978b0f1313776a53f63727286ebaaed5bc8c5e38a345019c056769abccc7c63fe01f1c0687ff6061a21ab539e1897e3da3d73fc0f3bf2e1912f3736492d57ba62362a4d9362ee6a6c383f88de13b3d85b62668aca163c7fd21c0faa34dadec89af45bd8a29e5c1f4ce42225298f174d0721687b7e7bf1f9d83819d00ca3f6ab5176be5aac09d812f882c45426eb6575504570bc95b04a182dce3aabd9fc874ebd53fb2dd4252af7c6210a4ad2c9113d7811355b083e22879379e6c80dbaa31b550fa5ee98c93fb773634221f2bd328e0a9b3f69e8a17fb578a338d02e354a5465a2e313b3fd03a6ad2387bc830426ebc9372b320178b549da5d9e469f7708ccc0c55640f932522b1318383437b4e0df10c3fa12594d520db486bfb958bda0ea854e3342ea19720fdb777c00a89c34e1074eedcfaf4449faea06cdd6cbca49d2ead0e853272eddc69e1d9d7fe6022b397e5c043e18312679b0eb8a34dfd04d6a108012a37c0246e45ff34f0c2cc3abc5e51ca1e41a5dd9b3284a2428e7b9b7b0d0a6f162f4e268e9f6c8ade7d352b1659a530cb7a89b50773da67eec384b51f79346709ed480371e60102dbb2ada3b7515172b86ef7fa555b386bb1617947552611d59f5d4e7721b4f0365d727b273a8c8167846f32079b7158067e3134417e94e7250ad3d4576bb158dea12a2e9ed92e742e1331bb18948a4c703d6b9f724baf30ee5bed287d999f2d4b82e58945481df0d27e7449448ca2066a86ca46a6f08887627b5a9eac6ffc91a5ffde7ab71d4cbc17b4318c79ff94b7d9e9801a27ea17d6b071a8eed7fa4c3aba12cc8f8c461b1d1b62c58e606743eaca87519907cea4c1b9c781eef5fe8117e1930144361250b28419a18a6fb81e57b3cd8b476a38ad9c7e9cf6521046ebbd3a8046e3d4fef50d8ceccea57a0a8e6a38142b48cc2965f5269e8ca5f01f3bdf4c346deecfbf702dc45c8ebbafebfa84ce5ef499877e67a32cdf383a2c4025d204e93e1250caf56227966d5399436ca0da1c9cba20a196eb80bb4cde7a9b5d0098b947d77c369045a40ebc491df12d7249d9add1c569ce95f848cf7288ccda51bf3eb0e4904edd242d9eae2a5bc6393d0015df8bfc0c6dba4bf0ea65634580dbd5b525c661ec8c165e618c9f2386aee99ac511ec21fc2c73e111487823cf355958eec7953de490674582c86c73663082347596ebad252cb3b21ebfb026f14668fa9325b3b018ba97bf3ed3fe7e294d988e126ef17ac450f593a849fcfeb33ab821dbd47be10980bf9e7f86e9a64dd5837f2fad87be7e07b9a27a85e878f08ab5f59280497e737252de4b119e8ef774ac21c0826b80ec70ab2f15bce95d27526d28490663c24c0ca95bb6e6d117f7cbf6af779ae31edbddb34d9849491bf73bd24ff3519f1ee67caf0556da3b563b7032d0823e79564c234c522f5edbd63d63e7d856222f066d2de47aa6bcd7c12d948b26c08eb473aeb30aace9ff5f665f8001e7efa286c7bcc40da1dbd44c9e94f108689b781c3d637c64f478fcae2162c58b1a5a0f99e7a83f494ecaee09bf70bf3633d2080d1f58782fb517daa49ba224b2326250178b291ffda3236d74e524b28454025267997554aa4b2f238975c19f32785304adeff3278e64d858fd8c17f2d6504c7cd595a3391434707eafb6a79041453a6a62d1702b2c476eee87ce9d24038654e20563c51d27d8b2ba4ea6fb5702a8d8540adf13683ed02305eb32cd814773d92bc692a06a0bc2c635a2cfc0fe1290752ba26a664449790c5bf83cd518f0aec7183a48e41233e879fa951216a3158af3263bd9c45e5b8e5d28a17c52b7043db50f1f5b06c66ab1f23e07300379b62bb9a31e056a5e644b4459b52c2c555e32b1068e3cc1c0f3f23fe482066accf5ada37f4d718d5ce65f5c8129237f029183e7554aca122a5c35411bb44c37c608eed6dc8b42685abd1c48913e28744301222c9bc9cf311403405cbcba73102dca38f16995f48de1fb03ef27b8610caf34b54e281faeb9cf992f04614ce982c7c0a8151bcd7bf9a182dbc9244da275e0035bcef5d7c09117edbb4669e4e5f24f22db71fe246bb47e938572ca0c0a0a8eaf46e2fae8221d9a5712c9945af2b816308f15d32ec18a680d61fa76aaf58ad4a45fa39ce739da382275d2af093885e0af27d0a1359fdb361628dfe7785d8afe872c183c61266fa275b6cc3cdf50e18a840f0200f33b0cc75072237110955eb22b376e11b4a851bddafdd997b22a1b3743e8878c22d9b8b11cb7e765fb2086dbd84325c8a448db6e3792fe1869e1b2f1cdf9c7e8e1e17634b9645151f964eaec3619a8f7207ebb232fcb06579c6b76939c44e960855924dadbe6b84c060b87a090e5e7a8c9d137e39450a2d3254ddde1a104b5f3e0a7b2d3131e08af22d2100c944f48756a4f215ec29756de19b02e436781165527eb007e8109f6cea584b3947cce8b3e43ac64592941b3d3d93eb461e36b3fe41f31ccd39c2ad86ed7ce45e701031d01f75e7e2bd24b47d8282531ce77e1b3812e780c8a2af04c0161c0ac59489eba1f671d0ef8e991a01814930765683c95efd0700fc9432aa18be7f37c103a06713504472c3e7b29f95bc7c9613ec66224bdfa72d8fa662e6b8bad750e498e81e2d406a22f45de239c924d2475c707bb61d6a4d874e1771964c806d01dd3328f4866df0837689f6d532d555b3dee1ada0a66daa07fe57519779ed15ab7d61647b75a58ac029c3390830478245014d16a93615b523450ad0686d544a60e788b71a22650ffb54044cda52c89d98ed40a769b05f0772f8305db63e630f925a6357c841bf6c4847f0810ddc596fbd6aac10808e1eb4fe8932ddc6c6ee192862301a52eb75c408db1ddf5c11576f772751178a1a11e3693ce28a6261bf89f72ca5594567cc4a578050815a32fdb18cfe4b8ee8e3a91f14bb5ea7e49788fb68899bb27d236c73ea0d64b053609e403b50c1d5f07f0d0c849ed95fd03f781cfdba56ae8f9d89e6dbdb98cf28c37ea30d95982c3cff70bed9bd936f5733f46fd0c249b3f18f2e28cbeb10ddb657032c00cd5fa28e419ac2baf8a4070dae9bd6399dd1c86bf82b2d2af96e7af71181efcec365b7ad2514f3d152a91000732e2740d3228c42af5380f6d1b04512753bad5049fbced6681ebe410087664e52e18f2c0f9637f42f745f60e3bb2d3665ae7cb0867d787954f6211ad0715946d7f0b202789447c7b844f679f7a3d24a42ecdf09c0fb965071c781d0357b9ead1f384421293a5f53d1be3088884270e558ada82ae6cb4caebf368b6f336a472aff7fa39c0ef777cc92c5388e02aecec78abdfeb3f7df3f53fa050f4047dc481f5709a2585c1f0f0d0fcd8217d339e0061a82f224a5955c6ebe7e73b8b66e16072f6db0ce4c19fc1d793eef2ae39ad9a8e6afcc19d20c8fa57439b2b84d341b95b5a248a84b8646f872e80b0edbf78312638c9b11966e12fc2beb861f03c9a5a7dffad143f4f79d22a44f952533fbfc06b1d6629636281a36d0fbaa368445341371a92bbc8877f1327f64f676f4cebd9124dd75edeca5c322cb263dc46dab6230e068325a8b1c7e85db35cf6c0a8bf39ced757a1c1739dac6a0d11f37983481e8bf7da40faf71c07fe4b61bb0168f5f7b2d1c18d017f705fb36a3fb1a19171282abb02a53a14993f50e5f3cc4906c03013d85573f4b120a7d25136df8083e3c58c280e21b3ff06eafbc9e532be9b8b2ab679ffc0a85c2d1316d66ff9e46f2a614a05e96ce62e85b29cffc9f56b165430e8a9b5f2c0ebf1905fd909867a19dad9559d410cae530f43a18daa255459823953bd95fecdcc2a89601b07d4f8eef036bd51ae66839853d02a1bc017c0156950ce82c5d791da709cfeda2b378fc5769cfa79cf59436bc80b268ef7808b68370696fae1f215572c1c2314afe1e688e6d48f5ba482740615ec2d427720c909c784817aa55d1de0b982f76408916c5972d53dea9056ec0dfb7e862b16debd4108baf2adccfa9420d3493008cb8029b97cd9b83fb837e1a89a20c5a3085fcba67bb57ff0caf19f333828f2cf6ab0671b99502b6ab684d42d29c5ad4fc72d43554bfa5fdd122f3a52868f04be15eb010cdbddadaf3cb326e6398bbb14560b09dd1a509f7eaa76ad70aecf81beeb87ba28b8abc9bbd47f03438e84c1e0504dd303c74c776de5dd021f2e956ef294e318c15b1e3d68eeb533b787e3171c369399f66af52a1aa6b4ad860633e6d874b3bcd36510f94b9ea43121bfddee2c1016627efdc4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
