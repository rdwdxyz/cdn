<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f3ac8b89e1b4213021e98d8d93cfeb835466fd8bf66dac73f3d59215d92433892370e1833130d97183a47f3a8073317d5cd0c2c327c3ea0e66f85d9a7d1e67c2de92062a5ee5a22c65770d883f9a979aea5b1cc1a21852353bc1f6d387b0827c5b15fd6ad526134f82e821be9890f536043690e868c6efe124f39c92f1858472c7c3dc6e841b52a1e529fd298cb2743b1ee51ec2ec0cb5503a01775bad9bd5bbb9c37615092269d6fc455548ce6cc6106b97115f69432b4db4ff9ae495e8cdcfbc71fc1635a3202a31c17ca79d29e1eb3a6d63c06deac9b5a46eeb34b6629dacf72a358946c6f27beafee09b42e22eadbd79c84675bbb8a4667e2258c8755699a444be94334f6f395002b4451f8f09498f51bd7d6ee94fe08576a1751226349ed776665f072d2579a361b8b56297ba3e7dfd664c8054876bafe327be001a43a6700e4a37972a90d0d038f1edd0ba38d31fbd718bac12440a3b8824146ab40034a536ef1e1602a0cdebea0c73dabbd73a7960ffae0cc9ab0a9f665379b75313750f2a5d515c7e0cec3060771b4da8e37d27a8b4377976f8305fd641fdbd8ee20ee6c7311ecf76237eac0b63427bc9cec26ca6076bcdfa492743d45c413e0779db68aa201ea450e4055b189937d0e8374be6e3a23dad96528e4d3ada8b58664ed6d05bea6384e353b01f1960b32b835197748d039e772e29b9bba0e7ba5fe7651c5d8111398cac44a5bedeeea16ae35eb6026e5ca6ed6725aa3a5c98d94d09f0f3e984a25888a7c34c730fe7b42c6eb74d4e8b6a1380e66706b258c8d0d16301909c1e21eece40cb46078da60c91739b7868fb199d5c5acea4c3b45dbe49ebbd01d4a95487e3f3cde9dfc5815d91ee3942fbcc9a16e4d3eda37c409f479449aa6c15d433daba58659f8e41725bb738e81faa46230963ea83c1faedda63da2f18d65600a89ab2e596a8dbc92a083346c03238d480d1e01ddce1db75d76cef3ad244bb9fbc36cbb3864a7abfeb9a8c4579a2d67044db0f512346319f5cf2c7b6fac22d9c3991324b97d7b43d17f43b36e0f82e2a2e41580804db8f484baf04b14b8848658ea7d4e585d1909de20de497a8b83eed0cc5d7030d5fd684d6efdbd5910bb3782843fcccdd885812a8ceae030c8508931359f862cbf3263757bea9ac7bac3805c2669675bcc187b36bad9cb0a53e4630107900e84b761f57667d0936b2e6a4b5bb560180eb51408912706fc4b5c9b4782049d5281a363413b2c037e1f2cd2dd7c48f8fd1db872d123f6e7eca30b4b2d7d8db81a489b182efb144a4dcc17eb1f2776693c4d2a9876a0d8c526ffcfc4a69e4b06fb9d8c75345931849d30fe6035d1ff8feca0f7a8ee14bb94a5e6c5ab5a3552b15f3d42ea85e8e992b00f7c2936567ba2c65d4995fb8bf5a446c343b66dea7d690e240db0c7ffa501e04e38a45d88a39c45bbdf238365d554c501546384c18ebe50e0ef5497eb68c6553f1c24f65716a2457fcd3f5f6bb90e6e9a3fb1a8601e33fc5f3850365f90d228512e9c70720c587cecd5a6e386056d9f195f1f9e9cfa4ff85ee839dbe156f4469e704494c7d59deec739b11adb4f4e1b60a82d09721ff08969c335d8b5e0390aa0db94ccff1adbd89b8566563f7579366b56e314d0dc49f3215fe9396f47a564ef3aa3985d2e95ae0563dfaab7c1a8b0ec68a3cedf8634739808be9f29c9a1cb3c040dbd74fc01820eef7668afe92e68293088d26dfd09941107534f15602ba93af827491b120e9ed8cf8d6356e423f304caedb6cf511b00bbd45f45b584aa84652e70a0d5e2864d61da23842ef4f709d49dd68c020e8dbc7fb9bdfe5f84b7669ce88dea71bfc1f854b6ead3b86cd65ac0309f90724657a71aec0d0dee23d8bff60be28e2affd2ecce4ea9b10ec868662122810482b5514147d46d519de53b2eb5945e65c05745126c687c40840dddb41712458803109b9d32c7ad5c33f86283c4cd8da9247482eb70602957513f25d70af058080739997e7c40272fd1b73b60feb665895d7ba8b75ffd780a18402684b4cdf0714427187f722f243b21ce8b4e643cc63867fbee5d8713bc3663b429b8d5d59b6c5af4d2c98eb6b51d3de47103112f9754753f61ae4cb224e9dab860d982a171c8de8c1752500b416c2b4707638d5ece93425ddecbf343766a781d5b07aba3a3c4e583decb00098f52f1aca711f9afcfcd7db07ce4b42c82fde7c04b84fa18db445afaebd53ccb5e6c39a8a1968a164a951466b335606eb5de83e8713ee7cfe18fc6cde171910c31d75226832b21a2c4608f5fcef05afbf5ad6406e805f5de017f8adb1e70fdb2949a2f50355ead29d251ed37f36d69c44dccf46f81dc7a9aaa043067ced6a89f5f66e64313a5dcc9d37f9140f7d814c0a915a4f387c4b04032aa6309e1d8b6c3e444744ff199b97745ec2de3393adc01c4aaca2380a2fa035feb0c0cbc5882784d9be8b3d6ea8c8986647a0599ea658f3290d454e9b102558c71d78c0397a1651cd76ea117ce7eedcbf8c567c9885fd5124727ba00edb170214c11c1ce25faf807b31de703d5c4388d0846445799f65c5e0c62ff566ee01751f4c8635cb0c7d37c175d430b6acb20cf556f9aff646f917d2629cd8200aa6e47d65cc00cca5f40987845a70410081d0aa755ce31a58aff47a14cd9ac5e7a5adb07bb6adfe56544d559e2c95b6376d087d5d452066cdd39a08efb9d5701a167d895d021560804122053b543a6e01be42c5b137f6e70a557b9024a0a3feb783d5b6c5f62665428173d6bf2d3a7a7e7f904a15057521a7d7e602cdbd5de0b0db06fedec5ee558574e7959d7ef699971dd8f8faad7322d7ea14a1f5ebf19c5ca1e240cd29afe64025815fd26f83103a2ca8ba411870c6a982eeed2883e65fef6a2cb8a77dc6d6231a9035905227f656f371b045d32d03bc59e1800ef946094d313a5b0d85b3c77212bc1cdc4f68502ddfe9a46b819b6ab7bcc80ac6fb35ce2153e7b370d91b97aa2feb18daa3ea118609b256d651b05c1b85d670cc3ef04e73d16a2fc58e23245411756fc362024cc966ea7f5ff1dc316e7cc3b4789c13a47b2c57e0283b5c747b2929ee9602af96c41cc82abdb778feb33ca7ee27bab25a779ff9454cbad54b9b366075154990c03e2bf3c4fbc422c154c59d1ef1e7d76f1bfa9a624774c09b3b039ca4373b0d9e3c7170ff93cfa3dda7225544e316172ba2b461bce15362c2b17fa397590a5b4d32b26fb60c642c147a1b5b9491738015686a80cda692b6bf51e9ce5cec46bb4735d7083c53d32109dd1075b01c41c8649fb5fcd939f3bf78c38c3614a641ba20f53ead2ec288e4994e6301ba42dd8761ab5ec3d94452ba6d8ecbedf0ce4ea154e5cf03d368e716d3e9c09d6d5247f34924da8b779619460560a8bcacace2dbb8393897afca943ac3d46b6b874a76141333ce28295bbe2ee57947bbe0716abc01bb88d419e43a9b20d97aba1f0772ab613cccb28c1c12441408cde713f3e07350e2677ebe8711be359598bb675e139ec494b78eeccfe2f28ac013e0795d54fe15e7a8c61e5c17c978a9ee65630a057df3e42ac3c336dac5a412210bb0aaf88f10b05ff38388dde0173013fce205158b4f700896c5fba4bc9a7895546ecac938b525634a26b1b89bf2c7ffecc677e5f0fec6de25f38c4846d88d53f41c1ce27c59acb5e0f9ca78edcefe78138a5aeca01519aedf05d7cf56aaed79e7a344deb3180f42eefec20114db2d305ad51c1e476e05cea9bf7adfefb5746a04429a95352d68a1c619dba71291138e753a1fc8bb8b1239dc31d1f61028a20954d8d30ce1ffee9fddbe2c51a8a4b937ad48681bed4d7d4871c6dbed2c47d61f2bef2f93b821d49760514598da12b929c9535a5a9b9aff7ba6a4bfa8b67a4881956438505b498c6deb52b50151e223d1743a05bbb1566825605545aa629f157289c2b0bcd468352e0eb988deb11253984862a72c5d94252cfb43267334f1155aedca9b4c8caf1ff7b2194f355e0d693a5b42af46e812b798cb1af44987c40e921721d3bb23e01021c63b0e03f65a402f2e15d04d682ef929121d422ae3fe72370bfb7e16dec3b4af0d6ab7ae53b979239502b40735a7ce3bda75b65eb4d0d60bd8784fbcf5c3f602e4d97cbfdaa9f80f4545ea05926b8ea3a0acb732af030f454c4b4ba1e2b5480da6dee53a1d990e1f84c108e88b5417928a9ed8aefee5567ba4b35835491ea1f1a744a1b425bcd308870543b90fcc4df22b83d1d294c64552d6f23ff1bbb5aa465267c3380aa4b7686ac82e597b91a906ea45c9cbcae8e99f5ab4b77613e0751610db9498b2e53bb7db35b50a0937547c9e448e3a950a433f6cb78733baff19180209b9c8a9c4f7ee7fef38354f598c294a4216e6d6119dc57a72125ebbd0224b147c49a07dac1b77a92cdd1f035336b8b29934bf61911d9d3f5387958523821da5c89b6b3dcdd0f545525d5610262e3bdb550d3fa0259e5998bfb6ef574b6d89e7c3c2d759d120bd3ee8f8909c99de9b7b462d084450981fb2b706b81be5bba9e7a5c7bef700eac22532243036736bba4880d8f9e88e4dfb21df59bf9b8934d49d9451d5c8af3867d8c3e91261c7dc53357ebea5de000a93baf0896984668c3064fa49ac291fa987d253c91d2ee8b969080152a9bd2a553e83d5cb59ef98a1fdc739af80edbe1ddbf586579c98c2da110ea368facb89270098a33e90f9533c3ce198c4fb00ea18919481e13a850f4dfc26b9a9edd2fbf8911bbf45df64f5fad3464278d21f764b50d059661409571e879234772da685928a7ea35e60dfb821c6ca5d97444b7df2313f2f6083a3e22fa1141e4ae5ae78e5dcdc949a7d71be5af4695c5854578dc0f34c41f6825ca202f6bd5d171835b614ea84378724c88ae0be149da38e45eac26c94c7f2d13cb16577efdd134e43b343a7f083daf995cab9b07316329740154d2cc939094cd488772697b4ece7dc1d4f0ca06dead1bd3786528bac9a2c17bb8db525b7312565bc4aa5613b72e1c98d5901f40abe986a4b68a885c8375bd5a2ad999c54cbf0424f6d5f036469251dcb33a8f627bdd87ad31032e51e4294ff799a91cc0a5f4f8465a0420e1b33fe1a35a424fa447f172aefd03b2b2b478b6ab2913c8ac0505e5f7939e653241fa53500ae4b70cbd73f32e2f3973224b978841fccc702a79e830d936ca1977a7274a1061a3240ae5f02947f5a479727b8bb7a37c819b9a2602a4136bbf64f858359e8af597b1d012569f33957ed561f331cedd0577bfdec108958dd821ea8a6e0ef79d5dbf7c12bdf24dcb4e7e1a8f08216109f7d3b281a35e11e2a264eaf325b4ead1dfabc2c8c6bb9165a26956522f6f1fec30d9b132fcc8fe7518d65d65a68a860d0daf04b3c7dba3344cbd2c64040b1d750aedd04e73507187b0a29ccdaa2b87e7a0d7f8dad64da9d4aa077032fab44c3156474a929b44587a1c760b6cd05e3f22e69cca10532d8e250b03972401b0961d93468e594717f6ae6ffc03ba750e517926a4f0e6307cad9147b583871f9d332e168232b3268a4b155515f5f7f52159da3fd8de0b2b808799cb1fa5c4d11b841c4c67363f5ea552fdb9aea8a29080496f71787753c36d4c4de88859e844bba6ee2e11eb304c49085958590d82368dfdf83f4dd6dd6f286afa793397d3e8ba609600470b1022d0ac147b3a95e4f524d89b26431819b1aca2254439885cf7361d4752e803228e52a9a4c310a5c96cc4d65e20d4f1a2f6c26d01e023a9f48c6274baf25850e490122b370bda36171ed6b6e66b8e120c4060026ac761fb53b6ee0ad2a2a9321ca64d17649fbf95eddb50b17c5e806f73e4388cb82b13bb489a9a41a3e4b2d24e6978ac5e52ae5694b814f28c825f194bc037b9f50b81df466b9202786841bc2a8928bd606f6142e868bd36e4bdca6139a68fd439ad4919e53b5538706305b278b41bb18c5b7221eb43d81e105ef3de1735906b1536cfe3b1fe4c5812ac6916f648a5132c563d85e8848970e5faf6bc67bb4a9d0d19005720e160c8c32b1aeeec7d5d990d01d94fb4da508d11aa8a34c8060a4e7442b916696d3b63704eeaa0e4b6fd546c0ad56462b2e650c2508adca123dac1a2e6cee22a2777a9c3c5464e86c68f344c5f9d7139df80fa2f363f1f9c238e35a5b44aab31c1db221b22d3ff7edf179d6fc01ae7e626065a063e7bf67e65099c229b8f3a47d64e0fbabfe7af58c191d08796b878f9eca972e44e633699c30f4cacff20ad5cbc6d21d47776393e87584245e4545a34f0cfe09f05d9a44458a0e53ce0835cd186f4c017065929df508e43c4cab08ca5fbf4e82602f00bf11aedb1923958ecec2a3e0961c5a26bdd15ceb2892f85a4ac8d3f8e4ab520c9907a307e985b4cb90abcc38f47591706b384e00af90540c903f70b6c1b0803c5c9897783170f0f81e2637c531523c5f0e57a777251b28cc6f7d6ddef47dd8eaaa6a50129eee1ee3812451516fdb7026efe467e6ae50a506af7c256653b007759a3ac454fda7c80d385b41e2006387957f3242adaf9a19763ed8562d84e1f0e192acdd3a2a7832bea6673629f4014d674c0084e847d453e333035f76e943efdb1112c05ba37d326ff30427670f5053eea80c93c45eabbb9eea5936a3b61e55e29ad228ce3e5f38572e9c014a632a4b5569ce003cef9aed6a614760217c6fd51aa57f25d0592d162ca82b4bee821bad09279ce5180a2a30f8a1938122e4aa819a746f08c49f51a3970bb16bac4675030289308306368e6c76ebbb2c15f4a929769f856c7d6a337baaa76ad20c69102763a0853c29723fe75fd7e07bb03711424e60ce97161d660016fe85daffce4e916adab91f59087c84d1151a5456f105b92306ebc26e2b73b76c76db7ef666b755b5aa306293c7d654239df0b3f378911e79be0b4b0430d87906f61d3a4f65527fc125e4546ea08a27e6bd272fe7ed4a51746edc1b477ccbe3e554a5e9552b0b6a6784f704fdefe2e4d1c810011f35a36ca7055388dbbcb2ebf7cd4e21ed6ec9f829ce9dbffe72b4557c310b156874e9a63927e75c3721d217de0d5f5a690013a9306a273fe320383dd2a56e220972a76bd767b85f56ece07f8c9838f2e15a6bed846c6e0a789fa0608c955a910424eddae80b467dd311c53980cd337a5eb25162b85d3de00a18c2ce4b4325cfb8cfa265679f1a0c893f8ec6aec43b2b9f44ecc385fcd599b2bb68e14c33ed9e6c49bd3b3de5fb498a7debdf04f5242b1195ecc6b750540f43d12ab5a900bdad61da64a12f4a20bc18c7c0089306386a2b12dd49db37c95d16408df39ff95ea73aeb8d92c86f0e0f38ab775d201f6c4f34f2c8d55c373da6186d402a20e3f57079db5a76daa730db35bd3fc994db398b548f6d6ccb9c38ee1647d54d01aa583ee96c9a3bcad11b0c2a9fe30f28d9e760e43b099e330e3bb170ddf75084ca5a0d2beb1f407faa8dcbf9e4c3cf20cd9f90434306cc68a235ba9f75343fbfe52c33af1a32d9d2c49267e222a66f85f09d11f0639a154e127a5817e928cdbe5ee5c9d913f4ce5eb963bbec4b731e96f331114ad42d9843f4f8ab24ee06f62191f5108d2bb5fe866cd3ec744a5445432c2f7d1290f8dfb65814f6bb716352df037c95a33a93c7746c5aba4930bf72454ed70dc61d1530928bd27457358ba38b0b1d724123bfb947e009b147cead61fdb01162665547aec3fa5d6b4c6690fc47964f547bb95b21b8017b5a88f8bec22af0625c2bfeae202691762adfa854401bfee569cfe5890d81bd0389f6914bb9314cb2506ac67053c378d495decb478d021033a8e35a29ef78a24c2c1ae16612b447d652d54b0604e89d5f63e47f8d7dc5e8c4d1d68104d7f75904deee5f6285254cf4cffe8cc2539d50d835edcb32c300de0d32e521063663c51df873a9caaaa9d91b3e53e1b886eda3871306558cfc10c6753928d04cd660ff417cb09f94d47cd36c6bc9f285652a7481f28fec8ae255e07acae8d4053497a48842a6a53d90a64f617daa941fdb0991f6d81638cf38d660cc5f6479dc3608993a9bf591cb8b435487c063966700965134069cd30ea9300f9e443a456ae7ac56c3abd8c4bc44a35bc4468bf8c2b960b87988e1e382f52602b6e77c8e084ea76b87e9d67c732b3df788bafd00b0bb2bf7e8c69a0317f41e85441091f926d172402275827c9d8fa9c3855ff44eb95f402708a12ec0f56e56d98e99c1dd0fb32a44caa17445ebc5a4c8a7abf2e3587352d04db601cfd13ec815baab688f7eb804caf2f2a2b68655ce04e7ce78c8d9b94ff29e3b1c65ef8b1d5fe5baff28790169a87866d2b6b48895a0547c21dfae211cee9447bc395dca68f35ad0df3823d4b957280ad9b7737fdbf60f126a94ca675a72d222625b30b7ea9ad9b3fcb72e71e7b0e933deb3fc0c5539f890e17ccee99a1a45b4050f01a45c6512c539613f90d818a34accfc9c7537034e4bcab05fe2ef42a7196c9a5262ed8aca4659dd7a95876a3d74e69f819feef567908cf273f44f1770c520116bd076506100400e46d0ecc8a6a6e643efb4ed7390db1578ff3146c82cca11d96aa37a87ea8156774406299ec3df904c98126bd58c16b83fc00ad1b048fb80b097a569209bae9b7d6d59fea28cebb238a900a7367d17a5a5509d460895524fc884c7b7f76f49a0fc566443812f9d4d421249bdaeef0d6311de328982e2634a2e75582f99673ad0d37a1e203da138c819495158bec0c3e695ed1658cdd4c5f47166a54897f63583ab0ad62e4885df4603b732e2a18c4bd9f6d8d31bbaa33dcc5d59d24e011e3941817931998bcc1e30ff85e44e5d474c4fb800e1e42db549cb367ad228d08fd051d9cd2984c4431b27eed0127c9e51845c0e88078b7c374632568051bfd6b48b26b095a93e024ae800f831351050259cad5b0a8f0273724df0bceaa02c661362a4319c77829f43327824d668778de37cff3724652aa1341140533c3246bcb77165eefc99c921ba3e32ef9d11d6b4bbc48a22730c620caea1106a2f635ba06e9cf1e7682f1a47d00e2070ab03dd143fcb2ed3aa8a7b12c0d4efcb8a21180fb3e8006d83d32e56404fc65f232fe62cb62e9292f0d2585730c3ff2ca63e86210abd7fb57d126e55f1f7d32a61c170f403a843a47e0dba71ee410b1885bf7ab8efdf5e0d4d56325faa8ac76d9b80d563cedbc0eff557de1789ed73ff80358992b167a29eb952652cb5688e72af864de4c5ec4ba79faaa50fdfa5819107dbe08511b4145888d95a0e5ccb9c70cc2fb23691a2b082a736f87922b64073a5975d2a4aa8a825051b06ca11927491468bc2585427b4097aedfbc007833b7f4b3ceb3a22ca4477be8db72270e089030f27483def2bdd62d877df2cf7b17c644f42024ac06068410328cd07ceca45c4497f508a710e44541f3d4c89b08d373f65f1ce5d2c27b14dbdf76665fbf4e26b002910d6543efa578ad17432c43723371a972578087b0fcf90886b0e2f7cd7b63074f7e9fd516e1b5864d335c7c996870e25352527b25595fe730b8bdf6bd3d74d51c5974832c0624baa5d30a2883960e38f5a44e92db83dcb805fd5a35d3c8d94f806f97c4f0c60e8e2f3445bbe17d96994568bfa27692cfb80ec6a88aee6c7582b91896c24c7eae2478e310c04180dab82f425eb956e1bd911017d40e4811e4ea918ffe4e84b1a26c393af02929a117bb6b72a31041f9e3150a07948de37a6515ae08ae0e39a7a72e4f4e89909dc84c0271c9d91ddb96ff7e8635681fd5cbf17fc98c3c2188cbc33cc70d2caffe6c3066de9448abbe1fbb077c9c88351fe4a9a0ccb8ea15a02871933404924c9bf6c6f6d52c6f868c4b6a7b0449cd51da09e9dcb4bc3be0d11089b78f5450fb6197fa6cacb6c71cff4860b591c418c2676bc290b45504d8ec86c886c8361298ee300edd4ea1209f1e206fa7949814a8132f1b962d5b31291c603a4c07115e2927ea9994aef1db0a106610900cd88873298eccf3a74453402f664a63c49c1af25cd32746e38dde49289f873d186ed2556c0c7fac8db4577a127f269a514a132c7d115b79f6c6d54ebdd61ae0a92e736b4206a297eda55f213778dbc9ec27ca4b7ad98a2b367f8708aac990f51ff39dbf30576ef1018640d78a5925e099414ec18699d7da361c287e77f7f55654b95bd365d5b945ca8d4f1bec84b3e953bfcb39891f15f785d9f1a0ad6a6030894a8f8ae826f9c951eee8a728d85c68b3794238ae856b7ffd7ce421870b03c03535e1e13f9ffe78efe907d380c78cc96ac07a327bf88f0e9f8a5acc20399e10b913d76ba91094d513047","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
