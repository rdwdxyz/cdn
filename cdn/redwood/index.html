<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4fba26b694ff313b227139b6ea9dc8890e62c7c159e1ed8c3d7d832209305ec40fee1b04089459f4fd26a006c9d69d8afaf80bb8efa2b32b0567c1ca2e997ae6964879fc4bd10dde8e66fa86626e80876ec61e1c1d968714e5adaf86b4fd1d7f0adae840f879883018848083bf85a9967d6e73b251d57552a86185a854a4bc0d85965176c16d7ae6e4ec9d3ed08e146ca9ac025026b0653c5c6daa458b9cf2f99076b8963ff5ca54bb43657ba10fc87f63e552090f115327d0f5479bbb38d5f3b7bdb8208b485362de47d3c0c21a5ef07000c6404e34a2153bb57e7feffb1f5567e060a2f39c4f5092845d3b92f03dddc05f1f4ce63d2d6662c49747633de006c6f98bed5dedaeac2035edbc7fe046c2d82be6d2c52ffa95a8b048ee198efb92d74b10d3162507331214f8c6f3cb2aabe374825725907a3d40db116c48805794754169b0969f3218f61eb102dacddbc21e7ee3ed439d2ea8966713244628f9d5f2f09dd563b4008c92e11c75b40d8ff85f7b7e3b8e06f351872fcee281bb44d28138e5ea0d5fcdb2281bb6ce71a8eca9d74185af2b8f58254a435ef4fd1755f9e18340f82496ffab610f7dd1ab87c5eaa29248a9b49f83469f10e07e309b80f9efaeb16e798b46d77ad739f20a8c555d82919ebd329c86093a17a597f9c37f3d57762f6525a46f42ad5431174bfe012e7faaa1e60773b4e29ac58020a5c326f2708b0335ea22cad559e3569da7bac21c6f6b5fcb087b73efa84a5d8277c44dae0a841a1ed04facf0fe1e8e7d3188c05dc465a17681d941d49f2526e9fd518051cbd62f791f7997f609a21bc01f320f8d8912ef7bd8703d48ddeb3335f767e88a120161c569ddaea369ca316f9c6e5abd8634310ec86e93df1899672579958df6998fbfa58bbf7aff71745a45721bbff1ad6dfc915b2a5a614ad888cae94ac67d381f5e4468d10936f1721c88838b2043386bfb9b18851284e4548de2b2cf1754d0e196c05e74fd050863348d5f43835bc9987bbcd6a1552c6ec4dcbb9ceefe4bff6daae800674b3f7517c0c4954220240c02c3ba99f0334c584996ea1aba2ef9b831e0822bf796c97c9fd1066922e7a4d9becb22d9684ef5330f2dedd183c4cb933c482ab205e3e632cb7d9f1841c245dfdccfee8d027a9ea3809aad0aa140ad72d184f33ddd8bc5e776c3b453f32262d8f93788674eb1d5e0bbd9fb595f53c20ba68af4b965bb1c711e590716996b64d75ca78ae9123914011dc6927de068ff980e2a3573d0fe799b24d1b481c281f26d22339380670c850086c798c2b27d70f2e34214760dabd73b733a2a17d83ab0e4dd1423db039f26682a0a318a164c1bf3d2794f33b6b7f6b71a39d12d61d3c448c7f5db77c19a8b4851b73412f744fc1def2229ca07e9c09d4f0387ac5cc65fddbe9efe5d4d185e4c6bef94c10dbf30ab19860b5850eeb8da249f0ccdc5221b0ef7b380e6dd114ce00dc9c6421d04978871da471cb7f81256ad204ff028ae971f4ff7a207a6fb0f0b3f4b0f09fa4ad24b9ffc7a3bf5523e3810ee3e7b843e1ac9a3bb8ff49effd4dc567af76d1d8bcf1bc46c23310b414c2299d7e18eae8786dca8dcefd7cfa0810ae82f4c4630adf995a9a787e38cad9c528c4fac99e012b2cf3784c4c946a3e3c3be4c9cbb65b15080ea26455a15950b5615fa1165fa12c6c7719542e6ed0d6e21972d2d895210930451c785a07f794e514b9467a232b3131827081aee3727ca8ef7b045c6e8a056ee3b58534a12781eee88ae0a7291d9e665b8145c4380592a8ad927dd5a2c53f40eec40dfdcdd68d1d78f401e8c6f79e2892fbc18378812c6b369816d2f348492f31815338d028f2e12b7835e9e1574a42c4bfb158d54cc8ca8a8d1322a550c6f02cb442915f0a3a588e0a48e73180fa4404396930053b82a5afef27cbd7b94b7afe95bf6ea1f85fb02505ed3585028b5550b952f94ecd5d1ba1c6b7ded06e3b1f0f34a11120550f20d49e08b80659b74528c9af2bcf40f457bd96452327a5422f5a59a3808b8788122c3f5ab0cb9a6817db1cbc3957bb8d7c6bebb1c6220d2e7fde38845170bb74510b4362ecf0a1138b9b4fcfa814d1cc710088e5faf598b4a218f60f6a56b4ee16a21bd7dcad4112a85a16a2ae81a37229aa0a6e9e413b4ba014914f49d2b7c9d553e7e3da2be02c4c73f22b356d47cc1cbc454cca443de29575b408203dacb95aa177bb2d59486cb5144904e35599c0ba5f33145434dfdae052af742aec48f442e1f5674848c781e370c6a4a4c074dc45e4d5ecc10ca8a569dcf054caace297f0f1f0996a3270e19075dd0471127601a2f35e1d7ae29ecbf87a3d901acdac4915d6d2fa6d99ba4621a8459efc1d0bb84f0db50ed2177e6fe945717df25c8f13eb33c2b3019fac461a9877782cb78288328a1eac378ad8340226cf0446e4489aa46154f126d06968d872293c9a4ae983f4a60649494c77fab180eb3db7be59bf81762051ba25e492a851732bd0cae892024d878a8686bf79904d40587b475f65249609d435df5538754d456c6e0ff6aebd36c0de56c18a3c9bc39d77b233a32d9f48b498eb8e6defc5aa2ff02140373508bc8b1ba1a095cad4214af65b4e64fa150d430a53eecfb163b6a584f84787211ac1fc0c76d509fde451648c636b4a85c6d3639e97627e7bc327cda9fcf0e3d5df78149582ff8cdd95b64bf5478fef9e4b8b048c2cd2eda6d7b76c96d07d81192f92af5bf309f8e4aac2a72bc23fe5437cdd866d0c5c46e8d9770ec2a5561c4f47b5a8f09e2e714adbb3e5040e4635c5fb8b803b83cf270af448bdc95d09d3b68a1a10c30878ae44144419c6c7bd0b7b799503b2172f10268accce40336b8fcafcd0dc72336da6f79d69e542a2e462f610d2a1daf22e3828d6a8e021fb6e9241f20d80c51579120cec05f84aa10574d1cf67a2917a8f602de4168d9224035561fc942c6409c933e8e16e36c9a82f8ab200df6dd3c58dcc8e2d36608b114403f505e351eed42311a86bc075ad73bee7fb52c5449c9b97d521828104ff90a1b7eb0470d806081b5c1a6d8f8c1390e6df9223c0abe1272b84fb3f92fa419295eecbe99b915d23a8085a637c997ed9a6de976ebb1864658d852f3326336f5f1012880e7ffc3a4b46954f5269ed925b19a3db03d6ccbda9e2c1d9aeaf1d30cd5e8c6d5f1834babe6362b70b174ad195dbca22589d3768bccbe58ec9c0cd79f0053ec4137ac0c4c3df77aa49690d03cb6722d31cd66b3342454d76e524ec795672d3c1b1ca7468f1830d2301b96374bd19e0b520b3ae7bd88cebe047e90ff9c38a9853cb08998bc6f627c6907f282b85ba398603c02e3a07a2f8c33bf19d822eddf85281d922211105996644fd777d22154d46d3da670b288247ce25daafee5ea509ce2050788f175121382fb1a97794598cac1c8ed8af0501485f9fe465448f63e6085ed8c5084a6bc556234d8902dc90d776d380484f34f0bfcf9eb33ca62a0da344fe23089ded3f55c778c02a83b0f5afa4e1f913cf696ca8e70c8d257289d93e8a6e311e901672fe7e5af9dee0d2b8b3efc5a739b72b9c5092741033c13a9f6ef1b5e75f127118589683a7b660089a1f2fb0220629f89b8a9d2a434677f2cb14edc544273d1ed7ba1cb268b31eea693d1e47969dae4a7ff0aee075f743aae2822e84cc2d8123a880613acdd522f76a3c7b8cfaecb6e277111e2f0f82c7bb4f4da16a4d4f35d86d9351b522c4fb85558d1d08701fe5f303ad74942ade17960fb79de70e2319e253c96a4a7c1e2d78079ab2b1f3ae2afe7c89ebcc7fa861b1380dc98442e2ade591d231312e4bb03cd5af3777a8b04b19f3905cf317e247d96863f4af1ea30b3b4bfe820e21a359750ff31066ec7895386e14fd70cf8e7d54bd0056f1be7c543b955a0f14c90bbe74cfcca14f7ed67aba3009626ba054eb52f11b07fb1d9b5654caf5b3eb466b4d1f287c210af75358e22cdf02f5c789250486a5a83d82ff9d950e6739b8d58c7f88600b8758ab372c1b71e88488bcd4822a847c4b2893c4e4e27185b0b388495c0085f03da2699146397e586e1f0aea5c4a007f892f6d627f96053e272bac50bf82ac691bb79d8de572ca64ee374558c16f7278acfd1f92e7ec410754c86e1192911a5cba6b712e29e0c22994d0184d61d4a1213cd4fb3e260c660c6a0cfea192d4a8d11dce4d6157d458bc4e19774a0760d48158b7c15df1578b1ed6d805dc956ba8d6723ceff0201f226fbafe27364de2ae1da5ba7ae7a9036c6393e7a46b710773268086f9893235163f41b4123da47e1ac7898ce279ef83dcfd28b75329fa2a6049937b9aeb587146f6f878720872c4547ab3b119045cbf15bfc6bacf095bc7d1bff5fc78d5369433af38af95307c4f225f88b36a174604bb8cf60ec61913b477f374f32891935ebc786106ffc2d4234bd1f740c1c7966ca42922fd607664d252a357d977ff7b7a9ed5e6d368990294020181fdf9a3d3a32a349b81b50e86faa38f1a6dabe9d179b9cf18b399f12a575667e89dc61a0fad79c09aa9634fa296bd0795d39c07583356442f434fa12c0c3fed2f1ed524d78686867f3859da06704aad6d21ef2c92dd986b4bc1070c906a8d76e93c01c6e2da9214ff108e42e0d7d5def71c1574a711d939b0ae35837e1c439f00c3a0ddc990457b079ab792e0127f141fd9167cdcd71a0bd6bf869333b8fedb5363851b9688a1ae4ce887a48dee5a0a802b4a94ad3f7b9bcc7196081f0b7b0a0ad8accbef403a55c20b54ae0512af3cdb99cc25d44c90275c1a3d325d3fa07fb19e34b0e4c3ed4a855debbde2bf27011fc3c64d52f802745b1d39a8269b25d998b0371416e3169637912bd1f8f682a1b98be17b9132749fd2752c864a64ecb32da3ae4e8baf2c2f9c838a0bce152c15dbb8db409c4d53bc4b356eb6ac4255498521ccbaae8f5570c3ea2d2c69ac4cd36b2817018776f58f4330858970ae13008d91e9d24597390f5ec93322e05b92de0e770963af1f772f28fd31c09a6f008fd82a764e34fc3bdfc018bce542be78a86b2e61a480d1abf8a7492091cff19a6d0fd318ac8f464b0db21ac9fd6d89567b4c4abb837092a72b761bedc8f0dc99da3f0a216bfa85a9f1fc43c820501bae8c95acbb8d4895bc03e902d6a972648c2ed635f0223aa8aaa40e7e3c895af05141a90f7721aedb08b349d32452e52df3ad9fae91f95c878ba1de73662f4cca856bce06b6cb3641f8bf53d4e9d1ee6f63b80601b421e70733523200c358519dbf67d0eb65f5bf7fdea61163f89b9e119ddbfa385d909edd9c44876c458a6d0eca3327f9c2f355682242e637f9bef675c67a55f7a1732f669c46ed733a4fe6416e9d5b14b5209ed4a40335b2db9c0652a5da9868ed921451a37908746ad48346b6f1653451b22dc429872a7cb6b7fcbd50b45cc2c6383682c8b542ac90224b955bf15c4cf831c4387cbcaa0decdafcb8f85cb7cc6a0201d382df3688463cf224b84012220fda9dfb3e80f0a16abe6ee5b13f97c3b84c90033b7f70789a9683051aa5992744c0490c14e3bd740811ae76f5a166b3f1db9ea06375271685bf85cd7138a0a710051611f5ff27bac2bfe54c6c45dadcf8f1ce9d078f5aa9a9b90c76f09001c322fe5b9c182760260e28d13a9dbf48de327bcda8dad360e8c287bee4cda9e519389ab0cf2d815960f340f56784bbd789285f863fe067dd9f1ecc884c067fec5f0a4cf1963143a0f667eeff2625344ad8c4c26361be1e6b08580fa0c2048dba2d85516d0f19613e8aab13f9a2493d62ffaccf8ea97426a3511a6f0c69526a55f53622275475c42cf0eb43ffe151284cc4b51d7aabbe32456af40a4513a177ab3b09c29422db8b153ed8bc739626c88fbb0ca48fe327fb0e612e5cb209af918bf04ff7f02911d2077431b6cdfc45f043520aaf4ab5ab55f4ec86325e7001c8b23e799ab70a6d90cb2f66726834ace7c9cbbb29ab8a61f23eca09dd98ae03a44866376e025eee1bd724e4a20122b8ac08393f6dd6eece9fa46a0f74dd140ddcd8080ca94f607e0f8d553ef04885b0c288e31218b7209df6492efeaf5348db1c29780682fa79520a704910c7529fdcf668d4b375d779487686b4d48f59601c797c1ab53e1b6ec192e89c1432cab4dec8c4ffcd04b07831067004cadd5ff5fa8db2c828ea7b36df08c7f9ae77d768ef69e0af10a17b1d4e162f9dc743c43a20ee6f417ca40ee6ed4ca22581dd72c0c2b74ea7ed872db98e9239141b6ba03fbed7a51f04b57315e6da528500d829dc7d558c26af88ed770ad39528f735c130a61004196d1960a939f2903421dc7ba05d9bec78b01d40404d505057eaa425f23f9fc1e7e77dc73e7897a4d9ec983bd510e412e47878fdf5d0cc27343a3fe193863d2dbfa7d9d4afa052519f2f6da9c5ec338a6752167697985a25db7a63cfad79496bbcf3494a4e32243faf16f7bfa2a559c8ace3b498c791064e26ab5d2189e6ec2f61aa3d11ea3c4beef1e5fd60613d9cabb23e9ca9190e0b0d4d0ae99a39d528dc783786b204ebaba34916f3a0d80bc23bf0a9048bed4f68376bafa865196f821c986f7937f1d7689cbddd5485a48b0b92a3d32fe00ae406e44e96c20b5a3457ab38793d1f78d73ba8947dc9576a8a1cf42a7077f0791856cdbd2de59bf6e019fde935ea4f4535a54c7ff0e6dad5707f15010caa8859d49365df8a931403454678441f04d6e0a7aab847b7b1434b5aba07efaea94b2afb19ccf5a8222396f186434582750246e6450c9662e756db6acf3253a3ebbcced041215459f6c48b3e772c91ec850fa78555a646f3c938910785fcdf3af707918ce7638c12f7561d4ddd082b1ff4c11d665e651c836a0398f9db4a6e0638178f0beac6dbae1bf87ef1d3f8e19dfe50a58a9db5e5f74b6ba92a4f0bcecb2655844f5d401c98647a23c62d399d3bd3d1b4eb20426ce46effae2f9d47fa2b7e39e3b0e39c31b4af2a4e1f519e747c8d35608d71d67d639e97c164e7580c2cbaf0d825c6f75ddca4dfa93e29ca3d22eaf1d25e53a7bcaa938b3783741d2d2c064bf9f7d7ba21730e99f62497a0c27f310180c2a627a347de0ac4baf4187a2a57523daf41063cfbfbeb764f2210fac000126ccd68adc40baba056d2ac99c20b5e329b90032f3569599bcbd09cb8a00f6461ca2c1d85141aa5149a16c2990a5bbc6f68beed67f54c3f3fd455f3d8b275593e3b764fc9cd82ee0cc15e1133f5db3cc0d05f75296a6a6011a53f83ec3db35a865258648f51dd09e655554a6ec522e9057c622e8548b940ab78021eb70ff1bfb8683674590727e2cc52cb0e83e054ac9340e92a141618a6975ec2df70a5c6826ebb7f5e1764b506d1d09cda0067b7d3d68c6d234febb37ddfd4d31c6f72430f0cbe3653f1c54918765f19cf93e03c06e35ce70fa1d01701fbcbaefdb1fa78d9cbab4e655bd9c4f6dbf6ae06627f058edb7a704854ff56d686e8b17bb038da22527e6d54a20c5989fd5bcbf8c954bc1ab3f5fd965814e5fa45706d6d55385b905dd4bba533a18e0f2359047e352a23abb7d63641206664fa076a81a426a418deb389356af49ea5f9da082b1eba60883ede2833811cc90e3c81f339e404ee2a1a4754304f84a723503296d3fa6902316b92aaa82a1d23a0a92aae43f69ab7fbee928513dc182e077122d5a133006668c7c4effac38fc1a9bb725e9321cddfe3d8d9d9d901103939c83a2152f5ab3b75160b7239a75b52b7ecbf827ae12b37b5b7ffa6ef0d07b6b024d9226fbe668069ed1763f3a3c6c4c2ed90c1fd33425cf572b2658cd51b18f2e84acc13c971c736db6677c350d65ce1f67a3c6297c5aa392b77d1c48f8f2cf3b4924020a586bd21ae07796434c923649a10134f78430d07cab67493d22472179afac2f1149759f61d1f71c83f869654ee44f7e6996f19540298938866bfa7877fa942fa4ab7454dbb6e8212ef46c2026c690f67d3341aa9e64b2b294b15eff097f61b5f0ba3534ddc6adb169521764ebd7fddc0e834e8b19dd90cbd999864477f6c0ba443aa45f673911a463f6f17c47d81bec35e90e41032b20b2852a221205748faa49d48a6256f7c1074c9a02e708f0c58296cc0381e8a82df7f899fe4b0e96675a26f73573efb78e27bf019c35345c155641ac9a4124889d646267d602f161c9d7a121304708589582d68092bb2f549fd77bb7ddbbf1a8c6d608065e6c23c52606ed2354acecfc6fdc47abd106d483a3afbba6ba540656ab737eac9d9cf19dbbf32611afa014b3577a0b90263ae90eaa2193ef5dca0904522acd2230e60a8e5e849b9f9755b5f50e8acf5b30e7f4ac017fe05bd9e44c0b17c49d20d81592a7588a2bec1dd5c1e05323b6b2ed736d21fedf6828da14c10f800eb2fcac21686da76a6af1f5c0ba9474751716fa493ceadd1e8288be72f4de325a786fd458e4d22178632023ebb896ec41e170c310281756396bd73c70ae4fb749001eba4b6140d0e2316103f03cbe019e6db76c507a92c7559494240d0983b61fe990eb64a80fd6a5367db2bf8abd9c904456a530e585028f121740f85e075eb81128b9b4aa559da2577827b26f575d1d5289032b85ffe161d367dd11a8189c725d69ca2b06f6eb59d32ccb68ecb92f3874a43869d7b8221f9932437b7c6c816ee1b2ac1066901fd16469798d0107a946814160c12d7248b28127ba5e72b723d9fb0f299bfa678ecb05420bc57f2842130bef3ffdc5981d69d548a3adb8f35eacd7305fa001ccf5bff1751ff5b0b2c46a2f66ac4e0375a6c83045f236470ff27788440c58a650366ccf8b436b1fe8c3cd1180bab0f7cf27c4f148b6dd086f8a5ebab487333afccbe7c505a583a2c67d6860dc294548053ab6b2a80c5f8ab69dc6cdbd43b05370cb01984330759b1000e9d19e977b99ec9fde19367a6234bf8125dc83f9e6396e38c34a0a12c8fcb9ff9a30ef0adf28bb536602b12a50bdba07d4ccd559168c33f05485f90a02feca81c827d9f6a53b6e77227c5a34128e6422c7a2de1004c330959dad9d03a84eed27b01b0432a1ddb7f7fac771558cced54d6a2d24d29aef371356a290de950142cdae78aa65de464a192664acb4e10435614172fd62ba25f8080818f6ea0d406d6b8b2dfaad0c2ccde439cd0f27d3f46a348c833ba42a056d580334dde40d2a41c8858871d5bc4ab136ec30308156ad5c64ba52e77f3e02eee110150ebee945ef10b9aa10563e9857a2dc26ab70de29d567aee8a855f0ac484bb2020698a554ade1662e96a6553b0bea6632943738ae7750d70f62ce46f311d2a7cb9f69f53f74eb9c8f1121b844f44a3595dc6022667296b6c400fde17b500157f043ed6fc7d0e35260815ca76ba9082e3ac088bd4e115566938e1b6789e91f2f146dcb312f5fb4b8557a8b1ae290fec96645b9ec9f831b45c30cef58bb310fec2d87a676f23ba40028dcf995a0283f4cb926d5e0edd7908d65008e9871b3ab1deadbf3065d80b7a9392937521e5f1e5e2e8341a4936c64164378658f6bc6714444f6ec96564e438bac94e3c3a27c7dbd4da03f1ece68d8ce550ffe53f0389774d448ef69b92530eea0011788a87590a08504f7ec69f77fb237f7b525bd14f1959499ee23337e4ca17698f223f28b4a9491ebd7264d3a40b9cdaee56303e0848795ff293837722e1d68158ab09756de28bb41680c68f184588f3bb54ae42f07f0dec74011e458737ef42df86a3285fd2bf321f0512ab00daa6dfc1eaaa7ac4f347033c33986ea0cd8ee29fb47634332a43c3e1390f365a6d7653d346d6192487d96fc131f361ef06015090517d75fad8a214285cb9b7bea14859be4c401b791c9e4c7dcf14c43551d582f16da7a004c0cc85a9621417e806a7b52a8df9ef793f1ab2b56034eccb94e5f4572687c78fc54627155ecd1110e2fd214f1f5b71ecb854fb51bba05792bab3fc029781c110f57f40e644a5c02de75488c97a65f684060d62f5702f0f94df7b7c60b3a6dd50904d28b5e3ed8ce276aeb119ddefac39c5406689bb80dae2ea2dcd79aec400a24e73660d164b78ad9cc1c20d6a3e34443c270f515c8bbc41743f52dd6e8340fc4f537a733fd14bebcda71d8047445ca5ef410a65d39734d7daa9a652f07e00660d2cc8949f9fea3a88c902cd8f996b0b09124531653891c934fe83a7a231c8944f531574e80383e8f26a367e1ebae7762873f46a1a8543a1d5b7473587a5191036d202414e64e4e6a259e6ebe92cec5cf43bc5aaa785c8861d8353149844f47aeaeba9c265cef0d6ad3ce177bd74bbc709592b7d87504662be0036ae18923488fd2a3cbdaacb6bc06bca9c717eea6424280161d48edde08d4035d38b7735d14b19dbe8c94fe14d596c606d83ac5682417efb86ddccad3be9d8bc1e3ad0d272d84fc6c48759bb1773ca1c6d8e4bf4bf852a882644b26daaf029c1d8c13f635214604422700b9a5420aff3bc9bbd73e8ebe2b660f5e17aab478f558fcfb8c9145d0e0f43049d7d1b6f404d9d3d5ed5badfc6b1b15af460326cd646ecb926e40c60856658ed01af2bff395437783871d456942f892bfaa4eddc91046477f9c5dba48eab494e16486eba1543f069c5dc5a2302ea420b5482587713e58d124fe4039cae5b311d63f77a2884bdf5039b1f90875a35a748a00748ae4aef07b2ea2b2bff5350cf47c6392f27f9017d593f377514ecd31d04887169e819e59792a39df288d6af0bcaa56e278c8a7995f7d959791b308453cbbd0fcf58f5964d7aa59bcda982cde9afa2bcf3ff3a986097afd08702a72a82984b410dfffc82d026f9f6626a33f308ed9dfd5b2b9910a6f4827bb7be86f65eb49cbde0c031619f73eb729bd63f3b57e1949fe6b902536c07f40bb9cc0ad5f86df6108c99ba187f88b89bbfdc068a7b580e79e19d4504718312720cc909bdb3cc848783f3fc1d2698e00c9d6268d7c2921fa86d456264ba7aeab74240abf022d4fbd1bed50fd31488b58641488a143437f80a3cd89ef26f61453e48e78ecb6a63f6f3495ab047b7c89352d35aea602b2a67cd1830b8981d55ca61697e0fbea82831557ed64feb6f4afeb664c99e777944af5161a645b63338a55ca8c9f2d2281cd2aeb582c7c3d89471dbbeb32d6cd99056a912e50bf972d6dea485b0f5e05185ebef7fbd19d1c367b63f585597bc9c385038b70231634316021cb82d223e44ce316921919d21676cb81a0cbf63c56bcdba93d1a77ef0a6718b05e1f3869405fa676855cc8d09378660e5c91233e217aee7b02f121c2f85ba8674f67584c648442c82a0168db5636c4c3a814b7c10a1e7343666a088f6897e08e2f1bca85fcc941b7064c63dc5c9ba5892a3dfa058622aec83e797f7d3e6299d6c822ad7ed4d32a72d826893ce45a61699d845e24ed944b468a381f4af97724d0c55b07e316d8250c2669258eb6570be62944e82edf2c0706c1e4cdbf368cdcb268a2a04d285988d405843abcbb3ef9b27f536639781741c8676b1836baadd4477644b0d81eeb1c742bc82ac9ebd652caa54ee81f7a1b642bfc3292fcefc507bebea76c303bb569b91fb5efceae66ed43366bd4af10d3d3b15d53ce528ac828bbea3447c60cb367fb99621d4f442dcbe566e1614764a9c73d79e8ac8d101100104c010c83a0dda05a18ee91c737dbd09fbd0723b713608877ee146d0329eb41fe15c70567ba1bf79b23dfe5c6911c2e7d810d4d940d7c8356b5d4fa2f1d7e690eb788a35655a43afbdfdd28d4152caa989e9d1b6da1ba103575bf2d60e6f32e506b88c66893e219e113d1dd58523b9e9c7b87e33a38c019ba3e913c5886fedb013e0b4c3c8b4c720dacf264ca918cae00aeabc999fce18c9cae1270e64cecca4f453a9cbff90fcb8ce733bac37c477b890628f598c7417e89f6d4828322ab21b6a23f034b67b5992ccf32e3c7e00436fabef1e389748d31ef07bb27373e73cd6a5fad51eec51c61c3cbb0890ef0d0e1e0d9f00f69a12c2a3ff01eb7e8f7dec6b5b3e06c366510c0b39bf6a3cd551651cf1f47d754abf06bb38d1680eaba39c91f2b5ddfa0dbe9ac74b224ef0de00ceb65f5b2d1244c8d4de582aabf668d88601a720cd5fb6ea36a66c624d27dc748af540aeb38241e7f50ca3749cb4ac768358454e9a9527921cd16514e85e57b554e7c6dc8d234670ab5bd2755d32fd49ae7d8bbb5b046a6174e5ec23e187a4f1d8d0e9d329024799f4a647525fcb7b81c0aea9c2b6b3fbc39927c2c4b9a3f1580e3c86553068cbf5abc04e9ba6115141c4319d739f9b11be9c502477e223ed96bdd9f2298549371fefeb7483476fdfa69400064807c67cdc5a883b709627c92d51b5a103d63baf5302ceeef0bfdb68f64602b842dc64eb079556a5d92b8679e4d6fafa3b363933f44289b0847907fbb96e67c72e41d8be657c55596d7c146eee43536bf03aab4d236715463af2c6c25c7841f6aa09c049e29b9d0737ba011db4abd1bfc71f14118f641e010409d7e8b39d1aab339c957e23553a28bcc18aa0b93cf54839436290642357a14536e08ed09801d76095591d36a05095c7cdd2d3073e8d94186e66126a68f6aa185df58762b3eb1c801e65d24fcc2e12297a7800476afb051c3d3f93f42d10e5aa6ad48f185774a6874581c4cb7d7a285757e5114a17209ad33cbcef364a572c4ffddd372ead17ad89019fb98c29e8503b6b5e898fd56e2bd77aaa003d743d7e723d0f764bffba5fa147aecf648c69fd11748a6ed01853e78c8cb9bb12bbd735d97de7c23fdbfd1589bc01ea3ce75ab748324db378c4c00547ef20fd64fdea8861bb47c6a1b7257832d03334d4830b36ebb226777d8f783f6982774e65864658e2061ed5498419db6c22e1551a657d13616d5ef13a2a533378de919b137288999a917da3dddd8004cb3dae80a2dcf1139514ce7e34d59c0dc5c07c2f53583c95485ba70fa53ba09d715c736960c5f9226e9779d2f81e409b34912d9d1b8179a2ec14f4cd8808186dad6fbb5960f2b24a86c24a6f7c3e4705508d971d285ec648afdcdc3f2408477105aac9f3fbfbdb99f8f932e2a662040293daf0a7a8815e456b96f53913ca1be76c4b9b639f3a32ea1c7dc7e25b880cc2537249e1473dd8ce1a6c12bf74d89bbe816c1bfcc7179285e0c04ebf0bff48785dfa831c6f945ffa29936da2120e94b640a588d8a46a1b97b2358ab893ed56dd1a2013e468652e14cc5ea579e6737837b9cb0f6baac3389a1103b7eec43c1986face7dd8aaff8566bf9275a07eaa5548cc3718e5753ced768c67db5e0acd16d043652f9a98995f5a116cc31b45740be00a5913cf42d747fcf78c4bfb686bf24f8510957432a85b438d7ed961ec66cadd3418d9cdcc52d954fbb00775ca74d7b64d3dc0f34fe8d1d1b39ad9fdde549f5616bebf660330a266f49b4f2c339d1a525c740674afab58e7920722ba16964e86daaa715046080156618c00e597dd6231f08ecb60d874fa704afd28ebb96c7e3f8e2edc37edf0000afcf9146d8fcaa14c578d587c6cc9b3ae2b74804c59dff73d2941a4ea3766ea52f97834d323e1b1dce3e1a38d219e6583d43b9cf381d11337247942eda704b87da3e2e6633bee37b8b0ef202f59ba8dc44f3cf08fba5ae23567673c65732bad0b8a2f2ec7c944609a8fec943b01917e17e1d3bfac5d983e33e0bf54745c2f4daec08a578ad3eec8987f731d9846f0fcceda2e209b16bd899b2770831e2710f17c8cc0064f5ec9070d5f98ba5da13f706b673b8526cd22c48e07c4fbadf73c2a93e157f2254c49c3af4f21ef38e50dd8d40ba062670af0c7360cdb70acda476893d9c772fafaf366aa56ac582cf1fac0f99280f0cb62c06fec9811cb275471f0bfd337b3047a5fd8720065b564fefdb626f0a7680f4800ef2fd7e4ce94af29651c495fd58cedf8dad8b65602bb08e11bccf2bf9b1728b3dce5d1b37ea5df7bfedb9e921ae9e2e5bac6ac75b54069603cf04d5df9f130e06f3be5dcedc8535d0e39ffd8da02363903d94c90f0cf86cd0d941c0e3e8e6adb8f796cd655b47f99eb1ede5ca3c601257717d78ffef46a86d7f11421a7ef636e6aa3f8f3151bdef51523392d232b01d0a05daa49c8b393c08f6bc3a03da1a5e656d26e9fa40413de8aab0b6a44427f21214184be50c72b0ecf4945438d0495f26e5bc79856cc10d6769c27387751c611e6d87b5763149a086aa83f8e6b2319a4444c9e0879070642f3e22c34ec55b9e9372aa53a572cca86319887bbf001bc7113a7dda36304c86c4f3f3b8e63472188ebad5da85b08f48f05a2e23214f030f27027a45a9d8a1c23fd17d91a6352405fad832ccdb96ecd67b61bebb60452a2744cff9d7c69df038f9d862d3a9d79c5fa23af1c0442cf7c6f0c0446e3d796b0f5e4c894785807891e3695d8d59a9ac7691d668d0d768e2d759a9cf84649acc239a902b1a9f59b408945fc71226567c5b1201972cce3b29f91e1335a0a14448bc207ab915893ff47e0a61bdc34909817be79063a0e904b202ab617f6dd55c59a8632a0639b7cfa66b2a73a5fbfe7b8ae6528eecdfce98cfa4fd0a5cdf592ffa0893342ab13415a5811644be1c8f6fe7118d2bbaf2959af46c62adecd1d1b6e117b3f264072f2be09f8ed9e8783b08fd72375747e85c9eddd7e3baf315bb4eede728b53c1617d239886e5a6b2abd2b7d147b1c354d5c8cf5a7517fee987ea54f694c169c03ad2a61470a94133ad9ae2e521d5c53f863542e08e4e2a3efdd9e5fdf40da9ae12d150d80c0d3c2404b694fa16ca85616125c42e528aaf4fe54fc4d5bc7c9654f25a200cb8491bd75466cd2ea38ce04bab1f8642e8f0b679c5306cae968cf06ae984d0b5e4683d3c99abaa9c73b090bd764d75b07876b9b7bc1535706c9cd9e4838b4b5acb50bd8980c52238baae4c39f962e423554a67fb156d2768a3d9a76ce57f64e0bd3c7369cca23462d4b29997f198d07e6b29c7a7162132678be9c6f0cf5eb78ce2d82c1df7f6be1db005fc619bdc8400fd116d68dfd1ad7578ff3bf736ef8fb98012f53d69624323da39b5b08e3fbf7fec4d0801dbc4f314ae29f2baa750c2237487c1ba25dd3fa3c62dcd8f191eb66b2420d8fd1264d01e9a1af78a3e3c207e4cb8fc07fd5ebb3a9f444f4f0c978c2f249c42dbb51dfa8e87205acf00ead2a0f11f96880a2026f573e32f362d5362ccc9348c31ac7688c719eca2d394a948d8b03cffb102955161b684b862be46382e178caecceedb564f5981a1782461bc28a033847d4ce8337d3b31cf41d4f41bb7614695a4b7f49ccba9aa10a0366e61cbad1425c484cff73b915a4cc77e54737856b5e823bc8d8fe3bc62053da5f762afc43c285ba82864e506ba64438410924059757f045662b73b6ca50e95739d9286e9af0d027c084f0e7c552c6d82ac7517910a7d3045d73d0ca3cf912c53459940b2f45a9dff8f28fb3bcf099498f6dde3a52ba382d013f22422b719aa011efa8be0e9a7c9cd72e248c310834f796612443b4bb6230fc2db157895f85bfc02a07f1406b646beda3fb37725a946cc1a753c8ed1f1abb0c5b02c668d947377a33dc4d0040baeee65fa314a87a4d048324420391b11b1ec5b81de114c8f5ce06942b6a030e7fb18f2a3b6c56f9b9fbaa0e44921f8ea3a9523175539222c7c5ef73a6f175e85a19a2b7d4c5bc376c093bc2ec664770730d8eb1a53d9033e334de8d26f93f04fbaf710a9024f6cb49b55bd6aa82b21c5903a09fb446e6535f3dd084bec29aa824e568495541de82708aaea5ee77a00992406663c1cef43f33ad092fc2febbb8aa18c49fb7c0d69708d7a7318a33964acf1f4e0ecfca58f93d2a050c05be465c6149bba83c206edba1aae16a5969df9634ef3e5e17a8710ac3beba980430f272f523be61e22bd1c91429294fc283c90427ba20fbc1aef667ca640c703655afc087f338aa4375da64fac71e64776f4bc6296bbf40b1260c68a436b029680927cc85009727b68411abcb224cf43d174ad227316462356a58d9c6e77771d237821f4e6383464c845f59539e659234005da0d94ab7d7e54e842e993ca5e4c9bb03cd2640622c62a77455bb785732ae2c736df6414e569da3b447e3c15abb0e1dbb406bfa08d12fe17cc4c55baea8fb6b8d840467bfbe6b2c399363ab3731ab2a93513e3497a23e1788459fdbfe72c5521ab6ce1164ce0dab21ad881432daa2e2d6a8c0d5156a5176c96711c42dc705249ba70de6670c3847c2bb1a9a01753248af3b2904bcb10dfdc8b16fa99c05f0e0c7796b1119413d5ce9373058655d19415e816f0557be4d6827be03b8285de99314104c437f91bcbef0b22046a127ead14b58e50a22ab159708f6a16b3d5eac6960f58e9057584ed6d38b38b2c09b96d6a8ce4616b0092b15ef5f77ce38cd95571357d6250e0f061fd0d829e35d769fcc233cc881726e9ab49ce251fffd286fb219b512a56d60b8336b4980c40aa215c0374931580e7c0dccb41ca972a9b4ea8bed6e5b166e998a435c1fc10a723cb5804e7d4955bc281dce317ced2dd0fcd995da32d75d40a8dc75ee2fdbb9551b5080d6e6cd3b00ed108c504418f145242f54d8680bb76bd77cf78cb9e54336434b38252c9aed64b140794e8071c1cda50449167a9b0e1abf291a03e02a2a82d6ddd0b713ae2e73c4dede525f6ff8f2a447d3855b37f65477d49da2c94e424662b22ed4d30e3a50cb223f51aad4213df58c6721a4e88958301019a76c0e7ad3e9abb9f5e2fd1aff9da95d24b63eaa913fea9cf2d15b9b99ee17bc9620b4cd36b12425c242b50647d99d22bf5b06b68af84b9d989e50f94d4869680c16bdc0d1a191f9a930c522687c766dc21eb2b923ae434dc7de2a789c9770fcfdfb5e4c42b4be3fa6bb541ebdbd5c7f854b009f93d374b30da14f399a696a3ab0187a364bd0f7cd2aaaaf99f11ce93228aeaad68e89f5a40cec180acb47f142ddbdc0373f9ff0c9c7396675d07ed96ea4cb9c17368bf61eae5e08c9a844ce24e860e7e6ef834ad1ae3ee467427143b084ea51f33f39bf493a8e738d489d448d23e3887150bc74098e3f378d3161349473e2b8e8c323ab0d70f8abb1965592c1dabeaaf7e56e00dc5057f1fc95e4a1a7f6fdba893ce97b82ff836c9f113f1253ec8acc6651fa7644db092b04d76dacec0c3e8d5c94e4342497c6fd25235498f18da857e4a8c81faa3b3ff492ff95017953bc8cbc15601c7c0ed378d14c32102ab11efeef5f3ec5d843166360cb36374cb384e850d8a5cd2e1370acb511f0a1bcb0a03906aad82d8a70867536d34122c93985ba4db358dd75d0d6f72019e3ef24d123afa050db9f9062ca221ce903b97bce8a39db72ebd87f30e56ad252f02aafb31dc2d347b2face42963157ab21a946c6d47b4ca87f2ba299ecc9657ba9a0f94eefac1d5713a371cfcbd2aa254f9cc14b3b62338476e7d9e5514d750eac3ea252a32f0df90ca55e026ced0399bf6293e13d4c6adf4a67da268616f1b96d541a67a22a93e18a2bd9c78bd8d450fcb67ed2d4276f10fd10148ae36834fcf38017ec4ead6ae9fd8d7670c18f3e8773a9155405513c423d8d4d22feb8b2f308995748ed539b9de7e8ae8dedd27ebcbfa6bb50c09032a00c4e9bc6a7a68683cd18fbdd748ea8ecb603a2babe28345ecba57ef54be37ba2bae5f49bf220947d46b97167e3cee252f333b243ea0ae27627d9015042951d7b0e36a4ab90abff4e5454a38fd840acc8ae2856f77270ffd3f0dfc1849448b06da13bf423a7a80896194c9a67f9097623d0ccac80cad2eea39c1a47e0de5fd0a36278b7bdd47e42915a67be1ee7f342cc2c63472e90cfae9fa9453983c8932e53e0dbbd0b8fca053eb0099693f5e569c1b9da3e9089d455613c7bac5791ae511e3af5df6934726fb07891c8c9357a22d6dd401c2335afdb98842a8af4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
