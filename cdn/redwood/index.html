<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e0cc4f09b2a9f68c8f5f5e1bbcca69f8c66c6cd03b372d0dea108befc525ebb38142708e7c440c2d48e79ae82ab0f32406dcd1850dab5ef2e54b5f406b95b2ddf11083d1d67e830aaf86a389dc700327ca9fba0034b5c4783d3bb84bd3cf0370811529d42704605dd8f8cdb3d58d3115a5f559188e9f0ad31eb3a004fdaaae1862fffc6dcdb77dfe590ac347af1e06e2a8acf02dd4fe181ea435db844807dfb95f4faa629b66cf79d77fe63270cd472e8ee056d51abe469295e32435b2ff45d7af8f07380bff4d8509135ceb6d28c773916f2a25a2c5a69613cc974dd5a7ff2ce0f2a2d001bb4ccee9553ac95ebfdf78da15975d93013a9805a3455a0ef6fee86dc9aad805f639bdb36453415cee51cd57da9fee7de24f663a72a9e0ad4e437a654deb99941af9bba2af27ceda4cb4487fd26bdd47baa88fe8f84c8c7adb901ed3fe2f5a89a43373bf898b9c0f97b9e81abe3af2eaba2eb9480b9ee2582e24dac1e902922f92cfbd5eed1c1ddbbe016218eed1038e257fa1620347e7755c8c742dce4ab0d9968d0534bd79f5dc4f6095eb5db7ec176546bbdd2d68483c0818d380afa83aefe37cd65636c8c669941cbe08c7c7c3ac6d180b4f3f56f2f48a77227646f425505e2f742ed690744b3b83972501d17cea5418e54cd4f03965456a01412a7e450db10815028bf60434bf2e6caefd0741e3e3f6b6bfb27b8a418605db131b1ecd3f72ba42b9241d9a58bd4e08b9621cc34ac48142fbcff7870966524c1ea49ef723367f28e700e61ec092b82c62210ac0280f54b1c375ca97a3269d97026f9dad3119dc3de01f6317f6e2ad677dc47c5cacb7a32c118e7a02d9fa689da9fb085658a87ab9baca1b8b2ab2f027fdf64cd962b20dd2c91055294d47af777fc535abf915302952c915df83a3688e69a9d6010bf47c0ca095ca97e77509412d4b3a132b0a1fbc01b4668886f0a4132f1d1bc55555a1947f9fd98136347d89ccbf6029f07eaa7312aad844fff368e36c2ec2073542c1f21ddce4e833bd139c50d70fbe304fc8b788f2add640f0004f8c585bf3aac825cf4c21e63d99129bd39fa0656da13ad8d9fd85bfb754906a5670490e9a3620f2f1f7e7a9f114966cbccee87b565fa38b0dce54b65c1330c39b3ba7928ae43ce26e9376bbcf2d4e96eb4afec633fe671ace31a9ba59e8b2eac55ab1121a10b4f8193dccc4c735662740fe9a2ca443ff1c109f2dbe09f2e9e61a46ed35402e1cac423d4456ae563bd7eee275be8bd8461694b82e9e328469cf14feeb3b38cac6b0f9a45c01f6517541ae23e232590ee8ff7b502abb69b98dfef584ae2e27a18dc0c6d4c5859f9730663142f695440e94b9fb52297ea6b4521d25c873d3d859e22a3c14a0baa95ed70be1f063b413cca9b10e04af5dd1f6fc5357df0130a7bf6090268f8c46e885ad2a634326ad849d5ba33457cb4d610db05c576572afbaebd0ff869b7ae3d509c04da409f1e26bd27807c7854bbb5a066521ee7838f2b5db12716f8bf3993a7462d8c6ebab87ca1938c6feeac16e15ffa86ddfb3a464cd9868846d789d36c672c8a3ecb3a8de703a933ebd642644be71d36e76d9c74412ac8b3e3c7d3408abf271112a308911102500bc184d3e41d9227772a20515bc78772dbdd97b79bc285bc77f81bf1ae287df73474be8cce1b786aff9c227a45f3ec46d7e3524085b9b7b21f42f8fd48dcd713afafbfabb1a02c8d339c27c2e66c588f3693c94b82f1d81a15c3f74c93eb9959875a6e3817761594fe71b700890b983600a3e3bda8b302cc021387bce38ef9d52abd27b14b372f4930c229c36f543f40786ae795e24db8e9b3bbfc38a46807c1b5d16df5c1f88d154c0f3176d221d64a5b19c9237d8f49df0109372d5d569430c32db4ecd4d0d510656a3038814fa060097476b29a9cb2c5b55ad93682c30bdcaf58265750237f58292c484d41643ee548bed17d6dfe77e1d178fadf5ab11852ca0dfbb92ac6676cb23f04b6eceaf7a8b756d968ec3fe74f393b21eaa8503758519f10fd4609c9ca462a87b346db0d28134c5d924359d41573576922bb3bebd9f74a991f75d2a676c6e69c9429a93a11623d4e3a208f15f9b6bb2d2b3e792f5c2835026f2d73b9b2d698936dfeeaab52408691959fce401ee8f9e42447ec5db0e20f3891818475f625b552c5225144484a7f637899597232952fbd98623bae6faf2464ed257b1a346c05c281a4acd3c79d0484a682d0d47d6dae382e7ae8267e8247f1188b5880fbc7111a6a8f4eab25ff6bf942808990d228e6f910383da93b9cb06dc465901e5b7cc52ee531638bdb1735a62142872c99b9ae5d6f9c5450ae07e887ccc8ea1b8a96f4abd44f7395543623747bb3c6bd3907822f188495a08b21a7d33444ad1363f4307f54bc3f348867f390c80ed8bb6975056f7db8c70d1621b5ba5e6814e6726952ee8233d2da5615b4f3236fa6ef798cbfb455ef65e16bebd94723bb47ecd7adcf2be98d909cfcc674b957cef9994de6841c1bea47eba8a9a15651fe63d54f456495f0e9ab827e2c97293c5d7464016741e30a3160141cd05c39b02a7770a91f765e67072b2312365967ba67366dee1a26e8bb9f026f38149931af5c6b4732a350e76ff4a0c7e2673c7b9d04b6e6f43d5e04b1833219a31c0e907597d223d9ba2ebfdea8933e6a020eb3c1af98a5102b57552a5a39d4d007cfde00f5f6334dbbab80da4e3ecf8a40e9e63085c5646ff2fad16a934aa3b10cf4d2098b0de12e97ed07e56212959cf2e0c4967c08fe00b49384f8c9bf3e1564de946ed0b4600dabae8ca5cd74ad89f5862a9fa3eacc5a646ec61c7b16cf7c03aaf7c90433f41265de6d359d8d7877aa8a41ac17fa64583c87dcea5f2cac98583434e620a949340cf7fa2deedf29ff7470c8d21b15cd2244a7b0465df3b9f0edc3141ac974c563a4c24eb9b977ddd03a94390f447e827fcb5116065a90e9ff6cd7153b54a843ab4e3c1e28e52e466f1e8789cf03502b76a68cd1732917155bde4fcb1f2a0b8c9dbb96adfb5bc68618cd748cdfd0f5cbe0145fb150bd8f5541b1c855ebe27edb61b79b29b0bc96689a37db2dfa36cd80a5917954a0460f16e04eb0add300750141e5d4e3acd85eb60491f722b4d6de284270ca9cf1bb830160e33bb5a3e090086cbc054e50daa31a762e98ef802db6197c04a152fb10f56facd643799167ed9b9f0be537c79459837d5e1c7c4d74ad60ecd74d06067a754523394031427c9501b479b1a2195834e31e6c19e4cd855aa11d81dabcde8d9bc06a420850abfc80c06282346a9df2cdac794b9fcf73e9c0c843707575ab82ef435849b5ec637514f15c7a7a3bb74270a73694f63c07fdf8e1b3e08da5600bb6b1647e9a86f14a3157d26d73003fc3e505700569a0a0899ad1617c9dc7c5c21f80b77f20cd10715755558686b705d830bddf30f7a56ed778edb17624323f4694e14426769b99c49a3c92861dc01a8b6f0e3ec3087c8bfc389c598ac33e696e8de1184f61a078f59c618a13daef01e1f116ad6851885e502c913da40b0722fb802c2736515113d2aaaae06b376772d161870e07482301bca84a2291b3ee7f6e9cbc3e58b6d246e60a0e98eb14fde4e48a15a56f960383a382d5430720e6fc21abb10672372301ec04664060f7919b12a340ba48ce18a6abed7efda8f89428505254f4e9514723d54ca3d50976810c67f1a55ce98be5336d140355cc9bea9bcb3d247a4ad2fc9c5029eda916d347288277d38d666f2b1727721e3b21289303189e17558fcfcf9d1dfe5acd76dea53019ebfe820f50e9ff1f933a58f871b57e08f3b2298337ba1db13cb8c1b5ecd77ebcadda83e1aff8178afef1f46d1b5d7e3426867ef5bd58e4fff6ce82b018f31321f2f8d1144d091fbe697b7f9f0722be81404b2abc4d5e7a948ea0d711198e77b3c60bb7851a73b5d57953e803913e8a75e5b0f2a5dc4c0af3fa33abf6e47f8c5f9cd0fa40baadbdd4a68bc8e7a6e24df5c0f8759ce5c940f76c17436e873cb373c5278a315cb15ec05f8045affa3add2457c686ec065b0bdb8a0b6c1ae9489b52a2e1c7b939d78ca1437cb236307c2e9ba9f1475f222e43fe10042c81932145363f1e32be0b8fb4b82635ac5159e024d7c23e6922a7b59f86cb375841a3f86da57276733ba50bfbc6a11e0bacf2cbf2c03dddad0d58b32147b3038c35c8f5b9337f92e79495a05f9032b5dcc62b9b7ff87fc28dd43749770457daab5d5b8cfb774b55d2fc7f50afa8964899f67d7a9bf40b89da4ca228e6e97944146977bb7163e16a6ce7d03ab6ca6e4a6c12ad053b5a87bca5906799ebc89bf862ea491e2c02322fa44c538e0bcdcf81be1e2bfb60ea5cf7e1c8f75d82f1eb72c3deb0e47b5f8bfc89412ffd1346692b265fd50f45af316e89566bba29e4461cd4c13a4686e9cf6765fcfba93bce0067b8592478e7c687101c91b87c60fe793bdcc51dd3c6728293a1e2fd1866323b693a9e035122961f39fbba406672aac878a912065618678ac41e2523549abd1af048a21ab79aecc813d450f0d830bb4ba285a5156ad1faeab605e2430d046c64149b2a1246735aa3ddebb2ca2bc53492858023a7cea945b74a55efb27fd658b539c4c7d8c9c27b7beb511b51a4f6598981de1f498fe263947c2710d051b3a49244a60933fecb100fc4b2a9665f33f0b69b64b0552737d04c189deec71f3f00c7c9246aaf60c284900aed997e689d02c8e365e3e696186b03263e42c645f4c3f334b9dbabb5d02753122d404d15c94c928602edb10be29e2cc55b5a4029ad2b6f37ee242806e66ef8ad39e28b114d6e9e09ea8a11bc008dc039582e5114ce7072a741f875fa846e41df3815fcf150ce18bce2d054d07632043ca3e4ba910add01264066f4c6c6dd1badc6318830255390581c9c3c791d80c72cba40f72298e24c4923bf2689168c0f76f6943a2b9389bb1249aaaaab64d251d7d2d8b5c0560c4229bfe4cdf9de58a7bfc3b3ef3de8968b2e3cb61b06a09ec674be927c64d739c7b8d11aef3cd4c97b88c273a1349100e2995e7473b184dcc6ae82c5024270c950383a9ef70ab848b634bc6c939dcb8b9e37cb9ac8bad13b33145081ae0bf979c8d5023bb60631208d92c526d4476da9b1b7ef4a93c20faba4f15b422307616c68b666ee53991b7dd7ca73824a4ae62249b934b889c0c271857c4184a96258e105fed99fa94ffe0c4df54a336a98f6c85d17e2d3cfe6b2324b148fe37eb3ce56919f83f33aeab8325f753d5b9197521da09382326216ec3ad19251b1fefeb58c177d8a149ce2564fd79ff1c02c1bd9a61ac0b1a8c4fa66b290557e10d8bfd6bf0bd2d8d1f29a8bc0c8e2a717a495a373d2dcc984ec0ef1c3e1ebf609c4cd51dcf1217c0415388dcad1656bc7d7a81a80102211a0985f334b0fd0f3e0aba859d5efd5cf549f97d12892a4b4cd17a2a284842c9d9d7ebe8048702e5cfd088c04451465a80a9834b916634092c0b56f4d2a6d475225304fe8b21b7e234831a7cccc3701163593cc5334a128096752695c0dc46daa01956688b15e5d43cdf13b7efe44ead3ffee794c01b11d4e2df648527eda1573f15ed01779f1a6c90b4f22cbb2f3b9e1a45df79499cd74912cd68c608dbad283ffa6a94c8fa4cc6cf4fc9e3dabe5f9164e83fe441f39c8525be000b5b5200bfcdf51cc1accd4906580317f4f451f9be0d4b15a567740232c3cdace6b8bfa6123af091f3bd6eaf0a40b936d267e816a0365909a1d456bd773075c321105198d1c924e277f130e00b1d1e0d8e2c6b8459e22eaa718599f43f52befdc16786f9da078ed3928eb0060177d7bd971c817d8478b2e6ccff7976f0fad514c8df3aa78026a2b3756791b58bacadd003e9a20c16182700c174cab6b71ee47fe8f5504e2b4f7914c45e2e043295edc31672ec1823daf150078118cc885097ddb0f71ff7319dc13d33c2b14bccefc3600ad4417b8732e0490f8c372f65c076374fb26ccc92be30a8091340ecd7fadf6f04e9858119c17b3e23edf6f1d151b48058b51eb35d905041fa844b35e81d1b6d8ed9ba30e82b83e07e434f5f9a32e447719e73058ecfcc2cae51df4308c1930173d25d952ed8fdbca2c08d4af28a6540b4a51e0c81cf35c9f26967b56814609b90ef1723733433511750b934ce8e9b6ab1953abd5559dd4902071334b5dfc4f5bb19a048258ad0d272ef6a0d06634c0c11b543203260827aa72b23485c69dc6f20169f895c4ac82e502389b437f746553ed777151e00c9b2dfb589e266991e009a1c4079afefc5a43626b6f6182df4db90716f0e915812e0413fbd729c405f614417bd368e1dd45eb605b0a47890960defd216f56f269228a249c13625b945fe7064f2ebe1ebf0a003b4142f63dc2f3c88029ea9590dbd2481b105d633b72cde11c3b234f9f0485bb7e356a4ce64506208ed6e7dfcf5a27dc5a84cd9bf97b9076a9cab9899329cb030d42fc14ce0a4008d84d1599c2f9860d1a6efe974a18c1d5e5d199a8e946b05b98ed01cc831cae66a5ead4f5b53aaa4fff60099777f563e6cb8e0dcac4010dedcbbd6e6ed35f7413007c95a876e6629a6e45fb981a3dedce3e4700e24b51e3c4df87977d45c7c64e719a0ca022087ba44150726b3468691a3a1703876bde2ac15d3b0ac1216d884867fce7af753f8a1bb978bf1c423ce3953064d730bb7b83eb40a47e984e828e823bba8b1980f99107df5c246463078556f6da8a0d4517c194d52cfebb4b555ae3d41136df087cdf5578908fd77bc1bbbadf86fe8b34259e25bbe36e4fbbb447cf0a32049391f647c758fdd6efa0fc86fa77a8a1c83f1c4ddcf2ae0de58545acc46ad028c86ccee7176acdc700d2ad25d05da746591da92e637453ca7e1bf87fb0a79b541644a9255c1cb35e9c6e35f85cf8ae61c9d971ff3ba83f23304fd2331442181199309a28066e0c796f861877943ac36b88f29ba40aef2f326a9abeb6851de2b073b63d81c139b3bf0e9dc130b84f6b7ad58e2a75875ac63a714194a231e0fb387c730ca6daf59e361e33de9ac00b6a27135d64bbe7736e5fcf9ef2225eb6dac8a35dc7bb8950b22c9cc00e24cfe6d762cc343a3594e37c4419262b728400f7969483d4ba0b3ab123d9761ac8098cecf146ff3ac78cf57ee1942df3cd6e79ea98f408fa57a90431119b0ab2963663c476da6d3627eb3f0483e96577b74fd6e3690d515429c2121778ace54777d517b1e2ab2f1ff30e6a1da4751d46c286cf7703f9b29ce8400d7c99b37a57a9fca836cb4c95e397cdd9af110450194bae9da4561685d289db6427d00827584d6a77d61b8474b5d74e4de32c13b166660ed42dfd154777fece1563fa5ec8c4b3e08c5d100d862c3ecdcfdd95d41078f5b5f10b29153ed5b63d10c23b64258731005a129ef5071f412a14533337dd47c44bed9f3f4e850c67d7eaf34d92487447b642c94c41199de97850eba7db078faa6782fd2f42f07330634e7125f21b2eab395f840422ff7fa1d84d4eb260421f720506a92ffb7197c36827d21d45847dc8667a5b0ca2fe9596a000cbdd6bfc24a47f21a89cde45f10fb82eeb701d935f8cef068598175f35afb57b9810e0d90fe5f98427c7944e0cc914d647dd9a23c7a036ecb7efe4f516861e1b1fe5236d4079318f99f19362e2a03f36a73964e1e641b7997411f7f3357346d3ed5f0ccc3c4b7d8bb06eff1949ad294f9b664a2765a7d7de57d62a790a3b5606f5d7e3b7bccdc44f5590efe643e5cebd4c57c4e9b2f1678a59fe510f9b6e76041982ec0e19cf098ccba0c3562b9fe3c3f9104eb1b5bf6556bdafe83ac5b9c42ea50b7fe0d64341228e09e28052320db1069cf42277beb746b47b606099189686af2c32c147e28739dd91a0c70601fafd76e8f063a42c825464e540c0fd2be582614e7dff6c641b6e1dcf13689ea4af30825e2425c4a2d95a9cbcb6335e467bba68306d45f039a2800984224373d4b50402dc351812a85195cfacb8543c20096608b5ddaba71a0ba365767933ce8989508ac311c2b7a3f48b64ee1accb588153703ffeecf8c136a1b0a5b7e0bdf4d50b6679456e23c56f6fb589b6c90f37969992a9dedcbe5e427c71d8ba5fdebf3f06b819c80e334af12c600a47adfc6360152ac4699dbb2e3de10673cb694263066a5c485319c3f4310679e09b372bd840af1e24b457781a03b056ca7e96e5e0e28e4aa5d428133ad5f9b5f5940f9a8d30ead6439ef21e622f76c1b642109fd024cac1be12dded4b7d8949bcfd46e12bd17edacd7e693cd0e3b07648a99526df1d50d42f846150e3e0323a489117c1d7e854d115113b86ffb3c1944b40af159cd54fa2e33d40ab9e4f60f1c88fb88acc5c3b5ac9dfb5197d978aee9c5c9b57e38250c3ec938b8e93fd39489d3704512440b58c3157e647dfda1d35101c67bc60403ef6e21ecea1648a4b42f2b411d4970390cafe2951305fa1960f9821f94c840c21251c03068639cfbb19a126551d037b08862ce20bfc21461015c28f5ef585b6f82097d7dc3b3f4c4bad0c91b65d6fb00b7f7b43c0c0c46248b22530f55d493f3c84eaf022dbe10847a259aed488969173837b4fd7795e975a88ca1f0d84598609622c168ea136432a53dcf90744c46cf28f6b9fd17a436341f960f9f654ca54c8eb9cf7148cef2a0bb5a0f37c5fc14e2238f5cd166fdedf8954c35b4e71ce21bf36c8e9090686021928aec5b44d75821138cb3efa45edcf7bf919b4ed304d379c746dccb18f2c534607d96a8c18d02311326102dd5ef1f843198514c6a246d20f69f581672eae8d3b8d56bb452996660f6abd9ea6c5bbd16021feafcb994e0275e68efd2c91b7349fdbf38e91b64defb41ee3a39c8d2494a39577c6e94a67b444df8574d7758cfe03637a9d835e6c6c33258e836948f3991be7bc1fb26a38f11dc01267d7b1ca072585707d3359ac591187af7376175c3ed9b2d7f97e21425b5fc114fb9b8305bd6b017da7be08b327093364c2b80f17b5ab5668be24c5487d59820f68ed9e8b82ea6c8ccdbe608dc34729b181a58439bb943a0497dd34116765d95d074c12e437b597eccaa1b7c762d244cc0342dcda3e4180837adb8783aa7a0647545637d9657916ec2f466ae563a9712107b11fdf64a2cfe58ff038e59fb475b2bc74ee52a1c9cb6f3b0761c9389476be442e4c2b775013bd4a16df827860ddfe9c45f6cd009dc1ca92c413452baec0a40e88a600c076f3ab3457407097c29434d792190d6bf17eac48dab3fc02d06b2f2a006438897571aa9c270741b9d307aba460be8241a30af83b8d1c94514ff8946152039957bcefc0d40574cd21b6a8c5fc17ecfb6da32832b488c144c4fe0b021af1d3cf9d5661de01b8208f015978b520c4ee747f36ca89031d94b12418fe07a1af7956f3daa144b4bfef9eee6c9affcfb8e71954a1be6fab002c595c5d79d3dfa0bcb948166bff2b34e2091aea8ddac4f196c10f2b59cb5136760e24006b7741a15fe22fbb9b30f07459300dc93e75ab5c287f17c20963c223936858a0810eb273122bac232e9a0a3c904864e89082f89be1114c3bccbfd76807d0e0c286d19c0843ed13933f0eda79e70c19deeb9b4c2c204ed47d0fac99ca324e49438188df1437fede69a1a169656426008a13d44f8a1886f5a20a69ef1f2b2471501184271d4781df5d4829988773c3794116b18f8b9ff85ace397b15b263a328745c43b918ed45eb9a030f971883f4cc0c8723af6e57ca581c934d8f4feaea52fa5382f91f70b041a65baa2fd68f6ce56c31c8339a3dbdc8399a4a80d014fe5a609e0c499cb43b5096b1ae745c8b8083b366e70599c7ad1dff1f3c5ea40aff1cf71615c54a4bfba7d41ab055495387e6b0b7026ad99387d946e31f7d6a9762fba778254db112dd71c3c1d9eaea33e8dfd0ae8832622b9f38e54f0e010f51f0685dd7fd3a79f5aec6acd69d9ee8cdf611cbdf40d8abc5ee1cf390cf9619abe1b49687b38370c9f83b402074046ac3903f32eb001f06d9026f59be398ab2c99a62ae23baa09fac9fefd2e1742612788ca413602ee99f19f3fd78c8960a7eea83afc7d45f93159412ecd247d2a558d22bb7db3f4e75f68b90756a0caf147b473a70c0fad50b85ffa73ff25eaa2f41442d924ddf98a206ee8a73852b63ba13288eb038c7e47fae34a69a1e704e54dfd1a7d495b3a3c617f700c30996d2e7a2dccae210e613ab5764af25e920801c759d4dce10d414acf2f20f03cb943f8148042de2cbfa92eec0d06999981ebb0f82bdc31672a6baa083d0be502e34745d18afa58cb4106ede05150eec5707000b32bd9ebddab762beb81eb1d445d381ea6c47a956550a644f1801a36d9f647a6492c1a85db3e2f2172597a56469331fd3c54988431c99b071220262a874c309533ad65b77c11febede979a6a74ebbb868c008fde6f360f212b3fa2103a15008ecb076d28cf0b2ab4f19820e2271a2f724d965c204830ab3ca5e809d3d8b5cb7f87dd05afe42b21bab7b4622cea800dd5566878a26aa16efe446f436a2b019c1441f17d09d12f850a4b3fad0f6898b00271a89fbc6fb927ddf2b3ed9713dde72d18f365d39189190c4f838b71d38f47469aa61b270d77e0e6b128ac3d2e2f1888da79b11762bb3529145963b6613c0edae2c53f630b0ecdf2aac015d92b7d8c29a543e3e7b9985279edca932d8bf21364c116cec244ec76ec637ab9a558b94613765462454bb0e112ccbe87588aa872fac98d8b7db2e7389d144d0e3f19108a6375a6c7038600f59a3cdb39f21ca642aa7462c53e84e5602f03f89fa4d208a7b2efbeda85d936aaa897ea916a03e14dc856bfcfbbd6062c9a0fcf8b3d7d5587737ada5ad2988fbb71a5317128ee9c0642e8bf289ea0ef7783730e376f8b14fdd3204d9071131ed3f667f209aa136654e6e0143820e82a9d2fc604f2700d76ad6b4edef3035bf92bd6fb44f396e279a253179de42fa9d59c47f4317ff0e23a87eb2bb9713401edda33a542f61b8211d4558ea86c0534e7afff168dfda5710ea93f4da4fd3eeb744ee5ad771b2180e29736a9218c8bc833de94d0550d2d548c4cff62b3b1978661a8b619c73473042705d004a8428d31f3534923478aea99f39e45f24a1ffd81d40531ee37fb8e5a19b7d001b4b8af802d3f835e2cc62317ec01870ffc5b193e10d97a97863ba503b35173f26b64613c3b3910f312201644ecabd973767f06e0b81cf07bb984c92f6e9423dc3fb7a4740d6b42c1d87f204ca4635c8d0ed97378ce0d2dd01a7991dc6a3b2d0dccee023c64be3e6c7b94fce7ec459cb4f04b6a0684f191550b6c2df8d738faa80fdfa81f3b660d5397a61a5ec896cc68791b914789e69c5ec57bf62d435ddda03af6f71253f101fec29f40ddc8254ff9ed57d4fab76becb5fed3888ca1f37cb347fec8c9c4f3685cf28ef0c8de62b6e77579c57d72d561cef0b40a564e459f60ef32a2318d729c0146cc1ec5ce2c984bd0961b5183269508bc539bc719c2894aebab8a6449f86ad058c9df7bdc28ea074314520715a6602fb0532db3ad4e65bf285b95ea658856c2c7be39d0dcdcf1e14a6eb2b2f8d6365cd2e65095bf1117c5bc86aee6e680d053cd163cef87c59766417127840cd7ce04e32a99a67cb6ff16620ff6462168cda73d74154d94ec6bcf7d693f088a90256befe678339601dc196882cab9098435a166707f87d1660a17c05a579c1c788d83e167ea224f72f81b6533740720201eaeffa42574ab80e9fa2c1929783af6b323b8663c58d8b91126c13428c4b0176b7579a8e2cdefa53872a27679897d5723b8d883d83f96f4d95c664af6e55dfe590f1727279c9a950024ba742e9b5ae8e97e9f9c9d6a08c014bff62149ac1e02a4c598f8b6f4bbaa89a865167366cab6480250d4a001d5e8e3b4530413a48206439d044e09779d596509b85b57641d53cff7e91aa97802f85249d379ff62944cdd50b203e526f2d1e7605a484144316e536f2b9dc48cb895c66cfe400863ea44c23ec5e1931fcadedce7fb07d4bf137b337f301f65f070de532014cf4e73ec3bb255e68181782556fef53223029e31fad405e4c511c4863a53f187324c2a7959b7cca892b6e0023076f68c6ea6eb44adbd20874f79b8808f26d493934295ef79c2fc5632d3b63ac73c374f329eb36a193af659e282de2b30f8e10fcf348b8a7fd07770033a612a8f56cf7b329629d7db6d845502638bbcedeccb1b6d792779793259ac085f122579af9734dd1f7d4bbce213f4e0983a9ede6a396c886ee5e929771a1e5264a7c50fb9fbc2ea9a9f98f5a3986ac7793869d9e8a4058e9e2bc2616873b416fae8de75cee8333d3ae7ac6a9ea5e1c72d446933508b446673a97788e2a1fb4904d5554c68800c6e8ef447e64582cec80e306f210976aa67db83457e295b09974ef26fa01b61a534b89ed74c8743908591af45997a2a8a4c8da2abb6873ce83b1a052dce52658c1bd0a0561b7236ecf363a30593eb4d75e3d5aef1efef28ad37e38771b7ff1d854e6bfb3288fb82e027243a3dd8b2a82ee41b9ab624941c6894d91ed57634ffddc9f037e7a4e7bf31bee25c690394e15a819c3a609bc9834e6e1d08308a2d0b483409edf9a939fb023e1d93c753dd1f62576590af4710e59cfd54ecbc2fea61c42b60b648a7f9cba8f9d607ac080921bdffc0c95bf1d7ac7ff107f65012c1cbcbf474fc2a59079ec979d449b81300b283109bcaec278d91cefde1752ec626f12f95de47680a20d6e45d55d1c7a63f73e6b523507c3f7769945ce4459a85ceb1c18b8c690898781b537f75cc081281081c1eb06f47263543f0195e95270dbf11438dc6ea205da365508070e439cc7814fe443fcb242391cfe9777ccb4fa47fa9c9a5e259b622b0b087fb79bb749f6d9b85588a309f66e87213747fc3432922f6d6c6f67e865f500bc438cafba7b7ff94800943d2df4a22448a0d5a445d3991a07178227a1a6d85b1069e849f6a2eb96ae21d91734deec1e842e16781e8318de89f54ae53657afa8eceb58dc8557cbe657e4d44e143de4604f2146bd4c9117efddec9d3693b912501dd17fe9c8a2a39df5f563912614d85e0ce5fcaa9b7ed3f4fc198fdcc5e3dde750b4de3855daeb6f091c29ded0b52deb65125f757399e50aeb43e9d4209d21f5bccdd9b9e1d71e4c89b02d80b12ed626a7502c6b67bcf37908310b0a510c294968d0453c2eb8f50085e2f26165ebc469f5dc114678e31d4ecc085b549411b74ac740d766759d22da75f49cb8f4c1ae27c791e8638117d7ad07d3d39433fc78658dc0ebedd08142268e1ac80c48fd7d6fce478be48b9a08ed7a14e958279958f30bf46dd1888131e9a12bd10dfe7c7381c819d5fc3c19a36e53df598b58efd3296439e676593c521ae518eab222c84b20ae2d97b6d1d20245d41c04db102e77d0274efa6d4eab89365d4cb18650df43d6d1c270eaf67e275737e0803f3f069485fd9468a2346163b4cba370980660b67a0b614ae32a779c2a18c9ae92ff5f2b422f4440c02d053b4b80df3891cb5e0877a76b391726de3ff5708d1ed30a58c7006016928c119916d7a734569ddb93b8a4d43bf1e3072502b24d7e113b50d0273f51412ae87c8b6ae05e62f7363c65dea5223461d01147db241b005a1b868732e72205fce2c90c016b9ef46a4dee2517c72c202e41c7e287722c96c11da9284168433d0b2f1376257afc92b3235bcdb104b1dfdf0adb04be969b34d5b9d7022d1c03f3701a800d96d59f5fae6d10fbb614cad0ac0f91c3220828874a4d9e59e92b9e545dc7754b850100b4f25e4748458fe42040f678407702e219aa28cb2a21c671b53d9f427d3c5253366e334198144835c3e5a475c7f6b6178bd0050cfa12eef2249c3c3c81f0b8241be7563c60727d36216c5ba5ea35743559e0fa73d4b6229b90584f9ff6703dd8f32d1b0543ea571935d1c58557ea98d401251c2f3481b755cfe323b08e5b535a716cda76f3f87ac1397f5cc48fab0aba0e45560443545f19c56334edbbe8abee3bd633def7f6b7de75907761e38417335d5455d8d67a4bacebf2215e58bec63878f2dbf0e928f7bc89ab6df759f2d8fd7dc7fa6b775831a31db8e3f529b68f5e5af8ddae10d57192e7c80a6f8fc39a41d25a2abc0f683e86fb665a1c599ce55d2d3758bc7ca883767a0d918b3f1e7cebf5e7690ede5b770a806f26febb2198821ebbc038821687ceb7398f10a6e2c950539377edb3649be47b3d9d2e51e2eaeca65f8cbfcf2c192e5c0e45d0b9b98ac8445c1007fe7b8923788164c8ba3f8c4715c082582bab44fd0106bd813c8953c039bb11a22ec2b922e218cf33b17550ba46eed1a857918aa5a137eb6a802d65c70f68a5123d4558a905c915a06af65adf0e68aa03f10fb68bfc4cf33485933d0795332817e24d9c07f056d7ed019519234bc7425a34037dbd680fcb92af13cc3755b0e1de2c4aebc8353c389262e413b99a22ecfb8864f1ccbdb847c8d9d9d362e4fb28b452c827ec27c8c9ba23e4aafc9abb614b60d7cdf9f5ecadb90c40288189b8927123b690cb032fda09fd05aa51ae5da9f3699c49aeb1aaf056a8282b4dff19a9e83051c99134ca37d5ff2c37fcf56b3d981e263367e39714617647c1eb441e44d61a59837f8248e150d10bfdbc1a9ee4d6fed151e36000b2c198160322e4d594ba850fa60ff33e2347572c5ae138de315da65106fd5f3ed4c9a0966d2a8e76136b30cef8fbb2acdfbbb59329733486ac40e4bd92f2b8b58cd142f40ad097f814ed9d7b0cfcd3c9f2af6fd6c0967820b60322bc9155ada867a7b18543d419cab0378e7b9553cd6272e772c4b3f965af89b76b59e2a6a610ff571ad86cce3e4d5321e20382d0e972e9d6edb8de5eaaf2fed83f852ced3fe29276ef4dd9ef961d1401a92bd582c8146601d53fef621918c65b0afb39f5acd8a0c29fe60d006f79b5e77c9f6ed781fde15188fbbf1b8706c86cbfa95ef744f3f0cf0b04f933a639c48e9966825d8ae71652a8a2beef32ec75724f82f0e9fc38966c67deeb1a447262bfb3c2e9884d85918980cdc8b2e775648f5467dbb26a6069f15b105c227fc00363d3d870a568825dd0801f97b191733f6e7c75f9989ce3bb6bae0411ed8beee3cef9175fa869df7c3d6ffbd1dc33b47dd4793993067a5244df86d563f4eb8cecfdae2845038a16cb708c44bfb5da7c168020a1123363c2ed0a5464d9dd7e0f8c80d14c43fe22408268e0458ebf57b95f69db20607b259eeb02f87b1a1bcbd9b3658d7144372612e50189aacb8b7015a46608674f01be10b7db61a06f3b7fc6d6f3b4667953fc76e4693f3c9c4bd00a89ba630825cccc51cbd216f24f2e390410f29303d8deb72b81928ffa2e1b11f1ff3247c36b6aeb37e7509a1d11c8ff6e6daf0f530c02cbe8d39975c6ea4d9c16447ec58fa04457ad81234c75f24a2fc7e37184402f8c892892d28095bb9643797c1f8c8232f1910fd46e9d481928a4e0f8ed3a8c38647ed6e17a40d8e8d92ad1228d3e1923b097829dbe1c2682cc285eef49e7a76f6981ad5d5d622b08d06c381a5704de3c4efe31f31711d9f8bbe303a89f3d58529686d92a79da52547c666bc65fbf34a79820bbf250c8a25912913ab53bb3a9376565ffd7057a2b24c039b6c1e58bb6c8f2e60994d8b0bb57a34341e8e0921e88126472a2c9056c33433216cfb3b437baaa43f074fb8fe3441aebce3309ca6924dd03a3650f1d65b14da13ff5a3afbf259f9ea28304f8a9c44e7b7298b6d515ab813972937ca41bb85f8c16def7ed7096aec3f92591882f7f9b650c5620202c9df2ed7f81d9d8ac57b70f2918ef823be5352d907ebe40357e79845f2e1c847d1eaad7ecf6ed5f3c8cb81e7ca047b8361c655885d33acd631f31a0b3ec4ff1982a1cceb99d4beef66d3c377ef569f731a1ac44ac9b57ece17b69f1f9ff4b1bc37d1274a140d3b63afb3e66d4ba1d60fa6e0501f88d657b3c6c80eafb2c66e5a0374a3fe4e42b5dcc7a0972f01aa4281f1150cfc9f22b58afd63fb49dd1960c34a2dcc2ac9bc8da26cc60cd0a7401a83a9f923b67fcc6c880baf89f55774532f9136451b645e81d596ff9b1081cb5c8c457b59092b015c837ef948cf6953b8f67f56b541664a724864d9c68535b7edbfba9b01e518860db31634e92369b3eae94d9de606d900a2554dd704184c59afc721521bcf9d527324a73bf63314cd00ee51aa2df20604e8ed25a54402e383f7782c75b392ce75bc7f1ee548e11f0a222932912812a0692706e991206768695be1c78bd708ce877d707fdd2742a49422baecbcd6cb28d7b46a2178f74affc5068b4d3e6b00aadfaffdd8cfe1592195f528841669b964cb712e7a83153c6b1af3c1944eb221d88319c7470f0099d5d40949b7de42ac72d55f32185652cc43636a5b34b7c7417c491c80e1bef69551afd2f635c21000461bb67dbb3a8c556ca00cf0056b27008ea0bc6e40b824c05312691073566d5a31749e9e65ecd7cc5fb40f3a9c192885fb72d058f59ea59a17e2b16e72a576b08565049410fff93b7623ad5ea856728e3f7e4ae00a5d1f4f4e026c1dbfc34dab5d30b0d39fb3127c0d464be043fedeefc25ffd8f10d85cc857ec433cf6e7d8c709ff18db182ee748fd2325eeffac02bd377314411aeaa85953bb45847a6ff63d42ff6d21a22de35b2bbb463106962adc3be1ad4dda4624e570446f3d950d5cb9bb515093e721ccb0f1b795039c35b884dfc61c7d9cfe841a77a774a2022eac66bcca96875c3461f3d6a3bb1cc290e4c842f8f541852b450ef81ea0e8f27794f4380a05d8db8707a789dbad6bf348915bf8783bc9973c8b2886aa345622e8356e0dc35dfc053cd48334ae164542e53f608c136a88395a0c866e2686b7854ecf98831c026a89c63b52e7fa88402397bbc8d6721f6db9bd0ae2a20509c195919a10c623499de0c35a396866468facd1194fb27216aaaf5af56f000da348ec1fc91030546af30ed2638fd95e7b0baf2c5fcce09d5d6d40605e6ceafc95c0e29db47d0214a6e4a43d59d5ecfc6ff0a047b5d4f3b56363b55ca9db41b964d2505fb4f1846450d06723c8962e27a4a0d74a6813c14445aa4f73148c9e5cceb9f0b61fdff39e3e31f38d76c8d4dc04010234d826b8ea6e6e2b13346fc133f1b52cc7c042e1a4e021ad4301d44532b153cb84660e7c37c6d029a4a3690120c012a9dac7363c35b7010697ad2d328a6c0be15c5f5ac958712eda929c32429a24422cbf12fb2e7cf2e489a980811452cfcb20a0916d8f314404f1b644e50a4a0533e765126af3e28b3b60e8f10b64a89a8d72adb759887fc42977762805fe976215f2f7d55cdac88306776b6a4bfc30d8b54cf6ad428223c1b89c2133ce152d2e0c44688f9b3e3f38987cb92f219718ca9cd97b9b7c2ddf05b6c29aa8815271d0ae6f13bedb36be2a28e7676d125fd3818ea562264b48137a6cbc944f5ca7fd3c194a72839d85e739c6ee7905348d18b0f1085a701f80d9ca4214f95a9712dc99d6727a33e43a42c141a99a1cb8bd6818e4fbe0d03e5b5d1ec654c772953f7573d05aad5915f70338b08dc356930169262570608e3ca8554fee312e172aa2f8192046a977d6007257173b80e297284ae6959d6127d2993cb55fd341ad47958a118c008f44f4e597c0b6967c57d7fec3edc588faa151a77dd184efb72f31d4367a1d01d5e804f9e62d13a76831731d7ffe6e72de7b1721e46ab1f3625c3bed302691ae7182e1813aa3beccc73b13d67bd23c9aa3a8bc9f54a2ccd5878ecabb94a8a9e16c30a21cdf31a5a0b2871330636ac8f568dbf2fade6a960f0e2ae6833ee210fe5a2090d2cc149b5822a702cfbfd9112b2d4e55fabd1e9abfd6d16122b0cf7776f88fc91600b806e2154f2df0a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
