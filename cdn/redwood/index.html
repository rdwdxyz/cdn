<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"17519f411e943dd7b82c982ada825f87c8c6efe54bf4d7d23218d36c8498654a72b37c7e8fac4944ca7a41b7b8c2833318f905f2739d5724c1616736efdb8ac760098ecb4940b16c398b02444af542b15f1fc5d891232e1189984d4d5d39a241f0986d5a116ea67eae16d0d90449691d81b008c5af7ae762d82dd00288cee094c184af32daa3a20f22e7f4c0a7630c4735a846fa2c9a84a73ef1ed8ca40e46826cde48624cb014c0d469a6138d63306fcb5d70916abdc74360087f9470612f620201b3154344c26b883cd365362f70b1f8a8545e03c85852e4d008f099de7fcd0675f953533221aec61167ea73c7d90a7a25730c4b49f3486d191b616c5eef9be31f2c481b005719fb3f4888342c51f344563c2ff77803b8bce850bb15d77fdce3903fd4d657fa37b66bb0dcffadc97297ba0780b41acbdc545127a5650e780fe38083c3df6d3b2df7fb733529b1ac8582029930ac054da5718d823c2a63edcd4f9f146299a7806aec23d22877d89648d4f0310746e27282d8d9fa5c296cc6f275240454f8360d81a7c1bd491e729234e5885a34733a03f98396913683586e0031a7335cf3fae79c9c16f816947a531c1bb0487ceaa254a316c44bc390e3ee7161c73a055779664419a58aa0f9c02048d1ab1b45d73f1e07032d0a07b1a3c8c111922cad5a557b6e2f26cdb90506524158e00334eecd74b6efa9586cab17056c3fc137726ea828065e622137e7e94bfdff096f9d4585a2d4ca50591891caf6b2eff33755d82c1eed56ea9ad6c841a10224d6c1c1cee6b6af236b96f85a22e6b88af0bbf13b73fa3502250091488f1b9c92113701f0e4e8244a6e1f6fe8bc3f4a66d5396b10a397fb29ebf79190ab42fca8b1240696fef528d27268dfb60d9dd742a555619686e900ab5b0c95a9ff29eead7393edf3efb828ebd6f1a6d8906db6515bb77c6259836eee21d11abfa030f34ba01260c5dac0354bfd14aebe7fce391ecb1c87c79a0dd24669d3ff5b5c8e236132b50aae166c14e318fedb4e77e02daf38cf9a1737b8950db41e1282ed6aefadc8dbe49770985bdfd254bb30ba83bab2bbcee3b169a8cd2b3122fe19ad52daab82a709b4613298d490257dd5d6dc3e92102ccb792f15d0cfbdf896c07eeff9109d3632ccd8c066a3267be733b9e06fd8d14433a60e3b4a15c8529250cd23b0fd603122343b84fe895beb3e37b7a8fc97316a5ec1a257950dc88de403fba2f9860587878df58d2e7caaa39e3fb1f440d48d7157710e558e7d51cbd29d4623db680a590bc69a9320212d22f2f5cebaef0cbb0647766e62e533566ab181bddb7e6b0c0a23e0187500090ed66a6742b3486714709d02dbb47c3bea52e759754b1051c94e19d5514c818315aa310465f01cb058102d8367a1056ab709f20a69429257607546c310632e6df3fbb4fa72fac20185edfe9a6673939d57581716339c4184e8bc078a442098f9d240e6e60f4308c1d939fc3697f78d06f1ebc726751c03a903399fa3048f4ee8c6a8b4988df54a33be5a8f684a0771ad3af94359b02889b0533b9a775554e52e048d0733acc1481cbd8c525ca7ff1b91c9707270fcfbe8e1c1354f4444ef852dfecaec57d4cd3e4ec214e5f422a2fb2efdf00d59b71a0cf46ac69894dc3da03a2073f89303a17cf060ac4f2570bfb9046fda011a7b68585a83b67d2d65ff8c2990e27c0b5a80d1fccc038c17ac9345d1e8ba626250b306ccbe19de7fa4319826d22804ab011fd44b75bca22a58bc414523395ab2fcda2912bfe5d1c52f7639b2ff770135fe4b8aa2a9d2f3fa7a678f02608a25893d756261ab249c5b8b60718a63be350a4423edccd2bff55d7e2786b2aa99dd6c93497ee9a7565cbf96bbcec5556f87d81cf7221325b833d5c850a90e155b47b005fdbf1d377c07d1cadf03f9cc5c3728cf5c2266289c10948551286429e963c4909f7008c91c859beeb38d112b7204e3370d764997506b13ca0ecb24db7eb5794e1b7b2e2d9589aefe9460d7020bf993a7bb7f273ead4bcb04578c12345b91b79c8cdb3f38602052ad52a4d64cfdb98388735547ff05967ce152fcdeab09f629f95a9bec8485c9c2de42e156996260127d5df593bce9d8a6ef9b390c6b0355ffd5031bbc0ba6cf167fe7580ee9d1ee36334e828bb811e32899e32aecddacc24c7faef3c4d971b971ad21d68cd70fd7778fd91d633019ffb185237fcbd5ceff7e82ac657681222b5509596ae2dd9acd137aa0ab09a97e11f05651513f3ec795a2000a8f2007eb8c0cd0d2814f8cde134ef45761b58fcfe9f3f4b1ace0afa69201cbcf4702029c936280da25eae13d05c27926cbf7cfd5c6993350891ee6fbd8093661e4589af59174007c7e5cd92c2953df3dd5ba6b615ae2bd7e44008db588fff69f0f195a490e0234cc4baf054bac254fb2f15ba4ef6e0316513326153bab426509b00886154885c32223a9262e4ba593c0cf15ce093aa09732d852e1e2e1e0c9f63873bafaed32a70166d373d0fa71710651d18cba4ad6d95d0678e0770037f408fd6fd78e80fab4d611329cdb20b928f06233b5ea94f9c5745f1dd9dbe0e0824bd16c33f66c447801642aeb61e984d50c4b30209896855b46c87862106622dedfcaaa904cfc4c0dff4a84957150b7c1b1118431cc03d83ef229eaa6d56f5bf0268ebd79858b7fe57722eaf17126984e4ed04a210162ce1332d4d9c6c7ca8d75da3154d9b211e2f58a252955e454a9d98fb44943beebe34feba4f6be8acee577a31c82abfd3e539eaaabbab3be90375afbe15d1433d5ac69f104968eca64f4747ec65b21da1b3803f217932546788b63bb5240dee567047f3a7369703addc3d2850fa9ce87ca0060e724ee42f32f9ce5d9a1cf5d5ce6d55b36af546661faaa4464f605b07fbce856e238af89a2a15051d03d5754b98f745f60a9b59b160dc00e05a678d27fb8b64e17859fed288d6a1ea8bf9d8976385df88554c7084629c2a268dcc766103216c18dea57af9638d2ccb57f30f3c7de4ae034b8400e281beb804e5c8f6d2e11fbc66f750f3ddba214724c20683bf93384806c9eb5c37a3f52168ddd172eb0378bee999f0416c29c45c80caa3ece755d5f6760cdbe57476bed033c346eb2cbb863d608ad8fe827c9dab4531b814221208819a9f379a7291b3310d2bde61001a660baac20a37e77ee46807b2b5a37c834513266083a37ba2c7d3dd289a75e1f486365bb79a92bf08a4dc62d78be5c91579ee108435d10c1122b0a8aa6b11265a3750f24df46300d21f7f5eb6368bbb66b8e9ce881faf87380306a027c7da8dbecc23acbfc79364016d9edf2f37913f6cf3d4a6db668a40072eabc44d73d0879b64029a7f65af9b5b79d4ec41a6c0fd3c5d351f42035a233ebe1e305e7f037f1c5cb04d24f0d7b4bc061500a1025f1a8584c62dde79660cd737c6ed73f4bfd0f9730b330a64df9418ba373cfa9224f4598e051cc57a1c76d58b4f9506d03c6b3380df45a847527bc6fb500486ef7c5e897d3463b05a03a7e3a3b386328059a97324a92cdf3bb166beaa1cc979aa0f20a89033941e06a07c2ff5a983d4a00249bc01a6049b3d464ebb599bec9cbb25cd67b7f5af5bd11426b1bb603745e0fa12af6a048795c0baec7003f9ed81585c945bff47690191be0f41522b0183e7d3d1b6af5ca61834997292989109142c38764e6519dc77d45683d529153c8d3d4f9926897a92509d9c28809407cb8cebd9c5e2cd1904df7a77698e01e9fb84e85865a7d146a2694835fa8f40b29d4ae88d0d0715e83c6bbbc84d973f228bf446567805f76ce11df2ec3b6421b0507bdcf596d025dd262d71378a04e459c6a7585e3f2f679a27e219b716f1be5bf9c1585fad3f93c3921c1b8a27528aebb3f4a284ebf03a89995460964311cbe7da21dce956a18dfcf01021494ddcf6db2340a041c5a5c7ec9db927a47b30e3cc167372f89b7dfa955c38054e9c23c3f5717cdf6297142a7b5d328b56bac45066521c0b55e85f6ab32754f65033a9bdd6554e894b62c651d7b1fa993f0a04cc8fedaf8ad442bbcca6e4bfff6a3ede31d0c6dff91458a526a2bb0d0da3128f73619f0c42b64cdbe6ca99467fe57ef1a7cb48fc7a1c16fcd5f21de29fa4f68595855179895eeed973220a9b2429f9e7582d9dc9b4ac6bf045f3976d3a463244335a6e5ac0d8250a4eae3d575b171a536f6f0eccb08134552330feb2f2d87f7191db2a252fe511640d1afc013787f4f6258d1f21d7925bb9771cd4a4cea2e3a486ffecefa94d249fce13f1bfc97680eef9d5ae68aea717bf8522dbf8f01df6fbd436da676e1c9dcf920e8ec7a1cd3d5e20cc9390ca440c26724f6f482c5ca82c964b163138b7453eac0edf229a170bb0555c052f8b4f22349dc55af7b803417b11925be69b044ec30fe075e818036edfccbaa16c9d6c328f0c5ac27a702c686a08ccaa3289c270a95285e4f3fce37344502a88295ff66f97733551080aacbd2e341d9055cf99f8b67a88f45fdaa63ceaa64a32fe6473089188992eb6df22be00a9753001de141bea1970acea88356d6315d36e53c2989cd9b9e4c373d016a1ff835396b1e2342a9a70a137828cc946570f552290230fd33ee73b47e5194ed577288a7b0e07482ba7091f8380a20b42e811a59f04ad1b2d189049e62377d5ad9a5a9286b21041bbf265cfd5548ec747d89c996534ef1f53cd336e4b1522da24ed2c56e9831b9bee8465e2dc13a3a1f2494dbf6273b5428da351137f67e3fc2a3c5016b7c6f2be425d39c573f5ee160a6dd8ebf2aa4d14d9b73b94065764677829303510c357068c16d74171e0450c83ea08ebfb964f101df8121b8a26fd045ed15a7fa3597135777f8798ccca7fc01a7f209cfcf3f06e864a9cad6a0c97da948620256ae27ad0b2b6123ca202d987a21f8b0378db52c74a6741e176fe290a7e1322a9d2b0250d4710fd13ab08129db7b00d91103d1fc91c192cf059396578fe46ef597e28eb0dc167700acb7ff163eccdadc4b4e22c76976af3fd984acf57860a64d303251a1b9f704b2132a1b2ddbb2f03f1b1cedd65a63f13eff8644b864a5b9fcb1f51e489f988eedb3900204b93ee8e356f39a4026b3945c81abd70efde6b52365be1664a958c9414ee46a0e73b62a08bda74df5a7f327e59dc4e818eeeba849d9b1d2fbad9fefd1d4574e279bafd42f37de0d898b0fa78b8d4b928c2220e45effa53808d209437214799054d1769a68af232f6036d04591f447da6d71bc6ff7da45d3888e3c774227395abd06377f91de3a399feadd4eab1a19fe79d63f7cd984770d256eeabb0b55c3c54318d655bc7bc01ff392309e1c959e247d411dc2ed463ac41fbdc98a8d5126e82b135a636162745dda8fe49797352bce5f65075790d7bacc17e8a2682136f2a3eafdc2e340320a13fee76f1d6670fdba3359853777868c21d3bc5826ec51e340410408c2aeff7842b11d4159638bdec9b2e2cdaa6665c3394d25ed55b656e0903a6c21845122a0b385beb00d25cfa599f9ae564a9d1c47da3cfa55360d3e0c53e6efaf04953c20a38fe94f84ccf9a71862796372a7c62fd1cccee6c0eb05bf4638a601386b76ef2bdf0229e1a1e3c52ed389eac370ca1c7352a061a2cfcfc73c7623435a7324569bbbf137b0804ce94c140db3a985b0ab87e1ae00e8517e4b4c3bf3727328577a21e00be4d56f96ef8226731d565568a7720e169a6004bc85835cd6b46ca97d48ea6bada436c574a3f9e8114294995e9c1249a11b0207e8a2ab372727a80e283df18e3c6698d4480bb0ba5a9cdca5d8f9f9a17b02e4354168aaf30396958d479b1088d13f9faa64a82bac2947f4fa9ac6dd13451e9c5b94d920b072e0b44a830e3ed2bffb8cc5fa0498ad5922eadee3ae44e4dd0f5f64aa4320a0182d71692de6708c34e6dd4260422e6523632de67d128bce48148c438b64ce9e8f9a2cf3cf20e19d43ad8033720d2b7ecbdd9336a78271abed8d0f16d89bc34d0cf3f678497f3440b77cd020ad51b63667cfbd9f189a0f220e838268b1c3e3c0e386437c4551ca8e2e063fd5e0753846d2300cc94a0e0ee50bef54677ac4c45afcfe2897f4bba8d492974655c5fe472b6cc602ed40d27e4a51528864a329725435355861d08b6f96370e7664a38ba5063b2677361e689dba65b98d8f7c9d5eef2d440de095419d71ab2a208ad74c8c3028b3c24e0c2886d285404fd1f9e35f37f99b6b98e975dab338c6e0f1618f2678b23ba6028aa5a7d9b077bd39d47b9127d909c049c86820107dc50f4615f4ec035c91bbf7d549c337ee1cc34dd548fa8d1017839bb7c76e2df3c77383e989b12713a3a20776782111424466a69d3f0130a2a97449cb69e5333624bd6aa82f613d307172425fcece04d99f758015e63d40c26a6a1d234d16e59e98c959dd97bb3fe54458e94a75f91149c7d18430d472c53decbfe2654ec2d4ae1aebd47011ca6e66fc3cdf4537ccc7e720bcf69eddf0308c9ca3cac4cdd4fee0fd02e95c8c59fd67d4e81e2854f919488ea0bbd8a73560f4e9f5f886ce66869f00c9276242aa5b18e7a0a0d9f7dda92f9a08238ccebb23bcef0b7750775567e2ac88ad7028c4990388ccc7c3dd23d799b1f5ddfc31bb450767769dc103bb9f46f010b920b4c80610de6dd4471518222f2908c757e435d7f2640d4db70771c509bae1213cc09a68759335680c74766fd7474a62ce42b9f3405e2013aaef4276cacf1f8e25dd4b0a4b54cb839a28ab46774765b81aec2598e030642ccd2e2ac738382a21eadc1105836686398a62dcc653c2c0a1e66e9eb126a33877bd2840c0e16aec097494d0f247226864e894544f2be87fff87cd940760ad4673ca21d7b1e98a9f7a2c7f9be075b4b98f44580ed4ba0673d4240ac87a6f601e0b2509725c3b322f50b3b707b75e538ff2333d8637f98f79a61df1af27d6168eb4d36970af696d5f8460af3aaa41ff1141802ad45863735c68996e81fef3c08e0611d3dd7ead9272f4275fe6064fc29714ab492e0c9b5e1f097db0844261894afbe11b9f7f84fe96a44db7d76f7ca1469c328bbb328aee68fdc40aa1b7998ed1f7c4e55aa17de711c431a2f2b0b9d5c73744e4a2ab5dabc65477903796dff7cb461b6ddd856898a08f32a2f9b9d447ae430ed7bb6f88b84d1b7eb696c822716009f7636cb8ddb012c53b07e13df0ed813c0a4229ab87e24de28d423dcd2eef5e365a3a496e6ee5aa1021d711448db056a7c8450f34d9ed69e0cedc524f6700243544e29d3bcae24cc608699117cc6ad947b522d38f10244980a9941083d01334634cefb1f9ce7dc6b544af5bbf532ea15003c814cce5263d59888065bdb669a3299349c4fee52dfc63aba387ad2dc18d0441e2b0bf36ed7fbd09c1e61088d607168fc44fa96915a0f566af0a50b99fc69848f0dd8be2f8643e3bf8739272fa51e0188de82ce53b2cba7561ff120eea64ca1363838d1c0eff0dda33a0f7a98bf8f990909698567768f83b4b58b8180ac6f52b0b7fb7dc82b7de0f7708320f120a7b4a6f6b40ede4e29970e5bf193479276a7702e2fd42dd52b4478be11f14706db7cd11d2d96b1839b93a0c7e6d6d184c338efbf0282949c021b94f4cf11be5ae2c6e7116460fce69fd43c6e0e30dd483bc9016e16ffb137a48bff3f35beea96eb135e561fc7ffc82f51dea81362a373f1cd14f9b7be616daa70de5fd96f059a559da9a074bdf9560b25445d36c3946f9f9714c8280049973a8a1e803f645cfc3c53024b1f1339f549babb0cb62cede9e913b39cb4857a599cad6509222000aa7925bd049a185bd9d8838380ed09832045823ace748251ffe77a023c8488809290fe152c076f1e04c3bacafc67f27ca1312304282f6662abbc0cc06723fe851d0fd2965da4403cb150d2553fc8ad007b0c5db1da81e2d9e714a440e3b371918a783b7ced96f875193a97742ff6b9c6222bdb8110fde2fcb59d8a56b96d52877fd2cd709eb97e49660fcddf8af93cd3ea1e93e3c806232d9bf8f5c2b0ef28712fcc30bb99e8dc4c56b780f88b58d703578471f56af3fab095789c9fbb419331d8ea7d868823b417531227f4cd802b1f1ffd71e5d7d5268b737bc42230ec91d7f50a46b8d302bc0390dffd1fd298408a81d6fa0c0396fce364739726c002f9423927e2ca4b09bd7a96ce7643c42b4f09824bb5fd6a78548926dffe3f5bc5c0883a0daacdf2456a3bd93656664c1c13f015a71b9a8ebf617a9c1a8d5945a901a3f66169459cf7a8c25c3081835aab519b6c77a513dd76761748f4c4a637bfbd517eda6a009ea37145c34f41e32d6ce87b8db2d5995c60495005bd436ca28c24bebb285ca9c84e607d7226b29ac9889e3f852e7649101e49bb28c6477e3bb6a2086b809e8ab9241ca0b3ba59de880b88f442a281dd3222a87230ade4a131328c1953db19e4cefd661dd930e3d0e0cce4d63d9ff623830ca7847d046fcac83782a23b16933ced2cd798498bb746d2e30fcc3e3832b51dbf97b42233b085ec90fbcbb1593548ee3c7c9837913ba36837e14ef4707a92fe6e9678e68de0e11ff1265c728dbcf44b918d7f9ff0216328d36bb19108c225cd4ed0d7128f5ba097ebf316992172ed7a9aef478080f70fb620f7c66909a4a57e6ad3f41a81a5c8bf1827df1c3551b52f282e38bcdbfe904de55fed23ff16b2d90fd730bf7c9157713e58cafda97845ed2edd28071ad95d4f742ff418c4a10fa8dda0d568542ec3b33ea5975c0cf3bdce889783dc30735dd3e175fe7e08ea1bdeb5d66f5f16278d46f25c6f1ed906566ded359fa6ba2440ad5e67fb2c208bce4efc9b7b22e708c8b628f14ad7f9cf0c46a3967a7b70af96e3009834d13f535a679bac26ceb74a4b8e2474d9202b9eb086d03dba5bea2dd57601cb9c270c759690cfcdea8b4c806100cff3c5bd507724d3d447e44182428bf60e4a8b488e537b0d8101f427d0d94ab48665b29b219df381cd95793481dea721123afc107ba2da758af3cacdaf6f06fa47c15a37dac7e15fb7ad31af7be17e6869684404d5dd301d51a75f41837dfdd3f73470a6ce1ca66bd02fddb91d9dc413990bcc2a4a5edbbc74dea7275718738828f339abf27b6fcb28932f6dee1c19c7c1e12a4b13d201f0c4aa5e54ca905c5a319c5e15fdd71ca54181f2c3e8f33af0bead46c1bd22c10915a9f354ecca16cc65fcf59c6df8f056ae28674c64051437a826e2cde94b1e6cd1257c00c5dd4b9e05f449e4d117f328a3dab5fa7ac6633a5e4238630b4dbc5e22cfd57493e4a135805825128831ca2f8343aff523a4eb18296b291e0b462f3c8c1825830afe3a0203240b4f06f1ecf6817625e6e1cf62518406c94859224b24822683433e76f1d6bc7f29f58fd8462a4bba77803c3f55975bf075f5272ba32bfd50cf0b16db550b6ea102ed44aeb5099dfca0a59585983c8551599f97ce89dd63f2dd13d2e22b4b1eba8f7c4a64e01809c1ede3f53625d9748458620a84f07e02f1d91caa3a781f4dc761de6fbdb07e3c1159409c96f4a515995f2854550d0e3fc58dac8fc3ce2443df15ba8ee81e7879ccdc9c7d3278fee69baeef6e058ec7c9096e2f8c03f842c825cd97422930cd43f2825e32e7e2909cd5157fa4d1dc34f8713bde2d0a917a13424bc28bf7bf3c1f3ce4e65bfe5018b98a66ec98949cac1f237eb1e5a25052f56cd71451eb82f2ebfeb3661cba72f1f8ff46b4196e01ca6322a588e43746c6ca1029d92ee39f6a4bff8c5512db3220af3bcfb3106d18481f7f6227de079aba8dc3eb977b4f41810ea670d1472667643f4a502a9509179b24e0ad9b0e7fb16e815a2760596ddb9ebafa425070bd349776650f12a4cb2d504328780bcaf9aff501d41650534d96c7c9ca394e9b1d00d76c2639783fdcaa699c64ff19f213234038b3f9ee912fdbb35cf8dc4cb8cf3e0024154615218d5bd8b721acfc65600df3421f9b0d5c4fc7844ba4d13b7eede2058a0f91bf1a211125fff0109789024a1674a7d6996d3e8d902aef2a2a43e3b1e19c54d6fd1efd3a8268794cc18dcfc4f2d11e344f493d52b08f9a5dfe893f7bab22818b1e0505605cec5de511bb6611944d30f0187ffe104d513b3918c38b0b252a3f03007b1860fcfd3f8a5a0d8387a345dc0ffe77734ce2281ad37cbb61ae6112199d5d2378f9bc4d599bfc31f54689dd5e8f4289e74f2768b7652bf148e99ddd8bcf0fcc8e784346a84c12582288263d82e79e67e59758cd739173b6cfbaed71d736848cec004145018d2199befde7f83ab43de25c450a9a20b25ada5da02adadaeb3f4c18f053f0e759ee6025210a365cd419d531034c0474aefa229eff356fa1e72bc7de7357886d185392cc8e8aee6366b12f9e0ef532b203c3263d39754b0b91fe0b607e306e435822e0c6c3d5f185945705928a820b3266ca5e3fd932ad0a705b6f9bb5e66ef4056f89fc173e79eb74c7ad9130be244b2ea83f7e7340b02720a78ad62ddcf363c25ac54887850dd4e774a74d4fc56408fc6ae0e09b490dbed8435a936306be685ffaf5ac9f53a5deb82271c6ed107db8ba2fb2c02f2fc59b4ed8b428b1a29e059ede4e028697a1e33a8d9cd073e3c999b5470ab4c9d761e5f958bbcb740cfb546aebffefaed73f2e542f3d9834ce8446ba7b02303491a6de1393104f4b992fbb9e8f80ee1f7953065dc8981e632f08af0f81d1fcc57af5f3cb92cecacdf6c33a3c9ef67d0d0cab261bb3acbcd8fbb9b458150c90ff6727bcff6564674d0038e8169d9ec1f3cd6e18df4a801225a217007b62459510246e36df42d84ced772043ad40add62697d06f49172d74270b8f9598912cd5381a3661ce8d50e48184e32b8ad62d47afcf7b234560f165a0c937d6c1942e6d463328659a3e43d70c554e9e335ab1231c739c061be1d653b27ae293da8e63a18ccf27238d38aa730867e95662b45020e05be321ccdb696bf3b8851351ef11ff387777b7b90afce20a2257d5c5be668913d830d82c04d56277f9cc968468d4222186e7cf05ab438f1a2facb4358f0831b05ebddb7384b18d0fda1b4168b01119bc61bedb56857a3e91145d19885e0ff74b097d221cc988d7096d45ecd79ae03ebf2d00d581356e3b75f4a02c2edb2678cf9034716820bad9c095c442fd28d98dee90045d356679ade473acc88b05afd907aeaed6262d810cff972bd16d15f67256225f458baaae204e04aef1f31dcd3b38cb4323d5b7de6e6add0f15256af4a4bb213cc63f457d746007fdaeb2694f8dd68f7ee434fab55b77d63315961b1acdb9e12b684baf00ca5502fa04c681280948136d9b0e532536a33e2ded53d820354cb07f32b8a9aef87c52ee8146d3c7c150664c5d94c55870b568ffb74cf7c3504a45e1d6a79e5d6859456f49fea1fce25d57d2e751bb52ac80239bae8a44b32e9e9609ca0efed51a728ea85b26b7037f44120ac99f0dd95ba99498a54e8c77bc9e9f06ebcb8e579508b8df92237d2f904bc3d9c1ceb1352f07712871dc14bdedd7bae56f84cf3627cc8ae27867d73d3c388250ad78a29562957e14a3f46af8d6013bc1ba65c3dbab2d905cc9465bab8528ada98b923dff76993d947af59fe28dfbe0c2ea843e5e3a67506d8cdaea9ec800d3c4f1ffa290125eee137674bebac489234197c586e0e2a9b4efdfb3664181c1776447123cbbb832d6f79e8db726e8f09aa5cf7b541425face13003cd446a37b586f683a58324481921df535a79b607196c56d47d2a597e0b820188932dfc34afff10a26ff57f38a81332e8cd96df26fd8128acb6430065cf0ed1c33f0bf1f62bad428e49147ab07592935d45f7075e9aabe031fce4af17192c51b8ea334fcc8a65c118d0eca09200ebe0a89c23090d276c63cc372e821e7b7cf4ce9558a875b5a90a2cb16f830a40a8360e0bc8c99c6fa1ef9c85b2b2b7d824265159d657bc16724bf3a6a3fd01902e4033c16143afae9be2e68a783893bbc548ecbf110243258ced2eeb964f9d6a21f2218e0528a9947a07119531b3a603beb8aac59c4b75766e59c115ceb3cddc460cac02cd6f525fedfdd0862a3eb49342e09ffa03c47f8364301a3c2e400c2b93322e85855d4ecc9475f577f6ec876ec6bbd6cde36ff92b8d8b297b0763c076dbdea1dcd888bdf42f4ef76dfb91fe20d987689ad4bb4d6e3f08cb82f9413a3cd944a99618bec967ee5f5deca516e43c1816a1ba6ff399ac01203a03c04cd88c960103d15eee67d9ec7724aa091bbf8df1a5092b9cd46ede368362ed1798b04771a74bc00962f49d6b4ecd47fdb0590bee7e4237fa6b77e23b347c50996278626b73148d3ac61d546d39e93105a8c27a61468ba2136ab38b349ebcdfcf5d3f6a0af310fdf307f1f9a6aed0cb79b8e9a4ee8566faa895bf72f2f9174887ecfac32773651c294999cef58b2b444f4cc8d087d70e3a37ef526d49d74f033e3f4d23f619ccc8c6514e13dfc4d91e34bdbda99ff96cef601149f3ded534f3dc51e8b6d0259c5f15c7900212a75ffadfb6afd15e335d8ec15ea8f9568e40dcf2df3b9058677b6d3855a1c38a70577b0e34d4e3d2452672e5b77c33c8e1ccb5b92351ba6eec1fb97591273be52820a2a3534cc3a3c3dabc69a7f6c501b85f4c31b22e48a7fd45ad98945417f25ef1d6050bf2b0226ad5f0999a7147f5c42feeca2b9fbe480020d18cd44f8893c57eebcb397b9ea6205195a4391092d0e5b620c2e3fb2af1ee045b9cc66e4dd42afebac06392c5371b542db236fcce307aae2e93f098da20369f14abe3166b97557c1e502d101d7173dbce7eb47ae6b56ac02ea0963d046d360c4d0a40ac8bf7265f6488b41643f2138172eabfc51d3bffadc6be32345ee760328acfef72394214483ce1d5c53bf856fa286690f58ead4d71173e3e052dd676cd4192567de990d80f1508cbf713faab1ffb5de1af0902725283a747c7c7d9357d2434a794dcb56c0d5a49ca095f38c716a3b27d1975925e21657e98032b2281f6585d35775c00517f6ac851b674fdb099a75bbd9fb135701657a452d86083796e666e2005ce04e22647eaf2cbab43e29892555bf755ecb318ba97fd55822e596eae4ddb04f1cbebfc599403f983c7b3530f9ccd1075f926456907c15c366434b18e41e3593f56ba758eed817341a8bd7f24f66189e27da86eca8b9e5a8ded466eb834fb6a8b1436d71fcc80e146c4fc262de4fb54082abdefc3f9f3f13a738eaf5afc7f216d51a45692df4314799b6d5ee089d15e6f8a9c212bce939ce590a190688ff959fda443ff242eefe640270d0ec8b9ff98a9188d4d0c7295807accc1eefa9c0fd1fca6191adffd2fd9050e1f9ce43b2c56fa961a856bb58ad3b852232989c7b359b32a35442315f566ca2136f32fff36455ee279af2f2bede47c91a58774a714470f536d4466ca3d09243f0de9ce0828d9b010e595af018afb54206ef177433f1403351ca3ff3d5c7642198ce4623369fec963050f461209138db57bb7e78a15e7c400787c7c00a7e675e49bc9642b72bc0127ebd4d23817bfb82020e090fb4c9684ea7cff1b7f3ca3374490800202f529085a0089c7cef2803073073be3f47b2934f5f585bae7544c7067d8e65fc88d4f9a1ba0677e11fd44c1abe9c44f70fcf43b1de9306fcc7dfcfae47dc05dd3f007986eea6112bbf1e3db50609b561d9ff995deb426e37b18155d54356ad2db8d2ef2167abc5acec5a49e3f7f3715cc2213a1d57dad3ff49037119ecb634899b25b9629848cb09d828500ab98c661a925a9770c1075dcd2d33b179d2d6745211e88fd7bc98d4e2048e4a85f39c3c10cb0c80250fa5f8ff881fd5ce434e3d4ed23bbcb02cdca13ec6e55c5e40a085dd4db2299b5f13b31245226d2c9285ada526c908fe60d6dc12adcaa1f5cffb3b78b1eab8ee592dad4e0d42d7b5c97084e5c1ec40bd71a2250005dda9f4e9df9d0f9fa113276f1c309fa978359173ad668fb3c0cb01d763ac2daceb71a6494a66c73604778fac43a2244844ffe3e9d79086767b37037569559a9828d74e49f681d845bdc119075802c62f3525ebcd4365daa1d0c8a6412c4dca4a217921395d519d40a0a6036a9e089f1a6adf2e4984e07cb596c3642d01848c4783f84c9026921b529387384494d0fe6b16b506c4d5b3f33da5ab118ca4dbbccc5d54256773ba8f910b98d54370e710c2aa2d03aa0cbc53c37912cf6d4684c85c5eac3406cbdc162eb7f14f5bd0c759a1561e6cfa0209e02d5964e68d165fb53ce2ee0b1274d2a9f23a55aaf9e2aafd66e3f306ac6147c94dd9d1ddcf853d6da14d087aef90da917fd3c115f80d31fd79bc86c26eb45c2f8c7c553b4993af9975df774ff7eaa172db113e1974b540254bbd1c2ebf2f54d4f29ae03f8609fe0a32d3251d25a681a87f9a6c7e813290c0beed5f74adac554e4407f2442d36192d4f883cbe655ec588d08d09ab00e4de7f770f973434fae95f2e10e8592ebaee8d16c55b5341aaea0420ca9643ff5bf6905411781aa257dda71719eb496f44ebe9506aa73cec93f35de700b09d70ce7e5965d283ac4e45158c57fce00600c395b2af06b8910b7bbc275d967f80078c4b005fd0e2a268bcc97e4858e91da65c7776de8b4b277754564146422ff7e55acadb92844be97a53d394bfed1f97e5cd7f2b02023fbab55eb5265d79722df207d23d9981b60a500a404d17d8d24ede4076cc6574a9f34a39f13ec642489eead4c7f7a73d705f880b5402b1ec845cf07ba89a0999bfe20aa73a9984b8f89c711540bf006e89433c1efb705ff502e7fa55d5672a636c50b2899086cd96d1de44a6557fb5a23b4947ed18a24c130fec9111ae8584eb3134af876e9ec3bff278d4057f97fd14b5f3bbfbc254312693324b765e6d608957ce015cc7f7f65eb037a59e6492e5c481230adab5c0546869e30ce2161695e46bcdc868b13384f600bfe6ae5ac3fc9fc4b931bda8a71841b2729fe5ef0452b9c1825b335df7fd5301ce95e3a0f53bb6db93ab7076baf7b745eb008d7c5abc49d1dd316442b0f4131fd6a5366ac8cf1a616cf31433b780639a3dfa60d8cdcc61412c60904909c96359901f4aa37a79b50901814af60d0d3ab2c20da7346172d55284269fc658b8ea62444c4688bdd7f63d950ff2d73399bedf10d6ecd0c1fac40a948f324e2b6ac62bf715fe4782654b11973f2a8411e75711f45c14ef58773cc69ff0aeafc880ee208a89d971274c13d0d5da5fd430dd6c03eec9ca22673c520fc64bbcfd24b2d819c1cb9d94e691c5048c9f825453298b08f1e29d16624e96207f60ed881c915460e0edd0748666a6d3764b08f8e647537c16b036ed75c10d001609e3ffc52af0fab1f1a48c0e6ea3bb62c683d9062a2149efb3cccc45abe72e90ce715344145ad6c934c20e69d4421b0e1b18ad19ebeb0d9b8cf9baeb37817b4575ef53ba25b3be09bff3478fd3c8f7d46248a300fca883fdf0455d0c1fba179d3859648f85fa92266ca6893217828376d658ed046381f4f8cbaf0e2585c4204b54b152d8c2562b091b60fe2221606826587c7dc56ff0e88f28968e20a958fb9a34e13c4275d5f36a613038cccd174c6154da832b6651e633d7c6064bcf7c90cceea6628aaf1e497ab74d8cf4c7721da196aa0d4632ba7f4a9ff86aeca874003c7ae96999a27526373e8fa01e5f0b5dcaa388672368c674b75a2c122d62cc3b3c1bc50aaac84ea61993e27bdd6c72dc1dcade2f3f2e026ba8748a831158186140deda2802b8f08840c053eeba59094195e279f474220793ca56827013de292226e84e8212d6a44373cf67f858c57428ae845c5476328f1d08d5864b37b7cd92284a69de6915e85acc65a749bc72c9f87606e2700f9805c229857b1c8bc2ffc3fc1da1c9869a521e6ceab7d7fd365734164bc8220cfa611d596a3f054cefbcf23c4bc12ec7604ce59b045829232a574d2b3340ff12dca0ff04b4953401f743a4eb5c1754b3c9b8b92c4f830965a4b8a152a572a3646603c8c60fad6cac5889fc1b847c01f1cdc45ff1003d1826dcbc84524c7953e44174fc056618a1466b502dc8525146375bea15380b977da41a35951f5ed3a66a34bf9d47308943b227d01e5ec3222d66581bc961332e86f776b047f60bab2dfb3e2b6753a471f0fddc7f403f0a3fe04a66060d30c364a519d3f100078c05e2200a58207a2146dabf4a0d19104e8be62a08ea98eed5ce073b18ebae61d31daaf35b04804b8ddc3c79dffbcfbfbc0df192538f1ac7d6eab1d54272eb943789685ff5086c2589678b4d7fb5568dfc3002b5e0e54207c8305546ad73948f860cd5982f6cbaa4b4142f6469fa70fb86793082cbbb49031c9b7baf52c9979df0b39dd44daadb3c39173f5f9f7914e4d392287da04ded85104c438ca27f2076a82a296c0e3835222f72f1e63213cfe690ae1110d0322209666e78acf0c8c02d1365294be0c49ccb9ebdea04a7f9faaee1748816c19455e0da83a73d557a905e9f4ae43b8d9178a19d2f4d4b77561c5730b4157b8adf8061696ab25acb7a593e94a542093fa0763b9867324684d62c1d37268bb9ec320574b35d5f4ab64afd47770045a14c931405498a0421900724b764978970adf46b0e13df9cd30d2faf24479b9dab78650d4639ce8d6786b642a8f53d7cf8b489ece0ddf3c37b6136cfa2ed2f4e25b1b1f09029d0f47bd9c2b44560d55b537d2aa35375acd1db5d91c92c0b2fa42a6881bf1ac6f3ac502cfcce69936784aab98bd988c8e4dda5f742c705bd990ce99765755b3494082e43ad4c98ebe8e1e4c71ee3f6d1e51e7b2fb43e0b2db7a6cae102fe9536069683463384c2ff1f5d30e02342d771865e3e92d6564df745f6e4a5f4d21b00bfd8c43bf9ee7091b641c5e94bac5241ebed3454cccd90ae446954a2b2ec8a8435a13f7a8f18c039fc9fe8e733974b85c8737f61d5550ccebea4021caa1824272d1b7a2badf0f07e8869b65e8773c6971c445e0cc034ddbdaebbc72739831661e30c10e9e15b118a1d175c54c28e2451ff8cbe2e186c0f64d0d8c6a24179308f1cdd10ccc6efa8a1f23c6d9ec9149cb0f4b4bfce2cc7b681687605979ab6576dec35dd4c290e1c502b72244e8fd725bf99726a7e9b3a39affdb2345c0bf3ccae00ff6b3806c5859616887c349c68c316b9d0418dfdec8e05e9318ccdb29bae44a9dea01d0546c2c812109d2b1c52b83b47e2e347c172486eba406d4a37bbb8c8b7258f533753a495fd7bde627e42f5387bb8edd3393c7fbd30a9ee600c49c6bb580a8d8379e0b01618d0dab59ed2260a456b079689933122ea0f16d19988f1da003452c2610b0f8530998c560a5abb5bdc7bd70f9ce66538ffcffa55c066f119291484811b478dfe58ef173cb2175ccf573baddd3a2f086ac444d8c62af5db58b3ca7e29d2bdeb86c20548941532e5bd7a10412c2a1d3f5fc496cd9be544c5d0e6fadfbdb5fe3ba9608329958d079ee4e7b7008ce26846713411564d1eaf78c812c1f2fe8b811a8c09873b8b05cc7d8ddb2b1d694f535d31e7482743387e1997e5a89860f44a44c577a01331d30324ff860aaf135cac70a3cc49cb6076150a7f241b26e941071e2de22e0ec526b66d217549ac849f9401af9f130d0659461360037f430bdb9cea5a88ef9098aba67de80d609fbe8cf4f079a36b83b075cd8798656f675df18578d40db549bb90ec6764c6e60dcd70a7eda127bbfc35b72fa98eda7ae5c99220c1f19d283debf33936731724a8b3a6b419a521d3dcbb91e541a9fb7830f1ce257def2fb2a8a76bbbd933728f51a82f5027cb4ed12de49a1bc9292520dbc53a838fa438cdc0f35b8baad6fa050d5a82fe82f07b66bac16cb0e7bbbe13432882b73749957f17f18c1dae343560b0b12b1abbe2de0b9c11a9b61bc44bf6962efe36f431f9ad572003ed3d1e4eb456655a70198","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
