<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3226cbc39b6906a65f2d66204feaedebb6eba376acd3b0b527606b66656f31e021168cb1e027fd52092296cec465f79db841a9a193794ef7661d6d341f6c39a6588002c7548aa356653015c414dbd54773555ad0529ef9e83372f03064e78059bd3e8cd7412b11ba2578eb675cce60dbf99cdf91cda563735bd4b0da3e387c2f57c2fc4e6275b58e9d79e2b86ce58e29e9b38df72ea3bf4dcc01c548a9e41f59a095749d8020c11b752c7169cf871bfe1ee08a1ddf2adce4454970bd891fce5ac3cae880d3dd35c3f098a88f841f64bab7dc01ea144bd13be352f9f1a4e04812e57308ef193bb530d20f50d2420a3da14971935e55ea13b46e9a0758f1f8f5ad8b99e48bbc64d46019c6996fd1189cb73e8bc400fc1e28390cf897f88d10dbdb0b4c217a8ed3fc7dd773f00e0a1db64a65c923c46199e36faa177caefd55ce283e521edd09fbc74498ac373c2d4fd3f31a284424d1fc7caac238d9a343c7829a9585f0318314b91518a1f7e248641e5907ad0325b72817809711339ea4f4b2098d09110ab527b597cc0a87f2ffa23b197166c4fd515e6fff6b5dee218e93459959e71ddbc4329c3bf2e537991a336acced16e5343c9fcf312931e2affd97c6f632529dbb00aba463d4c5bb554cea5106762225406764d45469892ffcd35e0451fbdfe82a6c1c8c7214ab545df0b5811efa122341d001400c2ce2ab9864f0335f24ae67bd7996134438856ac4b4174c3c3e53d40e7fdc3325c817a0b956e6dfbde8333d5503fc093159fe2f91acdf0ace93420af58536d631c2360236de629ee18d186f2b4ef8159709d46661abf28868f22488be0965c87dc913d6feae14a58f54b28ccd4e69417c1127a2d6853a77c3cddaf28e5130ad1068a764a7671a3191e1c67cc86c167cb6cded67519c3d51ae07b7e145200c76e02c78d8ee2c527128f7c3268d83e0391ee903a8c358a87a7a4e5ab45df160121a688359c90593485f18c67df7cc9629ea1148fea36fd28949474b45b1897de48b162c30b0bd9c7c6f5d8322705342f75a7dba1e57607febc83df0e978ba378d079ee3ea933932368c8c20a362b01c7769d26038f84bb27dc5430c3ee7546dd3ca75b0e140fdd6098fbbc6f43f7ef7a7044d8307c29d1e092d22a0d1c23bd0dd2fc33fa7cb65ceb799f23134bc2d5d7fda3ae8a6c22aa5a3d97ac952c4a65b422d84d20b9e8111a24f88efc4c69b028a4cad3a6800bea4d69d6780ac7660274fd7e3740c6f958b62ed1cf02fd071e651a54b5a0230ad4b884048e52c02c530fe31aa7b8d8defb3545bae4f4d53fdc2a37e23173dcc72d0110e61ddd86aeb1d76cebf7557879d62c85e1e3f84c126463c5cd96591d57b8da12af26f1427cc6fe17aedd59d321841476c6c737cf4ba7d99ddd7341ccda62ac6791b2dc447a25dbd3630cda4393b8f051aa8df6310e3a1ed3846178caf20f1d28be0331fe32f180985a939c2dc27cba926bcef5c46ed3cf435e623ff6d924ab7e25d686352078f8480b209dc1962e7f5ff0755fd7d52a77dcccc55211b846813e37a407f786f9e9b5a2757d267e427e7a68cbf20773dc2a42db20ca31be45ec3161ef14725e228d383eda0a94237d574779260d0081d410f150d3c38168716d3dc19affec82e2fdab95196b9be8efe5775c1a3feb5e47920536974204ebc1d1f5d6848d545839bc0351da57b1f9b753cff628b6fa3512776c63d5cb65ed2b0c61a66dde0117531980dc3de073119630cccbcde535fb7661afc5e1d1a3766529dfeddd261e180e9f14a55947228e1ec83b6bc85867f3c79fbc233b2f5120a8ee273629608dc45f0315dfe8c1eeb0c41cb8285cfd12b513745fe80c0caaa06c9ac3caed5e7c53f9536464d9ee5dc955cf0e3d966ba8dc8d99842df98e8fb2cc15eadf834291caa8f7e5b626b3f333b800da7c82cc7d50f2eb8cba0bf7a3477eac04cc8833185fd266d5cd352ee3447353895a96cf1022d090664e86d9704c72381e25fe5a2e112a5914848b5d53c4f5a71d5f6d1598b44936f7fd57bef1f9cd75016e2a005a2b7ed1686a95ca4ae923f96c342e98a50ee9243e22baf5374166046ae9f42d7e59220e54625a4e6b65d3602ac25dcba1ca78f862e12fb9b89776141f96f0ce0993f0e7699ec696354d4a215ffc3ef899ac64d1e19232f1f9adb05d6b0c6a87ebcb29b11a26e6cec46dcb975a1e4cb347027725c5dbe52b5c810eb0e39e9dcba95494eace2c2df32ba31d78e17d53f3dfbae3745b8cd2990e0b1200e4304e506f41195e14bb4e8980fe758f453984527c980e3241c10b62f2aff33b376594ab93aefd84e779c3f6af9af073f609bf5e57a24f8ffc199494d2c54329d5c4563688cdbf6c9c0db585299d0cedda1ecfec3475eb8d8d1973b5c2e7b5ea726c2cfbde63a71dff662310cbfd280be88d33df853706a54ef8002a75bcc438eaf3c2a6f9d34046bea0fb68ced45a473334ccbdc8e56f5b496bd4fac73dce97b8a18c2ddd9ffeebda5a37867f40282b51450fbab3732d293c58996421f579863476803fba9640fa8ae2b4f44c30c8e043df517973301bcd0d3a1cf693fc3379df13b2b291b12e70243304d0b27529e54439456418d8ab5ff21aa1808a08b80780137fdc969a67036ac767e1d126526e86f289466a2b283aa66ac317c95585cc2b48c168f5633832688d5d0e31e837ba0055078a4f212cf7c512c98e089a76bc89240aaa2e14f7ea2d564250303a29fa4235edf029887db683171e85124ea1fb93209e14cb552479efb3b2b8915e34388a4ecd0304d661f55952a872a35823ffbdde247e57e9fafe9c75f695d7d6a128c0364ebb17556b454c0392c5bb563a3a68f8ff84c64799738f75e18df325d597d1f608e2f7387f9ba3fab9919a3658db3a74c844daa176c4c981aca1a7f0bf1b42129416c92ee66afaf70655d071116668d96c01714ee793e45c12d1faac6903b2ca614338fa42bfcfa25902ed72251c7f7832fd24740d5022e071b85f0f537862d25ebb258089e433ceaa59003a0bdd9588a7ede8d60371d4d099f3f467ee1716c627d5d10eca72c7d9b91d75eb7231e234bf238d3eef91d7e845be4f040df51374163026f7e75298697e32a9d7f6e3b71f26960cc3f667d11ac335376529f613f9b1d4622026233170829e9557943eada4dbc25616f42d5e16795d61c5c5b83bac1453601912732481c28dc57dad60ade5ff72f7f1487b2c0e92ed412e4b8df8a0cd525887b7b23ab8147565f0792a562dd619dbadfbf457171f78bb12d34f2caf11e01e8fa229b36f356507062e5eaab83dcbe357f821ceb0a1d32e1ef75df1ad62b533d49ed1302586610a059bca934e67acf2ca6f7a3be51bd6282702d516122ea5b02e65ac0b99f510d2d7fbd2fbd52d336d3cd8dd18a4b3f69dd2768c158c3d5d7f47a691cfa67573696b02a48b1a855fb7c51577a3d5f46c1b7a7d0d31819b9fb7115d31825c1425003dc5a7edc43f76cb3ff6aabc19d2f08a45cfb2babeb125c6d664c51a8f5def096e9479cf774c6c152b8f7cd33a18d49fec2a06d115206876600d79b4ca672c94a56a80cfc812c7cbd134a5bf88820c6a7585c64d3ad61a316759f1aa6ee6b360100380c0756d7df55b10e2e921be5dfb576f719f33c23d1d72191c9cd8965639456f768e24152aa9a76e77ccff5cd9edd803b005059f75e7e353365e9e227e298cdbd8744d46ebaefe55ef4f875065ab88071c8cc91c536979e5692f1cf457aa95ffdfe794396e8863899758a75966b0e80a812e8281655c107416e62dbe020d46bd3652bd6b06f5c9517e93983058eabf71ea053e44a5686b57588feac379f2ddc654909d0a772a2e605e2dadaed592ec521681a283ebde3583a9017cea7f020bd44c0760288afc271f4f21e9edc47eefc6674cc269f6bb11eb92d718e9129e965e8f74fadd78e2ed76186be20a76a9c88073cc07df95b2de76ff37506a23a82a03e87fef3c8a876f160b45eb419d6233545def1495f70c78cc27945403f78dfcd9a2382afbcbb1b77825ef1beae159cac23dad72431bbce98d992ab3e92313ff9ed58dd905085dad0910d97bcd3d0f518616dc891ab3b245d78e0da6710eb4b1e035a21ad1e2f6f7e496f48991a37d4e1f09b464d613480fa77551a11274cb02df9ead3d436c2d3ed4e46e3b8b967b6151198e8e6e8c62fc3297efb155044779cc86c54ec2b68fdca6bb434e96f9b7ea4259383c18805a4d27352b7007e2dc6fae91a32d1209362e8610fc38d9c106d1dfda5d6f16e44332d689d17b35035af609ec3e60ce122135905b64ea9ecb5475e1d61b15496411aa4f677e3386ad64818823f6fd0a211985edcdb8a85539c421f7565fd22c5740c4964185ea63f0ac28c0294a62c9f7793c553a1bd3445c9296d9e4c9e0a0463116bb9cc08a759a46820d38afab4957812ac4159d75e69292501cce92435a708117ddb26b8c392c3b19cf931fa4f9dc817094012483852115bd3364d36af1526ddff2bf79f9bfa6b68b6e990a9efc61c2df9fdd04b7d62849e78530fbb08580c1f9bdc055271ea82c4171085f3ce8cc814e94bdbec43bed3ed8c3ae8764a8f517c7d50adfa90ca7e625fab6eb31f34e22e67385343ef7e309741819085348bbbb4c5de35ebda16b302d064e467fd49edffa53bfff0f208dedcbdb8e658253cfd65ae2104e3647ff33060357e73ca03e263bd2c3656cd3259bd421f1418a8cabb93a84188daffe629e6233189ac075873ec1c7c2e08b392fe484a45b189bc22d2603c3e3548a182cf5d713f8f33a3bdc3ccb536aa7e490af94ddfc8a02d95e52ce2f095062f53b75b5fa08109709e5c9b816bb23c98bccc3ea4ac2b7de3cdee7f166994951b8e2cc1ee299da84ebf8e9b543f459942cafad028d478e9ee54d70c3dfb4ae87e1ecdcf190e1efbf5542f0d71223c8ca80b408c973422f71f798783321b3c8a4ec8a2b8e8dfd9afa25f33df208dbc444d65e0e30ec55d6c8c3590e7ce71568f2cd78a91560fb77d2f53e160dd61705b8c802f016799b497438dd631b94f603e3e8f648ec6bd2732276207b8bef8484b4fd6d29fa349f55f86f69e8a2f5285e7468195fce765ca6b27af9eebe3ba3a77c8814b036170b0378a822f3d43f50ea624dba27091b57db40ad4034f0b4756baf7c594591196308d9c670072396dd37fe7c0b0b666e101b400f2e6b2b2016f8b6e8c1394a3472b046d8181266a75c96cf8c358049449d8eb5a9ff59bd772cb947586f18461629f9645a5ed90d3f4d0d6c71b9c8dca2c6aa91477cc582e522d4d544ce1eb70b55030c4ba92381bb68c642e997b75019b3a324fa2cf7031f13c23966e7289f60bdd406583e81b662a750f818f50fee58287ec6c6fb95286f117e0ddf6f9d1d58f3730b9679054cafacf8a03f1b9a7a6b17964827ee8fa1feb61c92a23e88323799a9b41b2f5b98a375341c36f0b8bf31ed1f2f3fbfc4da6e33b814dd0bf30171faac10d1520df19f23b65024b95525aba29c5299cf4152a2aaf2549befe4f36f27bcfda057b26e5ad1e1a074fb4e880d7599284177eb859e19d2643f79f9244f1734181c01757dc89bae18b8339fd7e28638b36d312683c90b2bf6438184cf31af91865307111d65d66144c72f9461cb6f0da05728f61d576ce8d3a7d4e30a82b844eb6b657fc78a7146a5a27e98bb4c920a4909554a25e19341447d550aace8acfb7e80d74aa22f9e4d2c1b6e200fb59a82fba8ab8727205be0071ed0d90a1652f4827818dc253fd101039cf26360a73b72a564f2b6dd9b6a534b993a79621eb9de5d72e60940220ee3510dfdf7ae587596a44c7ed8a80905e9754cfce8923ed9d39c9e7f8fb48b581ddbceb2b0e4f4f54cf63c37464f8d47217bfe813e58fab8457b71a6266c3282156afdd291610dec16cd0a0b0987b504ce2ed8993770caa1a7f5d6464adf67d47118fd2d63e27d1f2b2a38831470beff37de5d36758b09a077baf6d4b20106f8752db255d2eab944aa80e9c0448ef855cfefeade34fbc3e08149c476f8515feb96e407d71d11fb48eb0615fb95d2cf414cfa8164ff7ea01274b35811b0eb88f735a0eb0a5fdbd37fb901c9431a489fdcf8c80a57b01c7cddcd397abf8e5f5f645aa44e5d5404725bf786df53bfd088d95b6c32c890f1de3f612c75b4e3e0b9b0525bcfdb2c9730ced2e22be054086a754efae39db16f79c5712e55d71b2deed8f2c20f261467e3f1d933e2531b8395e76d88cd563f684dda765ae1b5b94cff07898713921a75467a046c748f4261884e982fcdd037bf9d62ae8759d97e4c9a1899abe3e98379236b1859d9f3bc10f19909bb05412095ce12b9a6d7532411c29db242526737cf00fa2aa0059d776abc670bb0a7775387d757558aa2f4f88617fabec2e692d824c49cbe15de39a379f8fbc1ecf3b7833fdb77dcc409cd608e9f5e2cdacb3c6b30636eab51bc4fdfdb79a756f1206fa9e248bc00734723b4fc2ea6f35ace72fded2602c367be9178fb8b0193fbb237413512e52515321389db667e05656c64fd5788a8ffb918af8b6484494d863f4f455665eca34eb0a9bff8c5c55db7a9ee0a6a58ed644a1c79e9a2f4aaf68dbe2510162ffad282ae09a155719468f656cc0393f48d51df231aa1afba078df88a997d305a8c10b22b6754abdbdbd2441a6b2de7b87c8ca92e8e1208d8001dbcee185e0c6c1825322ff46b934ae69585bc3a9c6a504b69a61c62a91bcce52a3391037d36ee74077223cfe942bc5fc8ee76daacdc5dd27efded2d4c2ef30853703a8aef0a4a582989523e46ca755c8da7afb47ce68e75ab654446277a65fd1ac2e9f2d5d60f8e7b0e8e334123ed479b71377811c0f073c8ab1c8408c5541d0d0fc49b2df5826942c6f0570d472d26b4ddb659a3829092a7ec67f309fd853d73d34af1af80807f411d37241a2653a586ffba4b5fa856e20803d823351e2ac5ca7512315baf7beec76d3841f4efc07af685eb638d0adc4663e404bf7495dffede9c27507f7cd8b72fd79b9afa43d0f07ffd02056be30264fd8745f89bc5858b29dff056ae9dcc094581d38fe846ba82ffcd8429d325924c68a39902d2cba74fe613a2fe2554623ed7ea7042624f7de250ad9871d87801c0909e4570eb465be513f61899e3e19f25ddf25ce1a4404f0bd2798d7f97a6ecf065fc5f34221bc5ca4d48fa0fac83f83a4d4cdb75b7653d9453b4f225e7a5e88242f24cc0c9b75392abc4f765622c375a114f902a583a99d930fe1a2a6079e17a573e839bf14e57c5e16e05c8594b0ced25bf31f4abf51569a34bee1a6d5787cc385bbeee7d014eab7725edb3e0f337cc2435f324745a4ff96cf76da9b9c28c4f4ad81e506baf3dced33ea482a6cd9316165113dd2fb60f7d36442b1e7ce1c30173e2012e144e46b4f65e340f85d8e515e89cb9e20c6efd8fd6d12536ee8a64fbb5146a5c27ca401ef6219b42707629dc30babc5e21980d1990fd78861401484fbf8a4f1cd8eddeeff2c16bebf064b1a275b5339e0ee4f18590a365ac69f32bea45bb32b52857cda65484f00ead92d5cf08690337a751bd81edb8da779db813db0c1fd59826de9f9c801156c3e3330595067407c7236a2c327339dd30393d3b2ebf0fb3585c57acea909e01193b1968bc7acc82c2a7bdb4ccdd84ccdf6c314f8e6be3d1c09d0f8750bd7e8515a619f0de2c5cf198afc6a93fd1604bc15ac53c65868c83b3d2191dbd389bdb497c2917c23f998e2345bbb0f5e0f20f40e5f6016db6fc13da2a3e7668edaf7f182ca222716ddea39c1f8ce7f97b2eeaae8e5f470516bb603df0f453f2028788b86b348f85b8f2ed81750a406a5902f15991d7637648ab1435d118ace154ee6ff368a2f6ee4524b558244df4e82ed16d0dbe38f63f1e5a43f1613ca7cc056a0f411a08969429d3291dd6f1028a6d1514084c0f6ccc4465a9c70c82023717ca972eb61fd1e02b796b1210e15f8cdafedca46196b3d079aab75999a0e6dcbd156405fd4edfd039d1488324b9b2b04694b790bdbf6561ab1afb1c0c60058e3008f8635f6efec7bddf939fd33cb89f29d71fa46b23e028fc54e9d099e84a49dc549aeb47ab2be8a710b322c3f2c31a33b2f71dc6bbe574f582a546d0a87f8582f8fdcb926737201df182c4a7dc29b2725286cc7f2c3bf68e67a21753be177811d3f154d0c861fb9b839bc6f5d274e852db93cb283318fb509a31b8f19c4f1ad88346340f32269ee9498cf2a5f4e6f492026e5b134b59e1d7020889f12f33f7112bcc6935ed4942ef347c0083d858d6de221fa84a7b6feb776586ca63bb8079825c5103ba06a1a3f3159b1a4750739957548211f0f09bd1d75d6338b8b7a3909aeec15fb6f905f777ed01b3f99e302f02cbc48ec2fd8b74035aec85883437012e77e6e3925478059b60c3177a28b9ae6f85aa7caceba448b9b91d122ba6cce4a10e585ddf2938789d9240e3e709841e2288f475119831bcf39eea638f0e457694587d25bcb91496d9192f94db0515bb96e02edd85b324dd093f0e53f17c5c6a6b5b575a350ab6d91611877e9982b9378c5b83167310e886472a173325021ec4a5fbc393df0a6d575db60ca564c44131c9fe24a3cb4eda12e973f26cc9b22852cd0be0be4f2f4f66fdeaa856bd7696c8d68f776b1d7369a71ff15300f2aefe6582bd187a099459564aedb27068c16ce759d0af3adf90e1d07f82a817d3ed88dbc138549de615e93e3e42de39aec78f661ba704dd5b360adc271f87bc04614b9065dee94dfc4cb8bae77edf579acf2c537048c5097b316ea56cd7fd93f8c622c65d14413caf2c2dbef19c7bb4f26deb22b76d7dbd6fa75e0d633efae0e06c1e4e03e0e42ce9c4ed718fb8246f89b36b78e4fd19193b9aafe6ccf61e3fb518e41a574fdd9ff28a999575ef0be5712ffaacbde27179720287be3c88e51a55947b2ff8c5975da593cd0e281dfa109f1014731d2227be80e19ad94e977c2d497048d5d6c0076bc89a024ed0c6c431fc8f7761519b61f3396b2b8701ccb1e780b45cd09db9d8182bf7585ceea47214ddf559492e9021b8be70c88ca56d75d44d441fbf0f75b5ac8f2a56d869a6579a98ffc3dd94a56915fbfae21fc5ab77f15751d08e246489730bdc05b2c8ce4e4005c22f50c30455be8dddd14c3b6200133e04b1c79938f9fc74fe4e1e7eb4cb6f8d9ad74dc90e97cb9ed1c3370f59167849f2cc1dc0b20936d51e7c8e55913076b70a3f7626924e60fec9b2a0c19316fd8d4d1e9d5043a32006d85c813cb24fd58830bd1211e7c2bcf8e019118bae31eec9b671f7cc1bfb491939a5de12b2d7feeeae9ec05ddb4876d94a50ce7bd66977e8df0684740afd86d5d2d8b35b796c26c9e39d5f2c5f57942a86685cfc0c04f3fab83910912ce1920182e8f318088d9b8fae97cc5a51e5fbfdf7dac6ec05ebfe943de6c8fb68684fa1539b5cb199487bb1adbbcc134e16e6e3f34869a8bf1e4dd6c8375305e19919dafdcf22da7f793263c162046e3f5846fd42e6e86a72a0522fcdc3b684a465eade9a7d20da3e5c67ad506caf6e7b7dfde93e0710335ab36c79db4501491ac97938f96d3234df26c7901767ba6f77759f0adcd417785a350ea7affec43cb44cad04067ba4eba0c501f1acd198bad11fbed715644fadf6ad388752d75d709a7c57321ae63e066bdef7991c2a757a5d1821dba881595af6836fcf5e91ad3d3eaabea2e9455fcefd128ed135cbd49f444e84d5413bb76019af901ae6fa2d66c60b7685066b499a83890f02143d32fecb6ce81efac0c611a316d568f064fe4a330ae7461392b14c6226397c7833953e5703fa91a738f3cafd10d83deb906b09f15b5a938c8cead7aeca84e0c7b7929088d8a11ac6d75efbe9d6d097a128001870dc0ec68ed34e4813a250eff60c818d0ad83e86a5a96fee47d927291936ad18c54b4446d3dc1f3eccd4a597fb22adaf5c60909a08a28ae6ad79b6fb948edfed7263e7862175837ea55ed2766bcce50a52fc85075ffddc4bbfb17b8fb1788f28a5b9ea0cfcf97631373ec038c0371e2a9889b9af4c1bcde81a525df72c9baf5f08b1adace6e3d0093e1a789a93b34d0cd836c016c35d0849689cb3e4a1b7a809398b1b9b2020695800086eb5df6df7fdd6f571861a2b19540025adb4ca7d931d53301e9e2b84cfcaa26d9fa2ab018041f036f4270a961918f3ed103aacf888045d5b9550b5e8f510728e71dea280dc81d0b8ef91c42ca5fff080f44580ad07d984a15e4405ddb5d121094d05a0280f04eba3d571eb6444f85870f0e4678420fe47ee6b439ff97ca3256456b78e2753b02191870ad6f3df12f1f4df2518f1586a3167c111fe1a574be6b11d647c7967ea1483169d7e37725963d8e4da98b312f071e9d6cf39320c019c7daab087dcb01a837fe0d9c4526b86236b6c4f1433f77a5865bb52f8ab19f2ac811e6e918616f1dfb46643afbbc5d658fa47ae03a888ee58b1912a21e25e2453ac592fd521f0afa50814584b5cbb0558424219e712be725f15f2296ba03a52dea6714060171d1a4362ae1def822e5f8971746074efb4e0281bad7dc6c257d66cc2cb338aba6b50f2165ce343e46eb3f6bf2d42b3e4db2c2f8fcfbaae06b9756e72954dce4e89f0439ec5f564ffc9be9597467ade4b5fe560432ac908b33e573077b63b887dcc66d2f7b7d865585b2b8798591a3d3a95816db5d44257e532aa118a3a4fe0090a766e75055ff7b01823bad107ff3ce40cfa7bda28931cf51d5e52ebb6ec791ec387e001b365eef369f86f852a5697671d09a95764b5a9ccacfdce18bc110d001000dcee25fcdef7bb96c849522f49d8b46c832e3bd76fbc691322c96677fc40600e21919d23b8c895cda15bc2bd40182d6417f6bdeb38f5f53d71e113e3ac19f9dc60a1ba99ea954e5a896fd932f70f26d0e9efab4cc5f6ada7d3dd01e197bd2e96df16817a8a2d3525a8b0f3f3c77197ccd12397159d0c9e73c816d42fd0fbf404c060882d910801e092ede96b025afd85d6a726b47281b95916c6835f9005dd7af347d2da5b35fe179d565d116e03d85239a62656b8183704cedc44802b84d0f840ca6573926b3f690702f867c36744879f918db7f3fd68671b8b2eb0fefc689cd04bbc42e6a81436a69a5d54b7e17d787f6c691ee5402a9070f9d02b556728668e79080f97c6a08ac2c4ba5825748a0df6ef90547300b582976ed903409c4f84cbac67a0770ab7666133e6a938396f812e58dd24650395f1254b2a7a2e9ee043acae62c80288608637cfeb00d3d56a91d8d4e396d8839ed45e08e5bf4d937014951227af249885b455d2d70c870de301546f67fd3f6926c7a01d254c8dcdd538441474507b0210ce4ecc4e13aaaa71cb8977950b1e122ff7aead26f7f19181d63f98b2c41c0120f4edc2667f2063acb5eb2f054261102beab08f5eaa71b315dfa4f1682667e3aabf1a772323c88a44e589273a8f62967242ef00d536e9c1aa99ae5d51346446dcf0836e8ae265d74d9869d39a67f460d067ed00986656015aa6c8caa80f83cc62c159f9a1a25eeb4a2d86ac312a8cb5cf09f98b5c7f153cc6940dc46351ed98de6cf9bc37fa5e125ea5286fd6565c5a051e2fbfa2a9d2e718760962c9794c32caaf5822364b3c3faf62582d02db98dad38453d7768d1d2119a99531855098986e80e63a0185b79091db7ea0fe904b74f70fc588b43756ddab5abfa89eab353bc71262d56415d287372edfd13eed5997ed756039de895d08b6e6ffe4b799194ed8a878281353e0753f987b3e5dbcb8759764bb190f1167fa666e6e72e9886e57d5c175a98c74e02643ec1d98816b35ea1543298f8e319a8f83b9cd91b88bda3ae6382039cec2b584b4fd1df9187883b5bb10881b0f9600c4677fc5fab2217da6e009dc61c83a69fb9f3f5939bcba5f907d7ecd64e2a3ac4d5b5f1b27b3bc6f4f73ee5d6f708a1feff534ed56e82bae051d891364c3ab97d32be2e26139aebbbf8ee4135df80cdad0aed3a9938a78859f8c735a60c10fa5d9dbf1dc71bd56bb64d2af7cda2a85f4e8d4ac4ad0de8a8d4abf01c951a299ea3fb81aee25f6cb79325e85105d73991f5a0b977e6a0e5501a0b228267db8f154d603a632e27b7ff4fe390fa3a2da29fd7bb6ca4d2360d2a5d70e278cec5bdd6f2e609aa8d42d851d354a05563de7585527672e882b30735dc4d8d22bb60c68cf92d3e6068d32dd19b0cfee26c517ca51e52e0d35c52322c545790c3f59799aad7de743ee7c984b05c79ac125ff15f1fd015b727f861b9c66b6ddca8d7aa3944dc515114cc328ef2bf0abbd0c6eb2dc5e85e5ab02dd1cdbfe2da64d8d0cd8d6419c3c0d6b685bc28bd99f66b3c8b295ed34564b5d7466e12c9fe4430287b072636c9ba86fff29813bf599570a332567719e4752804292882d7299bdf3b0106d460d1105dabdffaccc8b9be2c79c35c9c16112aac6c11f837386ab29765c1adba0fb83927a5a7615b89454ee4fcaf08d42acf38a28a0e539c27dda913971823e5fe705d18f408d994e26546ab86772e9bb52696cce8773e001d4fc46b40a1883f32be0df8dd8c8fd7eae26456828e4745bd5201dce6b470c5afc7de97023d2c54a35a28cc83cfdf3b31305a259ce1b57d6d437a07d6ac263ce93494ef35b33cf3a4a4e4083034ee45e3851f0910f6ae9a776579a4c055964fe33e11b8e4c0db022c020a9ae0f277ad37afdeb856d6fc7a03838220ea0b9e731bece09fbdfa7a48ad7aae1061963d00a855c44d2ed8ca925d9b9eb40ec8b22701c8f5c32f102c6a9e3ece6abf3abb89cbf313bdb6507101f61f9e0ed09adf117102c7f71fd279e400d68056f40f5b8a0e3e2a5dcae45a1aa3fbffdbf6b4ff8592c5165b2a0e8954cb1a1d16e1b12482ba04f7c2edd888e67d067c8382eaea3d2864c3fa467bc46c3d6f4a2fd44db365afc1f17277c602d14b2856180525ec8526ee953ed147032f974ea6e932d0aaf8eed74703f2ea18165d219a161105beede51e10a05902d3a32591b32251d07c478876c3d25cceed05c1f5c9389b5bd50878265927de62793363c11c5f6b090e8e9d3d590f788af0ffb69e0f6c4297e62699b200b0aae201a8f9203ee94f0777f0ba0074caa3d30f751dca9dec618b041db72e9e0c4cdac60716bb5430b1df29ce61f0a81b40efd25c9db2a8c818d0fbb4db8cdc0959152ab5eb3fe84055a97321a6990601ed02bcfda703e332baa0c3d83605d626653e5029ed5ade5666e5f18f93e08c4eedac944df74986e5e8d0663e11453d10786356faf4b896b1269492512101e103d10e750512358e9e368911d1d7880aecbfc5ebc7ab82dda3050bce832ce600f48f81de4b11718312fa27b290af063ba0b872a565804c7e3ae532bcfc7be5c57b1e1b468d4d08b8bb0a74dd08c18567c097a6176d1fe1953f1244f95ad79aa7e1b8a30077ccfe9be04845741083dcca828369268fafbaf758a06deff5dada5d466f15d4e695aec06166b448863ac3bad99d7f3a81a61863d756ee4ddad561e8a8b3e16668b235fe9cea08017299c63065b4395311ead23af38d079bdb79fe6b5d59d7fe0826965e5c21dc4ddc6a906709fd52b98703f0422d2148e78a7ea1ea344974e25cb6da1caa2f9209fce1256e3db510588f08d7236bd69ad2912e2906eb27f218fca4acf737679aa55e72c3fd12d6ed5dd7a9302bc95b33a935edfb806d19c563646362f4274a534dc1563f60c3ae631eb644138975e55e13f91f7bac8074ec293bd301417d0fe6f3e111190ba2a36b60a832d0d86aff6b33a7b495173da35af102ef11432d67e52f4939652e08eecda430683b5a6889e13947da06fa9cceeee3cc3bd46e545e161091b3d43b376e167d490d422ae1900e2ca52cd2df31c0dfe1c8c260b4a8b3dfe37b35f7674921bd80447076ce92770e7e4f7431f6b05737ef0f53114a6fb86e6baacfc0c3bcc5b34f71bae259b931a315b4c4c5958e967daa5abcfec6c4b760e13a6dd6803ef835344f7a599a0eb82ae23ba532779f02d3c75f04d5fb363f7809f76954806117183b520c348ce3fd3a0365c6cc966283f17d310fa0758034b5ad295a657fc6cec05393c2e7219a30c1ba69c0dfdb4f47999eec56699dee5c54ce618011b81995fac56b65f438513532ecf4bc41bacc60b1be88375089dfbffd87cb8182f1167e08fc9ff63534a270f627128033252478e597936f90a11e258db852f30597445e38b2834990ac5f61d8aa1e3f0c5a206a54ae995d398c48a1c2d6b375673a5fd4b6fa5082de8aba94dcff0460e3fb1fa53845888350e95dee5627c2c1895156f31ff1c06f2d2d2c6ca4cbc14e0791e8ecfed02d2448adb34264547c28edd0b8012ec1d2bd534a441f504ee2bb5dc34b3e57aec82169fa4311c0205c35ea3badc4759a1d05f1472eba3c0da9216c997eb7d7e75eda261459b9cb8b25c0ebfbf4fa0c7d5e34da423af593695461793b9dedbfc68198dd2bc288d8ec06905c1f41d85d667627f00068290c1fb681ccde15f485e178a7edaf1c44bfd63ac66ea59fb216f49d345f6e1d922730b3b4348357e725e0ef9229366ee1ee6e4b6f42c045e6e3d571b82dd9afbf417c440d361a87c99c0505a5bc556ca463fb0ba27053c278eaf86060e391fa1d955441be7217787a471628ecf29bcd4326687428ac79c960ba21d2f595a2f10fa7f062f95eafdced7914d10119bdbe26bc0c6afdf7e107e7c8f9be5a4824833326c5311857bbcbb2d9c76a8190119d7f35ac6f88c10a74e22fbbdd31f28e47e5ff263b49f79ac828c2db29cf62785c61dfee4b7ba1d4abce3cd71b43bd4b09d6938f6b86746945c5bd8117d5eb6a20980cb59c1ef2efdcb69eb841f3a977ed93e8759b4ffa78fb10976a8db5ec79539c94df9d3dc44b58096191a2e48bcd527dceb810962b3c2c9e9c6a84f6c34babcae611ff05a554bc18049e15afaa70ae687dc03b76468e30d2b20559da64ba6341b8ca02d804786eca50f3b5e6b1f23c69682825789b61130e9af14d1c14624f21d2e8a97ff5fbeb8e185be89981753d5007f524563b6080277301ab4386d4f8ac79a2a5c64b6ebbfffc9e30949d536d0cfa5fcbcd2fb5434c11dec097d5b264d7d4d67dff04de07e8c223cb37461605afca062e028ccad0814f4fd431cd4ff1e0b0577dfc41581008e2e584a298419b658c1387cf95d1d154f64f243d96def858c945d98111a74182bc7da86233df304bdabbdca6ecbeaebccfc289185dc1c7c4767e358c498ac553a348dc80b441841ec1426c616970fd3cfa966be27307594379cbd12a10ab272273460aa26c6d10f38d9893585545aef961fe55b2b9287d3e119d6c9968f04a4439d88b864e99333e038239902132310c60b02aca3a57cb4db647e84935c599f2e69efc4da00658e3bd966df04ea4a693c62cc3fd9a41fa0f75fd7016fe96634f2d900827a4535e05c58d924737e15675591d95618380205d2fa8fe5cf9362817e81e3efc3bf0071be9334164a194c9e024da5db7e770746a887bd165b5e4bbf4a28f0b6e4a7834324bab748bcfd93cf23462f54b7bfccdc25cb1f86a6e11d23a8e2e48266cb9f42a884a9b8b58c22bcb33311c82f94b198d8828a49049b996ce373703a1a82ed6d3dcefd4f6b0707df10ceaf22ed3af17150dc820db527f3bd696bdbd88fc5cff6cb46016d50fa3755a7259f249629449aaa089db697e916e64b63384cb67d925c54e929fae9ea7e8ef4016be9ec9ec1c56d80dd85737019295e6ee0e31b4d1cef7badb5d617013e8d3a94eae8fcee6c0cef9890976c3730f3b6c7cdf271588fcaad67a73614967763c2a622e7a2ab242a8f726f6d73d1c74bc13934e2695940b5dae4dc2ed3046cafa776c1050cfd0bb97945ae426735842781091b5fc80ae88a6c09c2d8defdc744315eae79f9f78acf04f3e6e0b2ddd35df74ee56a3bf6b3b43708e046bc3d6569256574b3b8272685acff2108e3f941c26ebf2438b3bae2458478f82d924c518a2c5d6decd522f2efa53cc3f701d9f5805ad9ddf07807abc160815eac75ecd434fd3ff628adc83e1779b611ddfa01f1c03afc781334b75a5970c0d3cc43d9b66db3652db28ccc2de88b2cd905c88bc922155b80a648a1e8c1268bed680e80410c84134560a5c1cd379dfcfadfbc38321781ad122354e27c9a3cf3f856f7216a6b27ff7d49207df827b5a803119fcb1edac40859665e2609f19a03edd7ca3cf9f4c8223654237b12618e6da8736ab603883a5a828a472bb0f909429ae3552f9f25abaf576a0e4d360ff210473fb03b983222e2d3d5fcf4adbf7e3f7151e3a845ec1661638e3a2af4d34123c62f760c2a5588530a83b57e517ebaacbf54b8b224ef8bd34bb72bdc06533f48c668f4235b4329a26aeebe5695c0ca8e38ab96e41b0be323c0fb84d9fca768c8dcd9491da54386137b2176cc2e11a7140d59570cbb73e3061a97b1b80ca5a08d1c6668d85110e9d5f81e01cbb5ab9f693f79b352c81401e1160a72870878104ae74b42becbd21a5bb83c39d0972eebcdf18f70a63cbdc2e6cdde23d480c77f60ad0acbae4f5785afa985fe08f904d6c0a0e50795b8f14880e86d9f06c43ddc29b5f817bfaa44330edc14340914169b94ad5d32115d630999aee676e39598e50765296461748a0421d34ed86d8ca64f5909bd5713b53c11bee21e5213e462cba251ce5cd484a3f50d99450a8383beaeb8a6debc7275524c961990f76cbd6d82fc9d5cd7c1fbe255d005767b5847a61a5eaf1e14fb47a1a6896c97a584a85dbcaa5323cc67fae3091405db6d0303a9cd6721800f37a6b7e422010f111e2351dc85b9d5c9f250a223899ac6a019ce5201409e1e33d1dc80e834e505dd4d127f0444ff1b8ec425bded34f9da8d75bdc61fd0c9912367b1377a19c9dde560e83a4507f182f3b38cefb05e51713103803e493acec4ae12207458ccddaeb5f6bb9b6a6b03bed0ab9d09b9e965c04b7684d662f05e67c18ec629532986cd7ad655af5b6b18b441e4263ab63a19922e56a8035827846105f37954f1538443fad132f5dad4f5e3e7ef1dce4930baf992fca7c95a9962949e5b9ac5c1acaf9cf30c362a5dd46a060bfcaccef4d888e94a3775bbfff71492f303bdec27b29178f3793990db920221bb255a735e33da60c9c2ce4b75613884876729a1f63c3a9c7cc8bc6b5575c3e29f5c840ed666999c6ddac98b0ce4a6b3b9ec8129719c5e74c3184800ea4c13fd0278d7fcf4e28254b4226b855a55302382723d5264f017bdde1a66c45447a38df94320ea8ed1ce1fae0540a370d8b9eedc953c1f7e4c6a24153936f7e9a5e81d4aab4008f640a1f9eba0dd8b1dab66e96c173007c8cde8e8efcb793b32008bd978f7d70a463eed0d9affebf05770332617e9a1448d234d6409173e17e6fdf78002f9d13cbd6243dd7b515c83b0aea99ca04226252ccb75af7f451238d3f1e6d5595d9aaee60668ca40ada58a2f35249f3599ac7978311b2108c284ed3807c4937585b9ac029b35460928e5605bde9fb6c9fb7eb5b8e1af9ad39af0cd9b125355533221a3fc92a89e6cd83a969badeacaf3d491d73a87e3e00e3acffebe181f01276475a117200df91e6fcccbc0cdea6fcb0b0a81c07395cdcdc97da8718427c58773c1ca5c70b9900e64267b1896583eee573cd5cb66be74273445da46548cb35d2db161f48b8472a3bf61164c1660a3d5a3417599693bf93da9c15c09e0caa3d74d5d5dce7273cc52dd1494877e75df1a1f05b591485fb2e1b729f04d63ea63df0200ba929348dcd73862abcf3ef2a6852291591844c7983eec8beddb2f2a4bd3fdef09ca4f0e40a609e81f7302a4e780610c8571ddef248fca676be1fc880660484e61c4704676ff9e9e38b9ef8c3302c993d639781b366707f1e08c73f917466500a8a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
