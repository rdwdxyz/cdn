<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c17ac0e3deee7ca09ae0b980e3ed0a50207332eeb562700932e022f635d07c026e7c140f2e80063ebca35cea21fa6803600e128ed4dc4a9834fd3f603cc859ebe358b80273a3c85a05e3ffde297859cf0488176ae319b5be7a60123ba4614e3a66d7bb1a8a95743fa564f1b66279a806b110487cdfef3146045da723801990efad1008c98fec3c712578d168653545bf42d365ffac42e85128c9d204226a60f48cc4d7cf9ddb324e3372749de41d4b20524b3d5f3d14892b9e99f2f4a605afd9a03af23eb1590684eb465c4836fedc84aa21b8f256976f0246c58f698a0f6d31164daf2da56a9b42446a22f33e6227f961974f5af0626652e151418953a9bfc99d7a76d78ce51924af3ead95ab5198f319b21bf59302e6c7279bfbf42d1b442d03e257c7f20f2d5ced19e5ada4722fce861cdcac38ce5f562252705e6ebb67e1a3f259cba4b888eebbc71da739afbfaa70d9a16ce1146cc5502f792966a804661c3df337a9ada76eb839073d62bb493c9fd190b35b42e6152a6a29dd8d66f62073623056ba76832979f99dc04a9c94ff5346cbb73914bbcdbd1e08d48a2a5fcad052ec3a0e1f3f774109e99d35ccb801c75ec6f9caf3701ff76187df0b0c7cde2bd3b72aa49f9c87117575771c5f420e1ea5eef20eaf5b8c3a1f86b9e6c2fbe720ba3cbd19aa2c1e902779e45ac8b048d3098b4401e46fd51856a98696ee3added79d0a21117fe4a8c7fd446337ecc7baef902e9da2bfb337505ff304796ee6ef23bc365c7c2123493221447c9ff06f78b87cc9c567c22c188c267aa630a3dfc79b84428d33dec13fa715165c284213353c43144ad518dcb16af6d5a3b1f537626626ea74fb643b00f4b032d085bb38f0170d1b4a931146f6ed810a206221bf47998aeaee1155ea154f4b445b61cc9aa2cfedd77c69479d5915e21e72eb3a4f850c2a4a15a8700219b978e2dfba27afbe03defe39af30a3949420a3cb8dfedfa04e943f54dd241883f19d30a3d333dcdc2152be607501cd9a99c863f0dd0af681db724274eb8ff52271ea1ad544cba1b290dc1977344dada37b6a6652177e169453741c98e62f22c9ef7662ae217543c5988569b85a21480dcbbd5ff4cf715f226ce5bd2ac2eba90e6dc5d19845943d0e4ebb2bb90c210f9a2b4cc7c2feb438686182c355c114e89ad77d674b590f99be5f283a46c55ec5b9415a19459fea6cf4f9e62e5f9398d9b87c9771ef0ccab01da32f14e10dd6c6980912090cc340c7e0e41101bc7a3f705848a99ad08f593ac630e49cd2d5b416593d9635309e1019030f7d24ac587fbe7fa20c6a340abb780f2bb07888d2a6f50d20e9c81461246bd1015bd24e32b7a1db10e67699aab619efc6c15ee5c30a9418dc2a160d458c0af3f22cc31018a0d6189e638d0515cef45c37efa5dd74a025e41f2bb93fe56d1f1e3ab02888d6fb35085e9d0a4a758d846391256a030ea78b5107f036bf43b396a25438b7781fe8056974a9e899e233b979d17b08a21e14761270647ae16365fd2274fb1323cddc10ff4f08bf0e5dac700f9716b7984201d58dc797eabbb1b6234661fa10125f3b13ee5779ad03cf007385e35a6f0fc43e1ed1528a02a01431aa54c18e5b2d51fb5033ada036581b0ea4cd0fc38e4d0017e332324a6d4fe87af382d40ae1aacb0583149674884f432dcc6a0747fff10204645220e409ddcff6f70f060c4053391025a6919b31947406912689242703d733176d2eb992f174b079c7594fbc4ffcc14e5bf21434ebc179aaf83c9260f25c295d4dc9a4ee445abdb99c10d3306a9490684fc12529732ab2e772b459d1b98c7f6f702eec1c42c769be8cdc27cb1bd07dd1b243efd80393e3a86d8fde8bf743b2dfdff237573f167e5c7f6f2be7555ad0eac69397535e5e2ed0f4684a1e15d69007696d6152592e12459cfb7a1cc58f11abd1949bcde68df814e67d219ca566190dafb8368fd2f24c808caaeca609157467f94a543b617e05129b9d1c360d520badd3f762bd49ca592d94e612c7273cb41963a6ea814e190846a92d0faa5ec9b0e877a42c932c8dd15c3f9c27fa8e283ca5a3308bbbbcf312a85b813197f765f3ac7bdeedf1cf1a97095183fd2febddf570e982c319ee1876166d8d15b928cc3a5102598b3b5c0ee3d9eac2b33332becd05e08cc7a98708e9ce8fac7f30dd1b848db2a6f686ecc6117a5288d9a1f461aa05bdc61792157ee3aa330a49b395bea587669a8e0f4e55e2d754087e4332f9118c27b3046ef63d20c73903939ba55a102bbc30d03e49d726ef5514de7d650b62d2bd40e239cc79ec4f1dd2e5a860b208674f694a272d3c5c88bbdada79cfa0f9a45f478782e03a9cff1c5918352ed55d4e0181e70217f806754c7fc46bf820ab35aad6795c2d9f7fe7546fa4493536fcbf7d7046808d04e15fb0cbef2c12f2dfa9df8decff2f9530ab5add8b3f19e87b90efb1ceee5627f1b2038ef2ff46c0084eaf4a0db2dd3ed4752308f5bc73bc6e5e1fe268ead76b6202f61cde4516f572858b332f922bfb02c1e473fc9d3e92ceb055733d882373443bf44472fe5b182fad5053ab86765856e7e25dc15ba3911784efb2af752bbe3142c250ca878d22e8d531a499442800796c6971238ebd02ac84d20d39245231de282bf615ec7e63ad0cb65b679d16c07ba2adf8a20bb752c7faf5eb15a609a08f3a5db50390236cccbd6a7cf52cb565c44dc9deb553d4bbccdfb87cf5c1d4683e97b6e942fbbfac07035b886b0266ad0264cd1ec846788efe2f6cdbded10f0329bd1463cf6a336127a35983d9da2db5f97f7e306ca81058e37a92e5f2f5b4ba034a509bb976e7c421bde5abd7ce15a9e654b9b8eb23105d8d147d1954b6f07f79d9da1fb6ffdee2489f9c5cc4bc459e0b9f4ce3640f538deb4b8b1d3a1b2538f9a0bcf09d531d60617f69bfe65c5a35165834d089da4ce53c63466986613348dc8fa0beb0b3cf1532b69e15c74a4e8c42198c5620c525bad72d4fbfe2f4c357c6baeba2729402360c03e2719bd962f262d1a1d22dc573c48901b0958e4ece675ad35e3d455df83528042b796b422c0bc3b77740e1c467e91ae6ac998256e984361c018d761761c1e3904b593571d58f69132f0aab857a76e0ff376553437feeebfcecb49c09f13d89900babe3b887aae26df29662c4cb336d0db8f7cb677f340e5bf01d606509d8448e8fe2c03153ae11eed64026e70107b0ca2c90c9088a8199e7b2d75bed8d109392b99e81927e257ebdaeee10cf004f241f92abb13753a52be8f3d3393499d30d354306ac248513d599901ba7aba13383de3301ec549887f85f5052b4e2f5ed4f5727afef2507fdd9d531b4f7f7e06d686079d090590865c42efde8185a0fdfd890d0dc6946c10c02775fa771e163d4c46ab9b80044585266bbc081cd5bd4d7946628b32ad3ca653a7d30389f685ac9140f9f3285feb053754d88d80278b695f7fbca4d1913b8338b75b63b0992278466ee324757aac89b11ccd00c2112a4eb6cabc36fd7ab5073843d3599f8fbd097cc7ef921f267945ff78b4baef9c5811fd3dcb6217b89c9c90af8a8e73ec8549512978e8c63ee1dee1505fa31a902f04e62297bbe9d5ab94cafe144de0023862fcd94b7e0c012bb0d675bbc2e19a6ac1fd8db827777c546f1ad861fde03ca351f9b4fde353c2af6ed5c82bec7f98baee0eccc942547c77667b5f6c53d12411eac8502c1bb4cbc5002eddba238b039cc17f540551e525a2995c06edc7690efc8573a13f49018a1ab0f4dfe52cae59c732c315b1b6d2cf3578990a429ab4fa079e9c65000e793e07baa8a35aa46e161bd1b81c186e8c543dc60f0c318a175124bef1f43935198f9e0593d5931db0927ebd55b031a0836839aee35f8497c6e68083bea09c3cd61b29eca74183db62beaadfb58b59f3a52b5667c3290cf3473eacc689df2cf61456924f198b1fd1d251d715bae14ef387a3235214c8dd3e3bc9811dc3d42f3dba6a07033b9e7a7e241a5b2a4683474ed332a652a653686a55076fc32d4b5c9f5c4928dd572285e987a7abbe11edd7a0e99b2ceb09175e4e6fd6b192bbe1dd5d5de5a36ba5bb29f62fd6af2729b227d33db8a9d9c9abe6b85ce0b0945a35fbdd6af0314078b956395719fc15451583ba945de2864c3a1770a58080b70e84a09b91b49a8eb62ed41a087af2e3bd8a86ddf5d2fdbc2c3e6bbed1c8b04fee6f77cb1ed4d09802bbc06891505d78d219a6aefbcf704bbdfa24a7df3638579750617040bfa0ab4beffe4e41b89383666d1af377abe54b780bc901e78b2509fc894d69631f8d8fe93b3ccb10788fb2cad99bc3bf7036fbba5e634217ac51bd81078bfec13915c08c698db68da719b5736a5006ac10a8c56e1da76efee4f75c143406505b56b40c4bd4353290d3c1260e3a037c5f4a772d64ef23474c63a7fea1434d27ad96d9f50bba3e1d96bd813acb9f267a6ec911c4b72d5b7ee0a2a850c53c27b7b127ef4fee78eb38bf37cd928208a535f36f88ccef1147208ccec73d9eac205cf458b4e090a1c9b249dc687872c2dd3aa357291f5e07ce1f8d483eac05a685d2cac59af5e1c13b0517f6da905f575a579d29ef895241b37f12f8f68d45e8478de480969dcad6f5e1790a2e5a57350f2f8ba182541b3b2a1068f9f4095194eeed2619b39694dbe95739abd6230526a6b429c14ab6a20f2cf32fa087673e2ff0a8e2248efe75a743ce871bc82d89961cc645872ce4aa8cc48c7f7e8cf512a515476c5652afa72fcc517729023bac62170403dde7b15d543b7a239431f2206522b641ad9323dde050784764923205af51ec600afc60eaf10f2b75642c51277c7ed3c8150c06065adf16d1d04cb7918f157210a9b526bbdc30d064f593a024a68f912bbe3cdb8a1e8c19da2d136cfb008136d659192a038f55cbbcfd91da929d91a62c0f49e5f6b683d7f3d6b23da5251e0ee97adf180f9ea200675e80520c434fb956c40e6124dbd1fb1745cadfd965709292bd8e9e616421a154c6f205c50f9268ed6cae5203f3116ffcbb1c6010eb662127435ccb741a1074be18e27773d6259743b5589f853dc4eff0d7162408f55518667c75086f591a7ada16ef17c46654840c40b18ef50a2588b7993dc06037be04895f11ff6886e2210f8b058aa34a45c716622473ff29f390f7560e29964785b5da435c1192f1fba2fcf916a59f520ed33a8c9545a42609cd552776de6b33d509c662cabac1ca090bd778b4ffb06229ca4e818c8d05eb36bb64210adadb57a6f57e62b66320defe169687d7b439ac447a4714845c845a68d1af05c5b4d413df021e1ee5d00abb81ada0fa75b29aacd082710902dae13f3fc76b586dfd18ecce2821d6a08fb32cd1ca0730eb5177e8bd5d08ef284baf748e38cf5119672f83437998afe2553be99a2d370ffbab86a00b352530c77af971987fa75c745bafb3b88123ec598503b6274d442a0fe009a45051728e2b4f9be07115934f48ab3ad1d5d3aeab1029bfe60fa8456e0a2ceb4986f8cce40a52afdcc2e713aff2af31c1cc3c782b29f1ad504dc7164a74a436f4d8e378328d2372c3959cf18df7de31e0e313b730113ebd0c566ea508eb413a8ea74f57cf298c8071a09e40ce0da14f20331dcb000200360a4c3bdd690ccffb5d59791285a836eab410bc243b2f8211a5bbbd00cae9ed2cfef523c1ddc1463231deace2b68fe0b70f98a7eff1636d99d548a8fe28c4b623f767c93e1645d2f72b9c2635d918ccb544f43a8091911304ea9a8a0262ef023bc84668450ea76b7d1aa019220d7aa42d60dd09ffa574c77d468665a0315fcda3faa737ac925dd58a77193b703f44fdf9005510b83984c9d6937c1d721733da3668ffbd6abe89c9d62564bbac29ebc185aa6d7059c55bbc8701645180ebabfc3b4aba567b4658ec74e5b90d7bca268d2f2144820923e1aa85bcfe0f5e0c5af7e601d5c6e51a65021d35174c4e781a1112911ac79f2964eec269d8153f4391e93ad7c5dbc65185672a9c462057f700b11b387e2cc4c04dfc43be523c4742656897ae30d9b1fac951f2b11a38a3c6c65873285d734c1046cbce847d76c31d6f773cc3528a945dbf2f777900d1656af2ed3a555a373c53d65bcb3367a83c0807f5370618f5648c5dab5f925222eaef633413bf61747b362138899b042cadcfc684edaecfc3f4de02d0c7c3adacf728f84bd72d5d3d8abfb1e5589fcb1864e5599dd71dcc85c4d453e20ebf948df0bb4ef017ec3aafbb3671df9ff66e53085b3c2d22d15e4139cf20142b6fe553ad4cd5b6bfda6dff34b5f3bf94fdfecfefbe065483784682f63dafee6ae56aa903c1263c1cc9b6c442812709d9aa4109994c9d0d01cbb31186bc3beaf4a5bd9fafdffb853ff9e4bd9755910eaf936ea995e92f1dd870d5d9f6ca9bd0529472b703ef7bc3482c29e9e4fd34554194d18066d34d1a0e2b4d12c30e782f6e3ff2dd3d8d3be866014a462f863484f031f37b3950dabf1a8af3a55829fd62565cf9d3e3f6fd4569fd2a6aab186bc34182f5738f3a892998fc8088e4c654b81b2b6d7bff7b70250f08926b47c52bbb603cb67a522c84d07f42fc3f58381966825153d93c5a041057593e6e7054a2af3ebdf8d96be2e7dd491c1e1d090192ed0a6e94efbb38c90c9af14845afc6aa44b6e7da260cc2ad3b6d0a90bae8153cd45f84e2c56e0917d389509c463a9af2f42b8d4e0955848aabfd434c81ba110ba03eee221d4f24b4eb689c777419d1cce14331bafa31f38def1a2e3cbaee800b88598ae9410116feab84232f9d15607c550e044884e27738391fc98528b89a76a3eef5461a4197693b7d0030ebd46cef7f5b2d950f8386546618a695c6335053def49e6479902f015ba0b79a2ce70f3b87d75d8ebde32f64d8cfd4c827d08bda66bb338776fcef23d5ea6f28d67228743bcfd3ff90cbbe21a74e2b454561dae77979c37fd01468c74ea31bdb8604b75ddacf6410ff1935ebfa0aed5e5b6d55c905fb246af574686fe9a3b27be5d21a589f9332b75e431848bc19bbea1ba79666e240b0fab3e21068f01ca602ccf493ed9bc6769ee3c82aa9bcba1533b58172369fedee3870227562b899efda6d8049c591942d654de477f5327e4ed173ece28e3f50523a6242cd634252a5d432084782ae8e77e842fae91ac33869d6c585d68416ec977cfec74a95acead83438d4f4eb3fa6b29262cc7c36d945bb094a1f445b9ade9b0caa679381ba7dbbdc2cc5633fcdd95339c933497fa9ad8c6a9ec2c3cc9c5474562525b1e56dfca2f77df7bb89b175d8bfc6624011eb5c63208b7d39bcb20c5456fb4f8904958c03498ff624abb3a8f83c6e8c024ef1971893a8e2c2f122f91cad21c7ae1384c61f95846e7b30ca3db3cc7e3aa52610e8a3bc88a488091ab81842a3cbcbf768dd66eb3e32f341c5028d978e1756ca88fa5bcf91d3bdc5bed250a0154dd84a57579f4c8267afac9a75d62ed9cf94e81612a3c7428f830254165568e055f256c3f13a30297380fe7e33c54e34ab5f3ad0a1ce85a351ce559b3610a06a42444198513c6b939d9fbb90d7912bbad510bc727d1193c779c3991a66c6b3a3c386b909c9cd2b46d778b03ffd20c06e7a035446d5283a89242d21c475edd2461649bd24083f10900dccb0144620ef4c68799bc55cbcd92a0857c20575c3c3df20ad999f5a7d6cdc1cd084247adabc65a5004c1eb745559f04885f27082ec64a2f92591bfabfdfd0a0ca2a3d3b01336ba8734695b9f0c859301ec0ac239a52cdfd3b305b99c198781970f597b28b278227db6c7fa6d0f00fd9a63f84a9f065cc0a3c0e78c593f4e5d92fe507d981c3b6712c889dd6293991b1c3ee4fa0c4f6ffd7d737203bacbca8f23eac6652bd9a32918e72869be47a782c61bbdeb2439ab0c14b078a14536edfce868bcc2fb39f569088bd4d6d03ea7789796311ed74bd68a041d71efb1313e09b0909b6637212404b235347b77e0e88779c9d1354e710d795c5860c0b3d86fc6e4ed22d82be4fa7109bc43fc93d5126f3e03d0186d786b06b1fc68e225a6df8c6d537d601bf99cf7ed3fab3a2da0d594b14f9d1e3ea38ec0bd7b258e487a47b577bf6531c6ac91ab9891b2145aab06b75afaad6e2066264d442e41fd500d7890fceae733fcc40a8746561188692dbfb35fb2672d2f260342e00c75ef736788a707ab3989eb953fbbb2e6185803c819a9dd95ce41e7fe4f7cee36f0c042846b5d1f7491b0d77d996891a60e523ebfacf72c4ba51ecdcd86b93c6ebb4b1464c3cacc986759867b35fc95399dc19f840fe73b4e055b0d5eb3eb11e9d0c432aa99aac3db43280672d42f439d1b26b6c30ab1e54fda4e2aa12caaef0572e4b528fada95f2f5eafec42e22138d2e1a9068ada6dc33b0725d39189c660925b9450ab716513393266fb44345fde9cbcc3e17018d3660c0278c34e7d531793b896406e57d0b34858d366516448e60427dfa228b56bd480900903974218c9e695483a4b85153813a66a29f48a98494176018fa7847fdb875a87607594ddf237e0849d9d46fcbf941cf2d26b3b5d7ff97a26423fa387d8988de526a593bdd1349307608d41a7460c5ae20cdbd9f8cf1bdf799f8c86fc49a46c26a7893c65907a20ab8f0e92dffa66588a073817b8a49db620f224603d7176cc180eda24b400039935d873125c682e86240330a580e5efe9f042f4b3f8db837d6080e5ae0e0c363594996942a7c7f39eb9da54f10da79cd8a18501b475583db53bb79bbef2d91cdaf09ceace1d967befa4ef8c2b9d2d3b2670c29ad0275b5fe0cce19f29c198fcf18d83401a9982b18def46846afa428796c76ac0f4c89dcb848f11e5430ba7d4f7b96048db386d29d1097b269a2b00ef7e18102dffc944cc608fa620c72abd43de2a59b4d415090a7cc5bed84630143805beadc7a69c2b9d69d1023d0103e458fc013e2aef48d01ba5ded0719939571bccb88f72b887226402d1ac2c45d40f6b4e0734d141d85abd34011d5498ac9a08dea228811a9bfff4ba54395afb940a4f9fcdfeb73b379b89012f71b47ae90c20e1895f3483259d25384c5c2ca1c1ddb764503909e5e947167d229917b6f9385d4e2b5ad845ef97c5cacb8a9f279811ca5cc9c022932907205c559277ee7bb9f8c87f3de87d452f1396cb1b5983c416229ce0330e4b642a8b033279a27f3e3216d4b912dd0cf340dc85a83d6d000807c3c762b39d4ef4107e0315e5dbd55ead4d42936c5d444612e90ed0468440dbfd52c9d23f1d3535a74a78f9b4d725d04a3c1bc9e57d3aa442de795396c4b09aed3cdb17868419fe116cbaf555cabe459013cfa59f3497b14db1480cf31bcaed8e241f91d70a44df91d840bfd29c44a9487dc3a45a5d689d185e2ee607402d86a76935807f80ff7cd4bd60f03acd3db134852e3479fa9c87b4d0319797eb86f9ebd77a73e1364b74a2c0863fcc37dba7fe72e61bc92d9e415cf5e503e73b5e54a036ac00ad55e084e823b298f7239223970b88e706df1c8cc6b9ec59877499032f38bf78bcfcc5acdada6d083f908168d6d5ca00c713e92472b6f5404163ff28e941f1e7b76099dbaba2d540578bead922b93813be872e0bba675620b63c750b18cb94348f48484c3283bc8afb9939f7f3a0a43418535e5e73aa72a4f0c6e1690ce6678698f8c382e6db143e2f3b1e777c795fe5013bcb800eea4f8140c577ec5fb67177d03315943c511a6f875a03a9ffeb52730687732dcc62b838bb9957b322db4a505bac0168a2367041ee757762a919b20c29f12c5d97fa0cb24e860f7969519caa5dc38c2a6e1398b258bb8a5873a6452af4cabe65701c75265f34a0eda3ad505dae8991ed290c9cc0ff3674e71aa963a16a352d90e64346099391aac94e8a18149d21c53dac59c34bb46d4c90a8cf4e56d22ebd247e0a265400fe4c54f2ad8f88541203f514cca2c9cd243c3166209937bd9fe19c44ac7e6990c9222a3cdd7fd22b479fd5d8b52008025ba9139173bb0908be821efe2358c9b4311a354864a6b3d364ba7829ef497a0e7f041552f0db8007169d592062fb59c7da2bc0de10f552d39ed7c91f5f1c1f793ebc18880308e7fcdb9bace1703c170c73c911b5617170bf2db118dc6e575b3ab8f2cb5dcc7c6e4b26710cee14004b36e6db137940cddf026c644d0dd60850b228d4005d915bc1a025efc82bdab043796ce9a74f2e9d0a51c98b9009f508daa7fbb47f9613a8d329be8a6f1b6563806ba85d22095ede3525423c398712756f70eab1fd69295bc1038e888ac027dab25328b931f3144b3d5f1004c6425142e7d6522394e3e5e2fc88c2d6aa1788359e75f69bb4bf88d86dbf93741305f2900081bc25072be9bd13f7ed2e2991465250cad3828819b7d223c07d11e200a56527d87ca5eb2f90cd33a34891d6cf0f812753c5c3238cd68ebd7370ca2c78da76ce44b6371586b164f922f1680997b5936cf63237f21767d7c98595dcccbe4edc210194e401729484e2577df90e0bca8698c2d9919c08e4800b622cc0c6e97bb52a25d37bb2d68e2c408808f5e7c23baede91852ef24519e358b0d7fbe07ebcf9e7df09c02d7ae697fe8505795fb886abaa095ad8927038baf2c184884099e9f4abbb0b6805a8a3812fe6ce7bd532e55675fa789ef69bfb6d7b8e4e58e5ac805ccc68cb7b6bd8ee79417c5f2541b6f120a9c666b0d95c6e0080d3601da0bc937ceabc8f140a4716adc8295f04480ce53e87f6c26f2993b99a2f367542735ea8dcbcf73d2832aac57e425852b2846236a5ff6edd5f4da7ba343077a9037442375418b082c2cfafd0e7c0e6b4505aeb852c488638538049896c0e3b68fdc921b31c7f4fe66715e772f2e805a6682cbfd6bc3cc78c8373a4bbb4029c9ec63f81053ee6e6799059418f583fb4b209b4b06f2f708723001a47af1663c19b309500c9997f12b1936e6133fe2035f4e3d910243fcab0105632007261792f4cb815b9cfb40ad7fae824452501377abaf5fac5d2c13047f34bdfe95647b45990c164dfa6504792b7a11b0829125103206bb1b6ba1be5a0357117118eebc759e056c59d0fca0bea1886a6fa7235283854f6fe1f9b9bdcb0b5fef0b97ff4549df3c67bca01b17b1eadf782b144f3b3392f43eb0414b6a0737ec20b6cf26308e73bdff571e8831d169bcc8e989c937e5738e09ecb0b477d915059f73c352a047454dd137760e4ed0f9d9811420b18141ea6f818518d27507d1d4fb84ded2c3ef9250230922d739bc1bde3845ac0be4904afea2c3ff44c48d19d81a6123b3657efe3ba6b2462559ef766f0f1820bd9c966eb59d9e0c81a30a688765b8553be890b805f405382587c2e562f44210426f616880f7c3f3d28b4f4ed9ec97a6b0ab45606cc4427b4f810825a9c2c12327c1343f6f4cc1363351bfb103192b6909d332a01610aae798315be6e0adf0f47b95c53b6ef869d49b07237006d5ab01e063012e93f02de974557ab585f88d794791a182adcf02991fd1bcf959195a6570cd72ad7b423b9d7ecff8295b37a8550f4454b2501eb78f0603d0bbb2b2f656c190a6d317b72835361fa0cac9df67e6d4dc48ac7e5fa17d63b9b31a3548dd199d01a52100dcad8500344207f5bc73b0926ceef04f5e39459e8c8c212fed04759d56a08dff81a433a49741650cffa94a472842c13fc026cb0cb263f80a9e8dcc388b45d91e47169d615dde0627569af3860a2102332da5466562fd8a197866531b5d56dd4e233c41bc446b3e92c45aaa546e03aae67fdd9c5626e287b549646464653be653ba14f80b44f152524a8b3c28d67569fa6cd4db1cd25a0cb4e8a1092f0157d10cf64655e628f805fd2f6f0c42167666e9556a946a65dba75446e2ce6a34394476624dc1321be0caea03a3a1a3a355e90dd6cdd9ab1c0870d7220202583b44f7aee06e104c8ab0dce4a5f93b476b2ce64657de83a91d4ec76bac0a94703452b2bf5e837f5dafe0ca29a2a5590969d53f5ed944878308ee5a4e60a92721c3c6b7e553e7273ea9850ea472090923a5b0f96380b0196810e89c60019c36760fce4996038a49b6d19e7059082671b3f94b39107d9cad9c895909dcad887515225924a0e68d6697ba8c5003887aed8e7c17181658c58d98f7e9a650ee6f233bc92d233446f0945a05023658f803199ef76e770a0e0c1ab2333dc9824dd29397a8986c568f84bbe92859d0912416582cc7d5e1ddc603ab75be59ee4986fed81dee2959b0f121d3d3a76e465e52a31b3f0686d2e292f7ec2974ab7285ad1060329d084de81da7c932ec2ab1b8a430cafcd3e9a3d2666c968d8f02568eace2fdbd58afa7b26de6c77b161d2832e0c8c9f5d9a5686073255c6ba620a0999c343ceafe48d28b576808cb709f20650985318243a25c70dfbb5b69127a26599242eab3639c8ae82fb2eecb226e856ededc1be9c4da9eba55bebb9cff62c242c073068a0595f4bd8ce3a75860b199a99088806d425ebc67a67bf1a7430d40ae09aa1bd1d3a5489ce14c75799da45503a3e1615da645d1a492cb1787a2fa428c58957e29f445bca9c6c1d8e77c41a35696ac03e83501545152d42c200c753e2810a8ad580b090582237c7a0e6923d88e566c28ad634f36274abc0c13de7baa7724c8d6dd02cab272eee342cafa65fca0d4ec2a2536fca065545e45c46ee5f8038529d6126247885a9f52425a2a5bd993522c763e5169660b30a9eb023c0ee6f4c65633590bf73c54344331eaaff6cb7e6ee181497c676ff862c512d5b93992e3ee8c109808e11cc17ccbfab01fce0ce54ee3eca09b1eef4f20ee068968a6cc2d5f8282d00c18a6526130e0b2a2bf69a64a4aca2a235fb73d9abe2f910a6d2402164f473f709e313ee13d293561c5a3bc624c055ff7d646ad73829bd663f623f014897e506c8382981d07af6d841a447599d8b4fe74e23d22721d9fb43d4ccb82f914f7e2ae5b421d8e65e002e73f07aa34afa0ba52f821016cb9bd80a3e9e005c6cde6065b42bee9852f747b2bcbd21399e4ed00a41339c8e91be1e9d15489df1f04f11b83f0852d2565c2aeebf0abae00550a05cfd5091e016f25daf68e7c0b9e306a96fa84d5838d09c1a9c96257273a8f4717da903cabe2bb7377bab2b05334a539276020adbbeeb26ed1be85f712cadcf0102cb4d4e178c81e2ad712627be737ff36ebb8c6f14ccc91c3deaa1e1081cd51d4c944982f6d29c25a6e13c14fe6829ab739e43cd2fbf6907194d69229bd6f1cdb406c6f1263be0a3a061380756690d9b4a9fd934d822955e95eb38b9ea9742c65b03820f011453934556e173e1dc41c82e9ddd493d11037cbd17d51b10b0aacc1377338986b45deec1f4b5199c9a44f74e2418077b4d88a2ab50d82fde890395ad1551e1b25c9c6795d12bc07956d73ca6e91446ecff246a0a99dc5f6588499313c5574f19474fc5bf6052410c22b2c4f7da76ad4fae4c706eefce6a452b63c16c15470a80537f3e2d3e6fa68447434d44ba13c021902dc0d0103f52543e842624406b6052cc3d99947b64cd7f786e5c765783351db92f6be16adddbc4cee81c5ca382beedf84421deab58b66844f66e90e98c4235110fb18003e06e2f80b06b2402f9feef2b145909270fd4b807edeb2e490c57211c02cf2614c5cac9149fca7d7d5ad03419cb72b860f12516940a5af459bdb2be1f7f1d788e1cc6650c76ff1a47bc712bfd8bd35739cebcdcfd1db1fdf1c79e1fcea2b5fd0bb9ef31a5ae7b212bd77f68effe4bf2c32d965d44cf670bbcda5bac6a7b062c2b1e3a92c3f02f180297af52b761456b74729d888358e992b9e64e402b21e65539e74f3036e4be16eece844417ea63d18c21ac0bc99cbb2405d2960d60a68626c1cc353040243ef377b3e51b651799bcb657a5b49493300acb1a75dcb090f5d177f7f716dad906515b7c2a8f41d9a485d5eb158780ae90151dd909002ba172853b07c39ea282f4a48c4d1fc6c1acac4ecef66ad7abcfaad95c110fd70abd12af780664f19d89d3f8f508d0f7810ed3ef2c50cce9117d57e6007fe5013127aaec4dc0759065764d5031123157e7b0fa93bfc7b34e0117935e075c16f2dc6946ba71a82ca38cae1621fd494295496e2401d2735b2af2955a8f4f05a684411e1be83bea6476cfd6674375ec9d65c60fcd9ecab145b04f9b51db9c8e8dd23bea9169e8241550fa4470083f9de5e1e2473d7fbf535ec907cdf56a59193925ef72e559544044fb0792f80671afd174c2df63b61fae89daa8a1209770f12ea001d85b4627b32b585626cc14da729c59191d368bd5501fcdc05f79ca30d84844825107276faf99ade8f97e907eea6db00fb487a31f43985bef9e4fc7ce5cd38c514a3bb9760abdd6f27b4391863b2dab4fecef4b25beed9b98b5f312d92512aaa60b10e063a821ede93ab14804ef98a1165058795a3ff626e340a3e3355008b9c64f6b1ef5a391655419f41c5bc2816739e0b640c9d28d2f145cdb2f788fcdff77545c39119fe45134c8f833388596bd5d89847c2692f987831b9252e77b414086229ec45c001422c976b7e40f61493bc8ffaaffdf2ed15de4511fa7e765904d44def74306941af8ad0d7fdf9e0bc9de97b96e69b1c1f0208d9230f799f4422f1d0b639ce3e7c48db6d67921c87899c28a7d32b4f4c6aabe7c23dc12df21dca070668d1ff7daba12805ad51e3ebce279dea2ba0bbdc36557b19ff865a3fe6a291fc71344090e18d268f2969c911da2f39ed444339b7817f8e223b5bdae15a9ef2538b3aa4c25c3ef19086d6587cfe3625563a1a48cc4311a69427bc604532ec9d6fb66c3d4f838f1c2f65155a3a7bb91657f2501b72727527ef00580e5d3d943d7ef331a5fc624ecf32bb2b3987309bc291b684b4b1faf027485a269c34c1b92f280098b1890db7fca12776f44d6ffe3b54551cb84f9b5ccce04ab1944a13fde4ffc792b91d75e68821917c264ef8f8ed1ec81bc1cac0a75cd1308b6d5d2d84ed1d9557b949267e9c3ab8a6987cf7b56228cad455a653ecbabc0e63048649546d0255389b56c950c4d2f1e00ca57101bae86c83af9049d92a4697058fdcea959ed8d3fe62d0419b30531bc7289c198b703d7cc05a54ac51b1dae3b90e0c8f99edffc6229943aa94c4aa9529d07df7b20da6c7c4e47d201e9729f3b0e905c9af95c945665f1bda4a1861d97aa388bc8038d7bdd129db51613d686ed12345655e05223b4e4f4d3b8ef24e58ff90acbb23620929e17790eafad702f0aaedee2a7591c1b84423f7b032310bcb6dc9e2278f5e672c3a61967f5952231e54a8489c11c1da8faca49f2fa1b7ad975a4df24fd7d6104a09219aa27ab61774abf601a241bcb916ed1d84063017707cd25d5cf524bdc29c0973f0cb7ef03f1a2e8b7a7565a96ef4cf2a6de5f529e78862b82f08ee173c5bc9fe66b78aadf26bdbdd2852811c4569d407e36596ff9e99fa98f715e9a823c6f4854aaf4127120b6233aadec73a9f768ca8ce4c8fb817210506f2c0f1afdc7ca9bc29a43ebe440238c2e8eb80e02f63d98dc952ac787695f3b2e966236cb1a71f44a30adbda2aed09051627c3b4f0c6c8fc3274f1652b4ea6fc0d5db9c2859fc6be114dd21115c1833cbddd8a0903080d83266d5dceb9fa5dde1f4002e676c5c54117781a92ef84aaa84413b9877e31f980b91994414b22674423d060fcb2a4421fc6c9de2caac306359d934701c51ee4c98b78ea80715236b7d1e909ef4deaf37ad35cb939858b5f6a220241c8ce87570aa2c9bf1d1e361a7beab933601ea5535ad84460bd6f9fdc629e97a17eb1cc55d70d047cda0da9b067971f3c1b14b0d97953cd9e70bb0b9980066a769d5ee337380b7b1b7b47597ea9752e49539198e127a39e9c8f5c5e618871e45ad7428a2e6add34c03564dc283b068d6051366a0f49ae6114148c5a5b35c293df8c18de0b73af73004ffe7c355ae2bf2d3ade13389b436ccd287341dec90c8de79e7b8de1bab2295c04630a9999483dcb64dac595f217e0288bd52bd499e35de3995ca21b50c47401d6e572951ab531b5070dff35c90be27d661311776bfe593cf063233cdac108d9ba516892553617e88802a5f40fd873f02831760fbcdeeb40d167d7dd3d9fd465d1919d504a2825f7a506cc19bbf34a627ce67ae655d5e51bba55191135907f4119ab7f290f38c53359b6fd00be3366416a2145001bb06d7699efbf7fee509e38ba5a95ab6cf3ccb3441fb5153bbdbc2868e0a3a69a9c81fb15363cf15b2e4040d1d866bf44f2cf5a64204dd743cedc64a225961fb938852cb9331e2be7df51240d9ae2fbdd654dcfc02d07edac525c1d086cf56da1394b7cf95fd96d25cf96af52f3d1fd48cb500266686fc90c0e04525b388d3e1657e46f20df48bc85f2ba6ac1d300acda14032546607004db3b229cdaedd6b8c52affe8bdf2598b2a5d33f84c685846e949736ddfd78d49a85275024c0babfdf06816661f8d2d735491b7c0aa07eeb6ae243c321ac5cf7bca00443b3396eb578f10c63b28766b90df30d5cd6a375fc246395cecc38be16fc9e25b06519a93d470fa9c431f85ee7e2cc097bf5af5baa7caedfb50b50152e4353a342dd3d8ee4187b029dd48190b27a3fb9e4c8c34dea5cec5ff784f8fba64ede73b12c3909bedd50e0a9a0d369d7056827cb15e92ec2f7f62ff095a029dca7156c7216491d39dbfbf9c88f3fb5ad095627c6878b66550a3d6bee60246f1a52468249f5d5ef9b461dda2158ac3f4bd5cc87571715492032f258ab5d03cba97fc3484c6cdb0981371f71b7c981298453cd7d60a2dc06e7335b27cb8793b01ad2be26a888a5b94066c2154849740c7eac271883028148c30fed73579b3efd4aaf1021ed63a0b1423f5323b2ae7d77b5e3130f4dc3473b8b41b052b8946aa37a46fd49c0cf3f8d207007d1105681927450adbfa9e131f6474b02cbfb2b8d1cac992c553c69212a9e12461c878f58c662cb28c82605292a0de1a85cb46238bdec587078dfd52d9864233e9fac5dd32bd6d6248e7a179bbec8c1351356481a22b765568e4e0a08e6c11575a8d9147bb2b349b1af91271c56f67052be7e9988482501ea29917e240d44548d57216e4aa21ad93ad5a5f88b48effba5522b460ae3ee43aced552c1e27538435d1a122363fa08a95e8a8d0bfe74de48bb003aa309c5e769327a651bd59a461b3253972018b19566503451ae92f25b255a38ae21077f2a8b8479456d484f01766ca8baca87e1a4d04a484aa38c336dff3df5881e00fb5a2908645326eecbfe6c4728da726d3446ecb3595d2e30806b1c90f50c0ccbb3facda034f4a3513de5ebc4072e2ea30bc56ac49535f0349d19afe06dfb511fca02f5336f12d67a2fc988edae760ae0018e326783de3687278b898584e6c4e7546f7f0ae35affc55c0300f56c77eb3e6951f3ee2c82fbca5ceace23e03f293f422bc88bca53ca133acfb266e35ecd9ba409f946a2bc99797e6063ca3ea7ba010f3e40fe4d45053cea4a357bbb6b2ad2395efb340e33cb3493a744353cf1001a8645679c58609838fc2eff4e5db824e93bfe56916d61610553940e9197a36ae14da5b992bd894d4a4305f424da7e73bfa98b3d85a5a0b73addeb56c71c42a0507fff1b7320df2416d0129cce1fe80c9865a129d3979080991deeb0e0d32a5abf1ddd9d173e7b5a01c485a70e1d1c07063c02af3b6ebdb24b3170ab291bb38337cf1a6b4412eb2cc72c427306b1b120f2fb74ec3697b8379ae911cd741743f036629e72f53443763cbc6cbbd639b0ef5c77b433ed14682561c7940736f3049863a089ba90774b0dcff1ea7f8ae7ea9285d264a6014da6b73e25329e3ee455d0d8534001bc17109232e47de5bd786af751e1a17ed31311f7b1d07fb85cdc50c84bcea15989b68570aa607e428b2f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
