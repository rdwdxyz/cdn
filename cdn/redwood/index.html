<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25075177b8b4e8617018be57a0a363cd7da2ebee2ecc0ee0d09f7f3ffea2a8252799d14ec66dd8a1c687ca2a01149dac79de59c2b3a4adafb184892c722c293ad72f640b11b1ded5dbf5178fcb469545781a2904f9f47b86c075f2338cec1ee3cf372e80a50bf76333564eb205577af83923a25640c057d1c0349ae7a6b0d7c180420101f0ada47e255187826d7672e55e93d9b662883ef6492aaeb1f0b64c96d6b4f3512cb943e345481df82c35ee910341642b90c8a1aa0a83c82cba14bb985964290b7b41f0bf6dab8018dc76f2ea6cf9609d8d37b44e53740fd49d2d5863d4f6aa11f122fa462f72b19769b12196a2c51f9ca57b51696a56d14c147631584f608a2006beeb2ddb1c67bef6f0adc806b8594a19f2e0e575f47f11c30e232a79b273e8c87f99a89ed554d3c1e7763aa68418c54891676f1a01681e51e47ec2e3794705f4111fbcd8cd6ff8a9a855a2ca16fb315f8069f0ecae21718e5a8552f60b5f2f5f57846e26754e2bc3129a881d107d9f3ed61f84137b95161bac52fb1d0f3881e7eb2f380f373d3914b88826ecb423414cc3a534956f6c57574a4bc67c1a2fe092cb9d9b8107f8a5cda6a7ed004c7acc3392fbc7c38e9d75aea36e545a9d73e187ee66751d5701274883b76374eafd32236d3ff865a228b11031c83234cbec0c02fbec720cf3f120bc0e966fe88b0a6ef58c24e9f3f340961461afbb21aa433d3d439fed9375783d71fdebe820eefdb3b0dc935233252b383592c8fc5ff3b6cfa7020beb0ba0e8c925c6815f81b9b1d01b84968238c3c9bd08797f96c1fd64aa2e0da07c3be5e3f984b911d0112887b4f7606e9eeb495d3080b0baf2c3443faf9c3bad425a312a2dad01f35c0c1a74a08eb4f41484a53c383bcb8bdf83fb6b5fa4fb5b3786d3721b44521395e99e812e940fc64215b6dbe9e27674b015ffe4fc4a1b25dd9a9db5059f0fc230da4036b6c3d8e94b3c07538c40814aeb68d1019e6ba9d2e335f81b1b3410fc71c4bcd783985a079a5c19d35cf8fd7c97df1109e72a73481a46ef9c6cb9b3abc25b3fd3456325dcecf5beb6ef72212c8b7b1edb1e1ee2f7940ccd3fa2ce9b8145ca0e89b0ec7c1e64b7a7be1d674a9880a811a048d34a253d05cd2a3c15b7a3d8aee2a75e7a75fc4dcfc2b4395506325fb6be5b7b92c9c9cc131cd517479984204a7524e6c43d6703c0f1ce08dbcc5ccfaa2556fccbd1162cad18999c136758fe288867a235b4169bd21c2298b186249d144b2d68d3b793b061a2c9ce574a03c0c713ea225c44306e4c0e8654bf5114065b11b74d9126693f046de55bb6f4230d1401236b922719c35076b80f1da39319f861ebd78506f68b9b515c6abf0fcc23dba0662b1ea81d255105f540fb69f6b4039e2c1874d5bcfa004127a5f247880f18730672fda008608fd30809e9a2cf948997e0aea1c79b8d6959b02d07e93255c1631f61cd47559d2696d3319202be5b495d5bc5d9d72492653e2f6f90be7a48239909d77f20507f846f56bbc8b5271f9d7c4c0b9d1927b65dcdeb2d8a3ae5c2d5e941ed4939216742239ec682573e452f8c0be02d78d9071504525646aad7be0f034c918319d6f5e324fe432046c0e5a6ec96979a31b647240b16d9c148c7747ff4abe8a6ff336b9b50244650dfb7508a6961f0a21e531ba5ff3b9f1b5a091eed318075ba18e73542017cfcbf52751545e15be6d5967ef8996514fd7f8b1904e777dac722ab8fabb3df8e639e4665c94732da368ad2d325f3d33177928f61a894a9694ad1e00467aa9c37b51ebee8b2c451f4871a790e257a1501eb57e85406f0055fed09e2c10b6e846e5b2ee0d745d56a221d472dbaf38dd760c3c8878fa491971e845dbd94e9634af6dadbdc2a7c736fba06ed4ff8521fc8125b5c7cd61a2ee0b12c5cef6829d92d153e500e2eab91ac752a3eceacacd7e4afb1aa633e56bb8ee6b2ed6d805e343fd78f1ee2118f01eaab7cf08e7ada566b02e47a79ab3788e6c11d65f03f3c8478c9168390753bf8e164e380688d400ca92a14b71d14233075af0b293e554a3051ae446a668184d94986f1139bb6c0388cf148aede2bdf3142141e46df808bd480c473e3a543abb4c4ca07d8f8235fa4ca75589f6d7e7185db79ef3e6038eb9bc12c3d853e522b4aae6b1c36bf61ba40f3bf99e5fd72da56386f67ca067857450912f51a9f1982f45226cf49792e17abc19326cbb1e92f26d461fc43af8cf224b8dcc2d2f6f81a308b5040954944b914b266e4f4dfab34b0ece88f06e179863197548c0872d171886e23246254044df600b982d8ef6d712c754cd3b8548ca17ade733de3f0a5c2418ac0b8de69fe8c56eb2e0c1fc96aee7cfbee43f122636072fd02668b664a7eee98bf1ad1c3538dc4fc8925d3c7a2e93c9f0028b170354a1445243d3bbc4d76be38ad7c5c41e4716cde5a256ed199dc79b52c484ead7a756e373fa191fd44bce7f467d332441d41c631755ceacb458be6259125548423f0580036ad943fd3d94710b3b00475142933c535d65453895f9b8168deddefadb6ae6a77bdea36c4374a3bdf38a7820531088224d1e1411b5a044c49a438e4e2aff45c89d09b3ea4875695a1f6c1c633f1aa95d86afc1cbe0f34c61f4176d7723ccb51bb6fe70ff36c7132eff3c786065d8ef52e8a1c071ad28f00881ab6e6aff2efc429c0e4be20cbf01dc650fed0fcf777e1386e4d7a1957eb620cdb2a56a3d3b2319bb9452958a90d6a0751245b58143aa5467180274b7570bf1acc9b5e336ca15a10b81421f05c3b9d462487a239e29f86d196b73e28dd43a882083ffe1b19ad005a087a2297a0162365aec7b89e8207576191b81c2a2a37183a957eb5bd2817381e339183e6c89f78e483d3bf97a3b53941fc02aa72c8b1cf10ee381d5da0de83172882b407b427411d260009458056c3396b7be9b4c877d4990e7e6b76a04546506daa27bf622817ce43000f26e859dd14af40fffb7a54bd86d7ba0846e97311c84e800877b1cd4f448bff84d8044ca3e13b5551de85262c24db0b44ed4302f646dba89d9f10cde7706417d8ea8ca6c897dbed31512f2e6eb5ac5ed5f1ad6cd2622417dffab6bf24ac60d07a2381fffbf45f72588ac81f0e61ae751ee10e37acd92c39b10d3866ef288ef94c7b0d3e4af9c4cfe9faaddb50e2a31d3e05e4be252a0616ce731087ca619ac27a8c76dea26e793752ac82e55aa3127aa630b09fa068084eb22de9fc1075f1ef2bd41c9db63905c24918f9c9c0241e0603934403e2c327be51e1b033fe003fc1156079ce89c4d7ae3f91cc8445cc9313077d90da2ee1bef39d0625d0643bca8cf6987afbeb0d1afb28f74e4ac45c113c92497f19aa8cc37a946fe0f0d68d9f263bc2f839269631338c9179c93377f535f00077f07184040834da2e6340e6b4ad76aca8d03139d1ca2df7e3bcc7698a40ed98aa4841ab21342f2a3ee154ce46d27878945d74a85cf7526037844cd57f6dbdfd3846510173a2095b147dd6a1db9d65e78e07966b46f64892fc5d68dc847cb15485369e34feebf5314dae089f465f8bad2f5cdfc01e090d7adc5402e9169b3d617590b9617a63686cc1f52eb31ddfac9a2dd7d9fabfefb928159bf825c9c76bfeaaa62e68e287dc8569b27e499617ce3f1ae5a9f24dcb0a0152b315e54bc63da7ff9d4111d89cd070cd0de6faa1d7860153ee33c34b94c9336c0e4f81e66077d84f742d8af2f1c90b8266b245569399c4464f4eee72231696fdde4f2ef81c4ba0fe92c7060fb18e94d97d917ae097c9449b5fe95ed583e297d081493d670166fc04b2d223bda27e3b18462057cd5254e77f3b5dfd63cba56ef3e51cbd310b2ae13f6dc14e178eb8f1bf26fe003efaf2eaece629f76fd8c72b1693b1caae131c562971d4b9c5e09687b5d24f42bd5dfc380baa8ff280b4cc625e3b298242953d62f5f6b0694ffdea04a870a28dfc8d3e6d79151d93b2f0dba941e8b41c1ba6294c9128028eb0097ef1e531c0029037698364b751f00949c9705614e5b1713467bcc4d1df7df27ae3a8155995631fa4b771ee864bcd45f34e0eb9f31dfc6b7fb646798a8daacba972536bbd7406342136c682baa2212c7a9148137d9a156bbb2ee8328b99de9a30ee01a640eaa979666d96f19987e21dd6cdfca1728e2ab2a5ec076a958f2ea58ca0003d7ad14249fcce1f9379d9ab1a443c1f856e34275cff0dca33ffc33e5bbca29e96d5b5507f49045fb84de83c4887b3d9925efe668ed98744991495ec17bf8c0b5feacc3d08975ae30598601fd38415b335ce0d136949b70ff3523395042d181b248229d7def51c622ca83c7162093d66cdea0e73ab237da35f3edb61f4402dae427e22ef55fdebf78994a807cad8c642015da3610e026491e6b550f0701c1fbf056b1170a2dcbc08f4a32c17ac69638c8b41cd0f3bcc5354a6810ceed6c7f4dc9832eba82f6c48f0b0451705ba4d46aaf87e96cecc3f57c39dc04b69c58397b5f17e0190ad44dfa3710e3fc6605c5c18339f64cd1550087651032f5c0717b4cf7de298452e39ce69e2d616f3a569a5ad14e9424d630890cceee0a80f9bc94fe986cb97f865ed13adcc3cd6fb47082ee6bd820af4c33a9aa2cced2dafddacf56825e0bc2943ab7a838d6ae4ca54f04203d6b4518a9a997dba50b2c9b87862a30dab3bda76109522c886536d0782a2a0df6971eeb9e0bf4570d037661ac2d8a9e2e5c5c2bde484a5bcb6dcfc77ad4fd56fa0f436754b75af84c67c8e6cd2b4ae534f4fac9d285497f385da7db0c3749bda492f4587e7098311871e1e12ae6f5825b52d09f0e6d9216c1aa6c2e13b2881a2328c44a9ad79fec77e453a1cca36774aa5879a53c53cb819ed753507740889858eaecf122d8a8e61e018023297456ac7c8ae526a26489aaff8e638c34331c87ff95542fd5dba0a19c02b39d46fec037163745789ae8873c351f8beca46c97220348cb9e61900129cb2063408201c02e37b14c60f2a35fe144a2032f2e0c3ea289d727abbb39a7e883c703c062543fc6f10ff5b282f4175526235c5401842b04c9d5d7257d4d1e08cec8570c1269e300696a15630dbf3b352a275d858ac355d0a898bef6f5e11ac26a261a703fcad115609640f7601a382059b2834b030987532a21b4264ac2b8589f778abb0c68c649920bda2ec8e5a8e8045ff695baef7d0e0d74ea0571cbb4ffac5d45ab66f8496958c1e6c15766489387f59f6f6073c2135d47fb6b03fdfc3dbe8ca3205106870db8406da955b8371ca9839cd012e6fce2e4947be2a5c394f96b907986fd1c98fe5c9829a909ba15ccb67c4e7c783d2066129425292563ccd7f4370ab9b00298abddd8c68cd869250775cbb243a8c4807ff49607d81d5fd5d19198a79de1fa751222c2f4c0bc560a2e56b9243ad219e8861283dc4a1a0fb8e7bf3942b436d0000eb67e3295ef53cdc1811ebd652c94ecfc98ed4857a9f3c2b74c0cfab9d4ecf5cca95da6f6309898de36fe5f3adcb03fd94ee17a3557a24e6e48aa1e60409fe5a90acb2b7ce491db9d8c32256f79297c71c3f6c2230158b507f939a7c5ba955ebca36b9238529ff666bf770978e3726c09c584cf5ee100d1b4ed015c68709ea74bc09f8368fc0c324aa8ca6a19f654544f79d16db0060abeffe83b4ee42c197c694eb6a15d945373c2e99eecaf91d6c9d0a9564c0db5d106dd55f9f2f95faa054868f7e03d33bc21af7732ed2e1571f6da3741029134223a9914f7c3355937cf95188ac626577ca5110c02e607b66b768f6258aef2a7dfb4a996c561ac663e085c69db2f07c70c86fe8ca7299428b084818dc0f8cc8316adf725f3d9f83596d0147aebd8a4ea62f4fa5d1c80e32d8c3aa522c33319a5688a6b469bdd56a0a61d847537d0212c84b70b3376672146f9eab76809df812a8bedda7ad5ddfaff4b077a3da289da17a2a377e5f6221ee761872b59fb652252b465d602c95a69a1820de81b4e40170178fb787891e79c4d6eb3249f197446bb5f57663f57f93dc72db1792321206737237b92d5a8196c9e8b1fc0faeff01de7fd72ad7a07ea273ed48b049dae4052f2a90f1bc7e928343e4db1f0d7cd47e3f3143d4010839543573aef38c2f467177becb637d2c935bc5a8b2f149d104fe0134ef6a2b53253a2269e0d2d34a15d74378eca628d426068d392f03676d022eadced987f874c664933748b34c7ff1d0328b6b0fb125ec605b551117d9f857b1813c02f5b4437397f9efde3b42215178a1d730d5945ff096c02ca5e4ad92ccb2d47e566fce06e57f92a874d15dada1894e6dc9be9fc509898c1be87e482817b7161ea89ff4d59944b470eee0d16aedbb0f33a0f44a413aef22cb5ce16d625cdfbecb6acf173c3181f3884924d35214f411545e8b673e71c1dc0fe61a5557339c8a190d65b8d5318c15d8d797f2755675c0c57bd3bcc693531cdcd93b4a7a87266619e88f9e937bc7279ce3ae1afb87e3e9cd2101008ed1fc613d3724d955cb21269e831cc0ec8c9dd4b30d15d6a2d8092790806c27bc442fc33a2868f6540c776026990d6d9498a60324c824855eb3a38fbb378d776a79b661dcb36a0ac67a1d007309f4af8ab249697a200bf511e06b720f8a2474008f15fe5b3628106e379838712476125d0662af768b9f208da3c120996be59c2b6a25fb0914da0ba1292a7d3f75ae652b8ec102e70f22da4d2b9b44aed353d607de9e92ab085ae7eb337b5758c7b0ea188c24d7f6213bc2d99de029183d900105c13cc0273066f995fa5bb1cf5f5e1e5e86832b019ea09422927e57fe824fd99c890ba07ef4c179edd8a19b10fe3aefe43d5884c7f2a619a4f364b85acfd2cc0461fde941df2941d0a28941fc40024a4ca5f883dd52b7d68eaccada4f5809fc7d36c129eadd31877caf5b0f051bcbf7d78ed89d08109e8851a9f5b2fed82dd7e0fd94ef99dccccee6db641944b1f231183d623b4d90dab36d9e1079fddd39a339a51b8e5813b6aebcaac1e4e3c48518c0a3a0d138c177cd0dfd6db4543563cb22a7497eafac09200fc3689ed7e099160fb57bf6965045ca336aa904bc5e52cb5020d001c25afa8f546bfbc9c8e76a7a1b4573b7952fe00a0642efd0cbe94c4e88ea2252c3d7f5420b038f79f0e4d4d03f2d732ec29a6012cd4671a10b179fc68b0677d069ad37c8d6d4137182e9bb716c1fb3c13b5e00d5fe62804441b3feedd2bacb00f8c6815eb60b638e1e816876817f7d21e251f17b4660e341fb8bab13c50886d4af9aac85b2601e8703d1c211a1e1e0fd4cc4a43fa5393aa6b1010aeebc58f82489b744359e6db32ac05abab122d39d7bd282b714070753bc5ff521ac9ff4ca7d088d3c605cc75e731efb3936f794d933a1e15424eebd108a9697b4fb774ff01c1251b9e8e69ec2604c6ac926525f2a154a47c69283c1e6106fc05e91641504d7f32d1195169baf0c776880874f5f4683edf7a7e8c382a874d98f98c3da05589baed90785cb1c8f2a6cc7e8b0cf750b192a42c4d9f30f8332b9734f0f9dee558abd88088db59f2ae93ab504e28d6a4bd9f224b1c33a2617ef1353dabede2a5b4ded39ce6036be3c61b181139f52bfe5d9a70f0e5c3ee8ce62e1a2d9edd9fb2c944353e8b9346c8a821d3526839e7123d35c1864fa05d930e6bec260d5259a787cc92ff04e1169b531b9e723664a5e922bd18caa0ce0d00fcedec755bfae8d5b69bca011cf1fc012c43ce86bf6cdbb5c0da1eaa6537569ce1da1929b5434cf583a2c761af7d047a34904fced6087eb07c33f6d112358af1e6226d11d78334eca4738d77e0dec9b98e605bf26204d1c54af767d4ad302be589496070df30eebd2fec7d67902c655397f8bad81ecea7dd7d3ca4d7c4a72c7fcf619d0a30ec292a7ed3fb0952063050a61f16f517b12bae25464a64e5b29d4c4811356d606735cf7e42cba6a345e2f4d97ccdb4bfaedf8ecf3151fad3d0fac1e2bd0c6467510c3f6c75167c1ad6dd9e453c1291d05c664a165a70a8126ec3edb09eb3ebcb98fba6c30ad5055c083ba1db01dc21dac0f260e56002360132d911064eaf154696e5df6b9195df5fb97d6c3f8e2d120056b883a05c67361739da7cd63205e83b4a371dc8e74e10415dd30a541715c5d9a61634fb8decbcc2fe5b8f2167bc3a6e85c9f0e027aa929a2e405cd8a6579269fc4fd5139fed7171f67d9ae62fe97bb074b62d94e62552b49e8cbf336b494c8b5092c72f6f66e9511af6e50367118eb960ac311518ea96012dea7c6c82e4b75e258f44d0c300f38248392666ab5508ba6a5ba11d0c8a4d1c34d802fec0245eb9b624f9dd47d68af2a0870caf0ef25ee30826c288fc38b15f60b7c006e318562e96795332ccc0191e5bf62a70e6f639464c8be5cde18cb67426c02b84603cfbc3f5f2b906555ccc59a6e44cdf58c056e3cea6333ebda039e15448d4cdb96819298fe2a1eecf6f03004e7e669196dcc0a77f9e195a1cad01e3eee8f534d389c0393b826fbb515b7eaa4f2704e18a16b1deb5cd7190190db8c8fb3947baab95550dab7911103656a83a86bdf3b12409e8b3ff17dc1dfac4805801ae83413489b84c0bade97a86db7c9de59e72ad0c1fd42cc34cf7fbb005664a098b06aa4d32dd0cccee4797427eb82fd4b0777dfd333ba3dc5f4ba0f513d1bab8a37a87002ec8aefceef6d0769d508e288e46b5771cc67b4df9ffbb013cf91302c005b4f4fc89829b0a9daa626e915ec1db9b1bac2535007fe7aadcf7b7b8548633653671d9e6f1d2abe995c39446002f222e8ce36bd6e1a554f866d8047fb31cbee99c52d96a42f343f241bd5e0b2c62e6d26885168465581cacee148cc057cfd221f1c6c52f6692d7d15b9d732faf12597eefe284f9e7cb6277e4e6662803a56238aa88e8a35d41245444b875654dd8df6c98a43a2f584e82c7de72a08098f6196ec97b9a93b5093ad8f21a9ef993380211f3556964cb136e91b26d9b63a6c8d01ea6b96d6c5e3985add9ea00bbc2547ddc2500defed85244edf54544b5ee819059cfcad2cad8884f0c9564bd7125fa11ce14f475860218cd88e4f9fdf99b26cc5f5f6f2ca4f5003facf8793bfac17e29c8ee353859c18187a88e1c3228e89499305413167ea10cb941cdac9fdd09ea4cefa27a2e5024647ac3d10da6aa12c36be476b295cd41e4ad9a89fa24f6a81453af3d37034a709edb58cb1cf440d3706255d93d3b218891ad6c49e87e58e54ea13cefe78649e17c81285db8143ab9ac95b55d7a2e5a9c95a10b05ba2d9a62f22e72b8d0bee6502602af54d61118dfe7f8780a44c299e83f54ce1a55a459909a6883652cbbd81729b06be2c9a36159f2ebb7285ee4c9f7a5bc88b8fe537c4404e3947f2fc6d0b90f63770154eb93b95472363bb11b3218d5e78e6ecac1fd47fb699b6ec6478fbc96bb0e4007aec27a1920def8e1534de28d5de0f8e4d87771e4717e3b6c0c5759ef8c300d04cb4c56d242af8e6526d487af53da164ac0ed9d060c17517fed8303ff066830e742592f01d17697bf4b7bb97f2fa5d02008ce909b71cb4244d9234305b3781b36cf8d4a5d246ff2c7b572b02c82c33ebbc678e230a774b35e109f7430563a0aebea38bc35fc6340c7ca2abcce4c3d5f1689cf1ab579f49e02a9f945905f579fcfab82e557ebd0965698d3320af5d08f528c1569e0f39b15b4478cc745bb858d131551b22421e438984ec1210284ac48a3b6ce513de8d129dd70bb94de7139411d776c10662f1284093bf05e202718d5782c067210c948fdd8a0c4760aa763cdd00d1be0f8f994441467b80fa1edfe50941b88a7ae17dc9e9be219f165aad1056c80ae4632a7abb065030b248b5e937ce9ac2988964bfee15e5701ef7f243ef063d6cef330b81793cef516939b3383765d8c223bd9e8e0054c38d15ed20adeab42851bf6b75c8e7ebfce619254348dc63220732872b789ad4b2dd054865355d18f7401dcf7e87c5bfe4d0ff33dc85f5a77dca6f7525cf6ca329a2365627bd9b736ccf2e85ab33980e41d4a930dfc20eead4739201719042d29f4078a13daa5321baa1895a60556f8d370f4417683624dc466c0ef68662247e6e8ad45da3741ebcb19a8278e57cd3f70ce4346fb9b416b3301ee5879926f015c8438b2dc4c6f3d4164895276e594b26d0fc5d030132021e2d7ef2e253ae90f1c64d387da936751a7b2dc75f0b430f42108c91b3048d46c643e55bc5b774cafa776f5561ba6e98d87227f2c87fb8b6c7e5e9dc63efb2d0840597b83fc502d696435861b2ba29cbde4507b417a842dfa3b58f1bcb0dcf656c7a9245f8e0af22955652a7f41c57bd7d7476464cacde3d3f4c765d9de33958fecd495fc9b434e5eca7a2bff9c40499dda4ef13e9d9d4db16d09dae025efe1f9daaabd94b4144072c9d3289c168b106740d9481d1cfa20b5358ad3371d5493519eeb7a8e39ecebf085bb56164bceddbf0b62591a53ab2a973bcf1a6fc99abd069ac24be24294ced2f417628968e8455659b6baf0374ee8fcd195285eb88652a5709c736789a1e5ac926c852ce1499808b01c90855f32c9249e911cc9eba666704fd871718f05dc358d43d23ca15e143ed5af83d12e3c473bc9c3d2faefd457511395eb59d58c22b04dc7b957a3999b50c963deec937d6bf36d4d4bb8203f47382fcafd91b2f1baa72c853689b64aaac03b14b8ff9da1cd9d87d0fed51b19a36df8c1501993f9356dc597eca9d3391cc7311c6393b2db8745ee720050c717efbd1126962e92f3efee354fcf3271621e5d149cf30f58799a19316e6976133b1c3623deb54ab16c7104a7eb8c33264cd3c9fe6e0d3a90b695f315025a01e70fa1b60b0aea198aad43cfe8aae087294d5e0e3e3414621f7a035c8962ebba1ab02893ebe25f880917d1fb5758816492661a7d831d47d5decfd7f4c89486d023b6024ea06c2340835950c4ea3c7ce9121ee5690fd3dac15fa96799047aaff454562ab2e718b742133f8deb8fcb80a4e129df5457458fc0854dfadb8af01318c633fec4a9c669ef77690d37dd75cab249352efdb95824b8201eb3e3cdec313bebecb24ae6acfbd089e90099be9cf61939be48d639d8567d94f8fcb69effed87f4900c42109fc7dcfeef48349f1440b6422f04808827cd91ef72d2d5abef34a1ee90abc77cdf05b66fa9690424bf12d44b07130320961438922a13b5884570494795469de19d244e4ed8af7ee99d92a3c1c09a68053fff8192a4115581d55e2d877404cc2079cae47297fc6c7a7f67525579022725f4eb2e8617524b59b0908c97a2001c5698805a74231279f98b17ab484d8837f64c76fe32acad1ff6746f0bee20f0712326c2745556690284aaaf93395bfc9fedde1c7d9496887028e5755d76f87a1c10d22b63b527e3c45f806ea8f172c81af8515e06edadb59409913c3d819f59348df9da6e76719c658b4a11a276763a9aba251d9ad5303e8efb495347b2aeb48fd9d59d6ebe66adcb65910155907ecb0e80f8d0b2dd375cfdc256e81cd87cceca556cb6cee21e9fa6e2018564dbbd01f1aaa9b7c8ee9923a5d5200a0d2f3021a1f64bfcd255ba144708c3eb3cdbf91a4a806acc289fe82400d3c77161e557930c7df5bb4d0934eaf6d4912b08de17d22bec5e034a0fe4befd17158c14b100499114373cd18ba88223c977e9b22410ac60cc251b540c2c686d5431cd912b9cbd15a2e5c8e54ba4770c6f011d8f3a28a5ad96e6e0cb27a0dd90fbda8e062a486f0141c09d3a53e6d7496061cb426a20e103f42c0536c9fd2da5e7f7dea8245a75cde3a2a79b77d39ad4be169019d8364d2c44c41de2142597720828c2dd269e2dc08bb1ed8d4a42022df2157244d85f210a8f6e34f1822376516f490e1ab15521413ceed6bf0dbbf2efacbe44cd68562d3e432baf84e18dadbfcfa04528cc7d41fa1526cc4bfe697be4ad09ba410b6abd4c96a2098edd744ed19fbaa029eb53d116cacafdbad368d65cb7d70b329991add00d139a901286973a5cfdb0f108cfc636e5bebc5ed7b1028897dc7a1626cb7118585373164a15e9646c340999c36a9a8723fa47d705e62efcc8fe6d5222ec306a9579f27dc9a6b98686aa155d69198201c4aa5de0bf548d62edb64647793d6c42362937afaeee25d2528d4cbf3f2fbba1cf500a4031a2fc1b38482d9b691a533992d5b4d186a72f14d64cd8dc5eba95b92369b452fee6712b7137ee41cae543931312880eb6bc30e8e4d2b4b9fe3bd1d5d7dedc85d5e2725ef9dccaeea1ec03cb2f03b608c2fe09938ae9c895ad993a08543af89619d0e0e0004205690b9d331d2e305159f9b9acc4826c29994d5a5f73362c06e4ca1a7f5ec41bcadabf6dc63c50daf0734d652e56c3e807b15ae5e1d1dbe3f267e7d2b6c3ab09961c5b983a6e04881d3e848100e0e108c7faf151de03126c76a5bc897d010d587b302f8133cef663af40f435003656ac5b2298b586ec71b0147ac7c8149124da09d4133365f42cb2dd392fe20248e942bc3a42cf3ea19beacc553cabf533405aa8ecd677f0ee06e5bdd18c5210862ce7b6e470611d2c3bf9aabeda1649f7f412f05b36b8542c1ecd46e2643d7072a6730758c593e17545b16a77a0e6e434081beb4c4bdd00f31f2c353ac87a2ec387dc42501d33a1996e3493b1c79d61972f5e8a5f8fec015f007188998fefce71d0d63cab568caa2f651957cce2d975becb15e249297607dc6d90af3e1a4bccaea2dce8bc158c31adde51275e3f3b3be4330f944fa709efe82a003aed8d68f246c7fc447a8bf25eaaa72e2df69879f94a3835f99333b2e2cb4d34508207d63040b6ba56ce203a33a24edaa2c801060a549b5cee6ba5f28597fb96b8de107065b75bb46fd9938bda2d2f23fbd18c014055e8b1530f09ec71ddc783894479d525afeae61d449f9b0d502f67d2b92ab85ad8269755edf0d19604e043de2097f8465b9cf3c19cb7027e1268000a46c87bb536728c1dad4290510bc5b92ddcbaa8e179bfa1a53dd51f5525622d036d79ef5137d053493b2c8716a59fa6e4e0fe905e9a7b4e9604be8576545100ceed6fe6bdfd1f972a68cd89f4c6c22224bed8648aa57fc68a3c6199f804ee86a8c85f0a0d9eb18ed5c54ad522b2869fadfbcd26e4753d1b0405fe0d4a4ece03eca8da65ea5b7119c69160dc72dbca9add0393fbe1a34215e4133688d273d6c5fc4d707fab506bb936e5062e7a7b53a28a7ff301851f54d7efb6b207d02f5d3a38956afa5ab12226e1f3fae9bb0da993cc623419b8ff4ab5d27a15a8455b4a618afdef8ab5f7eaa933da11b3646c199c3782532016a0bcb9c4f5465311c8d23d85c999b847e8854926bfb06614bd84bbb7ac76d2a29759bc3be86e432c3b0d89623af67e7f9e8d9d9960d02ffc33ae0727173f31213fc5047c52956aa54c3e86a789f519a29bb48ff64ba4ee88d48e80bb921f025117703857bf36ccbe076e718f519cc5185d3c9ff9a7995a765d8feb3c950a20ff9fb027169c6a975cf80d127afa863b330e57ce213394e816d3d5b0eb226ebf0cc3802caa65499c2ff178ae2fcf8e7a7affefddec153473af9effe08c44f0f3c964d75c3922988482551cf44fd2fcedb8a0f9dbca5e7a20d5d5741c18c19dfe2ec06cd98c5adbfa79124d70d8b07f4acb8ed1e49229c167b5e8820f08e6fd603e9ebbeb1370e9db0943ca2a7599aadb8370454af12be45d9f8204c2dac1cefb41a1f86860bf2a02a898f18d0489795445889c236b06cd966f0586a7fafd8557d8f664410852284a491a6727537d9f173c0d21bb93c71b00ba098abbf531afd3e4d049cc0f3f785097e7006f11c1f6db55610edea9db3cdaac292ef0b361072617f7d5a2471448ffe22f7c6766325448801d219b53115494d7e4be3e986841842f317cf65d614fbbd18b06bc4abc454b8d9151c9b766765cfe49caca312a3f4ee61ea8cc7103cd2cbfdcd34c93a4b5d0dbbc28bc807e21d1292af71bf3a8c8ea580c617e6f5f8f347b70e4385d47cc35872b25686fc0d2799237159828740473c08ac5e2df56ea61900c6c611bfd1e666fefea3751a139c82db1e861c3a6efa35eefa7b5d4aa4f5e48d70b0309fa2fb960403022e3ea1710bc8477aeafe997a6200532f54b8534f4fbe5b934c40648913e8abae6ebc76dd989196c2b95b74e5182ebc3ecdc6c2de96db4a4fe4d460aee8eeb58a282c16367662ef1a4da22a6ac9d699a342e8e6245657f89e1a0b86280040ebff3a3daff9cebf20cc33a29cf88ef831eb5c7a8785f38278d17044ddb8fdd3a409aa2c5e08e7c6c80481a1bddb3b01226878d757cb823bc809f2dbb3308ab7214bc96aafaea67483153c231af2cd584028239f8e47893e01de6b5251e775ba7268f37595ed7b83e3f9a5e3f1ad3585be42561db6431bbc48e48fc5136cc5fdbfd57ba170411170b55d635623dc849ddd406a4e30c34f65f7b91e2929bc4e21f71b032375877d7d0cba7b30e58f51905c4297d0582522c55f45fdf53eb086abbe08e6d6fc36e986f1af38e5dab626b5036b30eca4a83bea00178524b4033980f3295346723cf5764a181da6f3e085507670eeee525f1150a35155394f27cc098aa07c0f6876628e3a19bb93ce722299f0045d5e21373f3aef2bc720ec8faeb70299fd68ef2cc545dcb49f29df8b4660ea4a8e08a9627794434521ae2c4445d8f8079ca4db3c32e5dc1996e93101a405fc645901777ec3c4020c9543268a854f336ac6418a9cfa0a10c0f26d3a73b3773d136a51d9b7940f567395bd9d8f2c70208d73470d2d61230d979336bceaf076d3af017bcc3be2d13230a19b88df3123f5ae4ac71890045b61f1e66121b63493c1533dce7ef05a40f9d7a5f260341fd9b11d5b02a724ea88389bb71b17424553e71813c4abfe5de691ccce7477bc983db988328a02cf9b098c9c6bcd53eb00fb99f186ce0757593de477755b8a72cb4579cef6869d7049c5d950387365b78e6e8984e6ec77727facb1da4e6b96d5862cc4e5d6c5dd54d698cd3cc43d22bdb6a86e8ef3589a7db71af80c58a6bed634def6da7bd2fbbabb6d66efcb7cbce529804d082d4ee3eec8fbd30d4d0bfa870c269e344b36f9a2a3740880e77f1422e1bab826e81e87a96a1789c5f7377a0131877059605d1400643ad18f28e26978adfa8524ef8726e7b588f57c02750954fa75e0f3fa62e157bf801b7b63081f752319cc6395f20ce69867d251f2fba9c18dc171eaca558ba07ce5f6f48854072adb277b9849f24595bbfbff378f99355ee2a863c71b9052be43d7f24521e712a54d8a35e4376a90956bbd83c6badfd385286f58ccee79e83e611ab5f4901e5b941362d196bbee488d5be2d212b16604224f238d00f471a943f0b14488245d31d97e185b5b5c5ac375009997662abde2f3e73a2145b19be297afd8d17307f97c1a4f3309b7f3205611675265ef0536c2f5fd4a065aef2d612ed4622ac03916ce34a92a0c276d55061381f33bb85795fdda14c352342de83fb296b3cc5514e93fff5873893e4fdec38a22e1e5fe0655d5fb68d17bfcca62e00741b2c878dec73b8839f48b7ceae09be085e5886944eb46d9f4374d0d113acaf54ca7e6823e32321f3412fa0b9e126e98c71c8154cb8baa1fa99020bc019d2953dd8e7d8f13b680b59af845eae940fa2bd5ee5f922e2af5ffa8736083eb7f7df4da3819ad6b4c84a646911ef183a3624251aded5b06fcf3db8c540ef16ee31b891ca2d585d7052c01e8b79cbf911ce80404210e97acc8c88a123f9f2ab157b1454c4b879bb5a20ee04123bdbdbcb9c52d069357f5c9a890b6e52a179e21547eac16aae88e1e57054eb35b16e2f315548e16f8337023116b07b73e8b299b9deee2477950953139eade4f93337698dedf5d290a29ece16bf8238bf6b8ed83f08b8e8521a28d27a33d20eab0a110a9ba13ae0ba271d07b3bc71af00da29fcdf7f7ff9df2d867f6da2b6680e11558348010a9ea0c991bae2494c426839be949e874bfb449603340a6b93a13828aef82f8d72f4588afa94e4c5368cff0c6d30df84cafc0713d640a253095c0210a0a25a40ae13f4a8c4cf6e6f9881c508d472b8abd2006f2e368faf781bbd9864cb5f5ac43c8cb2cc95029bd9708857def1b98d54bad8d2b46ab1d016e98d62d1331fc9db24518eeae5c10e53ac54adccf3e0244975cd877366c3d5726c1234f7a6153f95fb50579c3fd605e8fdb41877b078abe5fa8af59d6f0088d674f7274751636726f8ac3e2cbd856fb9aa552a6d79a1ba0386ad0096a26ba247f9fd8de6c57d10bbbb61bf7124b7e8e49f5920ddeeb0e064a557e8978b84b20f7e1d19eea4eda6ec4e29cec0f870b947078ec8d97bbcacf964571ecc2aaf273a566582a3eac4b958976bd3b1d248ff701209a49580333f035c7195afaaf169493cf215c66d457a312d1a7e95206cf5e11f17fffc95df4efbb4e285e433223185b8560ad6729fa8cbd97b3b942a8c18c6e832b2d56001816e8d72651964b50251583925c34325748549c02d86f14f76d9c07629449623d7445dff033112636f504591e5b2a6472623ac0479a03eb7e31401bcc280330f4770ffd078c127e9902fbe891b2bfdac6152ac0e47530a4154290f6d8a76f445394cedaae4e832b1cc652f056c27539d64bd0088d14f164186282f86e739abfb0e12a0e7246d8b1d065b79d1c2c6d20112f91ff29a6498873f92666e5ea57e367f1b68456fd0caa76eb26a9c13b4023a68f3017fe143930efc9d5100a6c5c19b522cd694504687fdbae6fb4fcbe53a77d4eaafdd2d3013938e3ecf6b387d434351e6b161d04c7bd1a6e5fa946820005bcbbeb1f12f0933eeaf39a9fbb5a4cf686b81b7a85e605766fac3d1b181cdf412198befba700b3f82dd29ca0fb6178cc4fb1effd640975a86a14796ab1d9aa0257f2573198aafec6377b925ee78c9f0acfeaeacf3b23540087f89cfbd1361be72eb70a6664df51d3918106a69796f6d91098a45df25cef0f99d0c7d357142dd5d132111ff869060653224d89f891a08208ed337f289c20d61effaf4c42033c170e61ab799ae13d54c3bee50db42f8fb2cb422aaf2ac574b53db86854f01e2081a8ea4d1779cbe896591f5a9a89052c4c7ed6b4147bb31bec4315bf280f1048f5f9bda5f6ca0a145b34467873c11040a4484d3cb3b08458221afe0542a968c2ca8372eaeef53b9ba5639d2dbf0c81bdd629fcc8dd60c127fb71ff4927eaac648e80256934134d3cbc5ac18ce27026034bfbffbc72b3c36235fd3e9aeeb5e706307c815e663a867d681e66b82fa9a934a7ca24239dd73d12a7a1f9e93353b825970678af4659925c16c3c3ab00e93159bb36b912105450d972fdac457e7fd7389867404915bcb83469e74c4141173099a1ff83c87da51fa483797861216aa2343c0185b7519ef465583c8113bfb7567c69cb9c8891565ae18258993eca4ed5fe52a274c41b21f7654790fa3e773b9c225d51bb214ccae005c3005987035d9094adda4972bcb38f6f71966e4a584ff8fb6a363aeb17ff15fb449252ee17c1782d90000cf62a69e67253369d82b0ec2495857582e9791468917a2bb596847db0c47068135cac687aacd6de7d288c70a2ebfe472c261e482f540f788689b8eaf6eec6cfc0f8894d43772fae6839299a4986cffd5a9e6557b3106128845157b4d3a7c984e57d92823f31c53e17a58436e51167314189e0543706e83ddf0076a261b670792357b9aa1d2607efcbcbea54aacbc75fa1edceff269151cbb0ecca08e2791e118022cc7cdee6be267d2694bcfbcc30e25010a149219d52f5c83a1d882a19924cbe1f1010306d219283fe75b502a3c8390869e7628bf4bd667869438af7c41c15213bab64dabcc0be06cc8ae3bdfcae67c6bb67a0ffee8372ccee6b4d7353d6d885dc07f996f88524063508","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
