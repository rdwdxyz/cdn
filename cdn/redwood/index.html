<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a65b09647bcdc8c49341ded1a68a0ff88e757cb59196e401ae49edd21bde1310ad0915d49365a979f4a51a1368e63dc442a8486461c7c8389ad6473cb9c785bce775c03fa5a02738b9f08e37d51ea926c7de6c0a72e124da97d97a2e0dc877d59f1ef97b25346866ab2c7db8688103953ca8a4a4fc1248a3b53fb62efbf0853799813e541103aa86de0a81a1a68268cb0543cc4f1bd9f8c9707a0f04860e952fb9cdb347511857188459fac16f32da02fd5c854e04a41bcf282a4f2d81b64cdd7218b1e78d950158b6ea6c6fbb0b25c15efdf0dc104e41dabe38aad2ebf5a3fda78192a578269032f81e270697ee83e526b106d109719c332bc8e3d1ef3e07968ae2f0bcddec5c34aeb0bf094ab1f6308213ea4f8a013f7ddab63a229a04f282615d11e00f346a8ead4a803e6a70fdbd7532bd9b27dbdafb352132fec537d7d282243a2340fab9a49491c06aa5b0f22976edad2d5b29c2b0c9e2b0cafe30c7183af24a8a97877425988654b6ffd8a209850f526b545bec724b060d7c8dfaf0672e79f32952d97e26dab49eaf9a4ca886341bc7f6bbc95e31d0d4f196f4021ac01ff485ce4ab47bf9617fd72548e6f4b3a01558bc69ede71ccd757bcc08694c3a28049f7e64ed9cb6c1a63a57b5240a70a3e9c43174421626018848a031bf9c76cad752e5e06070b1db4b4b4430297d1fead0720b5f3f4e4a65d3baaed1cf719e925ffcf3cf8b3520b790c631a51ae1ccd7abbf24f9a6e98e8f4eb1d23fc2831faec7ff82af40988d249e659948ef078182908bc2a42bcdd66de0e363df55651cc1693e41814b7b0a5463dc6499448368e1c83e44fe419fe5d5b730ba46b152622597ee01a79169da4d19f95c55d81cf15fda524ec9f126ab81054142912ddf4da32ffbfb6f984fb4e47732506d85777342414a8710465cf3313f33d123a8d3ae86bcdf2395fba0d24ad1e93d10732481af800f29fa2eb2df3eb63ed1761db8e71790e8a6bdccff5c46423d67085954088132c69f481a4eeb52c93b8b242a3076060cea4fe0b2fb9f9453a15cd333d2d24f7bef171feb61e1b2408151e8a37211563753bf941aa780fb1685befcaf1ae9a842a2f522a1383004797b8060037828a69e9473db8c69fc26ffc69c0a79d9cb11bc72a1bba06dda5d9bbc2a12ca5cfc23184aaae799acde15bc84f259e46555e76f8ee6cbca67bbedc2da266c0baf8e1d5725132d86c332be171d0a84b11e9666a6828e3f76f8445f8a1f1ae08617a4e401e5e1989985e5722f5e8723d17ec70b806cc86da62d7e45e7843ca5ff36848912cbccd969bbfa74d9b0365c2a8bee5e010decdd6a34c5b90f0d374be53f8a4f3a97673b1dab9c478e1d17576dc2c2617dd5eaca054b2074cf29612e4e131f1eddf518b19f6f5bc89a8889a03206cf96fc71197a2efada03298c6614471f7cfd649625ad53f426f096b01b0a21ddc0d16ba910ea6517fe87c826b2f56052130e0bc90b496b5f2b354cd205e0a14c755b9570586a673ac0d6bc17c559134972ad6ffecbce1e5e0b43367d51a19c0b92300b51128f31bbab2e17b226522fd3e6b71a3b62eb5ece7a5037725f3737dd8a1932ac39c55381b0a088348c4b7eee30a96b7ec3a389fd9ce9f7740beda822e0fc0bc4bfccc33e287796f917593c7546e7efb2fcbfffbdd3fc744c30b1fd4d4ba7362a22b996f1e31bef38d6c1474c78918ef67469e490761102081062d19c05c96a5c564e18e547199ebad0577e35ee94d4caf4bca95b1f887529a6188491be4fc794e03c03cd6e1cc65ef05f52e5481b34aad032e04b816ee802fb6d51d706689da6ddf2d56e2d6797adec7d489e505ea259c6d79a786dc3eb95749c89571bf6e77883298de7ea6a6b54bbbb2996c7a114b5b8f737d4016c5a6d7404c326c91ef06a5666f1811fb5080d1854a64641ff251b9a473bb45bf343b2d5d7a6f036932df7833ea35df46517c875720822a3ec31ae099e5dc9812cb668500af79a7aaedace0684eb7589cb81d7368883095552bf0bd03edb66fbfa3e0af7eab132609777e13a968a79eb0ec167bd1303e3e107539eafbc5def6ec973b28da0e6af98f6751ee0637c064d931d1223826f131483d0bab1d3a7fa3d1aedc4ebf1cb5a8ba4e77cd43523008f057e221a36a88d221e64d5147afd1e14c0b5f4de7e416c0bbc7de78b8b4eccab3a21226deb9cb507bfb90ac47237c7411da67a5be4c8ec0ba8fbc3c7542a50505542e2a7dc92fa85093f56512450bf80cd9c6852ae19b3f7e69b622e48b4ba16b046786ee23c4147331b6e1b810f8bd8a67b31610259b6ceec8024f4d820a1c25983aa3d556537a902ea1a5398a09791aa4785cbb72a0b4f32fec99423fb72387e71b78004ea24ee30b0dd9aa8a6e6b976bd5a58f876356a04bf6f494957af463126520ef0392c23dfb30c6184f57ebdd0e3e05cb8485bc5d7f3758394389c13753646740d36ed8462a7ff635a267b9d3d558d9a198a2f4dab3fd31165e275222bef92a37c03d3f546c6119c9cdb87c8cbab86d2dbad3918ab3e88493fc17de47bc745aba0c46f3001a0ce2238688792778aa4001ea3447681c0f00ceb27c5c2c063b9686c6c353a4b1748da24d4848d883b67abdbff1f0c726a6ea917647a97a45e73a252657f6bea168a4435de318650f5b1a9a563cfaffa5750a63f517d4d41d462d8a8a4e7c1771cedac076fe7125321ab3c3a3b6bf12c9e15da96b59b675e2d5616d12c3894a670a29c3a73f72988f43d0e998c6236e0ae0ec69e5c6f20f2c96e8f149c505565f4d9f9d961101ba4340a49bd76bf1833a7287531877223fd102d97d7933649aa0056b8c7c93c41da147ea1e2b24153fff2ab6fb63ff390b89017b487fe5e88ecf7038194f9be8cfbb588addefb37101efe9f2de7608b6d28d6bc87d9adec77bd6e6b664ee82b5c70021239bf41932c44502f75f33b241bb4dbea576a0380f88980dfa0e3a5469939f6db5359b7f6749a56132289c59897debe443c84fe8b50b8d46fbc47d87ee7126fe7b9c5094a254e6df955a2886b55604032ff475098f889dcfc417e25401fb40fe79c2be5b9ce5ffe8919a76a7e696458e660ac18420b918446878d63d10377891b3aab595b6a258913ac08cdce2f43698c3e52855b0008f9e635253d85ca71092a1eb533ba35245c03ae7c68271f3e001e7f69cbf315db9aebf4eb7b1d276d8f76bd4d7aa47c33829c6673330c811d5ceabb0d4912698b48d6efc844823d9811454ffb5a6c278e2c979fc6df9f7a04dca89d2d3baaeea2d53bd03b06e2b129140998b6bd0ddf6458d4abcbcea7f09cbf75e8b418cb9b6999204e9345d46593636c74091a319ce5eb91fbbe9e70366f7cca0d133b57b1d3995c7498178b0e47ead1e1f16af9dcf0f5a2b27bb0575daeb899fd1d8f53ca7bad150e9e0e42f15f61bdb3d00540d2be104a7afcac1d4bd21072d5adec00e56bb8977a3e2769bd14be40183e4d6e549037f18eec112c9acc0a83421e3855d26e2853ff932c18f496001b4274c4041c8b82eb634aacc90affd86916441aeaf5856c8cc303ba53b55d16be079c3bcd8a2ff7a080be7d0c91c55e8148b6ef0510dd148291a5febacebc5ec455c2ee4c6c683b3e7816fe11aa046f5f0cc59a143bee35307f46e90ca757a1179b9591e8e2874b906749b1ff4861e09a2eca4cf60b9c2567653bc8264b27c58ed6a0da8d82eb14e0a5f50909042c25428dda4c257a5410388facecae19f95ab59aa10350214d5ff9158ce8f918a286d23d6961f639505c7ce38320af61879eb76c703987961e0644badae84c43c09877993bdb18e552e4fcb663e77ea1f4de06f3071b0d85495f32bf5e7abb15206e95f102483c6902a2a758473dbcbb4b8fed2672f6b93e66d1d1fc372e1525cb4af70ab999a77990043b043d54aa1ca2bf3a85c61366da3549a9ebc3f39593a4d5cfe55f66a9e03834921e5619886e029e83b12cddb5bda74b88f689db070c978bb586ac4ecbb708d08680fc71825fcaedbd54478793f691595eb11c26ae28435c08da7e628298947774ea5141a3956255a6bfdde4f8e435ade71d3955c11eb7c4135effbf8994f8b7c37053342ee4f2efe04eba8371f417ff16d2927db23d8c88deb3fde4e0b33cc2c2d923dec199d4671d6c8fe2156251575a84a5e224eed0582b6b52c179ecc93a0b7780f60d215bf0c06594cbcda2eec8c7f359a1e8921ac2b15891ce8c38c16d0ca99f424c78a034f4590d0bfbc33bf48420451c03a2a17cb7c309788ef826075ceb70eece01fc0e08d383e41f57977fe39786c4bbbabb2f6082221f594067d13f392cc3991478dcf64b663f44c5561b45b3b98c9df374994c9fc4690837fd2fb3a5e29ab4bcb3ca80682f12af57f8190b3e4408b39440bb9075e7dff6b57f845c090ce376b56825452e190a7d2634844f5ce0caa5d85494807752db6647d19eb338c6970a8c3c96ba0e5f64a462152a524f9de2316e30310f88cc5bbf644a9515b8f85236de1582fd34538b2e846544dadfbf9b2dea553c70da9f8d1ab5179287e4e84c2bde1d6020963c1afe13db9a91dcdabf4d4f6cbd9064af06abf3ed5596a9241942731cc5095a8ae4f2f6d7e083d3ea8076e9e1017082adf0d7bede18fc22e1f847f9f4455c43ca039be3d05be5509086fee0dc9294dae7e852e428664e1ade6bd6fb57dce6ad1965729cd3a78d3f8dff9873cdf6b3064aa06e626c3a1441508cde17e7e60b2c6ec2aa2e8aa63e4fc930b0bd7fd5d3a7c256add53ddb622c42e2cfd311456b24ce2c521b03a2f0795479e6c6e7f94265b2e8c9cab8d3e46f76b33e0f052417f0c1134a6bff7aa8148d1e1b5884288219d5e8e381b53e1b40dbfd9d13f9f329bb300a3bd6ec753c652e0e7894f779a1130cdd2151594e9558d28376d7449a4dd6d53c9985ba9a1a0a0bb571e1a6bbe9c3e0bb4108ca23f1e842cc44e97af2c24ee06e5b19027b9b3b3adf663d3584cb61d56dd32e2df8b574b64db4b25a41d34388308c3bcde1ba73156af4b8f80683b399bd380572fd3190bd3d37b3bbebac24f2c486ec819418e1f91effa6beb88615d20828d0e2e0d776b0d4b33e295902e69f8e58e35e0a8e5f6e62a93eaf0eefac5bd910008b6624a55908cfceecf91ecfa1cb32964a199767098475536eb87ab35c8dc39cefa947591b6c74e7de532c920dd29e863fada9fdc714c91fd088b1f22b80fb9325b739daa1e3beb8514f4f438079c9da41e7249a07a5f53d9b7e08603416791bb26252f3fb98ce4de1551e42f94bc5adb92a02308d65c774f94c3fad1661a920831ed5b9a36be05f1d4d4bd4b2cc7ffc2cc22c8ad06b67440ef0665c20b1fc8d8f312c28fa4cc66e6439db6dedad96082b1470dce3b0b70f98d4905064d99f35d513fd1de5ea6f19508393bd19319da70f28b8bd723540b2262b35c82e5aa58331f43dc0d773827355d8449bbec958236299da95da22a7d3a546e637e3b8c7ea0254aa308c1ba923b4c3363833e6d00f065fbcd331f595af68fe2f0d8f30487aec4c5059dec2b7a4bf05a592ea28cf45170ac34e73c08c88487b3dcf80880d9bdd03b4284d5a3eef12a7c4c62992724d8481f6d70ac1e1c4d023c8c7e4546d2232df38475107ad8736f46224593ed8426b51d85a225245c456de5fb8c366529160c8cb0124265f304d2f0bb50047c91c46b611eeed819ca8442d70b34f35896aee8989033a7762f6669ce6c1dbea232707d5c908f19461fb0974ab98e7f368f8eb0c42aa0fdb1f50d71ad844ff526b4644e255b1d49f66b5226b09ac1007869c3412ef25f17b08d32eaac2bb7e3919ad43078da6295c2783156a66af49b8693068200b7f09b555ff69be4409596cda2b5546a1a1815f2dac342f3b1b2662a40a5864cf3c196726399458f33c12d6e26d76979be4657ab920d47222e9902ec1243ea499d13e8775da1357b465999e6684f33c0da2cf628031155b36fe384863ac6b3432cfb551de9c985ed1dd986caf63dfef0792044761c2861878cb30b0fb4e2185186b79cdd50f50d0729785ca521acaa49e1d36163cd007b7a4614476f4f4f4167b4e57a20bb25e2e8db47b1feed374bc21702c696b614f42ceba27e32d33fc731336145c0af7ffa0aaac7c04119d4c32466ececa005a2da5ba7e9d1525e0179e32b33e53ba132fcc8f5c3da054321e674569203e544492b68a364ef73a5c752b0435f7d4c942fc361ac41f06e227afbfbe8e195773e93f45028f28dd37307ad02400cd6d3affe1743a56305afc9e121d5bec59bb4ba935ad61b7581e1f728f0915f6555e2ed3230ff900e5e1cb896e1c5a4f0455874d47d3c956320f2e74806786f432a3fa52d4ad950933696a0ea8930b0a27d73be9afd51b9c76aeb81a1b4fdc2e37360d998629d359a8a5214bf1230a582e9041b68d6d9cb32a55fa64802a9f39d17a28392a48c1c480fbd70c696f471c108891a8f12d24bb9ab44721240cdd8e768f123a0088317cdc4b5e42fcb6dd51a85440bbc7b7b4b032f66eef5ff052435c193b0fb8fd34f7e33196cc8862ddcafb48cbef7b9d0fe4e7b5a4ef83492f9205aa39a453ce8467e61217247981c1e02c19c83a296196dee78ecd605f00b6b6d055a9408cc2a5a3e3bdd2126e529f229c80bc2c3f76189bdcc367d0c459997a4232cb151a56b11e552f93e464cab40f302a60b2261983df3ac74c215f363fe1c04f64cc1009645a77a6d108dc7ed7d817319453e1c72966310ab0d8167d0d73f298bc9c3ae57227d333963c4e38f8556ee759b23cb76315a66a9b33bc77c9eb76917191abbfe7c40641a6c91b36a51e460b628d494f8d1f3b3cc0bf4cb88ac76a1bdc020132159898074ed29115ad7a1e274b215e7f8204346e3e92f17e654b23677539da0a322d38f8dc3e05d54a3b171953ad0e6416fc238df5726e9f6857206586190982766a35df348b839252c0bae6f4072aa2ddb0372bd50906e7f713776da3567d9ca76d74fed78b632407b93bd8f825e0fdc88405330cf386ae38cbdd897b600031db4c295d12270423df27f1527711e4d5e2e67a50328dcb9ce00d6eda0e0319ee5653f7d4e8584d75fd990596d2b3828b0d4168bbb5464c91715c5fc69680e12e852a30bd3c576894fa35beb96775fd377e781958faccbd713e18dc023daa5c21a246334640b5f6f82f6441fbbbe9c067c75f5829d41ed05ed033628258cbb9b0479bc2babf2ed2d0394a7b7c752f988810327e8fcc09022722964908580be3e24824f758a55ddcc7b42b817c42e2319de083901ac6676ef05ae68e342e0b09cb95fcf1de96c4c18d876d8562cdb2e780ce22e976ea8bb6aeaaae27ea89186d254e2ab5f2bf09fd49c8055953eae46c7f64695217ee850300b64dec5d13b740e973028447084a0f2183755a76e1ab3912b3e1f9973f2ba69db8be3f1d85c2b50429a84a10244d023456f4860f6d633f45c1023908d3d5f053125c30e73ec5e7786c144bdd455a3559951c015758743ef43c24946b68e6572bcbd75d56fa300f3dbe543cf199bb74fd10e7905c63c1bf68ee20a8502a64ccca97ffec686d141b092bf52d9b9db44066802b5e8042e17a07abc5d715e427e47677f721fbd3c736161284a6e4287f0ecca1b8dd8e67b8ac99597000c9b775fa45de63fc37c66b3206e940dc7d03e327fb5482b0f0c8511723d9f5c66703466c5d5b724deca6beb6b4219209b4666d55ce2e079e88dbfc4ff6d080fec4e307230bdcb401326545d1dd09deda8032134fffa937a8b9379905268450cf21271b9a4a6632aca9c4da56b4699cd10878f507e2e8f1c122ff10f880e72489c13ccaf8b8865868c7fe2bc613d7c194bf71a169d5c2a3f6b480e569d01fcf76ee841913bf9226c4dbe92d2d6f20040fdd65e7dfadda7449d0bd91516c9a29fb499e4186bff34fca122d0d1d4595dd614bd69ba837bc636a5ebe6efec8a0bec651b51ecc92e46766ed42656d0a138f11ac5adc4117b36198ebecd8c0a4f1d1e08082deb3755b6487a4c314f4ce717f7b25cf0a079ab51dc55bb4dc0c0237538e0307709a03e25aa27ce81c5e2623567c26905034db492711f5eee1e7c52988c64f090c0b64bfe3d468f5fcb935b8c3708462a776561f25bed7d9d579aa531178b8341f63b09f2543e50f9126e33ba8455f7233093ff34b1df011b30c44a10d39af24139cdfad6b300a9160e98d9c0c1e97b3923341068ff2661c9a038a6e33f68ac1b46fd8d7cd9ec84577ac6b638b8685bd3f632a7145999991c0ea096e9086fa4fd20a48801aebf09357caa77829d423b6873eb1941cc2188a8bcd87168da5cd237752f7190466cb9bdb98c92eb97f6d8356ca0b136493a7273fe537ca36bd8f38ffe13ae639fa38a3a64dc483d10d430596e04d6b0004f40d50b10c648e11b3218e020af40a9a5413cadc13c5b2879f26eeab95c96d1be87baab0aca0d5da8a123293c5eddfda58b61b26f40520432ce1534b462e92fe5ce33c0e7f37d16a4ecd794a30a10a7460a2de4b0f9bb9c2fa62baa5f30ae939e2d2bcb74be05de71e6c829065e084900ba0e31e1863c3bbd73b19d880c21c7a685337cb8eb4eb1dde32d6b9ac5cd7a90f4a6afafabf6c3406b3f19643ecc1a77faa33c8cc3d4c7d32a38db21839bb68548d32843aa9d2da7831affc8ea55b89953c7268c2c72583f7553154004ea72cf38e33a0b2a5f73cd43cc57dee1dd9d43ce47866bc552d0b81a3c56a072447a8acc78f56d7052ad3b94d68ddea0633db72ffbf13a0aa1e10cd3f65d94b55e236f4c22d696028295017f4887c1d699f2bc535563546b89a82a8c0598d747ae58206b0a27317092d8ae4ce8cb8b861bd16a8f2d163214ddb44d39e56624d09d34f2fd36e88dd0ffa37855fb41fb69f9a9322db4cebee234628324988036272f4d59074f3b01a54637b8f22c4d38c510b72e38efcb2ffcefe9d8fc8e8e08944620127d183028f9eedd9fa2ffb59e0199ebe63d387b7b9b035f5e81718fa70601c89352276b7d8bd2545e033eed5e9ec8cd0c5cea93fc4b878bae379354cebc98b822915af00836cfa3fc2dea7e71518c4be1d28b34358349916f9090ebc863b01db52990e36e51aae9fd4f4bbc9ef6b04c7fdf4b37172a484ec9fbc1bbb9d79bd26225bcd073653780656b6b9dc26d5a451229b08798276349567f36160192bb118a9105d5328c24e7806e8b0095e68e452278fe64a7e931521bac4fb49463b11c71d4824d5a3c387cb24d8f8569bf761911a8fbd86d1c4cafe363661aa6607ed73d5b22083fb8641bdb6a894d15f8dab35bcafd83705372f8fb9415fba1d17c678a0a3d709ec9d8ed8068cac2c756026dfbe85079516aa9790bdef6f89fdff8fb09845243c5827a0194154558aa2bffe455999ed19cc5fbc5d2f76e93e41ddb304338d23fd39ce5998497131b5afb475093bac47d1cc04c56cc9434f93ba9fc0c0af0d92693cc6941e537eb433702e675088367abae875a466e94efc361ca4b773c59cc465323d2a19426f5801ead1183b6465dd9362c65b0db11865a8974964f3d27f78d8e4400b580849214eec7b0603bb90c2ecf9a0af7a62558c5d21fac6412f18eae22813dd876f4faac82406c904ed1130714895546200bae75a0bf0bb6291445660874c27fcdf64a8e1594b4acb889b6df06293098703a313006061c37e030dd848d82663bebd1ca8df5c39458a64692fff491c39850e60761206976308cf31d145ffc2489127677fe12034aae2ed0f3d8150105d3a69f03c01095a161ba985e5db9789692baf35942e3cb3b29ed7e84c2c442f0b5c0e5a05e218794ba9529bf075c14b351c39fde03a95663a3c221cbd47540779d50ec8058babe2cd2a28d091ef290137963b30881b8a918f0463011c9065ab3a42b5c5cc2ae3ff1e7ace644f397df21f5e7a15e5aac069fb953a20981c45dea68b6432f69bd6c4402bbdee3abd901f677ba7513a369ceec5da60f9185d9ef3c6a32668e9d12655d002b15864859b939ebb8eb885d552f78e6a091419b1f2be1c7d99afd81fbc08a29104c291b2b58d72e7e4bc4a7dae26e606ed3b55a6e8193e6d8ece256ad5a065f61f6eecb77c60e2adde7813f4072abcda060d100101baca0b7555093f6bb8b9418355b3da3cfb24dfb3234cc134390a3221431e80fe1ed16b9c5b58a94fabf90d08383fc057c20515e917d26c7359c0665277616de9570e3e1e4affec3fd5ef126e7ed5c302e7b3d7c748eb84ffcbc743dadb464a8df0785fcdb258c614e0b4fddbb9b3256be745f32d447b6fe2b967f27fae5256f6b3c0d9708af9c2dbf5480eb378c3d739aea5a553a486fce616978534e8e4e6d547558f00248e4717b9e7a9295450f6edf2c4424843b6599f02c1ae1ea5feaa28832096f8c227c2f84fcdd32ea45d93cffcb5b29b6111b63c1837ddd19c4e379a7d8a68f97600ebf6ffb7323e8280be97790f3c9fdb4486e6516b1e95f9a13e108bfcea377269ff5236e961d90fc0e98e2d6f56e015f8672d2f060f12fb6ebc3c54b74a474ff0c94d64ca2be289b49d7ac846b48891e6017eb3699835f78979d5cdf22c1cfdd29dc6b0f03a51b081a75563f32907d3126588b1ee97fc4eea88185ecc6fbec474a13c03dff180bc84b254cc3b97f0ee6a76143f67c8827770410b2d3d1e4bd1007152f9d71e7bd2366e3abd5fa8aaa4abfd403865c7bcf1fe6316e4820a51087e921639bb5c00e3225526a446db89e684420e432b69f7900353008ad9d7907d6714859e03ee1f3bd2f533dbe6bf87eaac5d73541e37ab3bbede4ed8f3c594204817327fa2c1ffa5b9c5e933100fc317071ba0f7fc6cfae59f0171b2f936372646bdee6f95a41dd74701df5a297b9381b77d78fc5251ceff81f614cbdf3fea4879ac88886ccda0f8a6ec94324b357e976777087d3a754a8acdc523e903c2de177961c51c4a2e2a682830b8e92e1014745db0956b7c5bd4724577b1cc12469566387ef2faca624108d345cce6eefeea914555374d8418c97f7f7cfb635a4a3b8a35bfbe54c21624cd34b600e869f715dcfb0564699620180cf3a5d37820ff64e1d069d52ce9c6668a55ab2d08ee6f00954cd618d76d5630c3180eb85e91eaa31e4910d56fc28bb88e2e307244dd824900214b730dbfb8bf78ad31884e21638b3eb32dbb1677c7459d63b256af6087c5a7d9144ce373df998a1d06135c6e959a6bdb13c0395538c984e85a6479551f8875eb3eef5176b9cf9dd1d5f1c6585fa10afe0e5b9be42c034e08f56f17061d7c54fb4d6acbd2a70ba9fd6e6eb1837e06cb3920eb9c5be0fcdb251a45f70eb23256207ae41a4c0df2f456075205698aa6f851971172ae2319eae70c4135f8938fb59e251564bc1ede59739b4357ad38326b7f304a7971cfb259d24dcfe610c3780dfe345d1390cbc5edc57cb644f7661e44619843c670ab9f740713825aa400843cf9add8433b51d951b195fe7d54d7488b16b2ea767a3290ed54c5d099a9ceff535f8e8d2b385580b9ca8c13461582c55371edf94e10dc0d85674215d1445f804ddc13c9424990b99613807de93add2e655c22345ff5c5cc001cef164b5b4ab9ea71f9f9cd897d861d966a44dc75ce22b06afa49a98e1c721ae492d6881432662214d99bd087c91e361eb84afaf5a04d35c5b8763d6ac94657ae0ea68750c0a9e80b0095bd419a8ab581dae57581f7440c7b7d52616ba20a61c89a420cbfa8d62c8c32ac29f3935a64f001b7607d59be34e8efedf091a565bebeea479d7d4850a1c8909cbfc8fb08682a5edf58ab2c160815ae44c6f45ee4941ff517b6dc6bb80391aa504fd3735cab5dac9eeb04806f26e95e9413d49ebe4cfce6cbff0ad4009501a7bf78b97446209f30318e92278e84732f58bb5a5889a061ebb77e5249649c56163b8a99dfb159d24119979e15cef0af8e6bfe62c90847951c29c5e60c7cc0f36772e20ff86094321e536a49df35e7624bc09bb68c04431d9126ae0123769993056adb58f3e166c31b4184948897123cb102f5c066f7792286da85841500e1b9c44a0c90fb2480e272c08b447704426229084fbcd8f91880d85e0c556502fbe0c93091316c72c9192a152ef77b78629ef8828c39099777cb7fd12bc7685342d1b0e01711feefb150b7ee1dafee4cbf7cbf4d5c69cb67533105c6310d49e4ac46e7dd55f5f2f37aa0aef39b227d65fb17a3404e5aa2b7795c1eb9ad007b463725599b140840a607fa51b3e5b21f32efe928df4a4ab2d35bc07e86a91fcd03e1ee2782295ff75059998ba5a870c78e333d7d550c0ad8af5f8c271436632041f1fdd0c23f9cbc1cacfb59c77fbfc24396f8105541b454e2d71e1fe89f559b005b82eafce3bac89efe5ae67ba8ae5693abe4ccc3c16ae06668f9d47b8c8064817a51f558af12b95acb656db21e00ced914f9f8a6c13a0c70e9ead8d3cbbebbd69feebb659c38a6c0ae8b782e4d57688d7ca7e7872ee189c53039f304c4f1afe997b55f73230fa5fc2399ea99850b6665043218ac6680d0ec3fd4ea32accc270f9e93c417490bdfc468d131a6b80cc264a27d68248bc95c900c532a339b3ad3c0fdcc206af895b7063d1ef70fb1f64838cb01cfbc3ea020e64a578ca69397a45d0b793bbe2a2379e625015ea9ce1b410f3d8111b7d10086ce4555407f9b1d6e6790fc2dc1cb4211a2daafd113400f97d46ec70f8999e90541a58adb2bf792a14ef3f207ceaaaf7aa7f155e89c60d430d31682311c6f6d685e82dcd032c6d6cff3529c20f80139202eac607b764486fe9beff7eb88d648991edf379283f52ea43018b938f3902da1adad95005bef93726b459a0e62a23368b3cdfba91e0a0be727395aef166fe89113184a1c261cf68e186744ddb6663910b1a089111d4e5fde2bbb2b530bf3194f05b954ffd685f6365ab50e8d09f70845d1fea41d8751c4483407a3106e25aa413d6ffc86d09ad10a3b5ac686398757e56bfb6ae99c571dbc59be416627ce1a300e40c96c74ba115d994f55d06fde301aeff9e0e2aeec690e72fe632c35b1494e88dc08427560e74506a5591278f01e138008808171a7c09f303e459afa962a79a59b8c9d1ec65d2cc80b7c22479578fd2a81bc1e87aebdc6d302388cec59b019108f215735c85092b039e926b9c92923cbedb26b38e0b90a5eceba99b97d66dac21eb6d9008c0fff45a2fb0485a4605b5e4b98e8990302b592e61f51c3f6c615f0f6683ae89d0238d9e4479925309c2a7e08ffb14dd01baea8b4fe189d77257d11e5ed1ebdbd43ced04bd517e8e1029dbbc26d5798e5a2039d1bba2df7d4c491a713d94f45b844a4a7f7cfeb9d1080763facc6cfef871c07b8806be4dc5ad258e7dd48540274a054c99de0f55387dfbce5d01faa410ff986315fbedfcdf0aa328870e6df78397f26380a3c400bfb58554a68997b098a9d08899241de48a6ede63b98fea52ef6e913a7e236cddb18a60dbdd3a4f5d1494bfabbe00adb4ed734d30f3a63b861d9dc87dbac901a8205031338487f99916cc05e036460879d1e7efe8550f0798d3bb4821a9c706a3b694259c7fa59767e3e206b2ab68f8e93fdafa6206f4e929b4902c8a8d145466df62b669cf71bc1ac52aa4424b4637bf51a593840050cd691e998ea819c5ed12318281c3bd35346dad7fcbbd587176f0cc0dfb78ae9aace214dccc6d24781295d21dd4803d8e2043de3cf5c619d11595756ecc232ea9497218145552277883ae87369d0c73c0737b49753fe603ab79e85070edadf982809805aef85a0a9ec40ee15c57aa1acf3e4b7c51bf35fa45ac59e0545468f0dd7322d0fbeebd8004aee49191f857ab5da4ca3acd9b8a4a0c747447412d4fc63f4098a37938222d10d4c979b599029c7fc8e970465cec008846146bb6ed363344efca252f5b96c5decdf192db064003ceec055c648004a2d67f5f3b3f9d6ba13cb40c49ef67a848efb83583ceb09c1784421ca8634598a4451c603fadbb93b7d6036c51d007ba1ed17f89863a2878c6865bc38660edcc20cf0f4ba4b65130124520362aec3dc30d76a3f2e1d0b5b4f19b28795d4bdff4c36a37d6c98ebc25bfc6eaf12197bab4252136d4604d10a1e2cbdf6d81625f3f3ece2ff491488613c34074a41a1e2b56b02f2b18bf6f872cb688553c1cfdfdcf0e0fbaa51a3c0cf2ff1134916245625158804e72742b2a4d3b587db6bb9891e5ecedc1c19eb5af137f341fc49cd513163c2092bd63d0f39043250653e24789143e165756fa0ce8038de1474278647fa3a78dd2bb93a236a41c2f97bfc12454a3cb1a0f6b0b0490e0fec9a5a22495867c76d4ad72ccc3c0bf352a508b59738d66b977424f0eeb8b8ab97f33f1c8818660fc1092e33f2bd3b1dc6924ff091cd8be4dd880e9cbb02544ff44f6992bc94984c78a191706ce6416fc9c10e8d7713a457692d7b07ea903c79dd2c71eea24195e2d95bca71435c911da3819031434c2a575dbc321c461ca2476a8af7535b97ae5122abca3d70691b50edb141e823f3c600b8b799b9efdac3db6906007085875776af1fe8ae26bdf8fa4e936bc6884b90ffaf1a6e0d34b4d8fec729711107c3ebebbdc98611046eede2717107743d7392fc389998344f23b82fae21b3d14fa5c8638ff67e2c8f86696bd68b662b644b485e53a38bbcdf87c54d3bd791049ac27f11215b70c9557a26edd85a7478f207f18c243f622d0ab3a1ad636a6d13a29f1fedbec5531670e82dc4e849e5e7191ae304dd3cb2d034033eb3ffc6d5aee08cdb1fc345419b1c1739c0a0b1bc4348425b462ea1113571390199a688c187482702256a461cc3208460dc7f98a5d8cc35252742293933eb6947324479982d5e81aa34f1c8034a1e6d90c8b4015f628c277b2ad304c7a6e4cd17d01a68a01fe64df5112fb48c98808d62ea629906feb84a217ed4b37693ec1dcf1566b9f78bb166576a01f2d8bfae7af1cbd2c1b3cadb8fc7e4db8d7d6c77bc8105f4f79e8091e85d567fa952adb95dcdc781307a4a687f451d0c28d06646118205d6f486d37027cbb7f245e8d2e428ae5219fdab26fc35e3263ad5515ae598de7bf4e0a66afa7d7ddcd381eacdb5a5205f0d1cdf6ce872e59588bf5e79a3eea95b3879bdf150255ae5d42583bffa6b835ccafd3c9b8634237961bc27080ed506e45b48d00a42b41975dab3d5f4e5b0687dc6409a4a5512f220db9073836ea51b3d1bf2981c98af13a94bb168336ad194818dcca462ec9b5d2b68d989573cb5a50add78dc557a04900668d1430c356b7b64fdc5ac84562f94b602589082ba8c927e8451b2856e47236b8e3eabe48bc6a5715fb8296adbbb78455392c2b47ea828ae99ad48e20f79d9062971932f4119495817213b2d3aab7ed4f7a519053dd70b5831742c7a0ca48f8e3bbab6e421e6136a2e48c5f03be570a4f77bebc268a7d543030c28416ce9da49b2c23ff7116134b386db7fb1c09ba914b24998500691d8957e5ca1f6c7bb01cba5e52279576b6a9e71c69a60c224527c4df4ad43f79336dbc801a06616f5b06a7ce922a25f43b866a3861715512f7a4acf8ded4c172be70c281e4dbd84afde0a2cf9b0f2df8a200067a1c394a8000e225c7cfa2455cd0db095ac04ef99b0c2f56cce8a046a11492b98269bf24b0f8bceab86a398c4219e84cb42a2882cf9521545cf74666ebaba4bded1ddc67aca01e13cd7bff0cbe008a3328edcac61af5582a48b1f9f950db05520e2e0eee64d985ebae26116ef43f5c5e1c331ef86a1abf01c456bac761d54e2830da16cb27f869dd831ba5f38948524b2d9e478cee0e36ddd9f835ab9c5eeaf5cee54e7c226548c1ba99940cd7820138113a64f83661f0a96a0874d5b5729305b7eb72a3cf7284632d8d35ad73d26b415f27fc9f689a6401826d1e28f70ff2ca61d1f260185693d5c6cb84033c9a6b211a85c24a461b06b6bd5066033782abd16d79fa3d1f8b95fa911803c05f80ae0bd0acbb9277eea0e737a2bf52f916b61e6c4f408cafb1ed1ec50d223808781fec16b6507f5837a1aee90a2f3a69477c880ba621417ed021254edd11e0ea1ef43a937c2546728fe2831200c7a865694ab5ec6d91477a4f734fb355d12a64c656d8e482487f70f840884a3bed0b3c5b1aaab63c174b10df3297514beb0696d59df6f54702994ee9aadc5180d018c88e4334a8e32b2b4050a6136045a77366e2f8012cf1fe18fbb71a48a00b9994b611179cb36b56cc4ebc1864beb0c943265f451b8c183921f0a371f0f614ae96898a249c8f883a4b2a90fbc658ae255feea71882e7a09a7c7472498fd5bdaa7d878f923be75b8fde5680538c8e8f5afea70bb61c2663c6c7c9322c62a1edc4d875605378d812920f148a6c015885507bbaba714ae5ca54bf977a176da51c8cca4ccef4ba3c7fb6bf39cbacaee940b2320e154a78975404043e698587eca6008a87f5157a4960f007dc8d3fe83f3c5f2f618b12ff069254de9b0a64c509afad136848ffb3a255518b19d35476b62aaeeef959e2d1c15e655d2d110112b184eeda17541550342daa3846e02e7d5613b84834fa796a6414b88404d14b12d9c8ae082528e3654bde0c5bbff7dcd87b2068b5a0234fe76add7ffe9ee9865b3f46e5254027a55ddeebb3186087e9a65bb6f682dd5aae9211ff9506f975840f574e8a634c73863b250a8e9eb7e42d0dd2099dcff2de2b54f06c303d5fc18cdfc81af2b800ef87bf82e0834c73df2ec9ba0b53d2c439b007163861a3a178c1570554f6c1997947b0205b9d757ac4ceb786a8429f75f60c0e23533b508fa9d6a8bf98181549f461190e2931df439bdd994114d6ddfe6706ea76c34ab1784dd220a6cebf7e305cea70c267056e7c5bfb3354b22c3dc7a0afcaa207e7c016634d4323d78e207c882f47060f1baca6fab3cea6dc8184e02a6cbb47673f805d322e0d579910255d8a896e70e651dc6d8fdb375a248e5bc755c0942a92a4696a571220affec735654361fd781c617be69a797fb77514c7358fa24078f979de833ef710f26d728fb72c3b0ed6a44962f6a56645a8b70bd66ccd2178c9f0bd552257d9f409f65d1a6265948bb495a61ef3a8873020b3c3ea318b7573a5e72e782f9540818d1f2470938c0b0f58d005dcdfc2598d0683d47863577425072b236b793e6b8279d05e0a5e228bd469f9e5364eb6deab6eb7d13508f2becb7a95de6a938a7b78db693f5f3b47d3696907b89ba6ac9209fcb89f68fc89c75b1d5468b0e71883f8ee28c69d443180da318e5aa9f7ccb7331767f65c08192670f92a008ffd4994576cd85596bc80afe230db40e342b63bf9428ad597b1107a71b5f064fca8095e21661c1fb82add4097570ff096ae4c15e16329820d323548a969baf6cd41bd920b31027b7b9a06234c8d1ccd6b4b7c5937d710f796a7e0fd52c603ebc04b5e55c52b37ced22951a7fa655ba04d926ef68359c2cfe538d1204e48cc640ed2f41393b6458526a3d61861320bf259955c699bc89e159ac180c3c70c11428ae4fa6a0326ba42a9ffcfeb5f0addeaab98e9abd018d8a80d9e1b13ccf70f49569ebb1e242974348904c473e6376ee8c6277aadc5a3b74d2b301e73b70f4608f13cec4117ddb8e63591e96075d17c624c83f1741f880d2798851c2321e3ef272e989de90367eb32b237f45b3d3024fdfc09290cd6e96eb1dcace15cd5c4d5d43a5e1f052f25f52eec905da69d89dd74dee68e7458969edda89fe9401d87fab622598f7f0ea50dbc1f8a0a70cf68ee9ad09c91a55902b88a01bc8674b13ccaa352598a649ed640278d68cba07ff3cd6ffa268cf34b496fc05388967ad68cb12c683e0f0241eb7f6a7da7ee1e6320246728a05c4a071d4160c3534ab29acab20cfe88b98f67c604b0360d049dff437d944100d2349b0f3eaa742faa3ba2ca9355c42ff0ce20e0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
