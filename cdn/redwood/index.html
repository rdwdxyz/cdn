<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d04b65ea8d8a24f6370b35f951613fe7073c3650717d3eecd7e29bc76be46a17dee9c598e5865185091acc6b21292abc000fcbb168c01335294da8a6dfb31613154d65337cd9d807f517fc7f805e4b4fd210ed62b12e8d98f1bd5b04a4cad2f1e211691609b07134eb35598caa85a47f28cb46b76155eed05aab3d86c699d7c5c4d531372a065b5862908b27291b83e9b93661d3e6111822d86e3fbb99b878de85270529c170909e4cd540104f128a9bcac2bee403be0c7ee8a7bfcd42ff303e875e3f0fee304d6d9882b44a2af38bc2c9f50eaebda71226248fe5fcacfa975d64a56729706506580f0e844b098816c739bfb8e97944cb641b0f33825dcea05cbe60b081a25373c80dee8ef116be501f51df1377cc45c50769a63878f937b6a85926d4a85bff9f88ea8a616374009b6b839f0d32e67a625ae87bbd28972b886f191e1fc03aae530e26a1e0e92c7d4e8a6968b77dda7c11748505fac5a20c7684d243a50de556580ae97729a6918404ae1fdb5f368e4199fcaf148b2c0e35bf97d29c25b2a2ca29d477394184470ef3218d393c91072d97f13bc4357e2212cde272c389a49c772a0f39ba32eaa14bf7657c24a560cabeff94020eaec1cd0029aa09eea270c8f07ce3e3fec8e5bcc131222129054252fbc2c4ee3460805098810b7cbb40aa8718b7d93f031ce7f785f7628a0ced1039d7db1ca729839b836e78fa6d642bb729bfb93dfa2658048f883a4ee9ba0abf4a1dab5013de6416a2012d2b87c696b51449b26c2886fe0ff4aa9582177165b068dbbd71c3fd50fb567b453314ea3768121b2a612708047b369feb32759e60c3528864cee076c6f6f22e2fae6bf3d0d2f14d65a48b66f49fe67317c231bb7520d7e442bd90f5adc1f9fb9e520cf8c18c00375a03bebbc928dfc5bb11e003ce9cf75da883ca69dd0451d959615ff0d8c1f56cab269c34fd1586fb8abc860673415ba49a83aa857f1d449fda45aea0aa238c1069654e3e10de3abf3de7ce3d3236fcf6dcbdf8035f21755eb57d3a6c7ca09699051604ce4226d86b487d3754de9c1d4167c2e23f4556fc7336eba7fd6bf5deb83089d719aa8940ce6293aa3646d9bf37044773f85fe4a9fffe8d8f1827b07c2dc8891e4ff51c6a6370694397421b7483aefd7f7309d248e4aad471cadbd08aa0b1b7b825465902a936f000b26aed10f485fe358f87ff68a505c4f7d0cfe49bce1eece3c7462f9534dbad3f097b24dd3198594808262a2a1697877627c009f03678b895cbd3cae2eba1ad433f51bab47c123e457f8301951d06c4ed2fd1f36b79d9656907f4fe66d9c4744be22bd67927603e52bed08671468444f30784098f6dc287bd66b454580b84ced49212d89da19ee72e030cbfb6cdb83cb35aa2dee9326c3cae0c22cdee99051944f146e708ba7edb610ef5a384496d23b60d15687a00c2e0a50d0d15e8f0df8ca6f40a7f341ede1eab3963a5bb73d6d06940db7cf148be0dde66ee85a8b212999d299abe1739f7d300fa2d629866a415a8700c536635c03e7ce6941304f90a9a0427ac1b06c466e81a14c66e08f9bcada7e73bb54f18a376096a49b9f80beab350c35845402fc0f5cc72bfa7af0dc4954cdcf5c76aebdb36ae0e0397d1e5bee0b94e9cf09253bcf2a98ac18dde85de4d53219b1bfeb866212b542214c0657ece92dc121167aaf46e4dbe2a56ebe5da05cca8eb867e1dcfd6057b6b3b07948bcb8be7b6086b81a2e83d18fc4e9502ada83dac1986a62f7cf18aaa7ff9ec24e28f5ae39cad4c1a262787acfda171f07412425c2d4bd2580f0499f20a76d970a0661bd38f814f7d3003dcbd6ea94daee88d374c042cc657b95a525fc805386973d2fa7ab16e4c7a219c1681cb4cecd5ebaf4b5cee56c4ce6516ee3846f17389141f2d5a88ddc702c9a3aaeed97151f23ae2fe290cdc94480ba0f496b26a0ba19a70dd163f6698c986dbb3aaebdb2a1dd6c49e3d6f524967ffaf23ae1c018a79930b65b0f3cc0b4c8998b0a1b13070e60136d58f84c75c2be4776007b704e97ba7e4790dbbe9fa3b4021e6285e5571870413629e616aec8d93e924f36f4ea7772d9c0efcb88d2aa2c7215e9b0c1e9a26671f382e646a5ff318244e773b80fef1811ea81eb982d63d868bbed1ce75861f28065352b4b7ee87e67ad7f947b4869676f1fb9683e571612ce31283542ee243a9be7220517fc020629333f1e542810c392d0c0be7b6c80060e8009781fc5a0c7cdd80d9bb1d746843c448f3e8d6f9dbdccb13ced7a85f8930501974b4765e3ba09c537a514d2ede092d855a0a9284b6b0c5953272e66578239942b7b8ddfa99b3e014b10206b77ed1e72788490459d4a4575c157da0ed462168e35244c4434abde22a3f7a19b20774af5b0cddda393c2077af594aa97d75cedbc1929ea1e6329aa37a89a5b5837bc70da3cb7e877c29e9acb6e2970ee715ebd76736c5bfda3e40abc93fdf5d4561f80ebfc7274cd56ad57b1272f82fb24d2900a80050fd8866cbb041b59d80c58439a2e7c0f4b579c4d32bbf732b165f5713e93c7ae776e60c979dc2bbda077cb8d5b221a177a5ba78881a4b8a121165e4612e0e668fdd209d13748ccdab2880f0c3ba86fc5221658d8b8e7b407f5ffd60f654bcc443eb6e7909f0161899c67e062a5dc2eb40c78e23431b9d31764b5adc2b1b2064ea3cb0683362e0e3745d624c978bf705a996b47a01d212f3adde08e1ddfd2828ace9c7c010c0a4eca74fb35d830cbd94d2ec7318cc3437e78fd36aecdc11e66e4f2d57bed34761ab39041ef8da225551894ad35a3815ca293f7dbbc63e41febdf591708254e1608d2ae7f63de95af4e00224ba9bc993241344187daf3772ef4d636f004290033291ef45ca0eb368de779bf449ad4b5f492f8b8d26814e6655c244d0a8b572a5eef1daa85d3df4efcb862eb33d954ff5b6af57dcadc842b2ccb62d81a85697f49f3dcf1457bb9a273caee869bee12f00fb3ca60ed944b2ba82f62ad3ed0b94811f4b5d7d5e5fd8d31837b9a2af89cb291d4ea178ab67b890775269920de1f14e58b57d0703424b5a3663aef147d94033d81a50fb3711cf678e7dd96061f3ad70ee369fb7eba17516a10b45e4087ff14c0aecbc3cfbbc8cf32b7f686ecafc6ac6a034b9c2bf0a6b8c54b39cc1230e2e19e28606a98dfeacb8111ec2b84f9d988e6a63c47b8153ba1943bf51d5ea8dd6716e6a94932448d3a5c4dd2fc8774760f18186426dc6cac57b93c0397c513888f46b302808ce46d34359efabc2891e4bc3dcb3e3437f37f2f46eb7e50ba80aebc17b9ecd76f0206286d5677b838e9db6affcca223b7842d19910c5267ca277a8d79a44514874a66f42aca2e1cdd93cd316b83259f10bb32309b2d6b514d43928027e7e0b34fd4ec07c0c8ab8424d0fe8307b70081bc1fb98fe461ce0d36f798f0651c306504a29d90ea204eb4b189663db1b3708cd1c286ff63a12698556f381717424eab5f5d1a8ab98b74556ee8a42cd6d2464a448e1a3419629bab4d6d5403e8cd3389ce77bddbebaa6de45c0c213df3cc8cf31993ed5922769fb1fb8d55b3167bae05327976bcb773793ed699113235cabb36e5c7f10f8e487eb7ad5f081d4a2b2359f1c09698c4672d15f6331376b399fa523109a868f0d0fa886fa24701196fb0981a7dcd45a69c0875ad168a842c0999d3bc1c1c5a7e4b13379ebf5b956e6502f93664210e9e8358188e0b56351e8ab58d2c056cc0cdd3c73d3a9dbe13ff72b1ab6b2a854dfad1b2b83de24a503f3605292e42a2f1249f679a8add08ef2014800826c7e3e853a60192898220acf71627566fc7d34a4c9bdc081c4cb228bfeb31cb96029694c064d931dbd4db54428b88df96111bb9a29eed950378828dbd4e73e319600900b3e22f5ed81acfcb78c8a9a15dc4f3b22157f9aa6913e5416a5fb3cc852b207f19e80a94c781ff5cbd3f783419d64d9f93341d6f5ae74520848c2e5339604aee80945b2fd3cc3b9db96557351d79041b859f91f99cc065fd93425c204d4f6a1b028b33db559cde0a01045a6014567c050f5ef6a184bbf29f91781c789e1c1dec14a95c0d38df9c06c2e75ad5260d22ce339a7b12ff6991fa8842e9a94359625032c8119c12ee67f4a2596698542c35ad055d8eb40cf4c0fa9d40bf322f19a5ccf35e40c69b87b2f628df719c03a6d8925167e7522078699ed3da472621ad9878c6924ffff9df2d21046bfeb5a20081f105c46a609342fc0849d40f35d0d5c77652f1b5a016b88ba18b92f8bc9decdcf697bc486fd99bc8b218a468e8eddcd551016fc5261385326de3de4dfac700138637c6e609688e36e49db3f650b7ad8d9ac40b72e5c788bbbe92eb79431d25e01b4c6f7e55497c90f9735fec39b670f37f4700058eb90458309980ad74e368791809e746a2f5e67e6ca146cffac31e4d215bf4cefc515b16cdb29abc6bab48b32f494bf750f4b16e94f4b952a5415d2a556f321e47e707dfc0f6f90aa784bd67c9f1ddb8719420c944cda4c809de0c44cef587b40b867471bbbbe391cdf57c9f35c0736009a96559bfb78350c940dd66259a29575fad51c69466bed853e2063b0f7569a51f02cf7edf3ab574b46b0102c9bfca0d143dd43bc143b0ebbbd9fdc959816ee18cd5530f87f68815bfcb8f7713724be05d205e361600cf612df959968a43e3db57cca82cb513a159daebc283b5b0b6c4196196a23b52b214d614c3522e8fa211a52aed601cf49c94d4647e4a35e4edaf3c30095a9972d393e2e5524b1c1caca6ee72548730e36cadfea6a41921873d089f57b3bbb963e8873fd3d5b50aad50946dbe8a05d39f814a6d74f23b7948e854f9360b62ef1acb31bde2815ed22801e03662507a442764273d440c02ecb224e6d22542b1ffccc9cdd484fcd8d8e6153f4524c973f78648e9f45e51d717d25486b4797a3474da0d42c1f6ef76c9ca8763039d6889be663a79ab2ab78671fea74fb968c5207707a672f0ecae52bd02460673673aff987fb51a15c6942fe1d880a4aa5aaa645f31934b9b2e4e1e349cf5ebd36dfc83f07b5c8159f701a1b05d34e14d738a0b0554d3bdcf1a6d6dbee2362559149079e209494a6a0e62acddaa8e465b72733fe41fed94ccab0b93de3e01222bed2b36d8f3bb33073bc35b5ef3860775e58c5c92adf79528edd8f42ea81af9470eefcf1ed148d800f6d8976423c25d7c6743726bedfee4b8cd70a156a20474d165a1834747591930347e87eb4d572b19f6b13b8f5949fa4f5160975e3e3c0c6848c9781009f22acc619395c0bbbb48e3e7490605051ad1971d11c742394d8420861f7fb305399317581753969064cac6ae0bde9c85279fac451764b62633d9e9115518a38aa20e2816fc965ff588990cf1e5f0e540865281de586412e20fe1aed8b27347c9d7b44d1580ec8a02777a8536a06cef0682b3f8115d10ad881b2eb098a9cc3543b1c72a91e10edfc7497e82ea4456b222d007ac7d0bb66892cd7ea7bf943b4925d44d65ffad52abe0d8f34f4f44558e552eca6a2fab904d45357cb7d47dbe1f6820f520ef1c2bffe550fa68bb452c02e058b1c63be8bbccde755f67fca5432a235b682ab6e33cf6f303c9cbd9df6679c671f5510a7fc0325a472ac361ff6790bf2f0a328e5c06fa135b2b723101ca16a197b504a90b05e127cbe4b2cddc88a108050cf164fbeb11cf8886d072e80f346261c6f90b7dfcefa25fdb5c3754a0713444fc60c73035cac77e15dae82f917c8ed6cbebb5ca5f580bd7d5bdfe80b8f71d458b5befd99b2fed4598eae015bc16e0c92babb1710ce8fc3b91fd11dfd1307056536d0547c32ff6b7d80900f20fe783c8e69f5821bed8cae93822897d32f55eea6aa0ec817e0af76459b05e8792a3171f0edde6c3be4d532090ca2227bf343ddc360670d4135c477a28e8cc157fe3b5c6928ba4b6a0910b13f4a09e1f7f2fd5c7dfe71a3912517e878eacddd23dfff6a7482d82aadd79cdffa8d393cfc58e7735e4aa9af74aaf33a1948a916706cd9bae5f0505f4d3e91a9a6434678072c420d0046ea400c29dcd6a9068077459a99a05833558913af1bf4c2dcc16df8867e1a38c4fc688f70690c03a765109248b6ad495f820bbdd86e634e8caf4d835dba399820445aadb62249009edf6d9b99f1ab4b9b2b99a3bee3b7e4c007217ffb0ced964c019fda2a91f8fec997ee830d26aeaa655f63269b46e708ea71e81d765b988f27eb4905f037c210b78e3b47a4f1e0a65a8703cafeabd3d2738a5bb2e4f455ccb1c023d60fbe7d1ae083ae2d9a83293122df8151c5f42943536a70dacc9081ab9587ef7fd8ab46e898fc42b377dbb1d3bb6a5225431daff3fc7a3da645cda8244076c07cf4e2a69fb5282a35433f49333e33304205d85d0d3390cb1ddea17b5341eeb631b9acf06ad81ceb66e3afb86c144eb1e0517efb7bb210dd8f80f515122b8c74a96cca3a0f68d1b4bc42e9a12efce06e040cf4402ded04e0d64612e319a01508623d3c616b1c8baba109ad4a6974a6eb8039fe1cb7048e6fad52bfe357ad5853cdbf704ed81a1a9b568511145ff9f39ea963b9a68d9e8cfdd724a2493a29413b59843922f869e69e9132678fdf7b33db075f1d0f460322f177b3a907cca722c8f92349b209669307a9b20e9c787052a809017a3d8bd2b7b9d454f3e15c14ba804d0714813821ede2d269880a8edc85b9c8f8e6abfb35e9a6b7a81219d1eb543e78b0d7a859557f4f9d876fc67dc3a63397158c1821f3bdd6727deef9957700c24860375e08942ad260595cc5be6d84e9e01942fa88b326d17a1a1c61d87169fbecd8e4b45f5409d6a940ccb9450bfda7298112c83de836a0f1bd9e2c510195264dc451d822b011f851316ecbe3e169273cd99429120e0fa4e2b3a6ee3b921b6631cfb58088723265a85785be0c327ce223747dcf40287b4f7f46461e50ec8ac5dc000d5e923d3d98a4f58caec1a754f0d0fa4adfe4a19fadb2dc3a13819b822bbe1757fed25732051886dbf89e594363497362953a726d3889ae9e700e4c384a9d16a0a5b3ba76fd1511d05bd42d6dc6bcb24155686392b4de68116a6021ca8be9fd65846116c1951c0f19a3b5d953477c3ea09d1e27394a8af5d068864d0a9dc1805a870bdc942bb40ae247a821f82975da2d0e09415304b641fa50d8e1c767a5bf8bd54cb4c988bf15865f856df2a923696e6ddd75c2cb1210bcd07a73b6099bfb426719c0da74c609b394b7fdd302083a5f55c89d22fe3ba01b0fc249b20104f84e36e47ef20b4bffde3aeec96706ee026c16af12631077bef0e54b6941a7714ffc750928b94fcb5ea1aee709a33cef8328768e26536e37b6fdd56747e68b7510e2297202728ea18e849be8831d93ffec75a45e6ad5ab071f412311a533917a5ee58c55f4ac82c6de9eff51ddff03f8178e3b405bcddc66ca67b8c7abf7b6a96f7936b703877cbfadee270dd75abec9da10532877d066b889a1455e3c2b96efbf8a70d9eeb5ce42ee6ed6a8f31785e84159380d866dc3eca2887fd635809fd9bbca08a7047159e4ef07e661686f5399bb777ce08361290a00a9337a5d009c5ef2a73f1029e404fd3544fc34785cf8462320f03a991c31265c746e9945d0080b35fae48ff8fc7c0518cd1497924a8d58331b79b10c484de475cf6b7268bc915aa656c850de4325ddf3c4ecc436a7c344dabe95e485791a69fc6cce5a893c747cf39a048f1a2b8ce6f511c98d621de0c0f1a7d92f54563abe22f065c9af27f5148bce2e22ccd8d4e3c0ffdd1268e08590526b12bcef1002d3e15308827fde32628de2163db40fe2e7a89b143e4181f49755c94951406d44fc6d6064cced124d16d3e8eabcb542ac17b86f42424717e803104aa9075ce88fa829633a4eccc2e62aca2aa92412d1c38cfac1bbec5a3133333dee89da757e39e739bba7afbe147cd474c118aa47e90f17f54ebc3f9b02ae055e9da3244fb8318af7031139c6ee486ca5b2d4947516d437ccec0abd5d5b413a0ee7e348e6606aa0fe3d9fe188e00de566cc955217d5e007334186790fc315a16d26b0dc937f2c4454a349ea2628b12ffabc455d0b5cc2fc82f37f679e21cc033375d2fc25bd71596456bfa7309f7a8f506860ba6f3bcb1b76fba8f2c8741d5fb7dae55eb05cad50f3bd2fccfa329f9de59a05440121ddce56e5838919fdbc9782302786aa04b797ec50575e53920679e991fe18abfa88850ed4b697f3741d633165f41f55cac9ada5bf0b875356e5b9ed0df27b33fb31d05c476d6c40d9076a3811482e70cd3e5ef918ed7102777fc12552813877965d6977c96b497a6fca6f0fc62a9d5a34f9f86e28c7984c62e40763073df4224965777cd9bc08b6d21d4039ef2cd716eb2a1bdf2df2f4cbd54190d986fed0b083c7e99f78e648efe9862b47c092fcb5148558481b3deb94574e50e56f289325ecd82131cb48ca71d26d3d93bbbebe73a68152371202fc37ddcaafc5b275a1c270d23cb1fb9ff22e2747a7b98b9b480760a04453115330fb3a5f35bf6653d0194f060e5acdb65116985766d5b32518d13aeab15ce20e410ad601df482ba287a0e32fbb802b96b74d0db8c2f14a97663179af5ef4e428eabfdd8b7b6ae1fd582680b45de3e7e1b68bc8e8bbd4313260e5a51c9472bc9264a9ec6f8c3be0ba6981951d1e7ebcefc6e2ec03355b60dc01fdea1668e1e84faa7424068edf075290218d2149e43db3deabfce3f1b3e0edb01b7ad732b1aaf2be52df0ebdebc799ee6d6939ba643fc87064d1d968e56d410eb1bdd608e7d151e23a5195e8b7460e0ad2fbd35a48f1b48760610fe283cf5a2448ec454503d598cc7ee5f26c5a9931a64963edf2dce3350b1b8081f33fd163b1e9aae9b8d16919c523706e936763f9f629ad8505dcc270ad22425cd68b6f115628901ad518d67a8f14c5155c7c8cc2aad52b9a4d63612609be55efbc88a8d26470fca0f14992ba460fbc12c70e255119944a1be05e22d5baa10dc0713b68ecc257a3fd83f51e19342c8922bb212e14938d86439bdb92fd2d46fc02cc7eb199aa35f327e7f3f815757e1c27b2a2e9630065d945a743f1bc94b66b2fceae0bf714b69f0e7ad0369483450a01959607337ed8880dc46016b3d7047da7d6883258996f3d14ba5b75b4fcdfbf0bb8f65b546513fd4c0c1284bbee909f204fe433282e4ad5060397333e54a11b24e0dcea40877bfc5d1e403dc7341157f96924773981346a5ace8741b0965d552c6666c1a60c40f335a68ed4fb5f1dd25d9a43f2f5b7441f9d37e68f17ad87e7fc1edebdef3964de60eb596ed11dfdbd70a2bccf46530bb622d7bbc9ca5602340cc2c8fcc5e0cc6af5c182e5b1967421733b9295ad6917bfdae701336ba3bd1349c2e6ecb88dbfc8449ecdda7ebcad06ef51fdfcccfa72ba6089f164d41c67e87a9c67f21ebb906a222abc5fc8ee289129d90984f4cd95f82a944024ade5cd483d49ad6c2fc85d3301051e757719825f328a8ad1a9624a7d4830a55da3f3752c87e8baae167654e55625b2734b296358bd33819c18e728b56fd6649fb85b3e066182f5867a7f1a6828ca1ee8650633da6fa4f4103a876e06e9e7c547cb46feb0a095ad75aa190d559621c76a32cc149a583ad15858795298917abc9a5362efee49660681bd6f42675ef7d50758e1e46abddec8507117cb912ad30b1eb0d79ea5d3046a16c4fd5cde167e6cccb9197f2ac00802d4c50bd29087e79dbac3059c86b34bcdfa2ce5e4c5d09296b80f438049b9ca65fd132d8c1215bc48e915e431ce4813c3807d1914a71e81513108abdc9dacc1bcdf65c5f9a9fc5aeee52dee0aba8c4af12cc670bdbb76c8e5327b5ae9d4659652c608fe7340cb0958ec07e38313deac541146670788c5ddc9e0c0e05d27206a3d496dd5871fd553228ac5072ff6c743acffe76cbf2570a7b621a4b5c43a038ff83a531952d66717c6db33309ef26858cf2e59f8a5e8d27aad8c90d7e65b9c8375937bf21953a8ac1548d7f99eb3a442a5cb8e8c3ae28d9716795897d0468dc0734df6239943a0efd1dc0be9ee361b54a9cf2105a220bf0ff82a16e9115022274c6338d16e9b11f2780f9555a66e9cc51eba63476884e1df8119f9d1325d7884df803ec5e12ea191831d00064a3a3379e6c2360eb02c0179a8dc4f380834e485e3c078c5018432c277fa7ab953fe97218779f5b8ba0d6307847bc8dc1dc047ee8d56d6de5c672ce0ba591abdb6881be5a15bee6459df0357023f59daf19085648b1cdb6f6ca9f91f99891a1fdf0d5051b00ca5a1e66a4f08932d1c3d7f1101818e9861fe9b3f3c258e7bf399f1cbda8e4ffb5420611d6218e3941c24e4a07ae7319c6c5568e53f08a242fd2d0cb5360f45d81bde75818fb6f24c099e90336f6e53312e119aa96aeec371f0f5c1b45d568177c89f46d814780ee2185fd0a8d2d0e2711a1f54028d4013ebd0b67a0ff080b2dc58204189c34cd1716bf95ac8a3711624cae6cc6884bba53234a4949ca2b5ef482ef94cdf33b645fdba832bb3b66f8631569d04929801a656a832546ea98fe429699a8b6230ddee7fd130f51e83e5721c7af17c6e318c1a2c4f1b443c3cd014adfc581b06bf4c827eda097b89a97f223129a94cdf1d49e6a784178fc00208f2693667b2e6113401a88ce9640d5b0528dbdb60468d65927298cbcea4f159146cc09eb6154009308a49e6fca49924b9812415e93eb4c0ecaf740cf90490fe2e17f3ba92ac4bec4774980eff417a3505120431916511981fa569d6d06a1542efed2567e0bffa4a0d3582a7562f684455780d6c55e2f1a4a36b331f508fb758ce001abdb0df4f50fc6c979bb23b19e3e40b7b5dfdc8b84ae6dc7f04d649a04f85000fb851da737e550173d9fdf7499165b17e6847adb96ac11e97b5354978930260c57ba66d263dd44dc07900a3988552f1080ec2c88db7e87ad25819570742c68d471f656e4acfe79e653283c19da3fb4a1a5ec03aa7d35ec55c7063365f51f7e9b49a64d297412f9b3def95035837eaaa95d6d755c81b71da9b183eef19a6b1ffe5ac9bad6b8aca33d8a21be87659598e54538e27f2349efa562a6dc14f1c04831f6a6c6252be8ee74a2cf4880fd32d04ac4db4b5506a69a6af6e15e4a05288090e8a45a3016f96098269792df3986580049a01316035a68a6afddd56dc36a27790132322e28ca6c5e77fcf7f69e2e6283eff70385c95bcf5bb04c19274b58ca8a5f61a0daa2f46708d4628c4cd1afae06fb7da3c211b4972a8ee2f34749a346e5fafa0d961a492e6297384acd85964b2c33dde74cbd4f610d5fa52320d54fd27d8e36fdde0c75365f79cc66c51b9df1ec76b2f55f7200528479eda0c74a37dafa8a77620177e47c5ec1b78e603951285d5dc993782bbe7de19dfc006b051889312a0cc2d24d1f733406f18008c419e96c35b2937ef2fabcba04323ec0bb6bad12da069e19cf25d647437e64398360c323312c1cd8b94b1373e7ec986fb94f5c00ad20a8c337507eb31985e9277e478abeead953780364827cf601de37efa8f070a53348cb6ac3a18da609e651c6e8dac9fb1150bee2ee4eba231d4edb038302513ce57c329efec805bee3457c2781c655974e6fa3d325a7aba09f126a2dfda4d16716d1ac33d560e9742fd82788ff6d0e8705888a0edd944402d47bdd85335b2eb50aedeccd2b5628e5d3250e38016b637b1da815501845ea90e37803c9350dd4ff26a7ea634ea92d9624fde384c8ab1f956dfba13a6044a341f487e203ae331301d6ce5e364846b8101026db94082655c5ca5aafc3af8f9039fa957ee0b51caec1ec791e2f84ab9d935892010df6f772f5468061ea98922017049c49126322b6b1972c99a887cff761bd493bfbf7aeec8c63b0cc47d345a093568b830d584499abeb84518c16fded582dc5ca8b117700a46e8eaadd249fdc22cf9b7f5d67126539372f902adaabc8dbc3c6d12231c3406917e9f048fa39b4f95117394b2c9f555a12fadbe01a6160dc87439425aec8e70b0b6e9b72eabd7f45b8ea830db423c2f802ff4fa2a5d78a2cf8d3aa89f23e49760efa50293853937f22904a4a5bc9a0b9fb95c281bc836849dcea21d3cee7d47da77bb318a54e869ba2afe2ae87dca1b8e35d5b4b8c7004105c4a3feac90368331bc232aaff9212ccf5ad7b8906b1e98a6213752cfd097c9bc0deba655297a3fe69cda1f4d876461105accb5f74a84ea910a047403f18ddcb037e881840ed77ac1685dbc21f8babf4d0f431761e63be87b339069fb770856bc2b4b5dd1739076b926d133a965143a15fb2616804940efbf51897c790e7c576606330f5ad4c05353f7f54eda3c34b135bb1d58bcdfd364bbc8c41a3f77fad8acb749f8e113405a87a5b7967f36c6260ac2b35f5b57dc2e10d502569bdd655ad5f4339e9d2371648320e0ebdcde333832d2739fd24d7a1a4c624bfc78d7694cf5d89e841a1d687da0fa1b7fa119120d5d8537823c82dda013b30727f7c8ba82f9e5ab0faa9bee854cdfb6f2c5aba32e580492c93a55588a6df6c19778f6975245b04c2bdc87f72090b831a5f6d7b5a0db871d063141081982078618262f20a5c23eb52f6e59478054f64718bea4efb3fcd68823b190563f14dd47e2a1308c9bc8c90940d15cb92ddf457ea31eb0c0aeec555788a6d10c9490ac7b62116774e7ba9c4c117ed80fed17cc967006be52d6c36c32ee8122c15a830c3334e0480f64fa1e8f31d0ce015f9820c23c13853a6f57487c9cab3f52697c801c4e04c5a881f56388ef92d971fdc54ee9e2e893446cd4c13fba92c65ca029013c954c6cb7d608a2d3ab4f83c557f7055f6ca4b75e42f22bb062f169971c81270a81c8287b3d1d7dc46f25100a4c4d416225f4b161fd2d7d38b82c1d4f488de71de6e4c6af5552fc5b9af35b810ee01ee885a13e45374ebd9d018adf1803c58b505120c61a3745ee0847cfd039fa8704920640470267b9a2883cfd0be4b8c734807c966da68ba90597c4f1e3b26bd70ddd227116105c0362fa388f54956170595ea2405c283cfb455cc47a8595b10b5bce3277fd4760539f4f367c6ee6924485c0233b640b0c147cb01554afdc61c8defaf8582a7736aedc9893dc4c7d5f057e8abc4c0ad2ff2bf1b21b2376e6366d8ebed595d5803e135de30f8e91e2990a355e25766abf0d5e0b8b908be6072860f0c45d2b9142d4967db41af7cc34b6d47bf736af699f608c7ae31343aa6478a96033eb1067a0fb9cfa09c3499c7b597198f64be7a20084897ebd17a5b66eeb004681481b9079e5967c980ee43a50fb8a71e16a5af45ad4af1b1a050ace05ea90acac69de2cd8d3fa5f8bf9e00942573401778486e2f143289cab24c9315b421771ae60abd0c5f08d37b123c94a21a6d3c4fe0721a98d45607a52da6282808f479c2ad8e5c6142ca85255ae128294f9f1a1a5cee34ff35f59031a45a5a32b6d430d5ef444cec63e88ecd7c3f71717123228f81f116939a68feb72e0e7e48541a7c25b280611da1fcfcdfb45036038ae938f9669cd2b13d4fc382ebc8715edcf189f29f88405b6672500f40ee4d22fe5726b24a5bb11985fdb3c1205461dc5d4c8981bd2406b7732f1c765553297162d8be95ecb2ab9428b10a4cd0288fe4bc0e2b3ca366f93eaa1ac1e7c10ca4935cf4154c17a5aa476ef98069bdd343180531dd325e9d29b33e7e1dad96c6cb380c1adfdcfeb646dfb30a2a57cfba516f8afce297100752eb17d1e84738288776c046992e199a6805505071811db257a174a66cb60ef6920c1922c072cb6ee4bad1f7ecc097efc170d35a2b1a3dc5148a9399f70917acfb2f32451427a93ddc1cc6ca0d6a0124b9caca8cdf9017a8dd62a8118359f0645a2007cfd0651186515807aa9c471379a6511aab91546caeaf1b08ddb902169e6bc4ea3353ac7e503ef99d584ef05b6ab5ab7a00fd9cae6870c18ce28d59cbf025d08d5e7fe7aac062d3270342acfd591fdac22cfc39e627b9e79cf3a2c5044fdfb867065a2c695314b93fb58871d512aa585bdb9a719035c809069e6c88fa95061763754eb107cf2f41ac806066d27aa699ed809268bf83abbfbb2e05d467e2abb997561d50f524ef0fca524ecc0331252490a509f06a85fccd245a4fd17368685938e648120534d823dfe84cc1167478d4f5800a4c35cb055d013650a1edf7013c34985748dbf2cd4769afddc6e0e124f00cdb94161795d234e847f43f3764001f5c4a6abb288e2f2911469ddac72228911b2fad75b002921551c0529c79c14f514db52f212506aafd82bab5c4ff75aee8440b7bccfcb812a28624983676328177c432a1d8f5dae0fd9eae63b4f577faf04f6c0804c6973c005b22cba7fd4d5d71bd8fb6623c00c985b935a230fca58e17808145679979059c842208675d7e4eb8172bdb9094f1f67316a81b9c26084ee022f7974483c747c0716f70d75ee3659937d540f946670203377b236de49c49e9f95002d8540a67c294f83f2f3164cf87fb3d401781623921e182f58393424d11155f40d4c91b48a4dbadb49fb3d9a3f39e02e4827c3682f490fe83e22f2bbdda218aba4bf94f1272d34cf35f5baf50c433a0ac9dc233ddbf9659cdfa66f09f0cc119235e67e61a1600806f645ebd9835fc53e9d55482ad153fec32a2ba7dbaeeda3d66c06d13642ee31f67c6fa9611e1ea7ee3322f7a15dc86080e7931f4a35913c22d474cfc2e13cf65c15a310615d36d5daa76ff1873e73e78d55fd1f865bbd8129f7a3b52d9ab4a949cf2b55d7519c0160f2d9d35616b275cbe70622e5a2ed1abe124f8fd960d6039d50c504a840f919c09e4131087334d2eef3f5f070e7fdd7a9e85afeb79a0accc849e0d7f58e5ce606cf8b9e37889554688f6456bd7ccec231fa03129198664a8dedf862af15d4b859725bf5658acbea0ccceceaa7f0c053e0ec6288acc61d8cb1786f53cac7f8323c49aa360d553c8e8116257c3fe68ac1d4ef79404569e94aefeb1e79cf10abbe847672a695283e3172e71b0ab91fdf97a7b65ec104c7f27eff850990bdca6faa14a8e5dc20130494d080ef8b01b24426000c718528b22dc7f55a585538c9bc227264f6a177d37041d5559fead8f9e8ee6f16f0ec2615de2b9f45eff10eae74d3e9ea019659c98ed00d33ba15ead92fb9a196f5093ad161e3ad625cef9325e44550397126dd9e7c8e03b2d1279b9c7625d649f51d9e74e3ddc7ae99645eae1cd5839f53ba25d28840e4f6e08d2d5ddd6538ebe7be12ffa0df9ed142b62f41d9923ffb7965628499079af4d521cc54197b92074e0fc04f21c05dd3eaad81b99349a774411895958c501fb6dc683b6f0b7e4a1d7f46403a5fd4c242708e4d54a06ab6a43fbf9fbe6699da824973df7f5acfaab7add9ebfd85f05b622b5e6007ca546654db5c5ae6fcd3348a849a9d26ee991beab69a2f2ae9d33434d570aa816b7e83c667cb2dc5368b9b44dbfe44525fa2ab585f60bea3b6761fed0dd40d3ab31a0e18564478456246438e702b2bd490401996ca38ea37102c7b7158de3b70df0adc0c2c262f0c717ccacae5b30632c40194c9776825b2ffed1ef09ef205dfcd17c0b2a11e8be074199291483d1098d2aa53b0665b3a7b4b454cc0525e6de4929e3701ef2fe69d53726ede01ed7f0a7c2655b339e74e2ad761f963aaaf79027d3451c5d09a4b604a14842080f39d306aa056765c7cc953c67b4f8e68ad2f0c8e217fd120c6da073eea06565378c22dcfa0902798433b0db2acf9fdd8db9482df55a3921de938e4c032f98cbad9c2b92e04bd83d691c93c2bdc7cc83202da55a0fb128ff1a7ac5ee1207fe115079cc9581a09b255159f8111d18eec18f2a08c1c194a381f849e1fd6996bec3f1bd97ecfff5e7040535bf82a2b75aab0d8b862030efee774e770c375c4ae6a3b390233d5d7d89cf11e117e1b1b9ea0caa610e655f5902c3c33ce6e00973ec8ce78cbdfea776f8f492d2564a8329993daab2301ef66fde409efffa52991088eeee70f2784550377564e791e5aa47304a91f547e42d70c3bdc32d7293f0134ccafd0d9bcc9b5856f34e83a9994d87d1aedd9591e4a7a485e95976e879ec452a6797322c60c12ff7e903c1da79ab6ac0edb75df679a3ec73af41a5ef1feaef40f046de9262358c0952b4cd8e369751bae5edf5214fbc5c37a17abc63c13f00e295a761ac4caeed6bf842262e13e34827c7bbfdad9769e0aa981b8019fcc34cb801fe384928dd12cc38699fbdffd6ac734b34cde46b28783eb0b0ab81d76119afb937c9ae2ac5b8cfaedb032a58999525fd0763a67133099f9f633f1a37d48128a65fd845932e88e819f083bc07b4198fcf0aa80fb7b13f4444a836d42c0198004cc354d42cf7502b2315a3f2eac234043a6c375f030fd7835cd23e43802aafa5705f4c370ab89be99372009a5ff64cf34863abbd046563548a71d176c7c12416e07190cf91cb3562577db5234316116fc845e73d6b9a0c300f142b1526df16a3337d788583296aca62d11500d179cb0e692caf78b625ee44ecbe6e7732226ed7969056c7c03e541c96aac6100f003dd2e35323dbbbaa946cfb8578ad6d85de31f5e679d49236bb0eb11d526809e34a6dc817236830551042afaf72e1a77e223cc71991a4dfee489b7789b7801bab38d41d105b306fc08d221f6a0773ecd87d4ad7ac4c5ce27b0c2e2476ddfae134bccbb81567e914b91ffc04d9cf2357010e2207763b0e7a7803abc21ebc22b910f3f9e3407e5c486026c286cd0d9bc1cbec5068f07f9d3c6a02e7a3fe9c11e84b18eb10ed80f6d2575f202241aec773556fa78bef4244eb6db988dee602103c0ca462ca98b3e2539c88b039a052ac78903146b4150c70d9af8b10a447d7e620f07331ecb1ff5392e3fd99aa5eb417e5df30c9b6d28c47a467ea243b36ecea7f1029bd6b5e347e8c3863b698adb64b72881f293580eb0d61ca8def2eb8dc47278579943abfa9a8d93a39e60c939fc117be5d2fa6c9cb235fac655f615e1930c18ac91fbf0aeca983dc487718ed289ae779b3b7d6a4ad60c2a207b53552531d92a6c7c50eed5cda78be23df71cae3faa1ef218c4e25b6dc48e99f3127fa2e67ff2d08f7e08224c6c588f45aa6633c8ad20769f0ea5bd4da3140a94f52f9e348168d84653afba776f249f3ef7481e97bce9bf3a1083ede46dce51e4040fd279a0fe249ba1daf2be0a2c77eabbd511d6bb8c70f1ca1e2ddb15003af31bf20b91774ac3ce63c9232f69c998c569aa53f5faab5d08e47a446d1dbaa57bd5c1994ff9783865ee1f9a11cc5a0a4a0f663d118e69199eb9fd4f52bb472cab63ef921fa0eb5de02c9296092b39cd8fb86940faaec726df4368c7a9c252c947b52e86b867ad3688bdeb9cafcac52641c55338b1ea36ab04bb1c83d63b6e3cea658822683437d5138fb4d2eeaa9391f71b10a4d611b842968cb14e9af4c3e0f46ac024fbd6d22501ce22b55b690105f788221ea80a6b144046881171da3f391d57f8032c74000c8c46997970548dcf1fd1dea96133124b3531c2caf442ca67730961e8c6ef8acf15d8bb7b22274488f10ad9c8e40c98d0580bbc58d1f03b742b2cf7c3d8cdbd6ee2e5011ceba39635da609911ca349ab88d52f766672f5a7fb51a75e77c38f016fe0615385afabbb08818586c99af88831ceb89af878790c699d2f260a2a552f1157e06792127bc7aba870f6d0788a1320d886d9f670b75d0977543de7fb49052421fe1160aa8f996c97d4a5fe5c32bc3d6624ebf4a20a1333d4182beb834427912a2a419bb92bf024c1e3a23f5506190fd2fcc018c607f5b6542d5f3265e60c99ccd7ecac22dd718863884c2f9d9ecc46dcdfae1e34fc28964928c8c0e80b432b211734c900e278f31e63a852f201adfbf2d75785d4a313","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
