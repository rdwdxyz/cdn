<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4a25e07a71b39a0048d6c6ec890961c1f899ece8e464e3ee276d3ed3fe33b6ba03148a769d0a5e813da8c18e57398ca306d4b5ed1cace677b0e0048d747dbe13323ac00ddba14dbf0a667bc39e085bfaa17412e0ab31f3e67e63003ecb9a098aa8b73899396ac9a388bca325d963262d22dd734f08ad3fe21f2d2d34157cae81f9f892f4121ce727820d90c19d8fa4a7c05739e5fbb9eaa7b08ee1299f0ab12e46ccec5813b4ae277c42a7643c43db90f059a9e9d77545eb0489db9f98effc79806fe835aa38eec59179be7d2dfb2251059cc690e0364a5ab9e68b911f6cb1cdb6ebe9071900bca207125201584d127303d6ceb29d1a93f32371a1123f316b922a15faa02fa173015d45c75ece029283c5dc94f1ca10c3cd7932842bc85f63c05751b6a2226eb0fd66a002f57dfe2d7a1ad126634016515c521292d78f17ede9ba258c0f01b3b5b7df376facd00ae32186f0fcf36e30524fbadf30f1d7076c438397a15993aa162aaaa7ee7307130407f571d843ddf677a45f6cbd168a2aca87ba691849c598e0e5dad9be445b25f036855bfdec55af2b55e457c0b1b2ff1ddc9e647b3f6126bf056e16554a5adff02d5c0be98be1aa2ef3de858a97cb76fa5f45fefdbc17faa6e967910625f99c9a16487bedc88ce5229e57da4ade1719f6ca2b0c1ccafa28b3f9034ae06e1491271811c78e35c9a46dd1f7c83ea0f5bb0f1c5c529de3d6bb566a714cb1c56521d7fcc7a36c2e93db2fe52cdcca744c65847e520f3158ed565e1ab55003e98d636f8a9903c2160488b8d93ce6cd3eee4a02c5eb954a0821bc334c309dd08c23e6091487d699fd54350626c2a46fa180081a945c04f1265cb2d25d8dacae6e483db9ef9138ed8d5466f740a479d7c41b52eef4d555047b4560548ec212b2e1ba817f25b9d28f829a3e9b89cfda1302d7230d6521ab75500a5e208c7bebc8dd97ae887e6b1fea91a74e662bfa940b367fc59b64d00621f218921ddcaafc89be8e8a234408dc70e316c89abd428f97314c5c9165e59eeac5dcf4e15fb157c66b00c6544d2b4972f0afe197c6d59371dc03c0e77af4e7bc5491aa14d1bd63d3cf2b500693e1d376c7fe7736d03ffcb30d35d94671c019a86cd1fc8995f82056cba9535446d1dffa153b2b2c050cebeb31865a83a1ba5dc5c01b9a8a55f8824af2e217eca943aee65084c9c1e43d8e36013d1859c2e6a7df2bc742078273891cc61a85cb95a11e153089d77c0372c4658cd02e73ce5a02130a5a380ea92ea824ca8a418bbca3d9e09181a6606d19b24132f09bb9b97cf8bc11a9e90d18e355cd5a0dd1e826c677b92199a91e91a6c95a0d042d12f6c23bec5fe0cbbf44f878a39c360b3c66c125a1585aa91658bf7f79bd08c81a2e5467702e5db61141b538ab77b55795f6bca79670b0dfa6828e087f105a13711b3185bf5bf2e01bc99a8f07e3838ee53d0352bdcb5b7120dc30b22c5832785341a8e5cec283e1ec42b1e7e4ee6e452e8a0f32dec1f7dfa4bca34007bdbbbdbe58ea52f4b52b882b5299db2f6d306cf2fbda3238d9eec0a60201f47e5ff45519128c0eee5bd56ab7652a3dce6a9ad2124dfd095133ac5813b94b9f6a573072ee96681c7c60de9028c594e34c0d92ae90e6207d448fe7de35653af78ad9ab659bbf37dbfb6206c585bc0063eb7c197391e6612e0260ed3ac1c40d3efb07e8d81f32e01ea330e363b0e6585ac61d194f2289f8078e4411c5fd822eb0d2d92ea8575922138aeeb7f3775d892bd5fcedab1ed71d4111bbc4f6a21626786549d0712728c4ff003fde13ec819fba1aecae1da604d71f7d86fdafe44b98f09b93626e214cea5fa2d2fa6cc57fdbff201bcf89ee42537e9d1de8820e7ef26e99c013adee9cdbf7caab037bc66e7bbea83d75450d12c51f08334b52ea424688648e5e4de186e1eb5ae93143045ed36105bcd0fbc49750ea29ec5f65c2e1a72ce1459a5a8af3ee9b85cc67a1b9f7b6bd8d4eab8612178b057032c7d0ab8ed235a99a497ed6f410b108c94f1f79359ec6467dda654cca59b1f60f2a7a29f9ae665445e9eb5907988a48f16e8175b24eaf825e2533aaac21866f19de8007077a12e99cd067cfa3912fd6f4d3a741797a86fcd2487d323b4610be82c2c97656c357e0302ccc86de3c7bf3592b380dc6afce897a4ed8196f499c020e4493f3b3ceab2fcffb98fe49bd988c270d5915fc0c2bc464b6bf96d4310033d4c7f6038a229df387ae816d2e2e76e4786d22b690456a9a9b2a6a757e47af922e294e764ccdb7e73f661a720aebc4f79cc82730050a966728044ebf2909e879f34a1d9d5d44ae3cfde67afe72ae77ac9080c97ffbdb97d2c8cddf319d1cf76d63e7a1570ee5160dadbac1844adedb3be448e625f4900a52276cf66c18f31872656caf3afaff1ea210728d15e26627c40095f534b4a32b9b763dbbd94cbf3ece90eba44f18a254647b16fce534200338ae2df61679c7facd4adf16f09c3e10188ff75491f1edaa67659ddbd036174c44cc4f5fd71ebf1d68f3fac352b182d5c7b3b959a030e48ecfafcaee1c30575c9cb9c227b430eb5fc3a062adfcbb46d533ac6daf06c77bd8d09c21b3271c9619b71ed66ae21e1c12a33ccc97341c3a08c95c3740ac9157081a42aef8c68a8fba27b78490b97e7a3d19c1cff5a2e15cf7f0d1ad6e618825db9f762db42c90c943a45502e9307fe7c1aad571a72492d9fbce41a60bdc5b9f8aa591c1a2d65d194a477a30f3c99504b05db7207288ba4ad85aee0dfa042369591cc9dfab5a5202988147193871b040e5cc003a187e21f329351cb256cb94cd8d78ee0b2d5235014f730722524a70395d170a77eab6417f6c44ae6169c393d05796ba7615632f2597f062599d4a0ebd6e8b56f919331c6bbc56c0c294695cae4730244f00e810c166a59ee4741773bde127775e9475bece025a92b540a3244bede093e03dbaf3d9711c73973f397718951d5e8790d4fa4807fb8ffaa8393e0cb78a5effb22b99e63ebb904ce94834a6f6f844911936969ca69f9b28243997e5f388550615ac5cf557dc6a01ca8aacdaf46c42088616667ddcd3ab08c4e9c5e51b4fbe4b7efed91e6a080fbcfa9bc257ddc57f6ff849aa760982a0738c58e6c644ef71093b9297dfd2cfa115710342ad7ec7218a178a665ac5282d4072a5f5f82893436604ce88eed31a3ad13a7d4baff950e74886d7fdb133e0588e6fdc93a9e7b54e876f72eed66695f1f561f77f8e1015591231a3b263330c60ec9638f633bfdaba2a11f0c9efb2d0b8519f61509fe157ac09f5dfc6bca2d4666f8483ce0cc0be1a679578d038858a5dce54da221e1edde47542c3a3c3c63dacd9a44c092e13724b8d4fb1f954b41ff90f3bf6162de0d0c5e354e13c3eaf57dd0c0b729e45470caea5de87d788b647cd17d46586ee2900c8142edc6d26099d1a60b77fcd0518bc818d7819f8065b86024b766fd3be02ca6e8cf020cd893b98024e2eb314316e3037080fdee3240297dfe5dd12bbe6ccd0f727801b3722384a5dfe0a1f01351036f3fa4ab875c3b21a7fb4d1f6fcefd91f11cbd33d6fd9bfefad3c327fb067df0b14a7fa37e1e602353b616f5b777043b442545e5cd53638e8762f83b88c2aa3e9fa8f153243d229053006f011c0424d8d1830928fa47434acf4be7e013d010a574e9611c8b7d7e356ad9deeba28c8803805e565c9a2f5a8c4c01f8cec5fb8e275768717b437b48d85f41cc9e248f1a95e8d16834d970022f7a57117908eeb9683b3fb4ff0ca407c0a199c16fa8c08e81c0f6effbec1a167ab43e8ad6c7791df49367efb5321b7df5e81837d7180add16188b4486967d7c3529adf5548eba37216ed53e85e53cc4f49e8c55020a5d173371f2356dbcf847fed344a1690a436acc5a2e71f1322553820551fb5b72ce007bf8a8d3e7d46c8da5cbae4d9a5d1c16393e6f6519b2b634b2814c63722dbf4f5ad024704d1924a5197c9be201a70d5c895b8e47ad08fd805070df2bdde2aaa0d46d7cedb196f712f801c5f3e7bcc56ef3014003e18e131ac117926e4f734fd9b1b2c58c9d44af465197d686a4873bd1cd46cf85e79dd46ff5cd00e36ee648b03823cfe311c6459a862ccca416237f5dc43dd382391dbc8ce273f0c7206988bb64dc5aec25d377d6b547da47f90f5b125565171a3c71011babf7e60cb8d7eb3ccd5baec856dd5224a7eaf11e335065c8c996f4bae6cdd68f617019b016dbc1f48ea4dc24132b0c735912313466c1778e3e57a25e0d9f169920e8b80b7c74d2d34e84343cfae466f3efdc59b9d2e26cb93efad44eb4488043032aee0c77b2b7e5499620978001048c2e25273f967448a8b67b36bd0a48ed7636a12c9f7348b37579ad304df49b76901ed7dbb62cc4554dc513dc05254de715ac19d5f3fab6cd2d2adccf81b0dfa51de31ab0e6202058878f7da7304ae3f27c660cc640314cbceede459e8d423519046df683316ef36b0b4ac59428e9b077e2a87cf01b098ab5b6bbd5f8c66cb785940adbf2d8d1a9400f3a1dc1065e2c557b0f4414d8464a30010cfae819930f68f31af355a4d2845d8b9b6b84a049542fb0f602739dcd8c7888300f976d9e6f0b3aa01ee8bb25a80810ded49b40a999dc325872d3a469f0948f23ebd2f34fedf88f5a1d9552920227b3e33403dbfa740c0e81452749744885668c7289bc7b9506867f27d456e11b567c5d63af201532f6e630f14ace12422f9e97918c8eac95dd37be33e84f7af09b632102832409b7d8a60a7483cd6f6192568d9591d8c4a7eab4b4b9f993754f39bae1a8be78d16ea4c2ba8cfb572efe18843b365c0f6c9ef264b717eac83cef12e8168a70d391309155a8825c9f39fac902775d4343a2a50f5af05cd4ab8cd52c4c2f08225b945566a379e59177dd7215a192d4246ea587d31ea0a9d138770428e32ad008d5b73d34dc13838476b0b4768668bd794172e56edb33fc244aa57ffbe91f5877233f5ff029cf8ca904f41f820b4bce8301085e2db79ee85055cda551ab18a7e1d039c347d94d3a371b1e8f1cf3b65c6ac7c0a7da47072be4f89b16ec0cb00ae077a74da810ac101a9131467777dee9924be507c797743a9ae5063c71959efbc0d29ab5cf0ab01225998cc957bc36d17741bd6ce379fd5a2a7049e138a227c9b3554c2719d0d718f4cf9cdeba6eae0b46fb2a958c8f6b5baab6a86a5c865a7951d29fbd371c95c69aea6aa1e7c2eeec324aee34ae87afb12c54d22ce3c36595dfbfe1596149803a21e79b9fdc52b0d06ebc878e756e4bf263f528231ce20fc70fa1943fbbe5d788b0009aba476011fb2121040c40ee14e3947e44d4d8dcbac0a57a5b364d87b29aba87222465cf2fbccb5dd7241f7544086bf2ebd624c26abfeb3b08c41727065eb9d0f3a0b021bf38217d1d8209376272417585b7c7edf65d229fbafac03903cbe95b350f2a6f6c2b3b7e7b2b1a056e0e6d7246f0369e8b340e0745cd3af6de05bcab1a6fd4c53982a1bbfd1298b495b15c3719eafbd9d3da6296080364f63e42f3b7b20fa6825569c456fa3df1b492e9fc1b130e72fbbbd6836793812182984c13732fd8689d6c26ef8cace5d52e21a8a20ba93bb8bb95769b57ac7d5c165e500c678bc5dbdfc049cf081a6fffa7fe43ad47d1a6c3702d368364aa165722954561d2b6be3c3209c7b492cb21e889421b05e97a9b1dc8f997f545f1d4f8f73c497217a0fa45bcc315ab8d0323d60091845bc306471446f106bf56f85706028cd05d7a4496ec4786e87b4801d8908aef972405e1d97ff50769ab72d8ade2fdb78d751cb759fd3c498b8978615c4ce13fa89979694379a92ff5d02f3022d1fc47881919facd347e9a32d8216326b09977f17a6acb74dce883749f62000725b5b6e176938491a71a2b2c3e17ee5215bbf22443f6c089311a6a49eddb6a87fcc314117ce3e4a603587fcef51ae8fad7d9d0441e9fab4270c7d8a3751c295a3674a4cd928365917f91e6d0e172d4d4ffe0d014a0eb01799d367030beba4e0a883d136b531764138391f0880d91c0710badb34c612fddf6071ccdc0a8aa8d33c17e85a6944a4bf47d18541ebd72d4d24acbc77aba639de25ef5c01bb9f253399e35874295a6127f1fe55c9ab41b38b8fc94cbde9dd923cc326b479575a13ba7dfed4070e88e2b4b8ea68bc41785d6b2559953a3c77925e4c15269a8436ca1996e2a1136093f1f8796f5a82d84212efb6643cdb50582e5c19afb9164be1570e1e51650bd5292b1272c5faac18a15bcd402423d7c6dd91e01308dc6fa44eb70ba975fdd4213b554b3acb68281645e2885a9e4fe0efb77573043bb2591bc2ef861456809b07511198f83359a39369504c70d797a82ddba63d7d3718be9716e141e002541242f528b0a26b238cbd3784ac90fb5368a4257f1d610b8bcc1c610171f95555b6bbbdb948f1e0d110e61fd65ac807e54ec310d4e5e3862e29e88362055996f31f03b94fcd396081deb78e1df100c21be55c10c21bdeb086f1e5b82f21176aa643f04aaefbdf845b22282640bf68009504bcd278f10120d1de3d2478ef180382ef81f9b353f079e00c9c3f3180d16ae0f9d875533cfa76b628dd16fcae7765b771c2c70f893d08ec5f660cc98d33aaea64b77e37f1f69489575e1489dc58f4051e94a433f551e48a483283ba64532bb0a4cdb9fbb0bfe9d46a1d998b782a401600ab1b84da667343329dec8a1f4041254f84480e13702c5fcf3099e67e9f06058d855184068dd55622849856316aa95ede8867384607ba6cbbb0d031a9fda20014dc6bbc5b7ddd023bc977ccec587a8c5cc96c5d0b12c39704de4688d5896a003898d5fb75087000ae97bcd275c1dcb0c6caee33b16647a005957b5c0369b4279b377ea46195f0660b58e89bc5046a2b5bce2476eee42c6a8d8d91a4f110b4ce811a64663fe8c9a612708674f9aa107dd09abf3e470397a25904a455a835927240ad93a73ca253a9d4134921151734b9d807a49085e8d18ed3313c3518fc71d8bd95df5867b1f3160063698cff10e5bfbbdbcb4b53851818afbc3e04fb1dfbc6ffd5d01f4654b2e6763abd1322606f43013ecd9a14c41c3dbac6e88b1e38630e1bfbb23131d111caadb87e5537dcaf8c99f7b12ffdaa5ddd3764ac8f904c5a08d5c36947fb8e5b93ae1b1aaee2577af47adb0dd1919b91040e4121376284a72b3e11a51605259f91e9d1549837ab136121558da7cab1c947dee67eb6131a0c157867166aafcbad25d7671671163d63c71c863084d2093af5de8838db86f67bf8921e8b4388dd35844c31f1c32e95919ae6b26df492a8671368870395ea5d7ee3649ab9756f0ca88c66fa46071fdd4774fd715a93a996ec8a713cdbbff891b3dda8ac3f228b27a5102389fea7afd1cd36b36e86fc8172045c3d921e71d2f632fb6b5b10bd42bd63306db0144cd169e147c06dc2066ed6528185d2c0ef152ba17c5b57893204f0d3d305c594c2c9f9f31e86f3e46a8544b21b60569b3d2044000ffb7c162dcc291525dd338b3cdf65e9287d71cc98924c2e6829d3ba3510591a0c28885dff3e482a23540920de6b228dffebbd14271c83343a75ab91473087a9d0eac186a48cf73ac8c2ed4adc7c9815282b3284363d3cd59cd3b4fb0671442c2f2a020c687c5037f099034eb235f1e827fe8a484679ab8837b26a790ddf0ee7de26b72854fbba479f2e803c8045d5827fea59ad04e848ee01517d118f8e7db2abbd5fabf56d27e90f92e14b225e06021fd5a4f854327f534b389c284d3eee92413a8a9d5efb9b8ea0a4d9d76d0f8124ba4210c46c35c52953a95cb22157cdf496ddb456b2a3932d9e47336194b7965a1b62e8525150183e3292229759d6d4b63373009b3046bed70ff4b8bee6894343d2a2f8fe4645aaea4c1e8b440b7836656657a0822ddd023b68e841a927949303b94522f01862f63f162881151d26e4235661189d906845dabe7935459a67e4b2e8e0091b129825b3c79f83767b0d9fabbc1ede7323f1ff77a11c8d86961ac5d576ceabca084ca44c2d87a450ee5cf84a8f23dc91de1767559f8da873d61cb695303f6377c2a35755d4bd41d5eb6b2e3e364a9589e3cce389951d581fb7be53d8067b3f9677f18e583a006af21a0876d10660c74411ac246674be64a78ce720d3bc124854902e76b0582f1972d5d053234685f25a555eb9e7de56ece141301dff3d911e63876c22089ad86d53c88a3bab3d674891cf5fa5edc7c10f53a1adb32ae8b6f990f2ea26f00be70dcf222fdaef2ce2f97d2754862c1cedf2e8eaf9d0078295c23399dbf7d7a8d52c7d0e8f3272cb99978e1d10b60fcdd1b6af9c79438003f18a48ba82ab1abeae3d61cf196a45a8eda53c9f04b399f065102b8fde64b4b10d120cfc67f67d5377281719ddf057a53ab30d7dca0965f54268414c07b420c86f489780d959bc643ecd70bd362c956ed627d004dab86d9ba923bf4cb796048c61fc82803687a385bd2d2774ab00a9b63ffd211c6fbd656db72774fcc8d1ef603faed304b48374176051c022bc8b239c4d64eda2dea66220828cb8a89757a718c532e1d274cce311709e1ce46ebbc69c83e796f3ba42771b21be13c3d80385bb0c8d4d3c7f2e0f1ef448b57333f38474483b9402ff990b1fd9dc0175f561cf4992c5181a92703a2e031082e96f09c29a737c4097cb1f2eb7580f5bc7a93e279fb296715f0f950238f1a9c0ec8b1bb54687bc57dd2f4cf825926190386ff48a49ed682212af0e53cfaacef37744d45b26a2b9cb8b5babe5ad861e00e2cfc882cf67476fda395adeeaeba787b46b91d70a7198b3937c11dc6e65f5375222873d78d3c576bee8a14b0079261765b048bed0ad71a719c09592bba72e4906002c83da65ccc77401a320fb2ebd94f5d2b4dee5223a8f0d89892dd147bc3c63b083d8220c95e8906e92877a2793fb0da8e754c3cfc9f43553947836823b00ce18a6c1c54c6a157ec93abade8d9d5126f21de5f7ee3a92dc2a8fbc95152b98835419bce46581711567ac00735b8481c64de2eecb4f4b366bc7eed9ef9b451436c6850707613f65cd26c49ecf346df86d7b23d280a8c7117a183af2f55cb18ec373ac2e5d3e928efb4fcd662d5f389a0bd9e2b324c856f2456429277eb0f7677f08a34728c3011745f0b39b82725db22a30a55d197da3fd9c3e66158da870ad409a9f79c5e077cb90c7f59613faf5b1d6fc2a9eaf15b0c90fa99a2f367d400d3dd606becb4901361f53e903df22ac01adea08588ffa1bead2e30b2b0131ce9afdcbe8ec976c6fa669f76add3f68e68f72bd84773dbb1756c9bda970e8c7c40da9da910d37a75f1de1d58bbf6f76e6d01a9b2ad1e5e33a0e539d4f82239ef475632a6fa3419e6eb4f10f6c9a7185cfcfb7709cabbb375e18c571b16dc6022878df7e91988abedfa2967e83b8f8b998dc4ab578f60efb80ee2930d3fab5923f094fcb1b0a8c6bd764e2fa382547cda9c5264f39ea833c5e94ed567b406ed4d16014afa73875909a64639aa78fbf62cef837cf06a893605057c5f96a398ced253fd532aaff5e07993765e8fce850a01115db26fa1ab20715a6f1cf2711b9b8a8810fe6b1389eb027bbc210c2f6ae32b7f4e12d348dd5ac90a0c19e2d541062631acf592b558e6d839cc56864d48554143ab6ad784633e41e552fb40392977c060263cd8871c2f1790e92d2bcd223f1b695567c1bb41dd95f08c68e36bc8b884e9ef0231ab2af7949cc834c7b5ddd25c32433fa8baa81d9edab9f4cd0ef0d5d646d5379bf7b1c6944d249af219cda0b5064575759329c2aca3fb80784f3a4e0bc547f1259272eb59e439c26ab5d8e8fc5e7af8f81144f18a570192267d5e71603e1a64ca187823d90b07e3a2b4ccec9f73b9fd7393df376af9d080c9ca9a32bb6a24cb2e91e3b9f2971379da3ee24bbbf9a070bd0dcc3bb40efa5ab37ef7572ca9eaff21f33e934335431ea98e8b883b8ef893025c97af9207660a147fe19d95d2b6e97804d4a6f06dbd7abd6a8a6654de614eb8a3749f1e83e17b7231f33a5a33b8d274626cf1b760d774c7fa7a4f18a1d04089506c917e4dbd9983dfd52b9d9cfd907968b240f2737dd2dca5b354c096b9e44b1646e389d6f9d869c6bf89f5c7e567df33eb72a8679561a8042bac76789f240dfcc67e474a9cd63e2ba2ccb0de8148ca6ad3601af6bbf9498148114f45731cefb40be9523ba6ab90887b1dfb138108a08dde2185033a260dc940c2cdf34e293a551cd1d23d7382c5b06842f9ada329d2fc004976a8019f83a6edbf8238f25baec7e1efbb4d289811aa77efb803417ba59fbaaf76fb9ee225453e3cad6c2802e07b324532f2cefb94aa3929f6cb700eaf23e694d17a51e4c4b7891de204d5b2f914c25e887f8d9946d7677974fc8996891427550823d3030ce95db9613e3210dfedfdc80cfafa4ca1dc9da2f1123c0d53417ed8d2f8e093d9c318b165c5cbac5bf80a367a250e2c8642be1e701f22969a1cbd6ff90e775c45e5aea4b3d859fcccf4a9881a33b23d41312fb51a99f8371a532fc750c3926abf018fe937f212005404d42d63f584905fa817384182580af7447b2360aca486aabeb4ef64541768dff2979907418f9996aeae45a05137e31f64c5d386e9fa21cb4d5bd4896c200040728fa5e7c9bbe57249c9c8605efdf5a635f8122aa46dc035a9564307f9447f5effbfb38521acae2fd94c4654a083587b615df90726b7f9ffb7ec05ea269e86374bb07b12ebf402491ff0b2ea8106597f3855aaae74a1f3b8f48ed035ac03798ab5355b48523b14ab4ac64fa1c29dbc3997424ba12ad7102bc1cd4140e06fec6fd48d5cd98da89cab889203668e2984b1dbc0bbeee36d81a4f95b32b4c5bc4e5bdd2509823ff753798e1f40ae66d27280c15b6dc1a7389b31df14711214e956128feda134376936b5b638a3720c44e25a993398e393f55e624bd5d4cafc225595b8e22e62254aaa1f1590f5b91c8568e6aa916896da6b02e284ba4ffaa0c3d3f051faf448a4598a0e15d511f311576efa50af4b4b9abf359a5d7ba8af64a02521011a3db33b99ea2a25ad30761b2c69bf4f4d5f6b9616e8a5c9b1b99418261c8352b66966b3eeef833eccfc3445ab7c21052b73ec28c4dd3617dff97bdaa74562d8728dbdb615ab1e3468baa2c13c15052bed10a88c4864409b91f80e9d8bdbd0b2552d9ea4d44c667ee8e5b9972594ac3e6d4576cdc519279f41060ffab67bae50751eeaecbdc420ffad7864175967d5ade113519aa332a703bbb6d31fe8038e9df88c933c8554138f94fc50583318772353dcf1c179b51ceb2ba57ccc5379b65583b2ff86b4d976e6f91a4859a52ff5e5c4bb19e07280a4f54c806afaf657a0b26535ddeff5ccc75adb4ef15f2596b3eeec7638365cb7531c61f46d9e1a1c088d5b1726a630d501657c81a53f0bd316a89bed2442d91827148722a7ecd9a0f53b3062e74cfa14204bb681fc4ad020cd03fa62b3787d5450adcca174b9c381e2e7ce693c7aacf051ce37cc507f32a41dd1fc348d428e1ea24a16fa27c091b9897ae68d867de3fee5386cf485a28c3abae0699a60f2c5eb314518e6f36fa6966a2c481ef0a6641a0b9253eb5863b4326ec0a5e5301d7813975af6aa1cf84be57d9e3ac0aed7ea1be6c6705194d522a81c0850b54ee0b82325388d0e5d171ba02191028d8e8628133ae624ccaa5737a9d6a11575935668dff178d44c6f7e0bbfe284f2fcb69fc1648dcc2b7af9ae2c68e470fa734be76edf7cddd76e47cf2131a995f7d1d1a5349948f9d3b5f11a0d62807bbd684ef5ce0211142cc6652e55c87972673431a2cd68d120fdaaf4ce31a671884423aafbf38692622f592e537a724c177d1472cc7e04ece92c4aed31271887119ffc9138753b1a129a333d6a9ba3f09c077dbc0a28fc606f6020d98622f333b8bb04791f7c00f49d1e0bb5415057446c8c02fb9e175a91f058b42fac9fc327c5a656a95784f0a79ccb94e86595e3e5cac7f63967883488dde7c8951671d23ce38c53da79d9c6a3a3b3c34e79116c9b85dc32683a7f8bf696baf86a7f9af682ef127bab761de35bf2a6bc085bbfb0578a73df53c38d41bbe6970eb49701cfc77e00d0bdefca5d5e10685e50b00c6a1c2f407264521385348e887db9f98256d57ee225c3fcce53ed23a19bb8c55710df3a47c215b38fadec4c109cdb66b56de333a931e0ffc9d014d8bc08f159c20a99559da635dd93ca78b626de13bfb7ce1f3cc4d823051eb27547d732ecf20e2c0555e680a02aa3933338b35ddc4c929aafdba4f262ab39a8d87632e1b3852bcd75876e777ada8c66a3848db999461ba58ce8e146dfd9930d0aa287d8dabe59041900c3d88943617347ea56291d375a93d8da58a184a9b66969d63ed7d37dfe852ce2283652eabf4ac63df0d8b49595e0713f6cb866e26403c4e44d0a9b28617faa3cf241fb948e7d33f3c913eb75d61fbb30b098b32a64459011e5e0985833f359a5983691a5f2243b4fa13d0c8a5d1d1b4abf59cd9776fe4e8652152d345e46cbf22184bb0dec57462dd9c32568c77d3fe690e76bc1168c6332d5e620ad7d455da25ad1c4e783ac6951a8106eb6e1baf92d51b88db874118d84cc69da6daf3dcb5b0654cbdb40d5b4fc092f4a459fe490cb31fdd18ffc2aee62180377f7c9242f4c4703f08a43044669e02a7009374dafb3ee533f2203080b8656c2579ae718bed816df70a3a2ddc370b57d82bf848071b95203dfe72d542721fe2f31a070806782db88715255f0846aa6ccfe5ad40aed01413f84b3b071b0334646dccd768200aa57051aaa7edfbf9c54534c0a74838607869e712e434f0b3b0849e00cfe4b6ceeaf03ca85d685087645871a1725950c69c05e6f190893d2c320b3564c46937ce253ed3943616258cf4c0a29f606d93a92a844d1ba91faccc3a052d323080fce28cb1175c12bc65904fbf8b3d47a70080316e189c65849e78f802890f67bc162ab545d872cb260429682ec2244e697eec2d3d09cbb84018ec21d7ffd82a59cbb794cad681ec1b16e9c5b3765d8dd0b2bbcefa12bba6dae3b57c4e9e844fd8be5d8d05c3fefb94a262c97e44574ad3f5d45222619cb138f569b1d81fd2e70c46306693a28b5bb0ad62a0b94384cad9571fa83704813247546a4006a8b4ef3a6ac7a904c1f00fc2d848c794dfda75322b2dfbbbfb836e35c98e1abb08a8b21f0ba2dd39589652a9d37cc79a1300004091f59d71f130b1655c2efcff9ed313e8e164f97dfc1c9a90193405e9ec0b165ac7057217a7bfcb7898703f37d4b891a1b123116c55373fe39aa45f884a890fa2149b80df55f03708b6346fa8d914179ea0acf62c02c443cc6a07d2f77bdab8d0b7b692f43f48eff2555ff4c1fd343e702b909c4f183898f08aeefec024a90ea50b27280df285d8ea883a0ee44d79760897a677d75f0c68108b1df4039eadae0b39e9b3c85bafa0347ee6fd2d32b578caa9493405134c95557f8faf7d84eb44d056137b46dda2a69354f3e7d7b109810454cbe342727ee41020e0fe40dd1cd2a3f2be66c92326a26ec4403c7ad1a18ae2105a12e1e61c7bc8c4323c3c622471a85e043be5da776f0b8d3434889c397b7f4f44296b61876277a8d4836477c0ee600745ae5f59ceee03f8239c4b9658f17b1b696e21b6a3dfde6675859ee0eb2d7b38ac05ee3faf815bf5d2db32eaa3bb4bc8b146cc87a30ca34be8f6caef222fa30ee7244055a825ec62b24ab1dc04048b3720566a7fa84ba677f756ee56585bd90067cfea9c4a4f1b4ba7be349c602dc45490fa79fe7e4e80a68159e664c61144363bb18c0900d6478508203369ea9937a0c04106149e1a66769d6410b21de520027218000683ebfd7170a8cdbfb80902de74fe9f34dfa02898c34559a43ebf9cecda94aa894114e0edc2a4f1751202d42a2867dbd4dae90ba49a3a68a80aa034864f0cdb64e284e27a3c3a75f3d92a7a48bfbdf59a6cea5a17ce0588b851d40b44c069f05bf1bf2528d4963eaa0a31aceeb4a76f43fa3a6f29f8b6b91c90b8e73a19d6f5eb9ef546ea86a489082a403adbcb69100fc3b2e2c62d71a6b5193987498e6d749638c5c8b0abf2847f2942e1ec6be7f300b484300e434bec876ad33f77048b2010222b835eba6fbdb18b01783e3567cd7fc706a547ab8cb421258c5b26090d2d4df4cd1d252d47df32f9ab31741a09e534db6ec80603868215f74540bf206fb713c2058388230b6715b06093385bd86a80aff936030084320c1a6dc59e21ce20d50cbc605f5ea2250252d2e331ed65ed5795b0f38626a2fc147e2702fffb2ed2b9ab4ecffd7add43269d0640286803241bc9db9ad022ea75a831af1d416d5ed628accdd8e4c92a6f4041d3dc6f8dd720aad7aa737de3039d61b5fa462dfd1146f86e789275f1111935a4aa7f09cf72eccc80d32d070a3482a370a86689d704fcf86de8707f4ac5f880d05169b699e16438497662bd3a845138fbe5f6e83a6c03ea99b6dbe8204cd276f1e59ab8b9030a8292ed5042f58044120446ef76e74c9622307b7128cc10aefc8387262b2e95f97e56bc4a1d97fc88afb8fb046899076485e0824bd9168d20ce7ac3f099ad31b841b44db486793fe0df06c293f613464a6dd1df52c09ccc973921193f5ac71156ec4a0080b80249f13ad7cee0eb11ca2d17503572c51eb549d484a555c497f48eed19e341e4b0ae11739a71bed22474db17242c330e1ece0669dc452e9b3849e85e6264c5d47f4217e46d631321077af901d167af4eef10a61a12f6e34093b8b2fb110dac819e5ac3bddeb45c5317058df7d133ceaca56013871b290e95788d38084928d161ac74e93797572a1be143d1d82417522d71aeeadc335162db3235bd0d118184b5a397f4bceec28feedd4ec1bda0f3c4c39cacca0d8463c82844a712e731660d31be01508acce2b79986c0c15c04a896e0984eed724e077fe94f4c7816cdaafb362969e9559e34fb0e6f4250fd59a4551c992fc7d5ffc88fcf31c1fdb229d7c6314cb7a47df932e459e1305d142cc54062d682d0edd1e341de3559b94688d16f264f4929b167f847dfe1d018ce17623f2b2f8ac20f4e2579347171ed3f7090243f4dabff1237d9c802d46d4a4e743b01019c649fa52edfd0558711fdaa17dc544a8f76002304b80ff3675885d06327700505d7ea64f03c0813d0974569740d0e09a94fab50ab5fb5e6a0949d0c14e3fa88e0fb0fbce4c0724dc928672d6db42f1a97849c285eeb8c2ab5e1abb7aeae59d09fb6f8bee41f8fb7e9952e1e197790b5fceee9770b22fc5ce2d2cd0b10e34b282a685a8f5ea425223ff2c5dd494ecd5ff272d8e683a48f18fa4ade588e2d3eacb3ead8d4e8a1e07aac887b27a9033a9f612edd40816c7cd1714e5b28a85860c8fa112fe5885bd1ce76bd145e9debc361003d2fb4f24251c634e13d7affae0e7410f70893fa75ee54bfeea1709750e65e38bf773d2bef242d00b3d5c4db79fabf23f639931a5dbe7e84aff19ac36a71fb81da9d5166529a541519430991620c7fdf261e7f37e742904818bf9848dea90731c38fb1dc3791a719b17fa1b41cd3114662694aa93cac68cd877b3100a0694a78a45d0d1fea421cf031f332b6789cbb94eb8888c6ac419c9c7ce9be1e1e5df401205caee4c81a2426af0e26d0a6a2c11bc4a9b39251dae31954680af953391139c43999e42971e18e1a6921b3a50ba2f555723cad67244fa944b4d4f8f46e6876528e8dc03a408c5a3c133fdd9ee28a19589c43d51e1e0c2f73d8f8ffd6dcdec5b992d3eed82bba75a2246a99e14241ece65305a98437684f419bc32cc48bce603202eb9d85267ce0c2519753a011a68d051c85226494ce6541af11aa28029c744cd5d18a42078885053caf9e6cd5c9f7174f25652ca5540e698608067ce3a2c54516f2c6d94e5e8350bf1263f98c22c00be0dfb0c12ed5874913083a800c6a4850a2ea1265165808d9816a8689b8cc2d138661a24e3836fda1dc76ecf7100a31d51d02622b88c6c0af52af0214565ffa8eb03effbf9b876237cbe00a67542061032003262e39661c4b9de3c9ef744f7bd122ec7e5ecdc55e22de72935facd7b61a860a16a37ffb71630147f146b8ff61d2c8eb54f1003f33c15b83216e073090910b3b42f0a8c62919030fa7b81f0a49a7e2bb3d80e4ceeb4a0f89d73acab6c534255d64a96357d98857d632972ff2e9208074fcb64b862d7f6260f14775e41b0b7a8bb67d79438aac90490769e8a3ba9036a4e3f26667a1fd6ffd019c189df8a31dd8e3f1846f84fd306148c4456a913270cfc0a16f23fa4bd4e717373b30c66828b5bb58c392fb9f3292355d4ede93685091cc3e9d4fd4e7b514c2c552b729b2f84bd5dfa431c242072cbe4c709c55be4e9e39d1e5ec30fcfc712b1e4c27d4edbded8aa6abeb8a737f5aa06262a10b02b2964439363626ea36309a62f85e617f184dc3f9c5ec6a8fbe74e1e6fd64a6b02d3cfbd7d286a1f30ce33436b3c0ffe8355ad322b524779a027eec37f4d135475557118082e38f32453fa730ba0a173aec1bfa4060f5b8504f323e007ab49ab8ea4f86ae4ea437c9be3d9935c893a9f637e8d0693a19cfe54d213d75b598112b0fe55f8cd373ea8ab5835e7787710fdf81d572b8dead0e2a1a2f104c6eebbc0e49df2ded8bb75c5911997e62cf02752d9af6bd335e3ed008bdcd24258ede0d3a417ca59748d23e1b45a176cab24e9eced6ba846d946ab901aa106796ab76391f9677a6d94ace36fe286fdd864c73c546bd4a6c2ccfbaca7ef75388612ebff163446371d1c53b56fe163d39f58cb4e892abd50065041d4c8054c87f3d60a0b68ddfb191d5691594b3ffcf13f02d45b3bea71f5df28bfdc5d5b7e35548dfda0ff2e9e4dc44a01c58de40fba6a7596d57cf76b440aabc5996d8b3c507c62970f9520f3ef59a1f6e03aabe7fc86340dc9214c44e17ba3633f0958635e9def73aad67ec8cf836f2940a35931fe5e85242657169b2922bbd024b9b19a53ff1d0a57ec7aff6ac3e941bb3db921e1dd75c49b4f8c8decd9dd066c91125b5274a9b94f7edab7f2e5647e1d0b3d36250dd57fc677351727d934304524792e07df1813327c5df004c56606854439cddf707598435e40a5ea12e0680ba7507df1f78dfbf6f4bae4f43fa0b758b2163232d534d4d82680e4de856d36d6007545ae27e2346f0d453bda718a135f08fe7d29872babdb4807dcdcbc8444e19114e2712105ebad872fc65b4a8f52bfc12201bd1d504f9dea50f68d457913fe37720784fb61850b506b60103f72098590999eeb290c742e8d78ae80b4be1cc905559ebee521f841ceca99fd4f32f06ed4b73e9483eaed5132b5fc979eb360e64746dfdc1607bf8d1bb81b9243fb226ee1111a52c06418868de281d36749f3ed340df154953f55ca22e7e3c361e15951fd1a8374254843a48aeb86c51468b1691409a89a39af46ae4c3593c46e20dc1781ff2e5c71d260a50d6357e0951e019627477ab71365916136fdbb12ffb2e1b10d6c7c25b16b57ebe76e98a7b55ce3fb77b21ca8f84d07212f79e73d0c1a267019246d5a43999d62fcca8d81cc55048344420db4ac86393ba5a74c2642449278151284c45883d0fc28bc07c7d7ffd890befad47cb63ef89658efdf882ca858f14bec410dfa7bdc6cdbf2d71e4203372ea8af2e03ab4aa4920090ef1497685241df8c32a6a52fb375363b6c38af870d2964ad38240e91d647400d0705f1b98cc55b10ed91c607a4249ede5d54ec5f02b7524025a54d3ce75f1293e622bb7fefc2f5cb32b5594fc14abfbdddf7df968d5c6fcabf393f5ceeb68640daa56383b1408a34a1c1fac33209f74ada8e8e831c7d5aa24dfa6fb6a6b0b7d468c44e315f4b7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
