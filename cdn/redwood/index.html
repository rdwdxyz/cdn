<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"854237b2435eb4f3342a6a0242435f414b031b338e05a15c1953e24caa531638c4452b1ddce82a746d390873c3a4ed15398102fa34185b01c3d6b4c97dd5d1a4410c545c799ae9bd2d850f95fa1ec21e251f3de8cb0d6660d00f073ae5a32dfd07bead4c8908d4ba8cdee09d8bd3dfc752ab83e7e2eb6c90daa9ab398337d3285b64891ddec87ef6f0c3470fa914c40c832cdf3738b9d724e9c28451e76ff02df555cad5a107ac789e6d0a6847d5b68d0263e0186a783efa589eb63a8633fc553c3e7e5829d3302f9b3cc0d633d31f68c5c05953aeaea197cfdb26349fc60aeb2636946bd930c86763a8232a670a6623d4a0558dccf49909537d74edafd1f4472dc851f5652e85f3f1d67ad558db7b34fd0632f90d8916810df56fc20a5bfe6db71c00267a3fdbdd1a37c97ea899bcf966f7c9fdb6e0a3a0f11178b9912cdf2a9cc4d5ccacc60732ecd4e2fa1e2ca6d1bafbf673991e4708dc6123b6290404027caafc91b78e93bb16679a890d437e3573f1c8b4dffe0779d65afed6fa874129083945eb3cf5f04937082597953ab4a63c6dee9161bcd9b0d7c3cc7052fd94e5eabd54b8b5d4523dadbc561529612924405c6fd0ca4424691126fd6607f2d8a1e3d89fce901c106b6677afce4d2758b689f8e217adac390b416a13a752f4c88da8107871ff5714fae4d3b48f8deb725efa1c89a35f719cc1b4f049968d73ffcf19a5067e5233fbdcf3ee247ed9739d459f30f07c26870dc28a55ea55aade946298891cfa03bf6561b8443be8be9e492d42ccca2a828e8b53fc74a378ecdeac7ea428855b0735bbdff30e4fd563395d614f20507bbd86d34d23efb0948be618f2d1f653b1f31b98e9c205de44a5a684e87f2cffcd6e5a222e4c9bde06ed7bfadc2cc58a09e22700f95467a45aa1e9204edaddc856c004dd2c68824552f610635e6038cb81bf0bc6cff3fe632aa82e5438f282e090c5373d8a51043f4bd9939b7ee32d5bec4c1b4dd027bfdb3f3087f76a4b5e7ae191e2e89e998cd536f3524c2244bdcae0d6a7b72c4cb4d4fc6bf7949e9a8b87b915586dc5527ceeb19db30ba08d2925a1b1dbe5698f7fa5e312e8ac0be63f0359eac53b6718e59bf009d3596abeb43fc7ec0164ac01c4810c5c009cb8635737071b7c4a6e0990f6ea35a26ab41408ed321bb42a9c7206068cdca733647991e180019fb1eec644ba1075eb0817d98602064536879df38d415e7a52184f67c261e7dd89989a067e6d5a5c4e09a8b5fd6c2726247ea6ff9fcb0a7a52b147b6e43b3658a09e4af1f49af313bd7f0f9193f2fca478f9b17ea86f951dade2041ada0f647aa2dad5f2f8969d9d485a72e2833dbd7083305c0e074e31dc4729df221245f0417ab564fe2d69298b3123b93f7e1b539519360d5ab6ae071f80b9e88d253efe2d46333bf61c85113fcbb274048e253b74f2fe943d9965e4827b9807a2c20bea1f75e0da2932232b3f931b34f0fef58e1869b39e94b4d3eca86cf0fb020f25d0ca4f6adaa4111a592a3e8b7f29072fe40da6909be4f6e435a6de595c4001b57626d4d93326be9c90f5b1c8e8ddcaf9fca243903782c260809197d8640d8e9d604195afa4db173696d30cbcf3572e9f523185d79825c4755253e597b8d7abd475c2166bcda2b13759e33fbb04369652f942b1178e6d58f01ba7c6a730b62ec5883bd66503bfb2b51b35f9f9eccf23e1bfbbb509178d3569f3dc8ce0b8f074ff5ce0f9efaca290d0f89e732af85dcaaac218d39c654e275c3ac8b0f2d3d6030ac8c3e926b485921ee2c084850fd9d1a2712f9e5110d5cbd34e067a9b5507f38cc112c6d38de2f5f90d97462a1a34150a7dc1152a2e1b1bd05572c4e512424b4aff4dd18f2d5ff710cefdf397350df07a0dc1f90ddc030291e0db6e75fe29b78a50e12fc9206fe27294d726b53433e6e5fd6f828f94278a663cd9b79e4774eabaebe44c46faf175096b196a129b09ad90f8b0dbc6decfd4c58d9ed20315fca494e1467614797f1525b0da5571a26511f042a9b2c0a3582c8e4e475a06aaed5665cbc90b9d89ce3ef925395f7ab769ef1af0a02939b49e340b0e63ecbfefc061dca1a1d4e0e965b34377bf8b029ea7696cc9bcf6294a0de9bbdb7e094d561d421f25f18e8051eaf4288f109fc3ddcfb3098342f86aa73bd7f9f6d5f9f7f3c649f96fef237cb5c70009ce066a3538ae5cc470fe70cbb1ba99452b4102e7ce5ebdc3ece333df7965f6dd0cee8d0dfe15e8cf9c955b2f49606d539f9812c919b59e106563ecf2b6ccbf23c848aab96fa187d4187d4369829c915f547d1e98c2633460d213dee2dfe23a574066e3d31fb02772335fb0c3f4a422e40acfca87df342d342f84fef6865a071456ba513aebe797c7512e08bb45e65a81006c136ac331cf27a3c3463218a88add043076ef49512ca0323489c56ef83518b4088ff577e3ff44a6575d1ce3786e5424be4ca4ebcc54adb2664f73f1cd0a857de45f2ce014531d20a0dd23ff898728af18925ea86b2aa79f7ef9e95bb8de0ae4f9b5e9d6ab2ace42bf67e0f209decc9ecc8044c1f4de18bc576a90b366b36f252c085baf687c83d5ebb25f86db0a306bcc8373e664a819813de0ed929243bd4a09442bca95ea2ba255235d409e721182a91b8ec5d847f2818844c073f7c49f67adad5faac46e123692554ae34f59e23b5a128a033e7d74f583fc63dd9d8a7bd88bafcd8f59b4aac559b177ae5d385641a3fe5b3bc0fb341380bbb936346d3a61aa9dab056fdac44de882060bac08a8499d4cd14c5da4a6ba1124b310a77b5d58aa47d25c405de26d4bdf242c8b9b0a23a464ae0960ac02f6ed3f5383236f3263807cd195ea7222ede763c94daa5bac4f4b4798052ad66473c430244dcd11c1c798bfb0c1a268ddfb6e9f381035980072dcaab55afb6a9a10a7dde5de739ec49c6755709f2081df5b9903c5357b9c2629cf1171d1d0b864af3648cabddd05facf99ca7a364daa08b812bf0b7f35b2fb2956bc97ab0ce15f13bfcf8b345062cfc08009e5bd5929b79bcf2f6710ff74c9ae5da298a30e204821d1f98d044212498db49a00d8c10d98824b8d3b6c712d58f78568e8014ca0809d3a8e030769a8589f7dcca2f378b2ef6f82cd0d78c5659c97b945ea5034f7efccfd1c7f31e5c9a9c125b2475410b93aadfb3c016af13f7796a910409e19a11aaf028bb2a8d9ab6726da77b29adf47752a466a37badd0fcf7146734b1cc5215b53155d414d0a3edd4e0eb34407518617538d719c71fe7b40a19320254641d2b907536499563861a333867ccc36d6c5fcfa1107cb233492c9ad0ecb2c37440e8a52994d5fd863ed3228119d2a1b4002aad37b4fa00dabc0d3f6715e5c00b075ec1382c63a82ce6738351183b8e7a24dd41c6bff08d8ae10bb8f34b96ab931616cddb501aa1a799314a7f59cbe16f0dea22dac1b7d479258cdbc3739f33735c64a9ba531be5a7f7bfeab277d0875e3d23016e16388e2add00600586d38089185df19b2af6334e5bf6f93ee9c164efb20acb26c0afdf23c1481657863245c445dde5f8caf34ae9a995ffd3be37538dca81b09ecd7e23d72ba9d21b1e60045c7105a42adf78b8abe4999c8e2931d73248701f57f99bb097f2e63d5a6521571fdc172a442168c7c2b9ce38f487c0d92f3cdddbaa33e5b65aa5ff3e5246bfef28a0eed70a4970f5bf45ec3b40a58dd4969a9ce33fa3799ed6761bdda34b0e866df4715bdabca2494b8a2f39ea88fd119d32a8727d77bcc36ad6b98ef29bf30c67a9050ef68b712c7969feddac8c902be01e0bcc45977c1398b7a20761ea1b8a2a50e3f9948970b605be0d4ef1f174910c5c00d39c31dbcca830c1911fa86c161834291d4334b531597d206e2daee8b8625a8850a75ecb72010278d22646821fd2dd69badb0e12bc358b71c4797d9f3f3dc7eb69f595338857103e32b08e5bce4b82766bcf3c533ffc27622f2c162f7c98baa1cdb37a70f9442a1f6be1a4c6be30090c64c2c330532783d0a497fc9f4c0c8c9be82b953ef6a974f33f8f781be8c4872ec9fd50340fa46352474443f021e39bc74c10a548f7f3fa0b94131ad2bb5cdbce74902a60e7b9aaf35ac71ce0036bebc3b46f3e0bb101da377ace5afdd1543295b8f04b2401002f6e6f4e2848751e30ac8212f54e65ec7253423f4f71973e2d3ff2184fb1bf17c57dab6796dd9d6e2a7399324b5a78d3ecd52e61e707f5bc64b3e95bba9eb867bc07603fd55a00f131a57ad832fed92e2a40da4dadad1e5b6127fa214cfc157aca22d18452ba24a190f3765cbdc14178ce0286c69987b73153603738000f3ebc1d54dadc9bdd47169dc8be72f6dac9dc70aa3b8b0419bd3adc517bcd6ed9113a60be835f7698772441d16d33fd8dcee8ef98a08563469604137fe4274906250fab86097de1d76afb2d1efce9025e87a6ebe3278755f3ff5219188701026869e24ff128e5f401d6fbd598f971cf8f30167e82a79f54985eb2ef98033808601ede4b3a8b5ea540b6bd2cc708b68069447820e8a98e5479807c639fafb12883454ea302a8d755155e847529934ab4cef3d9346b8639553a1652220277ea4aa4811241842d31ffc27a802d4e80172ef086e4cd6ab31c58ec0576181f4768771398de7ed76a6a3b35aa71fe3396f6983fa7ab2d758ccae4bcc1aac8adb840596feed8cb8460e169ecd606295e379da6aa532e10bb5378da866b000944a77d7662b8d36cd060a894aacbd0dc600509c97793d7424bb5d6d7d456ab7927058dfabf0a2c83dc685d02d42fb2a3ec25bc2ba565307fb80b559757f1a068be0663c0740d2b7c8c8895f03f3f9ef845149361f545534138ad4d7428f11370343aa44c9b686a458b1910b11cafefcfefe9f4a982047e53bafe59befe907e842371dfd2be1867a832ff33edec421a69a2d1c0ccdb86baab4b3cb931301831a7deec5a1366c9953afb454fc16b9999c71bebab44ffae3579da5928ba685a9b861c3b7d6429a51780a4c3b32442b19ed4257bf69509484d538f415e79cb6f96132210ee4723acaaee76d049b6a19cda0ab9a63b6ff72c0241fddac965029a47e580f4c9cdd7dc7ed3b420bb94d18b06b9dbdf91fe405c63cec73ce2553992aa14271f56c3e1c47e0fc17e3604a72205cf0c3beaf25c0fdbfe9b1a27b9ca7455adaddaf4a94b1e5c06376e611fe2485c65017fae75a634d61944e444bd0ab73b46e001b47dbb2839f5713cdd606273316cfb5bd3e067812a2ddc02ea4800b1e132f962d62c4b49f5491d2d6d43f3a0b1363673e4bb6ddfb51a72388c01b93728b7a1a7d6ed382d8cc16611e05eb6afc51b14cc03a93a2cd9d4a60322c024dc01414ab7ef29c58e22ba0e303b12eb31bb79065811cf1fbf25e957fb53db0181c44a69c29f686f610f38fbe2c6163327fa6a7fdb2813700a816c1f9ffe9a48577920f2e72615e1da4d2a4c48d2ca1b1d4382b65ced9f1fae43396461fff32a66623059dc6c5e07b677c4c7090f26732ea3acbd85125b106dcba924dc0033a596540780be9b58e407e7aae982948cdfa86a46d516766d05701225ac51a0feae47b0d1025d82ddae468d2c4a8c55cc961853acbbe9a5fea39ca7add4d56e5806f708a9c4cce6f72024e64ae4a55e52377e38ade487003e383bd0e76347609939ea1a982900ba205f58007e1dce0a3b35ea730b36010bdcb58c6ebd968120d0c539933afd09cecd6d67c304ab489e5ff561ddace558117fd265ea820e4d3fc2bce7cf4fc4e555bdf1cfac212acd41dd3bed34f080ed71adacf898f137156423a51b65dc21c9d04301d19c4f2320cf8fbaeb10772ac838618e2c4c8ed0994751faa7fef74fd7b93c14f5e1d47c8364da70234a3ede50feef2026fa5b46da3309bffafc9b3a8471cdf701f93ff69f1df4571b914fc86390e2502cc422a76d2fbc8504dc9e6dc06d306b953c6fd9f1f9a3ce100429a9f809f920cf0c42f9b91ec87cbcb58c943e089f8b7a74973a4a6a12d37eb6f9e9261c644f9668d56c6989f3ff331602a9482139a3e99deebe85f6d583f6175e4dabc096dab5e29bba67d9709a7f58504aa8ffdf8bbac9a9a29d70d2f64131638669b41ec5c577a6c20da19ac4db7d31f128c2d37105ce8420c8d29732c31b6d640a74d1ccaba5f07c9dab6dec076382d6c9063b835dc11a74b1275b33f6a84c542b8a914ef9e06ae10364a8bbc8d67f9c2f7692195dbe3519cbbf1bb0f3f4e3ac781eb198c49b784a10105349e0372545a017e6053736f3a31132ee89c78cf71cba5a7c4d75cd84ba034cb60bac6540069b9745ee8c28af3bb25f116d69c659e8acc3d296afbd7d330449319727f622730fed7cd7a4860e89e8d9987fb87538c70608520a97b7e5db1a548ba0ca1705d02948808fcd17e4e5d929c73a0d2844d16959c52b08c516301be6a85c85a791f9236c83f0a5d85ef749f7db98c53d40f9eac3e5a4ec4a51101e437a6ff68bbd96c4141d21c45b1643ea5b9859da29f0de5e0016816b2c99c4fa386002a5ab5a34baad84cd7b4b74673b0c95a900a4fb9317dbbce2286bbb1e620d028b327d13ecfdb350dd7253fa1b6701388b9c7ad8e3d3869bd4630efa19d5bfe56d8429ee19740d6cb00eacf756808b1f233008721f156725f571f0b1bd60009959726ede3228b1c1a976977fd99f67a1a41ea3f5de87a21527b8dfd28df6f114766ae878564715f9424130b884c95c76db896d672a61c9f173f49031273f582cbddf8f2bb16d0e04088ab663df204753986c7289a38f517e7e1df2b7763f10b33372ecb4c147166fd4656022c8276fb9de99190d5d445abca7df30309f223a1aa9b98d9dbc34c861f861ff75ae45b1e882ea79b6663b9a2625999b232002e223b6289137c62461cef8e29b743373193693f867a3384d34aaed59d14422d6db56d0243f3fa01987ccf48f94e8d0e09742cbc579ddefbeb26a679e88fb7ac8c02b86c2918b02283776f143799a1006c2b63a45904f58c62a87529083ddb818bb0f0a91acca7b0e2f1a11f5fc43cdd9719676a426bd64b1a70a1d1df355ef5ac385ae368045281ec9fdc8236a07f60417ae602b8bb76b27fc8389351365a392a1db2369232269568c339e2d0742313a59a07fece0f86f50a159c698b9f2f51322dcd4e52014b436d973c914ed5dbeef46b055e727ca63a71a1a569574b890445ef4370eed3a4c1890931f526ca2d1c096fbb48a40d42be0043e5e261e08269252c0788d8fc1771ff4664019a2b4f4785df02585ff2ac06bf08cf1f9a5256b27fb00366015e0e6aa611cad1491f77b82d712c5ce6cc551a82124fd0135a8d28d7c9ac31af2b4ca7cedfbc0d15263c9fe7e04fae6fb8b01034dbb37022f535aab43a4bab24bcbab8ea44086c35ef6988ab0d349a704b3144c205694e082878f3399e8fc31c66e8959363f4177373d56a225bd0e9fbc6a7be289133643383a7576d9f508a49d213489e5e42feee3cb2113607ba6972e89b23f94a63bf0bae8cfd5b0756d936efd98070f73fbb8becae20c07aa45bf397ed4f919828bcae04c36254329260b56b94229d61db1611a981acedc946114660a507762004da0292f12e2afc93acf073d2ac4eb6029843ebc19d1d9f628a1266cd19b2b90ca2dc66897b8477469102bf1ee99aee4284514136b967e2b584df396017f8f5a4de36c37b11ffc2b9d7d7931ffab9ee8723e0edb6d0149e862788cbf900ce2ca9cdb03e21ab365315d57c4787c059017c8aee3bf9a023e7151c2be0fd93623c9582049a32432e2e603881c619aeb78643789145a3b8d332402fec59dff19f54f97638409144e2a8fe363f09823948441d359786f38bfcf987770d5f0155db079aa23e50998fe3296acd79851ff40a3ea23102042f4b6ae2f81d734973f55ecdabe9484379eb20831942414eabed4577a98d073c21af846a14e5cccd864269bfe04d659723640d0eca1da6c355fa483f997ecfca29aa70c715eaaa9b2813cf3184ca8b524b46a2467cd082c7372eddea03daa85949dd7da19d6421d5d0f998b5a58107a7d618ba7ef2f07a4007b381775c22cd102ce71d76e721b4df3f437b69bd71b1d1218e6cde745ac63b3f7f58560746fecbc5ae8d32d47f0f642c1f4a99f2c9c6e99cff5650457b9f1b291c58b266466c88f82b42140ff582bdcb64d3608fa8f7caff78f3f9eeedf9da3b4138f23da089c6c5076fc625461d18598b6b1c2fe4edf3e6b577013c0b270b507d5bd7e8dfc440e0e6d72d420ca1e151ee9a82883886c942bec4d7a93bc4d709c93dc6db5524c7adaf91fca7b5d6e30700d1d587d454ddb4d36dd291fab1145ffd96e66e35149320e36c470ebad7caf643d0e0a457135e788fa88b8d127e35cb2940234f8d2a7ef7640e4dff927d0cae2097ba91cb03c5c0fb19871af05e20ebb79f7a06c5908da4ce7366c2f37a734accda6485ef059b56084a7dd5794c40e4c53a8b6bab4c6920f1fb1f43129735cc02132bf2d97670525bef065094960c6c31f5bbc72b69feee12b68169dcff95dd00eb5903e7faf95f112890ffc9fc1df793e029e89e425727736539df078cd70e4ced02b83ced390bc82f9706d0a8383e3295d128c0dd9236a93461514a827e88eef51933eb2c5badbb542a492b301b45c11e939fbd9796c92fcad1ea2d5d874f2cb00f213b324ce4c7d32f74f5707bdccc30d182632f7d6308fb51a4320bf2f55c1c6d1878f36aba04c4c6c1bdba3bf797c269458a6ea4bccef74f7b1c1e7ef5f3e6217b5bc94fe2b388345af15ecd0af2d861efc30b9768754c289076b22876f6226e2d0d20b81d646c0f18a827de1f8857c18ba3c5ff5e03470aa5858a7ae7308fa3320ae56a66c2f6fb732c919c6f1e780bb5b6491ef7d134031bdb4ddb106412deef47fafc6a29279bc3255d0d1bb77d36c348590e68de3d5bd504dcffa2b64ff19b3db63a08aae705e6993a6d6a1ae4522716c477fb4b9eba390cd612a08ba5b5d4c1339dbaf0ba1efb2488ce853cb6c15b46a4568510e595a87ca81dce21e1e356f9f7634a8402415c72acef8fd46ba1360ff455d332f71ca2bf619b7891118ec296a93f0d420473edebc6b6d203f35819607baf44a45e573b4f452b45c6807165bd89fd926b714de1b0e1b0a23a48862bffabc4fb4fc8e928ed12e9c46d7ae5866dc41c472491ecabbed8d4fbc72d1b01ffc4259652fe05ee06221057269a9d308b807e12d9116511de0b345eba52425edfbea0c7aa76e78cd0e8ea0ef0590e34c19ba9552808eef00a517a2da225c2104a3945591fa8923ff57ec63bf27f0d9fa85360240d5da912093b44f4a6824d9da2858b030275dbab285b43dfc2a6a544072f0d041acb01d4e79ad37fe5f6810b8d548c733c8f1e9c40a046ab412e374a28eb1705cec85a2a19802d606b4e251301ede0d6bd76d576cb634fa84873f983a0e1978aa797c5a12c604af9543e77c9d4af36f579f7601cc7daf983ef28db0d40f01c54eb820339fa352fb82710dd98149ba6ef8c5643801883a18759f527670f87f51c1cbf1480a1f72a20c07f369353d24c91b259d6a110a7f4c08b3914b92f093c435d23446c860899cdb606588aa818cebb058ae81b8f3f48cdd47d01841ec71e1111cd4315cdbb34d6699cb590ebde5e8ae079275db649e5a2895f51b7e2c8fbf68e9cf6479f0c0bd170f905e20f5faaeb0e407ef4fcbd1794f083f692a8a5d068ca4e8ebc606f6c4d0b5fd203b65beceae01d611c1ca9a9e4f91a6ad08b068a30b14a2d3617fa51400a007d20a67370f2c196ae792035bf7b7323b03de30bb55c054078ff22c010237f65b053e2aef7714ab6d323da11ed279cdd99c3e6d82d6332a9b2de736ffafc5db46ef3898c8e25ec747253d895c4ee9cf9bdffaf1818e6eb832fd64b49661f1e51fba9859daeb71d2ed8b6c0c37216f070b8a6397f722756f39cc3faae157d137cd68bfd2d2c7b7d1c44dff0895ac0d07c3d6b34d513fdd234c8d5542c5effe6c398b2bcae3b1833643b9f3c121d19837965ad6171f853e62ea47d4e369c51e44522269fe9f3aaff98ac6ca5556dc248aa930f0e790bc2a9228abf09e24e42c3e148afcbe7d2735044804731bcb0ae84cbc371ce2dadd0f2903d79c21e91e8d3cec3a043a1151ee0b4e446042510099eeb286c037a26edd353d7ad0ad3004ac5dfffbddd0ae12e373dfa1f8fa18577541d25c7befbb64d4468c8fef99f5bc56b37e0ca4eed3db4500a2b12153453e23c212b7ef20b580ffe753d0a2966dcac1eff49feac06cd5720ab1f476ef17b7d877572ac0712aa6ea8b835dddfe84365b3ee74a9ce159abc4171936cc92e734e3b1efa756cd2c08b00853e0eb800dc03246c68801be47acc58e720817d268f87433e33da9167dd712e0d71e422f8ef1d502a9b25907350be10ca1d9274c4bb732fea561a9fc07815ffd2a255099a2c180dccbac669c83ce044cf0e8a6f09551397d8e6910c75cf6f6a246cdc800d08a3353222e8664240c0ec53cbe310fe28a1f49b2b42e2178ee13529a0fe62d22ae96e408135ebaab2f1ca5ccb1f0acd015d57b93be69c3471ecd963c2cd436a5e9fe5fc3baa92f017d7779628d4cc5cc8119e424d114f6515debebd480e95520cf88495b2371f53d57f68de7535932916aaa628663adabd781cc9e55537fe4cfc40de3736c081469fa51ce8e348f560038785fecaca93ffa5e3ba66e6d7f4bf13d4142e66c2a9642862f1ec4a72fa8027d904ac38bc4e7c62fd083efdb2cc2b40d41451cd56c8c438bd1d5493ad09caed526747ae4e6faac80eea433d9310563660422a9f87673ac5365c87cf219f61d38d6e9e660de6db955db5528507fd3d6709128f7bd479de96bcaed048cc4f2263b5c82b1f91b0a5eb7c503c3476bdfe544578529139244402de93211aedf0e262da887ccb4631a332938d84cdbc44b736fb557b9aeeb5d021af3cb9b4b780c9c67d16073c5ac62b52e4eb6347c08b6648a59875743fbbe4c89b2397798f722c76b0ee5b981089b72fc97dd3ab127e3547f09a8ceb4df66dcf535e38c6f0772a05bb44a0f246ba58ac82132c1f05186370c4e811de0c26b43bc26b955ae8acc52f86d0706f4227ad73110d533ca2c473b5a845195d3a1a613e6719149192d01b388f4442b478ed2b2be98bb5b6dca86942f9ca4ed4f06f55271738f7d6035b8e1d9626fdcd8d4b7eb4b2f9c40858ba0d41c031f33e11f599bd3ba5a308d5f07d96c71f4cc1add62434dde54a106b5936fbff83d83a5e7ccb9a3b4114c3538dd8eabe1be5aca92c919361c052c055b5e144432fe10cf614bc709efbfbf7c9b10331ae72b7c09605b608c8208798b4003477fa38f7b0048a8467d5bdae5d069f383c985baff4e12fd8f993688e743df61c4fd8739e0508f87abf083b892212a85aec82104adf8b4b9cbf9214cb676175846e78c17631919e7037817921c97d154f70dcd65cc54af0b33ce3a8ec14ffe99c583d943616f86ca7cbae755c175dbff950d667d23fd1eb7487ff4293c4d7547b2a5b5c49be85690837495628a748f9573dd3939292eefe8342c3a5effc70433caa517a93330cbc1aa26e023e1d46775bdaf3f4167355c71904e371fe359f60bc56cd70d75576fa07057790e2c9eeccee110583c76f1d08f3a63dce0292a608857f5eabe1878c7a7bdb33edbcf90d8ce2a68b7641a7896a855ba4da804dfc68630c8cd0ed0d9379c937d54c4f7ae8ae52815d3e7fe4ff28fe36aed4138fc703e593781626b5e115d995fb46696f694b8dc5a29f228edc6ddb8993b34201ce999ba030a15d2a03701d8bacf2f1213c8377b993e139c7f89f1c96d28c932e54420f2c15075c1f3e6bc4906d676ecff6af90f1e2ebb022fca565c40c70ef8c4c07fea33c9278bcafdeb39f42df805b9f924cc501705fe3ddc254ccb28d8e5e87d7db4903b5732c3386c76ef9b21154b216581001bb9c650b08ad2374c6017453d903539e498b6cd930ff5f336374bdd902cf22211cfc9004e7eec7dcd36b0f4e37669d05c28582478987118ac95a871e6a59711708f6f56e15be16e516128b75d5057d2a97c9713fa79ddda7684dd91736936d8531f1359e99386d821bbe79854ff91a06059dc3d7c42258d0615f62eb0b41e4c232ee77bb6169bdccb0aa005bcd689ed8275ac859d0cad2f83245436fd04cc4da5861ef60a36c2bb22526c9bf67ac4a66e4a990f52351065434e44e8369bb31644da3d9bfa2328d4f05a0c183926b453863e9138c3274f9b5915c1304b8098415fedf19f2b522224ec2613d704a95e0a00a32c44a922ff843bd6c985b3512340110b8ae5999556a76976650743efac26aa758a0aa05488bd69cd4b084f0ddb227e1f2ebc1d2fff6fdb1d73fee64dade2034a1d6ac8412cdaa4a001dcb5e92c844df228a0e27e11b240051ec2302e60e0fc8e00ca7e1933c103c85a593c4bd1008457db6b4cbc91feccdf0779b4d48058f3c0e318381a78a2b5ce9a3e8b41231cf262b8ff3deddf16cf6360b8e82e05687f5817afd0fd83d2c2dc2071289cea4165b774af5cbd63d6bb3aff26875f9e08bf5b170826e8f456cf949fc753e2091f1d76adf9a288556840a8f43374b0ecab63d4745d1928b739b042f0cdc95e4d4ea6a40b7787ef890621bd1f73d24c611d9bc9fc7416744b45784e08885111a8dcc6b2bdde7e1451d3faebc1e8bdc4a9e77d23355b7eeee8a6c340694424218ee150d5f8133fc756ce199ab04f48c24f94c2619556fa6e4db732d360a3c6afd1146d11c07be9d5b44c164101e1703605c5deddf30f3ed3c03d31e99aede12758f29cc8df17723f547d9a7a162aa824c21df1f614b212d69ca8dd4c3a0f045a21f100e554e507e29c6c9956768022dec54bcd5d791413f73c980f9d929a8fda43daafffaac73cfa54ea4307644b53f15b294472321d7623958ab4bbaae8ede6a5173e92b66307126e09f130ad5973af65ed2037fc22f99c963fd09b9424030972e6715bbb5a72d0d51ea4a65990d24e1ef465d584382e4d4dc0e560e6f6ffd2fe14d718ce37a71ddd3c220e83e13a2dd5764614942f15bf06a82e648847019e2bae28289e93dda466a9952d33e19baa996d78d65fcf0d511cc954415fa1db1fc30142a02399e5e9a03b07a8505aa55d0dec007cd70051c1539efbdfee1e55149672886921f1b0dda6a7d6d63f689b457e4aeef330cb80e436ecb9814352454479af7c2027cbbc71f163deb45eca379a6ae951609e710b10d885bea12681dd5f122f3f26c9d5cf3dd5788445b13c02bdc1f8f9522e4fddb5615b9806ca52c5a9dc8e6e5f0b719a561b23ef73a2e4d1f4fcac2dc9b6f655c501496858aa0db3bba00d3c5bf5a4d0b3fa8d8ddfb1a989a5ef7a0466277a2980066f1ac496c14aeadeadf14839ef8ea5326a120fa736f17d5cd0301c9af5e3f1bbff158b11bb8c1ba30397219a14efd4128fc0c3560b929297570c96207205d3e4adbfd0481a32253a72198dd96e7740c996241e3cecb93473628aca986df2c05fe73d04e6bba4563fd26a85ff94b21146baa948922624950b19dead1ca0b79a261603241cf06d8b73aa745f45d0d8af824e9a309ff43dae33278ab68c03d609316429b1ac3f03f4b7c94f87bce492e94dde3dd7c10eb272c079babae7e8905e33050aae75b1f19a1f324f46399dfa18ddd8324bd946dc3c9be5f88e41c94140daba0305a339dc8aef738e8f394348a632b77027a557523effa344d1409768f9f0882eac4187a8e0d8aed0c18ca6c24317fdb9800854ac4b154b03d67b330acf1c86ae68d911e2524561437de6aa1a2859f31732aa3eac245cede1c664c07bda2049ddedc9d85d461bf20b0b1fa6e83e5c5342d338770b3b17822038a54fad1ba4968a38db1d2f8253ffcab3500db3c38af323e2fb8b43e18d79df93c19e05fe4f4b98f672e899c8fd825198d535ba22830e457fc52ce4ad2804ccaf1dc39f25a9ca4aa72a0e1ec67ba99f17e3e07a163e044c7c6d0c903055f257b46bca26239df9fe168b0b24bfdbd1f08127574b995dc40db8d8226e359aeaa099cb80503888a4d25277095bebd7593bd95293c56d390a3d5b30f27e9ab0f7d4e06f4ac4e161cdbf3221fe022799d206e48fc2e7d31da29e5506fb4ca126f630f1cf6b1d3a158706285101fafda5038c0f8d1ca67f2df529fc95dd8e8f7adcb9ce5387ef3518d091f3fee1d9891554538fc501cef82d004931d4ba78b1d3e038c9a4d6c4e9bb4fe767b72633971a5f7fe9d13c40a9d288d240ee4fae34797e037e1b1de08dc0d2611caf8ac59ccc34d67ca13fc93b164415da9e8134ebfa627105aea1286a1a599c3dcda8258e551dfe242b82dcdfd3c53d6c6c64dad49cd68de26e31cb58f2b6e6ad9b802d03ca00f7afef55aff14830d16d9ea0e91d6f52fb339c3ad6c308aca20ac3ac4b8c496fbd46fdd284a763ecf469e5782114efe86bf230e54ec8858cb47a5a7d88f199290a228bde87219f6a0d1cb6b737c72a60d681349557c26aceae481ecbec3ae8201c354de9cce43b127a37b1cf8276357f82dd972026afe880d1c8e49c555902c62c1050c923bd2697883b870a1ba89a9d14e87d0302e82b171676983fae32195fc7db1101aef71da5565d839b0a07b7c3d268f51baa5bf0c8d6127b7ee16852832f5b8cf144e9041b48bb21edd8a224ad4303cccb13ae7cfe48b5a5ebebfb232af0c34842449de6c0a67dd570cf1d287114b094e6050769c1eaa620aadba5158a776c81c022e2f75ae08fb1a2d10623fec864f3fd7123d4ed3867915bb5ad99408097613890f530d97b554f68521e920d67ab131240edc44f376c5e0aff6215ab7ce3c4d257e0ccd547ab8c02f3306a74ffcf935e385cd1acd43b43de11408c4f06a4e6a733b0fe019f019547f7c3dc4edf2765d15a1ec471c35105f4a388102360481bd660429a12aa587078523b5a23d0ace3639eace186262bcc7e5d47ae95e0da7607d6c6748ff5e28b064e29ea35328acfad113d65edfee294371a56df19876219c7a47699a3ec5cdc867843b7035b4866c58a475f7546fd5e5c749239959f1848ee75ce9cdb1a8e53c50a325ce21f8a14fec33b1452cba6d3e33bdf85941d10126aac842d4cdaf9f7014db09284c6fdc12534e5078ca1d76c87e00381b23e72694022cacf03db4f8540c650791dc4be588be42aa1cd2ce8ac181d5b785e5bd32844b63b0cab19e0a900dde31aaa46e5427f6b2614b94cbe96e99f503affa4bda31759e293fe52d45eb148aacfc7625049339a026f3402f129ec666455f35a47a7b41909d57568290539ff34fc7d3260256f40a96b947402404a8ac5a2eddf054b1785ca9f80e63d6b926a5a21ac6743fa2660a11eedacd6756dde64e0934739bba9699b7a5803579ed248e6d8b07bea9803f6b386c5d89dea3cc7627308807bbc364a401849053de5943aa0f95a45ee57aebc2788a9a5d393b72886b111dc362b91ece30eca6ca52f7015743e8d8ed9d14a86ca97c96a0f81b50208d12da1ce4ed710dda919db582d2b9b018eb9cabdec71ee572b3989a39e4f9978351cc4efbb554efc5669554bdfc39711beb67a5e2195b0fc64510f4c46087cd6cb949946d8aa185c2c1c15fe678428203d2d797f1e020bddb14c96e4e5a1bcceacad7b5e9605fe7d3d19c6ed493e526d45f8353453f96058fe99c9e8697acb3c6a93fd269ed0450caa8b049007d55a2a3efa91438e0288ad80dcd901888b440d7a590cc9fc4c5690c6a3079e6337e14ef8c9cb5a2bc91a660d8ed3b863528e37c641d8a9b6aa99d737368f25b3f4e22956a03714d87d2ac13079383cef5ee9fe0d81f7d3ea16ff2f5cdcd81050b3ee334b644cfd0202f9a9c6ab23be95ecb7310ed64dc32805e700b14e5899e01673b10b11f5033af4240431899bdfa064f50ed1ece96490524f481923c04f40e7744abebcb224b0b49cdb86a2c2ff9b5b5de7165dbcb8a83b031c73f9a7e798dc1689cb580f8106d2c7e2ae9e54034d309fb56c6b262cac7790c4e20294815998e011e9d7cb653c6d87dc11f2c5b5c23125aef133f32c997897ee1f409014785561170be8bc1aade6d843f3e7496657d20180d5ae2b8c30f8519f04d0dbeed19888c72b88ecd01d18cf8b80504b0cdd07a1d4b28bc6c5ce1a7edc0f104967ca562630ce4f2162d8120e4d69b57c07f836785d8b3afbd4975ec93abacd1065048e52da45771ec9133a1fb2d3a571b4165cab286f6641fe91efc2c029e222b0b5cd8ecf7991ae73a328a6b1242b73ce0ebe89ff306d25c6211d3f3d4bd1662bc81cb1b86ed2b578342ce92665fbd4e7e0f433fb2cf77e0abcdccac5cbf2645f57fa3e6810eb5994d199cbf377051669be0f83884e6c173838979bdad0ec21f81ed38c330164b7e90a7dea82284c18b53f88fb4c727e9c90699d6a1cc58e8c4231f70ffef26e3fbe589fb74d5ade8240a1c8e8f2db0a38d38b8c486d4c92f05e8ccaf925c94a6cdce0142e6b4cbec9f16a22163a0e4f1e2251ffe1b2fd6892e1df11ddff408576414c3056481d9f8722294dda6a9a86ea55ebf62c9c3de9a662070c6f6ba7d0af570eaa6c7436209dfa76a4ea53d2607441a8b651a118146a9f3ee8cbd83c2529066df11c50b1f88bea3c4314f1942ab982c7ff9d4e5ebeaf1ef6f9f83e1617c30ffae4b8d000305254d55559620f2da7fdb27dcea90b6a3f31836317bd319b01d7e6797757a48fedd1794ced8ec8efc8e1e725518745bb6a7737a12ba056314ad106e2bcff835aaea289b9a36d01ebb59b328d852e22921a57e651bdb3b9d4f5957f56bca903f9a5cfbfbd4d6cd98aeb1b1df3810250d347e727a663530e354cecf5da0615a3245b2a624223fdd7ef03d9f13133ba9b2ce1ce529e644780a46eb052f54275a700a0804f4300ea13f5733fd0a824f38cb819ac6404fadb463b1268c9fb764ef0278b120e6dcc6286e50dc0951378e2e0abb75db5dfda68900df1c7d85c16c10b20dc4c9f4d3d5e674dd0cd0645ee5fa1f2a9255a1615c7b36766b30974dddb9e46b3bbf563fbed64c967a2f86f3c93db0817d7c536689b79b5bc3f96da3c4c648e2916fda8b28b24c1dd73a3e5f2faa22bec29f8cc98a58c000f545dfedd00122c1d105695ff42a3f9334f1234185efa4c5fbbf1b0414d31a52ae9cebd2bfd6a7c6a8b644cf477d931bc06a623031e90d854278d122e065a8aad09d570a6bd6f88dde27dd1249434818c69c56abd5c9dac21edaee47933c701bf0557696a25be7759a1bad780beb51a5d4f548234c55fba276a80e3bb672af5b8cdd176fd48923988201bb49c9351b2614928e4a938aee8c1678c0f5c7074ccc4e3f6f5df4df72dc798ab7a68a8350524c3e831c378b9ab2a84dadd6fb1cb4ff4661d58e3c258f976885d9d4a351cc24517286792aaea3cace757a561c95fae59d0a70ad6c68ea785cfa83d2b4ae0762c48347df63f1a7f8e8f521b3cedd20ad07501c9a314851bf0a4158c5c2bf8c695ef9af4b18f4727a55bcf48757ce882ae1e22f947d8414785183d16f4e6eced3e2f6d12247d306cf83a7dbc0eb90fe82ffee07e29b01a88298dad41d2847aa4c77d04e47a3f7e7d51ba0115aca2ba23ea400e96cfb8bda4f080bf827d119ba70a5008fb0b2b12f41120532ae1a2015d1859f8c5781f3cddce404b3cbcc02775b49c8b185fbff62daa51f7d49f22850bfc63ff9ca56d2db52b88adff7346cf1541fae8177048e143e62ddd8f3db749621b2bcf6d9f273f6565aef2365d01a51926e28f2274af589cb68d7f4d22ac28ef509eb6798603c6094c97e7c207e189c001bf80e3f10f1f088966f288e232c71d92a32deab5a123eb3cc92104acc8274b4f18722980d146b39cf7a26bf8bb83d619b0566c68991c8d3185004698d3e0ef05c68d15129271073a7f8159a48af","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
