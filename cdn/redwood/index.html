<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b1174c20abd1685c22fb050197401120ad441ef3f6e63356770169b8cf0cdf00c52b2f03231d25165a4eba0dd198cb42810e212aa4cbed0ea2892ad7bfa7d5b06852e881cfb650f68ad7d31d0f5764785268ad4b70da30b91dfd9a16337b90d5df5f8d8b50ba22fb8b868c941ca4c707948521456c330c220f2f1be78bb2244e02d8d1d50070198401e53e3c4fd8b488083eade916e1575c79ba93023a1766018d1fcee45cf16257f0f45cd0022004d1456740b8f6ce2adfa16bd287b1e0d371e060a8eb1cd43f4ce32217634f0af2a49495ca0ff69e550e4a6e85570aaa407844b87897daa77d299acb8d0068d21b94c951f59f36a1fc259df060412cdc63ec9480fcd69d1d332831e3f45812ca395917608da30c5336de005c82443400adb4951857100abc84813dec5af0286cae1c9e4120554b7a588cb2faf3a34e8e11326ea1d270f57e5b43d5c097e1d2671cda4e804424af65907672f127cad20286330f9f1efcdfdf954a69212465406dc0b9d48d19be3621821c80f200c244069e1ae40b17edffa828284035c2599447d6027b7ff7603f15b5386d9bb7c091640ee59e66eca2c2101318897928ecb5ed77641861f366263fa23f775a295c04bdb695bdc3db04a2c19a2678034e28d164b668b7c118f843e64fe84d3fce6af94e802d85392f3dd31140f62386e9dd21d79238fb414f40aa42a269a763cac4c068193ca9a93ee631fac21128654b4af6570024d7819dbc5570e8e512d070cfae4ecf5f7826dd81e1b3fb0b5ff24e5c04411e3fdecefc7c635ada54c3d2b80e837d3b61842c688ce5227b0ca84e09c78f54d4af8a980ef02729b5a2ffc343ec38abf0f93e5d4a684c64e16a67263fca8efaff6df9cb215f001079182302628f10bbb3609db3a10468c205d3f93a289c367fe0f28843ce273828d72165f3b351d35c64986470475c74554b5f92e47a559e0aec23fdb7457a975d3fdd9073d01a5bf8ac11e2e75450fbe48328539199699306a7205882227d1130237427e45399f92b89d79ae22c8ce7d2c0f4422ab924106813dd8f02e0cb35a90577f4981b735fa0d5ed3e36a67e10bd166b6e16236fadff01826304e1a94f9532e8146b3c11b5ce55435bd790d40c500dfba691b907aa92e977d8e5a55edeeb363c30cf9de2b9bfdc9920aa1735df1e912e1972893d5b89a732f0f9e7a7424801c1d700bfd5fc14271cffe02348a0450610ab115b4f0276ec9c362a45f9a3d0c7c4366d34d104d75555f2dd7f310b7ea36b898aa8efdfa66a47a45ab4a653a4f4cdd6f713b8349622968020aaf1a7de43efe51e20df1dd1a023a057007ed0633d949532727112e5f7a4e44b3f9a0e128c03f5530e3f0a4f368964ac643fa55fe89e7d73c2917e4e29348eea4ae9906880a8fbcc827dae0b7f8ddfa7cf72cbe40f9dc6653004797990c2c09046ee18e9bd355312f6cc5b87e446c61bb3332087ba5694da3bebcdd98ed1f64d21644132fd7ca861da2516dc501b6e2b11184b846f23f1ed17a9022a0eb864f0fcc0e6159744367ee5e79daf82c58e4b0aeed0d1f67c471d40c8ea71a3d9e92b3b3e435414b284d2230712f88bc50901a33a1a070234f4555dd000cb11aa9de6409299453bdb52e367a3cde1627c56326cddbb6b6971dad974b22367d47e96457891697caa6fe0b02646c5f40d917a9f626d2213c284a39a6d93b3bffc4fc627c6bddf0e97f842136f9188ca5a0a9fb76cd21d622d226f4bafd640ce6b77f16627011b32a4761fdbad08359a05674576af68837265243c09153c31fa6bd7b923f5e20e3c6075d6be3e5b132ee23c82c2f5e0f231f234be3db7ea41eea9224686d71b2c1c154a36061ef502e990b9a812bf687bf737a498994b849f7758c8fe254113b17b953c6a070d130cfffc81d8e02594fd87174945f969ef06d0294d60a213064997f736b3f4104232a846cffeb12c299a0442ba78f4569ffce4738c999a31acd941bc0d0cb3e6838f9dd0c38a7d4dda755ec41814965f26333cb9374a33a51bedb742a22f11b2599af5d122a2f8df797e7231c7af3b8373172642e7c755619aad6e4326411501fccca1e6456c556dbabe882e819e95976930b0519d1de87133a1556bc427fa73ad6ac3d1281722531edb1ce2b3e66362cdf935d68a76bd6d4a964808f8ce44c3bb2728747c3f78ecb9db9c21639b52e8227a085737aecc54852c146b20298cb92256624f30d0c0f2e19d4e20e3cae99dfee2256495fcf0bc073b3adab0937c3cb00d40eb73b103a31356bb74ef1a9f1855e9bb9705c65eddde1eb65f99cbd94b585d2c466203803468a0c6c07005abf382bf2a07a6bb8c4c12440256591b2b940be8f6e572d3c6212c1e8bbe45f0049ae24563d6f3a02b65cee811b22551ee3c2143683c17b65136f0a28972611cb19f33786b24fe4ee9954f61c8297270759f2c52d114d64d321e1a9bc8c9ce3e4cface521b2e4280a49717ceca9c2ffb9c73228f619a9b4264045570eba326e03f9b0b134eb658a2bece0245416d11de5a1af0fccc51477f7559af2f616a57b4280809d7bd506f71d52c351e062dac262ed98f509ebf30e8a8e18eab7a77e37811c2183ab082c5517d3a4a48db656320eb4a76bc7abc36906980770c6da613c0458ac0bf9c544d05163285ea46a907d9fa4e3ea3c0900c3ccb9da0656c227ff17e9399e17bc7156f44fd1502c09713f66190153cf50565ecca747d29a57625db07e30fb52f9455aeb98f2a24c00fe737af3ef728369dd849ce8cf33846759fd2ac218159bda94c419612c333cb3dab1a3b0e3eee6b464d0e6c89286ad1a4b769e09c57ee2446d5ce432e52004f2b06e5dd77e95fcdbd68580de2b550e9de17467d2e089e6b57ed17362d1285e49ea1c05f12f4c9d2faec9a754ef300f08d5eb508264500f5eb226d6e12a8b5d9ba2efc88142f3ce9313e7ca46687adc41552a561abf26ddec8df3cde9ed345376d6c4aafa622d5ae41bfff502c6902755013d81a2eb7a900e459e166defaa229bef3b2bf49adea1c0eee9708fc884b02af137f689334e7914223740ac41ba525698a51408296bbbf82b32960c9e9218c5f530e0d415ae9f590ebc752525d1377b5fb77107dfc736225e831c581e2c6d4d9ee2afde9c9ea1fde8be510016014ae4fcde5e9b9142b8b18bf6a1030ef1c4007d72e768c4c7ad6af13bd2b00d198557374aaf9a6670f5354eddc8c3658d2a79943ac55f646239ff02b0c4a0030b3713c89b6c5c5aacd751bb2c99fefd7765fb99b26a06082558d30122d3bb3873a39c9cc2595125b69e9992636cee7908983b714a1f8b1798dd2b502e1bcbdead4d8b8289249e2e03596b528d7d6e38570945d9cf1c121a7e0e07e2d2004f85d0e8138557a4a264684e9c0089a57860ed86d71e066015f81f3a1a2bf339b032c03492f42e17bdb6bb1ee7986861839251b09a7f8a72b529d8c54dbb84a41bc7c72839319321f19cc410886870db99a50d730c8eaa30c4c008c7cdb45a1e8d9f5e964ebc88b4c629ea207acf268143adba19581dd25c15c575c151e37946cc54061488040adea7951502677fd37a6d00565571b63e396f14014efd56dea81d7dc4072d4e115642dfff1536553f2a2d15efaf16a1d797c335e9510107118fff62852e3ac5ca8bcf8c879f752ff58bae208b95ccf505e88eb55e7e37b28f9c6be8b1523d65743f190067b7ae897c5e101e537464f3437e7ee678e4655a006e98e421e50f2875bc361c3d5c41b3bc119e7e195d1019eddce88f7bbcdf7a4a6b365a7233691aa9ffb5da786e0911e62e33f7f217cdfbe6d37fbbcc64ae042b9533fa96c852961a3f676e38b6508681c671726c5bcdc7f8494947d88ea0daaefb01d1bd642207eceb900471286d1f817ae849dd2baa264293d19f7304eae766ff8f48749736bec1de5d1511f3fab76332537447081283fce19ea722db53c956f370b605ae11417f78dba9f115719b649f26ae4e3abe14c7621999ff3c2f32c2c64ef1d2c5ebebbee815b989f108bba8a4443b10a47c257ecbff1107898a8fe5c1eee85c5b0e833960fb85fb9cfc37cd6b29852f93b32f896e2f5334966e8d97c6f65355bbc1bf4cd81fc5e9eb88a80c4fd80a2f9835178430ccf75ca07c13e0f15f352a90483f39e9343e4440ebee883149e7f5752b2aaeb2c4a0f14021eabe77165757dd60b4b1f11b07775fbbc92f10dda87c2ba262e117b49a8b6f613bb7869ddc06f3e9d25dd6c344e5fbb2290745f9a483d0406fb36bae9b3cf881809f32066d11a58e92d95d22f46a97ffd8d4140651f00e5a172802b879dd87a37682e8686a1832b408729d335637c9418e299ca381ad99da54f42b2fc3ee3c725b0f21d67a17fa8bb45b2520070d9382d6868ec61d097bd5ba92915b7edf4ba1a8b4c7b26fc0bc45890dcf8db6c4b5e7bc4a3489cbb96c663fe1f04a1188d245d492f65a06d83aa327dc0e40f69595d93fb035752ac9fe731d9367a5a44dfe1bc9cfc32e9807da42f4af555074962f593481b6a70d91408d0c01442f9d65bc37fe10be86643dd6f61713025872d7d944b18324d1f05b85704489b2b7864832adac9c6814f86446ac9c682501f23a11178280ab60187701698fa14dc742c791ff13b80d5e020555bae766205e69cb7433821bb5f89417ea5a97000cd5aeb0f1ad9e1db9382789c466ea5431e75eae0e4bb4f6c9d402da542cb26b753a5e26c8ad7f405b2841db5d6e854d99b1058e8bd69cfcf9f3724a0e95eaf2a08c3fc9e24419920271022ce40262023f13ff399295602c2d3243fd00a14e83ecf441b16accdd193a4c631545c722bc91a54c1cd58d211102a68eef77d9af175528b22047c18c32b69139f8439032d6d61546ae933ac2cc8901f16eda7258b7cb7ddf28837b632bc0893634840cba09c08260f19521ec3096457992504f558e06399b3a22b083536545d3e2048931bb1fe252be0a41c35c7a76c3b57977781013d6ac60203db5036359ae116e0c1cf8c01e92b627f0d1fe8ea4680b457f2349eda6e16b961ffcbb12579ad4c17392bf82b31588b0ec36a37b65edb40b79e76629b3a2cd7b6c464b1df1500e78e6f7f2821ee5849b0f2e23ad5ed2fdb1f781b2de024d8d416945bbfcf5153924093a626b783f9e35afcaba4a753693f0823ff7f6ae03124e46bd2e74ebf2f099fcf1f410b3e3dfe084b8970012091d8a370072cf0f8816f35cc1f59f18faf2720d9f5046199c4f36dd92fcaa4ddc8aa81158f47fd81bc2b7e57745fb0cc0ac4f723987ae455d10fc88ac826694e360fb819e2974f4794d4a349910edfd9c843aa77a595f08dbf8b7da99072d70eed118d362e9cbbf9753255774a993e04d47f94b7a70858844630274f0742b8b521278d19aba0082391549b27f167678c7a3ac77e37d3640aefd48c9f529c3fb8a0298e913064bf48fab8cbed3b0a5892d580b9d209564c1e0748a9c57acc5b166b4efc459b24513844c3ac463cc26905103524be1b592161262c346167b6f9b008243f5aa48a6ca98cc12b2a1e22cc4fefe6f25d5c2eaf3aad70d7858a6b6b8e1e79d83cf084bc3f007608e826b78c82f860c728dbce46da6dba01d64199ca6a9ca59467079b916aa4e3cef27e98d0aad8b99b83615a4f4f5e2fcaaec5db013e6519925eb3fe038ef0093d80f24625a2cc9900346b7c0fb8c17be6651190d8edd01b9aefe3de6caf5155c3317b281a3bb0d95abad8aec56487ccc4a9e040c48feb3851b7b5184705bd9e067b4ace75f6c329b5cb12a2bbde9e46157864aa0a2e7c57a354edfab6983472e97070c518e4fe55ad6deccacd2b73debcc5ee51c810b2e78f2351e1a5d93a132c5a2df703cb498f6da4b9489dc96e6a5a32003f54adebfbf8c0606d760505068ec4a70ed0e25b7d409ca5ea6c372b7c55d5d4e555baa7eb65e8d312865a818a811d2a6ef5d5f28f95f9fdc26d10a4cd76a82919363e4ccc97e785624afab942f8d9f800e73dfb647b930b5a744a14d2624a30654ae2155aa6fe192e71024808419d0c2cb5038ac942710ea491eba1d9a6a31854947b8719f1f4d260d85e5822e377991f4d6578ad97ca4ff4661fcf21c1a3d59d2d553c216984d9332eddd181bea14e2b42f86f364e7377665b3249f1bc7d0d13d6a8cf21872292141300004be73c8eb67a37482e5c32a5120191f6b5f2a454fd20ef4d3854b0fdd085ab0ddc4ff748297eb964ccbefa453cc7b3adfb60bd1328fe05b43d83826e95c07acca9fa203001a51d5b25154991bf752cd0f14ce6aa66bb3e4ce1e09497dacbe04a81f6fb6478ff78a45f3c46d1f0e31bfc70fc732273384384079d74750847dbc0f00339431876087551562ed573b3baa599d8c79b18ee9967f5ffd1788efbf710da0e1bfc3acd4025bfe50dbeeed2657349c31298f6902735227a5deac1d936718d085401acd12af05eabbd4cda6d14866a42909c8c5801bb4cee271aa1ee4597c75bc013c2d1b6e9b9a3fe3185b4bbd01538889f2ae495851b399267b9f8e619c47f0d64e106e306ba6b34594824149850f1eb463948924f96acf803063579b17478d7a140d46e6d5b4e53f11869a19f199daadf15dcf2f0813132222687a34a9e55bf2d681d46b4bda3af351d4c99731d621c45a9af471c28492568012ca2901ba68307aabfd2a82544c26515799529c0b7cbbeecaf5dce09a12cdb3d24ab7ac08921f48c160ca7f15efb30c4a4142db618f5970d4a56198601a04472934024056eb4ab8df798177a9b032db80def75a325ebb994785d91843d0363ab85dd97ddbc4505b2e41274106c4ab1c35930f56c48fd77c1ba55317b7dac43da2c9ddca3e458b540e57303fb7a9c817cdbe3baa49381166d1506b4d405f68035a2dab4b8e63a3579d704ea4f95ac28557980e38688a3e0fd70b9a59c3d9b06cbb397c0e231956833e42f9e38f37a6794cc62edee436c1810beaf55e7a2cf8c1510eeee79fd0e59b761c2b2c5debd35f4030ab7f73036be6e2a64d9bfadefa85540433a6e1f25dcfb54fde4b72840f7674e3c9e396d7a6008a72b4b2721596929a827bf271d42d14798a585d79d1d31a276b39687b351cf139da00a093f46c372eae9c29177ade843738cc10326c217c7d5c188461f261adb35e8c5d152ca742575992bb87d54a1ba1e652ef4ee597188e4ddfdf5f27011593f7ae92e75d692932443150e4cb3d986984670c8d50940d3a8798c5fe674dd4cb1f6b3fc6c35e0c9eb0e515603830a1dcf1b8335dc87858dafc0e8000ac62f427cbb866e75dce35c8271505f856feeb2d29d5c093296dfb5cb69ee2b62d34a490cde1a1d4dc73f85650b17f8dfdfbd9d689efeffce5e13482f0ce9cf0a4435b157a89dec4b5671ba948536a5bbcd74db98e972b5edbc0bd723cc0d8427a845efeb07f1055a5f11142a098d90b888b6019a880f1c34baf57f4c182bfba9fbedcf48a5745b3a2694b307edbe1ba034d4692e2e709c4bf4381237f7f03f6075b62ae5eec0a54a646769816b1faa2f25a5b969f7e681d3f217903c1848643dd0c01d6f4fe051b856249d6e4798f04b640496a51986da452036e05dfd2b891123c7275ab97b1c0c37d0bcec44070cc1e8dceb9d18c7c1799e91b9d0686db81804b43d0e876b1d143bb58d6f7b0d1dee4cf480a3b4ce023bfc4e5dac6ba896cdf9abed5e960ca4741da2d11f5450182942ef5bc5168a2efd836b1b70d9a8402f00907721b9e4cf2cf588218b801beaf2c0e7f6be97027e7832cafea85ea4a110640c9d358da8674165fdc09a95d67a371662973fc1cd2e71beac5f659c8c2e5e24ee163915535aec521f89dbdea36b66bc3569acddfc54584b099ab4ca333ff61ab692f04b583b1c56260d17c9722aa16499a25377c4b1df91e041339a9b8f25a378b5b6be0205d4d8db7ccda9d4737605139403dbb15c8e96d8e7253774827d0318806a6fd9eec83a1e1a6ca0cffde3b679e1c80a2a5d3fb8d24f74898638dfccd5816c16e711c6454de825dccd5809c4b211887465dbf38b6fbde290b8c9738d8b4e9a3a1270f22c22aa7a1a55349a4b9a1de5b32235b18188de8dc150fb44460ec30f6227dd6eeed6e358894808f031c82aa5b902a5dfd0232b0f30b9e284991d6455448c2401d4904af16e7eab6c5cd381086f4d0dabdd3a8d461fb68f30fc4052786928c87896008832679395c8464aa3debe88a6afc8cc511b81061616db80e052e79387e1ef2f4b3c3a4a41f882fa04b4839d3b474f203786cc0e5cbf6068e8ae926affc75c586439fbda67ebbe3e506f1388e27de75064759deb6626cb5930afde5024cac9268ee5971eff602e4dbb2fc1c1573ed4d79f54481d3c7cfab0fdb785062756ef0d0b1be578a641c6247cf520aa8d32f42d3c6ea1504d5afc9dcef18073253dc35fe1ba3418174e2ce94861f28307866a21e686a2e54d3c5754186599ada8119b42a6df89bd27bc23d61098c72cb8a4c27d72cc021c8982cffa61d62901d1076dd8639d274e6342d54dc1ab3ea7fe9aa4a0c3d6f12b23d341d7e33115a68adf80c5a96c120c706adc6c42f83f33b21425b3274aedb67a059242444f9c0fb3abb1206976eb104313b2957b04af9b38f24644618495638e0f24d2c9d379792f2a9649906e6ffb971ec576f0181f6ad5b3bf80a45e92ecf1ec1bafd6ad534050ea0d3b715cf7ca28c2e48845c29846f9dfc04d77622c01107d2e3f11f5da43fe2b4a2e4db020a90f8509e878283c428a1ef18fb3adc6b3d78c68a3a83b1050e8a32f6262111fd05a348acf02664de9a6503e9e8aa92d85517b8a9a9b24999f29212606d978ffb1971ae0ea58d2903db2b3e61cdf3d002451deac017fc81e0043aff980e0855fa00360ac90a527d45d49670cfb5ac280ae6729403e313de1eb8316a90bc30e00eb8e7c08d1ce563da214ee1fcddb6f1a85316f6d8d39ab041f3ef1be78176d261fb149c41c90ff1688105a4bff10336dc569440c40493c229944a723ab98ab8454d8e3d76e1f551575cc98e0bd51a385b58dfe54b6dee14e5ffbb7f89920018e9f42d4654ae962593a84a18842428b897ba6c604f5a5fe8664ba43a060bf60e23c958ea5e90fa96fdba948dce2a52950b7f252929ef7e60d4406b663b63e8eba5792031ce8a020f6a105f898afed5e99cfc06f83a91ba0345d2eb010df27501334b4b8f3996e21840300124bf5e84dc0f5b731d023e8f21910409f66e1b6aee7aef19af772748d226529876e83e8cf5de700fdd6fa495e522b0146b04e0984051be25321b805ad2e76cedaae1c9b49912039d20b60805b4cbd87a6cdc4dac8c4ca12b31847414c4188f5bbc37b1264d1c9a8e5d764d2b1df8742b48e03dc50d099a262b0f475d22e3c00cca1fda3cacb69a806482af2bcd5dfa3143f349058bb689c41a0f3ca8195315c88cfa6de8b09c36081f559329468e99b5c67e636480a7b8c2b0e1c64735f7c9acc471d68259bd2d4464903802c316c66b369748b1aa4fc5d13419a577026cd17a4d394e9055868b9e946930982788376db33370e861fead237093c02d4f2f6cb4220a526f5afc416b0fbd0c9cb7ed74cc08fa8d916f24e574e9543ae324d6fbf90d499da5a660ba316c239d46671529a1442483bfb7d1ed16df38c5655a891657bde41f5acd1076d5986dee38775107c07c75d3329dca30aeaca00844f9a9d1c6e1979504a0dd2509e82c9b4e55c540f6e2927a66a2e5a00969ec02aa5f12b90c750074e1a405e577f06bc47ddb5be597f13fd2d4a12bc8de152d8e2b3d4d31510ed7b2ca4b2ba98c2326de5c4ac3bf3a21f453599c502a4a7bd84fc1a0126d1b8a65a90941e7141e3a84be2d95715df4e05b2a48fc2a1837c97ac3a4c57afe7778867044a634b2165732322a27f918049827e77bf020163afb6b4232e25c16ebb176f2336902110a7f6b070826a9447e69823bca87d6af97b003f8b2be5b2b4d4e887b170261a37d390a72c2e3e10e3bb4d87e938b66894d24fc02ca77ffc4c85e4d40785b59ace3a0158168728ebc2557a55dd152a54a667536e6b2980687adbcc69a3aa46b00cb3663a43ef7d03a60ce89f3f3cabbe5ecdc2805dfd950cc7df716cf925629473caa6af5061f4f6c9cd91025d753fdf3d01ef998fec62dc6143cd020e0d14ca2464ad568e064464174a5705b2f8fc8666e1d4ccae50ffd044b77d372cf5f24440a51328637df1d5f8fd59f70be4758e89b057db843fbfc74b5831ffe7dea334d6567980514afc5eea95dfcc01ba7356a357ab46243fb60e519245ee37dfd855c9d3d663e50afbb5b87294798808e75b9a59e74e0922acb914c741952d171fe17f402a941d1b45670111f91049601a78264e93ad7bee55bf779b85b696b781017c589e4d91295697fa4e7f8ae13ef328dc61b0f7a3937f4abfe8cd18ae75d27f4b972174ff0892a33b82b2951a0753386e0fb51b0515eec1047b194d5db790bcf3f2b1262b8d4ff96c6854e46975800fc66612cae0fb7d9ae484f307c62f73785cc75cf984107b12951915ac932b44642de4e0eba47755d9a2e1a660db1637e75ceb483d9d51c91d23acdfc68fc8195fc38b1b87992e530103f6c6657b446a25c0504414a1fb544af762cfd619f2b3c401174ae3ce0b52932fde5b9dae8ac9f8bac81cb403eb6b310189ff90f1bd88341897e2f73de5ec8f008899a736c88e8a5ec80aa9f7aa95fbd65106533a0545e43193f9c70161bd5a6b7d242bbc637b68529977a37736bbdaf57050f3c45473b77d51faf470347abc2feb375f06dd4962b52d7e042d74dd7baaa459a1584d527d87d5289b12ad6b6e64d38927bba76931cb3ad0bf4a074d0985016c1bb2300b2257fe1eea2843a95d1a6dc978964f57f5439b0fec4af45a103ed7e138247c3b9d956182e6cc9ff159f4c6cf33a25c4e0a66f8801e7d2b5238745122c1919f7e4e5d5921e0196bc24812d911c9f7471d61a0ae35ccce6a1afd6c0b8d38cb2f0e9782b431d3a9198fc5a21964d13842e436ed777535ba904500b6c61884f4cc077f8480a9f27b7854ec07f1e196dcea8f0ba835d445aa64b4dcf1888f795d8249f38b3d6bd0d8f88f0059bc4e2ab4a0eb8c00bc03590c9b4d4d9d736a6bdecf950e56a920e02b73cf965edd269d79544bb9d8639321450d6b32f6f24656a663cac37bd53b4b6aa6745bbba156b9176954a9887e83fb99b4086f1a94c10276361451579faf6d2290b170923cc01d0d266e49b61badd0791e6c588451454951804169f4d32242373825fdc37acaad1ddc73c59a17eee663ef77ccce1fc75faf7470968d13d0679cf80fa8eec07dc57677252ad5124fc3dd72222128f3b2542a29b4835f903aff8368e0a84661a308a85ff94a456dc27d1151c214382beb451eab51d066679ee03578f748c4acfd34b5a41f30a654ce778c9e29255a35d1eaa48c8ad698a3b1556e30ef560bba1d4293904c7aa968ff09c2fe578be0724d719553b34df501592c92f26ee398e94b199371d4da6f9802d3e9efc759d8d0375c1abf7085c04c2bfaa0d21285b10c1cd03eabc14de943e243ca9426ba2b3ad171e53d0ab0285ae623211d96f27103aaa75c734844d8044d7700bcdb0a954c4c54cf2d03ace2c88c8104c32d0af29434e45c7fee257552a3455fa2cdff4c04fa2809eb7291fe1a6a2300f019e08291e88bf1d9dae1740ca2aafccf873508360514b1d0613e0f58fd3e06503c2ae42c1b677aae0cd8a3f6fe91992b9ada5a0c4e089d87d928c04b5cd0bfe381e718b33f63812e9e1f6860f02d315e915c3ac40a26339cd36cf87f032ff8ee5ab4aa9c39ad8e87b7ab28372a0aa3c896a6e7923c5435be3cb713afc4b143d0859dbfc02d28765db9ac2a77a03ebeecde77095fe9f527d3e3d47d77b530364d35547d25eafb3fe213bde936a60bdc7066508edd8bf3b455a26839680db2a9c7d96c031a52897ea2b1505d295be9b30049403b5d1766236f6c01127330bab168a26c4cf29f17bca1a0d9b17e0d7633517ca520f680289182446298af2d83c5c50bda81a10f47345768c1668856606668ab904d633ab53469b095b230bd6b5a5298f97f1a0fbed2aa9b62da6b93da5c1873053df8153841fd561675852e638b5f3f4e05968bd13b1adedd639f5f1d777ed6e5f58cb7aee9a84cd3abdf472e046e74106b3b95e0e4b9f73a2eb07f28a3d97be7ca5d31e5f48aceccd5d9154720b3c2768a9cc5286a47121d0f0fa746c53d68febd6ae36970316eefb62176fdd24f011b52a458f1da988bbcdbfb791df67626bbe132e8fb3500bb2a7e53c00658e28430ce96b0a29b0149a7bb1c4d2a9f176bb6ee7bd5dd6dbded3bf413b1f3937ad76f7e3bef3951400a9b4a3910ebacdc8723b5f8097794928c9cd08019cdbad4073981a971eb60829b2906465eddef340c3280a4ead51c2a8f26d2ae474c9aa0003eac086afe12066978d37d75de8cf2fca952c804ea9d012366da2d48e720aacd8d3d92f564f733749f4ffab1e57e5ba70ca1385284069a2b4267921a09ed633d7f5c3aa5b6a6a4b96a1f929970efcc1d9008702b0c681b1ba1809ff551f0d113a2b4e22e54876e70ae07fb8d8952d4e9270da496b7d90d37094e148f243c87715d00b4f6b745c866ac20baa1c8db9ab2812a1cd3aeb9b6782d2dacf08cd39fbc0161e0f04b1f452216fb33ffa199b8a7bbaa7b96ffe3328a788960e7a2c442997c432dd91a944cf7faa03aad010332f26415937c94ae1e06e6516c27047c8a3c5821ccad6fe362965f08d1732a9c5b492be468a9669543f3f31cd2eee2680bdaa1ebc71f7ae94b845dff028eb8f8a4e1f7bcf1ff37826530eda51dd65dcaa6f434cb0d4d884fe48f23d6727c9fb07bf1d58d1bbd3ec1c074389c2cc54ff3bd5440094cf8043a1a07c1fca2ce11c3ba01d80478633b4c54d12e25bd045f68ff46e6618da128c4e7007510a846075c37ca1dfeb62d65130cc16f325b0edbf0d4feb43204a0e1e50cfe2989353b639c7887d95035b8e297981cfe176d4f3a15388a358eb4a4133d881de569eade06256447e9e4fa07358a2e68603dc3eb6c50bf30141d938157c81a1336a305ce1cb4ffc25104db4c2e4bdba6ddf4c7118127f76585418482332b8e0646fe4be93a880869772c010f92ff512df02b06c5b4355fb7b93159e87814334900a8f7bf5dc29189a0066a800e7324c5443f57b575c01c82b07d8dabf43a9e838cb4174cc00da198ed19dff35d73d571af6428df14626e7f5d5ff71662e7a3dda39524577ee78acec81e55c3c153e136fc6c5d3c56ebd4afa99e82e71dabfd0dce885985a72b839fdf37091c225dd6b9bddec9cae164b9fb9228432957e877e57f1ca084138c74383e7783d45b0c14644671f8250ff2507fe3c0cb25892fa00e317fd84beb57efc9157fe867e2abdf7024ff7333b35e063195c229da25386a7330bbfc112f295a233d58f7ebb6fe6a3849033d0170e06d6b8007fff10f0cbec1db9c3527c5532bee57b6c92ccab6dae3ac5467edc40c52b8066facae244f91f274d9843ee9b07c468bd33f0be4b175595d3d80de702c5f16b4d70e294f8a4bcea5460b03126a7c0ae45672e70cb7421143277c8ff095579d9ffb577eaa16c0db6b073d7afaef5a6bac5025c8244d510853121e2509fecb34c92ae02d91d489af3e0edcea1bba3d97482bdeab2b3c306f45deefd2c5a9845ae88b288ff6fd9ca0c72e8d94c0c6b7ad42dda4f39c89f754eb0e113796424b8687cf52832d83ea730ce6df04b34e2784b592770c1e19d7de1a20cb406d9810833def8c80293e0578889d8fe3e7b6b920d08ddfa0884025965dc8a65595023624522a7bacd130561a826cd4f2a02f52e2ee6d447ad164d469cb41b70ae1afb61352d50cafb917b0e442f663d0926af5429c5058aa065b99b2d20f451bf6cff87bbdccd5daa5d54cd2f93f693f042df19c3d4e1a55b112968426ae950d7ee1301d6946695fbf44604ba249ec5af827fd758f5312456b9162f628aea6674aa68665473516b6e5f687571fc32df206099ef9cd9a276b5728902415249fa2212c155a68a4acb0fda9e68da26b974f42ce80cfa7a8cf9a08d2132eac25fdf027b99c62e5d2b80ae597c9dc901720c8ee5d7975baf3db92f0532b8f82f96c23033dc795009f0789403d5112a5d9565a19f2adedb8283c3d8fe2fe642fb1183e6c50c7b7d23c98d3db5fc4d9cdc5f5500f6c5091a07106665f921814c6e2607783be8acccb89d5498779e317ab08d172aad6b5877be339fd99ca563476119e7c3cc574284dc8b0c4a1c9087698ee59554da8447eeae60f60d7747e4264f85879c768c2f609a8a314a84c6cbdfe7a44cac9dc62692db55256701f56009bcc701422981c96d1442fd22912564568e58b96f5f81c2f77976881c96309a85dfdcbc9e6ad4322cd117e068d28e20827b752936f8c2959822bb32bfc3c590af6c5bd4cf5a63b046a5d25e12f730eeb71371906f08557302791d706c1745d9e3c26a0195eef2d4d31005f2d33025c8ccb40c8c2f971174b5cb2eac5c8c97ba3d67cd87b12fb5ac13849bf832ef2617ce54bd2e480502f0964a93e10fafb0f2ea31ac806570d052c54182a9e4615a09da9236def145a006868e73aaf2a4bebc79338bcd83ddf507f389b3f795fa2365a596180690ff2c580882082a3680fe3ea209af43fd478079e95ea14a8838ffffc4d8360e8f401e1f9f2ef698f26775ee4d950ca164eea755fedbd88b9e22e0c900eb4de5ff7685cc4657ea4ee0c0e1408d41a2f046625508f0fcf30065d79baa4b4cccac185bff77d356997d50187151fd93498c0482f8cf0c3c1172aea755dac1b010b67a3fef73d910f3cf9d705d4a977a7888fe4e253a763d5d897e829ecf52c8d7d23e889c4f10027d44eaa2cfaf833422bb13d1850a01ae7c92bd9b59ce8b7e5253781d9200c52eff6c0a706a7c14ba1c4797a0d50e02f35178592f3d612378ed1c707fb30008c0f10c9c2dcaa6ab3df7517efa654204707d684a2572ccb708fd8c5116bb4900198097145e7c98c3fb1c75d134843a8b6ec8f9be2ae1e69c9871c2371c2d393f6cac0ebcbca1740e07c80e09f32c0f4621dd618196998f8a7dda7088d64689d05cf05add4d6558bf04bb796a64d158c4658afaca8946bf4a76fab585cebaa8e5e9c0edff137833b85d995a10190d47c02eacab93597b665bc4655e5df13a68813cdd102fc16fe7eb8f5613950617ee5ea2ac48a220e07dda36d1642c93ca796ab55ba4fe92460469c462f6fe1848356bfb1e4ec90bb82e05841cf5fbf02e8ccdbf81b1121cef2ba9aad4e89a73fafd64f2b063bca4e691657109bc8c13b61a6d0d6457ff5379fca1616ed10113e19b3169b5b437ded05a76531937c6a46427bb6317b64c0001c6e67bdbd4dbd3f56ddbcc9626765e02c7ef625484fcd6b39c8777749f36f9102fed1f31f0853cac623e48c0c7206c6d6b4b7f2001a703dff30578b986912a3d6086264277ced372764bc2fbb849ab82d0b23087a0858d9f607e036cd50214ab2d34bfef8525c36e56f8c957e17cfa696fc553b620151964671f6ec1a27836f5d6f0467f11be58f17c964b52ace7dd67098f00c1b0825471f8063d2387144443d71010947fd698976f90c0328d1a887c5f70e9b879f4e0e3ce51fa8eaf2c082e9fc26dbdc9422d04342f7eb64c5a30e6ec3354c753d096a538057d2858e30506a8543b7cbd23407aef1326f5124ac3804d098c653baeafb6a557ecd8574a53aff0bae847a14b248ada8e4f217e9809db46667db14b9f17cdbda669b32979aaebeea49bf172ec1d74efba6a2fcb23400ca942102ed15d77056396ec9a1c2c7e51ec5d6007185ed189fe8719f61c574265715b086eb74734136f039afbeb69382289514559f2b86d0366e54084e049943fec781fb27aebb303b89eed41d965a220e0affc50098029fc4033273258be1963bbe3057f7252097097ed2db31f8cc1c7b88971e6ba3c09eaee3961d9c50b5df14382cb5f7c4dd55219813c7057d9fceb6e2d071e494df0f082f567a8e7b956709aa6a8ba65eb8e6b825126cf86ee8002a0593150fcf5b9c1653b91d067dbedaceae45a86976c7e4a42e5b927305e8c991aba17b197aac647071170ce88dc759d3847f96c35f6887f64824a18834b71fe9af1f0bcc1660ef585e25464509b88b869744be51b6ed3ba0b17a964163efbc666002e64f3ed444d0e11fb3e6908545a9cf56588cd2807dea7003726902e9cebe29ef0d13910e1597b8673736914849d4f6eb04aa5f2b8e07cfc5e5b8b890e2b0b878d9992e5427ea1a5b415369680dd5fbe23fc4f9b18a99eb087d34bfdff42eb2f78c08ce6b091f9d4fbe7261a1c8faec1155541ba9fbf2bfee9844d7519227d28bb0cea20a4b242a7e5739079da95a1a70e1155483ac7c5b2ed40fbef3f93fb6a15ca835825f65e45cd37990739be59ff4435a3f39ac63a5de85ca46f179f22d4bfa3e19062a18f607e485e14c94e3fca67164a5894510abfc9933827e3e1689c3b8eca2b44e6bb6baa4899b68bf7b2a688d3fe694c3af46e75558d90f0d5ed627acba61fdcb1b79eca1daa5b9790b25827263621a5c96b660f563f0162d43ab0b948503ffd6a197ced56a6cfb054b730c59205bb6ce7f12e2ed2cd3fa7cab513575ca3cab4d17c78cab09c53824ef14e395b57d28d19681ce62a709b51ef625ede70246d4d8c330ad099679ab9e6da9422d41380590240fc4c710b5fc240e774bdef5d1df28f1208fbaad71fc1d2a9d72fc7e3abf45c30dc7755f2e22d9b49b1c83858ca0844dbdf35b3d1df3f60cef44e7aa587ce5dfd0a571a15551a924569a2965c9ffe2989d649e71791488320f8475672dfee80e491681b86a9fd76c7e74e45a863181e6c47afdaab24f71ca5d0ee08b2fff353ed8d8e968a1eb8883bd8683d3b40388caed6899519544129ad24396620cb34426ee04d972f5e090beb4a84e1d605040082aed07c157cedc4cf566087f4ca35c53ca45b13637bf4d9e77801b24ff861687169bf6de2d5c750825ca7cf4ee25f40175672bdedddec183d4dea19c88bda7949deb093ffb4fea34da5bc70a84c129ec98cc7646e067b73ce123dad1661f7208a0967a6c4b42f2933f247529d892c4ea852064be16a2750ace0858b278415e4320627e1a581d1c3d155b51967f58e35635f56a47fe7763c5d484aa059cde3197cf607771f104b2f33941c73da8a1e6042256f52c5f332027ed873ec68f6b80af7a2a9aa52e046dab6801293c8f65885009e03f7809f6961de303f29b1da9ca8139238a5b676e5c1005d6108d995be245514c4f5f16b8ee718586e7f2277f95a5a527fa6681d481588a3a450219c8ca1bf517da46cd68f82cd7f863a1f8d2c782306282794db1a55172b9d367cc7727ca5edcd19917f54af95e4faca9dacf969fde201b8678ae5743cf97fc8df5de0a82287ca6484c4fd07ee7cab95796c6f60f6a1efe488f0d25f3d02d602f28de2a80a83b884d343d533869fbdea83b068c80d5d9e13b226591ea31c675ea515719ee3708c3186b743c511c1d251f4a42e700c5bc1526843e66c5c32919e39146c3e9917ae5b3efbcbb2e28ba721166209d90a6660e83bff1f94bc54003c309838673391af8f4974b24e4bc80228a7472fb7c0a45b164f1dcc2045dfd2a6be45cfb63308c292ab0e52a63a78d25ba385c1c942027879f209caf431e6ff15ac2cfc7950edaf163c0838d0532c83a846b2a511702149f975aae09819615b39f6bb43b981b1e808c6316d09ec2e5e2ff9a305390119ad00a93fceed8f01cab51ac9f62c38732daa6f7331cc2590bd9c4bb6519cb8dccc77d2b08929e3808e18d3546d67008a42dc5e62a09cb9da6db338834d9eb234f8d4c9c9ce580f416abe50d4c280f44e9992b817ac35b232f7917a00","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
