<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f89cc0c3c9e53f28ef63c0ac885125fdc10c8920dd2098b2989dac3a50d34e0c08c0e60a9bab0349d55dbf81f6d90b5ba18148938798a79bbfc928f502ff85679823816a4ee3c9cb5b36ace20afea5b03289c26a5624db3d77c7be666ac1a14660137042b79cb7bf970ec2d550e66fc19eda83da9ec983f8ea7b9a7e3be910f0161392252e08af2da7bdba0d3160fb7350cbbc80a5c6bc53963a4bc34226c73107958a9baf9109e449b63eef93a17930479e1438f44ceefccb1af2075be1d2a404e53765f2293c554fb5792ac3c97262313c0f48bf49ad23c4eb8e1fbd4bc177631ec29e79e4e7fdf43b4c5f43e122eefc574299c1f1931b7ecd6b01752617fb1886ce483006e0da874dc5128641cf3c85fc3d7ba85ebfbcf457701cbb998c10b3ddad2276b8f32f68173a82b9fd117d09ffa55fd522ea4559fd5bfa5b6446b9013d9b036374541063329b0d340d79ac9d3ed2321f1d8943fd66763be39509d2ff1b121188144d9df5dffe87d7350715a94ae9c813bd032a651a18fc1323a82b9d646391747c3e5c3cf4b9bf00e67f2cb693875604a7e724cee86de92396e68d72809dc1dbc057f0f586e7a2c710a8943a82f88f4227667cf84fba91eb7e2120b1a863ca89700090bb91a99cd3e897dfc36dbc5bbf83d7ac2fea38faa561374b8f67c942cd3b2bc3227c2651b72f1bee4c3cb4f4ed9a1f925db2de859706b32ae531eb2d0b2766df52acadb63eea2e6a2e9ae3592574a3ca8cad16feb11debac6af25b9a59ac3dd6b26bc072ecf6e7c0dd16a3e0b2c18223f8fd942902d562f570b9fc922fe2acbbfe05aea3d772e0d8cf4b1023df2aa074f551bc85e78ed5338813f2f0c24af4aed758dfb28eaf623ba189dd082ada29581a47bbf7ae9bb7b912c5a8cc15e92dd6af03c33e44bd0cca376beb97875b816369a18c690b43d98be8b0feb6dee9b7affd21aa08f02f0ff7740f7a650317b251b3abc4636279b3eee89a026b364c7921c2e8709e0413122cf34ab1a78934fc12f8818cdbd41f9c9c9a59e94db51f563ce42ad4fbea688ce3be246cc48252be0e06f3e4b3c913c42c766313275d93c3467dadd9ee6cb54a84a7fac9ed5dc7bfdf2590e5add6e943434b918e171e844400dd6a5d214b63674036b26e1658b0b697bf2677a406fc6c0f4c0f7d4ddf701f552d837ef3afd5f8687e93aba5f2c6d6ac2da722f36982c7d3628edeff98d93bae52ac1fb65a28b64cdcaa3a30075b59f70c62e6bdd755b4f5e84d0acb7bef63b1a55d64dc89376e28082d2a4aee4078c3693f111efa98c493fd628d576c019a4288d2bb330ce303a3af2438c84de3ee5698d4405ac4b881c5eef3198671db263f639c6da599eeb722cd6883c677e72895258a12dad1522fbd347ed24b927a2accc761dafd9f9878a04892dbb2829f39f87fc815c3c5fc211690a11bcf91cb987105b92b90d9a8d86a57f434fcca7b5f3c2c8b7f0efef302d3753af04800100c07225efccfcb0f2203ba87ef6cb6708c417478bedf09c4e88d1d07a4c94efdd5f12f89e6885deb48186f1a23280fbd9641a5b8a4dfc2ba79b5d82d83302838ec3abc50a5a04414a6206b7059ca44440893df82e5c9d05ee0c4d2f0cfc5b5f3faee409a827e528fb48edb4d3effc6422009b479bdd7d9d72ddb997f1880673f4fe37702f082781078a403257eb90f50c9b35726228a01ce29a8f6bbed638c541dc8e41a9f6357c2716d7551bb8685b5a11bd990f8b68d9219539d3405fc2a28a078ad6aab0cba2cc8207b6dc06e8d3aa9e6a01e56c303b5b63b8ca7aef50875ba29171d7e0c78bcf7aefce8173b4402c61e2edd0d7b94f89f9aa7135b127e08b59364a9a3caefdbb4c838cd1b09d9d4db51d47f7dccadb4061ecafb5d46127343d6e5b5ef664487c1af4e68131e5599cc4fad85390262b5212393adeb9d6d69adecebdba1c8bcac7c4c541088e8dde0fd78e768f4127b33f0a15505c9b392b3be738bd6878766100af6dbe515073b46a1ad8e34d37ce25b9ca787d104e1c3389bf69dc6b8259db24efb4428671add75726ce6af7342d2feb52988a81e2bd9f1ee58d05ab6eb0178cd124bd7afcd435d6f11c52ed55ed83613cb29049ccc7335930ef9d08c78fabac9263927d776bba3c1f5e53336f73dd520244836a536924364eb8705bb830219b105b9a558feb95954c3a74aac8fa428c73496bfa26af62970213c556ad2c69b7f75ece832bb8012df7a0660da16e0a808b77d8924d333cb95b0b653cf9339a8e5d33a75bb85e6ca09fc0d454876b6310e199ed1868df6dd4a5d191c656510bf4ad5fca9146c669e6b673295aeff21b3d1cc2dbcb2c9ce47dd4b452e18818de2ec115038b07ff0205d8f3832c5533825b57e49b29dfef400876e1a8fe4da2191872c5aa132efc9dcf5726462c57f816f10363810f672a0c0d22789327c373660966e1c9abaec337e144911a5af1eeb52d6045b09447c56b834da8fa604a05559dca0ca909445b39fe8302f0442279fd0f24f0f1a7bcd6a4ae8cc54bbc1aaf6b78ee773373c052d058251bac7c11a0bb63dba4ca5d9cfc04d8ee5403dd06b91296b92328433a2f9a057a547e809bd009f7fe8aca3256b28640985b16fd001121b79dfb31c11b2f91125238a707fa291d84e9ebc8aae260134af7d323f52a5c9409c502244c5498d5bb63e7034829d2e37c075af721902accde0486896261204363506696ec6077053753951479590f03831dc977e608a09d4292b565ebc4e0eb894df2404b404fe659241d6aa9f86c427bc5ef89771e49a4fa0236f63bbfcc0459e556145314701f26d40d30da1e0819169f46b93fd5ee359fd724572ca489989920f84d09b2e4455ca8950c6509d4b1575ce7e2acee7dd3111bccee41d3bc549d1fa521f93ce5f23c0117029806cf1f9f7d377fc85a6f222e7da6b5580a1b2a3ac591bd060166ad7ed66eac6a93098e01506c392b9eb360ec8732a110afb18508b8ef97704f75c8cecf159e8ae50b0f5467404e5c01570d461a1e021fa71ff130dd97568b5cfad2e41f9f3e277bece4fdcf928166cb6abcafe7b1764c24e8ecf36ccb17f103e7027ff57b2bdcf9f32af56d5ba0215e08f610d719f7417d002d8dda80698f712ddafe9024b6201f894fed4eb31c163395d79327cd6e12c938624f2e66dc53629e67e2f9f186af3545082d3f91bf56a4df5f8ddade8b3ecf85c9d69d43346d7c52ae3dd87e3b6e0fbbbf0ae77c2dd4958235ec2cc195e227130cce0c0452a8c4da7eee4f2e2a2079a3664af90fdb9d65bc380569acbe52140f9abefc8efa03265d080eb164588172e9258987387f9971b0fb108cdc51a5b565524701def3b6485495d4feb7668188c3aac79264ff56f5bae8c2768db84b9a22a7dee51c40a5579e67d2220618d3b358e829b75b3af73055c465dbe9eeedc37b9f5a96abaaaf949ef11573685352a23001727fa3aec1dcb112512aeed931bd31cd23018ca616e0769dd726a18aa05af384f3190959acf7cac0554dfa20d62e01acadf4723286517e73815c525ad3bfaf28c1d105529954f9d193369ed0df2aff15202f94f8960b0c30fc984789f0cee0aa166efa6c95038e4c088f2ff0528b388e9113a71a46287862df2ddb746dbca82c3b0331541b6c6b4ce1ef93f2e30ed2b5c8a71aab5740ee6646b9510cb24676af27005d46e712694a6baed009ca7ad4f85bc4f5ffc2a93bbc9ea13b0b8fc58e66c3e5e5b51d44ca3ce6fea964165e5343a95a10662ad2078f8cc70925ed3ba8c8cff81eddc511a2ba851dcab8286cb1c2d1aa1737f8b7a4312bf6a345fb0e09ae39e507784c702966dc65987eb0c626579606208d2bc96e042f133d6c88e75214dc1a58597637bb98ec835203763ed3d04d7175826946f89750fc591e2c4a98828042d1bf46dc617c3a7fea545b1f8c2e7e32b2051564c1c902bd666438976e2bbc82d6cf453ae4b4a432674df5bcf2b71b5e3f84a39035aaf8e4908919860abff8b2efd5790aca195a25106aeb3d4437901a10afe5b0320b873915b70c94902539179b5ab506418ab06b7eb43b1623056e15882e257b0aa0eea8132614bc6def9ea45b6503c889399c251e9e414a4e321ab8c6e49c95a7d92cb16d2209e2fae297342c045673ae4b9bbe6f5c3ff0fbab3f73f0a5dbf96cd826c419fc6b2a70f4d1fa7f100bffaaf959fa5e2b5f332605f40793941b21bff375992fb98487cb96801464552b77f2c303b257cf652b230484d4b7645976de371dcb5cf9acd666814bedaafcb80f6f1781946456a8497fbabd65a4f89d77f5e2828d4b467d6f97a3ea13ec42c9e65bc3bbb72afefd58fb39e9a191ed4b353c6489d6045317e8e99cc49b7b8fd23145ab60067dd4e2d95131873dd7bfc35100cbfdad395b8533ed1f3b582e46f31c43641f74253f15c61c654e818d4815ad1bd19a111dc206eb7ccb1eab26f1beafe1cdb1a510c02ce41119adb7b8911829b24fdb9860761560ebfa53672741d988ecfc102352354276063e6b768a666bdf2878f92dc920fb3302bf279b965edb3333c7afbd150ff54902f69155ed88c1a60bf241d7f678bed78751a9056a69f1109517d50f570a3a2ee23195516a01bba02926c05dc270942f8b1b84a2b55babb15fd511e7a276ecf06c0848ead0ee7552e318d7d4cae91fe1c160a103feba87c3af98e580f12f5aff239fccdb54683c607c9fd7b6e9176223d1b27f3f97f2abbb9c193d2843254ffdd697649b74e3c3db5df411cdcffaa2b60d2ba4d6fe17659a75cd8e6ff0483ad04bcd1f482890d768f9bb8e0571f4b8deb44e4c9f3b37f38c0a446c434bcb7b930df590a4d53e2ae3b9bfdb4dbf006ef1e333a85b84095fedff12b07c5d9a43dad8a700f29ca487e231223c90c9dcd8678462ef33f6295c41b4bc31c1141af55fa5a1def862213718e231f5c8613026cefa1522ced904d869592b1f80b2fbea899f71c09000c148b9b26d6c18273ee6d557b02312972aecaa9d4e56d5c21f3694f2ec0a8ed957f9c5452a90e8822bbb4e5e2c9ebe66018673c54e141cd73aca72909c58dc87c5a11a72ed12697fc76b08e5e56279e60ab7d59e8820ffd1dbc3f11fab8b042aae93c70c76d5f7900a003e69e736a49ada03c2be2908100046f478a40a99090a57c2b9c3571ddddae3eeb8f28465fad77c99d78dc21b5e3a7d0b333a63ca3705e86a16065fd94a240bc537e0649df351caf04a81e2d4714abc8138e22960f26c045d94add888225543b2f64c695fa3582c35b89b994a6673a32f398bb9741798670ef2e23979e784577589ca6917b716c8a5fcb609063900184ff2a1be4d120aa9bfae5bea5c0a8ac6b2045fa09600405700edf7c770bc2528dea8eb39f4b2e0424b20ca421dda9154213cabc09eaa137f12769112d591f002055b3dae87b7fb824f120219b1a402f4a36410201899b66be306560cf0a145a1e62c598d66e0a256a44ffc6f3e2691466134bbd71cede25fbc31fe36ea82d7f4ddb4f1708456c6e9187fe16ee1f89d1471a60c2934d749daa6f748af6229a54d2eb98b9151af125357fef8746b756ca858f32c36dda44f1ca2ea2867254f0709a90836e6f8cb7e581456f34be2d3bb689294915ce3b511891e77e54a30953b13ba2cbf74f2814187b2a5eb2bc6d70bcf0046a7b31428756d6b576c552b2623b4af9cab45d3030e4a27dd860719002ea9b552a8b9eb7e64c0e6f98520ed702f7c8b874528127163e1df90ddb2015cce6cb11eae0845f641a65d856f97f8d1792668bd2a069261f2d979e4ff330b286c7c5e984bf205f4885af29011c87232516a9a00c331e65c0245d9d4e524d1543330366c732967a780d6af287ba65f5926efaa990070266f0dce3c3c490baae60c8c339e36fc8db7e41111c9c7670d607f488a9d23a320f2875103e6d7f5aeefbf672d92244e78a335c3bf0d67de4dac1a7b594ad84851583cb4cfcbbb176d95fa0084d94f3b0054f5b3a04f18549b28effb95e4e43f4768e4c882d24bf67560b2fefd38f4ffd3b48dd00664acf7a92456eb1c49ed865c208ecc96d588d90210e3f4389d48661ca47829a4af07ed3ffe6615b56b7fe79a6209caabe87fc069930f7976fa35c78853e1c1c4053d0735630fa4377e27fd29f351ca7fc2abee7b32ec6ccf41611d768cc7b34c1bedc74b86761bf79ec5e2294d26a0f4f8095b45e9f7d677550be930d81b4407aae2b77917275ff25a773920ad0e343cc45ddaedfb45e1e8029c80d1bc0992d53a88a2ccf5bbc82bb388ccca37b1cb1c93032143961ed7b5f6c016211d2ccce005c8c6c32834ba69870759b6e8e40c6e4ffb033b898430f069067469acd5a8c4868316ee44016238a8582deb1cec0ef8b617b36a1ddcc5e79e4eb88f2ca303923455892f1531f065c5e80a76b9e0c133c25c12b31bad0e0aa7cffc17d5926c7879b80625bc397d4121eb151481afb5982a2a9f707b30d234c0c8f88b5f43c7cd68f9db799655dc663d6248f2b0d8bea87be6ea9288706b1e6a2943d77c39d9b2a0407a2ce5031f2ca80c3fa3014d441a0ab6716482cb30edc88463b63a454ccc8c9b20116be0eced12310d377cc4606e078f2099ed91cc30658121b1459470be0086f7890e94bd022305b78b8fa86d79864b3d66e7aad3022e81e4d0c1f6161c62b79be6a0b6a62584b9aac949e4d97a658f2ee6f24b35923c5e4d554ded4d414a5ebb33a267d3f0282a9e118641d1f297d9ca2b57ffa01613e119f72b5b96bb4183545d66d9112ef122f00c32205829bda6d5cea2dbeb9698c26d36bf9c2089d7d6ea4e30457fb30d79ab3a69d39a6d8675ac6405294ee1cb459cf88821e1b9d26834874b930758b47e9e7d5cdb1d32240871ad8e81c2701fbb3fe11c87f2d04246b829e3abbe07dcf406cf8cd614b874f40090bdcae12f8f8712f77c51582a4ffa6ac6e22e568d6cd4d15be2e01c97635a9a2031ed1c32d5b6ff07722370ee0045c7e9edf0a67fc20430fd81ac9ba49d30715963d1226b5ed7afe733eaf28171b93ea17beecf848bd750c801eddd0e75e30de1c1cdec881e782e34acbbd4adbb497c428e226ceb48eb59e3ab47ee747f882c97a31f0091dfa700fa2ddae9397068a327af53187f9034b4051f779fb7cfde18f2b0b67a3c4bc8cc2c940eaaf37eaf52255e0c0f6ab7fd45ed32cd939eb4588df20f9f8cdc8a7ddd1329758bbfacd93037252fcf6529796faa9453ca34262db872d8fc69f30d044fb8571b7aaf3df8470407f2ffe18e18d6ef1e408284bf4150e81b05b9c6596a48b351d32edfb76ffb80d8d7240cd0e30de1bd35ec2374645d2653c5d19822a9e04e262f4a9bdbae888681b04d698fe091bc4370ada6edba90f0c3896aacd284f390b81ec4d97b56f5321667b6ea110c0fa70242553cce1a0eb68fcea2765a36be8128ccae386f8e6d39f01fba8eb0ccf8b15c1f6af2f6684bce500873e83210e6ad739168270d63490855568b8cb7207518fd86553db762bb64e294876b98a0999ca4f8da1abc0b23768930b32a8322e6ce7e51360d859b8e2bdfa9f9fc9bbbe4b619e92bdf9fe1206cccc1266d57285a9a7b3be9dfa5e1b259cbf98253774b511031776d6feb427cf5bc794e135f353ed5784efc4061cf051ed20d840e37f2b04a53304747e2857f60bad99054ddea7bbc68ea537988dad9874b930255106dc59c6ee4940aa5553514f51e07757ceafe94f6c9f052520f9bd72367339595c54815d1d383197c6dcb5c84ca190ebdc6dc451e27f24ef5eb80ae7a9bfd6632a7aadf9e4e330afd95a413a0ff5f38271e6b4f5e1d633ab4644ec9dda5869c93f2069feb6355ac2bd3d2e3e1f6e405f2e901c721f4f07591130a7f019b00fedfe1122fe3be543ca3ef37e90f59ec0f05a97f4d4a80dd7db4192247bef0aca6711e17e74365fd6836201a856fe67464890e559fc76095ba92bb92a12f81b23215aef1d319b881dadf282e1e47005da96b5689c6c1c4431b9ecb558970de9232d32932e0dff3c9541fd87f5bb4493d8b9afb777e0a0583280c0670a807ce5f2866336050b66bb6f7e3841b90e16b209e685b609664a298b8ec7a3128bed383f5d552a3204b219f0cac2613f38b635f64d3c5c9498ba3629ecdda518c437265c5441c69f644b8de2c6e562eefcdda3d136d4163db7722b56459dcbdf1f924e8b5b7ec937aad10794896d6f849c145def48f729a5889d058e758bcf4782828ca13e0858139010a863ae2dc7856ed6577f18adbe0c14662592163bef59b732118d7214e7597b636df3d8c2e04bf611e8ede7f3fd87ffe85e10757db3f7c86ecf534e4b9c4372e3b737968349026ed5f3b5ace294ae759c0375fce1e6389b487b43b99cadbf64ec5b658a401af45d09d26b3c13de58ca9992c85251a713cede523c4bea651b3470397ce3f45ccfc0ed177f27169a77f7aa4a48d85a1b10c78427324091a74f040519984e81a2d4c5ec7827af29d33632229a0a116c30b9538927f2a6638e39f318ca13ad760fac1d68c17d1dfb6d9432a6269f28f74d4834c9183781380f9f51e85f20b43605ff932fd33d3ccd4b62dee437fb85728f1c246c78a33586bdfb7c9b2a9a5f68afd482c7f0d870153a948a022d7cf8ca530306697f79b33df686c5c82a805ddd447676743f96a6496b296a5c007a37fb2994b62d6738894842d9d31201cc33cb4fadc9ac74d07df518e86ac989149f76be24cc018176bfd16d06b124e07c49c5abdbb155d8a3a8cc2e4dfc5484bba548533dcf27f234e4d470f38cdd45d4b6291f05e821a52d1b899c5667199396244183716a876025edca9a653e0df7e8a630dcaf823115735ddf4a9b0ab7ff96158f8c8a8a7f0d9156acd045a814fbbdd877ea9e9de4fde687d8cc9e307fdbaaca638d948d831f482a1e4da16f826d219e7caf4e149b7659eb855b3f859c95f119fa56b06903b1dd6682a8cb1121f82c6e4ec7909825f2dd7056611adc7fea6180092486c15182ea277f463a5e4caac9e2c79d333a1966a0e8e770d3399a3dc8cdf279832e2ce1c69f0b6af99d7c23a960d970be3d90caed106cbdfbc6696dbac3cdbcd6ebf4b33561d3cb43a6f683bf6eccf6c005b1e9f859b28befed0a5830cdc4d45d743c4d9df1b31f03caf83d8349afad916941262e60a58ad56ea448ab714fde5749acd50e652cf4be6a14d42d4af39162b4630d36875e582be0a8a8916dd9aae9e15830e6ab73b902e76a0af5a057960382a48a81165f7d16dfefff5ce10bdc717b29be1b365cd61fae0b9b9e7a79161f031d73ef2c4b82927065fd41f29cfc227a227782b3b17a5c0828f6f871f8b69bb4afd30366386cb96bea9d86300033df23008ebdac2b5c9fcd557b9b63a6a61ad850266476fb9694647d245a6ad83d5ce9638a331e8a13dbeee554d7a8326c91514252ee69fa1974404b895f63d68f0e7d48d520ee848c80341653f4676c9880ce2729b7a32f3355d50e32bd53b2832c30af8d4050cc73dc9fa9eb7a022d0cf57cace67a81d2687ec1d8466b559d8afd809108dcfc960e0e9684d109469ea5cdcb6bc60214fa6dee583a34588e9a7cb3bfe07503fb5e4faeaec9767310c68d731e77009da906533d52aceead92883ec2dc8d105e6cab2f790a0dc575b361aa204d06a55ef1c55c94fb9ab3974661fa5a5d0fa9a76bbdfd5dd7ffdbbfc1963bd9cc0db6e62b8430e5247c656db00137385ee94877ea95093042a51ec4444345651b8ef0b135c40db0517c1c3d5690166d3f501a38f8248eb9df1fcfa2cd94ded6f8d45f655d7ced273b69c8f25d50d412fe46a2c3d2621698ec8ebbfe0478e43795b93f10ef21049eaf5ff07eb399b08438cad127219bc8ba1a9f5e1129dcb585f803e1f3dd8e90854c74bfa17273cdc4d59e7eace9a2d7e3dfffba80d30d6ed4ee8ef6840026931e38fde070c9845f05f20cce3ba61eff321d119456eccde50240abf2cf287f4ba78d8c05b0c98a3a815554782cd6ff7bd5584c780959dd2953eddc39372d3eadfe20c4e13eec501feba9e30e14ccc718c2e8ff20c981eb742a9b65dc69d0bf85d4162e4f55a7bd3216468f76c81b8c992d359c7f3c29e7a52619bc93bbcd03415f9746a8fedeadd4821c31249764fa996670eebc752aff351857a65ffd6084182dc4e274078061c697d9bf0df0c8ba05f14122d3586ea5138e64ceeea51253cf5d7832367a929cb1fe056714970db69fa098b127f0b488d07d401909ed7fa8897e545a9880835807b0a1ae4186fb0c0114f6b65590ca3f9298e609d1b5b2a518ccb70b58e12544da29d4822593f137887dedb6aab311b08ae3d2a46b62b99295bead5cb1c88fb53084b145aba64a60820fda333958c3aa8051c7d1966c4b6ffe4577163c77e3ba03a49acdcb20be02e31fc05c8a4dbc5e6173ed6f397d96a92f17f9ce7cabaf3f07d67b3d4e76fa9e4d1ec1ae79ed89e83000c6d0d053c72297ef43302fe9d0090fc83facda295a018bfdccabccff9de01d7d0579f39855a5e060f0a32079e26bb7a48c40c4f919c104925e68cd4fe3cc1849fc6c18f3d4188a6dcf5b62ac9c860869f06730b89f6c0183a4a25594e4b9b4c3c0aca2fef7299d1e86f51dc05ce8f25098e52897b744afad9ff05f60b0f1c6d927e2c2f73358f4986029ed4d7b28e98682ec874901ea0acb668f727911862271e57f2c612d717b2d86d46ec18a7e3fbb68e9ac607166420dafb20f9aac1f90e8a2955f53a1bd19b29d9e550c59b20d9f07cc8153bcc3401fbaa60985ecf5e0ddaa19bccf51bc15a51bd40c84025e7df41af4bb20ad24d4d2bd8b46f47ef7533b64b10d51668b853f56dcd5667ce8d1654b3265511d5c1866dfeee7ccfd67d6dd7333d0ae7cd47f5caa23f879754b48cee83f3d73de2be4a1ddfe20d63517daba6a51813f43edb2eab75cf06adcdc6b16e1119f67a703374178dfe87a2178decaa2d761d1225ce380919176c34f527ec5a45c19e2e440348af9e2f092009cddfa0a9d6abf84d1779b2f8e86c7f0710b3c727802ec6ab886a68afb8bfd968394037e8d9465120060a8229382ff2c984eeb545ed80cdeb36db937d6cf8ea3e0f238b1157fe22c52472d379e2024176c6fd1749ca3103bbeb2a014d9b3be17b175a93733e467200b25dc7203eab6010b1b06a10c0a3299fe0b96961cc7f6baf37cfdf7dd022f8e2e92b48f22a1ec7b33e8c1bc9392fd599bd7c27353b52b7eb6ef92f77510246a61cdd4453e1088fbb81a6a31b52b524515d76d24aa54d8bd5bd073bfcbc50932974bfd5bb023ba80058d2fa7a00d39e6f0f59f28fcc976197b4c80817b2386d8ddc32bc4b34b4420476c867ef6f9d49aafacd5ddf23e14800f42eb0750d56a9d3a28ca27afaadaab326028649b56e1c3064e08c0dd217d120b133e3f3e60ffddf45f22b7d2952e6f44b460f749bc8bb46485f83d19ee7d3bd739d5ea81980e8c12cfe85b22981a41580024e5bc5c0355a5865d4d5182b2ad8560f732ee8228e5621e41f83947983255a9aa22b5c5d2bdb592bf89d72c8c4968fd574aa4f18ae74d89eaf896e162395c9a05ccd67af0d1d77c5894f4f2937f169f1c48c78820e6748b48d45e0f65b8e7b8f1524080dd16321a55bcfb4ba4bee63874a62141e91498e7a3548f95bd7e25e1a30e74baf57d7fa4c22a507e53045309a5e0cf414ea0836d52c0f3eef1d1ff68ecde8aac2216d4aa80a1813d7652f1f958e0bad058d6f61d8b54d03347a86f77ffd71a6a39e46a2ccc41d3d421dc3e098f59fe9c2088ea3e46ac5f15fa353f5968d6f65e48b55aafa81e2289d0e7661b297accc1188e3ffbac4cbb4d0109444a51db7ebed941319993efd5f45e18d05cbf64035e08ecfdacc737948526c4937f52916e9be78be239a5a5b79773bf95a1cfd2c609a503a230256e669e7c80961e0166bf141b4a61301bcb7f7402387b93184e48c651fa96930d5702ef8568991e5ab79708d5eb79c192a7663766011cb75d28381b44f9b2869530b33ab9c19a57c82a168fa1b74a2bd642b74381d042982e1545e427116112b040199473df542d9b1610a274ce7c11aa67c2c2886d0aa944ff58c820b45caab8a27b16fe3e020dd93cb026da1b544cdcb1fd44f96930599f782b9a8173fb86d06bbf6a3ffbef24aa34a49c19ff2080de8011c13ce375b667dad4c2b2a1e178ffbb205bc20e2ca3d0e153f68587b445343b50c88a389a143ca014676fa16b5f458177c05ddf2b5c6637a430ab0296432deea4f4baca2311e4a17c36925106e4e73820bb9ec3c485f6a3bd14b2488170ce2c66747e894e49390d9cb438f71ff42021115a8cc322c0b5515af45a63a16f10d925c9b63bfe9f391d688a6b24d0ed75c4c6e62e85986798ed1821e7e61c30298993484dabe0012e6fac0b6ce94486798e128358b619f6ce032acaeb2dfda805d65d5a711afcd81f2f702d299a57ce872a602689aad6e7d18583f968957e4efce12aede03dd59c88b976e6f758adcc7f7ccd1d13e1b6a26b98bb5f888dd4e96631a617c1564bd56251486291b0423f8dbefc70bfaeed06c442d3dac606faffc13cf32cf6dfe224d78d75bca375a41a163b5b3989b9b6486fec212170df113acff10742f837c188207bdd9ec0780e624402305a5175079044b78d0f93ce07696563a8ee7ea7756312a184e1e8f5919a5c66b46bf62d029828190840a1cf4f544533e1aedc65f084c89a681d964558dab09924d8c453c1d415961b83fd6e54c97a9cf2e2fd4e281540883859c992f101eb228fe03f1590e6f50c5c2a5094fe78b9885729357358b71b0314611aedb3f2e919b1b49fa2a7da3fa6bfeaec68aaec36dee2c7de90641e37d7ccb82cd782e87fe5c4066678ba11fe8e451fbe953c4901677140915117a2dab8bd42c5c54c52211e0535bdf15190b5df82e599aa9a97c639c176462ee51a6a8fbb902e17d9ebaccc72e4098d0161593ec0b63b8f23e742035ba1e2e31b123cd5b529eb0141b31e0140298d679b6121e8c37b465ce519c324c2264403863f81cac7549cd0141b0a91eae1556c95e97096be4b48f34b01dc9f68aa3d41a618108ae86ff7656db01b2d07d47dcb4aceda50d6d5ced762ea7d87c6804709349ab1363d31bd75c717c748aa09f8008fe0ca58c6dc926f2abf1908084a43f85ae00da8094306cf6775da1e6016d13f9794b239c7638f9eca7f06b2b65cd0145f4f6c8d352236c928808d67c1c370a913a5a1304c3456ffced69aab54e4c265a78f5a45266bd843dc1af847305122d697f6ceff133ecfe4c10235a30dbda79ae55a2da29f909fead5c64ced388cf78dbecb85274a4b5ab22787fc317a84c12c4f25169cc559fba3800381b83142b24c138c305fb06cdc363ef7133ad65d25343f43f1f747dc8e6ca4202e7a09a5d8d446490128849566b54304bb119fe95326fedc856990b423661d13a03ffef68076bd1ab35c2f61242a225d282f55a97347e26a06449626840537a4e81412aae0e5eec89e402c273fd6cba0a037f67fb7fe73ded24f6ea4df92aa7f7728a3c59a0c7674ca99713aea5dd419a8dfd8c6edb6a0fb96b3c601b56c3fcc9577bd9fdb18163fa5029c962229b848a345cfc9ceffc4b13821b2aa602706585a3f4ed8b8e9cbe33cd0aab28e468c7c376425fdf2484f6fe1d8f37af7251df2f8b097b77d116bc54af243198d2a8d73442155d1f9259401336136a2b711d191c7d0ece29b76e6311ffd3c45eadb820a8709e33243d7a96042699fc6fbd1736cdef7f2550246e50ec6a012b697ab9e25074ac674d3cf4e9453d3950754de1b1c53d6f7a6ae859b3b1ea77c7651a41475943770b1f07b4451a64c761e3afca895accb3b453088ee530600510c869151eba7a9e393b8f99c4f76d1e5bceb12e4e0f2e3bfa8ad3d309b309204a43d974500ed04a01f1b535323dceb2ca27f51b23113c7683c1ccc8b05b9c99c33f5ab106b3b58b43884e16b736cc990e2a37d10a843bd8c8ad03db5baae8754ff6e64000eed271e076cfe6655c21cb1c7c6d8f298a56b2d1fb59f6db60e729305a694de9fca4b18de6134ec0aaf30a1f4760a70290b83872970225420753558e4a72ae03bfac80c81299f688134edcf7bfd7388680208dc9c2a2574f93d3b45191ddef25af6a536dcecf9c78ce27a109ddd255dfd350c7fb21780671618acd592ca71742933cd387422467847c908aa3490fa8c48e26bf16e32466b0ea66f54f958e2e4efa6a17116e8682c8dc349477d48939df7159ec6f7b8afbd4d73161940e31c3351ced4f04a0335d7fb6cbbc4ea298dfdf8096a00ede3751d509d9481da72fd374559238280e461a3df67ef7961f1325c14811451ebf1ae27c0f10414734d5b474a5bb240c11b3fbb1764492444e9537a6187a74b63ecd844545076fffc647036e99342de4aa8092adf2f53b8f90ec4f809d1e858da17fd0b5a74b75f49f71d79d3896a6f77e9f2930f094613dcbb74ba477ae9bfca36c9ba9364b46b9f36903859aa225208e7e7d4d4107475ec3c53d5d365fad7dba6e2cf2743034cb63469c9276e873f357cdbc900c5915f635a0707bfbf729cb16a8d86f932588b611477ddd3196f8b54b0d0ab8f01ae7db8d25e92d09cdb935bd691fbee2d4cf0cfa93b5e18011a1a3ce6c916f7bef2d916295365cd86727794d6fede044df56300e7098bfd61b8ab01bbf3b7cb2613e868d6658fa0ee552bff6915a6f1c9baed9c63b8f1994d2e78e0474db6e7271d4f85e7f95ed8f14fc8a1ae9a81011211c03b52fd8ea4d5348d40b4b983a044ef286ba60f3ca0767b59b6a2b34f9cfb1c852de1c15d226950e3d4b3a6a5a577e0f5991665ca1fef900d24d8439495630817b86dc3b7a2528bd2571f1516437425c2716d434c96134b91e7ef542c7f57c6efe6d895674fd879e89b05c10b1b566fc3b377001f50e03e8f4a1aab0af4e18566db18de4ea5dc9464aeb33ace2a31d041a640b302151fa41a4a25e0935b7f68075ad30a076bc4369c22c6d77cb333102d0c4bd9ea801049b16c944785170a86bb8a2d6a791575678","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
