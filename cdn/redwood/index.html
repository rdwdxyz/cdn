<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e932101136c60219a3f0754dff581fa2824e58c659162aa94acf3c168eb2ee25ac0ae74011a582bbf16bd85f6f4fdd61a0b7b5d5fc716a8a8817a900ae8f104cb408bd0f91dacef358f42a1491b2533d2df28cf9a0365f85ea3b329fabf9dbde1d849e7b70faf3b0bb419abdc166269cdd5e16a88725bf322cb4f3543419f4bcb6ec2e20b8f81b44836ebe7ba1514e1dbb6fb666037eb9e10ccaa285294bf238bdca45072b04c7271b13ef72edb90795b04adfc8f5ce061f7deb1789c4436a117dce099ceba66873b4b51e83aa628f610226015544b7a8f96c8d0e97dd29e193314ac81ef751f7f260db47d40469db7f02eb23ef9ff40137ae812489eac0d549cc51fd37cb4ab2f2118122ccc2693e39048b2700713e20c52ae1268a7e5b0340cd9a0c7befce3a4939bb396976f6777f6736871dac02d3813babb01489dff4c3333677672bf37869905eb73e2128fa1b8373cf6f637d1acfd190a05acb5e9b483b80f1dc846cba8f3e7ca48cf16f9846201ee07b3b71c20984b6d440171600a406fa2c82ec23f7ff383d4ff67441bfbbd35cd591d89858415628b9e79ac0672f74b48b7f2bde41f9687609745fc22be0ff8e505cb0c46fdbc099da25fa9e44156af50e901665d127e72fa6246666753fafbc85777be03ad866a4dc37e21d9fbbdd5e58e310ccc00474fd19b236a73c841936f7766e83014d4be4311e9278584b7c4a473969e2298670bf520b2da8ce755fc02b2c0dcf4a31900aa1211c84e1cb4b17ebe32c749edd35fae90f3382144da271d15e82fb4d7cdc76263816c6c7aaaefaab36ceaf1dba56294dcf310ebd5b6da47048dd8bfa51c00385e807afc06b7553f0413c8ca8142dc6ce7fbe9cd5038bd10fea65cbf7680aabd5637aacdc4a2767c6f96c056547d73ca85354417a4e06b85520c1f18f33c537d9e567fe62d43bd3924d442136699914e9fb14278eb12fc8e6e9a46d629b9c46c71786aed5f7be4d29f188873505c980999ea8576e644ce6133a8022602522d24d70bafe6dcdf054d9c28886462b8653ea3017123fdc16d89c280ad9235f489ca39a537702dc1076fd0ad6263e565a7fa7f03f507556b754ae23b9dbaee810a82040c38c5136a2322b9f403d41378d991b5f130785eaa169af9a9f17314663d1d360c5ac81af111fd3f74dc0657d1a2da5561c973acfd01475848f5c812e3c446236cbc0e387de50c8326b36537500406767adfd8f86bc987d969cd9650684c7e6b832dc9d9f20b4844a307f31040fd14730282669d0492d91bf9b7c509deba292e35fd92566b037be0bb500a4b25081bd373cfa6c313b4145be5d912935f6af2515693a58214c7fb2b2252d3e87424e2b73085fdf7133cd2dc5bf0d936366a90caf11c7fc55b604de7d1c88415d3c6a1916af3acf2b0c05c1273702b5e0449059ca61251f0789328661bdb06e0082b17092bbf59a3ac9a246de61849482d3114a3badbeb6133a9166d4d397512a2f9f5fc9e38a99e2e20fc1f68c05c34176d5727cf481fbf3dbf053c1307eb84d6626045e6702a3804fa51d9271ae82060e6fcbe81ccc3224f02577fd527e0f298b0386f051637b155fd54095d42fc0f78b5ad517d47b389d5272fb02a093ddbb5ce0c8bcb639030a6e6bef042938ecab37c489d4af168ff88758d608d450da83552b7f3de8ed7e40407d09223b8c624100f0b58791b8999dee77663d3bbd491e1a29d656a7f1cf8129e144f73e882a7b40fa6828e0f7d9de7f0f7f01a75809213278fd6a4a28e0c505fb22e15fe665dd0e2a0f537fbd5d301bc84ab100b8ff894a9428bdd8425fa8107636984b3d64dd96c7355821ae86702d48d83d728214124d2d33765ad6c5318c4288cfce4c5cecc52d5d41855f7a0fc73f99697b788b889eb2b39e5af45d57cacc1ca93717944f342d37b7d514a4d7d5d9fc8b7c4b3ad4b11485b51c02083533439f88bbbeb4e2996626f05af1cceae9e9d8cc466268c9b46455c9a51a8a79e93a29ad31db0bbb276ae085e5c4e8131f75b4f0d502d3ddc56c2984d969919c641a02166cb6079fe4a736304452fe6c42d37ff5291f1c07bfa48d280d6caa4ec14242875b5fb73b6630a6deeda601b2d8b6ae4a54cc4d0b5a0a10906bd790703f94dcceab927db0d8c704d0c4671b668ad7619c9bd3f405893a40fdd97a8f69753cce7c184a92b4bea26c68497922848af6f49c1865e586990f6dfe8d3ac51a67a7c9ac284c3d133379a6bb5ca1a1589f4c040dba5e7de5c9459127e79edb3d81511284b930654af5d4b15bdba96de25dc678cef3b3b8e2141a3ca6971633b505e4a2864480be1a0ba937dfebf736fd3b01bce0d8483864a375aa469b3a432be660afc367548fb38603c5fc48b9637e367b54076eab61a4a8e7eaa8018e473df35e2abfa92bb7361ded8e999a16f435c2423a50178ffb531791581ce839d8e33d8b8e6d6a1e3bc5839c616a6b63ae1e07282996ce81535c328c4b0bd56a7ad9c6b285581e13ee4e31ad1eea5ed750da5c7cb01fd550593699d10992c3814578d69f1611c1a45d4a2466c5e7ef316f61985cf13478b9a85dced75d95022bf9324ad1fa89216ff4df28022ed268750128791aad6d3b1b3418b257e63ca3ccf295b46c770f71b2830429ca2f39ae9c366b9c5bf45a2b6cfd2175e8bef97d763e30b7206619bfa46d6b42db8bded8d3d9f1c5f66224fa3a92c3f11a00b7ed53c3dc676ddf464128e3461eeb1534233862fff8745351ba6870786c60af2eaace4d292b4ff9dfa80b800fb3351ad5aacd84c50451f06b850157f3fb9eace27c44ff819aa46e85bbe43f5d274862929b85c169de4edb7377a77d167e44a6250906a318285a0a548c3738f2767a258b91e3ebfc1bf5ed297a0e3fd41d8da26c9a198866f7ead923fd9f3a45b64e8e37d7db3f137cea780ff6e8789452198cf8b64d155bf703dc13c4aa7b7beafe1a9fa298a9c2a276873f3d0e0098fc46cb41a1d9531a6f1f47e2946e3db37ef257019279472daa48465a513fdbdc4d4f0273ba8a08b59c2080b9bd08098eb2c9a67f56dca5522a01395ad42f5e3d78a0d301b05b21f542c70f908860da50c700e7745eb91b0524da25fcd4c28c9859fdfe582dfe37c11ed7d9d8b6fae0686103f9fcfb570ca0fbc115cb8e37aeeaa4570585eeb4ec6798d2c0a92849f164443fa46d9ced59227d20583e1a24253ff40dfb738d6b87cb2ca9b8e150f00f83b3f8c2cd45476afeccf7d0f7de605824c8a3ee297a5e0df363a3b2d11b8becb5ef42708c9919d3717feb9c1b78979f0851ff306918f04b4ea21946da1a67992dcbb7f96ef319f1d1bfa2316b1d1eb52aac44070aa6d601db7ab39b06c803f7fcab7013842addafa3cdc55d7d35e45520edd7d45a04dbdbd935e4834fe9081307240110fc1579887d8fd2f69a98d47f73c08ff10f352bb46977b017bfb2c81e68e18c5add7ad709c69a0cf56e221d83683675ce1c4e6fa5c3de74929b53f97269a3d73e5fdd143396025a87fdc7442cbde9d8f8662454e197f62e949bc14877c405cee9319f890e9923b8a1140976746f6e9b33c40e4be946853817d31f361aac2247d7b9cee4c5c413c8bb5c54355d6f9898ccea1fd2f1ebad6bf1440b233916bf07346ed877d4272bf2bfd5a01ad10444bb95717a77d83039575f8b8129c1e96f3935988b6ee4e19415e88a87539505deb566258e03416288af48431e8159ff8b40a59b9e2e27948f29988c61b330976a100c9c3b0fca907e4f44d4ffe3ce8d8b2e3f698ee842f0802854e923ac55040a584248ddf5d2cea7fce0d3508d1193140f7ab380fb25737d8d07f101c0545e975d10ca4624767f355c91e9e9bf01e5dd2745c1adf443346226fbd185951d5133f198611e2326544cac1d2e5585bda8a6abae4750929cc14aa2bb8b3b5dabf2cbd15c5455c01952c5616b5a52a483b50f8fc6f0ac38cfabf3794f28df4fd3aaf94323f0e207182a81f920f85e28b32ad45af6102d02cf75be1c1801c679183232dd361ba4fe9706739c075354f17e674559b04cdb64437cb00a90caf1ff24da0c1c127919a6e0ec148bf5b23244d75c8bd63ae86d9b62a61b05960585aae8c97d7bc452c118ae60bee0914cf6bcc8004025d0555b3ad46593bce8194ce0126c61029a8fd4f1bedd8f49480b5b378379bf3defa98375de0d221629c9f2456ad7ccb55feb1b5b03f089294413ddc8f0a12cebe529135dec508ed8852bdb3a87d6c0bbd24d254dbbe982f7e6cb632f63508b4431333b60078cfc7b0ec109fd707a1b2f4fe82f526e44b689856969e6c7e1a32f7f5171967a56da273edfdfd3359b36876531ee1fc339ae429e254fe79fb66f73ff44a9fe83af3ad4bd7e93384ba2470a955323031c7fc8f51267751a3673562b55d67f457c9aea1968cf258937fff32267c25b30790b7f53cb3bafe787113036611713f27733ccfbb5b388ae7a405eaf7355f87a26c7a690e0777d568ad4c23bb731e373d723a20d1e954d4982d69f847f8a6160907bcf8d3c258a9d586a458fa21dd3b24af6a10cb455b40e5b1507e00fd017d44e35755b71641847ee269deb9316b01f31a96ea1ff2f48ffe2f44e0e7b72d367fe3428ee80f9494a104c80b6bfae1269cf17a6515837d97a3591bf3b15c1af581664f17087754e51c09e6b40b4b2e5aa999e2cbf2a494631e1973846e6a635a5813209155d2c7614b1e806e1015209bf36771404078867e33ca491def1d27efd0c1ae264ad535bf4e4764c2808ab6ac5645c6938f0e180fa0c148d87b11c5b1b722048d3b9355b86931d84831634df41088ba08c8f93f0aa151d5f70ffded618c8a038c908ac8236be60b7aae71796d6322f8d83b0a5abe8e778610ab18e3e6f8db1a1ee41a135c044fadfe8b9d8d462c8ad1642702e759b16ea75cd9593a94543e8b363600a135fcdb8dce770d83073a284949b65493e4ca061acbcfdd3ff3c767b7709286c8ef73892e2dc68928bbe15d428fee54a6123400be5a31bf982711cbf582ebd31f0406459a400a96e03e0bb10b3650f24bfc383a5bbdaae6a8639e4213ad7ea4d81b2ac23d35ef77b2491b975b81f3e57c9bf84af66b09cd80133e83f0fc088a81396dbeee88bb8641ace2fdd124b1f0d234d47efdce58fcc01b14df3789f1f9873e33a6b25acbc65abe841f110a10bcf9b16a4255660b6ae4365bbd5e07ffda855296e8798a66a5c85726d2b70d63ae9b9f03539ec9ce4a945789f2bf9e8673e497af0da9dd08ea2ac49f3b85eead26017217cb9db71054656f7ac3096617f022fa445a01a94be48c8f40151fcc323146554c587281702883d7fad1cf35d0a65f5b78e12808a75c85dc39bf5d3cfc3cdd0e9958f2277206c1944c2e18def521bad2dd9f9045483fcc96d4e72dac431150b706bb32bb9675d8a537ab592208921a4310ecf9acbcfa72a5b1e1e5a1ef222d29b7bac7724936ede4a82be7b48000d5473af8b75f214a6c44abd76075743ddd723a032233a09e2d7fd4103402f3448d62d7045d6b0507ccc70bac7e246ed3fa7db670f777e066d6e82c4e96e1ac1e374b249ac2cf6bf76a8477d574df044813259889117ca6e4fd903e48780aa4593c4bd8410dda36dcd2ead24da8773cba4086101bce247fb2fc071f05e67425c13b5a137de3455d0334c91c1c13b0d2682d8aa6c801270102d331e8e7f79a5e7dc18f74d63b3119fb1489c94c3a620b792c0d737f62cc22762975b33e3af05365bdad25a9b6bbaaf4e6fd266470d289f07ee0d9c2a995fab03097b0a5ab48384b7ea80cba176bc56638b768b941d947c55901505b741dbc368c8952466ceeb1baf5d6602750667ad4c4191617404bef9dc9be6b2517b9fdf88e21c57b1ca7afea7ab2e2e7a25da517f69b61e277919e698e4b30fde4f3841bba218d2d9c800df20c49bd9f40120e24c8813532f9223ff89e608eaaf360c7b4715a187212e466da3860806b45693b8d108889b949d7d02be533bc7c974d792b487e22ee35b99d51587f5e045c6351df939ecb73c749b9823627c4c7d1a615143b89bcb4c7203326453a7bfc945aab850782b9055351bd4d64876bfa0ed97ffad5f14b4efc465d98e86110e150802e2759d1f2d1a718b21ebe008efad3ae96860958cdb801233d60dd588ff2a6aa3d6984203f73f2709572177a1caa4f587c4943ac198f23b6f7cb5c1caf1f2189db96db64c684e9c11eed7d9ad09498848582569b353da7fbdcd8ccc59923080974758873ebb6a6633abc2a2caa079ffbc99cb2180551c6eda48fba3953b5b7bb1d4115de059f73f79fa96ec8cfa625ec43e94cad99f7052ea27f25445d154339fbf7175a59b30667d5d5f54bc2f3d838bcec9379d191454c3ceaf9c491350827163b3c4732ffff0cb331a5ec5dcf511da7bc69e16b967c25b88d5a47faa73a959161185563fe7b117145862e64b8c15638f4a684421d937d15b87370578df443676e7b750a3c80c14b3e354c019a990f32490940cf78e1dee2a55e9290785d094ced5f1d3a99922a4c3bd05af33cbe2b87c18a062b14303f23427a3d27b31d7141fbe41445cd7921848e4387b617c5db9930b5799dad5ebe5ab5b30704f9fdbc59f2dd387874c5d37e9a4c1affc1bc5ec97a13e72e837c50f087da20265cbbcf099d3259aac72f7c82b8eb7f93850a09c8a9001c1b93210962a96881e1b7b11a74a562105fbfbac602e054e98363edad2b8a3870a49b9e99334a95b8d2104701bb07c2c2d4dabf8e3d7c6ce81a9c7a13a022d385e21c045c691178acfb6188bccf6b62768bc2e02677b0efe233c22b4ed8134cee4784f1698dcf71234a40d8c8ba150241c7d67bcae65a035b923d3d4bf86ada666561045e303a0725a779ef2920a353848e1100cd99d7427fe36d8133830e4f3486602fdc5f5ca0f0854a85bc58a0d64f0766bd106aeb3b9eb99f19288b6104e3b33b65c94ad0ebf3ca176055946f57dfbb6e1a40616cbe69ba8fa06af162443c7e3a9b1f65f9e87daa3d8048fa35778c6f5bf5ae4a051c287df4a59209043ffb84acb962729bf404bf378b99a83cd7733297228e554ecaee47db71e23349c45c7ff9c256428c9a71b4da51d7aa8b04a70b540594d145201f262240ae9dbcd370afceb0524fb8a6e6145bc734468837fe9b6bc8c4de907c53ab35b00742a13b5675867dd7ed622aa5b763cb37aefe9414028f72ad3d2d5cb0af885004b066323168bc142033736969182a0b4ad6cadf9ffa9fa7972c19fe0e93270f477d54ac9f373b404cf42d28ed5c33ee946bd74031e53a5b21783dc5d30e1debc4cf8d477aa3deb25a5fb6b87929f0ffba47b4580d24fa322774c49143b42de4e5a95f7e0b2091ce6a5d8a868b4af31de5d2307439716d9b514cf2143789498dd42f3156ecfc37b06772d5b75fe33bda416b5a1699cf11f3a06c8f995d78fbaf20e45dd251f85be71b501bf737163a569dd4b6bc1d612bc8661fabed7eabdca3c0ad425a81999126e4e309ebcde974681bc41e7e0aeaf98cc0b885ccc3376158c45f7df228e2b464ef0aeba9099f4e4da323acd36384c8757cd72ced2498df62cc8640899381dd5c27772ad8c5709c9d3d17822974f9526ed1f18a321c9f1e0d2ac4dbb59641992b3fa2fe87f23e07984d90e73f432a1e13f25a72616f93c1f4d708a44c46493fe0053825b77da3cc65c7bd5d02be13f796ef9d32de473ed1ef76973d642626c3ce76cf610c37fc546d1a217872ff6676f063c417aaf5228563b789c8ae5c5b0ab83ded468e4d4f9f565e7b361e81880d178f683bd94221807ba8cbddf059df0fc12f04020c1880fc615ac4a93b19404584764baced33ae74567c11057893b4aaa2f4ef0f7fdaae53eff9d097a691e76ecf855556d4238d36228445eae89a474186d16cf5503bc0a93d7ea5669c6b683ab2f5ebe396576592f96a44f4fd06c7f0b01cadec0282c988612c807be22f9a77f046f4de93f45d43dd5834c1a5bf15268182794469bd333a2db2e7f0d25fd762b8e12e46ab257f010a255329d08c0c5ba003b28c7d3ce0bbaa542deef6c0bdf8b3727f4ecb70f24b7c9bf3c2e597d879bcf1e282389adf5f68157f1ab715177f3c3846ee9a9338996abf88f178f835055687438ada4cf73f979eb2ee4192f60436669e9e642dfefded4ff4446f14dd68fd7d9d2f5dd708537a5a7b861e8cd5a7606062651b01295dfc51b63f4e29f7daf85d0ccad11a34b81cb2bafe20bb8a8bf513477f6c5db2d68b5f0a34ab5712fd5b2f7faeda6dd6944d645b4eb33a5bc9156837dfe9c5dd37a9dd6fa7519ccc81984fb639de2d930a10a8b17226360b9fc2e828aee64264106abcf186ad8457367f44c77acd2f38f434079d7216c258fbd0c3246c922d8e0e143383708cea417e33e1422a145322f141d06ef7d5b0cab1e5352929d53dfe2cd19964d8f72743999d149b206e5b2ff507cfa25d31a16bd8faddff83ac6f265708125acb4ce4683ccaf507bc144bd1f496aabdd9c5f2bf39c550b692936bef077734c579e315dd9ab7f7e5288abe90d1529cc12b1104f24f3fd0f9baf43ad79071ed331cc2c063b9154cb4c805815f1068fd30e3c94b0c66b7d6372fdd90c6eda5c381885b39a26addc127fcf1c6122505b3c9d98512ec920232c4551b7863bef0bce96c0635bfb3b1b90ccb44b4eb827bccf62cc1609f78d89855f31f99e799aa2727cc264839b74294270fed6db6463cd38a5514751c6324e59d1546d6eae58d959c04ebd8c3226fa2c5fa12c87aba5fb992afdda756813cbe40c99f45480d0294fb9f9fc385f329a6ee1c4d5a9e222472bad54cb259947ac4b37d6139d34e99bf27fc7f4368d1fa1d19c1607a146a3bfc153d14f9b2585a4cbef2be3221cae7a919c8d2fee97f4759de51507fce1378a0dc7d20ac765ae50c4675a2f77e31ccdbaec7262f6e7e3a629f4f7697620fe01ce345863ceb120c0a788c9c9e95e9488f255258e1a988a0d9046ae2751efab863e8c963bb61d8d9c3a0db28a30f1982fd0ca44ae314fdab3e5f89779194a3cae024996f352d703da8f420da6fd07f232b7388cdf5fe9fe207fe7f27e47598bf28b727dc3604c22e046295a8bf321631d4cb4eb9552dd69aeb8a5002f00d9c4f8f7da7cabc771eff7e9198800477e9f2d4ba293eff301e76d58af7879900efbfe2cdaf9499e3f84516a043c44a34b776e20f22b373d2a64fbd15361d3e9ffe45a4c097e9666a73cd31e4988b8062bc7c99a91daa1b671d80958cc50f215db3770b95a2218f58a49b235c8701750b3231df6c6adcfcae2fd53483b66a17d30146aa937268a6944e5c2f8287b7ad6e6c54498b9b1249318bffa6184b01e117093112b0c8b7d825ea68173a6ac44977a9e0aea6c224fc72a61ae74843bfaf6a45c0cbdc51842ca624fc57414e60f00798827ad5ca9e6205477e58c3fdaa01382749f7e9b841a0314ef1bfd19553acdd8f35c317790f1e877295dc93ec4247e97dfc33b16d4380c2588f26a2cce627f77f7e86d9b1fd72334c945fa72794d9c739126b0609f26b59330f819cce7203039a91f771662fd4caf3c5360d7f246805194e99a797594ce1541650c362ea43325385c6d52b667f739c4d60eba280bd86df5c63153c19ed4285e965d6ba9b17545f182efec004a4f921626e467eb1bc79f10a4c2dc38f65544126e53d0eb42b221f3682b90ea17a62932d8ef8f46dfd4536bbdf227df49afbf8a6bc4722298cd371f7752ad57422d10b049776075fe8e195d523590d669112b06c2ab74e35473a72c959d12288fb81b255ad2fd934dd61f08c58641003b2b8d27635ff63097181ccf64c6632d8a5e90471101da75cf63a3a78c4f0b7d4d84bc2be5f586575f3ffecc334c9aeb725664e324e6c4a6319082ec3bffb81a83c663caeef8dac0bde240fb3fa6b0ad34502340f03ceabc41eacbf3f153132f4b6d3e9a4ad06c2b8e5c8e888bf54a7532d33d5b42854188a3270cbed9415b22b9bd3f5b7180b74d8f00d512a55d0457eeb4375914f2fcd4d9eab725aefaaa17fa2c5050280c8009266c954b4a8e107dd36654b50cad352065b786dc2b774e4bf0514549c6f46dbac5c9e49a9adf2bdb86d5dd4058180bc43cca464bed12556741f5e79f812766f7822803efb44c4421b6147cd289369470ee50ebd83ff618c9a9d7b840887b846c79494f2fb88ad628772b2214927496b275a7ed8723cca401e9daa51be0a2d96a5a50bd0e1a29861a191b5caa660131e137f308e25c0b2e28da143a0c45c05082481770b932f6685b91ee8ed4d581076d4965658526a4afa8f0bf3cc4889dbd9ede9cfa3cc6a7bf1a8ee913dced5aba14969cfce549ed65da0a634b127b6ec72a11227088f3b954bf11f48cdc5b38aefbc3f9fcd7684ac0c2f0c42242ae3a26c90beba920433542544009a771cd2625e33f5051ad868ac3dc9290e68db5d582041fdc05ceb1903d8d7910d5b447908636b9d97ab52c28bebe4888cdebd517e40b421bea3d237afac4578ddb7f046203a34e2c55bb1267f4d987e42554821cc924ea1bc1379cc3e2ad7eb3fb3b76a1a5a8b0ddbc73633ba6694af024d075734847f68b7586fbbb8f10fbae4744acd817695bac4d30004f97c5c01e9604b3818567a1cc86d28cbecc90e8f720b24f3cf76d5187517a85864df22bd63d2bac233eea1882ef35c40b09bf3c0b66707a7c6a239090ee2b694df985046b829b4a2dfaca431f10c710b88c9f59aea686d4554fd0b1ac0b1c1acd69252f838ae35bdf70dd1e841f221de9ab7388047edff3c5143c308461a55f57ce272c548bc854ab7abb7fbf018ad6c48bf44ae418f769b920ca1e148b904e10c64310450beb5bfe2c1afdca96877df5740ab190509225dc796ff75f114c173e0418caf27b146f0ad14f80064ee445596eb94503cd990abd3fdfefc50272047d7548e3e0b16538366028a62fb6a490d5ad65ea3e29e4dc6e285ccb7266ee10ad6ec9799bc28726ebb4a8298fcb68c975653f3ea54e64c3aa3d3857aa7e3dcdeb447f119f1e427d561a5e82e8f6ed11d69d32276f4a174ed5ae51e12d70a3759f0f704f96734027fcc3bacc703ab38766c6116c126ec6866a8ec6b486c80e971a219c772a75e00523e6c2433dee670e513c87dbe8821c873c9457e5bb885816a0f19a44d84b534f978ad69cf28e855ffb7496ad2ef304d67e2d64a3bc754b0bd9817963165d2a8d3f8fcd0b97f451c0fbda6a5fb90537222852c6f118c1d9d50b0aad67e3ac9a2f9c67afbc9861b1e4b17632b6d7a69f0fb1acd6c4e63f7a7c04b24f38b3d1e86006c6a450ffff126ba02d91a15d02df4a7b41b6eac664cb8e6a59626dae756ed2e804e2acc3006ef081a3091cb304908221b248a929d45efbd3094f4c91124501b626a887e2ebdfef201c2b728a0bd89162c41e0e90d3a42535874ed3a3254d784a43e989cdf74a5105580267af50d4e5a0eab1aa2a7d9c90b2457e1836b7f5fc7566be44c05095dea870dd0e00b998edc7ecc58d37c4fac6f071918292aff5786d7655823e6b36efd5966ae0fa33d0df5fa460898b5cc13b339515e8dc2adb0639cfce5bf30ce3e37b2b6e9916df733d4aadf6983881deeb991fa83c6adace509e20ce8744f0546e5d19c8781cf4323bb51b5831550f40ebd8c6ded1137ce0c6129e7d235554af6d75cc47ba06059cc4a6c22fcf787ee06397d2e09950bbff8cb7e478347472a0fb7b776f131a0e4f6b07767f47c9a797de937cb70ee702bffe418dfd3cf393eaeaed0c80b3978d6cbc4c2bf0c4b931adbde8969ea922b7aea5828e36974d1e7ff7d78a7c262df4149750bc51ff661180fccf55b77167d8791e67fbb71b99b70c5c017b5d169c24c168034459b23b39d6f29c17efacf2d56555ec33b6ec52d1ace903e26284c9ffc83807fd95b194c4ee562deb617f4c5094023702c883179b69b468b2455fb24cd59daa57b43983eb011bdc59dac16b0aa4a08f05bdd35f77b602844fcdaa68f23b51db34aa3e7bba35ac90a26286560a344b3cdfe04764115ea75eff7d16700c3adb2bafa2b26fc86089121ee891254674de07fa43b0d193e24e6389782454c0b4b42a609010727cdc4f987a7d0a659ea496c969d8fdb4111f033e856d1218ca6f7e93932884d189741ae0309ca0736fd2e590ad7fa17ca548a4a5e93371319a2de9387d4d196d2ecd7841148fb2eabd7b0b231938be55bc208ad18f8cbfdb8cba1db0f47cbc15cf47109c528b988de50bf9aeffd0cb2c9d8d78fddc91f447cffccb0949ae7446dfd1a32ffd4bde9cbe979371f2dfb975c8b1a74b6705e543438d934c38db93e67c1eb85707c63266399bfe58fac8e4557b6172f8b20911b67fdb03f1a90088a3ec105b29a71cf4778601a0f3a215e28cd9d19933f3b92c310ccf8870570932e437b411e9c91709e49d5d2668542b5fee5739161841b5298b3c19ff16ce4bd6d056e4b5dadbed9c09fa2c7bad759f392426388306829c61afde68e2e9431344bd248c50f4dd9052353aed07ee8f17a43aa6a0345681979aafd7c83fb78c4aeefb55558b77fe89957e832c7771ff403689739bfd782ae5de096c258fd986789d1ce66efdaaeb49bacc581b1a4a9e2b5e3f8c18fd6c93e91111cb95ab75411371fff6438c212bfdc6c32584ecfdd02d1db5b0abf29bd43f7dd7f6cdf6ca4604aec3fb9cb6c9fc0d2e0edd05f29f98a95109e39235bfe9c3eb06a9c20d1db18b943c5726000d3fdf1d6e6db45b2ed261a1b64a927c3ee90c844a39f0195ecd61c26c7af7b14c01f31fec924438444a7cf0bdbc547dbaceba879afa1e9aaff661684a5ab30bb55cf7e4f817c69c37757996426b1e9bee989b2a0f650b254585b6e595cc10fbb3ca857ccb64d5cd12934cc34eb2f86dd995bb1584369d6677e757ed3b11ea7a8bf62a46bf6342997c19fb786971e90977cd5dfe19d48cd77a263c487c2612c4fe6d00e8247ec70a6a861c8337c34c212e16beef1b9689398fc430dcefc513d4b0fedf27fc898537ab2bbbdd071300b3238dc0261b007c8db251167f27cafc1d63070f74d0793abf0a24d878acef0997bed341b96af9572284e29b9ae6c3eb7f2c39643ecc8af72026e6afb943710e2e37139333373b5049dfe244d3d6a721d77873eb3fabb8b70970a35449812600cab3b52d7bed9e67e615fdf7fd23b64825c59801ee57580f4953b3c4be346e45c5748a18df21454f3296107876785b40c15be5369921085e14402217552abb851592becde69f032e797390823928306b9144636b0766969e0e8848a56955a3ef6f4d39377180f402de4efbb4fd3f8d813c99a8528a0b1a6c47e424d55dc3910b7121c81a7b338429c87a39df9174822ae6913f08defdde23eca0d40b131fa8a9e7ddf0e8bcdaf3538a64d0335b99931bbc999655a5d595e092f54553e8a7c32dbeefd19e5bd7b1f75e22bb281a366da3a48cee84de84765ea724e2e9b12a20a9061fe687b483f5d35018a1bd9946e4da264ac388f0a73426f760248e69cd3e5131c57f9085eee53bf3c335efbd6b648912bbc3e15175263f6a03cd2ba39882c9a9f32114b91150ea7280a6832c0ca61e6fe01e6ea8eebb670615ffb92b11e338b175659798ad91e0c6cba1c820115f6697ffe64be2bcc157746855135d508945fff53cf4540d3a2853ea6494a824d2bfefbbcd5de7b7941b1133c6e01b836fac5c2ca446ce2a8055411dea7d1f75f7113e7e3d6adc27a0343154378f9d5270d7e02312263d006adbb45e02363ce6185bc57a4064ea4dabf91834a8a75e6e1811e519e43dc72ae88ab0f794dd7cd534290edba4d25a3e7210e0db16e48c47ac62b6e7134d2381b49c869135de1a4121c3767c586dfefd4db5e7046a664bcdaf27d4f689347ec8d7fc38d0cbbfab14e0b4ade6f50024e49e0d9c13bcd06c0797df6b7c665eb5a36d54b89b7030d8a7b0ef726d540005b1371bf66f9e25027a341f714560c8c27b423c43a0a4eddece101bb0890ff0a036415dcfdd7c69e0c62d5df00f108c1484c76cfa38f652fbe25bd7a406a734a5503b948857d8c90341c0927ec16e8b89e49ed07cd84f6cd2234c28df37bc3fb080f85daed9015ba9013e33fbf70cdefc8371d63f977476a264e55ada69b3e3780bfe16b28c8ba57b1e0a1fe3e276658b9ab7beb2267654c999741cdb87d40ffb54cf4d7773c6225d22b3da83438f44480b207c851275139da4de1e0dfd9089a35d26a7ec3c0e5592e1de9391aec8eeacc0a458bcdd88653d5a350d68261ee4c2ba2ea82015b68907b2af4f8de6c69b13535b9f46b508764a21ab846bdef483db2759bd7da078ac66a2952e4c0a16bf9aabe1b6485d4739b56aa730444d3c118305635ec4fc799bf3e3c5cc83b60a5dc487b96db44d2f1d5064d05e1e61b7f3aa95b6aebbef09c094d7ca2459424c3804d682581f64ab352eaa80fa96e685250515a3a7b1acbf7c2b2fe15b53bef91b6fd3d0e9105861324d13ee34c03e2bdd59112c889db1967484236dd009a38cbc27ff1c6be41e3d2562720a1ca6a5967be8358a670e74ded3bfa1d0266b79725ef533cdc56b4fab192ca722e5742ba7e5626f71bade1f158026afcaef07e1e475546768d6e59067528a27cb60ef13801a0203798e772ac4cc0aa0b3d211c73fedc8dfad210805b1a1bdcbe3082a2c28b295a258c27c789951b61ccb09d61638e9538207d9f4ea23918ec05d15a98f54d3345436b90e496fdc12b5afaec1edb5706f28389d6fd3c6391c394ffea1076702a6c90fc0cdb4862c46164c8cd7d05a195b6359f8c12471937565bd97d132de7292066d021953736e156103c1a69989b5668a2f75efbace9db5030e5638f8b334f4c5d2ba73b53461a41bd60361282bd58d8710e83c463cb6b1ba92e4475c176c9ba43b47b2d4427c47e91683d355af0060de76c66c066a8bb4c2d97cffeeadbb4c80ed85c1b705f77550330efbde1ef58e72baee2b389eb22d5c368f8c558e49a4a5ea4ca1e99d7392a03d4bebe1c5fa3cbbfa7275b55ad64fc0acd3a355d966ffe6066a70025eae50d1e8256b244b809d48dcf0e279c53b502ec4766388b6133280b5ee2eec94b55b5f291f7523d75c2c5f38fe18d9b414c67dad9ea43d90b455ad672de318efeef2070b929bfbe85bf7cc35899b00eb9bafc103442aa7905298192d71ba37d7608c228eda06525ca25549f8a1d1979a5b673945d595319c72f29f17b404cd62fe18ecea414910065f670a69c52a31292bbe9cdd67d2c57dc2f07805eca8ee3d3bbbe4459d9bd9bbb1a59c26f4944bcc122626070bc0071a9375bbd649e48a4ffe15b7e1159032eece6851609b2f4601b7ca74692a3c7d84bd1f3dc5db0a54ad654ae0e9686421951bb4675a706712797ccb5174e6c437f1bb2df2544757684c7614037267068ebff58356808fb5db78a83cb6da68c8fe3fdd5686daf2a11ccd08bdd67da3cebc26e7488ca8aa8a7013b175a4c0aed4e9d851bd0bbc1a33d44128952239d20f1aed68f8875bddb124cf6ff2aff46239d949034eb90e6d6904631d448499d4fecd6d7f9d988c96a555aca200ef54c5e366b3c968d2ae18f239cedf84d0325da633dc51781eb19de92498cf2bbcb6bbafd7991045e7707e3a06c52ad4008c32453daa4e86e141e923bfb9a5bb563478e3c2f1fcc80ed40a29d76ed598f58aacb990fa31e751f76f2951bd959aad6f7b92bc1ea238784d0af1316e5f96bb0563b4989825639bb36fc6b7fe23784d30b3105437bae88e37208b0afe84dc0d95eb8a38ad529b7fc88300ed1fa401f0a063770952fd1fc7fcf2a25c8e670497901b91eaa23aeef30eae585147e24b07c3eea0f68becd2ad19e740ff4a569f38946e8b6255b2c4665365206416d7645e573fea9909e972efd1382acb42657fc3da2aa0b1f812615e1887bdd5154cce56da2c873ded069705f2b9fbd3269e7cb0613989916255e4e0ddc060937c6b2331776189172cd586f6d4057536135eecfddce3c7aa91f984f15aa1a07cd0b72ff24d9c2b287ceff270cff73554852599ad6ba972cda512f619a48e16729141067e277517781bd38872c6dc2b645baec2845daab744a5c8d4b64e4de3326a59f2294e3f55ced3860e1857bbdf49bdd6bad8a7cb7d923c253377c21c6def44444d7b5527571a8bb9344d20a90109c2af5d347356907f49608bedfe50e09d4c130d549fc34051beee7536a79b17f432a8cbfba8973986fc66b2b4b57a72856e309af6a3c7e4e426d0b046d57afce8ec94838d1e18ce2a5344d899ef726b4950a0b80eedfc8d8d317d2b050fb61b93895b0059ce83887d7268ed98020a0e7d328d4ca1fd826998ecd21181d09868f6fadbf27960fb65667b23cb2724be742b2387e9e36e32e678348e5a7d2210d6e752910771674a057dd6db033e113ef5051087d6d39a47f67bf77ed2541c76d2c75ae058a79ac04ad203bc4cf781b47506a88dca1a8f0b71fa5931d01dda349cad29d7cddac876ca519d2cb66a2c47f69d5136497ccd55a97cfd4f92ec388f3f6c78c7b42843eea8e35eced26142a4d8294497f0858d075e2cd25a3dc893ba161eec56aac29c278c4ac8bfb610c14d2c7c924aaef3af807b01160240b3fb4f7b2cf760ccda0f9889d6f610b8f5225e046e7e84941b387133e2d23ef2b86c139bf99ef739bdb29671da25cb8ea039d9fbf766eb3afd5cfe85a34d1e2a409fd9ceffd335a00766af64c35dd7217a618833f7febced14c092e3df72f1f33b6d4b58baea0be9ef5dce52e002184eb764ca6370237f90dc3f30fc6454373b2d5d312b3ba547b23ea861aa84cb1beb6e685ff80ef16812b9ec7068273a81af79554010d7434052b967d581b1ff139cbacf42764d6530e031aacd8325a595dee4ebc619b4294e2c398a6e4d837f15ff027b38c4e626ef4a28fb1002c5ab25d8a151fc8161fd4d50ed13c5e6fbcba923963d4b00df6283eb307ba52e03353cbee0fc16b3acb44ec2dd0a4fc062c5dd7dbb556d596e74ae85c4d958dfef8d0c6b30bdf3e3938a6e54f5f2719c9d3ab78539f91e4afd46e180b6768ebe94522ee97c8812e0d32a39838f7afac42789f39a888639e1168c41e7033e7a2516b7ad7b8aad1b3ab733653a0ae4ef60be90e9269ed27b1d2f2f8da79767ef4944b27d49eca00a9c9a08ffe450fa3cbedc387ebf05655eb98cd0776496ac71c3683026bbe84900496fef2306ee4378adfd8188d63113288fc94f5b2b09f38e52301415a742f70918841031962befef87dc97dec1a8aaf6e94bdfdc752e0c85a9a8d843646024dc5a4001e5301ac3251620bdffbf1807d70c2e5bd4797e2570f9ddb3d6d4ab7fdec85b4fe7efeb0f829014c5cfeb01d4164980fdc769b9ec522dbc1b5749e2f774625de7cb874a6a3f4ec4f077d2f4df21d33dd929ab2a89a40134f6fb45149b9138e3613fa068caadc0ba65c68ad32b1bb15534bac55b81b61af17574f90806e1c361774e6445feefddbd9d2e065795f178a71a3648a5fe7bd03e74e4ecd9bf87b9fa69d0458dae79c9613b057531782f91156433a9c730e7c71b725578ec71179085a245ef6123601f2ac3e94d1eb6f0f5d539a6d6fe4679c52582008a7e362ad17f5061b5824195214a946e5b607fc2d7dc3709e82d49b14c0dbd255ba37585d050c0516f632e4f86f6a2c242f1961b0c7df88b7d6f1c6435129766a27fba1035fb1bd7980ea016b21a1b26e76909157536541dd2aa9b5404614cad0d0ce3318ddded0037a6c36f8f759e0fc9307991b665ba9f4f182cbc405dcb55f0b475c0aa3c7c2b5a6df8e5711ed8a083367ca826023a75f5108f556076c88cbda22ac39ff6e9feca43bd83e9ee7db789deece56ca6faad585b458fe04efb5ba73307c5bad0e10e18eb97f7aa04929681f367b4c402874b3aa4903c9fce6fc75f70528e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
