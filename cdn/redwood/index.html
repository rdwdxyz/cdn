<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca0cc772f56e536c648d885d4126843b0a71ba8c4f955b59596823813bceb668e79d27843612ec94b025bed6196533af32576cb11e4d0379d34b8823168f5a1f0dbf04e97b896ae347585343dc633d1c7043dc9a625e99a4e03ca757277778c4f9832367f52497b6aa5f9c62022c2231bd70dacd853ace0751b983144427dde8f0ab12c18385c0c359fbca027b5ae61b1a1046df35d927a118f71222a71c13d3bd6d669b4b0f99c3852fcb2409fafe8fbd0b00976d950d6c6e79ecb232d1697574673e074b00b5302951ed5754c3349b64db75d00da492b66356fdc5055d3e64262e6022c9a51383a966e03311f7e16df272786d66682c419ef0ecfb0a906adec4f48e3f9f6f567444f0f459d22e70d49358d3079aacb4a4913fb2602061e0c4e5407e5f955a313d79061b3f9851908a0c658d0afa1dcfe2ce5cbd0d70531c33f8cf81ce5b11fd8998e9fbe3d52a1a628a358f115d934a19d80090f92b846afb85de9100717104f676d588466db5629189f46988bb6c3d623bb5f30249dcf19a85683bb47cd5b4792eb204ae14274e88754e4c1ec324f436635d9d7f697920306f1715fe5fd0df0e3fa30debca4fefe448856f35d344c54735438e4eb05165d5d7d1892a9835d828cca59d7d927e4b92f162495dfaa30e90e2e3befad11cd03cf1c56edf1d11a3cb1d45db39794729c61e2c4c370c7f4fa7666a4eb4a36ed1dd4bb0f8c408126da270ad2d04264da7e89479fca376fda53404f6231e5b58264354f2d263c04d13e1680c92185971ff0c0080c88b37e7fc71b2207f379d41c69f918b27aed462acf3a20b34328897978199478808b8ee7d51e6c8818f6a21c7beb7973bff23ed642f57d37e0d89aa42069e1985ea058df81ad1c74406b16c357f41a6a312f0562d3b81f4b7af5b921b7c9a82e999dc803c00bfac287494cb434c0c2829bb8c9531ec900fc7c1d1e2ab187321144160e8668169eed6ef4eb55a96caa0c79def11f4821814e9399bee263e7a39b350ce781d4a8d29f7221e6ec438133bcb3b200e7f9c7d9b70e20a1f70f9ab1fdca9cf4df62e1942798149cd9b8901b09316156abf057f506ee417a18b9adc926ffa6be1bb149e5f43ced190851341deeb643cb3a5f7ed3bc80e699f55a6983dfc850728607b2e9f94d73c8175fc04482789e02df5d2d04a163b052cfb55f04279f1b57b036610a4b1a88b3c6a5c3533950b0455b217471001ddd1b87549fade6c869df7f2b1096598656a79e4ad7e0ea8b47d01fcbe9a5ffe4f18e75428683e6a4451a3333a5bf7dea68f51d8a64f7317a8b4743040033363f89752b33082a0ca2748df300208ac91991e34299f996093a94017dc86076848dfac130fcfbb54279c090165c9e90a4c50cc5a945859dcf9da96aa6d0494f919c83d384b4e5d57ba02d471026f2b8c638031c865932379a7c49da86d68bd58aaf7ead10554fcb545e28669d3780245b03440f5878940dcf599a26e0b6d4fc37fe9bf35befe67df69948f04654c2dc89ddb2ae0f7791cec7a66aa780c6d775b66f655c3a279b180b0cd9a789ce7723407bec8ebbf91117e25f52617f7d82ba18dfee8fc5e210f6ea3519803cf8733f852da00c1fe9e4955ad7b354938188a961ed1a98761ad208fd72cbe308871bcff41efef05d933a5392bcc1c883554bbf5699b986f53ec69ba5ae672405ad85253e17ff3df38470cccd45d1d7465e1e85f6a09e4c42d5aff7f156f8879ea4df917d6ab9b8afc5adf1ef96013690bcb6aace7b2a66db01bc17877b25f34ee04a68f920de81b96620ffaf99a4cb3f3071262c803a38285975f13a233a6808a28df4b6f527b730c80545e2af629705f420d84f1fc85731278554d17d15c59c2507c39b94e8859bcb565785fd0fdaa337e472bdd39c19e88ce59cb1e41bd0a02e198e6c0428776ee7f2890ab637e79281e3e8f862a0456956fed5ffd49d8cae5580e4426c923ced54cd48c8803ff487c1e01b76dfd08b5eb66dc4ec32162011ba13ec0a87dd6cd45fa0c22bde4e6eacc492a2be0f07597c56d10b5c99a77c6428235dcc74d7248043dc3daf990837c313e46ca814c691143387c258ee60bf6b9ff3bc05b9e6d79ced58d4a4309eab13186b4c6ff660e3418cee8862f738e07f38a2d84156c4b7f849bd37fc448b5716194920e2378a8cc2e23d7a45dedd7bd9f2400fc26877380685645eec2f50662915070389ab312e638cd9b2c505a58a710da3ac8ac3c3ef742bddb8cec74317c39bd1e91ef4600d4fab15a9ac2b1eff39a338be840d62ca8298d6b4f3212c45517176dda60019b9930a0dc112afe3c66bf7a7e91ea2ed67f07d78c3b6e790ea59a9faccc09b4012fec3cab5dd67f9b6d4eda2a9efb4ba8ee229b2d1e061fbe88e6c526ab617a8d453de53d70a8636bc956cc3998c6995c0f6a31828a4f87f953b63b47da9125f2411251c5ec2d5bab90d4d7172afe79e3907351a7113d068cb5f46c7c7755438707932337e52068dcc856925471ec6de8308ee8e6d2b1ae4e6589e51c2de1b78f2f5b41a3a518ce701824b3d43498ab12bf8c442ddb6457e5ab2a80011054a97f446ed0ceef71c017dcb39600819816e81ade26addf1c412219b62c67b0e353fdb3a1bec3899c6441f259dbb5583c535d37047654d30ca0297dff3330b72c4a675f7a15fccc850ac098ac10ff924fa092436961765f809e65f763b4a6cd6a4866a87cdcd86388566938cfbf541be65f2aa0449a3fff7cbcfa246abcb7206c5d2f697385c974aa672e025085ff771bda04f3c54cee913a71161a23ad85bb738809dc6c1042be14d48dd03dadd7362c17d5a038c5241e6746130426baf91194d71dce9f0228f908e17c593c8c9ae488ad594197e5aaec35c22ace7b09c59a697217dfe1db6778c89be59ca000e13d196a1aebecd52d148d8b5ea834af897b706c7557d09e35d4887c4d3173faa14b6651ad065ec9fde8aa14b1016e9bd048d846520256fe307198528a3a9942e8ccf68a1f3e98545ccbee0d55777963a4a4dbc5523e781c9e8f2a828e8969ff7ea6b97479800e7800baa01ddf9dbc824afb16ee3d303e389c7cdb9ba89ed253dfa7972cc742df1363d413d1e350206af48b027068485a30b73548f41f65b268414254bbec6b463980b74c15d7ed3b7bc95740ab7a631766416779cf47fa6ed9ba553cdb6501e796b94a884566cd1df34d902d4424c1eead63d7b7bae6b6c079d1fd8f3f39c2085fe728a8be67beff2e4e8075bf6be6b2470b64d4442eceaaf38f4c89fa8eff0449a1d0ececb36850033fab80ab555660421ac894bc73122fb865abadd96a45e6ef419d30815a3963b0105b0e04aac20656035d19084add16b9750a707b8d8ea83a9dacf208b3a0aff9e0439f79603d89949e52e5cf242a5d9314ee07537dbeac7c8ff279218d86d423d5b900ae27d153a6be47843e69fa41b661ed2c6f9502688006962c4453ea240cb34ce77f2cf0834aa9a0021d5d66df8d215cff2632ec5a6a4f97e03b03dfe490d65a6530f2cd8b0544decc0ea09627738969e5787237ba292f78d2f3371e6fe3fc8c5042be8de6bb17decc6c6e25deb62b658e970a8307fbad9281023dae22b10708cd46202576366918288b0d9c589449cce7f250b086a4f108518815de133ce9bd12aa8daed3a335ff121dc79110916e6bad099f2b51b453ec8228a1bd0093180e5ba2eb6478d7d40f320cde311ca62294c119b5902ca92abaecbfa74c95aecc6f15113db9f5e05565cf306ca3b1ea3aac625ff4927145c7e1d7567e678b53a4b6051f43edb1928f6222fae86e5ccd53d5bc96884c929aa18a618848883c322f7e1f0568650d51a9f5eb60b5c3115777ec3f1a7157f56b5c76a434127ccdec082e21594c23e71b5c4028d631e954d0263f9ace1d11ccf8993851f18443549c30630b92f8e1811434342b2d31996b5ea51443eb377f0f0206c8be64d80569ca08b3649a37be60f28377b6081c74eedf680aed7b022ff021e92b993ffba96bd26837a2516935187574229591cfe23e1ac3db401bd52e4315343875a0d05a68b1c9f36c7d548b545538f09e35a4936e84ef4cabb9e798e02b3252dbe8a4c9f348e078479ccdb7faa36854d17140b581c24a4367d7e7731304e043e244af215c2db10fe7710f51fa248cde8646c87c65d541cc7c4654f66823c2867353f4c7d892870efca51c055fb8ba1abde4e07c157efcea5ab4bc0466736655b64c36cdfea14d00e607a240ee04a02402fc8733601c2436e0d2c35da80c4eb67fa2f8255a333a80d3d442f1138973bf55697231d43266d939182c808a69a889d2ff8607b0d44ae0fed806dc99ab096d5fd7f5401d5d46be3c437f0c074c65977b02b99d1acb93542d05d9c9f6d4be2e9646f1c65382d929dc4b464463da6cb7ab9fb7cfe914c137e12457a462043226026d434ef3bc3b55ff7305839e4bfb4ba71cd1f843857f64caa4f138184238663302c2722da0b0590d316a105f52c6048bd2f604875308b04b3cf60f5657fb66c99888a4c0c37b7261f7ae690b01cfde54390c27b02da315fae36bd418ea443acd524c819546fcf6da4467784f9223377533037efd956bb4913bf937600fbb0ce8e342f2284b18a61e575e285e5586cd97a95cb18a33a8a8762174d69f6fa457e8f184f81b1e8c9f3d97dabc00ea6190407eb472f0e5c431fc15ffffebb43563d4af700f9bef74b3e92e8880ed30a1cc422b5825a1d4418c336478f048416b2c6899820adf15cc4a222702a49d08e2153f7d12ca10a9fe01ce5c4717233b406d96bb7c42da2b47c0dcb80a05e0c0ddcd25c37f084c2f4024f13542205ba0443a126711ede2b2db523a758a154a9d0fa9c1bbe189e6cd6a9f51a3cd5519cc53545e86b479d86abd87a4ec3a63d01bc3d6ce41100c9c3fc03066b0bf880e38e7ff9172f260e55cc82418655ce86c81ef5366f0dffb5beaf4e83a01c1446004b817b222370c5ddd116e83ad7452e2bcd4b0f57c4377fd013371548d978c72e0f0208f73dfc7637573482a0035fb2641a4db73c1e10df32a8cd7a4f5c2284008e3051cb4fd3c2a9cc9fd1a2ba10b6110f5bbb15657a3dcce44be3b3dd144d2d23d7890118e23562d0d020a37fe502549e396e0880c3b086013825296cb2088fd17a9ee23a90c7025575b8ec675be2180b5a3fd879662940319092b42e16fef6e4397263e8c787c52bcebb3ee0241e298472b9b2d3b4d1f693807ec6721cf0a431abdce053281c61b9c96a1a1ee34f5db38d23bbc54cadee05f73497a52d834d6e024a29d09fd677504975ecac4b13dc2fb19cf3b1f5b697cb9b31ff92891108f348030556fb3050bcd59ce02a2adf438b5d0ba374bac782b4a779bf92b1cb7d743aaa6e371a728feacdef31a7faf48a98df8caaf6a517019567c2cb2bf0d651ddb7c9a5bd74940829fde2269d97c22170b1a6c970723091fc9a62b662f475bbabfd477c8d43db31d8f9b9cceff753747c55225f409f75c70512ab3c75cfba752bb53001a291f5cc3c1bc04b29cb0d628f9b31fc230aa747d5a8afcf7a8c2912af7de598bece379b4dd40425097dd0ece3a9efb40903cbb9d93738652e72e426b6eef801401d6822af630370c00922d2a948f7a1835cbb79536b2eaa2f6c63ea2411390c0d6359c4c646a8f7154150a47062a21d517ead8d74eb7669fe32f89539ffe7ec3b020e8e6d008d44e8bc14204c493b94b011e061b27341a3a4c67beb8444f19c9a1d36a796024db8eb09294a9a4e16edb9fb107b8fbc696f07eac194d1cc8277a9244755f90a3b4ebc9aa6e12526ce044b3ecead52ccc1e4adfe68ed0ce49c882a95b16df93ea84d57b318e19d5bcc4331336ee53e6f7d0c12f1f8364a639779fbe77ea7a3e29fcb1c2df272d8873344fd0136f133dc226b9c3dc57727a381bb696a451e5ecee287250564b7fd909a1373bd336b09805fd8dbee9d375857fb9c3c128c590756ded0e7cb68ef89223f30fe1d1852fe0fa7c95980a790b81b186c8b314dfa019259419e0389b7fea130d1a4e277467809ae0481e9a2fc3fefbb657cf522a6661209cae8ae3d90a9eeeeb88dc8fdcf001932e0b7fd8feff89f600971719e056f95449f0a5aa37e041b67c0903fd2077901d274be57b8b652260ae448c80f040d20d9fc5dba5a7359a25d3696dc23625a2e929599a8e74a3be2cafd4a8e856154f00baebf210c51652616a23588696f32966914dc759be65d5f49974135569d52f8ae1f466f049696870f39a46d389d42ceacf1faf762b0362cfa6fb8955dab8b2097d6ac08e18cca78321787e60131f2d7b466d13bd5c9a1642467cb22d2cb5d53d19647bf4e37e40cf8f6d38c80810862fd509f587a38b4400314bab7c0ee789fa9750e669e21857364dde33adfd080f9f57538244a26c228b92aa0d7f20a34912ba5667e8d778a2b79289da7d82f6e05b85013255d39b5eb3775f3bf2a0d4ee020cab35bc070b54e292e9643dfafc9a0d4b30a7773e33f66b36785435e726efdd73cdf3b3e6a6a27eae4139912c2fc85305898768f4d1d610b218469ba49ef9aac7143e16b652be981f62a5695b7142959cc40dd59af9c178994e8735d47a310e491dc8259001e24d98797cebc8a3cc6331183d4e635795091335500a170933bcc4fe03e31791405f6aaaf78b21b827a3ac820eaf7256ab05ca7fecfa2baca1c1cd140318755216f1202bc3bfc056379ad3dbdf2f1253fecb0c31aef67137fcef5157ea5f043c0bfe553889489947e493a718d4fd0d27837cfc2d306af621e9faf96dff960a30c2042a613a016cbc2e4b9886f9e0ca35796eb59ecce2a7c2fdef316fcaa45673d98c99ba344fd75512099fd3ebc0ffd7616b74daeb1c53e261823633183d13fb75225d11e311349c67061bae82127360d366e239c29ec0e4baacc39b3ac446a40c042d9612ff5ca9d712087803847dd75f0cfefc11b92774f6bffb41ac9293a0afb2e33cf0aeca74180afad45c5a0488ef57553fbd8ec144465f961969aad271649ab78a15a9971218a4ba578efdd2ac69df7d0146852b983dcfae79a2e784a57475f0ba20b5ec4f315f1472a3cbb76ce50effeace3fa7f74a6cfff7dcd6a2eecb8a6cb3fb55545fa1a7285cb1263301fc57a11d5c1a37c49f5e7c6a639abd7bc7bb70ebdbdc83112c606c112f783f6aaff68e4df0cfe73dc702410a032f1e29e7890a4f31d91824ec3e283baa9900aacff6adac199a7fd7a1c1bccf97bc3cc4e411899178c5103db11c7e87305125e276b313ff5bb22c798378f725fa98a91fe8d957457fc79a248d64a306ac5a654ccccd86255521b0d2947100ddcbc6386effd45ab6a338ea03606b2f9857549a4ae86d63df7620f1ce3ce89c3e64bd076275a209a7ae1982dc1bb41f5216b46415b891f20739fb665548e4c100090dc4c1ee2fc61b53c758699d7c5f4a0bce66e2f925c2493ddc7a59099cc13f2e3c333599fc2d006082258503b757b76e6c01e90423f230e357e4104e18df326735110e917d1a0242c0bf3220a97630d90e2b32744a85f8076dcfcaa3289a20084d4ab0027f742259155223761cac1ec2a22c490b7b28bd244fd89e6f5d8c2d98bf3374c3c433c287f43746c80201428c91b6cac3c55345ba8f9f51b77931130ee726159f7c7aa34147991a5df45e8c1d8ec681b04865bbab8e40187f2a82b1f16284b5fb4b65cbd89a7a373f36b20e5f041de67a01364538bbee8fff9a80edd0ae34304b210ac80892cc1161f46a1258fc0f62c9906b699c630e71f1cfb0a48523b49f87e45e7d1217b2c5576e8e32bc3d5ec0efee39ba23ba978fb62a67c9708975cf079af56afdcac1d09363576e31fd245ff5b833b64648f78c241ff42ebe4f9dfa5d3c0f9aa73fc2e5aed1902ea52b09e1d92a11d882146a8e476e4b05363e01125c4c88ee80e8387bc5cb6bad45d65bc870c42bb64dedfb58ee1acedc1beb432b2ba0d1fed021e6b2ab7cebc08f659d05afd9a38c89776674a9208deef414b4d6659a99f7e043158a870df7a443e8a235ea78f83cf44fe1c6b8e5d7bd6c048fd34c7f75c3213370b91b373c7e91a35b7a0532cee3dffdb3ade1d68276c76fe9407241bd7cbc9663cc5ab001284e43200f125f34a5e02ec76abdf8978e9783688e47219079359be9ac671b40ddc28c3bfc97b0a04d47182f3bb4054b8abce76330541f950a2a48b8825b85084ee6bc282f0d09bbfe63443ba9fb890d6909db74e68390c71a4ff40fa860a33c871e0fb49f386ac60f311005ac92208c36d77268f7e86ba79af475f23cb09d7f9df53c46f73a2eaf3e74b2b423f678332aa5bb12c5a9727e37269cfa5babddceaabb4e743d2876822f2f09f01b39df211e00b611bb24b8c8234f7f723210c82ab281b207c3eceb37835c32d893a6e0172df82b1a2fc058e2ef42b91901c22369e877aded5cf79e506a7709896c73095bfaedbb522edb9774f7746185b5cb2c55b06c71102f6c62b54db07d011e177f70ea2177db3c1526f8606eb65efcda553531108f5b84eb94db0b88413199735f75bd4e338b9bf010f47738dea54a165a0a9fb14f2bf3993aafac752e0d10deba460e7f0f572517ea530712483b9c7a72c661602a2f044b2fc0f2579a6fa416166b70f52e29558430d3121f204860db56554a94f016af6c563bba9a83821949b53a858a52f0b577ba55199cc0764e420670b49e104b9bf66992c3f37b747d6569a96460c28c31b8c5e0889fd0b11bbff24c6310c09ab38bd7f865383931c86965605651973a2501ef398f93517d452758d3b8c6c0b24b0bee509af5c75eef95bf2177f5592b0324aa63556cb48083bd58e8b4b4c26c2186e8c8af2491001b75c82881ecc60ae2ebc59ba4e92f5232aff89e55c6af14299f90d44536fbb36dfc4083ac2ea78002e0b01ca6a5b089f035f67baca6b219abf3fd23092773dee81fe1909d3177dfbd250f2c118acccfaae4c061ba37b5e12d71e0b3c4b68ad25a86c94971592e3e2e9e4ff24d72231b08d3cf7f3650e460797bd70b7b445e7e190f37288df9b65b9a4a6a3d197dcae0561d2d218332b24f35a93697ad5574ab56966a39707ca0799cd11d378bc88b4e5d3979c6fc0fea41a120dd6a22d5bad34265a752162ba819f20891c07368b0f36abb4fe9344dc58a62b46caede7874dced21a151b153a984a519f2d6ba5b12fc5e61853454beb90ea827ef7602a205ee46d2ef477440364a1db217468b8bd555a507f5e84e4773b0289ac76fcc6401491953ed3d2d6e681d3f6f71ab5465afb5e3eb011e40a4f81a345663d3f7129515b232e7f87adfa553c7d160a30f09e8391dcd2144d66eee93c94c450b0597f31f77f23012380ab9eadda09a87555718e27429f8d967436dd7f68ab704a50af407b06a209db25381c57226034d2ccd9bd24f4e165df6a725d3850c879c089ff3d816a65f84ce7614ec4a64beaacc9fe2902841028771855943f04f0d45786432df679516051ecf575565deafa84779b6c445a53b45aa982e028f8ad4b07cf4faea44858b2a7415801e79491af1cf428580d8d81c4ef206c4d99ecac0128edba5ed4767d2ef4ad08e1fd3521f80172545b57b90b83cfb79531db76d0a5d02fc012001031d63d6fbb09369574f334fd54b35472b8188062ca9f05d3a8eca5aec49a10f14e6bcb387336d0ee0c4bdc683537a64b86c6c05dec41a7995700ef0f5bda3ac8020c65438a4f9b753aa1bf518b17ac0e0d74e1848598787bac958e218feaa335d808daf70d03c9ad09ba11ac2118046433660b2ed827c225ecdd3728062855413131cc71fa9cc99a112de0ebbe20f434f51e937a8911753ccbdd120a26c546adcf00d88ba8c7df47dc2efa0882cca380a909fc991bd7b9ff87a3f2d12da8f742310b2557134e431ad0c85ae6cb3d32be372b5aa643595a1a9a5ab7f635561ad1c5226af2cbeac71e6f1ae250624402a29a2d1dafbff4aa65a37ea8e55c24887d68a9f14f3a9caf8608acd4701c350aef025dcf07bac953c3542159b9986853815e5cb392e204c2c0c98ace5c371b3287301ff0879a2d6fe860f272e031855adca62483ef9ca9e26476e12a5975be6f318e87ad5a170c5ce038ed0f47c12db532c8bba562c278ceb37f6bec3be5c0e20d6f753e71a70c09728e9f8df562ef35102ccc33e400ed4155320040094c2e0aac6b517a33266bbe53e8251c4666012c8305a915de8368727da346c3fb597cb325adbcaf09b2ab20e85b30f840629107a0696414b7490dcfd5f90641ddd4ca81828202ccbb391e44c0d1a43fc2d0a2d2e6d8e06787c56f5579b2167225843e0d104f55e8f112889ec32930e8adc9863964f1fa076e7d159224326f50ad261c2c07f610b440a97ea4c6e2c5d6568a80c157428f4cbaf1a15cad06e2b1b58bb745e1c77ce0413f8000f861229efd867d4886db73742cf3e90142dd82b42d8a29813153229b7bff3d1525156ecc763c2b592903a8a36699b2df93386677178485fca79f1d2328a4cdab8041b44e5d8f4971ee2a68abf63d7cf14fc6293dc5be1164b5e8bc9e04ca7d0eeb0051980e04b8dc8ca825bff748b174746e30ccc93a8a7daeba7c843b0db4c5e9dbfca790cae22c860752f0fa37bf6d0220dc376abfadc5725a1ba9f5aaa9ea3a1d92d3ab3ba46340908f90aed7201754d7e4cbaa22a7805f17ac923ba651a1ef0ad2938e2078687e6821083ebb1c0ec8a36601d47289a4eff301b4103e25e657c0afba537c6a4be929d10eaaa6a494153f2ecbea3b877e39c631b4ce42eb65b7255febaa8579864cfc5c764b42dc843096fc825deb5c133110f3f94e60e3fe5fe6b707b887b280963a6a6121d34410ac9e3cca174840c428e8528276226507a29cfeb905c78eddb87de3488990746f3720c28f3e70074e4b055da96442e9679830f6f8c6996b5723a7dbce86ae4ee559b9224aa30ff6891f3a512feb9775bd0faa65819c8098e4be3564b7d174198da7e6da367bd5f0e1cae0bf45633a42db7b445683a074c4ab38c9a2ed324b7e644378b35006fbec896f5c11bf4726d8e264f17fb0695f15aea76b2362afe3e09035e82399f913e92c63bf8800c3be139254df25b84ba8c82b2147635ef211088cb9916751f19384041a7f25f6fc454aebf9c2f24420a7dd1b0e54f9b52d8d5c36d6f4abad10e96a958c9734fe9ffe89868dab4b72b8327336fa1b0595f608883086fc67f0d28a6ec3ecf29e42f4ae3929043f77190c42f693d598584b89525bf64c27f63c21702a8dd867f26271e52ff103837cd07bfb94be98f28a1139b8647aef2cf13c8d5d3050ad1e92fd7be6cf541caac3e6f955e91efe266d763238895737b0978e9899112b7b62c1e08e9c35fc1f45e0d97585916fe6030483b102172127f51d9ef4e2352caef0236d651fc705084fa83efed673c961230b10b17c3a953d27c1681ca10aa47315128e201146d52d267f785a49d197b5035e25c20dbb1a63f4625f11cba6ba8e1edbebd943735e27d1e9e6d1b028600a51c518ef6b2bfbcd4ee2403fad10cd7e15411aeca079fe4a0468e5b2c43bf034d471581b29b3f7160188a464cf847bc069e99d4c9959ed3fc5abf87ccff5dff07363e47b63162fa22c58117f267836c1a93805cee8674e9f7515e7bda200066b6b57262921b096a9b0976fa94545d8b49749b78cccebc7cc27e7f541f1435540ffd227f901e61be18614aa68617a18ddddb678cc8f3f044b580e5c9e57a7bcd3dad9c36163f11429143a0c77bb2807c5afdf80dbcd622bf8eedb38788f6d0efc3dad25cade9d7d969b0ad7b6102fde05a643b4562703f66da53b9603fc571b7dc089156f950a22d5954979cdf950ffc7e91718e4c9e453ecee544f28007bd7c5bc51ad18275d218d8e4cfa4e491480b33ff953dd4d88ce9f810cc9a477d1d544cf2391cf9d33d35f5c2601d4817aaad04e8bc8e57369cdd4071be351873df033d5fb1eab135cde34a8e46626903a5b1a94b83462c6225671ea7d85b46f460a60f2a98498549f9007f620db1065757f853fbd0819481d6e675244a792d284fc2c3a896dcdca767cf1e8520a939b772a6f602351a0ae60b468560216523d69fb7376c5bc24882ebbaf1e577819492f5e93a581bec7fbab3508c831f01d1348ec536aebadd1d7a3fa01482d0fc7de7cbf3b642e89f7f4ccc321644344d3343da335b3d9674cb7eb5e2e90292442f790f2afc12dd0b1930b8e8ec693a249dd2ca37c60372d62dfed071f39391f636cbff5cc14a77bd8bc030ce8a5e56c7d87b9d36a8096b370f9c77cd041024754dcfd4fd763405a1865da19d83bd140d3b8e545e5b5015b3c185bf395ebb4a2fefaef313d5eb709b98cdde5326de1eeb150b230c4f41e5c9bfeb8e7a9284c50c3d78a85d5a35c3c28634010e291b068ac8f46244a1b299b982365072faf99e53db1586c4312e55530c0301c6de246eb6e75b0baf46ad340b2baffe919347b3ec1829ade65209701bd7b792f810ca155b476fc42505f3f0f80b81d2dcbe79a129d0ea32ae4075b9906593935f28848ff858c3ce88c5217281094e5f7bc780ffc4c29911a2849360a9b13c45b212a6d9dbd163bcf1f350842c130a92f2db40181025f2e0d4cec40d3e425811db56941d4612c0ba5c8dc3c27baf631a753af5dc4815e45af635ee5f952e230583db9b2a0cc113cf2b0dda45f75907d0b7fa27f1f1f58462c7c8a38740bae9054d6ccd32a7d2580aa05b97a95943630204dd4c743deaa6dbf03f84fd5a7ee32c468aa83e13c43bb24d918987617b3e7f1376d499a8e77a962c50034e1e765fcbbf5521cf01466aa9cb4ccb5e8adf459e3019884c648c20638bb28062356aea6bec15bab9879d7f70b7d79d084a2528a11239ea4e1d13b447eac70df30c02a8f4f99e725893057118dbf7f3d4f2e966a855cd0030338fbaea67b9120ce43a5cd81a1c0311f81adbe923c2c7bf485a56b05b4cbd60fe35eb8fcea4c2be9fbbd59192c4c35b77b40f90b94562ce9dac29f3234cf5824329f7d46beda5a8a32a668847aee341bde30526855982549b5327ea594dc14f5483d2d904a9429f72cdf717288b1454947f2ca69c79a9f2b862fcbe98e4ed1940a0a09e23580d5c07e8b3c66450ff512004f5185fc203d0f686c7f6a57a853842907bfb2d9d19e400c8fc6355ff316ed2bba298af3d3da6915ff2b898d61fbfaa7c8e6e2035fb36e828539c6d89e8305680eb4c96db89fdf4d9d46e542a706db9afa305c45e8c4c2f51b0a094b21e0a782d6b3b19fe7679d0a1b769aa721d7296ab285e16a7c89fe128a9448abdee79ead57261a518ec0126dddb4caab158f587842ef3d7044c6f05386b847dcca101d0ddbbda23137ee274747a2dc8b5e8bfb0719ad860187e952f39fd092d4ef59eff313d544325ae9479ecc3ff58ae47f8321b5d9c9810d3e67f391affa04ba2e7145597f92e95327e1a29bd2f55e66ca533c905f037fb599250596aae1c585ee4e79b088085ca12b4cd13bb41a66424dc5ac9530dc9a6c2932f19f4451b3974deed6ded3920509c95e1c536db35a305ea787a19494413abc76ae421178aceb90487643adc5ab1ced14ba8e0663ad211bad5838af496d068f3b78201a163c8380ac4420b1fe15a53d57ccb71a7a5faebe3bf143034757d5a688184f5814f7593111bb1899c609d31884709f04fec5fda859a6801a58b6f4baf8bec9e5390266c9f315627ad2b0d41555f7f8c93ec89f3753bf337f07ef33cf6f31266499a930e5ff976f4a30b8fd9c054b0d26e294524a31f921336e18773dfe9e23bc514dcad79ab55a982b1ec61fcae97dd2952d465c0682cfae1c1391fcea05f90985b26a99b3b969b280d94c06e3cb0d476388f971c32bbff553e58d8cb9926e9cd7457035e039292b21b96e92bd10cf57d4e530e8a9db354be8025e22725d9d4aeb649f5a028f4ff1c0b246824b6fbdb1d50eb14d7fbf509608f56dbfbb2b9f3bab4c0f413b2c49e0ad8072898a585cbdb26ce1f50c59b2f19fef94dfe66e976ebf0ffa2ec4c5b755be41929df3adb3e59bc42275073ac458a4996a631cea90606328220e6b7f39193b87a3512d9713de1e98163b09a3f079a1acb382d5494a6843cda7a0a5e13967f51019fec7be7ce9387f1ec5025387ea5fb67dcab3b138689b9a53e46297e2f306951b3ac529547680bfbf3ca2b6f878bc86faef05dda08f24248618460e0a6d1284248ebaa37891fe3a665e91004da2ce149e72aaa515327b5804a63f19de85ba106f84ffee4747f0c7425792dc2b3d3d0f14e3bc9d5fdbd98b2a07f62f985de67a635dda3722db5b702d5fdf72c6d25482bd9d27266b32a30167ba7c8e79e03dbefb11bb1c4a288b0259e2102816eacf526daa3847f84c302ca634968afcd031790706fc9b60aebe27197732d1b0dc9e848848f7b3e62da88de0884d5d49c267b9917508d4304966a61f427627f4ead5e6a642b5daeb81b949fcbda8cf439f32ceccdd45b87e0646afba8b27544a71c3b5b46993590515ed96c104d4851f7df94b70fd5f8c4930ef1113e8d08df7007bc48369758b32d9e46fe67de8c4661533b9597b8eeea994f736cc991f8a17414f9eb4a517dcf30d4e652a57c85f401100ae1ebacfad0c8c43fcb1bb1700e698196c814fb7dc1e2c4835dd1b197e3788aa5176043a57c5ba6c019e4b9a13730f788aaf0c0548fa503727b5d8a30ab80300945c5055c43a32486ec57e26f5dd009ae2e7c77c782d26f80ef54ba8b673b9313b5d12ac63433f62339e23bfeef7cb648059a1fe08d43a50efc3f2cfce2308fd0c565d134c596d5cddca7cb7bd86abb39992d096ce5fdfaa3080cb249f4f78b3969b706441858d0a231322ae1a4f90c2ae410df4a355410fab567476e951c12bf3d76ed15dfda9bb130cf36565a023cd5fada01ee059a800b5b4ee315fcd1c296ec9a10c9d888836128d372e8f79a68dc4c86994eaceb848c50cacc40c832b47af9749cf2338231bf03f62dd4d7d7d2cae301e165799458859f88f6780985d9f4928f5bbc857268e8036f2358292f0e8189df4101147fd834579745afb945de9eb44460f1fe7f7fff08f679092a72007f865a2f8311b9e2d7602497f64f98404e695ee02bc175569776fce19356428cdbb06c2c406dec6d940a8c5b9522f7677a6c244172b34752239fde50a6fdcf65fcc4ecc2bdcee66dc8df163cde72ea3094120cb377e1e96bfa678159faad5286500026ca07d389f7d164e3ac2acf067b96e565c7569814d3e549bf290a77474c134f4cb6dcb44d30cf856e4cab5887c2d3d40b0224aa86398a1aa1e1b3e56043527ecb762dcda9ea51588cdfade7c8fef708d035e339f3272543f1419ff367bf913168b8cdad88d2d16bfce5b35d105bfe450b4e8b23b9bc261a41abe28d1a7077dc63f3e098fb363cb4ae57eb2fe8f61ea6bb1eb1964ea1acf00d55425048fa0619e532cec3d8b5f14df9269979ae948db15225d9535ef7c049798164c095c4607629ce63b155497afb16f649d810ac64e940093494032c3e6c5650a248709f6f5a3a055c5472e165425686736c8d8ac6e8943ae605b6b54f906c59a32102f43e7f9c10e179bd4f71ac48d2be5dfa4a370204f9b3040b4b8261c1e1cce63ad9bbc4cf9dbbff6eee1e2fdfdfddb865b9566a6508f375d7bbd4a48df9aefa892381db984df2de67308cfb725502e0c35d245d3b8727b241775ec15f01b5cb336ad9b0cf92e1c26963b5261a2fba4426d74c7885727fb7db46c3ee9ce9126959a3c028d3651f0b348f7dd6d93561aaeaccd66bad791cc1c1550421ed8ce0c687c8c1d5879ce2db2d65feab1503e72f11ab704353474ed6da89149e9dd7e5621bff36b324e781d43d85e310aaba4b5be94df0ed2602227df5e80b390350a09114d1111ed7afe10c08b89054cb288dbc02930dd05adb1eec6b940b6417501ad370039b726f206fb97a914b09ba6bc22bb7290369862f9b4b0be0ebadd62ff1a340db5bb3de45b9b65b96678b04cb4ac6e92293c9599dbe4a8640a346f3dd1361779c983b4b87bb6d40c742702128b666d3f08ed76c910df396d92c04f238773835ef77af32a13c0ed36882107108d29ac2b64189b63ba68d4ed19366066ef87336f0a804fb7e306ec2919b18fc900a861dae908c883fbc9d9b5becedd256e2ad2c66c18bea4b3b29323bdfe53c8c84566f6dab95946b495504f0185d19a2568d3fc41bd4e21e9dafad1bee45796ae1a52f2242ba9ab926ef4a43c05239c7e41a6d713d155d186226479de2fd73a73130107f2494beb63229afc3b86201ea97cc92dc694636f335cb7c64fc6ac7813943e738332ab59046f884b36b7dacd0e9ee46c8854c52b66d73f85a9233e0de96f1c7049b16087ba1fc70c41c4302dc903f2f08f616dd70fd68099267d774c667817bb4866757f4ca9876b9a354f4ce618f691a60c352b4b681ecb35061a5ba2bb08738b52d19f38715c5492a5d26202caf2b49d03f8d5a783055ef9f70734d482d59701c807237371db9ceb7fb62d293f774c7366cc9027f620d8623e2b6a93139c52fd7596c6a6f1452fea41e330e6bcc20aeb68068c1c21393352282a02dd77895324cd4d1f786e7ee003e30a1370192daa1b5d334a8da3920f54b62715b38dc49e7a4d32bbcc4d1157c9653998546cbbfec3e1976a8e419ce35badb280154d754ca822a3117946ec98577929619a641c2d37befeffa170137cf30ce396f6cc3955409efa978fc970520074558898c0fb6357be12df20dfae1da1df5626578210cf3e19612f24d381fb1ffe37d0799d7d8260dfe730e715f90a0b65104268ef8abeb438eacbc007af93c8bba1abb05075a8a1761d961a79d077add1c65d9dee3b8b0ac9035d4c3b3926b188b0dfaddf5f3affc93609aab692af641fe7608fef14df835e8507439af103c11d85af77f9e912b7e392553a47c90480a0588f5ccd0ef99d5957be244bceb931735e941428f90726fca76d1e4d54a78568ce2ba9dd24fe173a299521badde069c2c407f0270a3e058d9fc2a09ad521806fbdb5c7d2617a471d59d7c45e3a40179538cb6b932b02c03fafd6527ca95d898c359cf0bab94e030672ab7e83e4b6ea26cab5b7db7281ca39bae3ab2c26619742ee36b774433b7d26397529cf69d988691857f697a5f9de7411bfca8b6490f73779a37d6de313ba9a96e1b1f52c5203960d8ffe2af783a968459cad7f8d6ff086f460ef0d31370f5fabc2cd88675fb893238f94d51795a4e3c36c831444d253a0b37a6527c7d00d170a44c4bc55f50d9ac120e97b3773307ecd7febb17263bb0b42fcc8f49db0239ae4de7d84e1d98508b97e526d284e418ced54fb75ac16e1569a3db5fd6dafe7a84b8a8eeb9ced57f3cda95e5b1256ff47c9f46d1bfce733d673b06ef421634215cc28292579ef5b149244dd3230a1a62ca3f0b6497dc061604e2d88dbb1d13e121c5c59575041f464db0809105795a3445433c9fc6ca40658d387506be11eb5d1a9ff932714f447e005367b7aa7c97e1465f931c4dc26ef4256dbd481722359029d1ec7a295e66036ad23a81c615438486107d2856fc11fcaafb70533bc15caba2d3833f44fdecf72e84784eff3335ca3202f5d90e965ae69956f8b6c08b60711d382b4a26aca654d4510bf57230fe24494b189f1b4076066915118714c8acfd7fdb36b07f3ddaad0557f88b2660e9359579ac8592ec68ea1f6639a79c54888adfd5a294dad9755f76c1639dc4efcfa16508aa605c9b59eadd5bc248c573059066a6dfb36e4f7b4af3609b303d5b6faaaaf40d2e36ad2ae63668bc49e69cd7b5eff7be72417668c350da3d3f6218971ce36e5912822984ec64a67cc67d01fc068a7b860568f5d26a3325b75f47ef5bc8d8e9000493572d4c77738a0d711e1fa7f47681f514fe47e4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
