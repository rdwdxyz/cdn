<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd06c79a264da8d467eed4ec65d0b76f6e969ba1e94b2c9ad05086ff8ef06f793e5fa844ec5ffd58fa9c4ba73bb8b00965750fa73d7d321bbdf5fffd709de6c916c21797ecb44a0693494bed969f2d784233467c124693c98f85f0a29fc68f752b8ba5aa068b7dcee75aff5f438a782986311d4611e9d26f4f0a5280fabc02e3fef2107519d14f7906b52d404d21c3c9fcb1ebaec9f79396887518d1b512a67d8e66629182a54099022737df7e38161e96102b7c616c3bb58d1a8a9dbfc4d542e616e1084060225498ded3627a349e0ffcce5c09f4301851d7a86db010c1794a1bdade197035da9cff7653f45e680ea1de8f2791894c88eb7fe32fafd10fa0036556d44f38f7df1d25c67c360bb7f9ce51b0d0ac0011cdc60d97f68726a0aa0eb08a3a52c2c8b294aa1d6c70b2e64a179dd9ef566ce97811c9a11f5ed7a16e20d7f820ea63ea9f7cc3ab1092818fd6ee6916d4a9e8251eafd16d4bfe18bb1c57f802f688edc81ad62c54eee75ae2d46f247c7fb04e17f907a0398193dd944766227a4c2bec75bbb1bc9c874059a1854ae8741bf10932d9372ef9ce65c7fe9e25c26f26bbfeec9465a9d8043f67022fb04ca2f61dddef4a7bd2f250a36518f57594501a8ccc9032a00f4b31cdf188b868dca206844a6168a9da029f4e4d30d3669b40d08bacad4d739c0d2da3b8e09b06ea066008185c3f4faad7e99011965c8dffe72e7d515b144b73752164f8173185be6b1cad24ed38ff9654a9cc65cb410b3578eef05e6901b4b5ff5ee49314d0e4ceac7eda57571d28a67c0867f776a0e99e7ff0b9990be4fed0951b073118da76e871340dc9cc5c5e103b774f0574e6cf25bb8e9322756174a1a106c7b82878865ee6ceb67fd94b9095babaa973c2ab7488ff1d11c911553ddaf84ae5c6dea51efeb9ad07bff72a9131d64740db041eb585ce1a6327dbe7f17ba9b1842d91cde30c030322674463e744120c581cc4a3221c86583f85f643e250eb9ae4bc19984e50c421cc748a14c77d988e27f15ea795a1612d291c53bcbc89f5e9b8f94795d35307efafe2ebb929432ccedb5a851fefc31fd06a06510c0b8ce99126fce6d8fc7be544cf7404e69112ccd8fbeda08c486fa06ae42f371cdf6fddbf144a0f03c034f60cc1ed0a66b381070fb88115021b8e219ac8a3d7d9d3e1ecbf124b2274974e275551df6a6a22c2110256c4719f0286fdc2a0720e4c75190bb10adbca52585fad639a432024f28861ad5053d909e223316f89dad8db0ef66807a229149420f7f147babcba947e33f7f1d3c7b565a54945471bc3a4e9ff15132a544730b6ab15282c19e992cdde9a61a8e74e1e23d0d2baf47995da588e439cb7013d669169d57db564a4f609cae052f64392ad9b17d37afedfc454e2710fa992b7edd9a4f078032e11125e67651ced129aff77c88637836808d3d237fe0d77a33fddd1c2d2ff928d5ec70c1f8ffe0fd2a977b13823e7a10aad19bbf4b595902ce0c55da4fbaab56442c1a3c90576e48ff208b050c819b202eb37682677973b4ad1be96627204fb6d81bdade42871e8af4005084d452588a29d6c0b2a3d3701b0cbbe700b8b0ffce99225248b2e0c52aea5313dfd026cc40349f425fd7a50e7bb3b451aa6785563b3125b705f4702ab6ef34fe09b7a2d6ee02c42af804c33eec6f472ea66a4c60aedd4acd9fb426acb874a3240fa6fbae8427741b11330c338e9b2563fddd602a3f7a78f393202df6e854eca8e82b55a26cc6adb5047a11a52fca86c3154c64d338ab3ecc766f266620630ef47d4d8ec01cdda50bd874c3317aee1a01f90f7da462311755432ffbf3948cd6b6a0ef703d033869392bfe065acdd9706a72c8a373d48e1640ceb46a1a33523ace81bfb6e23244ead886c67620f0ef7f9858e820316bc72ce1e922cdfb9661f1147f7e2724e2ff51aa1d168f061f4041846aaaf6fea48b52156dd66047d0bb87a5e96aee42145a5c82b2cce5f2f26c5739e20019c7fcfa3429f6e8962e2259d6c20a97fcf372933284b494552ed610f6a2019a8ef8084b531729c0151af2d401abeb03b8dae41a1c0f59f83f479515ffba012cc1a2a09050712fdf30e62f8cbc94974b37e5965be0dca23759058104f2cfc35ddb7a7b5e438c21d71d6de1e74d2d113c3b78edc2b226e78942e02ec6d85373abfae7ae1f2ba366eed2b1bb6c85938e2e6fd4b7ab05fcb6659ebfe688e0003997b6e9e733dd696fcc4229e1e61d9f1ab0e457ecd5d3f040b1098803670836c263428f163e3d34baa41279c1c0ffa94add0dc17e361dd6588f090155aef6dd22b3e027dec56031db050b8b9b9e9f61012f342139f29a2a142df1b5df98e5aabe23ec0cc0df734bef41a5c238941496ae449bc886cc679c055cb1f4fa68b0b83f94c3f77f59a84e771e80c2a7153167f4d62065297cfc708d9e48fd7802d909b1689b895cd94f171ad0dd2839017a6b1ca16609b7425e650bc3af0968a021f35c62eb1f432fba7bdf54e3da8e35ab74a35ef122c68796668a6649c77970ec485aa8155fcf14ee485fb942b638a92df91efa6d6ec571f60a6226398778c3277a9c9d46819530109e7f2cf247432d2f4ba607d7d05d846af2e7af28d3df055b54dfcce292e7c96e5f024e6593728896811c2fc2d44404ea447937a4165c492b59d27f4885f955bc1fb261978a1069745b4fcd9128ac0353335490e120a1819974da59ebcee06b6dc1f6262349d29a2a4f8cb5bff729608944ac53be50176aed1cccb1b99f1b395c62b5e6faadf2011c50532040bb528b446e1bf79f69660702e9037a5bc97f624a0a81fdc3556c5c15f4b59f5c37702b5ccbb7e476a05e24176a876450585523db03603f3dbb1dea23ff2533c120a0d5c7cd7abeea46093f5df754d98eb9290c33700838f4fd0accf5ab13ecf3aded94410f193d1bbecdb53d6ca38f48bdc8aa2205a74ba3c0304299b68aa5d45bfda2c5ce065f0cfd3eb651886c08ead612400866e24a10849dd978683c40ab69e33c7e2c0d60e6964043f1b076e72debeae1d70109d7b38eaecea7c7a2406add6c2673ee70811c2e17e47b2348351b83d1e323e0e0819fbf4269d3bb5d4224446fea0612380a4a5d5e8ccdefc98099721882ddafb64e6e0541c06ea16d946833c8af16b6b66235679223995d1f284c58e97242ab240453bd5116e625693694882d884eb2d11c1c9b7b7d8ae71ff2a8f54f01ab23d718431c098bf65ffb6bf711ab8f639a3b621624b8eff01127799cfd3bcd8905967075dc9cfdcf471bb074602ca71cec35522eac915fc3d83aa87065161810a196da20540a3a98c8a469585fed89af26a346573ded7b129e59e1904ccf3e55a4acb37a325d26e2d9e69c6b5f527558fb1dab4ba35edb93408c6c0d3d8d893f0972a2fc310889cce490800bcaac0285af05dbbd9a041eb612b315e3c2b09e2d741d4c6ab70f440b8e01021dc313010128a0a1cde4bf3019d69f90bd931bf88eba53e57464ea18446289917399395bbfc1424db04ceaaef5041ed1fde4fd5b60d2f63323359e7a401facdeb514a87551b1718158503a3f90973b2704e80828bbd007ecbb38135be3b52bbf43572114fd864537e0f833935ac59de5057cb4eb05765fa4cf0bf700dd13698ea8669aa2c1974bded4fd7e811ec8f5fcf3b7e1a1a9b2e210794a92a145b6c6a9ce93e4b7fb472239a14cdbdc99eec65a4cb06a1f1d5df9d4949a96a104af9245f69d0173742f4868555c222c133673e100b5c0a469204b80d6ed36a7a2d75a16c3414b8f2952074c9ab53f717efdd5071b26da70662c9d6e2415b6429859ec4e10dc023f848bf8c04bf42ee3955f8ec4dd9253538e14d273109892aed7bc07b7a0c1b5705252b01a1ff9f03a9e9e239071996cb7c2d16aeaa985ce379353a7f9ffeedeba25b797f3eb2832b859d23a5e2c55487f53000abaa032be59e168b7e60c8e96e35c1d653b424066cf5c67c64e20b4f15011bd9dcb333d69b081e407dd2469d37396627c68e7d8da7722134e0cb6b47f42c232389449ee54e6caa1c5d124bf4c9d670b84abfc3368f156e49a644f07311318e6de57f5079abb966153fd6b414d0c97c697ca4baa220577566dfa96f7df7b27965516cf0861785a0d8e9acbdebab16bf24e3343676b983909fc716e5b082049624da1411525bb08a878b1d0aec6b2d7f96d7d004ebcea43816a16dbd149bd7e91733a6acdcfc5a9737b61d26c132215977abe334f1f286517a4430b41df22eb4155b80caa02a98c9f33c8fc1a017c2010dc55d437876baa433d2110a5da4252bc6363fffd637dce199424aa6c7c3922a1be45f9cb11218a310c39ad005c16a5a20d8a21dc62cff817da3631bae62a3bc16081d85aabfc8433507862bd9c63f7288ca994ad99f54ce8537b82360a4ca676032f1c90a0afb78b5e7c2b8fe9e48c593339bcde477f40de634a343675cd5583fd186916b966441ad9192d3f7ad8a7718d09d6c5a171d46d35a958e13a6d71357005c4d96086299b6181bd4ec7279a50950a4c185b7b70794533add78682587518c4654552eea3318d0f7931ed70eaf17a25def027c2deed26e26d13ef39ffa27dd51d8dabcfc119e8e27e703e5881f2980dcfc709321e8a58be6b208739739d475ef7a9b730018ac2411c0cc60fd241e72c8515385f7787aada493c9da5ca6f2c811e21cf10e9984f50f80bbd375b495b18abca04a0a0554257a05e669b9df940277559473a89d74bb4e27dc8d34590d811ed839ee349230329e92bef59d75b22cd80ede6cf645e9579aea30a01fb78d4406f9d6df12b6e784839245925a4b3e640aa0877b378e23cd6d0b1f6b744e77d9d2a81c39e33d1bdcb24c57eb2f4ba812a7883e9e7780f4b6833c15389de9cca065a5067c31526807d52cd39ded1518a9d38f580d1d76154b59b785ccfe2f9a32646cd4fe62557b9986f2bf5664e1f1ebaac8e8ec995c834f700c08a5af212dbe08cd47ef798316978e716de45fdb95d5e1b2d19d93201fa431b092a281d37a3a66fa2286d37127a237b55854b8c36c31c145de9e26e8e0432890ada7c5cf835bda31fa5e7e7f8f66c92d45f56cca61732e43154f2b855e3bd1d163785b70028a7b0cd624eb27b1ab763986e70af8815c0a9b7be7e6ef6c93633f22912079fb485fa927fc27720b681ef668471043ba1492dcd37d2a951d6a42ecb0aa7ee4cabf7a11ec3de175a650c2c612a35256ea437dd016f4c9ece0e3cbde8a506da0c086d44b1198eb3bc3f056fb10a68fab8a63ada49fdd979f1361d17b346dbbf767625cf8140d16aa4fc24c79aca0f2c1dfaaea4b8cc2b28c2693ca23be8c21f18fc78fe4daabc837faf991a616df909c08d1823be8a5f30ecd55cbf0dcbb24583bfff894835bb31b23ad8f44f72e4efe6ac07ca2d81527213c525b524332b8ecbce45cb4c3eb2d65df6799c45efe72941fc312b7deee2938f34d519fb99bf5cdc42bc332b28a6abe85b6071a5923e868d9098465340cc6340f93fc650e3b4b9ca2840bb5c5837c05cf9d22c7566b0b06a3383dda3c99d03b5870f6eb70c1f0a82d67e02445a7811563fb642ca7dbdfde66e9f2f72d2723e8b90d83bd73667fdfd92b05d91ebaa5d80372447a8544e69f404ea187adf8c392f870cd0087aa767d6dfced46b4721341b4ea3d819829441bc59c043e93028b0817179c6b0d9134d4fef47b03b649b8f0d59c8f3dbfa2a328fbc263602b8a57301a640202f1731dad0c282a38d5f1c1533c25b2aca0564bc50910569d5d9ad3ed3b77f284aafd1c93cb70a1c60e78877b057e4bb7163b9a904cdae384eea13afd4683675d7087f326060fb3a6a3385f301f2445f05514e852da460a684053af2c2860ca06b3ced874e0a3a30147964ec310c7e32cde3f0e117d07b56e3bc346b5872ef2acdc8ef5b3b298f1d1a736f3e132478ba28ced70b5bdbe545b1123b54fd3463a6c035bd146407f6172cd0d4b5197ed7bd12184ba606e39a45027ff098da39eea2e98a8a304ff89bf11d425208e41162403d682be2800d27f7412192dd0fb8be8a2cf7baa0a554a5f9457236e8125a4f59ef2f13c24ff55f04ebc78bcbd92757a01263c46ee9ebb88c4a405e05f2d9eca9493cdd19042b557cae53d3efd6e4b98df5dfe0e58e43c0c62c9520009a3c3eeaac245da9d767b4df886e2e13db93580186488d06c8b69c09c0ba79744e606e6d1fad99d8f76bc6e6aa86d4bc5eeaa47b0b0a36bf278382fc8853e6f801655c9f498e881fa673dff0979917f671e65cf87a07de9959ca7c39890c37306a6c890abaab02c815861425b694df9abc94585fc428a3861702a76c89bbb0512d6e429177df46881a8e333e895da103e045897082a7762d14e790a1d79939e9e7b176d884a1ecb2811e519e36e073635182c118a537007941909efa68a3d900a05eddd8533914ef3408398c369380196592424a49717af3fc17f93454fab673c9023cb117e7bff8d52cbad9095d379ebf2d01134905514a5087f6d6669c56806cc2125a485039720f575e4247474a1fceb2fa9632634ce01fc88bedbc67f397ee441b06aecff28f0657ace4cc9a1e4ec50dabc0439148e3ced6d5dc5a43ec0cdf53f5093e566ca0a7c473a473c0a1d6bf1b687cc9410ca40fbb00ee6a036d50d9ea267d87bdce8e72170ac9a0fb21c5b03a1446ca76d7801e03cec4fd46719c88e6ba2076cb5c5477e7ef62c4e8778e79ddd0340dfa3430562d0de1dc8fdf7a66e335cf8d29b3b840dbbcea57ba78212be4766e28a7df842080e5c24827cec1e4f7ba55bfa99acaa5abab9aa0cd6c8b82c6bc0ba04c4940c2fff90257c339accf7ad434bd66d306383b526be9959e42c165cd69d0c808c9d776a649e5be1ef34ba5615106c8f8fe5d5f0ebaa8e932ec390fc83956c61874245d5c631d3fe47c46902930362cf133bdd4110b7fa4a29a19e99653aa8aa419f7f1d200d476a402ae7915d0209f4ea4fafba10a8b28f0bad8d6a3c1278d0d303187ea8c2a7f39252d6422ee5cbfbe93affab72fe6188435bb33bcca310c34721894a34da287d511a99faf62f5eccb82904627509f8561d7c97c32a2fa4f065ad15c4e31d498dd45d58b99dec77e36b6fd9fe9328ccb0310181cd69027ba6fe4761fa74afba85a6ae230731cb3bdf8bf1c866e825a95bb12cac626dc015d058b23df2a4e829da565063180b1effaf7b8f90d25e096fe7baf9f6cceb7db936c6c81cb9d021d6ca2f12e83510909dc68155397fd8dfecf6ff10abf18d17833a964cb609e5fdbdf942e6eb3291d5bcd3edbef1c87b0f4bae8dc20ac04304c3a7e29ee615e342e0d684619fd6ad8a81af553e87a3ea4095aeb258149b5fdfadb9683df6b271c52200637bb3354eeaa87f02862a2f49f047d6bc2c0ce2408c3fc7522c065730e88361e39c07813c24f330c061197aff74b3b20e99e70f2381209cffda74193f3c2c1d80f6d41faa978398619a5b601718a73195fd07715939f54b2d5fa2036356dab82f6777f196f966eebb114a79ff8e28f2b5c3f3b0107e793106fe41a2f964776a303bda9bba27d1a46dff5019c30688aaf295af2b7bda084480384edd95abf851e8bfe3502d21f93ee1e048a94e3a1b49e2fd3d093ad5341a1f6f11de0961340711e1d85dd7339753a1a87e9351e1eb4256913702bb19ea33aa055ccfdd4b60504059b7926d380ab11be3beea92c4dfbb07f72d9055f0edadeb577d7a0e0804ef2019cbc5014781a3b40aa78252aed3704590bbc680b6f16a9b5d32bf9be97b1843c6fd1e3893fbab0eed252cecb321aaf4e506c0677aa9dde7e49b688bc2efec4ec7c19896e56e7203fdaca2e8504a38ef9a627ee77255413cb54e4cc9f3a53fa4e7c39a4197e375132f0a35f5bbab901f5fe477325cbdc3cb859dcdd159e71b24cc433d41b7c5605a4765a29ed18504059ec3c00f98b1a954bc69543874c251d55e4bd471aa1e4599a0cb1072f494ccf4533632397bd333339b09ff1fbc1507e278b77fbaf4b1c66e48488231d6c0b205ecaa7aec3bd755e85dbff7e5c728968713a4dfc36c162b3b133ff2fff54977c782b785f0d481a03888fad96c89626d0e737b06f4f9e206ee0bd6e48d5b2f8ee95b885fbef64fb49b9bf8261dc5944873dbee914ee3fd2b5e77ebdf144cb00cefc7ceae0f952928f4d8593c9050ca4fad57f715053ea9652dd84100f676d3d4fd84391f712f2d962b0cd4779cd4bb5093335ee6aa80a958771e19718950ef476de0ea2ab202fa157e8d3ccef5b837656b081f4f8288b602a31ff39a68e00e18faf2e0e58c5282ecf894a8c768f2586f13f22b88e6d5e176c083b6262f6961b2207570ffe124c02713ee9fbfee34c3352d6a7a5089464b4d82e4a4b48e62da1b2b251f871fc258afc3790869a19b80be825b9a00644f88b23050da44d02e9df85421d6953ccb9e7d0c54ce8d5d4d6155490ee814bfadba291b0bae1267e50be0477649c2081d97ba9ba3df5f4d315492d58041d50c9e0d45cc567f0502662692c850769f74df9d606c3f31e56dfc30bdfc7bf56fb2b09e274f2b8c8a73373b94662693890b7cd791e075555ec31c4958f7acb60d83559d9891bce63433aca192e911ff4e18a1f3fde744db6a1e4e6c6b34c824dc33a9a58ecef2dce2fcdde4e1da9a6f1d9be5a26932fe67a5010a4907ae1dbb322af001c24e7422f795bcf1d751b62fd5844d6f0e6f7727d64f9298b3819c2519277b59c25a7a2e288c2a851902d64b22a106d09234d08cb31084afb348c3ba47ef2dd26e5017f7a8c71f1233a47edadb1b63a2b628447cb07f8d00a300039d5424ecef1cea329a97751001365c0d6d47ccc8f975e8c08bace1779969278464459e757be171894dbbe6b2a57df32eb628312fbe456a520285c3dd64daeff04c8354cacdc4eae7f2fd4767093480008cdc91757dbcb9c34fab88c2102b48bd7f893a0b4cb6f08326403931277308cf3a3fa73ec8a4473e9b1083d1bdadd9cb8b26e3b2bab3c2617145ac822c0d927168f8cdc865a7d457c1d29614abf413d73c25f1b985f949b17cfbbec37f1940c55846908558737d294f9fe155ba0c9aa6751e3db7383a36c3d3e604599beefc9e461002caf271b7d8ed2f43404f96a3ec6f3a21437a80be6fa6efb361ac9694d1e02063182a4aec232844e1c92f9a4dce649f40ea992d31b309ea4edaf3cab8f5c9d4d568f9b5335341212d561cc76ad43273d85ee468f14e07d2094598c05d3232370218b7a78583915e72baf14aa10fe7d4ea43453fa4aa9b4cf987534e509592683036edc7e1552974e9e229dce5734e25afa24a5d5575db3afb83d5e22f5b19528f1ccb2fe64d0f164854e792cf203d430ca28469d21c81b0490560d3a38bb4d4d4cb8e7a44e2be844250947721fb51660d455798c8a3aaf0067ff4513394730c521936488324a609489c4eaca6876ce7d99497785686f9756a403d7fa92f5aaf6e0c48c32330041a6067242d92bbc14c71c62954550b6ee1ce828c1562649fc7819157ff352a561aff975eec9adb7d3361abe67fb31202b6bcf5f0f1a7c97bc69a0dce4bf6b2e61405da59ea24facee022bd8afdb8d2f4228595ced4291b896ee1190abf2e6d018db46d469d3552f4f2ee7dc2917a7910be11926b479605c3017fdef4ba25f1b73266da887ff3bb0db8eb9a7c27754174c10f4cd14e1101a214703dfd7187cf47b2aa17649094aa0003e4048dc0ea54a072241062187e9fe55161e91aca7a6d2ba78b189d77d4b07d840c26281146e697bfe80184deec04bfe2ac2cf780982bc27b71500456a5424abbe940edad001ce656be6f832a480a4f2ef47a032037ce87850a57a185270a62f9ba748b9ebff4552640c85a43b48fcdfe44309d4b096f96eea5f2c15240a07cbe9acb767cd9707beefc5aaf067cd83644a4e555f4d2a5a16d6a7f558784b6dbce29b5372dd322e09b8b6dbff9d970ed0e5b5872388f90cdc6528c0638912f03f11c0aaea4b43f543ba433db50b6e7f5d4134650f0cca51c3a26effacdf11fb839115d2b3142b3319eb5aba7568bade1c25b8974af62ca4157a776f7f4c578fd732c976748f9bddf60e05abca53207a00a9587a9a71bcebae55848858032a097e88f04a60396ac55ca30214c6a646f095dacdcd773d2386b97ce4db4af54086cf7e7c3f910b63aa346df6a3afb299fa6a6e8917daa8fdc30d6ff54de3af19d6a25fcae20eb9d58150570e41cea4e605f377515b0fcd5715e20403d4a465253f2041019822fe0255df2bee935765b39392b008b4ee78cf89e8f3fd561dbd431d2929fa7af009fdbf4558e2cce246559124f6370b93a7fac0bd62c0aa7e783afc698c6f47c6b97b9681f33971c526dd21ba2c0c4b5c56b537ed372154a75100f2f366a5f6e8b5ef6dac37280b4ffbaead4324bf45a2547b2d32cd86d613f6351d72af99a615667ab1d12d9fca441f4284161164edd164b9ffe9a3f54cef0aec7d369c63ff5fe24b64b54cc1fe892a534c5407261d113459222e1546148152b61db2f7166437f4fa07c2f03187cb909ab3b2d7810188b35f0515592bb6d341891a21e35c49b292f4dc1d38a1537a1b9a515a1123308ce299c7ef5c35a06e7778cc1e7f3e42e1d454aad43580d34f16302df5e7f34cc969458a986122487045c7b05c5d2405b9eec414f049b815acc74787f50e4b564d18f2e6224e4e7c005635701855d92cfdf2cb0289ef2eb8f622710bee1160ce8b21c1d414448e040ff827737e218e61f0703ec8e1fdc2584d5f90da390d1a341be135569f12bef93823589a79103cf07cdf87bd0e04d7d4d145ec36f9d96435b6ba08ffbc246e0df7ce83e2cb8481c40d3ba8e58d83be7d4479b69d1b4ed12c0ca4313f846651a61526d11e2ad2a03d994a38b0e8f9198866fe7ea2ac92245cdf08b82d31477f1699fbd6bc5e24f03a00ddcefcae96ca57abeefe5033519db9fee47dbf4bf906010c69f37699b6e6c62122c770b5919466d62753c6158b82808eb11af695890cb81cbc6f768101816757310421a65a1311bcd06d7e813a41a2364aa5a23b3ff8c17c59cc6c7d83097a1988df25f827de2db625740ffe01b474ffef512be66797b3edd2453a018b8d3b2e2fe6e68b49aad64d3214c297fbce8cbbcd472a5395a46591ae00bf5925167f3d2f9dd079e0efd0d163982192946e0ee2cef874b1dfbacfec8c2b4ef03fdd489d14d322e699245592800ec17688687a2c6d91d8ac18a54337b026febabf4aa550fc4549952dc2f7554e4b9a3a8fe7f0e0a5059048b4c0ccf2e212edba386143acae3febac6f45d48cb5312af3c3256b4928728fb0b8433ff8a32d94e364f58d44efbe078d5386cf9e47fc57ea7693bc3840c8e388dbc76f6970a394e849c3b44e2536b2c025f472d339477226d0bfb308576924df7094990d619a0dabfde9e5448ab8564618c188d7624358d6776a7be3417a7c4262fc0e51c2d46daf2851bf02970627a254ea86c6e692623384242ffa882ea3edf899befe802c2e15264dfa9679c9ca93bad9fc1749b178c236f78240c564c32ddf8f9d2d26442287cb2d8926061ad0da7704ac76f7478c9f968638c8941c4a8c2aad324762902dbadbd2685c6c905924e64819e95a0a962283b966e4d020cbfed5347fdaa5bba1dbab4f2af4dea41d802b21b314767f53cea8567d45c81d49b1613f841ede8f15edb006cb94d570ac2b75c9998cdf6630c72a041aa0deaf44d0a8a2017ae42589074511ddac7baff3709f89e0005dae060b3883c0b11f7217b111e50d912bc46b204c004019644a20dbcee853721bd0f7f8081fae12844de5001c8aeceebdb2d4247e722508ad37f9383d01e971d932b7751d7d0677a8781c3705244749a6c1f0ca398e3ef517e03b2688cfabc7c0356cdd5f00172bffc81a49eb161cfe864bf405792793d61406f014c18198315f38c5eeaab7601cd4e4b99104d27ae86959c2959da9bcd8c43060c6f7e3919d5004d4525671f7a0b2cd9ff9f0306c5b7527f91cf20e3f0eca62f867ca514dd10838a95eee901485494449421b6eeb5e2ed0ac6695a86f2a7aae63b42066da53b692927226432bca650bef5864fd8969c29d0a5bca62d70f2cbb0e119f41f6631a118dd4199c7f950470c1320e6048ecbaf783cd8ab40f67bedbcbeadaa6d08e29ecd49e52227aa3d8248b3617b70dab70efe70c3dab446d76352c3c7cb845f9e74cbd51c566094f50b2c181783fa2a0438a7c975504df26e14e04c86ffbecb1f11ef23518b2fd3f81dba9c3008df9ddfb3adfd44ff5d2c80582fc929689bffe1a48bf6ac75a037cd143fb752ade2280c952dd6a8c072c1584a27567776c19d0c7500df50751be91e0957d7458f2ac7bffc732951403b51564329855c12607815b9909a02a7fafcdc2bfd991f9ef5d3ff9696d1add30a58270cb1668221ee43f3ade65e0ecc6d004cdfbd99bbcfdb04108c67398ef1f6071f88bee18426bc0daa3b9da68571cc84511ed40c5027e6d0842a076e32ec06ea4ceb81fb50064d006045671aa8adbab67b9c8a314f0698f72a46131237670b3943f93165e87654124f1ea08455c5d2a77d3df8933fb2d895082279906f2d95f5a1e0da037f3bb7aa7b5331c91b9d686a2db3048f3b101c5c1138d2fdb6c6e05901be0418b246382c08a3a36481b96e1d10260a01ca5cf28b686d00155eedcebd032beb235669c1bf9317257fad935fb694d3e3142ed764ea9c9767fc4a831e8594226a9c4427fb5454d39deee692b76255d996d4b74a16f1d2013e2e5cf9eaea4926e7085627d7580cc8a69736285dc920302cf48b9e680054cd124c5e38241058866f88fe9fa8f2bed237171167af0ae7e216c12550f3d72809e945b12a5278634c16f7f78636fb29980e8339fefe05fe8a3aa21ade84aae01ced64411c04c8a43a0a130f107e79ff8462fd2c54f2381ca0bda5a480f64982d80966d5a32b404aea74909760543552e6239110ea050936cabebff02a3d8233d2ea3aed19b7e20c64f0d1e59aad45fb8fefb75d4b0ebec8baa5849c58c5f2470a0e4c682ea58bf49453de29a7b78935743cb59d7fba60d1e49c596c58c86f47c21f7c5f3adc9e481e6e68cfb3861a456637e9e5d408929a5b266d94af625f4be1354482ae61e3968033d4c03f2bed08f1f437b1c989e8966381b05a7973bd5dffd3188d6ab671ae5f6f624122b5f8d2ad283cbc480b8648a15e4e3ebd8814aadfb0636c550032c401dfb673fc67b547db91e704f7ef9e21f7b11c1f83adc7974a10e86f68cbc04485ecaab7d159a03281e980e80a9c516ca79286f2c071bf3cb16db76b713c13d13dccaa666bccc53213e5c51b45daacdcfb4511b84119eef96f08da32f905561ba36fd178f1208bf9594d77f9f8c04bc65949615a6543d31383dc523b95b4ef0f6f2a3ec5f3ef7c5d13480017aaf6746e79f472c3f1c67729212674ed014544978f45e4fc402553be665c3598f9a7c064aa86043aec58c6f7eb32a07bf75cee613d9787eadda19273d7259734c99c5b106d0c1ecc44a7b928952922f50e6c4d3db137f7a7f932c9e11f03b28987db3e9bcfaa3f9e6f168ed1417e12c5e809d31baed5fd37526ec7c61f91e6e9d169bc57eced5ca9d5a1f77fa4bd84c4742034047dfc32dfc9ec7a6000010112e907381d15e3a105ff138bab08bfc96931ed40bfb06e5939ed835132d05da7d270e20887ed8ae6d86f9d17394d9b3083cde552ca995d1a7c1c20014242ba5f4e9432178938487275bfdd7234f91a8d2550131a6528bca562d65f50629b20efc093674ae4b68bfcc571fb80491413cf2b8e9fc08b8490bb6eb39dd76346e0a1c6b06202d9a18d83bb9fd4f9518a813dc926494a74c1cd61a53f4eb6378fe9cd4e9ab15c7d4d2ae913c70388e7e31693fbfe4e9cebc368c9780a2c4d41dddc243fae6efc5d1d8679894f90d343f972025e4675a7fdec05b5355ce99c386ce3ee389bf53cc5f702b73b6ed12ea7f2d43906fd7c5edd4eaac20d30eabced67a92e232d3a56c52e5bf5c5aeea029fcd1f5370075b5503945b52f5ebfeefa5b5ac64e45911a55b387f71760817dc2cd970069e7798db0ae560fa29dde80ba4fda60dfe9269e29516e6c633d36517cf48322e386bf01cc274eb1a4835a1c6bb492fe8df4f0517f6798710aee2acfe34ceedea5dd818649a1a3f4eddda8afa90384a564beeaa50d5a7e2ec6bcc5c09c042135592e5820cfed97023421fc0500453e79584611f554dbb8c404f42f210b9e3faa81efe23c3878efe328348d3c257ccdd647853af2648c7b53ba6958b7388ff7bd83da2deb9c3ec470e410d0b98d518f575f55d5fd81fddb1686849c93d266b9eb8019fae1e231ae980244012c320f7880e27706a764daa6f0426912d616eb63630cd723c4a5bc10e33272ede8ca39d50eee4a8512996347e4290b2674dfffcf7149b58255e446549ec6532697654d96b9aeb562ab521209418fc75f0630f0d9b7234685cf1e1055b74e7a42e3d4bc247186386c0519bcd95335beda7812b437e94df39f8d3d884bf4357c8f6cbedd2a1f15053a09f27e670fab9866e2fc84f83dd9fbb7f8111057eadf0cb1461458db175b9c93f8306acd8d7938124cec67cc4ea20d84635dad077710fb9016acd2ddbf71bb369bc363b77d4e1f44413c5336740d9b0d9164aac0b05203322bb8a992eaa7a2be116ab9d11afcc7979b1d31f5884eb8f4ef0b82c80d7491677ebbdd914c6e4c5c8f1352242d7267ced7be8ea61141ad5e8112c6ecb0534d50acd69c6cddba375c78bad73d2c355fff4262a3db33cad99ee7cdfd6115857821e431ab8d1a9bdc02ab0fae0f328229ff11c75e4da067e0d1dfe8b20b13396b343ea28b2edf677cfeda383a1c5ed733aa52f653d26641e244ac5894dbe2e50ea23418e733f520052e96718458338432802d471d6ee7684f430c9cce011ce8cd5ff0a719f947da3c802b9377ea0445f61b97a99cec51547ff65735a44aac329d4e587ef04b5bce5bc45157f6f54870c135c49c9ddddef40405a015309e4d38b1069ce3adf280236b30aaaad9bd0a4ba9dec13d0c6102e1799d6059b073373a4093c29bf942feb3efcadb880d466b2f581945da7aa280bb27b0b12b94d4d82772826a0bfe773ab638f8bc75fa0ebdb91901524b38a79b069217c96ab6dfbc5a82544c3786e0bfe6040f658ab68e0f7b5d7f56d6b99782ed1ee6487d3a9c0369b02461af56921bcc99b3c99809719a58b86e66e4f43563db595b8a4fc374572a025895b0e741afdb7dfa9184e03bcf595496eb1019c91258fafed875ddaea6f386566f3cce9a30f26370651bb4f47374f162330005832c725202e053ba2f2334b4ffa5ae15eef45052222e30d72a98d751523e5e6c7061225d8817af2a986546eaf071caeb64760a03ef495062ba300a1bcc0f19263691375fe939f563eff4745089e7cdf70879550cb704f411ec0f17a1fd14dc2f1890d13cf901ff93a3355e15fe517ee1a0406e92474737aae6ba12d877cca9268372ad7df53ee4a735fd6fe2ec8a230af2b8da1c7ed9a7a9c288a3454be085ddbd4a7727c37f776c0be39871173251d7272a5b2e9eabbaa38ce533dc3d63a9f51e32c8d10d3545360cb08de91efa87380d64841f50727146162c098422956898694fe2e9a54de29be35434943d6c71027c485c4f665cca8f25d7edeb8010c3406f33272ad62096e24e07b15452f142b94ac2cf441138ef4f5839d98546acb297e8aca3578c6d005f21dd2cec23bc58925cf2284ef3e7ed6c466ba7e600a65c34bae998a770fd51394cdb29703cb25b4d95a07646049f08ddf84b106a228dfe5f065db2c2cfd99023c0685dd2fdd7abb8478a1d513d4800e8e0224d22b78d7b375e1639c86325c08889fdb43129b86f07acc94ecf3975a783fb1d47fc605d550a7de44b7be7707bb1b17fa35cc458668484a4d0529726d7584c2b9e455ba97a422bb0448c7e93c7780126fea4e3e7a44d7e9c25e6693f1fa33ebf4cb215672061021619d6efcf110824756dc24925b4b50664e33e5d0ae12fc50b28b6f21c727fd2f93759e7525ed1274dd726313c6217c0980214dc959f93b662cac744d2c0ee6d60c460ad9f6636fc086356e361dc0b794131d44ff26896610a74ec3600da35fb96c61d1879f5275894dafbe04e83f86d68a881b3b569395928628889ec6518459795a708b0520aca5fa5766e26187e255582a58097f317695b49ee7a74a520e704a09f5c9c3f59498fb2aa7d11115a46375731ef3521115cd6f3100f1228d136eac9d65663ee36ce137b1e27202dcbf8859ea05fc5887d7aecd19ea26858f0e642952dbc8ae69d5e91339031bd24bb82ee11a3d0a6e94faa1ac0c524b0a9194645fb0d63ee4a8620e388e739f270c29c64d309c9efbd06949c4c537b8628b5c7e1e94f5ef3ed02be3fdb8da8e300e71aebebfceb43d60683ce59037e019913d616136e7cc52bfae239f8706f8b90f98d56fa14e1fab9d2d7fde2d229ba5c94228bf2745b755fa3a22bfb7e6208a6934d623b8d773c2eded227d7b78513707d33bb4cc49d43abbf27ae14078a661bb3666bc5d9ea7e4221c35cdbd060af73558cea0802f5eb655865d0018b080e6663d60042808aef5f3090ddffdca0d667a546c56ef2433f732d3ca39568be85d654762ff1a7b020edd4598fbba5f5b012e47629e0fae97e8434b6c5121939c9cc595c7b486c774f8e93c6fece59eebb7f4ca7e55668c6161dd0783f3ebbfdc895960cbcbe3e36b01ab0f005b22442c6391b22c0c2b63fb719049441030272ed561c12525061d812d3a05029359f9eef55d6d659181662330656d80a11a4ea0d8400d3aaa3f98ae29b40a847180161141ee1a810849cd5553e1509e806a43d211ed04df45f2b001bca2257b25c6eb2318f72c7d0633294049ac0b7e87f06e0a536d50bb416e4a34707a55ecbce0e12a011231849ce04652714931af73bc096b5a6bfd7c8ea766525f1060edcc7cee6a77437697f3eac57af342e48ae26b3760aa285244e0b6eac5e5e4aa32a5ddc194deb082fb744a2de414cfec3f397882372fa40dde3b176eb4b6c2f877cd8bc0ee95adcd5aa62be68ef97c551bed5696739facda72c8ff4d5bd548c2911b9a764299bd5a3996f462380b2401bfedc001f9dc21075daeaf5aa4dee06923888a19587364b8b41167895bec95e3c3cc62a4983caf943b34bac7194dc346709b1b030673aadce4ad02b03267f338dab97200d9cd8e40dea84efb7ec4efefdd0e2ac1c0f4f99f9c2b44b58ea36489a65ff446f4d9cc7681cbbd377cc4cf69972370c44fab24e22413a418c166cd0d71eb7d5b6374e78971a5591f2f974a5d943df9f92b1f45459a03d16e69ef32842d5701fe61eea0e110ca440a6bed2f4836239e4ee35de89600d8b964651f3a5c5b519656966f78bc2f47190bda142745813407ce40d727552c70e4bfe82d0838337b0deff9de73824c3782c3392d20539b5c608f8ea1a49d0cfe73eabc68d3be0e7e006ccccc70bb8bfd1c1f5a5014e019c89825663e88b06f0a3eef6d1f59cfbbf25801b6b2be7527ce3a34565d40a3de41975b8aa4e6595381826e15304845bde3e08c2278ded45a0ddb5480c12c303156102028247ac3d0bb6356c3b46f10dbdbcf8cda8be0f1655821eefb37d8d82ea811c901f2dcf8c58e395d05b3c817c296f7718d19cfe930ca8a330dbbc3de49228ae0003cb4b37196fb1e19f3ee408dddd809f266cfe0e7ccdf407c576e394f12444110fc115043371d35b2f3ab7d9470ae2b0c4fba486d92814510a940235e204f4a0c89332c22336e7be3d358847c10c34298c97d6f67a9a0c86b8e278d776472a10890bef9a3060418910fcd26607458f8361e6078ec74ce1e1dc893cffefc7cf5039d6227becb3ef7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
