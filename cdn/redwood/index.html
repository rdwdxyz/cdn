<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"150c1c014cb2eb88616d87782fd4ae126ecdf39776dabc804251c7bcf8b047c89e1a6dcb0ba6f9c286b2885453e2dab8d98bd98c25172b6a1c201c06a1be21b8af81318c7a4da4b234fa776c85e21ae371d6fd3d3bfc337ee4cb0c8acbeefba001bf657b0f8aec80375803b981fab09721d3d363b18b7393259fcb513739720ec2d3154a718925946a7eb988ed35472210d3c9c16009ba6aa6f9f59f7dcd4e10b60cd0ae98f41411ce8ccbebc5f5146742ac14d602b216a19b2b32b5512fac941caf4168ec7da1f42296211c8d59a287a505a3391b22b82f3d4ec39a647535e9821b93f4f547cc98ede59f30ca7c705dd7c3e741a2ead4b1f87f32160faa0d83872ff629d7133f3fa7be5983fbd72e82c2c92f0ec69aa252ffd07661a01dfabcd19b3c04436247bc6b9aad67ddca0c672ce4bee3027e0fda3bd73c3a6dc801c1c05d447b536b0ee9e4c6d57dcb718fd085dc5e1316178328314b7bebcc17cf5264e77574e331c71dab605aecde4fadd6d7852556849c6cf2a950e4adb6dca9d9ab4b4d660ac670ef0113ce570eefcecf10418360c4d80e156764b741da21d046a93996f668daa92c7ffcccb24a67864fa6d011957e87a32ba4441552c4cbe61d0cb61d180bcc020646adda29b3e03f60852d199106836d91b4ceda9f56bd4717de5415b245751963da2632987822d47d052790092f79d370140807d8b40e45de373b99a1763408a512473184a271708824ba91ca278a488185d89eb13996122719209317e0b1fe0957d3d0761c1e4ef9587177fd94cea8f40e83285c5872bd3abc424eda290b3fd66835bc2864ff577af381dbb12aa5576c457b99f146d542a006ff9b3cb5b5ac561b086a436d26f42891f2a7e45f53f1237ecc8874e6154860a9c2573e6b1bd80de049084233be951ca3c7fd80429a474271b16b600f644aa22db3ed483128dc874d2b6e614988ecfcbba1a3e6c2ecca815a575299e954d7c43de99621f1e0ad4cba641a902f9febfb2bcb25e52a305a29dd04ee11b5b25f8247d65b4073d7bcc003266e527a3808136f2dacc2a57ac114e88d600eb3e6e18f9d2e2f87086198448462aa15068f7685eb3b71abf5c8d492fd249a03e7122f160dd905d33093376925bb073ef9437cce70d11416340e18a11b4287fe5b4f3449a6f82d887ed82655bea340177bb53f8316751d6f13bf0a44ba0f121208224e4c59923214d1cf0e18665865c54df60a5202f374a2aac279b43555705677938403954fc283985f0b4d61dc6b8c4a5ffaef612a8ac2a95df235d4cd2e1aa61c2039f6abc75fcd592c0443c94c0d052111534748d7065f9e7f9c310b134ff4df59753de41efb7a97d89ffb9d3e04fe82674ec206a52be1388235517b61cce440394742fe6671f08ae073b6879f4a6c7c7d97b6043aa6e7788894293fef0433561ef8674665826ea204fb5304c970db21f557b723adac867c6b51e310f45155952124808cdf0328e52e4521904902ff87039ee92fab3c82bcfd79183fd8becf3187ad77f873bedf234c28c56e67b325da2a98738777a53737a23c04473c87ac3f53cfa02f2d06f197262abea408550f083c4d310de5582c73afcd83465e6d3ac6f6681f7f811d49e72f4c40ec57a82a78f52bf261d2d14ec58cb85aeb7055af0591809349dc24d543bdc72c07ba4ab041ec633601070f35eb5ea6c98116b27833a070e4768fae7dcf20cbaff2563f06d85a4bda5487189f09b9b86511885628cf799abce5684d08ac1aeb2ad0f83608be9b76cff9022f65444839246096b8162f0ac60bb183714a6ec90108b70d5737009567e55132e45db2a8f2fcfbb66cb65c4d02d44f7329fd389764738ba10a38d49c062c722f05416bad9d77b5e69b6b74b6941911c249c1d383f0df2b6a48dc85552134ffc3a0a78909de5701063191f4f79bc6464af22c83443d6c3aedc097ee39a71abe35fff1a357f60e0ad2d95b9db2ba0945247e5d75e578a6769ee54d220b95ab8b662583b58d8ee441b0e203051d584820f0b5ce4675b9e65498158363ed3c7754fc4c90912fee10eda65aa5abebacfaa12086cad1b3a9b5e1320dcd14701a9c55801330ea1cde8a9464b6338caac34cec796991dec88816ea5b988f9a3aab35fdf9ce40c1e1dd386e5b8bbb9485bd5066d307393bb99eaae93a64dc4289d44eb741ddff60090ccd6864c024c3cc90fd830f89c95f7f81b237f39ed118c5ae7a401fa9a61479bf01e9faea5bc44d926a4c0fe1e1888c529b00b21e00b864c89abfdb6d9be70af1fd3e65701fd401e34485f07fb80671f88966a4b353ebaebcce4204eae747fc1fd93aa99494459a2bc61a836e891a5fc967bfcd97cc951fb2801df613711855d7853254d2eb7e17b6a43efb8b15f8566614c151cc712f449e2b40fe1c5f201c2fbd020783dea20e918715718d4a305668fc50fae04f5d9f8306693a1a301f1315d2327e497fe8009420ccc41f4db744e7281ebf343507b223f6d3d10e1063023951820cc8a73ff03f1b00d468965337e273b4914b106bc5344845e7e588bd191e5c5a1064874e6a6d69076bc46869e42ca9a6b9779187fc2b32250911fb5eb3c87d1703ac84a85e330125f5e74a8b7f267c235d61d428376c85ec3ad45cb0c3eec12b787e2f98ee25f5a2fe28c50cf50d8276f5c0f619700e716118d0de56de90b97e543e2d510368d8b40338e7cc3504a0f2f67bcabac54fcc761021c32cdf3e11f6f6f41501daa2d53db0ce6f9e1d21915ba1249fe2a774835c6a14990e03409e3ba6af2c75e1064d4a6194bed8fd1c2cb0f5e55f8aca76131df24828c81587c36476f93ea4beb537cf1b3f78d03b6b5db2262a9eaf4f3e787be2d847f8cfe1c7790d283c396f71c6449280a729e34a40c63f756b7149056659f3a165ffea42a0fcb067fba8f2eead8ef48f3a9178e0385a9374ab60840497d77b401f04e4783bb557de40a26761c3f0ba238a322c1bbbcaae78ea26d4190759644bfe3486dc12ad3277b1ada591093a7b5e40961a338756f5db3832a382184b3c86084acc9586a44a331c37e7807e54441bee9bb41baa499a91976b9503696b2386860ede9810836e4f6066fc07871a35b8239db6d6fdaf0bd5bfded42932280e2cb87608ec701aa1b5b414330da9abb2d30ee6024b00c007710d15da728b84d0819b7d6509e3f54ee858425beee623e84b858c32b74547d5e7900518eebcdc296d3503f93d0eb6837de52f4ae0daa336316173cf8a92056fa6120d3206eebe5c976f56d9590b7acc3b67f58e304d38f35a48a55578b1063f15397d359cd2d8850aa6279aebc3c182552016d39fbf8cea44a8ed1d99a345d4a1068c3bb74e0e5733e0edc564de6764e501b0ff1f26857c2d3f22362fd19a1c37be83e76dd4ba9f0886d47ad1e66f952e48c7af66b00dee2b2032b1b2c10d72e566bfa8f86fb565bdffc75f64cf3f281f9f730f859cab048f05949d25e515398e3afb7c27682b34a5b02b77e169315e0620d0974331daed684e45d4d4480f5c802a21408082b0a7e180d8c9cc869b8bf7fff33ccf0bebaac249150e0bd8eb35ef28f08b59f2def9ca76e273777557dc6999367d37d5a948f6469dcec91da794a8784bbcc1affa2b616b0244de1cfca0e64730d68dcdf9c7827e0808f7025987ee55e6f258af43bfcccf7a85c9455d3e7d7bb534691e87353b457d15077e60cb59e1ab2b7ac39a61ba7c1d908e3d1931847485fc82ebdb934429282026345839417437d449ff49bb848ca94da087130196f08f6ede6820d0944ab92772bfc83846e6867148712db172783e25f776e2b1abacee35b88360ca5972e9296886a2af2c7087bd756827c92601ca4810f45e1117dcfb2d2a58f3b796740fdbb7ac3efdea4930c6d9a9fd9a89e0c6be21e2d66c6f86c43bd250fbd52188b1450ecd1256c2d470cb14c1015d0293889e7ca4d4291899200dd5411adbc4d6ded4a9ababcc7a3b8362715b2a7c478a0e60a4d3ba10aabf71df22dc485e276eefe9c40b302dc4702480716fc1109dc00a449829fa4ba42f1330e2a3390da81f0a8c317ca2e690107c8335c32347afa19f21736fb5eb79eb6df16fe33ff1e1416a0deec0abdabfa64887d06a60b75f971c12cb43589c640954afdb5ff89f32f1e3a0f74198fa4e0abdbb87d0400783e3702b9cb0444a5e327b7926f031b63475124329fd6b67401da6dcd763310eb5d89bc42542061745862631019d81b383289a5c095e6365067b84229d287e44a0b51eb9cac42b11c060a6df2bc2b952335343ee924c19e08995196e13bca1c373de83cbf727252305eafdb3f7d4d4e6cc2db47d6debf202cba65876d3c8313c9d7839486c1e0836ccc8a198b4616ffee91036a6bd5b475d93d44afbc8c353bf3a4f9050677d9af20a004bca1c936f7fa910eee29898b66f4c3b56e26df4758bd960a01cf0e488d08b20dcd0050743eb3592751873e8cf089e82349bb13ccb699d441c655986fdbe9082900119aceebcd0868840070ee83a190f24c05adae54d0b6bda1c1ee117ef739377e17f5c7bb6181ae03283ef6fd4b7857ceb468abf12d3b638126f7b140c24d3fc0dd5b43ec6aa67bb05377f7b43403c53ee75f8be99775b0cdb6c5da36b47e38357a64746ab1aa99ae4433f8eda1ba2708daf916e7423e8747ae1580b2a2302d69cd625ad6cc70c37ce0c9dcf577f46cb5266e5b29240ba74980b9fa4568a763b458b70cc5d3bc00802e314e0dc82af7a5a3d99b2b873da1d62abfd81f6a6c8a7d09cae23bcd1096feeacad5bc427fed6092a7a167ae398ec91a1105d272f9952ab9c483db5170dd585d584dab309b9d8c62179a2cf534aef5fba3f2e709854108a1a06b8479028a2b6f32d4799350135781c2e3eb8726d7fc88b3c49da61308b815f205c42e6e9a5770a3497216440cb275794fa04665cb2019d00beafee8a144b5877846cb9de37fc5e27415db302c1f166c1d28feb9d66e382c15639548381bc249636c46e0e86b049470ad13604e827660da250a5d63d69fc90ae26f6ac36755905d175c144e12ddab95418547703993e6313f713ce3ff52b310ff8dc202148f3c45917cef26eef542955a810f09429cfdd4d2c09164219cc3c5541699c6fa5ec5f845316f516c09df31ac3fbdd6e1ad3757284777eff15eccc3dc32e2b262c77955427571664e66b70404b546838d4cd5a9a2dc0fa7032520f42e8d3e1eabe161755ea1b2df5f25b11be5225670bb10433da6a1337c7776ed2b52a4b0469459aa95bce17f10bc4b55ef69cc2c6fc97f9b2facbcb87503c3dd4147350ecab3cfcfe53a8f0caa5b13aec745d4fabdaf136fe04e21d0e8d8ee7593522be1ac7a7945978cf01efd20ba03e32ff4604f376d0bf8a11e4cb7b8ac77f2f9cba562a3f56fb27e5360f2bc14f611084d3d960f0b6a73703d14464abd2767128ba4fd2edcc146ddc395daf2773e72390f822d89a720c0760b4171cd8053742168c06641f5abd7aa858f65dd1124c674d7ec8b7972cf98cd2c132a83da60409dada76d69f1ba6bc9186c80a3fa264a53676b43f3af52c5d9e574d59804f9805fa29aa19ace52a0ba62e0242d54e47bea2ecb7153558ef87c48d96c9e0586b6b5fa0f017af94eb5963d06c05731c6455b4e39baa03f17862a5fc3e9d968e5c3bfa204fec9feeee793664d0b5288c458e8c1c583b0975328100288e464921e32c27dd19d8450d6bc7a17bb9a12af5d115a5878d062d884158d098d5f077240fc330ce5cbf31892a2b0ca95a8d44ad7149d41f827c191fa1de7235d388420215a2b6e70f7f630c336f9cc29d9cfe04fac2a7276f0bf9153e6b556ce360fb3fedc13764375ee9454b3db20eac6eaef267442a46f21145678ddcc317dfdaa290016184dce28474e4bb9bae1f18783627bda4cfe324acc9d5dbef3fab4dec9dbe3400e092945fe0b0e96e8142f54de8df0877f7148d0a0e777bd8ca41439e2b7b1e09570f199fb4de8c81db4ee161aa0d35305c451112cafbeb1f64eea5d3d1783a9f6694c8789b3abe59c4cd9a99b5595ff5a7c32c9175e457972de8bbda3db1a1782e297a84a86d4c0a5cfcffc49525fe06b51fecad8eec70f0c97701f6beca92c558d901d877bf757fae8c18b561c165385329335802a23ef04d2e11e45b6fb8028980944d1282f3d91899f5f77d5fe4508624c89eabae7fee0b16e7dc55b957686ed37b9d29af53c2dba3cab5fc9df1efcaaac24fb63430302cc6fb0d4bbd4fcb618f46b8ce0f00182c21b92cbab15d8bdaaf201040d3d878c502c7f73b56047e998f02a874707356bb15964028354c951af24a9355d76d97ee9a31abf39ce18c92be4b29d5db6233b1c47f5c2645fe9b00c1a5c279b70fd14affafe5930d86917262cdcebde46fb65a255d580dc2a7091e189f722dbf8b796b66e79fe2c21fb34d3c0c4342267f05634d2bfd449241aab7edd6da86dda0a06eafca88e7d5cf29e61b2f8ef83cbdfbc2d6fb01a9775b73bca415b6457594ffb7dcfc914db5c85d802c7aa1a03db8272f5a00fb2f93896433269311f73437afa14e788f0fc1ed6f6efcbcc25902f336fec189bd5327f938c5a3ba583b17616cc91396196f6ca517d42abf0a460e9ebb09fe6542a3c1f29f64946f93ae73e848cc4813dd00924fe27830bcfac1949ac33e708e5d58a216c91582c4313b79b94112094edd24327312b184baadf672acdd58c454ff731a8d3982f225396f5d75d0fa7332b82549502b7a5b6f3be2a220729e84c06124f20fa991e1d3c118d2634ab4c271ce5431b4e59bf47402ba74b35052ca9f571e7faadf94833d8619d8a31381cb7a7ef0183de73fd2be35e09f8fa3dd72ae771fc8f9efa6cb8de3fb864e9508f366fc6e79f3074aab5f8c07fc8f0ced8ad69bfddc937f421e37c72fc1f42fb2c79fea3fcb171ce5daa5a4ff5582f15ce948212343927cbcf27d507679cf6707a2f37ad1426e57603290c9db8e7f544b9fcf1dc2f655f1e8e7ed2cdd4d3b85eb1174501b688d253638e7edf22bf61a55d9fa79839ab0994cdf422e6d7156cfc14bb72d355482cb4855aa6a7d53919531927f8d443a2c19ded20436e9754b2473d7aea02123dcaca019bca40080df2bd8354f1a7dfbc46d27390aa8b6455f6713973b891f6eaf36e096130cae7b1c9db5e42f2b864f19d5c67eed004bd5fa768a71b4491884e3468a36a846ef8ac386f545f4ce1f1cf76665a159638324b6365c7dd78b39e8b224ca616388c1caeed50876b4d358d2b365f76f53a53830bc22c72517c4d22e3ff33d9952205323034129f29e441e225d5f11dfa5b6a71e41480aa4440936c173a7908946fe26a6ae40e30d54e06ee4f6d8ca9a2599d9ae355b9fd0b26749a99ed7ee6c33ccd66e279eadfd780a0c867cddfc8fdb06b7d92ea78e034b72d372d57d939dd82300ab2cb4b1a58512240e54c75ff723c268ae0de3d860696d5e51568088e9a14dc822040c75bfb3c2dde703593f458cb2aeb8806f14564a91212c0492b2ef090272cf6fd49c2f9648bd818b2068ea54206d8fb275cb36d9a45243176dfabf0c75b448660f0600787d2eae8c854cffa0a8660f219d08590c47cc3a6f3f8c930f223fad97fc5b07c445cf32f0f21806e668ccf311bf875da806ad9e8951dad4d2b77192ae82bf07f0bf629f054cb2e38d2e38b43a40f2e925ef485f0e3f8fa378dfc8316846e0aa94ba3e34bb319aa7908824161a6193b9f3e5523fc7e29f1e98423d71dd37c1800c8a871210617d3129116a7ebe4e42cbb42521f878e74788d6b34e50a132d940d80d89266c783581702ee0d3f4d4e99abca83967425b9234713a8070ad65119f14fa3ef7e40bd6e1f8215edef81d3bbd15cb5a38bf8f84354e9495ae0031a9008f58b21b85c80856fb0326c7f12b476ff5664382ed9e858f8663ea7a9da9f3640c76b18d55414643bbbba81b75c2e966088ab6b6f13ac300fd9d32a4f249eaf591a97146a3da550d81b86164684ef4201799189a65869de258ef2faff295ebcdb699eb88ef191abb8be4cea03228b9514848701f572b1194067150a29acf82de1373e236a4276a13ddfd683e79f3548e817665c152a655495f65ac97de15884a893a6ddba68e16b4900084074b42ac8aa7da82f9116c1c9790b339b22df5bd75c5636a6ad626e076ad49755efda1f8520641ddefbfa103b5cc347819d95b69805f4201d0979cc715eae9bf3fc4315b881d16d9881e1bd4f30f9a2f03314653fc207a72ba2f1c39b8134c68ffb56b99af0a32277396ac06f396a62ae3de7504cd32e4722ad1c479860e9440928ecfcd5af6fdb8b12232194b4e01763fa5ee228b8327dd7e2e82a5af69dd58259bfa7a3c41620be11de5f462ac01cf1cd6db1b1167b6d4f8c349f756cbb1543e285a73247d068618e84435f1fe51207e3a0f52c55c32b7ef45ee82d239475eab8c7694b6660e4218df1f4ad840d8688283e8dc003fa5fbc468cd9692fa5d246bfe18a5370fe691a0e9f8d8501dca51b90908dd4bcdd7b8c5c99ed8d6cbfe7101f90df011b220dd2b94a32eb8e7f3e5cb3f15a60600de822741ea3401c5770d6d7ea1242779e2271b56e123d6a192535313cba83f3f95235d003561313d573e0aa475eacb3e166eb85fc151e1d10d3566d0d769e12bb5873d0f9500f5f22b65656fdbcc2f411f4f681a5dbe80f8e7255a8e8a920bc9083c114ef1b00831d0a023215988d7d5d45f5148372ae7b849c0a0cda7db414da2e839432c542706ef58cf8c413d29f6cde4835dce91604e15107882d1fa6b29c2d0d7bca6dc2dc63a4ebf91c7dd9a721a2e449ed6ee390feab98b8324eb3854f789da78eb860294b66aae19fc057674cf31837ca6c4d5693bc8271122cf165ba2094a4e9b9750ba96f5eacc6b233e88233959ffb9a68fa824f25b904db6b9104b0b7f7d5c379decd7ab820a707a6e2de3215bd3e2b6689b007197189cf501230b801ebed6a69210e9f70268a1dab80104e745db478437000489c53837d360b8aa729c231a59adbfc306951c0da76e620e054ee86a42e97226c69c5ca37b76ba9f3370445ec8117381b739654b12014e455746dcfc8b0f707657e0a17743ef3b38f62c8f7e13b756077187412220a5c73ed82123c2fb1acfb545ddc4af2f2fe9dbf508c3e8514781ced603784b3bffaecdb139fdb8af8dd72898fb6126ae6d23f24ae4747b16a89708b0ecbb9a0f4f7e880db9b52accf854d25e458b3dc5292aa23e0c2bd7e8cfae2a3aceb0e1d5bb3f2f7b7d527151a376375f3400ed7d0232d213c3ae7f21e33f456226995bd91fdb3bdbb8e8b2c96973dc0d2136e67e65643e96ec0b9e11148d20c243c009df342d1dfb4cae28834e0d3854327cd74f282131c778491cdfc234a2eeb85cac8a3860bc4075eb89946a8fe1677c2dc3266ddb02b97aa67d49febee12044acc588a681c4b54eefb930c3e1a636b010fee317344e1e9ef6440e0443e2979453a5e3097029a1f85e2788ad9fdab6e848452c760d0c6b5ce1e98cac75f10b7e6d1f8328a2406d56cb854bbd406545a58c0ae7bc01e6be1ef97052b1d29a8ba5673bc7ff41542b8c20156d4e1307008ea2638d904a027cedbd23e2fb36a7e465c57f91ad40287ef59debb3935195df4945998875cb7e80f27668eb423bddacf74ac0e7c79652a0685181259ea7f28c9da6bdfe66331d55ab52d2928bc85acaaba94c1335add23dd63028194bb1d498856f955162b0b7ef8825815dfadab57adaef52dd1a0e16893aca3c238ba719b4fe2d107c98073502bc8e0e8ec206bebfb30d9640a20d3d5a63c4fce9c04820bd21598880fca3ac3ae8314addc3898b98d6bfd898265cd33b9646b495a61e54a37a618b0ec4ac32d53485ff33b3a8ac45ddf7c51d75738f5b47577a83ecd57821497c607dd96547cd8444161241d88d703710e63b725faad9116d2b7102423d8a5cb790da7b97277b71a62cf8c1c782fbe5959a01477d55633906c817209c7f7147f2d59e0696efc56d8fd3aaec50387084050fe32a38fe3c92dccdf14011aec937a107ccca013d2d41e65f9006ec102a4eb7d9cffcbf1ac4b3db8f091ef4a5d462e6cdd01e2ebcfb87afe944c29fb24d15a8f115889b351decdef20796c2fd11151d784637dd857741c6b99cbbf937c33b2fb4eb300850d6b9ca2e2304c04002d971bf1268dfa140f9b1e62027fa87d01711d9d8db9867e5955593ced33152e454661a91aac2ecdd001a55a7e21755aa2c79b57cc526d00482cff4c103e0bbe84e4c35e41fde40fb1ac237187b1af3bf439ec4412287bbc5ff1ed347a4bcc215cb0187e44e384c5c6bd6632c1d2209c2cf4a29b763559444e095e628dd8a94d992262e975a3e608e8134585d1c07f67eacc22c4169228959d8f9baffaf8f635ea85cf604524012c68efd5868e1343fff785942a633c2a14e9a917dd7cfc8e13041705e5a7c27c8f0556b34e4244fde96aa49dd35dcecbea936498dde08a6b1dbc7aff658e2dcaefb37ec1852dfb4f6bf9635b2f5c73594845cdedfeec365e508ce8ddd29c2e5ba52e7e5ed85e8c2c62f2ca7b5f476d538f747ea48ed45d00d3aa1b256758538048159f92239fe0768563d99c6ddb9ebfc62ce4a2b18d0c3a743dd0be8f583db2dca1105d882ef1f7f4ac23c65721f5346fc1d47d573f4266757a8c9f4308779c9f31376238274f4653e50fd362c4ddc3274ffd66c235cf951eebd3ecb6018d97be3a1c262cbc8bba543cc5546f2cd70c4fa90a2b3e091fcc1d7c03a6bdcc36b7b709ee4cf96841cc824a60e3af1913964f1df4bad5298e44607c4937be1e4e5a71ac725e492d7d482cd1f4833b04d350c2c670ae91245b245394b18cfee39ba716fa7d33e35a3237aca58193bb7e019197c9145186e5550b51b6152106464954076c2bac21cb201f6d961afca0af06fbb2cf3f43e184db2063c486216c2a7dcf555bfd2287bf4731094fb5609ac8d4a1446c38515f077446c294913a16331fd8117e8e7bd9787e293ab4d268a98d95c00c5bb29697bbcb16f533da5b8b6370e6126b6fcae15ef8465131ee4de990d1aec3a8ea0296bac5fd5bd66b0c4db45cb0c4e187ec56231daf24589fe138d89d69eec99294fa61744131969d136c633eac02868b201ea7d28ade637450fd35441224e0855fb57cd9dd79e806e65ed222dea1ad1997d6f9c545a0460b33eb3402e48d60cf9b8c0bd2910a03b1f5c893608e6a97b74bf7a585762bc31d59c67ec2fa260e299863e5c0a30b920cef4667c1bcd6e7359f7cbf86a9f5d1aaee180a93df3010422bd297cb0de321f3d1a7802dd55c0d83f535975cd7b48970033e8d2e91392e06df349806f07f5fb4e52ea497cff7a5ba2dbeda31e6a373b78ac47511df1649eb8000fca81a76d231e18cdd3e21ccae6797f9bf1d7ab49024f8d3356980b565cb73a46399b8016b13a4f941e9d1b87ee42ba8087548ee975399c7fad24147af4d6f20020ac3c623c6e41b351d12222275c8191f66c151836087673d35dd49f674daafecdbc161f623b4ab0937ae80c86bd1abe49ed578210c84529b69a4ba1128cb49e6b5139df9060ca6da7b9ef5956e6c341b504489ea75524d547d5c876c72ee66b1ac3fa7cc4325279483eebbea55f47090d99c10f326f9a042fe1ac7e204dee57165f1cda3650dca22598cc10ed57c179af49bac592470951975bbaed531320992e92de84ef566874e2a62dc575c06fd783b2f29af517b7baeffb61ee34e7f41f6829d79e9596586ae6f37e28aef19a366c6f544c91af496ade4e49e549d8f866b3ac12c5e1b4dbbbdbdb8f22dd87061531585590ec4830370483cc6222cfaf99fa35948b7440d3f00abb1b6ead2b4a039d1f74eb830819e472369d015b5f9d7b6079fc1f728708a1b4715cc573bfec9d2fe1fc0a2a524f91c75857696416f9f3c51705542db6150493351a98aebf8d18ec71bbe9a0aea5615f969581fa036f9d474dc35fc4f9ccdc50e7deb3643e5ee56a6e4c38eca8cfc9f94e73b6437c89f6a735b39c28881f3f063224487dd0a9e148bbd8b6a4ec5bf9ee02115941b8a60fdf09eb4f29e8c94ea758881e76588b2526fc81831af0a5d99bc8271c39694e20caf1088d3bfd474fbcae91d5a47717f85aecb4fee7eaccd677a1504b59f58ea29bacea14969ce6f1e560508db2271a32b09c1ba279d9547865ee6b9988d6bcef88bc28c482cfcde1f4b7bf66fd2d905ee08e2b8ed4dd47a072f0460345292c36666efa0193d02e3bc98b26c242ea9d88940e685a61bbd74522592bf2b3df4956a66645c44a7fcd871bd5896f107c1d8a9d9a700850b97a0352d943afcdc4fafc3354301ca092af233b3037a1a17f4e4ec0ada102385c58e83cccf62b008db11d6193149b499a896a1710d09e0d4d25e93ae421be20a180b8e694f5e8b1301b9db8b4a4f96c9f90ba21683ff972d9dac1e65a36d3d0a8f7dda5019947b92d619c73bacb16fb9b3712e4d55e369d85d90b8f55a402e06e32004a6a2f8aaa889d4a64bb41f8267965732e7d538f7a769e8e8845f4c29d174117fc79a4648ad10983dd94a3f17a15e14269d36a4b7dedb8f4cb4de9d30cf984b7e12c10317a3c083a865240778acaba027afc15e1dc8f9d75df2734f126347c5165151c361fa5836a9531767c710570d456efe643c75c2e0f746ecdf4e8e6eccc5f6a3bf9c9534278dbdd96fadebc496c603be0baaaccc8b35d426c3cad480039faccd49ea9769e5623e0399a92abaa832bf03319b30fd5e03431ef5a9b958aa7b08e953324aa94c41cb9c7e5b490dfc5ade21dbae6d1bef85574a769a8f351485f245308b6b6cf238f71a94e3026f029e0fbe2aab684d73edfc849cfd23db8783d4586396d693fb10c96551e352041e9bc2e9602b68ecfac1be75482625d548fa28b493be4405afd7d11ff916da29f38658cd50ed805410b6d265f67cb1bdb09cf295765657029bd95fa937baa7be0eafc09eeeb185359bda6d470e11dcb6095a6df21f48d875bccf9ca9f57e36547b0a60a383a8eafb91a838badb815eafdcdc4c16176ed3aced36f82fd5dd21ab9b9931816f35a69a7cf725266625ccce7f92a8e9e928c0b2d9a8efee409004cf3373f191bcc1a84d593f05e927971aa22b8407c429b6ff5324e703c76bef6dd0ef18ec40fd4450cf5257a8dda2b13ae30f51d7bc5858bb7a862acb3355bf9615d30f409fda004aa47910996cf2febbc0f3e063a25e0452c024b4154447b368d55910fb161f0ef1c7a63b23c7d8fc00a9edd74aa742177649933abfce6d2061df3745b3928749c632f35f24cd89704301e9f52a4e3dfdf13d09ee7e0b83d09b8a058c01cbaaedbf4c4f066103019ad6479379335862fe6398e6690fdb0092172bb759d8a97c28e7b36e085dddc222ac176e5f68c7583c135b14b237d9b458c83b590493d36a45d69f9af17044752f15033a142fa38ee30399d983c3a2f031d4fd24c941b26b1edf1450e365d576562044ce25ba3899543b547a2074072d31f231893dd03c31b88d16e601de4816cdfdede2b4b16aa24c239f759097dc8c649bff9cd863f36c0e1c45957a5054cdbd50a68355034f6f2fd4fa0520b7b0bd403891a8c0fae5ba62ab80ff52ea51d5771f131086345b5c7211957cb42770277044a1e04ab3457765544f8dc193b43e23abcea4ea350e79a790ec100b9e15ea6d529dbc8461de02cc97ae2ec7c4fda80e5a2a284bf35491e69fa37513b58bbf74e93c3ce25ed09f1d2cf7f279c770b8b410c0bf6f9919316c50ac19a558c7ba19fec1e9dc8d1bacade83225d0cc4ddd287726f766a13dfd3c2dbea71b127f631b3c17ac8934ea14823191fed25a43cadfba3b894b335f72cbce07208f87bfa7b5b971a161960fae6a8cb6ea2bfbf3c9a44f21302745f5c36573f49bc58558d57002feae1d051e3ed30ce726f11a7e6f7cf47f3aaaafe34562b7dc089b85622e57db70012fade873979579f3e84e9524afa4d9bd207cd614679acc36e2d6d6153bb5c335ffd80859ac79f02f38ccfc10c69ef86f1f0f389377f11290fe05f02310b6742e4bf640daf5e283d67e7c2eee294702430bdfd84217d34f5b347e0acc357b44cbe8d86e6b0b3a370a2ff27782deaf4c715da05c6fc07e5254b83ecded4d1a93a1b111cd2cbd3d25f5ca58f961ed82b39f14eeaedbccbdb5f3056a3b1ce343c3321ca6dafd7f90f5b29635b0845bc4b4da025d12bea834653d0dc3581b452586d6689d563f2dba05c4db373b508104e9300c2205e30f1c62bf60e6426aad478d596eea8894deabeb77564a2d8c0bcc67218e03427849708e52152b5534052eb4ea6a8b7f0b1fb70e4218ac15995f988b49032081098542139bf3ee3924aab7128896147ca309022ab44c234dd1f5155d29ab17f845bfb9adc3363bdf7a2e35a6aa30298fdd6d0e09885f75b78083bb349575f89bdbdc2b0de152b7f59109f2517e5e86299d47edcb9830d0e9e3b239b4df6c19370d2cf037db27b76b86a7354be83be639c51cb5f1c3c1e355c1bac367f18294a7898d7b139d4e07aba5ffbcb0d08d6346139aaa330cb72fb11d4bf42dd2272435bb550d6698778f1096ba10942e54b9ff0817b6bfd9d59f49f173d3e566b7f508e4576f2d942a948ea664f94ece89f86ba74b1404501b28c295de018fd5a232e92c2e7cb8874da5f1445c6e63dc1d584badc1892e3f1cdddcde9480821457d7dbcbbc67ec5c97a7d7cb842723452901cc3c8b8d96423c1eb1a7b042aed36aeedb7dd174835f0d56508f081cb487fa46156b6db5a2fb6ad2cc02c0c3682cbb52b9e25976d624c2f723189c21faa59dd8221c09c9f22866e829a198654d6a77bacd1f7fc8f117a4ff6750bdb8acedb639dff66c70df0cc8a00d914839f96fd42668885a9995f3d4f1adc44a3bc5a3810411d4a403496d75267c4ce1324ba2e19ec01b532ec523c9251c7032d3c123e69ca5a195230a7fba86f7bc23c766f26cb1e315a4fc5f13d4ace62d8304acd2bc684aa046bad5b5461eeb8f5d8fc994edd0f949ab1b6fa17f0548324a22a5d64a02bfa18fad7df5b380d58d41e8756eda4b5e8cb9f5b84d500bb7c3d74133cb5d2687fce743a87b6b3b7e0664b3231597865c7671127b05bdc54f11cb2f40a172e3d46a40b9b3e6516494f442420dbef512d826f91a767b141838e877ab0538c4eecd370cee35ff5fe33532a8ffc3f37b102da7df8bc09d6d119715283beb48f5ba5bac5144303f45da52a5b08d14dc9dc0186406ce2a6f1ea2e1c6569ac805a53f7a346152e763222156e5c4b49d55f22873244e7559b425f688bb6c3b3aabba5324ea2f54693dd07586be0475659264bb3d62129a45cb1cd78ff687cafee90f251a112c71215400431c6658b3417748cfeec199ddc589d4e85154587eb524ada3876dbcfff4863746bc013baba8409fce365c041c808b967f3de5471e237be22a86a2770cfcd4e1d7e7af31cf8380701c13bbab19d8c6982ed180f26027eb4158260e843d6988bfc43c8334d446611c80441db6f4437e198cca3692e2d88002bb915d6aa297c2adcec3c241517f810a620bd7e5c20769fef0d8d0b6d014a849fb55036a20e35935bd5d6169b23bed66c611fce6951024abe68ffca404ebad218d169d4a3ce9dc01c7a002fe1ce1ae757cd6c208a304152d218ecd5b266e3c7647c07ab947f2cd0055244670d1a0312b8b101a4c713b955adf57f58553bca4346cc503f4fcda17a444a0b8eb9247c8b3c13056ac046d26235e3a8767eab9c85eb449c4c0f449a78c487d957ebe5a1dad5dcc09429f1d55574acf599813dc9c17d1cf0370fe49300f5130c00f032337d5af96f1527f93ed72f334f826313144e8cb757d1ddde84dc967edf3f2450997dc747cac5c32c8ce0500c59070b45e22441c8668e5a4ba8025191d291fe2a141ad8bde00b93f490932098256ccc18b09e1be67ac568f5bdb323a89b619eeaf25191e6dadcec0cdbdde9c01ed92e739e412db2fa53b80563f2380fe6512bde441c7573855301797b0fed93939b564c8dbb625c1e23bbf8655f136cef12bc1b2e5f7b5049c87ac729133a9e16bcfb524687d8cc94d05004185aefc0e14494583897a80bdf070dd8ba32af4c3fca251d7f86485a928adfddbd66340482c1128f2f3896e9a3dd2f62e34995999c0c2db3ec2e379d45d6087e270926120efdfaf98e761ac8a11b0bd4f7b1df56a7f9d85a3de78a315518997e1aa95653f4ad083a953423cc1c053d787e2bf1421aca58df951c884d127fbd1c403073e184feb159fbd92e0ecb1119e877b9a354bac3577decbc97e6972f2539e0e29f6a7f75a5f3f2002bce1a869ce614985e01a82217b1a052608bb8c17d64e5a7e05edc20bdaecb449b6628c69ba2c0a8ad517892685da6e0b7547f697500827bf7e3754d8882940f2930908ec9ea926c0bac73eaa34e24827a574f827b3827af792449eda9cf5f9e86bc6775e89a5c3b545d1bdbcd51b763baa46a77b44c1e15c8513b9ad21c90cd910a30d6c72f39d7a329089562fc6dc56f6dfb45a2a973bc3f8ba91528d0432bd9d089a58ebc3e6a88f34c20f3fc35bf788070da93877419990146576fd95fe8e3643926d724197e2adc6e04d5d50af04af248b561fbdafabaf7ee149ac1d4a3556abed73534ab962d27c0124a5c1feb318fb1c77ee1958ccb6964d2c9d0024d216f1edbfdb63b7ab8a1b1071167074535f81c2176fb49a1c118ef5b3f65e89444f5c7479c72f657afd64c7f48634bf5f4090225df8105b8db1008a02d3a851d97c87f62efa2be95e1416fc5176d1aa7a1a697ccb3f28e4f2de530a368ec31cb88914880c4d4dbf6e467518aa950eaac37e09b29ba0260092872d0ce1c18527c6f756b6ef1f6d51b51694b42e35e5a5e1f6b9c4be2c320c3a44ee8ee43c5be4f96143ca29cc8c5b8e6e02145832c7bd94f6dd344da9325c8c90b6f9135cc072dbf5220809edb36a74c85aec6c7b97f29a3e7aa28678f0191b161b20a98a5aaee6566564238e529fd7a8b324696eeedebae76109f86a154cc2a721ccc40098b883d86d777b3812adb38d15467578b0958ea2975dd4c788a139448c6a8dc962bd9f479f3b32871807101f89a096b224f4c0d2cd021d8573fc5b441f1c7eca03886da09aceb1976c0971dc9b10c26d598cc8efd0a417671e903c81f01dbaf523dc0ef14f327f063086ef41a6566bf6e7cc639d4e119cd32e8444c97e59376b538c0c6f9f37d03b7bfaa1ff5712cb45cd0790d2daf9ef70b091d624024f94ee147239c4becd3a3fc84a74c32b362871d5e6bebeb5c6e8621ebb491e0b890387b16ee0b8a2e5671d37990ffe50846911dbf6ecde9a71a4ae664037afbfa6ddc9c9c6ccb48bed5b8e4335ff0ec1f6f47daad100af529105fc9af2d4e65bc4c7736c39c89039d6b1c96a316244c57c570a626b827840d6a7a5b6d5381480fc6a806859081796f0e0fc802f4da701aeee461beee2592be9fb585484fa0533f0994eee849546cf7cb3b26c68d6388f29426da9875cbc26ba83158004cbdb90075d4e7df6158885d0684d3705e9aa9b9244d9ceae95ab799b2fb03e2f3cba8550f6dd401cbd0e3fe4c84f0873d70061f3251ba8f74cbf634e20a7b9cdb21048ce2ccbb97327309c7b0500bd20faefe95ae41dccfd245f59ec896ffcbcc851ad185c1913bda4ba3fe2c483aafa078f261952f1f78a214c8df506b2b868d35b00ae426348a40c9552daf695a5261c3f89cc3dcf9cbeb71f691b9910f2c346d17aa7f3462e8527e1877e57e34b618a2c0efd55dc3c5a9e6d9b0017eb981dd551c8067635b828a86b6de643964aa18c15c34d3a9ad218b870c922c7d9b898c4d45added7036286b1f06cac136d647c64ae2191d3996359718f1a481a89430ceee5fca637d256aee14ae35919fc94b3be7dc62e67","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
