<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3ba89fac525581a3283ac55b68b512841557dd4faca915535d02cc9f2a1468d913c52e6aca2a6aed66c6dd957f8c234bbe3e091f89bc3d943eb269d32ced22fd9bb596874112ce554aaf9e8bf4f7b715fe3fa8956572a10b08cd0db7046a4399b40a506aa381fe3ed607ef7e16839d526b4890f45972b816a474f0e209583d30d543ac53cbde6c301d7e89757bafa1f303c413ddc52ced348341ffa6c8488fe1ca37e92476d761de44185911ed9a0563d2e8d9824820ef65fe5438f8eaedb9ded6bd771792ba8653a4071b517b7732b69d6de18b9f1a2d8c880ad80c9555a8df8e67b609366d7e2423acc4714e5028fe8bb5eabcc2527a5328b4c371c1458df5d0b30c7e021b0bd8d3d52aae951cbb08f0b1c58dd7630a2afc13c4fcb46bf2e4d0ca84868713d5a6e511e463065d1f13a229cd4d5bdc8c1e16136fe92be416eb380e64f147c3654fbeb0d04a5f8e5018df583f096436712ee723c7e7e0cc5fbd7328dc6fd50ab236e93770af1564d9b16c48820d41a9638d23829ed3f6d27ea35eb292be40fbfdf6f8685b67c9dd869db1b43098098ae32c93d3497fc5fb8d6c6982c536c9d4745250907c86f8e31dc3ba5c4725fa9d444e5764777c925cc31a8f5e78351b1d64d291da26a9102812350448018d5326ad501d4677af0069191b79ebf62111c1d89795308c2c6a32695844c84b57bd716452f264810f3893fe7d3b75e4782d1e9cc6296ebdbac196958b72d79d82ac42e1545a2081d6cb8e14a12bd38ecee9f084a5806cd5cd991efef30b80ab44cfa15ba93ac65fa7a520ae437822cc387f8a5cc526924c6ca67fb1d0ecd7ce5e18a38386c4db4a1500f1c4c3236a39e79e3956a456ef611d57e6fc5524e155fe4181d7be4e169a73690aca1d9c73965c5869be525d48cdf22136a519d17ce69be15c37fc4b54a8c308606ba46c8f552997e74f6aa623bd5ed2a2f74fe1c7c9247b22f89b9ab57ffdc16baf25b9d473796be63a1d711113c0393e1cefb3574c919b821ad9813926e509e780633652a51a5db2ddf4bc79e865b15ffb7b8693cedcc47334ed100ed5c3ff497ab7450193e90989425bcd8aa3e7b2d88680e785688261ea3a3b1b2ac3b3c27c9c71c5daaf700981f40d218841c213426d3e064e88db6186056d623fc63afe341b08e58b9f543cf640534bb5eca2809aeea420fe8c3a9e8e9ef65b2365b27837cc00ce83378c1047867b6154a4a76d007d7c5bbcde2f40accd83178c1055aced98414e01092cedd5c6dcbc3f2da3e8710eaa955b08a3f6e3c5aa6d22da4fcf249cd9219788119bbd86a170f8bf470dd473f0ce456354e4ba653a0ef0304031ad71993edc5fecde2951076abb34cb56be422869ff5bbdde332c2eaf72a882f2f6635116596559276d3c0669708db9ea3524063dfdac1f69e3e12c8408f481f953216cd7d6e633b5c9d85706990185bb1f251efa6bd05e457589321366b6017b25c38badad36fe66f9f09a96c6a0600da572e82867d857086e77fd8d5e268fba45351464e5760015cd34ebf1b13be9f8db981a78c067f433ca01cd9746171df1fde852dbd68e06811d12caada66cf3f9eff054d3a2b337277a8ae6cb71b2810603184ea4a2f534f5d84db1618a792c1286b27aa1ed88829a92b89ca9c4982031bbacd43dd536099a46d97ad57ec36a43e6be71f4ed0e8583bc3303c7a142e503286e0aee9ac5c12da0b26b683a7f58fdf2621bb0a8c5755d5d1775e7faebfa175cc13a07b337fd320ba2f9b88916e58ad3240b1ebd9298e216b4371911ff3e0dd484069883ff4b12a833e3797796875cb8052caf3a5d4d159aaa871568e7a54f71ff8c1ab3a58f32d4ff9a330503af6722a3f3099c39838ce8cc45d9bb9f8a77ee66bf0423852cd9373f67f15246bfea039ca9cbd1e65a6a2dc52500122083ebd86c1628923bcc26dfb25216e94c2619fb4411f2cc7adf4e13fb1c9f1627ae91fc0112bf348f396fbf886b7c1744b5d7f0b28886cdea9f2f4df43d00968580bc25b30fe03159ca67dd7aecd0a3c2eca2e569075e4c56e93a90c1a8005fedac9e52bd1618430401bfb9d9e1fab599d9735a6f498a296ebc2a4a0bbc2ace02922f3a04eda80abe05b838969f796512b1817a7eb6c142ac4ac8e7579806a02da24e17583b19df5ce82978139318392288417bfc11f646a6b9f6dc322bcde5eefa2d3511d532ddf0671ca120d42595c827a505d2e6681f3a4b5a5d9481a810b073db0ccf26697635c1fda32f189e13c693cc43782b5b27b892b7aebf0944a9b064af75acffbef937583d254d704518a0f6b04f17fe6b518e12e54693f8d0ec2b78034ee9f4f368a9c236cf085920987bc18fe7bea1df1da3bc83fdcd0876543814a6d761e4a16401ef9534b2365cd9aba3a134f1469eef8f1828914794bac421a3316d835216e143bb3f4cda8802dd7235f37106de86a75bc5e68c5badb4add158931426c3b1a23aaee8afc0d843c61a2c4e00f33f3b5815bdebf89418cf74c82770e90710c2d53145c6f4dc7d1cd149454748c2a7448b75d82b91dba9fd6ab4e43e18b7fcfc27c741a9f38d402ae06eb8a9dac4ebcdcaa13cd4209f5957716104f6d1ec73566eb7a5fe9ac8be2d82c3fa6d8a298b3e82555ccf2ec0f812e0b6331482b4636522d5ae607298b07345ef89c9eee0761d89c87d241a34803f82f333295a7385abdd4403348189078a69c8a2aefd4fade2cc0633e844e7a4ef3f8436372e1abf16296e23cc85920835f925378f4e2224665af765879da964e2fca3690b2cf6bbf59747827061230753a09927074eaf0c2328cc1dc07cbd40b07b19d765b1a935cbe6168f9da28f06d960491ad1fca7baa3d7fad81a4c3025c596d84b3b0b3c56bd924fcedf8ec5c52b0fead268068559c6f0ecb05196fae9cb15e2de539f461b98ee77e573edaddbed231552ac181b6dda9fbf565dc0b3953c49c67ae32edf4cd451314ce1327e16c633e4c9c88df12fe450dc8bd23af780a5da9fec6e0e27df4ec70216ba51e47f28cc1b229b2ae292008def41fc250f7fa213878fbfd8e0a0b492d082177f542aaeee7e5ab769b1396fd2f57c23aea199430cee7c71199544c66698ec446ea30dc01e7c30ac2d17f636376a67ec287ad30d1354c0296bc4d3840026a47c8785b058853e4178e70bc007fad939d6750d08f01bb7a496fba844b6d203fe6655760b8c1c901d8aa439275fcbd67728026a877c443b09ca6de33c6e3a0245739138e0113ffc8c983e1b37e76760d16dfa046c621ebc8dede61e5eb9f58ff2852bf17d0f6d9b3e383e8f8ca13bf7ff5d6abe847561c6a7c2e8ec0521cf237cdfb236e2cedf07758bd65cd7f946f039dc2a7f38cf67e5b067bbdadde6461f2f7df345f6b710f6f1972535aa0226a3c04c075a98d1bf4e6b7e10f5adb48a8e389e9e1fcd5f301373d61620e4b11487b97df48c51faa4d535120e815d608ba7cfc77bc925f7998a4326454652f4abc0fbbc4a1ea70d405b42d597f7321beeaf0ec9e182c25c72cce7fd10b2418bdf7291b88bfdd003798f8f3f20e2eca29c62f8f8c57895765c9dc3e4460c5b48dfbeab1d8912ab8426e23f3a8d90cff8eaa3645aaf281a1240ad1d566c814ea5edab29ac35aafbc3259eda8afa43cfe63393653a50cd71cd2697bf66e9616e8aac17baf2a8ca15c167f254a3480ed7f965dd6e3194167a48fe4833c87646833be660c914c5025190e0572420fcf4ce205c027521bdf52bd091a71d70589a67e9ad386a850d5ee96321881e830b9185019b524f342db3c18173987ce319585974d393660568f04a0d709f1dd45a1ab32ab5bdda4a774c1c606e74308ba64ad86d73650dc482d078b30312e7c6bf4adc761643977743a9e264d58ca8b8c72ea766cd96959106ca6ef25a9ec03c9b0aba088abb57216db9773f1c68c6d72924577a88ff5e010de023444d2a5cc8d8c9b4604fcc2fb90ae803910ecdc2b05430d3cdc2ad6c1e1f34add0ec8b7e1d5994bafd82f4e4c41fe6ae0b36cec3d8049b2d32b1a80016bda6e0da7f12395925bac5cdd4420096df8075aaca3a10dec3dd6abc7f645d951c68f285f999e9e40e252e817cf03209903f47ee6e7a9b39cca3da16f9e35e5aa46a4b93af020953ec3e45bb5835730184d9dfd28370ea446afaaa3f7d7e1d1e4c711653746190288ae8c0f943d532d93849ede1604d8964c43557e759aa04870ffa755184034cdbe3f5ce7728b73cd0df1616f1b12050eaed64311261ed013510acfb3bc4c281cd43cc4ea583b4a266a1f6986fe0d0be34f74da93188c6283cd21ff8dc14411eb5fce8b82c3df5ae340b15bafb9f21e62d20246e1be4d94b95a0b755add9b77a9715d31b4c6494ef883d3ce0c261094240cc464af74b2a390f2ad64a8da30b4d3ba0573a05d074e8b559b170370d4a95673bb00ac007f84a7cbf3c3d2a849b1187fff7a549b26deaddf8c68d170ab3caace23f77717a0ca083d9d7da3010e2253487adc1a6a689c2ea755cd16a0bf1f7a7fa4b48ad2fca764f5d7f5d31baf2924c20712a77d94e96db7cbe9a1df0c0b9852e54ba295b54a76e739ebb0b7786a7bcab2882f1008dd28a37ebb8936be7e1d4969c9bb61c5fea5f5d2b3dbe2a2d7a13e3487f4d0bb8f23d76d1115faf079884d682d18bb74192b8cd4f7f4057e025ccddaaafbfd9383db5e5a9dd264aaa0df2e46451ec459e243c0ac4babfdf2911e0755f8f6c79c16ab5a034008839574331a1d90f5adf90ee095313353e68aebc1c51237f06c2dd957f3c71ae2b7b715831d95ec0a5d38725410d6994ecb3c674d6b6a74f9bf8d0c1556ba5c9650f2933de7c0ed78cb3a841e090cfbe9207e50a611ed3be38839871c588581b56f2cfa9750dfaf21f9e0e30ede630b7ca00227761d65eb5bb5a84d8472dbd51ff2e86164122b80dee8b4665bc3175488d163c65a94d007fd4a0f8e9a488ae43d6a8b9f86462ecc7266e8fbbf012d4bfdaa1aa3cb23b52145a39ed84aff3d0a81b24265d47532272801e3e512e5bc4cdb03ac6d9e5179f1a475e97263393405c1a275a31a3b880e6be6754345d91087f7029004251e529f06ab6712b6d6e63ac2d2b5e97893c8a9b3a8ccf068b8d238437e6873bf9eda2e990f9bcdc47729d8fe53841de48dbf6f0c8e03a00806e9118d452b7337f164237411306d5348802f746651ba55112e9f32e8a73057ca717e520d9c4bcc7ac1a3ebbda8a8c7cdc51c6c509ee7b27e7ad51643e4192b061ab9c4055f18a3ab52eeea205a3863d7c00f88e00c59cec42082c9e19552afa4ec250f00f7b30e792b0ff6d6769950490f7948982aba215ec791888693ce94b397452c0f83bfc92691f9cb86a200d6d72a9ae879cd98f9ab776fc804038df8f4f18d5730f00646992c125e78e372ba59960accc6e3de265dfc17d21d571c6049e1fad32388954343b835d9e2034690e43f95c4463e4a37f652ee4aca4dd357de27171c49a6ad9495ca5f5999846c63f0f0cb96433192c99c3db6eea22b0040aecb5676dfa0cf6c4f18a93f8e809233a30133c03de36c997e2f783bbbfecc3305809d9bd6308bdb99e5c801c186b9aa633c68d79d1717232ebc454b007b98e44305140b8687a07a527a460fad48054275ad79d12885b7cff293f71379d743ee8b0744465ed7ceef91f591b8df2302219c3e0ca0fd49324623789e65ec29e9b2fe975eca1c0aaed279c1c35aa8988280cee97111649801f75b9cc7a44ced741c719235d30cb4a75dd275fd4341bff9a874de65cbb93d471c2a14ba75bc8cc8a1c4c639e9d0bdb9563acf139fa1d1aadd0ae5f3fe580c682b74335c348a2272b3d6b0a0038380b647ce0b33ed80a450285fab36bf24191bd255cfabd6cdfc087b81551d67b874696d648ca19d89bb3e38c6cbdacd09306dda711cacf93ae699624362b4b3e863f16138187c51216efba7e36a73fc9257e0dbbc20933136358f960dd4c4d8d8e8f975209b62c924b35026fa50609b0ee5adc7e19341f814a214ac8ee85fc1693ac562db1a3aaa075e3b5ee3e8baf682ad774bfc89a55d569a999cd896e31541f7c4e1f40b19c2d872c1fbcbff7c314b4d722b3538d073488cb86706d9a3d413f9b0a38a12e810910107cb273a8087d2181102cf2ff812535f24d00fff373d28bf1322b992f2569bcd448fd86e35d6e38978edac295d7ca05a9ab6e5c1976d51e0b8408de8eac8affb35644a18a6b0b26eedcc038f810d8bb58bd58908ffcc702b5699095c909d5f810194686a22ceaace26daef537448d3922b3b79a321e7825d4cd127f2fe4d52acc9293521b1f5fccdcbb6405200547ff219034f06dee353e5ca9d3cfe41b6e2ee83184bba9337d0391e2e69bc647ce4b0dfb95dc0fd7c14727f85e16414d465b0c255abe0b3a63022dbe0cc4366a6cc5eeb8d44f88fd88ab7e195654a25c4bad894089faf08ed729cb8bb246c4c3b2e4e13efc673d71f5fc1695626e6c3e59586e72e93bd2ee5522a5f282d0658d3f9a6306ae4d9553cb2b9c2b94ffe7932f2c6ec7f80e2f1bab9f8a2ba7066dd3a2741a8d4b1e95ad6c2eaa6455a4ae58c5fdb01503f813026c0b28d21b4a8c62151235e87f1ad3bb33383060b1986a44ff6fc2ad9e22679cc947228bd4ab7e3afb5494b98f89f43dc178874d868b8e6648869b6493feba446011671c6995d83d3e901495751ee67a307e06eacb0fee93655c2964f77f8dd4c93600b2ed91740f45720539782101b0ecab9b1cbc34f5cd2e0738686bb05b3bf4278459c1dcf22097732ea91be03b00190ec4c11461502b4db09788139b5de5924a3cc9ea82c0296a3e0283812b321a3998ff1cb0bcb160676743068da49d5e558fff9a1e160342450d1285e020c52504e84f78380fba5a568b8078566a2972be19ead81cb4bd3228a12fde54134559de8b395c818983865285b304e0203fb33bb9a9ad14fbb6718fdd8dd0db7b21f0ed24d56d11a22c79f57b5b7083096340b37e499160f1edeb574d5aac2988b0b131054b4c885be4760b96a2ec4ef0d4db26b5eda1e23856191ee607ea090b6fbb30d01ee1c5868a8dc1908e4fe7d0ce59a1c6e3f21355b69db62802cd243852a8ed254e380c3e3cb5d856fa4449fae67a0dff46a01caa39f89bc1b6d469062ae5d97af01e287e8a2fbacd48515727ae73f4908b069dedbe520c9a09be3f4078286bd94262631763b71458d439817a09db5826cee5f46445da79782622b4422994a0910ebb8ff4bcf33814fca924767f50e162b52df47c4943b7c135ce0b5a4d739fbdf5ef149ddb7beb5609811c2510c5de27f764d057a99de06dba2d2366bd7df5443baa9cefc5a0c077147640acc07edd89ed61b4a2d8ad52ea17108f6e8150411483ed499f0617365a16e6be107ae6f319963e546f6dd0803487f371c990a22df978b3d3f81d5b4061b445b74db2a00a5b185bbac10c6ee1ec48477daaf2fb046683f121e897ba94356899e0a35dd3610c4e63a48a43de8f9b9d76369a20cd8fdbd4047f30f623120ee399b06a23b30e33a65ca9f75f36187e8068a0f1f638f9f03ab27a9cb93b1b5d392d0affdb31a13f07456860a9dd0c6acf41d0515a82c3c8fe19702e5d8cb03203506c1cfac9d96a70a41d45f52b589332e27f890dc865d0107ab4f4b4df69d27d7abbd8f5dd244d716152e168443a811b91333627e1252cad73a6c72200e5f0a9f87de573df5d822b1e6240077e6e65bace7ef75dd9aaa5405165c26fa484c629df7671d24725c52dd316b31123d2b1d9ed756792498f37e1e90e3723e29c0fd002178f6ee6d7b7923839d80369d44d3f95f4106a37882f3030a07b59a9a2816074a34d2b87acb5701526c36815e23cecd8b4bf2991fbea262a30066450a4f30ceb0f87e77abe6b0f748f8c4eb9e2a2260283ee8bbf3ae56d39cddf733f2c1c509711dd0ad082e25c112cebeb88a0dfa339fac38e90e5c9c67c61bb044c1b80778fb79930b89df18050aaf06bb5db555b34e5a773f5507a0af3530447502b8aca450ce2b6b0d30f2ae6459c84946d33cc75537d0721ad6f8e6b6ceb510f4e28a1e51a86986f09ee9498dc7ff7168d3fd48e2c8e73e94162da7c37ef1a1341e0baf649a379e30c8eaa62344f0b1813182a4d01c11b83ceea8b59bc1aadeef408eeaec88e7f43a7eed04de7df1a6cf0260cf8ad4d7b8ccaaae32de8a8e817f8a11880f4c9650ba7bdc033e84c4761b5a9fa6a496c6467d5438f2147981d0e013437125a655653ea2139dd9650373e15c03349d5d672f2b42b9304da0fa9b6f132e8740338e62944bb20c62101d0788727f89e643125e44e57565d28f4e06ab669376da5c15f0221856b4877eff72c309831f0e98ab007c09c7c0fe4b0a263d8a38c776088e246f3cd9e272404c6a0a1db80b8dd73a6c756902c89919661d71b021add82a0f4d8029a06f07fc17c5be3ea395d707acf9c1e0636bfb00dffa45f4576242f1b5339d08e6bafdd1e6e4aff8d6cfed1884c263dbbfc6fb1061b707491d24cf84cd765fdb31406c23beb8cc7e5828a195956d69fc4c9e200ccecb369519f90a6d5386113b6e6a3d7484a53eb5426b6a63e96efe31f0731f2be8623b7e4c9d1eb28f9f324817eaa7484c94bc7efd8ed926b49ded49cea67acbcd8e5120efa9328089996fed868ac5ddb65c78b27f0a09a5058937e894edbfd058d5fb4436ade1dbea6097bb67dc3cb36aeaf30650b01afa619a07d239cc2716475d588db07e9c0144ce1e39e060e109e5e773de394262c17a33d1981844763e04367f2f4232d2fe8e8636783c36cb8ff866290f8af9f1d285699aaf9c7d3636b98a5335bca60e424b7287536836804cf708b51f5c13e2feaec9ec3fd2f773c53a322de287257144ff38b52575b59a03cace0f7b6559ec9ce0f461f7fcac100554226ea74802b2c2bd2b6d985bbfdc79caa2919ddb3f37b161312cc503495f9291bacad27b742df44d15e1e470bb77a921ec035803830b121883ab53a21367988416c7d778a7fef5df6cc7a1fd643d29764f79da7cf4c6de4c77729997ac0f5b644878e5519e5214d447087c95527be575d568fe99cd0a4fc7c5667b16566d0a8eff1e0dace12028f6396342f8f188a10aceb07e4cbaa537c11be7561ff08893c83306f73ae5ca8e36fa1b841a3c74b838e382692e3e8de95d579c98742612eda691fbaff237b328cdc8c33ae8dcf6c9351173afe92bf2e1056c65bbacc97206243065cd24934381f3fa16b58802018428bb985b92c3470551426440db316a49534a77930f7780afea577cbf67ceeba8866ae4ad4514b324699e1629c8b56c4651a6e5f1727ff92e474038cb3a90c67c9ebc2da947e6a4c79d56f81818ce8b62cfbe9a73cd89d108295ff4543741a18f411242b65fa29a5c98853f37ff6aa0978170f9e407314d7334122c59fa626f1c2f59a163dc31d5fda0d6f0bef4d620112ecee6782db2b6a05477a83c01ba43d44f5443975f5a699e84a6110d81931d1ff633a7bb74a2617461cfb14ed4dcf8a87152f5b6e3b65ca7af2acc3c08031735c1009df165d5ea0cafc6cc100c60bc9b0b7a45b83855e198afa51ed64b0a88ece7a72f88770af5f10f1d37754f6894b9e109177d76e2f68bd518d032dc4630ace9128552db565c7b0b4e328f41c5be0fb05fb57042d1da90751ec7d90e04f3d2969b33d4b857b805614ec177d8dccd9e0ace010f5bfda6fe8ca139829eabdc4e0e9f8cc78dc280fd9d4af3a15326e2c902a9e968f88229341693eb87bb05d823bbfcbce5c3ef005d56ab28c1ff7e811b0f598eca781ca095631391d090bd8bcc6f25b3576cb38df82bc5e9ca3f3a8ef6716bdf09ff601596f0b70c96fe36a5864477d5ec81dec3c5202d44a2cf09fd867efc6537cee320d635f6255a8504a83e939cd21f5862c5bb43ba0b1d4fb8152920cc226e8b6c4c522560d9289917757f6113c215a8a2d935f1356f2df94e810ef38772f00a759c58c9a3df37ebff0c7eea54511bf5636501c7445f4daf378aaee628d2debb7fdcd832ddfccbff3110579e165ed4aeea0ea352eb47f58b6f38be39f50d9ce89a3bd15b83a1b33e0d11f4394e02b12b163b9bf3dc86276de9c478276c3672567263bccdd44a7a63dfebd35214e7b071113813075d80014305d106cd647eac1fe7e71da49646dc458912ceb16aed3461a5bbafc74e26257aad1fdb0cb317057a9c366c1d0f01683f57b92b0499b7dbbd03dc361df17e050e164bd6bc6437f79ca257c9fcc1cda230947f53c83277320f487ec4511de5f98be0c95390c66e06ea5d95d5c1b2fd39fcfd7c55441b258c20982f3a6411099a9907bfabfc67f18dc8fad4a3e944ec11679dedaa3959ab250b579fe21cb7a46300c754b5a206b85c8271e9aee3e4ca7b718ac0a0d64e7ff2f098a1644efb8a509c6499166cf93eae4c9a0b9ddda831ba957c4d23d50c784298b0e321b7cb9fdd68250d5f08c2b99d05d7f56cfd81a6b0767246dee80dcb0132e9f8271a94c431cff507e4b89ccb0ea9b60f9beeef9ddf59036e6137fa399d735b120b202586148975560eb4621255f601f1c7242a064309d57477928121e9e6fd9873c5717acdcc7ab951c5b7a7821ba3fb4a17a7c44f8d80f302d8e258455ef1f468da4f2ce474a62c8874c83c5e2ffecf5fa8960ed17f2075c692acac0c6b4ff2d4e829cb54169cf48e3b965619bfa04916c9280def7220d107083d4092cabb86738b67cb2828b483b0fbc2a42bd9f9795dc2a54aa2b063f2d5c76c01e3c67219ef0236a044c1c018f898799a46569456c90e720bd80d3dbcaf3caf7ba5611aec29cfda311b7acc626feb0bea04ad75c133a46b3a3b83d3cd1f106dbd92fe24c07fb1236f47f0a9883d47e8b6689a00f6fc81e0aa5f365b3f239ce940f6d47e8678b1d17b2b4b334a5f7b25ff9307d254288c44f048b376861265a9afa6c0e590e7933da2f6d9a72d25cee173e3cf0b03a3d425046bc892e5d3bbf2c77bb5c7d37949b5ef0039c61ce2012aac7646ad873183042dbeff790ad10a2b1226a79a7aa44ede2864852d9534cf8eae88de682a39e5e8fcd2b7f7a7f16eb772fa6267bbd98f24554fe7139ec81ee0db18670c9f73affe9c123e5f5815a231840b2417f084d9e8125a90cf07918f3c23f2b4e618f81dc59e613d9530474a092359696446cc2314b4cebbea37b09e6ed82f0bc42e9b2a798184f495002e0097f4bfe36e9b4c6dd1678777f92a65d2135fe41d577d6e9152ff8b4de1fd1ae88c8de95e0e57cfd17f8a064398c7c0df9d0144d716184e3915ca2f8f0ca9b7279396e17e0ed7fb99f35109c434f56934801b5d400b055a1fda44191018a95293c57fccd4d7061d76957668d37ddd091f0e90778b80e929b84e3c31c6b57c969907c58dd4a0c2a8d838c0b19064b0d286927d9892ba1d1d56d3f58536bebaeaf888ee9ddfdeaee36dfd2523a2270716ebed485a091b10f9d1ebf687adb016feae42aebe719d726d368f77e445fa4bd0ade6cb2cedbe47cfd3d609d9051f7f5552e36f2fc7eea3ee1de65760fc9dbdecc77a00d06095343e1fac16916ef348aca22a9572cf2ab98ea2ead0821af498fa4c9cf706a7e347716437f473eec276c7117dec296c27d2dfbc06686c0509d9b5fa63dd640e8bc5dd49bcf61ca90e23754d6657cd7cb9615b64825bf6520a36f3af79846e33e9449cfa641a0df1601e2f448ca6e1da2d4c12ea603e976077c9d438257472cf98cb7690f84100c39ed72aacca265d6e466a1d90173a5d8fb7beee77e7d65f87f738ac2f21996283ccd5c09987a97de3487e869eb52a8dfab7d16b6249bf5e33150e79be115a5a38d586b36f2fd171749ac43f262ccf66941088fae2a40acbfc4f7df503eb1b17ab0fdd1c991c46643d26468665a0a0a837da04419615960dd0d42f260855a091eac7f3befa3784e1c976ca4988cf3265193f64c62471489ee4e54770beaa7a48a3197cbb662518d45bb95639bb0922e5bd9bfae95a486284436ff4a709e16cd7e8b3f9ba9f996b191f7dd4796b638b10d609478ba7a671686dc953a21c8e03c8d1b452bef7a2593aea03e88d586fe24667882e4391a333faf1ffc3f169c440fea23ab90bafc719c8f1133be69951e969facdc453e2473df9d7631d464c2cfbfd850b2b4b954a4cddc85f9700865b959a7a31d694700cf0a3fbfabf68681c17cf5d976cd230b10357ab23129e779fcb8916c2f0d9fb483e0cec3242b03bfd7c98568623ada15247736e455e054dcb2483c154effdb179d078b35ede7d1585a3134da9aeb492ef95c00738287422bc306c12379a8241838036221e637565c1019750a1120a345925322fe04d4964ea9d2e1ea79a9718cfe04d4184c41c08c7eaaf8ab1b309faf0271de31a5cf097d1180a076c54872bbaeefdb9c93a098a65f04eb6c8f7ce2425f794ec43f438e835b4c0f510239050f80e0ab39ea1d557f1909e5f4f757eef561ca7e48cddc390fd6e3ec77c6a7e40f8de1f0c1370f07a5ecde7d5a02385d1b38034cb16743ba690a6aadf1b8596761e2c50c1310ff8dd412327c3bbb6b8a4aa89da2fbb463671a89322ae654ff4266b96a0392d408c5bf43880b67ee6d16e9ebcc387a58de7dfc1558bb2908e9b06360df76fe17fb52d8087c7b8a9e462f540d2799cf9bd3c3c69646fe1f41408931fc7c078a13e92468e50c45fe499e646509605cd5190f152ec591d4f487c8c40645ec1794bd26622d686b81abd45664f48c7f591ac993974b02ef8518361d2ab670e52bc558ae08bfc2c66d3aacd71c1b8a481d3d6831fa4fe8ac6cfdba53c92f0bb6f303823d7d0354c17f31b1f16ec538d2f465fcdd1a82510d4185906eb8fce866f21d4e2515364f339220dbcb6b0ab7d8bf8375210acc94c4fadc941ab09fe3ea02e27f6b8bb780b466434d5cea481cb59c89aec5b4138d9665f13f135db67162c815c69fa96e0bb4674a6b5e8e19680a8c24af305b87d1b3b199e228a5684d62dd9582fdcc77061444c18b58c292e85e6bd3d166364cc185c094310422fd92bef9c04f9e21102e4b8aa03781319c03ce3675add2b88b1cc4f8cca1fd02dbe4318594a1494b05a4467f06ad74d84d70f8b503d3503aed71d186c4e0011de1b832a4b1d411b805507297bc904530571201cabc31d0f4e9899c8ad48810c238f8e4c46cf45285a5f7acd3fcbfbef1c7fd91a7cb0950477285b75df09d712996488d9e664f86a93bfe7c92eb5bc4463ae0731ea85b8ade586ad97e300eea426a2882aa586dba8993f82b5e8716743f04572d73f6b8a29da606d14c61830385a55d6ecd9c4307e31203c808cfdac32df77e2f1ae12590158ad4d127607b5ed09df2b9bcb8f185150e18e3a2c247c1b6392bf9c8f98fd9d97610177d310eacc89ca5540c113fb00c49c1200468c38e406fdac43bd80f7c1b596d92bb4f94a7758c5d84afe8b488d8ab5ac3d7d446aabef9724e1f747dce84ff44c04c57110fd0a4a95f800025f4d88eda918380f32e14cba9ed1a2bb2e77d5b8bb6fc02e14039eb8491da23df0f77df02558f6abc7ed723223e5033c7eec5da9cf6cf1c289944ded6ce9e50d761ea824fe9edf596c80bf453a35ac311852bdeb557e22478fc164b172bf658aa214be51c546944a931c17d7903e7379e45624bb115f5b79c85090d02dd2bf23ccebd7f1ec9fad9ab47a62efdf6dfab5b40235ecc4ff6aa371cb82560b55ce167a4fe15c94d2c822da9aaa0cbfa1736ec00ae14410139ce6a490cf5aaa3297bcc25a3167cb2a0c055a6d239e5bf204e7bb533709b459129242d8e2c566ef80f76903f04d3193e307984020823924370d0c12761d27e712359cd25146411526ed306495455e29bd72e12f1e3a9d7a2031ba7784c36d2ab9c327e4cb7505361636c81db564a62ba044d6505aa93f1620d2f6eee415d95e7f0450ddfb30a0d8b801d0865788766375778c913c0c27edbdb239803a2c9b9cf4e8ad0675a7f07506a68b16c38af536f1f98603844d016b94a72ce421217bea78dd5f111cd43b6076d35a77c1d396cda240daf08ae7bc731324db24dccb1b1d4ac33e33ad527b3de6a9ffddfb82b283f546ca3a19d37c84ff8d8155bfb42bcdf909133feca4570305cea97bc9d013a3c0b0b40fb7b4b27703178edf0f7547cb0be25fa64bd7e2718fabb761c790f4a563b257410d47d83220632b9ff91a1aca32d85185eb39962b4524b905f182f509f14761f32e8d82fa6432fa0123e0e654f2d5751ea6ce9385f5ba107b52407c91f21687c4a1260b7522c50b9eb63d321c35f3a2802ebd1ee48ee578d1da282e9cd43b05df9b4854dee5e38a49fa2aff7bda52d8f8565cd65d25427c9b4a9f5566c58682e31df58172c86c1b6e7ff8f988b562162f6717e9c533580dc1d6ae415fd7b2aed6376fcda100d620bf6f61cb8faf5cb1c160bba7d952100a0d6247a9fb3b0c5172c9ba5ec71cd9b6b558ecc465adf904ccb464efa29fd258641edecfc569e4c5678c2c458e92f130752f1c62ce19b7cea68b13186d69b8000fbfa54210f0fa80d97c33833750b129a8ef3b951fe2681c1adf372fc4b239ff5057dfe783693e2c7d3e2b7d13a8ccc98682aef1fabf31296a857d46142694379be3aaa45d38062930306b07f0027d56bf91bb9ce52430d2c29aca70289a7326a67d408fa7e2512d143753f5862f223f553daba66ad1031e61e1b583400ec96bbd60901a0d121dea31a0818394428141cdaf13262faf092636a752225facddf822a1d85f89d9a192e61364a8298e5230464ba5a50ac6fd239b22e5a29ce7cf1fe7685afaf75cbb92cf024c0f149fb5066b5ce3653a14c1fd75f742a73697d728ad1aa1c40f99a08afd867c00a07d9af298c02d497fbc419e0d74b440b849be27c52b1e78c82436c2f9c7cdadb5fdf7cefbcdceb583a614de0a957ff9e1b91a2a03d78ef5ce964f7075919398f2471e3b4b069462bf416fd5d371b59c1456419166dba34694643a89b425b339cd7bcc0bd3b61270e50a1db033970a112daa9a02409307fc5ac719ea2ca262dd8b8f7660bc5267da13704907ed8d02beb18285be3e072e72ec78eff24733e63fc3f81fc4b2d48a51864821d61bbf03822dbe4b013f744a34b717957c36748596b15fb9fc431faed330b3c1126dc604ec14a8d9334066b4e3d931dec4b06637686a1ad4b71576010fb7ca88dd258050e06e346af9ae4170003371b52a5cf9fc477b47086ccb124f4c251dfc784bf82bc3d5fbcf223b84c0ec71710db34188abc3ecbac3c698992c6197b2037ed33cae1ee0f5599784bad8ff37df95e4c31b597d65066e1610ce827b954489d94920800b04431b5c6977abbd1895e6398ef7fc0d27f350523ad6874aaa9da4ba0ae984556490baed3fc03f8bc9941a25553cabb842580a822fdba96e1998c6a8bca4cf8443853949193ec875fad03f679080b4ce87918d71ba232f1c02425c5a954cf0809a1efd548db7e13d54602ace332643d93862f278b33eafb6a2b7cfc2955538fb61cf978ad9a55f8e2f854f88e1f66202c7d3d89d6d4d071c462c4081b32978c46241dfd7e42662425aff66c3694953222ab77474fe05c73499b52299d962bba06715da91afb341622a0bfda7b26e479ca6c8faea1fbbdb912bcee58b6a586d2c8e676568fc9deb2c47eac046710b2281adde471e45892be963052d418a6c9bdbc92bd4bdf768e144734b2fbba4cc392e8c6d59d0a1d0b3a70e5a0625020b112a5e220c6759fff38356775cb239292c033b582ae36ee8b74e86f9aca32e7f3abf6e78101a7a921eeb28e8b43e64a2d4786d25ae9cec63c5c2e1b15438848cbb22bacfc443ef256b4a3c4dc9f34a1d58fbc17943dad97fb75b8f95c24b12ecae29f6cd7ca59d48620ca4015b9c9f1973b03bc048a4a2a83234297d26fbdd1087103fdeaedd061c5cc6c7d40c2a93df23cfec1601866306f145ff56332a4a383367fb4c72139b9d3fd97e6a0b1a687022d973dca99b98e35a4ebac154b54b462107b33d6e8555976bcc9b8d009b6600987f903e92aa9e344b07ec675c07024388c2bb2daa6c645ed90b771593b6ebb153436cc176c7727b8bdb08fe954070aab08271ce56414fab98db247ca4361567924a858ae9203e08a99c9ab5b166c58c2363f96a661cac3d1e0b7c1ad4c2ed6213a55bea0f8aaa34788e297b2d8f9cf52d0dd844abefbe064b3a084b88c6888759750e1d32adbc094efc4d662b3bc902e7e9bc9a774ff349075afff627d6e221023c1bb53899aa8ac082ba27b10375e53140beb0ef706bbf06c2f0b82bb6e8c6781211ab4d9353d160dbea6c5000df2a81d86e7b684a5a581528a1a3f6205a4c6f1d5b2aed972a13361d34e5762387f211252dc34ce90cfd2778a2aec223f82329e89e9315794c2150498541c2822a088fec59f3c92f75f1f609d55a378993578300b019ea0048410a20c1aa25f2bd03ab97ff64b926650bcb0c92c11490ed9d8b6483b150c194b4a4b300bfa1479ce13b2844db1ee45f94e7f327598af9fd7a3d6063dddc76ab907e84759371b5762c39f031718022b98bb6cdd32d15e3f0ee79f0e363b6f38bff452a2f54c006332045c0b46afed237d1b02bce141f31ff6c36056fe8f4c724c3ee8751c59d709dec797d7963638e65e67a0bd865d2a682098efc3a9ecedd02c222999b4b228f301e1a81734fef687aad03ce69c9f84909c8552418795004a6ccb7312c852838ee628d03ae7bf617fdfef510efc9bd01e28df9d6cb98bbabaa328b39f5609da9bed04fe00a432233c5b375bc500b00255dd273295bd6a6f3b1a664e88813fa5ec35306cf52570ea77f4a5e135e48710c1136f526682de6a6daf4f513d9fed788399ecab302c6291909d31f57ac45af5a73c44283fd0e0cc5c2983ced07dc1935938c9820c51450a175ec898363599f34754516fc70bc71511d02e1abc3d71f4b38b86313c087d6d718b9521429e1f86051f2abe493368c91207940883204f7084d380fcc26fe5a4ec28904af58663cf1d6fc9f8ca875cbca284455c6edd9af5c1a03af95ca824ddd4777bac6f87983704105486a3d6b3abdc729d4c5437a7c27577db7cdcab55c59503e508cd4b9deb47b64dde9425367271fc20b0e020f0963bf08d1cbc696c42b8d4eda4c2a54df30c9329327ff2dbfa4cf5ce9f8c1432b9edcb51b60cb57948b8027849396f7e0e9395345178a6687f5809635f90defa70bb556a2d1b1bc4ba7ee8b332bc2ea110b49a40dd6606fd9d96c58db775e474f1da7036fc7e682eb961cd75e942aca2d5a44a28d7795d5cc54e8be6d5b84149bdba2eedeec1d81a7045da0f11fdc7792a8c2334f5878b4483793ab2bdb4a397b7161b348fc449f086a0a7c0009aaa358e3350b3e6c6725e7c355415dc769f00b112e1faf2ed8b874c5abc383da74b1900ee29c288ec67941504e632c0dd7da23cd12695966928c715ebb4cda8b35140542aaf1a1a01fb7c48df1e2f2419d070c57c35c9ce89242583fa512f7deaee1b1a1a7d51fb9587c1fc4674ee544f98476ffdd84744ca1369feaebc79756cf3053967e287a0e6336bdd25ec517344f1b4b28a09b6b46497ebb624ae813a2717c2d458fd5bb13cf945fb4b42e4d297321cc1338ff74445f61cde4e8b45bdea0a0ef28fe639e596d850579d8dbba72f9766a1a1c60b4cf157d671c800bef3829192f7cf6fc1d08c7bc62d19833e7a4fefbe4100480f5dca0a04b5987e94f7f318a9dce3b143671056ff45bee7c178d486853eab63076dcdbfdc5af05ed877da930a8e5cab698eb30bd439515191f3d78a260978686bbf3105e57f8d886f53e9ec479d248b233431b15e4568d74ae877d349d07bddc32ff86846becbf4903a13b52ab1b59d4b2296828e095292fa0500b5355258458dbd66b35ebebf56170f3b6cd362ea860a2f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
