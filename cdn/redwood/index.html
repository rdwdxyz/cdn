<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8c39dfc8b534e23e7002d6b703560bdfe692e89eb17f387bcc6d906aba21b8e132cef8e2b980ffa881a4c95d920473e02e764e8863534fcb7cc3465c92fb5fd2b66d171c6282bdc515bf703671333758cf35cb31369fd886406de8918fd698858223acc807f318d63a6bdc4226253fa4fb1673b347c192b5929da5ee848c87f6f1af28ddf9f4ac3f41d22af8a593f6fbd27fd9acc6f051944b1551cd8bfc8defb307280e57a4544d7bdb4192c43e13ef2a5902c66d8479197b6a00ef0841d09a7e2391bebdb8955ba42abbf3ce01a3aa63291e233b891adaec76528a9a5e8bcabc25c9fc3852be908f4f4db54d08eb6f0febad85e8d8bdc4adfce14016ca86972a926faebb6a6b7480b580d954727b6dc268c426f42c34bfd3dcfd2200b8f60e5168d82fc8cf04b6ad05de73f64c3df7b2ed44c0d089e4e5db7e889c2e9fa035e03ea9e1d7455505949224949aa13707dcf51fd886cc36dd112b31e26325655deda4c8582534dd6912e61c16044a2bcbb769c5d3b710216e3c39c2fe10f28a7fde28b93df208cfee13a44df5f2b0f3ff4b347d9df81b3a60f2ada3e590247406af4e9691fe46e34a3df83e33d8d56ec15ff79fece935ce595480c31724d3b744efb7c9d98374c910e6ea190bb6659f48689871739ed1da6b8f35298148d002578d0948aa0555fc91959a81960eb98c05ad4e317865f6eaf333e5c49039f22470d5b9184d37d100b1ea2f3345e958fa2fa6f7f2a00ac7f0b68a9ce5bd522396137af72582a5228edaed3c335c23d6ce14c2fa545859490d92bd03a126b9b2d7a0be2a25c36d8a20c6eac8020c195ecdb41dcbfa4a5cf01b15407004e105dc0dba3366aff8b9d282f3b180c1c0d588a6efe6a9b486e32a2d2fedd8fb50b158661049ca4c12f35690e05580b445c8f3c39b5c7f8591222307a618aa1aa8ae2f4fb3b2a111708855390304ce9e27419d7f15a6c58c6c9c79ef4d721afc793c90b494bce8f77da74b5076fe0312121b2914290e7d82fb8dda669199ec71a4e36219825c4c1a2daa69f2fff382fcf9728f388a99f0384780ce4bab2f02831a80bba7d37f5cd1e091db4badae495c192d2d3142f77e0249bb35d733711ec9798b58498165438022bda60a44ec3d5701bf519ead216b1fa01782e60aa26b7934e5596d37590bda597f70efb7e4479d4953233dc82545c5ce67214c49bef6961c57beabab7efc79dd8cfac6e8e47b1d100a276cba45178a27d22a3b89e345c73fc1ffdb96923ffaa57c917cd4dbe99bb0e3fa7243f902efdfb7722a1eae6214f62ca448d5b56422ee94222f0cee6f8371485fb0e0bf0e9a442683487c7e49b3d7ad86681a61124828a7b48b7d1fa1bf1f26789852e269cfeb2b8f78da302219042fbe13cc0e34d98e1c1cdc62499d5ebd0a49c467741e9ab0f386ebfdd44cbdd307a2396585d6cb50297d7869602273ad686cbfdcbc28b5d5c4de086885aefc89723f20c92addc0d4e45a7f0128b4e5acf76eefe8f2a458fbbf664a67de6fe6728244561083b174b67a55e722ebe6cd9877e4f31d950e3da32470e7961a5cb4418df7c913657d63a3f2438a16c018a46f26b7dd59530faa863fb76768af4a96a5e9331a84399ae004cdc5c040aa88c210eb14ffdf9e4956b5b74d85e81b4bcb30c5fe9e2d44bb3780984d0ad48a9b1bd29aa9e580b594593d6832d18fd59bff3cb9f293629449cb7a5de72f10aff2c72c2f2e14df8911e31f328a164e64e09cf73933315c9f64250810365161ab30a069283493ebdc640c3f2015a5d9cb846d11197339b60a16ef1cfeb1aee5a1cefeb8fa4371c5b0a8bcc6345ea4aac24fa2e011c1f16f04931eb346dcc5f63308b3d6ed0246a51058e0056309042ae949e277e3b2e46bba768a41222c1f11cf59762751f4afcdb3fd1bfa79fbe9980b2ead9ba6039366ea1cd4cb087aeb3860eea9246dc216210f56033b5b79cc2f7d92c4e42ef5839df9b5cec1d2fa0dfd21b19adb8249f88d58f95c31a588b1b5949fd2cde075b876c517c3902b82d38b83f4d3c67cc272cadd6fb98131b2d7456f5070d91b286d9c2d4268412b3b72709e13fae9ab56954b70d6d0ba2d741014e297aac3f6aa3ad3824dae230d45574efae5544aa808ef6def6b78bad6bfd6f5217a5cccc27923319bd4674d4a804c44df64e259df5b037eeea15ec4f874ad812d4a679bcc10899c83644a063367c74384384eba6ca2e84cc8414f22742fac301ab2fe5f231920e4b4e50bb6d314ffc68d568c32d333c5dc566bfba20a36ae280b990ed08f6096285319cefee54d708c4dc3c08658090aef8eba5beccf7bf697cc1da4f495f29e78a0cf187598ede21be534ebe364d9a5cb4fb02e32545ef6e8fe376866f697b2fd2f9f0d2fa5896e5aea20aad79b7e5cdba6c1d1e3d36922be9b18bd104aea482d77900f165faedfcdf17d2f72d7b17b28fe01605f7a0b35402197571f1551257ea904d47510194ce875eb0971042a3434d33e56210f711abba2ea30b89d01d5277a96a2147f42afc11de801a1d433e0516518b1918d3c75131486bc08d58742a28d818db8367033761dba2abda11d3a93e0b2f66915f41f00bb97121a42048282f95bc2ed5219edc83671bc6ea62ecdb97f55837b36aaab93eabc951db55f7bff3bbb6c0072a06f94673b03505bc496e2ac27a489d0ee732803aea60cac07fb4e5cc660e896664906ee38fa7a6012c3baed5ae35e37f71ac767d1ac239bac433f7b7d313def59913a431e998044d21686917d2f93a952f56208a24686e1d3a281d7457a63c78f2f2df41c1fcf7bf17e12361e275e424cb2279b5c25df8cbe2b5b3793cdd3813ceb0cf76c89ce4e4ce9021dbb7f240151bad387477246a54541267c6bcd7809a7741748909d60c60a033e3104f5ccedfe0fe623c57acbbe03e7ea38b4c2529c5e3377942758f7e0a8717ad3ccddbaae70b81d94d9c3df6757e4035169bcb8b9259bf6d8f5d99edb0095b5598ebba2c5160a55bbab20c4d69f02b3d6302d190d193d0226e1af363f2caa6980be003059fa7778e58fb184fb68ab886095aed9a3a3a4ac458ca031691eca1ee095708b813e47006cd97f6b41b2c411a785e8690c7831bb5d756166e7d8ec99cde85529b4aaa7e3acde70669bc660a317834ff0d88d17b51b272db39c45dbacbbf733198b9d8152e4dbc8ca15b555018ae6cce1227b97e6ea79aa9b4381b447b25fecf0334d8b62a8d74275428c088856be5ab1cc0574b10ff94a12de41f658d2b6065ffe4353a9f341a1e0d482ad52bc07105c019b7686c7fe577468c213fff93dd0a373aafcfea8588618471ecf0eb46fac8da4d160ce241376879ba63cc6acb69fe09c1e9eafc0d67826f3fdbd4427b4b479e6e429767cbdfa341cc80f98d331dc69f3d34594ccaa665b0f14f49b7cf19c09a8e322fff9f3b00002fa0be4edd71b7180f56afb913c2edb684fcf4d70da5e1ac96f8d2757d2920deff6a5c3a9a2ae80a67f3d6d51ff45a633ba945059b9b549d9f5d6102bb4bf605e8811dd05359565606bd10f255173a7c97747588c3dd17c1aba25f8c7905a89be1c7b080ce091f2519543e5999ac03f48068eb063f3fc4e1d21701213d3d14b91daecfe06dcb7960c726914c191951ba243619e4a77743bf551939dd7b8f9cf6c8e92cc2a12538beaaa4224d7c350adeeea40701e55810c00f29922944fbfd3fba73a5709497acbcc7f5a6afdeb143d3eb002c15e2ad9f93adc3623fe916ca50ba27da2e63a27d59a1441458aeb21541e898283a8655cc61ba3601692bd9f22fd8e8961474bc36430b586001d4f4c4f5e36e37fe1577c7ffb47d512230a497539ea030f10c4daf2131b65eae151331a5e81568177bf33c313a927acf8a404f1bc24d1a235d0e40d90eb120e683abc54c94a526ddc1042623bf94b0d5df1fff82c0b7703bec646211764f0107d87732b83a5aba301dce6e4e840603ee2e34525f852d977d787dead7638499a3c1851db805e284b53d1b0befd97fd71194a36798ae7800ea69036eb22464a9992b5bb0edce89521198bcfb7aff55bec8490e00d364c283527bb948ca937efeee6332afeb02b2e81730f3b45f1ca5b5bb9b873e8ef4a6ba160a1acb27f6af76d525a0f5ab3e30349bc1dbb73bb4e43b5eae52daf6bef1404505dc7dc4d398672c8734a0497c48c84ad5aa43b154fcfb34317078f22311988a57d877895c775184e93ec186f8997674a959710e0752576d469014cfca16a46803ce4bc870085987cafbbc70e29b0a982380fc5be19568774de5dd5a108bb855c93878c4dc241b919e12277450ccbb1ee4fb84a1b58739f266ab09d4ff5969eb37452204462288a4bffaddd0176583dd6e780ce6bbede6d6d5825734e88dfe57c230e4f7ad6820edba314fe90c708996afe7a6397acc1084d4751ea8a0e8affc26c5ae25d6a39e3aed4fc9f1327c0f841a4352618d4b7458177b312123bb2432087ac9aab8e309d8bcd4720e20e35cd01eed2807c466c57ee87d2c3ecc363eb0665bc57dfed43b0985b1320fb029d5d85ee0560663bfb081014c7e3e9def86f6af430d81999cfe37daa2eb59a57898b9fadad33e9fd8554ab3bb8cfd239f8e966f138ff1385a4bc1e6cb6da235abdec13d5c56e1c702d8381de9bef1e08544b5db1f8163b99a034028017866a1c2aa01f71681b1f62fdb24788e85278fb437013ac998b550f3fc7163aade6ab51767c215798b93e9887909a77148bf4e44dc556b5a38b773c56a122955706953a18e512bfcb78dd30d94ce1afcc3d539cf003851c504762eec93da7ed7a79634306ebf1142a4062a3a2754e941b5762a9bc97be6a4f1074882cc510886b2151e853424a5c0f6e77498ef252af7b08f87640f37fe4c87b8cd272c522ad65864cd59c63f068a26cabf07dcbc3fbc763ea97260dabd756ee4973d841876a643209969f80afdf696f4a495c8e1373706fe8df73da5a2fdd0b921f4fd7ca6fd0383c932ba0ce5e473c724aafc1adf8ebe372cb5375ce27a9d83f1804c0bbf1f3fc423e54b863a028a2a0a51703ac170b798efe986d2e95cb415844a489b84cf5fe89f06b6cae45b175734301cbea564fe534ab351824bd7f30091487d68871af7205564fc3a628f0ddaf1044af4cc690fdeaeeab9decf3f77e442d425d2a8541f03e4d69007f0db98d84a9b086c4574ba7a42733c5f56891ffbb2edbc94fae178f8ea6ea3dc80b9080598de7df20cc7ed73c8044b2921fc137a4bebb63fab1078c3cd22c3729dd78a97b5602016c50a58064434d998ac63632d1d84ee3801dca0be3e2878b406e872197415a689bbd1e64b0f56c7dddf3186eb1b27ea427d1dcc1d9d612b9187836208a05fbfae102fdd949e411950bb843997a962a38f1e5ec361b0c3281f53f573a7211c7e5361fbc8360553d94eaa21b50cfa6ceac74ddf471bf6e948f5240bc5a92706097a2410b8938b67561ed0a4f29988542b64819fd0116633369104e43ee295669e25ad9d54924a211801a75f36fcbf144a67d7a482cea1a4fbe6f2442f6fc66572b86990586d8c5c947a8cf60ac161aba8f8dbb69682243641cbb0097dbfd2636006319f6a57dfd03830f1ef9d09169893235b8e853622b242f07c5df791b7aaf4de4719ccb9e32498b3c282ac613f55a9b9a24affebcff2d38bad54c96a9aea67379a0979a4bde239c9c66b31d84f3592c85f536d645a52ea0585a1fa3c9bf5c781e1b10f204118341e49da5c2a6350ca3180653e477f0b7b745cdf584f7ae1fa2d90d9f9bd77c9a8cba7c0e9b8d7725b90b627026961992caac362f2cb0f6d7944ceafcd937cd424b0adb1ce7e412479ae25372c73ff8534c98f922b44ef8dc253676d8feffa9caf26d9790a5a0a9cd42ae1baed9be0a29321612c848ecfa1bb554ac27ec57e9cd16069600bdfe69316124739998a779c8c03802128904f8bd20788fc9cb88a958254d90b21659cf27edfa59a395b951b6565a0afc09626925918f1115e83aa89118ac2d3f8925ed3e4b2d9a2ce97c0d93daadba394360018bd726a1f383d8554c19570d9e459853c01b04511fad5495d6c8b9acfa2cbc596d03948d3f3e6cd1680555c89860e32b966ae2ad3a6278fe1aacbab39715e54e9b79c05e33a28b9b181207b817bd6c9b3323b8e777cbbec31b4d26f9495aa9b492a365243f4b9d87b77c672f4e1dba9670eb993486f20c0e3384713af0409b9fb8be517157a6f4fcc8ee7c625b8861ebb8db1b5d757d9d683e126aa023b2176df7156376351b0e37c5f5be17c1a4da390a785d362022ec42ed9ee1457e776d82dd1fdf02cf36a12e3850485533dc94d9ec6b2645eb016054a1dc412b227aae6149c216f0f4a007bfd7b1ba1c87f4a1781686d3930dab360df9591230573b020e17aeb74414992b6cc31985a9210975ae72cc2df5c596685c8cfb950e34edbee1df87518d3c01fb3e43d46bac6e0202cd2c9c36a2753997155f0bf3c4a3e7827baf82759d4e72d781b8c22f58c51a38b77318ba6637f4603f9ab7878ea06a7de08f49494cdce41b7a5ddd6ec4c4f8b9aabe3bdab2bdea3335cc44de12a2373ef4ba00ce81ddde51b839c8dccd5f1bae9ef16086b950cf5e63ef6aea2d4524bdb604250db5580571fb6cfbfec5e15b1e9b9b776ca597a1cadafad8978d33e24f966ca040cace01998c6b1d6b8b145704c66f5dece8230e40f7f6228c50e94a4c5ca7555736ad81c197017e81d56f78bc8525286df334d97246ea995fba800e70aed808325db004da3eb9cca32f25aac99ba20f566a1f771b93135618e27ff3566511179ca5c57bd512fd997b9f85a2da8a89ab583527cc37d1762700e833810405d32db49cc1b4c9b3239fa87426de28c3e7d1f58427be2d031b4239809ef23b81f51fff8fdd882b90f26763379b3dbc70df67fdae598e7049d540fa5eefcd3e271a607d341b51538395f9fca3755c673e533bb30813b16073c2abc6e3ffc651b2e2c6575f54b20f3d28415612f50a24e2195e6aeaf4c314f9fa4d183d5dfdaa307aea11e774cf7037c922b5ed58326df798e9f5a779a91f80832230f7bb0db35cc53f1a9a0c1666c09fb2b684155d819f91eeec45c34ae36782f0d3c59332e2e7b8e2e32639a2cd4069277cf32278f0fd3f9b2d73727e16c8ebadbf87f123ddf996cdfa026e1e66caf9f9ef95e4d4ea21c714d1254497b3bb7a9bcdcb5cb5f61665c25854d9cffb4fee270c0d6f7e1c6acc3cd29d04915d4ed5b024668ac8fe5355ce53aac9c52e8b1838fbebe8e30bdf90b3e0eafa6f8ee51bf793c270f905da77e9d72751c1aaf3d90a02bee8552998ed8e502c82c60fb67b179c17a1a647982466117b5e84326583ff0da1af54042374448c1727b1b2a203b7d112fae970ebcd5329f2b852c99b6e6282e93c1a7b17dbbbacf4a0ea92f44ff98bd182b4defce009a289fb16dd9118e55db0c522755a5d519080330a1d00e7e46b64f6dbf056f4ad7732ef8077ac46431835624f2d652c819df3271b2bb34680bf580a2e70c9eb12ede29a0c04b20d1d14b7400a19ef955c1ca409a965688c781cdc16be1b021cff36c5154d92ea2bc268d9555ebb9224c4a58fdfd01c1aa0ec48cce7c81860904b21539a4a42a93de28b6f3b508b582d4f0332cf2fe41218e3933f64221667db96f9f2288023e482b773983abd0d1df79ffa3046b4be204831906bb9aabbd0f39dd2f7db5714e366b0b83857caf13b7e95a74694fc78106bd81b8ea2947d24c8a4bce5e569356dc29945f5260937323d693d93843d78289dbd3a8fb5eb786e97d84429b9a97f4e25ca8e16ad145ab2177afc8c7e84146c3288833f847133d49209224464a80d94da5867bd7b5f23d2b8f93545336e3629a5b8965032252fb7bc95e968b6d5424768a10dc0799929c6eeeb338958a9998ef2811d315ce8dc42bb6ad928e4bab5d63e4e3090716824e75c95207e4dcb26493c4a167ba8b663af8f3bbe5cd13c5be1947d8df0236911038f15afd3fee76bc637f6520f4ded186472fc8412b26223b7ec1c5877e8fe035ff89841b46037af6c2922fcd77a35adc57d7c5cc1c038d22d93188165febcc632f9a610893c72912b97cc7086a65725e2653716a783fc90ff09f59bd1ff8aab4801076810da0e8f46d95181b0a4264f3dc325da861c750927f213f35eb6d8a79722eeb4155b41c095247a3aa961e6cf5febb5a762dfeb63862a79ffb34ce4f093af1173cfc1e6a028f57f861778663b910fa0b9b6ca64576f2c4b2dff70c3d2793e5db6c851efe1545dad8a5f823c89c001b9636dd9d0bb9283df7bb2bb88ef6879c02b064b2c294686580b68f070d91f4438e52d97dd472eb0bbbefaf0a0f45479596d8c1a8fa111efbb7fa57076a1ad2f81503b266d2a13759e80394c42f9728ac9a5f5c42686b1b97a34f3819b1de8d387b38d1bb73808012154e7bb2ebe2cd88a2ac5fbb1c1262e57bcadf008835f1fcb1d6f4831c98c39769942ed915d558e75e78d9a860a7184648221096a56f88aac0894edc0b824a36a82ec351ed4b2cc4ac3b0d42abca381e786e15423aad7436455664a655adaf1fba6402ae42bfcc20161980c9e717a07f11af29347b601d5853533a37738bc421c2fab8a8624058f0675e0cb7f03426d11ca1568c6401dfc80e92ddfa9c5521f2c4ce180d914b681a04827d3015ab96a199c8d87e36d86514c7b85ef494cfa8b955db36a15f4a633d8a7ab508612a1d9cf9bfa18997ccbdb48075d546f91dc73920673b4a79682ede96a3c8413816001c108359a7858744c4a3f057ca487e5302cdd3df787417326631e92370444276f31046a7ab20c5ffe656745ece799dbdd13253125db5e2783d1c3b6f5ebe7229d9c83f47f5a68dfabfbb47b1f759f1cd4e3e0ff1ff9afa61466313360487dd358cbb1f14ba0acf7eedb0fc59c88410478719651908ca8c13070e5c190c6e050a689898aa0c9f86d34755cd0fa2d245ec166228c6472749acc087922dfa3bc3e3df953348d0e1721fc8ce9ca69e149214549d57b9d0d5d7aafc872b68f8f8750c1fafd09bc77bbb4d4a323c4c1d2857aae8b878eef539e0dfed641b35304fe36e54221691672290cded4b06fbcb8fecb38d541e4a2f4d181bf894baf2cfbad1a53b2932544deb3b9da311e2f4744e528487add795227fa8d271e0d091a1e858b895f02ff08337dca273e1480e444153809d94694570fae9a4a93fc25f45b511a780339f0bade7ee4285dc2736c2dc730b17e2911953f197bb31f6bc05906f9045bff10eac9bc06d6a9f8053b72bdb3650ce79e00467424c8381014e74da7571507317b08866a3895ebddebe3deda9dcc75382de4d3d6a8b99cbd46bf991255f9a89444ade4b66bd4d2e9bc61f4f1568ae7cf2ae3d48c42d2897fb5565615d4ddfdb2d351fd800a34bdf960d0f4391625105966ed2dcf9c6e9ea12ecc2901c771ea014a34628bfa710f7b90c0b9384e3ed8d3d692b83929726632c82e21efebbf768ae1f10eda3a1ea5b419511bd40ac1ee8ab298f52fab18aa3a859afcf86423d1997c4cc46cefbf91b100264c3a6ffce651a7eaae438cd051f9876c089fdbcf595e006abb4b9dfa7496cb2798b8f042a7017fd51b33ee16b1296b83e1dc203724af673825960ecca13fdc5feecac81cf8b3b4d2e66bacb4425c1b60b04ac44f800af5d3061cc7ccfb73a39beaa1cad68c913db513dab46e5990a0ded471cc9b68ac24a306fc7514e116fbc08cf7acbfd628d4cec0f3d5523bab774bb5601be29bf1fea5d40bc85617fc00de2b32a0dc3dab6e1bae3bc505951601ab3db4e13ee36d9ec2b9262c3ff2666478ae2926183eec5a1ff2003cddfe3063f0c4de71dc7e3d1a0617e20dddfa26e8a2db16d4c8a1b12b2f7169f60633818ea8c0ca074057a55985b38baf47ac33d90fba0ee410e273d2b46d645f7af688c606362030227de93a7be850b0a78eb98fd99746de12e89ea8cbfe8b97f61f38b9670ffe3f202cf35e5433d4e5c171f0dc6de0e0f89a7efb9f53ee4405f6ba2effeacf04fe3df349677c2fa8ba3ba86858affb423b52fd3bacfca5d8c1ea03390151020e503d3561ce9692bf3c8699ab4a279579d7dcd9fc43ca2896248d0db7249ed90fd2d22e1f2fbb6c788ca942a7dd24023123bef7a08667b3e15b8672a254bb6699386b85d1dee4b5bef622c11775be6d2f437ebcde7a606620c39a78f5b93550825aa2c447e9fb45ba4b6a27abc260bf9c14b16026e53dd92a66feb6d808ef082423f096cb07630f88563a96eaed65b314abd30871c55c93341680065b4dda4fc96f57800383ff80ac0da37f12336ca91719343ead3d2aa36988e7dc6dc214ce2933775775d9117998e9912ba9ecb108d53dfe28fd6c921b072b02f997356cf801f713b3e3b7d7423265b066c63a7ebe6026eed38cd034ee64e842498adbb738e83ca839b7d1e362f0a5bd34499686ab305854001a7c7c7094afd4f007a4bf6594006b4ff302592ef58db056182dd3ad6a377ba4a9a2ebe59d0be8de4d37c0d18945bb6494e718ac7139aa85902a6189d7b1dc8fc1bdb0549dca6d177772bc2bf361b400b25a2ad9d9ae38e4df33a51d375ebd15337e9d1c876d7d40bea0fca0497cc0ebb0300db2fe282bb8942178e635ffce78ef94005959fbf9ba24d4231afe2bd26d63613258134359cd0ac3a14d57425e055a8b2036e8ad8ae9d32fe25835377d385b942d4a238a3ae077fc2191f758c6fe77033fc5a284c3f39f27f5c10b47b940c8ecff3d3e000224c5376c7dddf729d932a55cbdd5592f4dacf698c6e874a1c0bd043b9fb7c25afa1d568b16781fa1c92b9aa4011ac5858455a0c1f34b8006e16d224adb61a8085f1134b2c15718835f91af664ba2b84e8bb21504e92a4687fdd937b8dd60645631c738635309b2f9cfce9acdacea8a1e86328777b70fa0375f42c8607b8e6e065d0ffef6acefdd87b21c50e89c260459457025c3e8418d5935bf60d37dc23dc7cf5fd98f48ab4b8ec03a03c2eef3b141edbea9177fc0b542a3484bbf0ae9c94503de45d19c415e3f36de313803dab78ae7134dc414b8b663c08cfdf848cc6dc4b32261a9a1a9991b121a9ae0ad6028922e3c509c06b921945ac907981d824cfbc4d2436ff099f93dcc1240a0448acfaf6c961370f9fefb387e8abf12cc539ff0294d8b4d03d04dd284cbff153c3ebc62f01f3097669208b56d75e6223bbe5c3edc69246af1643defbaa27e41b4127372e9887d6ba51add2a0107a30a9676b33b29b4676206a7337e43dce72553508e507f5a5217c708e55422a69e3908edddac6c757e04137217134f5bd2c7f85b2a010995ed7e90af2d5cc26b678f0d49fbd8fec5a79a3356f3af77bd4b4e31ced1a90734db55a2c587b992771bf8f071afcfb55be2e87d7e43001d4a4470ee58867a47653519705c925869a718ced050f2a96daf117732accad1c3cf8cce9169e3b2dcff19a29fba7e950e3856ab83926f5f830b5e1d1ea5fff669bc9f86e94c0876eb91cfbf7e070cfc6b90694a8fd859caf058e5cab4b88d55455e3b2c76b688365e381950e260cc8244b163d972ca9a01d47de2549f125989bf69c5677fc990edd748e7fc1132c9c8c45a39c6c3dd26a60b7d8a98ce07ec6c501f8ae5d6b742ae05cc53414fe6f77b5e991baaecef27328cf8a9c2a4e2f846ec9776758c28eea92420397772fd6fcf2cc9e39bd44c5be8c7a808189699872f42c4907ebe2a60ef1ef95e93a7cfcead5106e9916714d95bb9d3c6df3de19c31ccb43f1b76bc92ca679d0193cdf41a84402b8c326ff1b4fbdb1dfca3501a1b6d59ecc7768c140247d3ec6731f1282fe108f440955bd0fbdd37391235ce8c959eba49daa8195f42655f285bea37cad68f5ad97ddadef94ecd9945b17bce3eba34cff06141702cc06dcb48c0ede2a8aff3bf31ee57d40c3d648e7dd2357c209713e60a3a050e9b9876332f1df5bd713bd5c6e8bcb2c5d40fe9d5db553ac94b90a59aaaa9bd9fbfa1125a70d8bd98fac38c47d185e1345057724446f20d06db0cbaf515b09e2497fb518abaafb7f432269d733f7f711eccacd87503f75e7cf7fc77c5c3ba9f9b5bd63d7cdf4cf42492f2ae9e77f6973d4589a9219b16a3e3254fcfee56e53aeff201a7d6d1f4aeefd501d12f1e0c11990dac62b95cbff0e6b3a6b421b98a4bb2ccc6c347504cf375a9c6c537f49b9c7fd00220ffd0d1f00ea9564b0d284dfa661b42504f2b6612e210629bbecd5ebf7c79676d8427ce7809369330b08da45539468ac81a7b3f034583c8bac5a176712358637faf0136dc3a85d27c3c884769406b12383932b3ebf73788d13721e191de20e0e4aab1698e253ca7f1a117760e4beb75debae9d09b569d5babe7de9be8f3c79f117caa964665f3d53c126e034ef646a7a532f21caf5b0673319f6057715d690c323bd62929607d98cf11f90ab48e03f679b12b4ba22310bb400c9ee4eddf5f864dc0dc217f26cdea433783e8f4827505a7925f0d77e5b0773103882ce8b63e09cb33d29201e2834cae295a7755ec2230f9c6c5599877b9e6303802783758e6f867a8999a453429b180b5a7a395f91c09704b7799e9f07857bfa1bfc65cdb943c4b8f1b8f03bb19c34aabb5adce21acf06dbd6bcccfa8f92bd17efbb4a7d1bdcdcd7b0ea26c7841150140dbeb213a0aa29090b79e311599166637f57d05e7dd2f2191a144da2f1b54418d64af250734aad492f5e75d311811a813c7566f8d83fd9c297fe1fd1683830f8a88ba145b9044ae17dc754bb665f97fd8408591fddfeb18e264cfcd3d8c2583a8e116026c7d21434a34e730379c9ec49ab0c101c84c567b155d443dac7259516b515455e1b4cb455446e26292704888c23f24933f59058ae41877741493cec02e98156109caf8e894878a17e524185e5727146b77202f39688123571b704c1f603fcc70a02fda8fd9c20de9af7a47c97a460fa4682ad6b469991f5769e492effb37bd85d78a8c2f311aedb958cd6ffeb92aba569cc23b84b385aeaa8199fe4d814dc898606bc2066ada7b9f6ddcd32b1a791a25b730b7bf626337adc49a89d6ec89ac1e0550d4de3a94b2c42ee90ba9a843c0e78749bf73cb3d68d8e7f972b5ca94275a374ad7a1a99252b8bec7ee4d1b50061d470fa6118f251276f04066f9d1745ed54e0bfcad15a624ca91146984d9c7eb348282ca7bbb9b1bd5cc506e7c13e0b2f614362cd74c30bc68974cec37440da18d07fe2a1ebd899a093458967b7fd37851a990e0f936da458abde23ca06bea7c3aaf3a560af2fd78201a6f0a23486388b674fc8e9a97b58775ac8fa30536fc428d28c414a891c39eb69addc452adc4a2d51111756cb9d58fe880781dcefa265f3eb0f5d6ad6cbad650e0df446a52c145a98a04ad41cddf7ab40c9890e8db3670d3e00ae5b48c775918dd0b385083346a25512dff8a3dab563f37998f38b4554a8e6e815bed1df6b1b687c20d0bc6365094f094d1ef564459b8e26fe90c52d03a826348104d5cf0bb2ddf9ecd757724c5d89c334b03ea68dbf757a6cbc4b3fae9379a652444b3de6755072911056d709766f6d4430f3efa0e10d97af656fbcdfb276a850a6a7924f1e96b938dd7377fd6febc794c0e33d508371d233d6fe1ec0dbdbfe70431daf9c012d5946aa697c6dc6cacaa40f28b323d1c096e23cb9bd31c8a229a9c339d296026bdef732e993e8feb110c5da4cd9222f5cce7f4eeb9cf1293af13220343cdd1bd0efb9143d320296e8fc4d42cd26572b49a596536cecd9bc2b250a5dfa7672d306b1709a4de826936de858a461a661b545d4624203e67ddec6f6a9ea9d579feb4c139cf92b5402d24815f1fe985a1929e729d241bcf3c507fc82cc7cb8af6f18eb18fafcf53d3508be315b5f0c972d10faba913041189437788d285b3415a91e31fcbde7d2f3b7b4769b5e849a6a792572f467cb5c294da8d1047ef3b375770980d26cfe12a9cb38e5a2263ffa137d7fec9bd5a83d1e3fb5f492b7273678d666a4760f7b9e0e1ef571c38b17680d8e256a00beb019588d41302df0d1345094d3adef86d4c3a7d27535636a1c184a42eb6c35a1cd91f154e62764a66bac150f6c8fb8987f8310b31a94f06f5e2db2a114d2b6066b4537e801043093c0800be88ede433c7ae72b575b7af06aae0736772f03c018658034ef481159911be3ffa4efce2e8c282911014f7be2d40bbc66bce58c4d380cf517455a424ef719276400aab129785c1c0e4a9fe7fd7a3fba4242aa3fac0e277ba3328a5505696fce52576658c5876de505cf09dae914cbb430e99acb95405e992774fb389ba54cb1afe39cbec03307f4060180c70a69c13a63f0742f477fb3d3ee45fa029b957fa8c528233c1f1d69cbd6f85d7898e120956984cb9962f4a37b118dd557cbae54cefe700f8a86c56eadc7248ef2171282bd5022e44964c10d8264ea1efb4f5285e88b8213a30d8f801b3340f650fd0b2e24c7eb56b97b1445f6d0b619f46d6dabcdeb7196ac6416658f4ba49203995d9807a052cbcf6f495219281f8a70928ab7152ba7f711736ed5a92141346e07f6562c797b8d443d560c07711eb02558f44a450187c8c7bff3d74ec77686a23eaaa7b398636cc2cb80b4f1f338436b97339d4d929d126d62f5c13d703a44e771d57f247ee5fb42c848e515fc4b59f0808173dca775b937d1128969563fe7ba0d44548f0581c4b84c279b2e089a192b54eaae48e43885e9d7387cb6873c940e6c9ac133b43a6ac99940bdc8d9b8c9dfaf3b0227f68932aafb994158139f96ec610ea9f14e7f4d1bee2d4ebe5d621a745539d8a6bcf6f3ee925e67316745b8f6f2343f803e475316e05d1476e64b0eddda0930e20194c5c641cb62274cf9bf2b22a523d36f63cc66d2801cfbd806729bcb53dea9499d02261cdd3d2b7ac9cafa1964b1aa4289015e460d18bc8f5b3b7e23061993591af08bd6fb254dbc6a0c1789f3573d77ae8af505f383be9d1ab7d7a1a495ae0c16be095a5b030400e4dc479c54c508af8db43a3e42936062ff370ad4cad33880f1c3892bf11e9671ada8026415dd3570f823e422193a9cdb43486350fffd88d64218d7b876bc2c369b1ddc95e97831b4e147aff83e0777f0a8c013e7aaa2e12e070db10da35038970edd1ce2d03fd83f12d1bd7d18b23c0a186f50c8d3018b510ac4dfdda7ca8f799a1e06c343da758f2cbac776964fcc05e92637b4612735ad89a62c73cc7c5413372b859ef4971b3ea813db7576bebc4687b3c376e919642a7055b3bf29dbc4722e47eecc343373287b82fb9277f7f15940a90e33653dbd926bccab3f85ffa4f354008641ecceb76edf53ad492f7ab058b730075d442919249b3ccd79ff1b0de7d89337fc5318042ca71059a85faad4e145cea26a5b7c3affdb129e8c06ea32262b3df4f4e218f632780d119f7ab644986bb06a3f7d3d45fe95c80a7942f66ea4b338c65e611e81a996cd5f19c169d42740639cfbaf6f9a74343a80b02de0ca753bdd5d1f5299859d8bd5ac7959a081e3019f8c9019c5ac820469637b0ad9101e767eabf423593cfb6d49edd90ce225a2615afac03cffafdc5c3f4dfa7fcfd269fcf5512fb464466d42e3b36f9680d2f16fd03ce3630d6e7972f0b04dac6c50c63fd8b69f676c6733b6e18803c0c5f8c85fa76a4a69d9501c711fcd9a72457f860c336c10a9cb7a8e7e845c4a68da77fa8c4cef99a67527b28291fda7196583ec0c8d6d03d4b30fd994b65be9f3e83b2445fe771163546bc35057035fa0784b984e91d415d9a7af0e88016c1a739b239b3d307e67513492aa547ece2d0459a8b3aa32b676fb2ca22afc7a8ceff4cd831f6425f7b9ea5f29ffc60724d9c19b9b9b401fffb5769918c8cced1116cb8af478fea7d6ebb05e496afd9d363e451d0593e6e00525dc9c63d5b3e41f92148e4f1788c1aab4d7eebd1dcae101b3ca724b4d7747ae89949c07a40aa124fe1de86ed8c085e5457cb18c886f8abe18b5d1455e984de4937599571da8ff193e9a359ad35c9df8eea227a310f1086856dd878f8e06ee4a22fac1d0bffdc85bbf888773cef78050e82c18bd318dfe1365e8bf0faa8879de20a4250a908ca62689aae35d169b510de6c6e0dcb097f769b7eabe4770af2f6259176738da3ad75efbeae8de77f4b43a00aad8c19c798d29aca4e66c194d20ee4e306df996b07bbd0e81c62f546e108c95e3b0cae30d1e78460cbd5d5b4c70a0478c23edc5d868c15aac1a061cb96a5bdd5e92f9d8ee475650c06c63ec9ad34cd8a5069c863a8e37476960c861d67dca9109d22e86d5dddacdd461c7fa42248c3a225736139e0d4c949be5bbd6bb525c6ccbceb474b98383d9b3c4d9f279160c06c6f49498950cd50fe5c97bf9063314b8d870bde66560e0cd6371fd1469e3a45f461567e17fa986f1446a1743731acf3119cc68e4a8251a07c46cf82cf147bd1ce9ce2c90ae00b639be26da405c0e0b41d949cf21ea19bbd27b6e7bba7ba3d08d63d1633830e588f77043ec41912bedea5497c1bcd556bab5228eda22494c30d4820fddd680b46883a5c33632418e31141f422b794f997b985e1dac9649e27a70d6548678a367a982185767ac42da9954fc2fad7e73ab403312e1ac601a9794de8d83694be0ae908e75516623d6e4575feffc4394c501c7ebdf4f2f666343b315e7ee2d2c539e4e5aea5d17d94050933221f139479837c78fbfb7817c81206df8f7eda0ec71384f8829a49af59af39add6423d18c92b945d34c2ae6f68de3f9363a40c704919846cb05fbe0ef9b9dfa1419383d817407e3daee0dedc5110457d829e0bf672d734a46c7fba6cc2a02bcd88179ca05045d60f93964f39faa907c134d57ee09e83c3b661f8255cd3061e76ad4aec98daf37b75f10e271946ae281edd176221fb354ec9c1a83f150f69e9bb6fa491f74431e5987cc4e0162f4b1aebba59cc47fd90a0ee2b4fc3296c20c6211b5dafa6a06c1854bad27b05559d44adfb740fc7b046d5e91e5bade2a090bbbbcce483a3b3230d2d70c0acc3d80ed387afab7884ad2a8313e182e94ddf7d254bc699e44f5e3b7f1fc291bcd9dbadeb2b1c0741487effa7aeca5419f0f58eee152805cf6a2daebba68878e02e3ccc13bece01e68419deb5bc4fbbac229dc910ae640450a9b938d7f3a23d65170b0720456e79741b0373a068cc9bf6308a48e3f725b7793118c02dc624181c8b23a6ef30ab7c96b10e5290dd8870429bf56c6502aba43d78f4ed511467337ccc8e18e19d2e07a6cd8033b107a1522566879cd3c5e651eb8569aa0cc3efc19f3fb24baf167da31fd363b4676f503476c1aa90ed1306c5c56a1f982f65c11a769c8a8a09e0219e270a49a181c602270e2f20b970c47f00066e4a05e4db1bf09d548e6aa65b3819c32dbb276aaeb54d1258ffb06b4b14bfd76db0afe6990699f24666c8cd3459821142c7df9cb46f6d0b982829635a5be92373e8f332fffa8cd7868678d2f3c422d33113f27b4dbc930d8860c2502c5549d26255aacfa3ce3c0c8a461bf1201e3b903c60bc01541f5fd63861eeec1147cc51c93ba2866bf5b6d7cac883080630f0462eb480b6960ddf59fc4b5c32609f0f74268f250d4a5fb525e901cf5f5564b98430c42b698751e7b708bf686f3d7b5b0f90d0f5c9bda8a0fdc9bc37c1d6adde39c43f8e61db00f31e23a79229832369a984c028969f76a2ff86d88fe011c75b9fc214ca5fc22402fc10ed1889303065c9c668c8f3e5cc9822febc854404ca308e64ef0a6d3803f00de5c8dca2687483354f4f50ae44c3626b61e5c751c08adfe7c7393fe176a6a905ed647d8b7826e7d7d3fd90d2e5f6946f346467026bc7211e8092fd966c5befbd73b9b86984b3d3548f14ed644a4ab458b9ecff15dc98b167e59cdef683e8c4a5fb9f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
