<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"06f21adee884c6b71f19d3dae9246c45d409c3946abed385950b2fa4d0b12e74d505b7f4185eb585218915d6018086c6b7df7ab93cd63e75623f18cb5de0273eaa60fe53dd4a021f4b72960d0edd089e30087e44ad19b89ede9234e6e5d2feaa09d11ebf6f05c37d800b69a9413b842ea898f3177b39469fbced80683646904f0341e5023984fb366d314b810f98e997c7bb1a974f39571327ec2f6cc8eeb89b5faa37c59e5e3255918369712f7134b6c348f569117c8af7e315e44237b5be0acbaad4dde8b70c58cdeaf4dab8e28957a760494049b64c1f148df2f5a60ffb78619685c17b82c20526b88070c825e388b7adb5033c581f0308202fb91706504804a01f8210ccbf2de3acc4d09b934d4667eb35956ac69d59d54face9357ca987dc0fccd5c2ea85a62f34687d48842d4f59fd725d19a6957720909d2608f4345d141b015773e5ae3fdb1cc6874edb8d33e5de6e7e04249a2f49d8d5007d2ca1701e9c040f429020c1920fb5c5afa0b4e299c4720cad2edbadad9dbf7eac28e68158ed1f2e8bcc2aebb490bfa8b8edda0e3c903df2b4dd98de2132ed0d2ce31c0917cf52a0adab183611f7e6b9965dafd7a831b88fdc5772d5f95c0beb63989602dc24ff474b3df232c2eba42028377f118c8b304bf7e4f31f67fc11b7632f3687453c04a9493d8099fdee8266552d1f9ddc27f524fa908d809bf1c5a3295666578a8952534c9c720990daa775c9f2a4e7f0e937de0b683353290f39b81e76b3ecd90fdacb21b49e3705fd619d6f503c56a03ccf7e3d0b3483662a083e98552719d3ac8c26c478bbf193802df73aba288cfd8fad91f4535a730ac2822176f86b2579a1170124d7a281fda3804618ba80b868571d0617366536f641235780af90f0155f3088a3e59b4192ec712ebc6d52bdd4e0a29929067e755ae97c7943308f185b346eb974093d05d0f5aceb194404db7aba83379f90ae73a84c41cf09f5f22a3235fc4af1733abf505c8572b85dce62c8226245df9cf52a8a0178b48eada138f5b340a261087f0f6fe4c27af353d9812f91529d3bc69079e84cdf602df78bc4fd6c014667d9caa202820c2d23dafa055f5ce1206c658297f6b896e6905c13300be6c756da350e450185644eb2a12cfda64c8ef5891c630f1bfd3d810669acccbf59e793465ca80921de01469f99cd4e521c445d73dea621cd280aeddd8873e348593685d1f39e82591ed4b747a716f83e087ab52610e6d0e2f97cd9ee1d3e844ad608a49ec40509178ebc8ac403198cd1069700ab2bc74ac60a8609d2947071bf73e5482d27dda89dd6ee641f69f261ad1da41b098a5ecda1bfa14d273f297e85b2f3a6e7d6a098b3e96b4acd7d5be5518f003c0ebff39bfe6b0eacce8d8fd380605f53fa6bac516441253e099214e7af63a56419216c4fe77e5a6a714d7f3ebb8ffb1561df6fb10e5849f65c1e2525ac46320875503a2798b7a658aa8a1a87236f4f03c2733990cdb4d9001fa4c8614c168511ed6f962651df187c810780fc46d526b394a73b57ada867bab08b9cf267bb1375d8dcf8baab592ce0e6f5a59edeb6406ae16fc0ca24574fc9bcb5f7b15c9c15cffcfbf43725f047c9326d116dd27f31301f7871a5e7f076560d6e6df0d661099810b79cb2a47e9d8fc785d532e4ad3ee1d7f6ce580eb9ee80b003ab74fa4a001c0bf4388461796f1d21a38d9a9d38cd3631f9e38f99106f90f9dcaee1ed50a17dc10ac11a92440823c0f018e3296c3744f06c0d2f8a6c6b644c4e84c98cce8bd7ede2b05a083918ae1b5f102244a5df63799c0510aa1eb79889d757feb4a266f3c178e26b03c6332987e10d0c38da68373e5450296796484d3cf4e3c4aa1dcff78da389a40ed1e0be715889142996127cb9d0ffa6afffb57f33f0344206fec27aa2b6b0c3904259a1ce7433de8d8648f5de2132d62067b9d94df94c45d782a5766a1c1094e90b7fe3fed31ce5566278f566495678565542e8397e6658280322b7d5599347eaf9b34bb096e79e96f3176f94897b73259cadf98f28bca88a48105ed5eb39ebe23d394a964653b273de656c96037c878a7aa7a456546dffdf444b7bcbbf07d6d8549f5988b41d39a2c17eae092271f90298e99b6fff7f565e31c6706ec3da6e48e9b9fda2e58096815f55bda196aa79326a14e21fa52d957ac5b341d542d8a7562a592a0338a4dae8425b3cdf0da7124befd2b204a79437cc3f27a5b3791768823594f1c286d5650a66f05d8bb329f6d4cf271516c8f7d7119edcf1263084fc83eaa9908ce9080be5839e936bb5cf02bc317a759b0acdac639b9b77c7a25d105944e86fec021dd35b721520ad6bb62fc3f142cf474fd633964068064f83b4f73218d4bc11abd869e693a96cbfbfb074321e08dbfd3f3b472be0ce285ed84305065e046271c4419620736d6a7dcbdcc032ea3ca8777fa976ef4bc64f36f42ece7ae2308d16be78720ef5f8d6fdd7b126b4dd7fa8f31dc1d10aff9e2418662923f7872ccc3139546b710178716fe9e611bb0aa64f243c7b1f3e18a1a4ca25c93e83e1b796e4c1abab7715900f2ccd7d9775740df1aef0525e183864da9f26d96093e76122be6f962b113c307a8555474ea4f417a0e5becbaa27f68e6283597c2f5041a2536f469d8873066e916f0828b0357e8fc2ca3d6ef784cab3d1dcc512e038cb8ece4306fb6b10f01ca8dedf50d688d5dad3705729366ab9566f9354bd0a9c256cc48e3233ce6438ac4f7dc313c725700ff9d59e0eb626dc36f16832b2406e2d38492267c30687f2c9c271fe848f1605b0f96e47d48d9a0646d4bbd2241c22ce4a01362d12a0889a843d0edbe19412fc318ac7edd443827985b1e5bc72c74a82fd6fa23e7fcb36d5928261535400577aac414b32c4f8f87e67bc48fcbce6749026a890e239122d2c951fc55e4ba0f34cf2d86cffaaf598f3570638d5d82b28ca150522a948f34d225f873ad7c9c156b3f07d16b6ef3f0a2ec4426deef3d4b5330af8d44247cb1d496a7bfee9547369b89a6bbee1c31a74496332d3034a5e74ace7cf76a8950afa8097f61ed889de24e157b64ff7ce8de8b15f6af4925af280aa6ac68d9b6faf3550fb17f2d094145dc1ce321cee552302e0bbdd94e629edb98ac5f2683790334e349c2caf788be07ef2c97575eb6e439164a852934c0b5e9f88b60e3cae95ae99a0b6a2fbbd7eaddc10516576624f4f0aa7acdf10ef7eb8d2c1c858002046f9c9fe5164976cba0f214e1ae38c709c189e7bbc9904b132cf052b284f04764109940c4deac6ebfc80de5697a1389482587ea5d7fde4ea8847bab5c83a09e6f8dce20559da0255e407e1abc6a633dacf1e3d26b42dd37d964b979ad7be9cef6482eed34f4386714bfe4ae8119e96ac595fe7807983db30746c42433140709abd176fd84b7cd503a9a3dbe4193ef1db63d19cdf3248dc54e67ec86726c334dc472597ba7da51e5a5f28f27b5cbacc1390c74f7faf25ca7978e16ec9b7d7a359988a94fd29241df613001c44521101b7c240242b68e5748772e840381c473363f4a35852d34cd23d66990cbfec15f7d8b62ca1f39263ca62eaf26cc4de4a2e2137930cd0a6382b15009eb83579923ce070c295da3a083a3afd22aa6dfeaf9aa786a0d27ef298f2d99e2c3de2c01f5170c0489dc0f74f2db641f02467c1fef4fe78645bb3a630553cc88d997bb4be85fcb685ec1123ef908aa8a35e7172929d60b34389179e62fb21a72dbd7c18f3045bee5959981afcf5f3059467aebd12e5c8163463f2a3b7283657a50da8f5601779e028350ec93702f8c2d0a369ebc7731452d9a46a8cf10d5340b6bc0122bf990450cb74aefe71e1294b220c0363e143be59f13e86b48e1393f28e23e83af126a8903d4e94ea282f984c9dd5cbe0c8e066866d08375833e9dfb97c5ea6f9d93b4f2b4f56b54aee433eacf6a8b238b74bd1fdbd89ec689519b5d6fd22b5749f018a17a66a4e72d99780d5dc089ae988bfdd9b6fc13bd476bbd1bb247c1515c195b68f657cfdbc466d8dba169d99b312de35ebea5fcba80999b6ec89971578a44df87a915652af0639b39b0689572f72c5e534bf07fec8f46dcd19d511c816043a9b0b3036e1ea516a87614a224ec7a19686ca279711cdf848a91a7ab78a2142331c5e76f4dbf6c3dafaac4ee222da38e8113c4561c725000380caba200a02a39670f174868d67dc45564e966ebe50c50762b4478c76264e5c03013cc7e0a0140cacbabf6a62d75955615a84a54b664b499102346c55e8b54edde30190839bc021a02d64d9b9bf7b5a8abad532a17b265a01faddbeaead326159a89e8d945ce703fd1858056c9af5bb2534be8d507751f5d7cd3d2696c720f2dd756d642d38716c29bba5c52e3619ab6e0e0230215d4ee25555ab0ee23c0ec68946d3b9e0ed4ee688c84314694773f31dfccdbd8358fb4d4e25019c960d9f78edade2dce56034e7890a98446107a6465e02c7cd3a012fa72dbc17af9d5fc0fcf5a0080a2a528fce7e7de3015957c3e128189c3d774ad1f09758fb855da10ea02a928df00d685fc74c0057d9fb83f0b9b37f79744d65c079ad4fdcb627abb1bb0cb7f2326116603266025f52fc2d93ee0b7f9617c0bace7965d052220134a6bd0c67c12cd691a0e67a4d1b3059181c2f06cf9d3a6a04aaf92cc3c2b67ada0a9cb907de1669152a172fabc121af8e438d8cab1b6fa3b3460e6825861395adac29875e0f1d431757c50652fcc7b06b49e521798db636f09b0be04ed493533ce7e9f6454d11427e4e4d211eb1974eaff63a2248f34fdc49d29193dec7b4a3923498d1240d59539a840e316144088d853bea158dfddbcaf905c9e4e68fb8ce715d3005e3df58c10c4cfe5513edadbf1b7732df326e5573eb14d721d43d4b5af6699b5f951979caa1ca1d316aa4a424321e145be00d94aad038d81a0469670d00978fc87464effcaa1595a6cb45b6dee98d8236bf5c662ac410375659abdb70d33feb77f5a45f62413d583c16a2ebda8d71ca34ec83835539d5899607ca8a56d67072d29f669d5284c2254f9ce181608572327ad2986cdc816cdfe2157bd88db41eca3d68df56d53963d76ca0c26ac701b8598ab43c27b110fd1a47f9192cb7114e5a1382bfb60d829aa420cd7cc3adf3a552d70e6dfa1e6a74c696af1254f15db237d772e36ef4e607d6342175a5eb4af53da00965df36bdde4fe33931975cefeeda7ea97ced2f2ceaef027ef9b69146e8aea3f8045647d57dab5f6d68cdcf6ab461a796d7de8a668ddbd3d4a884c33d77ba9de19b923a88c3dae73936ff05184f0eea65cad126d35248dbe67eadef790b31915ffc7df83a4f2c08011a68ee32f92a72a7d69f720381b9b4e22673f43773d78f89915d83d0fa586c4d573144538b5882f69d5a39ee7494ac015c5c6567145af62eb75fdf23d1618b623946981b850d86caeec482ab90339e270baa86cbac3714320459b299b8f4287bda56383269e2615e19cb466c300c3d3335ab9da5e1b5aa87f50229be87e469ee2d6b8dec72eeafe9a6dff08d4c2950bde137b3bff19068ecdc3d0383b87893429cc4012ba52fcf0c3925bb122091f0af8c2ac1bc0d5e2107acd312248544de9981ebea80843f9d87e659792e9ca17a9a24b2cedc139af7260178ab5c8dd422b249dc9f8c867085ede004a7b52211606669cff8a51cd8e8b576fde50ac43790e1df91cd2c9ac9654f2b2645f3e3b3d9cd27110f41cbb1a7817f3d762ba0fb8006ab483bc50dd999dd3b757183602ce498452d70ab46bc3aae96956913cfdeefd8b923b65b5c045233d17120d032db4fb8973f72ff831d97bf5b174d29700fd236c142579fceceec0b1aedeca2b49ea702d2161fc7e71320b855c15ecb2ff2ec77bea1041e039862ad57b9550b1d30e4c57fbf47fbc3dd8d4900b8696332beb78a7d192792d1f577b2b13f1fb585792a21be3dc0693144018b042a61a1ed6a2a02c697cb374a88c744766433f818c03a5c41b3c66baf904ee0585aa23a22ea4a44c3a33c94cc023f8f3c89371ac00a746d8d3b860f15c50eb11972df8b21a551099a59eb854158351daaf2793612104d5c5db0252725855638db832802d35daefbfb89d0fbc1e2704c87f777412152be2a31b97270e9670515889c8d44ae557548a7baa6fdd71426e592d90bba69a72199226bb2ea31b21225f40b18f3b59c59656b268a5f8cf40638bb95579a3dfc6037b493468bbbc6e44d402573f0676a441cf39c507a1cc6e7e2e3a7d4073f7021656301bca4500a94028b477e519a151490ea3838bbf8491d09027506efdc62d786b63f13570d63ea51d17acc39db5341e991d961a20c45afdb8b938f09b6bc2f05adfa03a14e4a03a9106619e4376fe8204eb1c246d000805ca2da7187c57f07ccd9e2dc85114ef9e48a86c43890d41026522033ad7db65b07fef60419a6056c6ac84536c5e2e18d5b43140d25a00ba07fc1117f4a0c91e06e538bae516a31f866bde6667d50e7758474549ac078f793f56788392748733633c7501afe1b4734091d19102dbaeda8e241dadb1dcc9e2633bd4751fd09ac78892c793d92119c42c065b4b8d3ebd57ffefa708278e06602e14678f5a042357f8a99c03142b04cf99afcd59ab9178e045e23081e53b8329753ed3e9fea34c6c6f930f1479d7d508b4ea14cc15290c7d6783af62b1d08436870514a811b9159442708743ed5b3626bd9cbf790c00f6a7714a108ffb5a22569b93141e0a582182ca7bc10c7932e564e9ea5bb20325f77efaa05f867522ea459faf3c9083440402f9f166b5be102fccb3d966194a5ef62c8edeb5f05ce1a12ef483b8c1c3966089ba89081b72ccef8359075e3f7df242248045bae5cd78ed4befd7dbb6010bcfc3855535b26a64fca27c0fea40580aff085bf0b89da857796bbac9a40b6339894c49f0965a752d65cf7380ddc9d23ce89128b46d4a1b5e3473e6fe292f9569124514c2860027738ffdb6ec4bc75980c460640a96dee8f1a5f8913fec69e64ed3ae73363b5b1a87a695c20eb462c7aa2b1303fa4b5d19170d9dddedd3ef6354ce0d19c11c4399bec97bc3726f4baff6c367f9483815ff8fe41975a58a577967eadf531a4dd3b3e988f7e1773b3d47f8313922060538f84c8feea99fb8a0147a5302834ca0ec6c8123ff9a1c55e56d5dfb45c3d7d8b64e7bc1fb7f6e0de3f556c43f1bbbf54fd29f0affce5aa3030865458e4e47be2f6a28662e38fa882505d81bfc63e8366a5692c83424137966c201682fc636d3d881254815e87f4afd12b6115e1a2d3960d1923b4e3ccd929202534fdf95866e8011dba70aa4c0f8b0ec317eae21455a2bcb0a7b6935b0f74f663b3c1623ab51559f034b951264b814b3dc56949b48d103e655c178fc4fc9e1f1dac964d06a1f67e2e95802b4939b545adb095bd12f1eb2735eaee33763d04315e5f5c68bf9de953d8f910b1c4941b5e6b956779dad3f079f36c7116567195abc6f6e30a9fd27627c7f1b73cd2372468ca156c9707f5a5c15c73e1f6c510e14ed9121c36321b14638259f4a4957ecbb5202b71accf97f83db46634b5686ff909f9e2e099124d7798331510937bbe65157f8f7a83156d271e591d90ba6901a7b34053da6dee0b47d89bc4b67008ff5c574c35876959b4b6a4d7f5b38f22885cef7f42aa6782554616d7d7fcc85edd7e85d446cacf70d531b638fe0ae7c7ec37dc2b3a23f0ed6c974d5d9ca887640f1bc32b4f1587f54c51739c6ab71f63bc69446d4425d37d34a251536f3039912688f98fecb1bc4a979104169d2b44418591f4c1568a136567c98fe6706a615e5e3dabac46f86456c177e09c2ded6a1ae10618beb7857a667ee021f59747297a38704d5531adec5370ce6b8d2f8383ae44dac17fc573dc732dd75fa04b5f5fdbfcf46c3f32e6b504a89875eecfde2501fc816ad5442b3498cdf15d3bde54f41f4e181bcbdd2d64de866a867b782d373b67add07ac4cf8a2d534f1b22c0045215885b1be310e0973b634ede7d2b567897e54978a9dbf7ac8dbd086e4a64b2d0987c572a7792806ab4ac9ed1a560c9b128829ff9f4b1b80ba56ede8ca1b15c4ba11419c7a060e1c9976e7ba198b65b5e119ea3157f2b3ad6a00cf7927df67aba5884d75b13e6549295840ed1fad184360be5428981cd43bc8ad1e831db2dcb62be22ff2293c35c792bbb37d1c7b3e831182633442496b4ac2f9d4784de49f6cf49c528f152d65bc5c2e9f01a8a23aa7c6cb43bd97e764571f72540100361a1af477ccea300dff43f4ebf2c78640bf18d5156ffc0f899b868b24f8b10bcc14176bba4f4d4f35ca00bc529f67583ef6ad6c992b8a7cea2c744a4e2d4632765c9d5d3757b95ba4cef80f5aa5111dae570599c6e3e1c7d28195319222da51f6e73907281841319dba5bbd732b2cfb996b6248d592c505efaf062b7ca1bac41a040b60bb48f50bdaa9380b60ab65ef43884a547417c401990c6e6196f681f4e9093234221c1b57503e36c6b29a198a73e38573e016f8cf89ee768f373ce08999331302c4ce851d160b0c06f8c70dab5db14b5d1e57154c2c90c6f3bbf5681e33c9a7bf7f23cc6e63c32aed713a377a6c73507cd65c838fd4f4c6459b18c894ca44cb230b733bfe50891873b790ffa014b323aa5d8ae3e5876f22fac6155ba959cee1e167d7c9889a228f10449c89273eb005b514729664206f48fd18838a328e62ff43077dfc3038f2018533ecfda42c34282f1931ab9d03631b05c76e0adfdea13636c17d8cdd3f073761635c7d5c489f2507d693b87f52847b5769553590dfa93324d34882d91550827f830dedc7cb57d26cbef670966f6ade0a871d0b2bf7a67e9e9eb8ad7ee08e0f7176ddb88833f624a472d938065bffefe77a1090f2c9fa4cd7ac1025a8b62b1b721735c6f699b1955d84095518f123c171a007586615452201f11f3c081312f98f0950edcc0e4bdd1f77350316ce2c7f652af8b8a1c61678f100503c12b4be7da108b9eb0f299b468dc3fa1a467c3f55e6fbd697e8ffb67f1854e50d70b2cf3329af7079a26602488dba1b989995c3fd4e30bf85523d2aca0afb69f1fc551ce1275946138e6adbb33451785d30381467f340579b33e64f87f997d11acdb8e6d8278f95c10e8128c95fc9b8b5865b8c971c78063937165bbf2a5e8584bc5a1bf80e87bdc88522c4d33aea3ecfaf3dd20e6e06312109ab6f1a980c63fd817012bbc01c5e6c7d147c06cd3c0a7c8545c3bd15b8329857465fafdb9dbfce3960e24d2c05cc015ccca23e7314ec8d6070c7e1e1b8080fb0e5938f5667906a9c493d86f07e885d07ec66074c6617b019454ce40402e1b47790c6f1f31985c9e771ce8477498c9e27f87a0cb64d53fd4b9ef8e98db81ac02fb8d9e0cc1d3a9308457b086d3acf0365d9ca4c7a59585eb04d18d906ca6a1dc00e924b19e4ba9a6b042c5e05ad86441e90372f55fc7c8b48d112a90f0a75337cd55b03670b7c21b5e61dc49fe0f28c83f5a1fb6f413b3bade87d7cec926ab84b4e95721c242b9041f98749e03eaa2d8dd85a63bd5b1317c8ec5e5f27927aba778efef8156b3718ecb21e286a65bcb8ff4eb89ab50b50fa8c1116e7a56cc93354bb47d7020d50c1e575a4c5304ee82fd70bac83793672994c95a772bd98fa31573bfa7daeb5b366c6f40d3dfa883eea1cd2e5d42babe8efb53726690420a7214a486beeae7132ceae541c4a2dcc457d7627e7e88f17cd47cc8626e81433321557b127566912b37dfcfaca73063dd5ada5ded9d67a147a4a8925335c4dbeda3bdba4b7d204a457b8790413684ffb0470438ae435c1f239b25c318db8e6d62aa49ac7f1f70fd3e6e8540eb1fc59fd7aea0282fc1c7d6ea1dc77d3c04f083c78dcee9216d3f9961ed80a5a3bcf8098914bc683bab8ed0bf2b278d02766fcc3975cdefc2259b619635e5f128024ac341236d3169e8b21bc04c6389baed77b73cd008ade84d423d3527ec6551e1ebb3b158cb0c173010f9d1d421aa51b36f1f68421dd72f820ac62cbb403f43e16912c8d717b65a681606690ffe98f2576a9f5a6866247df6a985bb86eb89cc22625477c73597c2a4a2188d3f86998787f6ad201e1813901863921cb9803f50d37715b699f2f0d27a7720aa2654431be389bc9836d6dd4f86ef72510155875a3eac89d8fe6c73ec6d73d0cb83797f0ff036c51ef5409989fe82cbea1ac6d382877944bfb38cb898f5114312f9c81f7f8702aa59294351d5639044790bfe9bee7ccdc9fcc052e133a308f88ae25809985784c2788cac7430dbd5acb16639391829c6b5bf7bda75086f4af8e2d93811df1687e55028a54ff5f8321b04052782e42f9361b1a70d7c147f4150c12a867caf5d1316610dd1c0a15e5efac0510c6b021bd31ad6949fe7f81d7ddb57c9cb595fdd9bad7e854d14eb4abeb501c1fb534b927732567098f34b6971331509cb5ea16c97113f52e9b265d072e3382fc1272b653a4f0278ffa3842b2abe418c60d1d87c1093958f952941350c8267c993e750a9f5e36642d900d9a38fb2c88ea7b5be75e69d65c73a928354d3d738ae0fb4ed3a758fc472bba4b03a9efb96cdf8ad661d352a56486f20801998225411394bac4731b3dc9179111f81f4a0671e8f89a1f5f8730513a2b6b2d442918f2df7e63277d4ffd862786703cae3d18e979dadfe268d98355bec8ca0e173af4a95726c053e2cd65dec5f5c6ac7ebba987a1d40dc37d821b21316330c90a382ecbfec587e917abc832c058914065c883399e6c8d42bb6e2d13f7ae72fc1fc7cfbde09e7b6b113352c20cd7d1ab7282ea7d5fc03162dc085f3ec090cda3ee68132eab48dd2383c4b111e861fda9fbc466ba5502fcc2e7f08420fc1fc5db8a36491fca15fdc1ccd4bbe3efba0f68c8c7fb52635cc414379242eefb60e916a79a4c714f0673a2e0750fa9992b9c671542c1d7e948a64f9ba26b2f79c795c2fe565ddafaced24110cbdf399d70f051a8067297ce157a59dd110347573fab03df9c34684a8a8ae19f8771aa9b8acfc1632d0a6ba6f093b5d9000055a40eb4eef01aed475812841b0a1356eb027ee5593637167ef03b07ac806b6cfe7ae6ce870fd624335e44aec3dbc70e2ca12602f2c7f23d2e236d8c81b51f5a2269230733161d06f012117dfb7b937ae3601846a75b835a523ef9554733c3c4bc39073783d985b48a706c9ad3f39c5cec03d232f0525f0542c95674265155afad0e93a4f47f97b2101a01745beb93440e9bc95de0d572d7731c6a7124fdfe7f60e592e695f6562f6decd7725605934063411ffc2fc3ba7e15f0e9ea034079e780154483dc2860045f098942112e4035049edf452f964497bcdd98b2632f541668bba20f31cc652b15d2e8d844a37da9432ab883cdb8080d43631bc6548390f6ebd2a9e4c6bcf55cab9d7df34d8382736b05042a6fbd794b40d20ada7808861e6819d45b6dac54e50966a0e7606fe12616eb334870b483dfaf7741cd16d534581016bdc3b58450a9b16547481232a530a0ee8c4458a2b91cdda696c42414fa048585749067aee27d14d5e3546de8ef821930dbf429bac1118c158d4fc434754a554fdd9a5d9908bc8afa136969924ab66c43f31103ff63981edb570bc2b6b16542dc75bb548a10328f7c35f23109ca164d5296b0cadfd3b5983e7a43002f6d98d406faf4aa93eccba04038e9c9ad6a34942e17fa0a145da2e2ca2bb188136fbb7d76bbcf505681a7057a8ab4b8325fe5e56c2bbd544c5aa86f74aa1991cf641f37db2ec35718dfc9617ad0071f2c521b186a5c9cbdee4f0e97cc68931a5313fa6cc7ac27105104210ed93dc80341033c8dda70023b4fde21d06d77ab13d06ff2ffe6953d7c157bb20aa455ca2662acf4e269ea77db224cc6d9cc8d2b46cc0bf0160b24381dfad4cc38ff98b311ddda4c0ed7839d8d5f32c051dcae8a4a0085f92ee90341835f8eb28abb19faac34ca6c66df124fe718cefd24f922ea0bbe95d6022b4004669a19fc39065dcd8d086ba83821b4794249103ece422e621f59dde76362c54610fb4a8ea6cb0c446354cfef98b87cf8571b8036ba61e2a1b2b00e20115680be43c259bcee6174348c4d848d1e69cfd4e3673668dea2cd698872cf36e18992f889d0e69bfd1b64304ed572711cfcb5c454ad58a3e715da16fb9474f7990bf415fa58647a85baf4b5c40509908b087729db31af7c4528599ddd34c102c2fb8d5bd6b5bc3bc8cef31ea13dffa45521c5337d3392ef4081ba13d9fe3f3e2d602f96ebbcd282b81e0d5d86a416cfaa2d6fb5ced3c4ee94febddc60684515bb810568b26b6a55d8a91b93f2079178a8b2a53a9032c5c65fcef9e25b8ccedd4a465a7360dd697f69fe99a5a6436d0c2c937e420dcaaa0a5f40ad0205636831364551b9f52741f595e3bea9139f3eb29058cb49a53bedd67e6b1ecfecc763b7dee4037092366e25f55a8e0123777c65abf906c02905d396b55be89f112dc9146aa58f24c3e3998eb112e1e120f116969dd3c995852b8e167a5df46ceecb5a225b8082f0f1fe3ffe2c55e7d7fc5545af4a0234cc20406322506781e0f8f327178668b2bc9402cd0d04203cbe712b848c2c95d0106b69ba8e47008dc53a5b9d1cb2cdf544dd299ae4eea52eb7e616cc56bdf4ec7afaf41ba3f6e4b57cdeafc1774b4076b7f5845af6648dc3f2bfe72d6598071d9de8e53f5e9c4f91024d94df7476ab76a7d92944648cfb34918e6eea68aa5ef9c36a4d947c2724be21752ff8400af7287a2efeb37fca4536bf1d9905a1168217d8dfb0246d8d302fd9d98e80605118a1b9b11e751bf764c0c2905bab64d711852df024eee235131e9330d322f5dd22c41df7ca2f674d7f26baee05ce0ae59f5517ee77778577ed982060b02fe3e810f59c97acb8cd8f80d2e8e891c30f35a54321ca8e4f6ef67cf1ccd17f99156e153defe498088b740feaab010f75aa63be863ef30bc8467f2bffc0c769529f27f7f906a853758f51fe04d0d498b9184b6ad51883acf3154550ad7c3f31d4f75b4950bef0eb0dbf3f90d8da5bfb68e50f68c69c7ed6e772abf49b23b2d45f352b453845e9276b656371388e5c7e33057bd887fb1aa5a9a0e195f26f4b8ab56572ba70158778e9f317e56863eb965c01d8fe99452134d473f668561c018cf6674c1c8f6b9ac0ee7285575155219521d25efe8a46a04d95be018f9cad02eae74431194e240aa255ef5b7175d399520208936d68a630933fdc5ad46af2b81f94ef85997564326b4239bb289a791f5c33da08dcabbd4fdbf4c4622c0b949f23e694d2b11d0f9cc891407874ac813ed3fcc992866e21d13412cab0ac5e49df397c993c3d357f156726f3f7d287d4c972c0378b2479feca9d948b5e7332cf3357c20a9fd8e5922f390867041cb0393310fbfa756738a79f6d4915882b1b61e8c23aeb8170aa82047abf8b0c9a35e3ffad80c50bd4c5f2b1ee4ce8a65598c695e346e2d1f5fc9f3ed0a46f5aef218ebabb829e1d8ae70b303672cf58d1fe06a71d3c919708f3b77c4220c27582e326283c44eced9061044c62a8db813c141154a931f537d00fdf96ec0ec5201bde3cc106f81b511dc44ea25e83cca4e11c10b909cec346b5b63d65d6a812c8d47c9b713792bef6c6858a554ce8a42c5f9725780ea7cd94257f6fec311a69dd40988244a493a9a7670af43534ad109acf4643c096c83853a571c108367430229f8980072ee79f6685d63d6ee150804e4caace6cdbbe0d7981fd0fff18f2801a6f5ed2d39a67df45814e3e898fbc8e98f1f9af3f50714b3f52e9de5cc5db1dcc964377775adf97a3cfba8d0f4cd7cb7b180cc9d6e62c47a0ebeb503c59266753b359cfde471a85ff6fbe1d4a05126b769f9c16eaef4e319ee977ef38a046e83abbc77da1e6b364fcf98c46db59158a2944e4e61a6a8ad91e3070932015c00f9ffea5c40a79d0c331aa5a88e1821f900d580383f13360a26ee470d85abf869ffdb15a4809722edddf34c4259f29a873febe37239fa5cbccfd07de5c5e752ca1da8b67f12a6f9889f2cbf882b905e35e16775f39758c2883b7c46060eec7c9ef59f3e13a146a2b42716be0603d21b3c12ccc6656a48ded869e8e32338af0fbee9902168d2b1f03e9664a850c5130dbc8e45f6eeab191113dd1c64561769f571baf0818123e120f57a3311da1772a8ba0283edd8c36adb65a08b8f95bb5c07e0eb25a267b29eab0aeef8cc490e65a0daed4481c81783f289fc444db323cf5b37fe61dd13407853d798f7af8da593ae234def05a72cb57d6841063ae766ff72cf27f4325a7f7075d2571ddc8cf72352ae8af43f51c11d9e947989a3d052666b332d18b581dee0f4402d80e3f1fe61c9c943e5470401d8271291120e9cd8de547b532b2c371e8b53efb2edc81e257e2cf53294c4c4f0e15f4c6d138a60d5e0a0407ff7a976431788b6b1f5e831f0b7164d0e3ae0884f575a08b23cbee77757c2ffb51279703f19ef8b1c5c036b30f6b26a1d8c58ed8ffdc94424808bd400c55fe84bcad705bbd343558d833a6fdf2b3e5ec04f73050b9dfc510849644351ca738c9aa75709b4cb088f9033851f5c33e3442a56e95d66d385b3d9ff172c4967c1d3d0ab8684a53d75117eae52a95408dd5a74d95dc7d17e6ba94b56f411f0da1ceb026e488129266203deb04449d61adf6d6be018df14f4edf1d094c73bca6c6466c70d075f95ef7d75a89872c5a277cec9184b9ec7ee4312784963dc4e50913373f91c06baa84f4d270b4e4d3b366c5246238eb6585d8bc7e4ec40d5236c10d0b6a98e57bed477465ce4b0fec8a120a3e0456388d916994334bf44eaece4be1cc1497c0398c8b666e291f37e400785c8e22a1b5b662975e139ccf96989309d5a3ae3349aeaa0b5a3163ad0cca0da98254464b5b9ce5827252671b2c5a949fd55675ca728dc0802384325c72691d22e31af7e18c60ff65aed5e866661bce5cd769ff6879dca7213bc2f0d468b43e76b1b407d23391c86c9a1761fd48b8ade3ef75b7c9f1e43d61e51018becfdeab396246159b75f30321b1d37ea6cab454d0ebcf6a3f3cc35d5340b601c5a85d2bb770fb018c4e7593f23368318e9b8dc0d1c8af4a83e9553a6e5b26496c67b42afe8f8251840c21c541a2676a43aea9a1caceaf35108bcbd4aea0611b378260766ffd125121ecc76107f8fd43d7a1a289e622d08b7af16dca21406dd0b60425729219a480740d51771e2ed5af39b91f54ec5411cb481bef3d8b28832c1696d7aedecffbca588948fa3e90431639914e9b72112988fcfcfc5775c27a5016cc4a78c41f8232a167acd3c61873b875a501b13a0a9cadfe31d90c0973e2a85b4f29e888fe824d369daffd1bc84871455abbbf4eabe56b4a4895d30b8d709611a5e31dbffa9816985df0966d378900c092c07aabd2c1d680a5a1dc9cefd164d58fb14323bb399942c69cea7185aa570cb875c8e3abf355a54934c9f4f0476cde9ab0c46b531e218120f162bff779d34c90388e9ba911b137578067946d8e4632b1b923b4fda1de1ec75d5036d805aa9f39f95192efdda431429ba5f10ddf55c616c85e295795c65154d6a8339522cfa6e4232bff6438812baad4798e4f66f6fcb92f4c7cc6758bff4a57450d277fc4a50933722513e3b07bd80a684fc16d796af6105fb7d8808477f13fb210f0168f18ee510bce135d67b928bbd8d3dca75f9b57aa211fe2560265bf4abded1246ba07825c91cd44ace20d231efe5070db67382c64c3db3d4352839658ee3bd09981b5125f138d028b41617479e94709729e3434037ef34d6b0ab79a2ce5ccef6ad47998fc206a7d8b06a60ff05692c3d201dd1c3700b0ab3345dbe6d88a0f2b9f64c4b4ad85c026585cb08c98875959efebc186799ccaf9bea795e54099822be476cbb67e22810391536f1e92291c373abe2a39f478c6d2bf68b459cc31b1b92818568763a31ce883d4f949a45d1c41eccc54fc34ac042e01856e75bc756a58ee06c2e056dec3dc1be6fd965e516befbb6d91d7671e7e77f7bb050c619e07bb74b621b2dcd15be6f00a7bf28a51cb24770793f04705e4326aeed1eab39bcacf618cd8cf20ee78266b822e332a6a1cb16e1e2adc5e6f2c979e61f050f1e35d114be3c2d826802e80ac6a665eccb6ff6ff2ca53cf8d80aa20f3223cfcbedfbbf0d18b46b896c3996e21411dbb7aeb07a1dc4dcb3d09ffa1eeed97330018b334d0fdf35d2f43d3c7b658f33529abda3188596f7caf244ab2d36f76619da3b7f213621f889e9209ae483af30e23b24be2cb74cb6a0174507d0158665e788987479242c27851a947f8bc7a690ba49287453e22598691f3c7d5b10301475330ee510ee7341585ae5d5e20e6121aca78fb6c2027f78d95ee398015e478d862f13175b34f29f8b98a454019a5850ae3358489b62af3bea7530e3b8a5a62c2d863294976ad35e763ecb297069d3f73ebcb60643f37b65bef6cc165a9f5622eec4d31aeb55d78aa33d969f027e0cb710645a4a34e3ae56458861cc353018ec34a2cb4abe2d9230f7e03b4aee519c7168c75b1f455d7d9f41e1cc63709056602877fe83696e4e16974553c9c0816ee04a6f3b763c9bf3ddc500ff0bc011d368c7eb6454593d912fc9c73a22044069e91deb596be71df63c72e3e37a290e0d138e52f6d7fcd6eec18248634613c0c160f7793a9423c4cdb908b3992195ee4d29f74c15d72f02ab4cb9bbd0e5e9db620d67e1f99113f0e898a45f00ef2b5a56d993fbaa7c3d83aa06240d11bc91287eb7958fe7a8b04f6fdceced1d07b4dcd2ab1b9f019d79b1f439dee6012f5c6adc1ca3a8bc432cc5b856760594968f53129f201be686afe5b2dee0a1623a7d6e8c6d6dbb7dbdd5f01519ebbed81961d373e369abc56fce7187ce76d127e14c1393b0674991babec50ffa177d914b0e762ee9dd76eb8980c165008d35170baf983f39503f5ab2e5524ce1cc61904f6f1c2d190f5db964f90222357ee4f2bd401fb2d6a508b23894404c6e6b8b6f9c50737d4d370f4cf57a52595576c544225291954dc1625fd3f34bc5031a87f3e7ee7176bbb0894ed4bd95478b3ad9ebe6b58281598fdec8acf2c72b485be64ec5bec8f165d1abdf4f110400f5010130cb282d66b43f28242d8cff508ddc112491bf36c7f3c968dfe5cb1364209ab8a7956dabe6f94cd30de39e5f3f9893a549fcd1f0baebf77f902d89c9fcd0db0627e837b427711909f05131ee6259d5ecc529487e2a5dfbf892bd8a4d2b0255b38e61800c90fd58fb5a8b355212126f6ba692b35008bcb88e4d4f7cf48b576b5038d995ec4e22b4bd6fc787ea6e4caeecaf5ec8ac5336a4074221e1b6edcbc0ef514369417d45cee130eb9e3d624bf3b11769220deae1fd40c0763ea728b73480ac108a11165b66ddd0fce7888dcd1f7100f4193f4b1ed00d191e1feff590ec2e261565525f1d2fbe4a1116f3d2747559fc181b56f01fa20f697083cdeb2e64b3f391d37dec0d4f0e39a291c84d36ba2b70a154c38601272844d8d0d4ea755db35b8429928aa86cc66668eede84206173a8c32536e4d59bf6f61c8fc36a499b9ff77407e6b395a02a1100763a5cfecffbf37b6497e8f8cf4031b9478b65ea3314e63a4bc8497e72188cd6603db1c25e61c3879bc8c18cdbe0af78a40b3c83df00faa5ff6693cb2d7ebaf4218a4805db8792806463b3a02405d884eab037a8e164009c285dde92d97d0fd1926aa01d9a9b0628757c34a0e52d90729dbe76925a5a54fe31f771f0d4e9b834a0ffc397bae55abe06e451937936ecce26f551a764d17f84f189cc3af26c97f911f68c2b7e90c17d7f10f4e8c91b74e0c6558c70d5cccdd80d9e4db494d400c9110e2527895b6ead7c6a6c7f46c0e50a585772672ab9b87098d973c2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
