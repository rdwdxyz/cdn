<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a09c9f30319551e0907267a58d039f90b46e7dce4fd1c08bc14a2d4984b725892bb53691ca7d6a4abcb5ae9d6ba9e503b271970080d8243b4f18bb1b00030a9e1784ca561a7d5f7abb7b9e681170814fde3ff9b5dfa483ee8a7bb836b81164978cc480c592d143f0c19f50c47870b9f29fbb0e51cb61a7f7fdf181eba73f11a134c58257a50448c2c5fac07841cb8799da060751998232d6d0866b608599c2884ca344acdb7343721278497c0e7fbfc66a4bd1b33b792d4bef2b3cec429577094617fefa59e77b190dc995a2cfb0c276d81b65b89bae42ed240f935bc4ca732fc7025dd4ab8cd3cae28d1c854f3295fdde7d328aeb0d7ac0a74817afc3b26ec20001819d1b172e1738a8d1e2d385c2a6559b695af4a9688590341a432d2a7c9f817cc792f5a8e56f9b90ce644ca8c1c1ab2236e04811f3c130fe3db55e92d346067339c2321e279d957a0ec41c01a1e6321640bd20e42fa97e2eebb64481dc2cedfc23298b438e76a554abd8fd539ec6936afadb6f4429bbaed6e84ddf45913336d211103e87a2766afaa064cc6660b7f8c7853cea15cfb3829e29775af7c150d96c43a59c70162bc95151cde217dad145284c3700bb045713831eb3717137d0fa23a1a29212690b59bcfb03de5bbf64a0e1d33b15c2bc821ac808f90c0ef08ce356c24cb4ceaa39754b10c37367e796a215a76707ecbd8ba007810f3ad1f3ece1fcad4c044f7ee63a672ba51ce7b29b9e15dae6826288d7363ed8ce1344410b8699a7d2d9795fdfe73cafd00a27d05943f827708ef64e9d4379ac6f231f3fc3624e8ee2cb2de2fe7c68972b11592f8e0c68c21356f66db7ef2248f78ff8d930e3f45ca363f22f18aa5564408247431248003c15ba0ff9ff9c6c3c012a14168ab5f2bfdc50affbe0358ac3d33d16ea2727e40a1f41c2e58c0e3e90a6ca66132c771c4115ab461ef7b95b3e4d918ff1ce5d57c779f945cb176d7270d639fd338afb338d7fea2c278df92705266913d00467eacc391d68d676e017eda87c4c34a74c990033782366d784a114a057b69084f7fb15b55e90e0ef3a5e5e134b3ff55268e857d04587163395a48d531b4d668458369ddef72e72c85ce271e2d25ce345107a7387b669a9518f7ee3bfc7f123b441d3515ecfbdd5f038af406182c7efea6d53825dfaf0d64a978080cfb48c2decfa3e9ad5f7da60931a40b1ec77f150c58d19db63d0b0638793c62b17a467da845358648f8be5591dc640e0079121fc701a48a082324e8fcfca5b77a3f778b39503b63497a39353ff877c3ba3896382378aec3b7a7b42dd6454d7fa235a34d3c7e1d7b32253d201980303acd86d030344395b5043c30e177e8933b91f300f7314ddc0462afba9364d51bf8b1946ebbb98f676a773e3628470334c5fa5cf17e35435efa0497dac0f86b2baf2d7ec8bf7e8290675d57d8320b86633a877e7f549baf3fd5ac484e31221290766c9c55c73dfdb27600f9cbfea113528d2e7a5a234dc398c1f0faeb95968eddfeee7fa9226920485e473692ddec6ff6c4d5fc62738508a3352a34d61be127f81d5c4731715a8b1cb43a63118d1e95fdafc8d7e55d990c0eaa178b0ea1a4a30e646098bb580a9d5383c142f23acf3b82edd7b75c8f267a51011a2a8920e091f959d2972312172b335ce58245145bc07db28cd17e2af170c27548189ab50fe32047592beffd8c32566c4163211e6f8a8f6eb97c645e7e20e9955e23a7f4bc61141f6962f78488d15976a914a29f0792e694fa855ebee72a046a2c67f06849d6fc7ed86f63d6bffda8b738811b158fcad04257cf12dec1fb6fd90495632934dd5650d23b36fa8d216fcb6f7600a2405616721df4cfe07b9b6aef8a3ce9291347183a962b1659215d65935d1f6b757a81d3edbf5003898b99b7df0c6be420fb84cfbe70cb6dae327923538fb3cebc88edf4a82fa23743a395838d66db83da6bfd334e85f08da8573a9c49304b0649645093158e225d5d3bfbdf3c5f302d6983120ab140a0351d33683c7f68d0c736f2c7864ffdbaad2ac7b5469c4b54f9ab1e5cf66569d646702e2ddf8cb30dc856c00666eb0422c56febf1fcd955b233b0b8d6a5944f2f60855e71d5db1b80811aa8ad17b055e8566e0c5197c6a5e6c04bd4500f2191267e7a01ca9bfc2e90fd2abf4023536ee6777627b91faa7d2759705fd81f26cab30853f5fb3527ca7b1c00b7d3fd4604cdeb7cf221e7c94c6d5b104bffe7c0b9ecd80fdcba0f50cffeef18657a4aca14dff0be09716f9aa828346cc32bc8a6b0512768719df5c3b4e783081e8d6d273026fd253384a0959d2ec00ea1102abe3405e38127993f381e2c9d2f599b4232b5e06b301071b6fecdaf9fca51dfd7e35eb08cd45a1daaa2937e3cac54c30c0e821f3ecbdc8832dfac2c5c16b36a9b8050c2bcbd54bef86d6d900b7852b21cf3140e59427fcd9a11c1d376969ba04be4050427730a5396d1fd2f3cf0ad57de5b3325821d865fce1d852c0748535643bdcb0e7a88756f6781d1d501caae0ca4f3b9f5cb82f88b5f707aacfa01e02cca92e080de1c7aba6caa652f10f8a78af94c187b2d56994480fe040a44859661fa6da6f5b560419d676253d0bfb6619117d2938f4deae55686691ea12ec0a28e3af2d5801ba0d384fd1e6c84c063754a9d5d6a07541fae725813feba38cacab076c853753f3fd65a04bb9b74d6fdebd5eac0a074668c74bae86195ef8b1f5eea926b66fd2db73d8662a12d8687fb1badb6bf5ef94507750226b1eefbaafdbdad305a682b65be1602fde1d69a62669cb433b1cf79255f94917f79336f564b6ee97264b0681a6ee3f51c7e3ae99e6f6aad994b5154748f65c9f7383aea61b661a3be39574b8d6d2c0bfb2a42987ddd0a2e505433aa4e967a12cd3b1b0ff08b516aa8a0842e28edd02f4fac6aecbc6993b09cdcdeee57769074a3da220f8f8bc527a9ecafc72707cccc15f8ef856a9a55685bd0f8ab7bea6b4cace5a34990a69824eec89be87dbdd07aa56ffa54fdc96e5f0f9ac2b8590de3556c20cfc80674afd9066e2ceade79a74332404c6011283afed869cef1a59de84a6c35aee3941f189b0210dda721d9f7033e3ef9247f6b6cab22cf116d65047e948a46b269c52de9af05e4ae0fc0119785110531478a702dfd601f298357dcd21eb675e43d66a7c1d9bd6bd1bffd71c654daafd39bdd9074da7c176913478e423f38909c254d5e88ea068ee9fe7a47db90d45f092d0101fd553dd6ed7a619bc066b0233a36c0a394b1a7ff1ea4507606ea4e6e9ba522b77b4b720906aace85aceb072f5cf3811b31ce25f0ca7cc84ede266df5443398dc231c14774d2832fea5d0a5c70a6df26fddbd3e66dd6f6e6cb23a92e0c61e3d16f1a31dc2c199f134f8e7964e951832177948dec2bdd307293e297e7bcc0599eb6db33981f929588db1b43266d614dfe8b3d81d48aad8cb6d9fe5f304a5d41d1ad29af2f04e399dc4d211a9c66dca3e2781e72d0c16ddecc40df1c1e49f84a10a185e40a81f507187b697642b63bf4cd381609195d8941848e6dea0024b4013983421a3140be983f4fbe78c54c2dce92db5af39b449ac8f7c52af36b2d55c948c2bd259e19b6262fc38121ce30f54d12665316fb7848a1990c01844ad73da79d10908ca7e4107b09b50b38c5290fbfa89c01a3f342dee2272669a4be01eb8d8b41233cba57c9a8b45014cbd5279bfba1094dce7e9efde4dfd3baab08d1b4c111d05e099f7ec619b9b2a3be8d8f5a5df515487c799193e97db1a77f5c47b2a2ae2513d8a8b2e9f09f002ea7a8eda2524c6ba261847aef9a30a66f93ca75ab66283175ab78406a15a14824a4b399de3979bc8d5a09f5ec6d27d48f78018f74c34a9c7503959d1d283c28b5893f9b7d7b7cc76a0155859cce8d4a3799efa083798cfed913e710c313da613443123391f6cb865d48d9ce460e781a23472f725813fee163e97094c5b7feae4a64f6731d719f5e21ebdb43a3b9d2b1526c123d368e57888e0e04831f15f2dd673793590231c1f98983e38edbd13ba6f23593b9942373df232df8786765c6b147f0b2f89b910ec732d827372cd911c8686b2a76989d2e44e6c95ae0a45bc4d371812c6c5e04b5fffd949f59b9c280c01d2837caa0f63792829e304f5cad81511ff4d1885c954030db32f90bd245bbd717e7404b50e497edd065e8a755ad96da63b993f6c0e55cefff1497d3b6facd3fb3bdefad1f37681e045ff493c88525ff063973f078ac42eb3f420f65a0107c743a829239663d8f0b6d571e539992533dfd77733b087b54b12b960cd0ba4df1830cd866acea2f6f21294d4bc9d1c22b0fd47c2730297db46b5040ca8f6eb63bbbcc9fc34a54550ca3d1011b5f72f90186f12bfdb279963460dc6ce10686c4c7547fc46d0ac103e5c49cb5d4fe187badd80af822a96e78efbb8ae71bb432a35d31eeeb34c0f110c16c00cfa3abe37e3f1a46c26e2f487b6e95f86b3f1b44b992269215115d612bdf69bfd9d7561728b09d5cc2642c23a6a6e40e1371f4a8f07253e6f9638c9aaeb33345bac26fd230a641dd39bd77927f97c377a65682a21db1b4ff7e1774bfffe3bfc2211186c0a9342c6b0b42ccd13b37df11537d9a1fa357b69491ad759b56d7ff342d475badcc5e1c1bdeedeb21b5e992e850730afbd76097165730064b670190ecbede54d98e4ea1a0bbeaa4f965ee915c06006eef5501b60db3e2600afc6b81ecea523f306b929c5853d9a40d5a601303f7bf350037491673223bb8a8d5e003f56ad264c0ddaaf3abdde97f04b773aa69fb13bf859c8edc63e2c43c6681aad2baab0866cfbd051708dd1c7b402a002604626120267cc9f25a2489ec1cd0efe08ca38071eea127f37c52c83c39ec474537b4d85fedbb47970d998c70bb61fff330442dba082592779e298edd6de64c290068ad9488a83fb746bb26dacd820196e0451fb2d2d27c19ff2645b04b0e18df5cf253d60e8afa71f7e4a403225f399d7fba55a80c87fe04768193bef5fefeb941119e3b9e36a237bff7e9c12f166060419dcdcaf1bfe0bfcfe07a554ec5cf33ffb1fe7fb6915d0c7961bef55198f0f63c60b839d5590d4d8332f382821d02509060ab4ae017aa0be4e5695bbe14929d58c3c79e1862413ad82175f4920c45384457f7995ac22d729e15481d3557357b87c44b23bd54443270b4446a775c067aa508942faf80d4eaf3167e5c36c93ea7934bba0274303b9b7826c2e42dfb2a068a30807a922e2a2b7a5e6c286ed1925fafbb58759ebb720c6e54d9bf72bcc2f7dc2e0880988a76ba55269657bd5631ffa95c79968e9efa6c9697dce1a8ceccc84be217d42da49dbde51335484afa2ce3bbcb54fa99b06d8e41a9aab20d080e217c3f5d97fda9d9f832855e7fa85f871e1276a2780a5dcbb68d8fa14ba79aa9331cadb89ea7049468323a46542ab022d908e7c615cb8eda09497e67021028c78c1338f37e6f3724e4ba30e42e9781a4578c118821fece98c1134eca94de80410d6d7d5a9288058f67a5e4bd982f4decc27b0e8451944b34c1ffeb12109da6ba10128a6ff123ce544073bc6dd5e0dcc6b4183d8d201ca8fbb634f7f055234a1cf0761d5aa07c70e10db292e7633a4c900bef3462f7dd94af3b9f5570b16c170291a64180fa8f1c7dfef356b0bf6138a513d99717621bc923005f5a2a4d457f44bb08fd0077e8199f195a55415aca006992d52a0c6efd0a6a962550bcf9f4f4fa4dd2cae878143d8524a23572d79635488eabbdb12b6609acb319264023de31bbc63e6d6f9322b92363cf57fc7ddbd0d7706fb78cae653367d515fb9480e943b6c23e1b49282b6ba172229bf6beeb3956f48039905a149b3d95b344dbd669f5d2064be72d13e0e5406f07c7e4dd69173846c3864526928b2f0ac9b475985b1f0c58c2058f1e5bf4de2cf464036415599375adc65461fdf678d115a4824022dbc463e447ba7a5f9893fb50376e34ef588f09c56055f46ab4a8026ba31755ddb97b8c0ab9e96a97a892176c815e6dade7c59e8f08d613347ef64db2dd2cdf366a54b9f248904db0289cdbf5a37b48d1ab5c0ff7b4d9e6d39a93175736050f36ca0a36634cf144b7def1ace9d8220004cf98d15c1b5346ebdd4206642a98fbe7ae0298ce0ea71255e2e7ea3292412f542640b666c94f657b28db120b7df9d36221c699e39ebb1028b744e4e768d881dff290429591adbf5ce4c7cc8cee6929479ac8f7a328defc942506dca56094195a2cfbeeae434c4d499bf713131d5800a56ef46ea6b54bc0f8ee7750d00ee0dd0bf7e077d2cec6b1673bf06beacd0a20b2d6127cc9749513fed832ebbee571d3021a91092dc2b48c655133c8373f4108de99fdbf918a66e605cf39de458e1a9489cb8a89adc2881a00db7eb1ac8e0135da0fef86e2cbe03a882024cabc78f47e47b5f86ebc2cd4e3595f2bd2c6c191b46fc1c42d3d63d979dbeb95976560c389d3a9ad1f442273a6c0bb0bebc3aa6f829d30ef45ffdac30f9bb0a3e187c568be8c74b624ece69cf6f029ad4164127fbd074fa6a67d3e6cc6126fb97c3b53b01fdf2b4a3d944664b22766a7f8ea7430b985af8bb27af96d9fb43b646b3f2c1eb872d7e2027b3585e899e1fb1668096bff4220ccc8d11763fb5a6371d2fbe635cf73d2997e5bf52697bb13a800fd1442172016a29d904fbdf2f2801523850d124fbff810487a6a021402d86f3398f625fd684322bdb4359b6cfef74f56689910e04ca3eb532f64e5a39ea296adb267e29ebf1268db1d037a7013b1853ffb626fd8e3f1c7e204d0ec776323b65f692b53700e601de807f883fdf91dc0a5fa02c1988664963800e967e055635fa02e257027855b73d78b694ff3ceb20feaf0c648e9be533ee8b0f92890de657651d8918470e55b319960d258930d4fd5f21b90f221c8ff55fae410537f82e7728bab583024fd8192cc2bf02376ef9d8f7612f25164821647f6e6059d51c38b5f8ce94c82baa2a0f80c00de3aa3bced3cfe8f181522f345852ea67f5c595dde01384947f10f8fd7160daf2ea3c80a8d3057143bdcf9576c710c9d9ef806d21ab0e1c2ba13600109ae2849def28f1031ebd00db4c70139fc9c6d8638906629671c53b225f637cbbd7b8bd9a9e6451d4580b51acc9db2e24674135e50a0358fb2dcf6ae21393d6c5304a4eea8c26f0c9d3e522c46ade8162a25241ffad0d2c31c8d6c8bc54113a826b2ae8588bac277f2d9688518f0067d3488d0aed040a52c1f9a5ba76e98c3ccffd8606cec3cc663008b70864f113db705724b45da9db54e3b3768bf4dbd210ed7f69ef7f6d2adc4b46cbe11e5280f751752197f840633cffff65c6f52d96fd7e40ecb663c8c33a28c5ba03ae7a03489641ef129e490f04f9c5fd3e3f5e135af996efdc1c24475e886cc08e3a66ac68ad583dbabbf2af87b027e429ca640cc1de92b2849ed596a298a8d67e9e6115b4da4a61b1b455180da8ac0c497615f706e5b97d68c00a72dd5d94d174bc9efe948acea0c04bee01203d0d936486606779d4427c53df03d793864d9ad4c462689753b8798dbf2e683ca96376309e7147b670159c42887db9b7ab9bf0f0ff0d1265f757db78741927342e9777124a186e02391db4844b00c0080695d5ad5947a37645069591b9b1cf15ca9853bb3682ea6f342fc46e555a4bf71779e186e1f8220c9d5803744016de0736561261198c1f9cb415f361bf58e1f6e1c05fc67c9bc73d1bd0c90f05b3924561299e4b07f6daf7e29ef3de628e87dbe52ea0bc58675d19affe82d4be519e1c9dcba1d6eaff59559c6216a21a1b957b98a20fcf45c18bd7085acd889eaa202ae759851cdf7281e96a51051dea49cfa77a398c23caa2f80f904a627a639f43ba763b0c61f8df7abbae6f9fe1626051adc3b93a61cefb98b8883913519f304e57e5451390186503ac819768665dd53213eacc21fb50dc29a215f53a6df43f693d24c0715c8e4295b62b9c712a03881192f62f4391660ad37e1f48c87dedd3829d96f45d80c6ef6e74e672f6d89b9cadff802f427d63f4c103b5aa0119d66a9b26a6747dc258297022a88208175398dc5bbd394fb17a02e6cedf54853800bc9f1531d17232d5f3d068ca59dc21765101828eedfbd63bfac6e077c20d47db24a75cb2265de7c2585c59de0a4c25baf4f25f574baf4abb7b4cb377ccc6ba6089a37ec5397a7659e41d683ac2cf2acba8145becb6be6989fbd5b2e9de18fc158817ee3581c09d8e545ff24f8c9281902c8d06b65fb1fa2815127225c3d9ea30c04005c5b7959bb58e0f5bcc3b33ad4f98728aef973a81c68a0e8bf164052a7772dd498d4ed1dee1ea5160367ff3952eed6f03cf5b885c9c761c18d8ff6faca1c3fd1a45234b997b65d3de8a445a2d9c12fb829bb881419e44f5d0d8ce5e5f8423bcfd14b3b3e6992f39046263bcaa82178bd3ce8489c44e96dffb713d08236199b16a45ff3c501b22476667a279052482dfec87f698bc949bd2b89f62d748f5d9a7e737237566e223c5800180194e4141389208b5dcd6cc0f7288c84a2fd7b74c79332435607f8cb44898c14606f5ed6f50b99dd54e5451ae3f45fb69bc3be4ca66004864f6b38516a4e6579ef48eed5788cd8f2a4ca13ad20d31b27bbd2a01e414259873075625220de7d1ea5e22766253ab1cf602694f1c385d6658e4e2464cb2aad9a289b932a3a3339da5d28d56f67c3efd87399938e736fe43d0a94586bee12fc1f3d4b2ea1131370bd9c8a28d844da3526597ec765f0f8e225ee52f59401240f49ad92ea4489bd5633b5edac751422ea0026019e3b27870549550e2e06cea84a95221f4c115c4097480b75a7dd834eca14a187b90969d598473fff68265751bb0c6196f793902f0fc054d69cc99d4b0c1368b4af0fbf505c4a74ca68c96c2b6322064f1e9dc29fd3d2fd81961ef2301b00e60aa5961fdd3db126778f08f518a2842a43d006f25c8ee2613881a608a1bc9f8a2fba1648e00a3b86ab02d9d828f0dcb182b628522c5f34b83e42dcbae948513b2b43cfe78fef1c9359dec8ec02961620eac9ed442dd5d02235dd216e1475863270d5ad0cfda94183c04e6285accf77cb70c7f7aaf014d406898535249d1fc403e71f6d27ad2dffdb360acfff384fb8bf9064ee508e034bfee18391e27c827c04c18ca38dd9570c194fd8fe04f1e874bbc9959b8c0eb501f50fc763b0d9b0c1a33a510231e7aff6e5014de82cc5d9df085779c03296aac58fb9487be94312690f07d7dfb7e9a41ec03b79352545730d5a09a8f15e76309129db6005c97f62b1e100218182bec96847cb57d7ac567a336ba3d02c8c631e924ae2bcf47afa40e14ce7d847fb3dccd531c49711e51587f0a26b0dd851f44ede43cdbf576ac6ab6336a2ab10272311e9bdf54812d74b04709f400a38eb49c75b78ed06e682f0f6d7388a2ab77d0d221d94a08c2988ac1ac5a7b315aa74b8f47d49b0dc8aabacda263b6fd049c5453dbe82211bed6a5fa019f9ba4edba487d7c036bafd4aa3a88ee40a4db8470d0826587d11a7eeb58ea363aa3ecd9c7fd270129417049bf0719162eb13f153dcb8902c5ac81d8cbfbafad386be300378c5a495e6af6dbbbbf3de5aba6026a56da0429e1767587d94461cd4e166afbc3f5231016d477ef59ee13d54bcd960622d77e0c84571405e154afbc78011d4f056ab5f780b9acbb6e3b64390619ec8735bdbbf374a5dc464cf75632c2eab09ca889a897615b36f0487e67c32430542e0e1af9fa23c0b4b573cf84f93186af0914f5e0eed025f4cd35b21def3c1c5efcba0d1878fce4977de6723623e77624d2286625894096b31cfe854a45a0230b5034635cee09f0c4b20dd5d03013d1be9d1d3e2878e11b8655c95400d8d56e80b2be0cd85c63b4b3c65cce4d157ade328f61900467fc90a99f9e489b5771587ef30e7808436b7f4a3e61887cce9d479b905bdf6c5eeceb9e9014e5f6656e6a76d5f1a4db9b0634e0a14d455150cf370f27dcf5289e9ab64683c41f0728f0c388ae38d0ea0fbd8529b1cd28591f7fbc929c382ae18af7818ca187bb6e3bfc4f35cd9a1674b0cd91df6d4bc32f962e29bbc592d105e986868e7635fa02290caf65f3472d69da09eb20ac0589615db83a909b8b4bb8d80efb53eb3ddf5ae5e354c8a599ff1fa8c8864dc56d9bc6c3cd89856057ceb6f1d9c2062dd388b3ea151c958acdf1e884d4873d80521aadacdfc8c0cb38f0b94fc72255594f5542cd379a62159e3f88d3061cf02e413254318f325dee6f11b82a14791ac0e51a663e1bbd275758a170c19b937a7d169f18e38166c34ec3e62e032504143f0df453d74ddf13949e6a932d5e50debadc189e50bb7239d9d16c8df460f032267ccef2bd6f0562728b7ac8eee48c15dd86117dbe450fb3a232b9e1f3b42f4551aee9ff9f405a2288123f7b49abce8dcd65b1277035f701028097197fc1471fba886bf3729cd6575ad584799014d97cd57c3adf856906f6911f8ba3d23352b545085e225984dc86afed330e1082f600274403914b11c9f0c0de19073f185a1c34083d7fc7e327438737fd31fe4e8acf8cfc1d0d3585932a368bb849f49826b247223366083af35e46353a1e260dfc8a1733bb9c52d9ddfe0da9161d5ac4c0a9f83cbc01271916aaccb24cacc8cbd58a3748a3f18fea97f65976b8ee2b5fd279c49bfdf337dc8e19db4e1cb1155e8640e5a70e5a45063ebaa4ed9d5c4ba409887f68b54d242a7bcaeea585e91ed944bd862c443ef7b15ba0db3d40d38bad8f838328fe6a4713f8f20b6fed3a0b42d6a3411b7b19399d70ca6265e62d019c51007777c279e750be433cc248fb66dc87876626a6768db19bc565787b06c6ecd3f457e8e8ebce8afb3f926e843a2448eb6792d4d2343db3ccc9f524cdc693b3018a75d8bc0cb5bc9697ba1a1121f898a69638298cd7f158a1932c5462b78ce723c225210b0f9effbc0061b2a6cae82da22bca1fb8fc492b54a3d76adebf7ba777d30ffe0dfe6313ac76771f4bccc62cc873471eb7fef782024d34b5de076f37a867cc97125749939944ff66f414c5f7eb057944c8c53c8bd853083e65ded23feb2d76ebe6fb68d551e5569f08d63993ff1a7ef2c70e337a9ffcf0f50f6f954df33aded9b200dd024e6a76acf566e60fe1ccb33ec379e12522b0075e9426c71bacb9126282f3cc806b65535f5ae665c4e19c43bb2723d7d294375055fa721fc28f35ac6d1e2fb4df73b0d28e0ba2c94a663f11c3529bf11a9deda845043836d46a1b8f943db01388c3d16c0c3bf3d90869691f67ad1fd37898e94a47ba7099305166a6208d2d976480a8febbd063320fd4eff169e29c9c33363f03d31e08ad13224e355fe330b7fd738248eb2d583a6fa1c1e1a851742c343bca842651384142f30cd306476319b4dcb68afb469ab59f7a8874dfe731c006e50f5fae741fdcc6a4e8cbde1661cb56aa484cd90a2a61588e166e3978b1dc16eeee9af98f786e3bc3e96a24097b49cb365da37018c105e213176caaa9b1851f59f8f1ca610a7495bde26b245244d3be8b3b892caa0f3acf92692ed2df33d8e0ba8068b3219ba318fc9fc664780a9420092c657d128581531833cffac0d9e8e0baafab60be399b6b8cea0cecb56eec1e77534f5e8b3a87d6c1b4b5a1a4828b8bce3b0ec9155318f2420fff7816747e132e3e2c0b69b41447a110102c3064be7047c277bcdad428930884b386fd228ff04892bf46cb2e75c65ab97c8e079ebe3af19121ef1f9f81a74735a7a158315209db614585246e546f8b7f988c84a25d1b2ecdffc2eec39e9c9adbb61655493965d829ed633b2b15d2f411d67edd9f1d0e102468dc77552e79edde6c0cfe25bc101ad70d3598e8927d404aa6397a0a275d5265b0fd6030e53afe0df65cbd5828f228d1e8a2efda2d764d38f81ca24df2791166cb698a950adc904d21777effefd0e9dd66601dd39bd57ba933efebfa7a8dd0950ffc91d777e60168ba872ce8092b294efc3504d54e4eb5a4238b5bc7a1356400515365469117a6ddc65f2671d3a03e7f31d1fda92db48425edaa73c9ae4ca143b859fff06f98a8b7e4877b68be037520a656ea70ff460a62ec8ce73fad801e173d2a9398812bd8c283bd97a98e01902d004bd95f2a2fca96fd6487fe3ddce5d49d2724dfb46000efb19f3003cb52a337db2450aa0fbc0e44159420c83c9acce801316ba474ae85fe14eb4a10f6b96f25c0a96ad78bf33b2e55963141adbc120172d3b989335eabbba7027d85b7c7d521c1f5ca9eacc4065fa8bcecebc06e5ed6c89d835528bcdb3c71ea933e4e9f6613a46243459edb16ab0e057bbd99f838a1753cffd68a8aa965291c8643b8d11c927fb114553c19b8a70a5d43c3a19a3765fc728fa50a144e1e803a1943cb3ecc15fc42729af0d1b511ab3a958781ec67e6713819194f067aeb972e843d0ac75fe8392d586b069ff33cd83d2ae0b586ab8f77b5e3d1bc845600e3657c8608ff0ea0fe5d7f23cde1d5ecdca2da8d1a756656b7ffc54056568d3a316a400dfd81a50d86edcffb1abccdf50607ae0c4cff0cd813c4f109b0d5992959e5a96c9f5aba344b12c1e2295651c483d779dcdab74005fe9c6bf507c2e12aa374b73b3a3e3ee63321d79a2a2dc1573dbc0b4793f60df7e8391217af71f5b39c534f626de4864bb3a3472ffc037179e06656e75dc0bbe2e915cd5e1ae3c40d57e46d30cc1f0578e85bef4ff5c01c76b62bffeb9eeaddd4c97476bc80e4d7e879531b89ca889c3a29a6c7541760d0e3a99ec841deb6c9239d20d97aaf5d81384204002f450f58054d7a4b1928a946ee06406da393fe56ece3f66df905a5417f4572a5b055010b2328de154745c297771a39ed9ec55a79437e45b076aa0774f518ea121f1ae828c7f83ed45de6fd6f991097425aba6926b4f024634d8d5ca771acadfdc0eae47213dacec558256a039f0c8dbc60defabca1109f3efaf834c4c0b22c1bacc678987f7b9082917278b2a3ee00404d57c2fc1d5c23f869f3c294aeb95c125788afad17650289f9aad0caccdbcf3be806b27178a831256423479730472610db336210149694c73c7fba50cd0db882084af5df67491b19b138ff999ebae50657eec6a1896fa42714d2baa33a3c76ca302d031ea0ea8c14257f70e942be68ca1b4d33037bf880a59ef6453ee7906ed7fcd85c84f216acb6471c64e3ac7c8feaad21d288508c66e2e1445f51d5e2c40758be0a69feaa9ef47ffde5fe757ee6f5a37ca5d90e50ed1acf0e6a89b480c3faaaf5bca6609958898112593742510f83f03fd4af654f7dbdc8362661dfe40be552d9fb05a2d016b0b9e799915046500f4a3b9fcdb8c2267ce8f9000bc58316c67edad824de1363214562c165037d90766ead579aa4b825de700c4ed933e332c10481a6c581dac51dbf1e0876510bf0e5373c3853948e18296526d59e631fea142f00102db8e30be96ce9b22efa834331f54b4f4ce8a38f21d3956a6d1bbfaab3d1549aef65f277b4c44986dac5aa484fa98eaba6f9e0b1e88afbd7811046dc170eb1591433649c07fe5c6bff8c54319eb8c29d07c22242bea1cb86847b819db4967caef446fb78b1ae7f16ed54589d5395c6ce8efcae443281ca57786d12638bbda583cbea94a39a5fac9f841576e41db8d27add4864e81f8d7b01b4981807fd4f84f342588087f6f1902c37ac63561263f76fa66d76ceea58930481a6ce750c40c88c389dc0d0303857a572bb1f47f09af92526c9bb8ba75e3d05506fe72843e1814619d75c45b647231b7bdf90f405ad9b1613fe3d39d87bc56dd3c053ce2867786b71721454d5f2280337583a765b4ba07a30d2e022285fd76effe45244bfa1379ef75bf59c97fa2f574ed7b47e1f48d526d22d2fad67bb829b6c935f51b65511eff5f0d9a424d2815a4454b69e07a2aebc57b711d3bbe445ca74657545a5450a9c3de37e294ec38eb84fcc5c81df803e76cee3d9fe99619fa627a251cc0c8f9a2711ae2d403e9ae5d7f770fbf5842e6c7b050e5bed02540981d31bbb5df8ae3b23317de2b02b5edef7b7530492775af67e926c2790ad67fe91f8a1ae3f76fe28ed6bdda14768cbc4cad999e7b795a854ceff32781c13c4c1a70f83336305d690cfffe9847851802267c7a18e6380a3d01e1b33dc0d20467a71e6d5f326fd64ed82ab6edb47717b9c28c4de5eb3a4e86aab200106250fae599fcc96a442aa398a411a8d58a2b6fcd9cc9b9c2798f144a5a154cba322c198f8670275b870bc735b5d926e137ed997828219a723eade3dba7cdcd8b9ec9f5c5ab324fd40ae73929834547e027c6a49763e5246faee2d2f3707e791c39dffa4d47b64f07e647fe48a3d0c84a38a779edbe5a1f188752d2af613f12dcf5d3f32b6387c03b08cdd7d5d81433a17bba44284bed17ca5933e52d1ff753d153292f95be5a31a75af55253b592eb5be3b343729611a834a9a36a492770e3f4b5eb0467fc7c7305b1f859645a7d76af2c79f5f6e45af9f979156d2f446c498f416cac821bc03e149766f4b8d6881cd15875ff40dca111fc57666379a11a8093355b6798f971a03314fef394725e0dda7693ff2573e4c8cade6a92ce1303f4d49f9606d31ae9254bd481d4a324a029b7fbddd004c026db9c6b1f2b7998c1ab1ed84a9b618b71410d9a59252b2debb8eb2fd0130f7f786661a0efd5d11817d9246d155423d34c0c6bfc0f10173692a0bb5578eb932ed86f90817de68678295b9533395b11f02f11782a1036c6c671f02aa61cd2bd8cc5e86045ab62bc04e8874ccf299986545521c5debe81a0312405d0a2cb87b65e7dbb38895d55322b033429e95abda887fd39041fda3cc16d1aa598128cd869022312f8f33862c7b148b5889bf0decd89cf4b5a49abf03b08caa593824348a0411bcaaae27510d4b8ccf132bd0a2c73c9f4be58f56b9561cbe46b0c42fe52c760efe7be830368cb4303818a14d860afe6a3c12273b9b3fa41ae6e8579b22baf3bb3c146a180e666ac8b162952d3df7c1919bf9344456a679d9cacbd8a3c7783a7982d15dc640e5552567c158bf5895c9acad91ede933dcb37d6c39650bc652733968ba6027cd2ebe8e19a2b0f488bd8f4a07da81716ebb89e7474d2194e72e2895ed8914727019c421bac6540ade35bd98031fad45d0d46cb7d7ceccef3050def2a791785e2e551adb11a29b6bfb312fa000f8eb68c564b170770547c1fcf8b5fca1e008ebf4f43034304cf8afc286d83ae8d2fb8c28e4daa410453f666e7e8bdf787a0f22b805efe5ceaa363904dd8da98dc431888e9fbe440f41139b945a512192e456fe43ec3bda06ba066a07f49c36a22e1419075b3fe75aeb7e43f642477baa7b3f7d2363986e18265f48d4378e286cbfd95179141cc2770f7e268b4aefadbfadcece340f41b1f8f9d08d1ffdb9b0e4e83b2260957a7e7221b219850c47ffff2ed8230316a4346487e18c781e79c2b220bdb6e2c92f50e108564fd665ef15f47ae1b899804174405d0e382b31e27809d4cc547c57641ed0c18d17ebb55ca2deea68ab1fabbce1e479a6e19aae81f2b407b95e56e8ea8aade6c950fedbd1c01d02119dae182daee9d11716b0f342479d4f4cce43a589c4c0f819cbbd62ab089846ba7ccb89f75e177283a4a9754c641b045ee883aa30ac0bcceb68f53574f0f6b95319df3b13ec1f21dd6e25a3383d64452014d535e548274357dbf9a2a324a50106c96255f3aedd1eea31855855001fa01eb4c37470898dd07d01d3cb10054eb7d0c5e409f22c3a0096fd62b7210516b6d1ffd4766511d0be44ba991c638a063c511b7c9f9d8218bc63924328642b15c4817b356f80adb73450d44b85bbd3f679546715b77b0ba4286bc7d246923777f9c04963ddcd70d9e4fe7cfd74bce4ad5e5a195233da8187d4b4de31988de1cb10392f7588e9082c0398071c19a8627696e8241cae7a1d2201d3e190fb2144c4762281ce6a65adf7a21e332141e3962d7c10e7469cac2a6d3c34ae314c24d1ef458344ea4b0b501dab4b54e9c6fad501242015ef3e6b128eb0d5cae8fb05d91fd8b7ba1339eb5f2f4bbfa865d92f09d24229bef82203ee4f62eac325b02b2071144343ad41bd7e9d0d71132d2525c5366b70407d205cfcc60a0cd46a29f21c0ffafd63a735229a3736fd74b1c525327c9c0b86a75a0b784de27c4d524908bee10a1d52de3b489906611602b5260c9377ee9bb7d99c1c42a596b0247d5d4f55e0899f97dc99648b12d39564789c9477b3644a9829f622bd2b1def8e201104af008eafae5241806afdb1037b73b5e85dd9ffd1072331c65d1d9770836cbfd365afaf30cf28465eba0d6a803053b824d7ace3dbaca6e207be015fd0f1e7175ba5b3a96559364367c6edb91e4f7250834457ac187194625bad00320be7144f520e358006ef30aaaa8e3ae558894a69fecf90d80a5afcdbd2ed2d2ba6de7bfaaa96ee3c9ff9a9ea7cb712025723fb8a9baebeffd814ad78e31a97785391cf37d363701ecfb152770324e858f9b817057781a22a3f2c841aa9ac953192d6bc4dcd82f7eccc3cb4c77560289f03f5d999f6fba043c5e4f56033bae944c065e4a055d9de6a675d36130c154e232ef0eef51f1a5708de2171c00d52f510319992d8a1f7a3efe6f4fbf63a213637d6fe5e76ee49b70e0d525378799a08c34cdb867152601900907aa28adf859d7020106b373c54126bee6328f2aa4b74547c96a37f157ea8e4b4a1decd61943da6beda54cbd98470ef376e15a3f4940fbc4caea5891af8dc1cd4303e0180f37a8723ea5fbe3f2f7205d79a9b79f60abd2b6c87ace3756bb1ad3d59d423f93ec893953244e9b199152008d05bca796379bb56765a9c88c29bf7e45ac8c90e983c7129e6d0e8aa88b94a083f3fa8ce466afe89365f9af2039af4cf96fb87f4ff2428cc27438720d6d93f503c0174e780a3deeb0a3a22ef93acfb6401858d1911c4b2d8e02fa904c529daa6da058e4c437f7913cc6154c2056bafc4d5f5604cdd737441c239d121f65783bcb77d635c93ceb996624b7b95d14069fca08d327582c93cc383b17cd8ea5304365a7229ebada1ef25ef73ca0fbf78132ed10111ad3c5578de817891120a39352fa25367cd3ae9e33db3879d63344bf6b83162e95a1fa2142820cff8d130e88c4bb544b2716fd7b5de9c5eb62a7b0017f96696dbcfb188246160c5564bcbed08d9ce8fa23045a30d2167955416e1e3a52022f2f990423c81992c92467a627bd587de80f80e975546030571ba02a97adbd2b1375b013fad06b10fccaf43427c0b19f52e3b384ee4227bdaf72109afc945d9d4153151a48e256a27982d201a7ae386693e0e33284a1a4ea976dcf2577593304e6d09b4b61322d37b1fb44a0d50f1a6452eb9b9a9980682dc7a6ebec84fa92621f5b1e4824a3a9665e4c3a3dd169b46c201105503ca6878d06475083d9b78f995d46e6dcde69fcf69404851e7073e9bded80748587b883779267aed4da98033e5a551a9caad08f287281dacb54997e74b9f4d4696e49b9ace43e9d7b17150b61a66379a6759da5a585e394afa66316f9819e6a67760aac89711691cc1430831e471c4185be48dab89f2f5af55d6650a58f782485882e72e71dcad41b943664d4f2f85b53b7897b6a861f386820dae29380242638b5cc7372ac87c2ad6bd3e7ffa993ea35c5b9926238de42d04e796848c55e575b66ec7577725e0b586945dc58c4ab66ab1031e7b6b4cc99e311009bd2ec6c8a3741005648b09820c9246ff360dafca3c74a782598d89b6426883c3a69bc18baf9d80e959d4b99750feb8ad89ac6dd527f760480404945c598bb71c84582ab216972997b0ae9a4fcc50c0f7625d0039590108d6ebbd4249eab87cc8b97dad13ffc122a3d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
