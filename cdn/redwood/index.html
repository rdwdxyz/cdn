<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a3914ece0a64ef16325d273436f13e621925bc3beed77baa029fd5ac136a02c2b10de82430112076cef7f02d99e0441145d5f59aec26e0ef8f61247869245e90caf8a791454d4c6aaaa7d2fa9705f6b0590da5e34a9a4f07017f931118fd8ecf702512152d9b599b183c8f3319246c30b1c6d9637f347bd9bd43b2692db85b92fca006cc88cfc8d7758232779fd5bfa3d3683702b5d07666b72cc195005cac4cb1e6b636457d1c1ad7cf2090c41c70c4716594b503de7312762e572bf10b6a8e3846a3d20d1bf127bca3eb5f3953afcd044d7f3558341343cdd63bb1639fb459ee359c3a149fd9de3034d93a8e7d05e78777c80248b5dad46450d5845b88149a45b9bda2691d2766720c4181c39034c0dc58a07b9811965cb8bfaff9249124b8d1114df0d4fd461a22550f3409550ad6edb1d3f35e2e41b263a95fedbe42ab7308b2cb4e8a5d311b2cd809ac6216b351f9a692860ba2249613bd65807452949ee5a03596e5e4e92614d1230785d305af87d08e91ed3ca9b913cc2b084f532e07f26743af8705093f9020bd8b36746be17eed06c2af4f55141ba7d80d4b6ee47a2387c9e89ce42883300397d47a384bd56f8c7c73a47c89cf2ade22f1973f44945d21e3a6e75e5b08e904793f58cce20029b5ab43f5d90d226348a28633981920f06e64f61c326c3845270622e47c5197a935144f1ef46efd43f445c858b5ebc2307f6d0593c603c6126fdf808c7fdf47116341ee808fde1da7039c67bc78e3ec090a26d09491fef3e8169de217017ef9edb4d3bc7c913e0389731e17bea6dd68258938ae6c93faf32efa25f928f767b75b9bd7f4e18d311167f81ea6da4f4876fb53b451af4de1f09fd7be08cf3c805db1e764aced65f7dc78df0b7c3e82a783f328ef7c219bde5aeadc0545344ab660445476a15fe58624d50e7726458cfd15e3917effcf6ec5364352c56b38a1af8016b389da7b8f0fc7ca50b0472093a169e360aae736bc3b105d831ad59b4bc1be375a2c722b51201e34bf09daa0cf28a5f15f380f13796b8a5494dc80d9d8a09a51bb32a2ddf9e0705991bcf7dd04275eb72eddf1179ee2abf3d3bba067d07a66c42f23d6eade0d66f8c56cc59f95102980bbd590a11e7bc7bbe4493aa54ca49e1b3376d52d0b648025d9c6196eed652bb57266b18cdb98667046c0a68816eb52fcbcd0ea460e4b507571b53bad4af5fc17190963a5d93e8db7f3790210cab0144b82531a2563a5a36a01e4eb4f3a1eb2ece06713f1c49d6891a8fa4155d53b5189e1493d1baabd651b0e75c2aca1360d071fa68ddec9ce13a98032e08e750269c45d0513606219ea23473b142b79ebbd291a7fcd9281bf2b55d321675439fabddb8465593328e6fe1d8dda28aeb070f8063547629cc8240916e03d36444c86999a69aa35775609749f560a76f529f552bbffacc356cfd506b6f93f7840f6918364bf8865422fb8c34f004fcbb4177cf39f393befe48b9d65953f2fe9362cddfbbe898df68262a389189d6a30825ccd51562bf0570191461a847326daee5454308c4b3a273fe9f98e6f01dd550d5a3c22c1cab3148cd2f31cdeab177c5c5b1466f62ccd604a3ecca2a4a83aeac4aa35eda5bc1e080f1a00af123ebe0dfeb2b293af1fa0e82582d378f9b3a982b2533c055d2d39e897b876882064221502f05631160125e14457d1be54beabf7c6238f46086ec2fab053f5aa1bfd8788ac1ab6b1f617b00563be1c4eba70e6ebcc7059ccdad0e096c3641e27fbca8953821310903de081007baefd2dc49b27e436b8341d3b36bc733acd89f4ad132d0f1f59b1b86cfb93dca10f602bf6bb50aaec1b81bec760804deffedc7581e14d6b0e6c8cacb1d5aa2f3e07aa53ad7404ef16978bec5750164e2ba6d9a02c84051b815cd1c968a96ca6ce104c444b7c100d257cd8d1953a5044cb756132e90ad84e4970957bf74299b9c7a9736169141697ef81c154c3c51403b482391e6259542066bace20a783d0d722261edaa334e4bf301ca8518fb9acf4f6d56032b818cd9c80bb345cd7ad5d8b4b994c15a2ff09d8022b51206dca6df0b314c930bfc499f57895ce695d7c91e3cbab6a252a823aa54f727736038075175c1cb1537f7cc8b15de5419110d225d1e5dfa7fa9a87479c703be79ed7830f2638ce87c98216167a4a042d44ef121e717ef804d8d0ab9d9a99bbf47813a7ec241d053e37c5e677192b01771c24dbc751ca0bdfb8cc362c1e4f5729b9b57a35bd399956f8a214779ee7afc13c183414ac143a4b17d45ad1b9909b8954a07e6b2b3d12e84760005fd80835c1030a6640332efabe9c5263967eff5138c3af9aab789c5bdb5097ba62af883a1fcfef5f83be945f81e653926793d60bd64ea252b05e48143389c60e145cd44fa3ccc632c53c976c9f79508ee7215c4d5ae1aee9761ba11168106a6b2891887192792fd2a1e255dcf9cddc420de79fd5f4b0d3f03281c549721bcac7a49db9db44111b6cf9722ab580c845702d1e0458a9c1640b38bcd9daad9fdb7200d3c805e77c5ee1a20654ee250d0274715e400c5ee606c2aff10d3b4040082c11fbf70c7fd14250bc67ad2e70f424b2264fd90c35d9fa6e02734ee316778a87578c4fffc9fb9ead2fcde7ed074159268c7960dd411a240c71f9fb1536e26c80d78c2db55ea0ad854c16b342154608be9bd1236b52ebfd9b94d81d208f94c0ed2af27f099106c334bc7fb728846a2a6541afa06faab6463f61d3d44ad8bdf9f3c740d66101724ff1149b455a29a737e27763487f325ca566f1071b45725201a50540d092a54c37fae6187ea8196b999d1495db0bfbf6af6651f5816d192a8272e32ca460390f89fbd2a51e22b5a4fbe5e2f63257e208b5c814ebb4d4109fc92cdbc64a223b7b56c86ed540ab2b8ad8b6c35dc0003bd9c9b129769e8375af909297d1cdf768229c466e90cc408e8dfb90115740851d02f457a875cf706b6c3c4b73d8fb9f1d8bd27e2d04fb3c52edeec1c9ffb596c3a189e83d2913c9520fe1276b3b254ea14c8140312f4137453c76ba283925ddd988b102e96cc93130e1a6c3f3201dc0df230f2d4d8ceaf1a0ef27dac699f5fd29138a141c718d2ba949030ce875e74718ac8b7446d94fe4f5bb1af136f64b1794029b20c2d417de3cdb68c42f92ac71fde1b3e53bd5076b9ac4c2fec345b39e1c19bb6d6e7199e47d1b60de23816a7a05e0bf69d84781088367e1362e1a63c7c114584c4f4c09544d47b17515126d37a3953aba658d4c2aa13d490037762baa5a28f2b934594943a1f0ed9bc531629b4832d91e819d38f75038ac599380b68fd94af229e9a0edf80a3a39364ec941fc787df18d25111a40420049ebd135ab3b75b1014db37d661e799473626c9ccec85e7472fc598384754b51c6bb1ae83724ea1ccba757d5e52ad2bbd7bef0faceb1415dd91cac9822b3956946e1801581e76bccd935b14760da649f4a2220dbe34384956b8e9bda98b0d290607494f119500c9475b6b36af90039ae656b7f8e9b2af44a23882dd11c344e8546e8f1f592d9ebf69cd57c6b0d2e986aa2d11f0487fbe94a520ea2f44be4aed649b17ae283aa160fa1d461f72e43fa948e510b6c4b2bc23f6015c34e0eab4833fe7f2501a58e95cdecdb490348189977c64ead57410fa2ff024e742f34a2a1ddcf686623d6ebec5d7c626a058138226263f0f44c57eea5f4e160868f5976a6f9577221f9307a1d86f87113d8327e0c023d960b443e7be06b05efbbda6cdd114b97774f8026d94beaa93fbb7088f3e8dfa992822ac50f148220704c6fce062202d5686a17b3d4970cda41578c70ba2f5eacd4e70fed31788ca55d54c0295273acd2184559220fa67092f3de8d59e9a326ad2e4fca230ab52b6d5a8e4a0082d2144f26c1366e5f43f188a073a576d2877e51bf0f4077222ef09a3b7c3180d97b1d8563ce5f26f72d589070b5e621c55b74359d481c3eb633b0b5b5ee35f8ba77eec238980e7c543cb217d9f183af8407ba5b84133dc6f5ded14d1655ac6934fd6ab045275e27761e6e015be96268372ae4a18c5c5747a04f3fb973787f994014e79def9c82d57da6324f40b5b833e5369b4e1fda73fa8255e981d934e39f2298b13cb0caaff4c2abcace61e219e425cc3c84fdd9f8a385b888626e851a1c171a3c771d9461bb5cc4485b0456c2a5e1d8e6389a975e3348d0ed4b907dc26afc07f9553dc8c1082f971f12954ee92576e1d47766b7773118875f4b1977ba3a8b7c0290fc2743217fc233c270da168f882d995d059afb2757dc493e7295d8ae6b02e607f3ed54fb6421e90cf116836051f06f05f5afe2cd7fd561f334e5418d0ce4b423aac132a82374c76acd8cb8637d53ce1eca92f20152ba5f424580f81fa1607cbed1d6aa72e34655f140302747a518ba9f2614eac328a8c2e7dd89f031259c0e71c4f040cf488ab58c448b9d70dae8484e261eefd0f38d8441e0724683ba88f6516a5a4700378f2d5cd2e2f47787ed8c691f4b979f7f11a4d7c631b6077791055d0e91cc3a6a7ba9ee9b6204678953481e0ff3aece3a15aa4600929aa4ccf0eb8f16711a08b7f95871ca984e1adfcc7d6f6397f71675141ffe71c6adc252551b38181153a8fca6e397d7a9f9b391be820a9156404eb8829f7954622a28feccffdc206b35d4eaf11694a6b7204ef61947062f5c244622d5107100f70942b594d10b1d184a14f32dcfdb3aec5575743a739d6c1fbd3de2be62cc64c1a331de8902edcd94ad6c92a179ecb5e61cbf002d0a93d0deb5f6e5ecb7ff48f67cf5b61b485e3a327cb9e47b3ea5d0c14c97638bd2129279d1ce4621fd29e371f57b247c939c26018df5d7081c395f7f150540bc217002d5eb76d7ac4998e7540e7d8a4bc36a4c35d5b9a08de36a2f95822e5144c3b621d7fca473ac0be2c8e967ca880f684ee0e2f86ba6b4912efc9c8a35683b8635336ad116e9e80fcaca843a1a6aa9ec339a3849a9d9d0156cfa65583413954d4d35cbbd6e9cc9d57b7abe188168481d5cbfab8f7132482d6edd6f691c34bc7f6f5512c4198011865e68b0b5c20c4d8cd0b15df3ae53c1eea7f37c6f55098afbf7f6567f454c0f9c93ab5a1e4a1b5297073e0efa01a6221745bd20d72f922eb2fc794b845ab71645b6c41b44a6be5845b8d933635069480cdb90393cc43dc01d58481dba196617d5fc41bfb7d2513ae9564fbbe9ef139990c3ed6e860d6edd3f3f73e7c417a2ccd80f47dfc9d83ec4d022b2cdea9489a7efc6bb93b3ca90e5a1dc4f6ec8d871d5473247a9483d98514cb5c26cb13dab2e17f1642a458e6ba9e2b529a84c37393ba9824717b042f20fe7166498970bb09a00608fcfcc542459d440adb60fa37b19118788625d3d8425155b88c5d49af8c06a702a1f31a8cc119bc940a7c6ba6943702bd782385ee1adf1c1cd90f1776a0ea6012b789539dd792476921015cb657d8c7c1e9bb3ecff0e0800a82e09982e5c7cb8224e7131ab8fb8d43fcb41688116d1e5ff33711509f0017f5261b3e1d06700bbba9ea6e283156262617e565ba189a86beabd9eacfe8ef1c28c63bb92d6d96dc1aec542e6b25c0ca2bb781aab609ed08463930eed4cd32345c06c67da743e521858b961d03f0b08ebeed4f6937a9c05581b3a3ae353681b5d1d573d822e7c4c5227f8e3621d873a4f566cb61f2c6e7d9e8382c560a4ad8b2bf7da88713f3a29fdcee69874700073ec2f7f1fd72086c8e8684ba635972b0e33a1a829c425f26c736c310c1efb4ab2e59de17bba233f5313b53830e4f644fc46adefe5db6c6d24b4c228d57561585a8b5e31dd4bdb32a26398c174fdb9810cc9f6e5179b3348eb4a765ae62894ca92d12eff830d444ecc864cb7ef9e9468cb86619fc5b1d4132a1da5d841d2bc9438ef7cef29f15076dd88050f6599c1994da44d61f0e7164c210e09fb67c2b2fd28c9d905f645c2e6e703825cf6369b5947b2e5f3e6ebc80afca3bf669b4e5dfd8641058e116b172e97b3a52a9f08ed6b509c43c295f57dd7bf7c28a0a72da12a3f232d534ff2a32420a2439421f12736dc1f02b4477a90af0243363432ad107d80a6cbd5378e5e1d02e6368977d0b743cf9f51341a37c9b101de5b43a6f8747f84db9da44964fb6b29b5e10292336c9cb1d195cd7f010df96d58bdff4144fe6c64de40fad5721c9ebc60878b8360c1554aed6c66cc07bfc3a057e5c10ff8d913e7691f21509c5f9d571fbee721f62a3233cad975a955cbd4ba8279d37724d4d1fc1109ee7409aebeb530b11c75521ef229ff780a225689d274d8d31f8f66591dab524298d54f361fa54451b1e698d29f53889302d1a88e3bedbad5eb96002d1a10704bc9c203b705096b3d9bdb5eea336c2245b414dc7abd368411a0283f9b97e5ccd194876f6a8b535f8a2a2f50d1317ea4c768f1ceec65f5d2781a24c6482f8d5bdfef040fc2b68b7080b6f72658796c777ac407b66c89671bcec232649e5fe0257d64194fb64f9d7e58aba95c60c9ad89c4970dc30a4f39a1473ad93081ccff439cd9bdf7cf4fe85df7ffe6770ef4b9369be7e2b4bf6637c53b36c44da8c4a0a7983c4f8f71ff68d16fe4bebc0f12a61a0e5f61bbce113b02607d8386aca92b8b0714352c95650f5b5602d3379537aa970d885042b5564f5db42b2fd0b6c7290286fd942ed318d92021e21ae903003fe8763284d45613e83836fd969b8610c98c70e1fc2af42db7694b94c50cd7128ef2da70a9c914bca4789aa237c13ac0c431d230409e0a4e3ba0382f2bcd823acda73e483abe0c71e4228c8c3c676ab774f0ebfe54b7ffaba5f269a84ef2ff10efa7bda27110646878f4419bb14277d125dfe743e856da7091a0f983319e9751af90f07ebca78a036ad3d101bedf7b7b1e446af9e6510c2dc02e9b0e654b21b6c59eb7c15e70b1d4c307f25a93de8de9b8e2a2f538a597a41ffcfa5dee0c910bd889693bd36076838a98fa81fc92a8fd9a912fcfa38f083939de6635bf22220da2be4c1db42225ea67ef51b46456e5d110999ad39fada31cbca2805ad5b712a68a26b0e43403ad0442fec5da017f0c24bba6216f95fda4aa20f63789c1ffa89adcf2ad2d4d63c8a09a2283a96ae111555f399e554e3e43b7fd0c280babbb60fb4ab58fd6ababf3dd5ae922fe2dca190c76144d3c45b7a0b934591a9558057076129a52acdb236f9933383eb610433388a42359257db23f46682d8219242d0dd955f2e5373a5ae9b056bb49b91486d9a4621ce782419ab27c5607600ad2842662f24ab5b2bee0a06c371da93cce12572906edded0ac7e862a0da853103e7d6c409cffff9ec1d9c9335aa1d72ea5cd3e2fb04c399f1f220f44dd75f11ee7bf6030558f3699bcb52322a7e32940b42b3382204abc65924ef07bd196146dbdaa335e77c7732b37a5f3eed89e11a0b770ca40a8567722d400045c65a6e98c08b29585f993adb1109eb937736d10c5a3a453f466f99905b88ae777f8e2978f2783cab0845b165ed78911d04a3a7e920763738ef9b0f3bb8c4b2a1a8fd997993b35f3e00fa34a4a9958b3d0d8c28ec47e59ca9a27a8f1dda96089c73cc599134eac38de17e502ff96ae4509f6aedc4585e91cb43ce6921af830e7d8c493abdbc736bb0ebb9e8f79ed2c341783ba1b595928e21eaec46e84bdd090bbd6f3825facad8fd8d357d94bd939201e00b763f0f89fcf0cf584684b782c216e119996c8bd6f061d8cc1e674a6d781aa7d646a42f55d688114b4085147554d5e24e0d8026df05ed9f17c9edc85b6f87bfc4175fad7384f6aeb69d43b7e771c2cc159d83986fa1361d8f6a1c02d5ec6c6e1a5b55414541a9990d8d61c139acc190b0e94554450159c516d9e6082fb07feb5a2da0a2841d5c3d8a972e4466beaf26f0e2b1e1efafc38020c9332e1d04c7373848483e7d4f6bf8a64236969fa314cfcfb68905bea87a0c66d2a96b5015a2e55051b579b6cb7e742f3adc381caa3f4d9722bc4bb4cbc5cf41b44d27d04af1c4c06e925f7084c02f454b1e44b638ef4d0a4d23eb3354c6137a60be344648e0ffe0bbfda7625fbec9bc3c4eab5674aef1bc638b428e41d27412e3dc88725693c051b5582ee8d78a859ee059af20cb583add5af03aebedad2beb07e9adc4bae052df9ff3b9b3c38d009743ce8d7a5482bff96bd6b11862b4a38cb4498829b36409ab15480353978250125bdcd298517b263c32b370d1dd6b508f19f4e628491debb5f54b80e969838219b89f74b75c47953ecc52ec90755f9ff4402fc8c25d7591b935a2f75608d3cd4c249dab11242b72513eb511477bba6dc01a4b5c6ae9b11e475c122c77a67c3af1951af3bcc1f74dba886dc772f55e7d9aba962ab79f7f70c135014209ae15cdb2d97f06264b0205dae84f9438978281117ed00c492f8748e39bfec47dc2002143e0fdb98f7dfafc896c3473a0a732cc176a0ac83384b71f563dd1631bca8082133147daadf77cc52b3da4eb77dd8aef6870e9a2486c8e219b90bc9fff2208ae263c6472c561a1a5a44d17cf09570808b64ecc711d744329b18ced604a99938a2f9557d9f691f4a8b9a08aae11dafce497965d221b38169d579cf1869e43e9c6f32b67fcdc0a8f8a85f8497b8bf2f90463c2161bf10b5e940a94161c53b6b30e36734fa8928cec3478bc41f940f39569b768740e51ee4b0f2d9340b08be575a1bd6c0890687d4c28b3250e7d69bc68ad41b028868e9178378dbcda64f385f9eb90858cc9e4ca4a1dc3dfd81845b3970e22311b48d6990c63d2b6b860b72a3284665334505cd56794f1adc34b17a3ca64e03b026a7169609580c8a7a0ca383ed8b66c2d7285cc56d8d7d2e62da04e32a8f22dfb544505ff4d26e0170915f476ddab847765ab9bfe42ff0a77e62e1aa792648669dc650a099d1b58423fcc2dad92768a11cf9d99121796220b39466f64ee9e7b9a33673f3f38804487eda4d27ae71e4c50b1ffcb5177d1744e1293d51c4e021441997659fa3973f3e3207344ff7179c01d04d43510d9fd39d76d23154a0881be57b0a00b2367f86c9e9bde69cd90c5466e2baa2c60596030ecf436477541998e444602648d4772c4a397fb643337a62516f404349cc479382c94271bcf03c71ce6af670bd8f9c08367818a94368f7894e1ce308587c1b8ce0b578e395b8373751d0e17f1681d5a83025283c37dac0f0f4f51ef0fa57a3ea5ea4191d3b643959d97458b7782f0eb3e0dd1bfe3659e6369fe71fcb9332756c834c5fc6754ce978154ca9a0851853d13f7a48df7e4172105b9bb61ccf204cf793dda5fb10ba9a43f815e8302fdad80d7acce0c5e9c69a4462ab767027899466ca5ed4436e11e0f39211818fc4fdcfe689462608a1a07d5a6a97a7856033e6682a17cde1259c7890a15ec529be9c602729ac31d01717c9f4b6780cf7656c8e6d7cb5c8b7faba629656ac82f03ec2702331ce3f67b5786801d069de3ca644182ed396602662462e50b160a08280c5f20b006200b6b05b4046d50b971a6edc35fcbfe18febcc00261b43d746524cc6c8db750f16de457cdf06e1472a8e60deff6abdbf51041593ddb2c3b762e0f0c2621273c5e8df6d1a90097c12d30b97e7abdccf533e9cc6ead016c6fdde9a775804c258ea7bcf69eaedb6d3a97963ff82601bec9a8b63d69c5f88dd3127d062ac1fec8fa557ac073b8f160149b7b7ee58382c0e2f30382e84f86942e6346ac9ba163dfe1a998ef9cdb5b8628bcc8b03dd737ee517e433629b84b3a441595cf62e399c58a6b8e1efe2100ebe996f032ce91e6df996fa217320747c7098567e7509811a9b4958c9a1395fb3a7f192d126b408976093c19d9723d572de28e697c65180bd87bb837eceea39bc4020c9532233b3d9e54baa0b9535891c78f158d8a45e16d064b8d78e389fb0cdd4ec5dfe4c32f7607b55c1eb92503f90f2446093190d87185a8d97be2720d3a2b31750289746c18975ecfe25a384581a5458d4ce0f0bd735c576a3a9b694851650dce293554a979e8b40276dfffb6f17a7b38f60fd85d46c0e600158b6b829ec96fe476446e0cc11fa16471354289c1498ad942ac73966e9babba9317b8a477af560ffc7ca2f45fdf439a4ca1051b9f8e46acb35d89135fc377a7ee782615c9948cd0152f34ed2a15ab3a6411d4e029055c112bf3886b6e8abd347995fc73b53f81d8abb6d07fd6b37feaf937e83915792177ccdd3ccf7cac57ec34e248eb1dc5a51ac2d9e3648586e7102f35b01c8ea8217ea035e2cd0355b507344641936d488981dfeb700c0d62958e4648a049bfdafa9a10a434c8c078380170086c4478dc6e99262e7f4aecf5948780c30abcdf78f847f005fdc5b8f033858fbf70934deea26a847de48bce7fdcda777b5194f1b8d8235abc4f649140d0593720a4cfee760c09e0bdfaf8f401d8531bc9f07ae899da90fa6f5dab6ddbc9983f32afdc22d4334735f8ef21ea7dcd5be352e2b68b25b8316efa396e99f2bd9c4df82daae9bcbe4495cb957327c7f27cd26c16170b214ffea3ec1e024279d7e45ef5953dd2b1db8cfd4513b4b882ae7567ed3c80506264930a6e90f76689d9c6f7f5011a40dcf29f6c2a17b271057b707b91775a83ec0b61dd0e6b4484288ccc0fa5b7ad6419e9cda13295178f36f6aa712a6c86dd73576162f54cf9c8ed06f8b84e46a944f424fd29da1902a8cf3b6a7e9642809b86491bbb2c26a72e3d7e633d2cf579bdddba5dbc6dc33d7e2ea69c69258984267864735c86b9fc9ee7a9678c9eb6965c488da7e87e516d1f26547ee7d2c7828c1aadfa3858d5d335f8f20e52b1acb95ba55fec1d0e95e248172529510d066e8eda384946c07bf4cb4a0e8747d6ed1208a0110b7dcbfc38e09a60308fef86f730ba67fe54b14f02441aaedf9e2789e53e6333fa29b3211204c7ec6724873e33945f0c2d05353ea297dcd81c4d1358aa70fbccafaf2215a2aa5f2c139e9a4fa57a31fbbb46490e50db5076f3366a07549fa570ef4ec7a268d224087d75c3fbaeb11d92537944419b50672be549c8022280faae5c69d9f6da439cacf3be8e542968fd58b895f7fc297e9249c085d35fee5558dc80f2c6ce6cafb0151803f993d68988c0da41d652c4a8783ed99da1838f869df8e83532d86079f7984081afa2875bbf63a60627174c693d7952e4dd7370e3d7dc768cccc52d96cc238c2ec0b85addf63f3cb32241bea47cc2aa5dd1fe8d810c0688a67a244fbc23fb90823b7643af024abf20bb888f4fac58b2060a6a972e5e311bb8a83ec3d00e343cfdca089438aa044b35ffa9ea26044a112e11d69c43b81314dbb56b48ecdb2ad64692015979ee2120ae11f3a237e1300351698f4004a2fa95d018be3ffa495ab21e627d66287877cef694dc65818db858491784301a62979b73b0ec47f4f76bb0b5df608032dbf2ae8c912ee8977c5d7a2f348ac80c1de93d170c99203c030ddaa149d306d154797bfb43e7e8aa7260ddae3936d8f7f03bb1131fdfad3c294e21e70e2db0294c728b967d04fa456bf662c3af2cfdf7e6ccb95b69ab7bf90924d8411ee4c6b7ee4413bc87b1567a4cde794bb561e1bee3fe2d7bca0a91397179d5a88d9391e618f5b66951e1346ca05d4dd0f832e90e9f51281133d8fc405e45073a6e69e55bd9a455c5d05b95a956585128530df5a5e10eb51d47c064b24078e40e146037b5c0097fc3a3e596dcd20099df895687c7d5d97dd4bb4dea68a742726c6f26f6d92295daf5b53323c41202eca7df9fcffae8b0d719d91096a74705305ff38148ae15b26374379bde5e017625d4af49cb0047f7aded13e7894f096c9bd54186d035f4100685a1e36def2b26aa15e9229656ec546f0413206c9dae4e3cf24306ed52aeecb6f2274aed2d615b79f526a48d8bcafd568be3cef9c0f1bb37a8f873dbdfdcb37ddd537a2c69b0d74278fb363c306da6dfaaad35cf92425122c179e5cec4e3d3c33b20ddbbc1b6f36ae0f7346b095075d221080128c03eeaaefe3fc6517c4bdbdc1c0e262d9fc7f60421526f3c58eb1d6ab9c654da992ed4d65ab65f96ccb4d79326be34aafdec4660ed071089ca401c350206964d6ebe507b5682877fbf8993662c66d45ce5aa462623b6703da4bb0d7667308d653e5ecca5f6e22c0f37438b69c5cee6d511f1dfad96302d7f5a33e87f7faa52196074b39741492f1ed4be5c62805a134c4cc2cef319a254a8dbdba7f5a4feb711aa5b65865f995fc7f8498268e0e0f6ab981c7ca8581fedd9c782480c91244e41c77935ec8dd6df79cf2a5af81dc4d795a9f4690e09f7368fbce6d94bc0b5dd5ee9f33023d925429f76bdb9a4285f37e19757647e7aa76d0bf669fb9a7f92eb9d224ddd57aa52167e782b2e3e449ebfe8c5ac81c16fd6fe7c2fd1ba68de0cfef45c1a79f40a4a88e6c0bb584b3c6e97635381e64f5060251bd07b9bf3d213e201e8160e89e39ecca17a77eadc3e240e7831580653f1319c2bc5a0bb9af5ca11bedb5cd7a5912da2c7de082fda5b39a2339d7e0f836af9c3578c92e9b20971f0aa356b00ca2dfe088afaa7ffd9329fd0e58f732ac8d1c4fa35fa01207950028515a30ad116bc39ee3acd77776b158acf0b3bfcacc593e370c87e550c79bcd57be976d45cc8d7c2987aa16354d8a428bb23225621401084b431bdef76949e208ffb0a4b1c3c4a4a18a6088c03fe636a78893e1b2b81e5870341901b3fa5c4816f07f0100b521365582edf039d09cb2f4301d371f074bac3950fc00764573b12f559186876fbfcda579b6c28a863a79d7a7c7bb145bfa68e00b494a32cf9a40ce92a59e474a79e6785827040313b12aa86742b717ee72605de5d7e2906679305bb027cb4b638fcd24704ba4b8021d0b4a3188b5afdfca38884160e5dee702fbdacc260cb0544ff2555d40faa5bf9e8f8c371d36f7c2aecadb3f2edd0114cd544d2fbf9263891a342ff254fd0f2bcfc9636b2da337f525d6a8fc203c1d79a922e64d6a8f5fa21344c0cff73146ccef177d5c125a9c3cd375b66679db5dc4ed0d5ad4b0b2b0974befddcabe81a524b7473a7e5ae1de0e38b55dc580a0615891dde334c3aedd62d9f73d791ccac3f313d7a3ad0a33a3841b9a83189a928c95194dfd34087f5d7cdce29dd9e0772eb8c4206c549339810892c9242c57e04c1b32e5bfa94ed5d7db771c29b0d180db3de01c250eba8dd3e7e40c333804d3b74f9d37fdaa6a850c56da7feef61fabaa2db240a70d81b27db302e9aba54c3f8f87d42e433a83ea1f24e066b6e9d7ae035d5267ff4228e22935507b50978a41b677408deb8d86b3fb758db4f0990c327de2638efae89fbfaac9001a44b1e1ef8c667ece5d358a9b980dbe1ff1fcfcfb43ba8afa1d1878a5a78c87ade575f4a466d7878f358e4f1514b053041f47418c639dfb2d50d3d415d332e28782d330b6994e97c809113a5079d52f27ec68431ea2cc15d7b6b2718d079aeb458542405f1081e5674152fa71f95afa602020cdd102d6b21a221f1e54e3ef3ede394681f0a19574da780f07c8da4a846a0125afc1d9bb88b4604501871f02e825540a6e71ed36beab5f761a0db54a1176badad66105e2b0dc9336600c97d465b600c736f21390ca96b5cf5d15635a9849762fb554f570bd7ac125aa93c610f4ac26ff082e1787012db03d1eaa13e9f2c274df456b299a958cc914b1b41d87f9c4973925097482997de4f5928e03d271f61197ebe946ca7f41993351912ef9aceb57c29c1e60a65771c63d5f67cd9564001c8580ddaf6e7f9445b6f7e0fb07df0327bc5fb195d7f8e46ba7b7745b2d44e319e2a22f4dbe261c608927f0f6951783d562b267686084cf3c534fd8c1b1485daa22ac003bc810caa11dd1c5304f969eab4aee43064044a540a00e8b943bc5ba03e987ed943ccd8290b9b3211748ba144ec6e534c1faaca364a5af3c2a930b3da9697b4ab4de95b7c99a75df1538b0056904c4223b67fa7bd889404a4a7f00d1501a0bd7662c8c432bbea81484df40cf76577edda240b481948e9f17c577d581d7b78eae8f705cea94ab31e0bf2678fcb7166e6e1230a9c8625b0b108e530a0c384a8524f6cc4814a187ccc914a726ab944c67872e84cd5a30802ccff5a43a7498f1fbdbe5bc1320c212061608473f6ff820180647b43f2010edad3e6bec6868e8c3ef6da07f7a6d88999b96ae85a3b9010d8e69ab932ad8e4f21c624f6c4fd3472e86fa4fa5c8223c82b0b00985406e78a42274028b8d1249a3e09be62e145e7fdf743aaa2bc56de8c400042a453220ba91a302ac1c78e8e539e5d83fa6c407a573e102ee883c030789fd5a36e10c0db4d944c317ee5aef0608efb645b1c7636c9a76249f5c50463dd08b725b120341e6ea06ca34526fea3b2baf07abd3a0cdad2579ae0a70bf016d9a469578afbd06f1201dbd4a494c729eafd207e9c167065d8b94172cc97fea627beeb311ccf4df134172f0cb812729cfc15337c048549f81602ffd68c3e88d1437b53df23dfaa68783809e8e25c319372621b24cbbc928df6686825571e31cbecb0fc8c9c74578c6e5bccd45c74d23dfa3cafb3a08ba4899b7036e444aed694c6a3999f447559466746974d9290fa4f48950cb70529a21c2b3f94f305150c3b5db1dce392e13d5855c3f4def3538feee1f5ea6b509b11ab0c0e499500e63a520e1472fa6b576c255fd6a497fb1fbf2bb906136f9495e89ed077f2b0823b6a39572606231d7ca95fd878249fdb109210d8b54f1a2696a1d33bc2859d9c7034b76fe4fb4a36386aab7ea70101d92af618dd7f5021a5b4dc36589abc6a45c7292fe2e6d9795162e9febb9a83910ca67d4f514a6633fd6436995118e8256252047ea7fa5b170d1efb62eb9bc38131c227a46ec33504a4ee6b70dd8776b62c5893b7fb7e6cc8213fe92926ed86fd8dcdfbd16b582fe4389f872b7d51457e057c5df4d3279e81f8ecb10c16b6c058f058b06830b4fe7bb4da9e2f5a0d6365fcab5e3f842dcc985c8ec85114ea0ce01db7725ed016d509656fb38ca6b5819ea90720e6e8cb9a3b8328e3ac2ea4a0cf5ab52b6958718e745c21c5c0edf38032c16e1ff652f8d9f78b6c7743b44425fa65c4d42e3462b4bfe826770c825bb974beefeedd9fa567b0761acb5b86ca5f7514d93822efda63ad1eb4e870d0ac1bdf11cb3f2a6f7cb37bdf79c07bd9ac9bd18d28540991c2593edccdd740615d9988229445572e0b63d61136927468ab5e53ae8958d4ed9c464c480a7b00a7e5f4eabe91f3e4006e8fcc79dca1ed24665a29f03fa703057b79f85511a52d4f2c4a7d4d700b8f14aacbf85281fd109c1a14f6934817442a6fcc2aa3495e4a89f27a0872d53c60d323d401aee828bbd89dbe7144c1e4347432ea25434baa9fc4aa1ede3217809892a633f79353e3e5c77b358e0e43f3e092aab8f0b82d5ddcb54444f7891a6c15edd8c198b9862179ea56bd186647564e2231f0c64f9166900c3ef4661eafa26b3701c1dc900942b0c7199802578414291d6e337333bc6f4e1f255c1ec2082f11b15d36744b66c058ae4387dc545db84363d05288e721c8494d3b71e99711ca7a176af4ae1ce3dd6728aa2a30b3eef5d42ed407d198fe9e22bec8198ebb0f78e3d82c2988ea49b1da2fd16b5a17be7eede9895fb5eb34329543b633000b5201741ba242d85fe9b51cddf2455a2a014ee8b3850ed88007f2b3c177370b84b1892f51adcb6fd8942ed49b676b0a581f287d6faf6c227b2473960e85cd1f48c591d4d0eaa2505dcff214e3fe0a09a4444643b5c355829ed7e5262ec98c51eb61ddbb8dd5cd11871dc220218d6fceefae2bb9e75b56f14287bdf8abcee85830786a90eaf4eeee048c5163598aa7f17926f5398ba459c3f3d75f524c11f7a91d0bb75341687204ff170b2339cad23e24b3e15871868d4cfae52b322810d81c2a6f47bf421333adc90b24b3afaf82ec414c4ffc214f953ddd8937812f7d222e4ce60c8a08985b93e1b87a42fe02b53c0a4c82513643a8d26d4888f994457a66093cf6f5461a2a3de9faf77175d12dadb62c8a9f6205cf78e1c8eb5794b179863ce24baabd209a3bf1e666fa26c336d5c93f7188dc2ed5256afa6fe13e79aef9732bf40f5d61827f1fff6e95ac455c17fa18c962e43a921605f0e66213eec66815623fe48551d101315014466dd863af4b46cb0a778dc14804207758ea77abc0eebd687bf4b229eb34dcaf7f036d6357b3b8da91fe2c39d4fa9dae2d6652a0aa07ba6f6d046c5ce8a696b84cc89439fb9e37c91bdacb1e4c2ca6f9d46a20128ec64b641073462c74209e9c47c6972a2684369b36bf190f7934ab9768bcc9a63ede64c9bb3f901b8c204be424f86bea2775e0781f2e80632e6313a896d9ebdb2c130fa7e35d7cf3ba2e40716f42d075efccf14f4fdeeefef7b7249f359e83e6f60dcc4f559fe7fdfa107ab3c36c3852ff17b506beca648637e499f752193ec4ec8f95040f79d4a5c4eb618b84dbbca0d00dbe743c8221fc6cd59fc03d402a65bb9e1aaff539c36b93f575b762f05be0bdea3ed14b9e420f572ac71834c169e2051408edcb97e046a89237cb2e448e5514d3b90b23aca926ba09af779b2b764a756b7f85bbe04e5c39ee92db78aeb3850a225f6fc3bc1c4282eb2c54525af015c64a5a7dbd02c1dfea6043826fdc5cb10f4e5ed77421132606610f72dacdd27a7df9487e50bfb011a614593edf35cffe25864813e6485ec26ad836fcc8d3cf69f2af8622aaaacf0c535749034c135ceecb624d32de3196b69dc82e3e0ea6434b87f87b72d4bf2742627fc1cc3cfc23b5851fa4c53ed9e7ed0fd6499f5f27320f610caabaf0f782bd68ab3bd02ebe8f8345c20ab108fc13876f5acdb82c6759898cce1d3a5f14f469e3f4ef98a84f2a8600adf48dbaa1505bfb3ffd972e3d18e0b970eac2f6584b4ce40aed2447a1cc22691d6f8981518e6aafd410b58272c96bcf7a563db3a5e080e9b9db0945e3c4c7536f737af5a40633f90357082279f6417b3730e7eec8e805e1ca6df5ef9c10f4787b2a39d6f1d38d5267f644d1fae75d65501927b9eb5babf4f9d61d7f61919e0bd00d6b242b974c5cc442a5d57fd0b0418a737104562acacfdaabf52b123e0c335d2108ce0694dfe7ed4ff519523ae86bdc467b6077d8f6db7f4c17f5c324b993f3d68400d82c293eada91654d393ef02cb88627e47a6ac6889a1a360f001f5cb15bd1db3638524ba370f74c973b923ee3785b2c3fcc0b6c8843b60bd9036f6b951cc316fff9128bde8144457238e0a963cc427038ded49c118fae638c9eab39381b4737ea6982cf8c16fd51490faac9091709ccdfdf604d17acee7b28778a2e0188a1a84177e005625459900c2a9915cf3cb4be6af701205a6a0e84bb1d5bb34685ef663da34475479ed2661dfecd6a697e5c6d748a2db706ba4673d28f625d1b711ffcd9137dd06c03cb3d45afead2ab4c1e05054834b67177acaaa8467e883e2c573e22a6c22049ea4807b430da7a978149f2e7b36773f1da32f0a565d93d061072ed338d23e59d3b6c83df4aabb85a42f26485259b94a0e6905d071f1fc57263547b425a610030182353be0a8ffc6ea6fb973f564be4e733e02c9b6b4e5af50921a060e31678ce0b10e17c2027389d8b7d405d8024d5d170a23923596a4adac53a03ee28a94a58b0ccb9d75a615d2d0bfa73f5f47495879d8bf4f6c76c0e429a8fe6a7edd6dc90e0362a9c6cf46d8d3756d9388662dcb82a9e30806a2c30b67feae585208fed443b7032f916a393c5db59eb4fb3f3ad914dd57ab7cfc7c2bb466a05218d6222851425ac28a42f424c449e21f19ba26ce105f2f3a2e4b81c25e0dfb842bd81c3c421dbb38138829c4ffc1565d22ba5ae2ac57d86251e7d8b8a944b271ff42b10f92b2571c7311bdc5a3f94bfe64b6f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
