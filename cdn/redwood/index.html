<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b29e9aef19fab0dee0919f1006ac9d33792b0cf2ed30e847735f411e8d41115017c61735a6c1769b17e54dad401eb86b0cb7803897e65f1864f9a1ac217b299c32566fa2b11348703098b926710c9db31f53b954382e77df448a1c135f807acba478cf2fa41bfe198f66c76a406113728c2ab330699b3563c05cd00cab42f4b63d65513ded23621edd67c7beec26dcee2a5e0e85f4a3b48286973f529523c7eba3f52acb620afef1df2ec9213b457db862607a3dbf63c62810aad719577d6c9e43506e351c09e8912d70147e33465ffe054945443024bc5e625bc679b85a83dc37f2563d1cd95c79299a52baa27d4c619b6da378397b8cec994abc2029831371d55c0cca881a01eb73db3188d490f7edf62aa098e6c8eb0dce966665e18a57bde4ee11a382ac5486078b99ef90c4b150c7ec149bebfa63a81f594070ed93161fac6f0abf8f1727efa82c5c846999645d30e969b142fda986a4396722799c25880a5b0c189ddf8d44046bbea519946e65cb8b7b5d1b455e1b411911f42a04d8a6ed1881309bcf322a58fa8cb5017c6893c5aa4efc604d295db8cf5c8770b085bfe36b1d06dfd76759f876177c136f32aac4846fbf1bdb247282937bcc3174c0ad8309fb2da2aa97df9bcef811ec25c6006dc84e645ff55116a73f176ca92f33e0e6d818c5e574a6ec1a58c921b6935f923195420c16db32795e66b95e0b2a485b3e6b7df7124ef0a113d9642ce7aacbbd4e358dc364d0cf3c7f061fe064a8207ea31b7129b879bf45306eac4dbd3bbc5ed89b8d8936be013e561ee474476dd60f2055752f8d88f32403c407285bc9a5e4f04c3d740d09d1d7654fd28181d64739a3e7451fa086de5eaf531605f07ae382660f33865805b69a5512ec7fd2f45047671eb7c7d8f565f1db3e2c71b575de8163776237ee66b3da9b21b5804b48a9deb0d81f4ff389c843176a3b8a69326ad38f950d9c176978ec02196b895ed7537cacb4a6044b07cef49d49e3686043c02a727391409832cdf696e1b310840297124d71ab5338c211ab1ea42fe1a83f427d70e8aa3a2eb5534137b1cd53b29f12516ca840014ccd34ce61c17e4590d78d512376067e8d391863fa3e780d120ce426e347912cb79b8a874f0ba3bbaec92ba5f6f41c4c546a3d9a32605ff7204c3e85aacbf45c4bbc4e7e1e3307d6cb97a48bfd119b4353e93a51cad825a55ff120563c645b3f8ceef69ccfb1aa006dc1119130043d1f6a5583be3b7bc62087916adbd473b8262a5dfe3813fbce261f173cbd06f687e9f578fff5768af4c9dcb652f11c24b4c6ad9695111aec0133def7c69dd1fdad82d6d16a71744596f0398848166115de9b9016b3fa04ddacbe36f5aa9607d0797e8260bdc8a6c37d0c616db6abc35c8a54e91f1bb4a0936ebc26205149aba8c6a0602eb926dd7fff02968728778551d97b4e1a0efd295932880f97a2da0c94ebeac4deb381cdf93505f7bd9169bbe1796d7057a900a5e236e5f6ee756b7314f803d27e0b3d3ad98e09e35f835c19984e49a4953cb88b8d86ad609538547fc1be11222f1774b0ffcbca838c9f86e603d836e831a0211d82337b11ceb401461fe76f0c50dcc4909be2d1393421e76d4f984b94eb79924cafd8675d915bef90e7f0587dc85961479b3e72c35699481dd836c87e23ccb3fcd94cfeae5991b5d5395a790a250cc9ecaa57c14ffcfc3b873d1fe9ca4b35bfe073b9304d8d9e776eee2e5638879bbf9ca57f6f68f9535fcd5459ad30f817a5868c0ad5e95362700a1b3012bab71b38aa8786a2626b2d9408e1f060ea4d0a55b43db2ba913e4f19feb3df58bea2bd118acaaa2d280d02445e6b87c89f95467c5b315bf9859c092bfe048b7dcf74e875f94031504ec7951e88272618bf07e8d8a6fec4a1aaebf31854beba283df7c2abcf201d2c1a353835aea26b6d6eed1a52ed802ac28cb45880d113a8015c28eb3241971ef6ebd634b9dc5ad743484edade4340b32dc954ebdfbf18cb0d9f48af9b7bd52633419a7390ab5469343003210e5ba17b8f3fd864e5438e6d748f5992cd6ee3188fb6eb067bdbd7d4b9694bbe098fa8acc0b3057b72aeb57eeb21240a558fecb124470b452baaa9cc747caa54d6aa29763ed106296d9f1ea83583bb5c311751c83ec36b9e24ccf96e6403091ecc02481d6b6ba00e5ebed2a826d2e21bb6b6eb7d9c7720a0bda9d7056de0a51bdc34153ee7298faf0c846b672c3e0e1aef0693bd6ed4b95de3cbe2cdf4fd82874538db61658ab387375dae341ba76e405b1bb67435041dcbf247bbf630111326f01a04b291df74fc87ba307e8b8e55ca5a84c06a106db0fa455806c618044725c34604707c703d4bbfae6adfb270bcf329a4984156b017ed8ed5a1a4a74afd5390906609cecdae25a5b91458b44bb6595884d5b35d51197a38556b7530233ae7217b75a7c45496c689a97ab2b7df6c5b0fa19822a37e4feaa8566c5b6115a864355a7ae417ec7af41370fbaafdd8705e254a4a71050b91b3a932a92ddc25a03d45788c8663454761d51aab1688537a8a57d1900e422ccc6ea2ab72b3845385a3687cfd978c27029b5b5483f9a48e91e5747d4bdbb591952d63e1da7f663398a9bb8bfd97bc495ceec9d42d5b74d6282c5e161ddeb248e4deb05386c2b1f33f017cb020b6a22a6907eaa00c27ba3d257c6df541e22e11b9bf77dae8516c108c570814edfcfc0960b246156274d55f160789b281e1de72ea657b4908e2b8e8df50dd4c4d111d7987abad2be96c0447568112722013e6f4011dd75f4d7bb6c3a8e1b5969ce92da8e9b838001082c6fbc1618fc208b5a9d48269827ec4b4f1447965e952a6d2ceb167ad483eadf289ef5dbd4bdeaaf168e23516e3c36fcec9a2d3713004478bdcb8f64c2630cfe54ac5a00def1c6ed6d3a259ade6e1047cb0f09b63af52a89370820adc5039353cbff4314261fe7441f9f66a63c04651b0289e4c6be47c1bcf6cb4c2bf82e1c2dc05a2b3d9ebc360c15e8126c44e0edffbc1bbb5818c8128af38541fcc863764ba92ca3e394b645678c17992faad7a933ef41ddd8c419919e80fe58329e184c2447640aa1f67770e59980a8a44ccc097dd82dcebdbb6566212ccb92c7fc75d7562906fc07760624868a86d6131587be8a36b4366c388fb28c1778fabbd0b741a04f463873a01b469e35676f1f7c754707e31fec7848321832652f45a50f5a9e1f005c698d43ef4cf25c566e2bdeda687909632483b0e5900b042b5252bddc042e18e3f0e30eae6e548943b76c4305a9b50856a002059232841c21f7817c819fde3609ca0a9c9228e0c410a29dcd8bf7cc57eea31dc6e8988281be57d4537d93b8322dad57e76cebc2ab6b353416694ef40217a903a5e5d881d6dacc5a257a38a66e36446257dce80d131ca148758325d4ce5c1ef0649df266c505abe988aefb66a09349fd8ab68909907c9a38860c2b8a753820cdc2849187d3c8c01147c4f43aa9721e50a5f69304789c4c2915bb380d1eaf2c0c34456e9df28f8c8a3d999275989cc3ca22c73f0a0658c54365f6f88812502c2ab1828c9a9b4d48dcc60fb871a4622079e670f19a8c577f26fcf9956dfa9f5eb4d76e244cbf1571cf880bcd3ec8f88741e4fac64784df54712fb6baf593f3ef67e00f025c3a675e93f39c966884f42cdddec92d336283ac7ee25a92b7ae179e8316142e40f44528b2af5868b5658fdf1c5abbd4a9726be4c095bd6d21cc13619334fa424138f1d8e8f055749378c5a407709fe0164d80b33ada61d18ad2df294446a7709291129afc1eac5b1a88cedab6e118100afe79f197aa4b81b5d78d8ed0287b84b123dfe39badc84572dee325e8de95e5be035d30a8d1546896b1e4644206a559bbe69291d0ae6be19df9de525a6e9bde0b293a59e4435d85b6acec6dffa27ce040885a2597306178dac2927a8d632216cde7fe159b614db7f1a7ee1179865e0237a2306e4115c719c0d4c88a6bcd67d51d2d9e06fbe706ecd1c0514de62268c885098dc08ea755fe3d5a6db7b2137c5cdd24374ccd2defd22705d408bf0161820f52aee71e93881680cadc7e41a48f95d299d34c43d0bbfc404b60be7288521d6654052b2cdab9a9881dfd3ffaec4400ac1372060ede45e8a46713021d08c69478bf706435897b2337122ff9fae8a396286ac864ec201c91f81dec02179c3714d956999392e03b50602bd6723188e4cded0dd2da90161a499a48ad518ebe0be2fc55aa939eb2c294c730f836df5df102b1a408dd8d772311a433ae08a9af77d0688bd0cd8c7df77949a040e00cff7d891bedfa75dcacfb5272e3d7738adc8e99ee112cf5316f4c2cee63ecaa86ba0a48fa0904c42adcfc971a9d52b8b3ba8f46f21cbc12b5511352134ca6279fab0150258c3c5bfe1c8e5cfabbb5184c398edae1176ee9dba9c4321932f14d7f5056538f1df2157416705ca2e1c21d85c527620b31729fa0f626ca54c86a71f1447218fbfeaf5b9eaff91b879146a8c8e298b3a86e4e932a714f7e97b258471d92ffca83854385258cba3fa95b79a03096ba7cad09c7aff91540d5b38c4308f94e4ff8d24b9df040d1f7c53f996e8696ee79abffe5a8f19874dcaec58199397ad534b0f0d693d15b0272f0a84dd09037336457ea75e004f6310948b614cc073da89ed09784b9caa51f3a76a8cfaaed97bbe4bfb812dceff4d58fe7889a009d8f23b6242a31caa110d0036fda16216efacb51d280c479f546d9a5cc1727eb31115f09e73b65d761d251be7706e7521278e96b7d1caa5820bea3a8a8acf67a21b7e0e23c23535ca4f9e1100eb5c1bef9d11d7a04d165d4bca447f72390daa4cbae4ac3639b24b7db30285cde74fade7fb8cfb69b9a891cc27f25889aacd9c31d4c6ff49aaba047912b81771899ef93f9e141d06ebdf7b9c9872c790a96973466ddffc88faed226d856ace7b1ae6e86857e018f28961bb1e51a5f27588b06a3bd47232fe5aaaa33f7cf371e919e782eedbb923aab808ce8081a144e3a4a0654d2e3f19a78f95cfb4cebe00eb81cba2015abb59d1d29d47a82a634838a74df5c915fa1a07df4d72d50f0406b345404d687faf32fd8cea035615d3578783897077854e5d3b90a8c9386e8f59e3a0272d40258d28d805cde40e584913d23f692a3bc04041036b1682793fab7bab341d5277ea701cda0f6cefcba3a769379e44e3c2a9a4187ee879c9aff34b26be7c0ecc1cfc36b5d306bb4d7f4982bda94a7bc79914bec3faecd00763f7e6e59281d41c6b0d071b8da7a8bfbd4abf81efabea9eba0249b3bc2e779a96e5c6e04f4a1d23d85b282c3a1dc719741742c52488701631fd970f0a73b64fdbf0edf5bd0f088086e043fa38d2e8159fbf02460ed8bedf1c6d165990e34e1660b60c51eb63526741958864d5778001d38c090d5f64a73d99c6d82f9ec4320462898fba9a2328163c42bf707550c76ac2f941dd5970216cc250e66f182091f6849367dbd3240eacdd3bf0ccf4fa5e1028289510629dbb5fc760097de3c4f9acf2da9a5f37e00c8efc66945c335788efc6355a4efa6af5ff5e9d825eece3948ef3c81557ff4e70ca996dfef536fc5eab820682c7a8f6f2a3d921bd76d66a3de48b7a1e5febfc7a4f75806cd8f1bdc9e97838b278f7ef6248c87e36f4d610d03e08db7ac4be99bb58c3135b9b8ae34b144019124f5d27070e333e0c054ec72ec115cb80d25d382effab500b9b21f016b56f41efa4c88e47ad7a06aec2326b0101cccb5d87b249d39b31ae02199a65636f2f1ef8198a91047ed9423d7af66dbcc97f986bd4fc9a92ac92abf1e3f442299037ed7a9e69a86c5221ac56aca9e269b011b6f64414287f4455c8e4520a40338cf81ab75fc8217cc1ac3229005834df173e5fadc52678cb2372616c2fb534eb9a6a563445c516f2f1284cd8619a93043568631cab8901776c1dbc168ab874eafe1e74d9b93c7e38570cf5ec28bc8456122f5726e347270caf040db407576dbadf37fc4d9365b104f8988f9e340f493fd86204bced42e2a3eb77b7393699e931b9598f4b1883b199d470d1de4071690f6bd957285a83e4108349e953ac4aa45ddace736bc065a12eff17d2e3c59258ca06efa8e20f6b501219e0f7498990dc7c3aa4e905a70131508168a4b31ffaf54fe9f9168abcb0034f0a743db48d532d876d3ca6a1a61c3b3493b8e644a4a540d50937fee53e8e76f62122635f8be2005ce1eb12326c174076e446c4b2830c0381e3b3e6b935cce8af8aede77deaf49f140018e8871cf63d223c494fb0d6037996698329db9d688cc720148930ddcf3bbfbdfee4f19d81714af0ef7d8898f76309db6d8ae926cf5241165cd5139d48d723d4288551a8ef6296585de8e235472466dca15addb5cab497184bba653ed2b5e38d8d0210218329457b35e5534c326726ff48c8b2196dfdda6f8f6d541f7c1ed7d7d1cd31909fcd86e1ab6bbd1f926dee163b69a600155dd587a885009cb7cd27c34f1e044e08bef767bfb6c011f15a66ea3f0101eb998e54cdebcfc3c63fb5cf4ff9b00326e0b3933b70f3f9fbaab4ac03306342b3bdb15454bbfe9a5a7d374c260cf72437f1fe07f1bcd681aa68aeb2c9d8095b4a2cb71c4ab7b87cb9791fd6be510e84232f1593bf162fc1c55cdac0053d4fc9832d33fd94da6e04a7e4f9a1bd6611319ff38d584e4d624a4d7db14643a9ee25fbefff449aa98ee19176d2f92cc5d7f999edb17379a09039b8f118a6422690816b9cd30e98d37d688c6a99b20b12c6cf243992b432d9c757cb09e2b3c69c97162703f971bfe44b4a1513bf270c8cded4e1538ee8dfab42f82904a1db64b0416ba23f64cf8f42c8fb0a6c1c9ab0a68afe3f2fd999fa8646a807a16c84457c7f66cabe61dd070fd6d7997ce3b21f496393c5b4a9764860a9d315aa11e710d4a2cbcc2d0a979d4ce9f9ec3cf4724fc65bce9af45c0db112b3180ac99eb7f802e4397e6ff99e349d95a9f44b840d00d82d010490ef57464f25206ce38ceb737cbc67c2ece32eb70e34875ca642e3db270558014be72dabbdb15782e073214ccf64d5a379fa04899e86f77d96ba11c1ffd170d646a14eae2fa558584a791895ee44af38e4405b0bd2cb74b47bcb75a7b59a0066319119d2ad0e49f55e363a1be80f8b0dd5fc8c174de8403efef40fc319b9205404b1f4b6fc15c56ef0f3d08b62cedf23edf4bf30a1089ceb3aad9d5d709c4f3a096fe8f20bc6a898398ad425c2f4a46ee9f10b8022c4391f0d0448818ffdad7086d913add470576832ba6466a38ddfdf3ae3a3b8a7652570f61eab3d1b765cf6a33cebd6bdf9a0e20c05ecbac9ebea55b76349fc46ce320895aa909f564e7c74c19f692035f1c5aa029a2a6b3efc28d5815436ff510ec761677e91a3ccea5afcd2d8a96f6f66655c2b96f463da99e238adc3dc3cf0957d8ad250923291ebb57e3a512e66cc236e0f4afdfbdc5ec2d716474b3397acc762b1041826486b8f261167e0c2ddc1172f7f5daf888ff74c215dd7be16ca02d7bd028e38f2f111766c3d9929c597bb514d508ce5c3b28aa705b9b90f340fed2c915227b64bce22ecbdc7299c50688c46f5aeb0fa9721a3ac3ddc4b71323e1c1ff216c38761501f73ee816df82b46c511dac052848513200e81ef66dbb9665a890d470d9795680f156d3ff5f27baf96b1ad9cb08b4765a0d13f3c56759dbe6bf8b505383391dfdac514d5cfe9e6b2f0a73a4c37c55c756328f558ecad937b6d6361f91cac12177a50ef2f5b76bce02843e04206963f63e9707a06d770ef8a7c49abe1dad3e1fff81bd8a9a5d02ae777a2f5f915b185d2f6021ef8d84d7bcc8be5345f2417a1e28d29dcd96019744b10f37f1b58b70fb602ba0303749edd0fcebcb3cabd1d3e3b87020c6663da5e4fd2276b85563148a77a2785a73a87b7dc45e69389a38d63898314989e156f0a814f5071c0cca23921030c11e3c6366380a4b0812f85b2fff8eeb3508ef50f5b8dc95893e2f20234372a7f272b82158b5551b14db460cd9b871f7d33299869cd88ce110bc85b016b7d4fd85c5a5f7a7476dc1974be93f3938e555ff9fd26f82d4e2568579567326829f1e4d1c686f96cb2eb10d11f51c7b84139c2a960c5de76e9e44be2989eca84c68a34039a6a83fd255a6ef39bb4c5506ddccfa173da6bcda60654d0e59d66baf3982cd0bb8bf237c668c47efd67666013c8efb115c0c35514e15406a349ca16a6bf4538e452b3b9b4a6fd1f28622cfa6be162106e8f1a2702f44e0f11212d6789a3f168a318604037e5cc4a3505bb3918daf410d1370cc8d5e64722da8c5d036770e6f8e9af051a1ac5298fba9d9517e3abaf4940caac7843e0401d6e2e42d8b23199b8b5935bf56a30f47f55acc6bc0d61dfe73fa73285f4c5b77c3f83b4a3dd5c08cb0b3a3d38f868774496520d9d5ce1ca85747706167041bbb42c748191dc60ac780c9907c13efa3705b3d55d709593d544e91dd9c0150f7cd5b8f98fbf7cc17de017a643e2899cb03574094e220353268558b892bd4be3b0f3f0c93186092a5777b0a417f0a1b23cb6bdd5ac86460e5e7eea561fb090f28f73cbe00efb69729d8dcf2b5cedd8d1771ab972da7f9f21a036cfd725959216dc14877ab168f4e894ea6944994c72c0625bae8f4296ded8bf39df50ecb9167f32087bf1f4449fa34873130f0688cedb1d66a0945dac271c2c025a50945abb49b945428454a7b081776f97f4eed5f756f0cd95cf2852a6e3604584492b126f85a4a0251f0e2a99e0e1f48c6593bdd0b69ecf5477951dfc0aac7fbb43d757daf928be71fb5f2438b61908b8d0be458656c0af653549cf56426435feaf74f4a8d6896fe32b13dcb7188b806db6663acbf7149a41f30390590b8c5d3b28ecc73633feaa6606079208bac2cbeb44003a5807a314aa2fa5ab889fd798d2ffea9f2b76815c3c46c1043666acd2599bd14368f0b31ff8f5bf450958de4eb3113cea6f4e838c868ae2baf9a8d9dd5138bf389cb03715a0f59e8ac6cf8998405317f9b1615de305475f3fea7129cc95d807575f954f70ecf8b52221181cebde7b71e54902ef0093ce9081c68af986863a434afe27a49b02c5d85a27be2f0539b8d14e4e0cf1150304c8eae0c4429c7b9a6904ed14666210813d23a89525e24250a6b30d2dd3e1d9b5a9cb82a71210f075a4ad4ca626b135317b853c59267792de74d475dc31614a498dad26fb42354c8f6c61e362c1cdd258cb4a2fab150f65b7c2de992a6a8cae56cd6f8ef0785da92593a65eb43c898638726d0b226a055c06e23f57989df131b1a7a3ef6558fd1adb9514e16f40e6108acf58abaf33c5181f467c93e86b692fa63ca34ef51b9262df340be517b63d7873f98afe1fcaace57c94ef575efc55295dada45379052370c7e31514eb787ddac0f00c5919d4ea4280a930e71091f0085bac19d6f9f0e3bbe4b522837169675e1d550c5d9b132b66171aab6bc9f63041e45de0bf45c7c8e3b4bb8003afb4ac4990df999864c21fe312c9a2bc394d02408e48f1bf0444f934a262188c829a982abd19367b481352419df18b140321d44d0987904d0762359c65ccbfc26972304186a3b59126b8d2d4fa9b74553bfb7d80a8122e0bbf18b90eb95847d230715fa97c3510a957918612e0448915335e23ed22f36b31e5a9801b792008e8594443f3cc3b950e9bf413872ea6e71f446715d42b40b5997b76df6c25fc6b7e2c7d40f2dd4d7bc2358a271972eacaf28e71be4823a9af43bf5c959648ba8fe65e404faf5191f590ca854381fead1b6a55e0fa5888ed862f1945961f8577bdf748e7c9345e4db9790b261aba624274020075835e0c6e2f80345d9f45cbc6c0ed792d06163f50892f3925071da933b7c37075b61e3555ec70e7e90aaa737bceadda76b018b18644ef83c7c0b2f9b0a08de16a87bfb20813517b26789c55fb0f377a9e5a43abd41d03256252c3f9b860af8a37e21aea5bd0441106b296ec6cb7630e93a4adcf98603ecab3811b3a92b455a412ecaf987bb723986252f556aa5a5e4a08d9e00e1503b3ec0caff1d2f558b2a5d06e949cd1af91f08e0a123addb6f4195a0b433be891e632149e2ebb95b6a03a28d69da714d00d309348e7d75d13a0a2886ce8b2339ddbcb7c59b9c5910087dadfa8d54d5f4adec9ca72c60b84642b6aefe0b04c5e95b1991d2052fc0637ffef5fa9cfe3541d54df567e2a05643346e6d13a4374c78fd92f2bde24d4ef1541e9b1a4feee6499bfc8d75e4e69363048ff26fecdb683688b945777fa8c25f390a99a23747b8f36d751a91d3e389f2c6b2c72e580112b56781349751b57b43cd8748613d588c909fb211e921ec29cd89045b315d9cb908d54074bfd32b4edcb1d0846f4cbe2b36376562f340d979de84e357809fa484538ae549ef686024720dfc23e309a3a7ccc8e3b287da3a05206b5db2fe9307d612f97bd4049b2580b6ff9a98db9c4e27cd86a6402ff8e9e0f0bc0ccf604e36c3f75215537ea74afdbdd7f94a2d144b8f424ae02547a5236fef13442e63618bccfe66c1101f21c64233af88e2f4d58bb2f2b4aadf3fb189a4c579e105a2f9261031fc222d461647503b75957aea34ff4bf1f7b61799d048620e0a2415301375bd1fa36e9707174949b5f9a69ad2e6214e61cf4ad25599f18afe263e6d6a7412021a3d83fa1a8dd6cdb3b0b7f286b43811d718cc3adcbf698e533b476443248b23a83520dff35d11db752ba9147820c6eb6a239937aa2fdc4129a4f1a4b8ef3a9ab3039f2afbf4fb9d1a72b990b06e4dc34f520747e54f31013e8b334f7992ca2c763134d56f89b0eeb7ef00f622fcf1b39a03cc446c497c2dd6d559f75ab9d0939bbfb9d577dcf2844cae8261b717b4e8b17c3406aa30b261bf0ebfb79bebb4f7117352ade7bd7ee7ab5e7ec4da15780b632a898f8ec6912ab8dda12d030f59a089b5efffdd0d18d0a410ec6b0d5e85aa950bab16501991994ac8e440e0b1f68e8dacd45fba6a86178859d3732f1e3e1e9d63fd4e60fc1eb6910c64bbd653793f0929537dddd925789ee5ecd7f729ba5bbbb5c6726b4588b996b5cb9ceceec5f94c30e916e21eaa17a8280986084a583be704f445e4d5dff1e4d189a914bfa96c1c1b9b60c29dd9fbc033e2074f4558e6ed52c9152ff641cd28900e2d017e776ccd082b978d09c213858bef788e8e2d1dd06ca91baf3b981af53ebfa23960beb2ce04cd23c87fb2708b4a1ca1e52898dabe8158716fd437fb220f5848d1e7afbd7744960b7d3f89ea8240ef58d1cd275dfb5902e2ed00f04e48d6844fc105c76a2d535ec8cce79db8baa4d745f09a9d3d3992e321f6bf45d54bd82cac7b77a094d18ec76a37f0535a9beb1444625e6c62d7530e0478be384cff2dda31498611cde433340c34acc7226eec0e1499ef31cc755b8a994e3eaf7c945a4afc26aa293f1eff06e1dd88f8a81eb428259a38be429ee9748e5203653fafde431b74e1a20ad4b07bc0373042958bb9be699755e1ae0c18dac24f975b1dae4a2eee6460f46e3bd9159e369e7aca21d7495585b6d12db33731bfd2899910db8a68bdc5c41fb6ed8b338b43d3b4e8ed8b6d960916b2d1da96a596eda146d2e5f32afc252c83ee1a5a0d758b481973fdbccc371912ab8750b931e92f0c4fc9a2e24cbdc4fb79a6981f6d76080620be24ac21abbe0d5627ebb6c63c899789e3e1a07bc41b1e0120d08704e1a03d4823f3e91d35dad81d6e120996530a9a85e44fcac9d7c0cbaff26b35187fb74ec5846db1507e6b015325b1ba77b5891b2eae9dd97d9d9936bca6c8ab30d618424f5e0b8c92ded8d7360bd073767b77f1b4dc477baaed30c267956a19dd54a84e07ddbe7c6deb042e02952ec89bc4ae70a9cd0c8251c899e3b96e1a88247a28cb3bf18e89f49b9fcab55d0230776aee6003e6a947c7833b790e30662df58d390c879100ac4ade2724941217dce419114a9a1455c2facf6e6c8c4f692cf1897dbff555c4c94b681564115de798d31b614db1996295d19b47defe7d68fe32d850f82e02cb40b8c0e5b3a0501307d61ba8bb0b39127c65f0ac6ca0edabccbe86bde24f740c26fff8a3d6b241ef9974ca5c5d1704042c8715dd508e1a0e63b14dc60fd2d8d23bd8af927206a6bbe55e2b2ea3e78cc37c5a79286bfbcd4410fe8d6c5e10f25bbf05583497c78d1c2fdf7c2d71b31b13ad7c29f0793dad4a358359f96f94d9a806bb4c661f4c59a200eed227d99b0a63ceceadaf2ca9813cf511bf08c8b18c5e8898cef2e19045686657ab3c11b34a2d656049c9660adc6f38c4ff54269dfb96062bb1bef5df2184300883e07093acc5aab05b86ad0df4121e845014ddb1cce88b39a00d758fb4a0593ab81e44f44206c36601ee73cfc91b7250f9c19384d45136f0465200aee0137df1eaeb8a4c7245ba656d43dce4870f4fc7eb4808a846b21f585e2338778306ef3e717a86492c89057d8677decbd12281d37ab40701eff8e9bab1cd68a6f5b266702ff3a0cdc2a6f98c0792e37a748a808b680628ffb83c473f868efc47cfc6f8f968cc36fbe5025ef87f8e22b737253599938fb593a1938ea3c6fc3c6c34175c4008db32ef1653906d6ede186636d6dc7f311a40957aeb3d36339c73c1b2d4059219fa1df5be2b3b8e4669009cde0b85afb5fb03963f1f88514a73b7d8ac88648c6b1da0398eeb43d14cb0a24b1c7ccbaaf7e3f553fee783f6240952bf7ddb1881adb641ac63a53dca70c2ba3a63abbc206625ad8f4c91cb9a5ab14c9aef58759d461a8124edc2a53fe037456493fb17499917f42edadc2ca6f3413d2297f79b988f97c11bfdef8d463176fcd875dfeb1bd7deabef6e9750baaf5f564d5d1e87095d932eea790275a7553e1b4f096bc5345f36c2ea67bbe3da705ffdf4316bb3315acd3a742f926c4054c16bfa9cebe3a197f210efba2152958425220382a28d383d18dbb8e45f814a4848347a099544ad563dc4c39dffe8a7ce792f6d7e280e52ad64905d00c0951abb6444d02b52de21e0051129680ebb099adff50fb3d8e78a48f10c9ec755d268c30676cd04908c2f9f84548737669f0844dff72bea0b9c20c0f3c52b297850e6be896b0f368d94e7502de471b215fe149ecf530bb0d3a3a5fbdcb4c13e1862755f1cf1b6ab0fda6b22c207cd7f24a698d56eca4381c76ae4ba306069e0e994880b0c7ea8d5db2042d46dbd329cdbfc71dd5ad6a932d93f55d0f247416e4d4e5346b15bd6651c2b9a85e950b2d44ffb46289409aa8577e461cd868899acd91e2056e7aa4d584c5ddf53a02ede43d79bb0ccaf76d92368755a829f47b9f2c12c4d3bbca755d2442c116ec535a0f1c57d4c8af0c3ea7ec638722d1fb09452770b6bf0b32d5f6e73adec520e3b25e04dd687ed3cb6f32dec616bcdbd79cbc408d6c3c056cbca7cf18fae93469f987a91d29b9fc02dfe064800d1ad0bd2e66f6af0d0a5ed4373c7611d46610a522be3b4e2238f25d756055b6c34fb3d7b3f41c7d9858989b434929b1f56cbb6e31eae10dd067a92664860c82e118a5688a44cfed3138be22049a3803d28d03a0546c5a0f6dce8716bd8fac10ed0ddb0b97e1e365b767d11a5dd6f513beddf1806f28956d80d3fe2fcf00a82344d94958d137b8ace08cbbdf7da7fa99c67543d8b6574d4ebbc1d5a22b6dc239bd4fd2bbdd400f93b1302c20ce4585835fa00d557bc7b96ba8ee865ef04110ed4b4988e2e5a653938e2289db7624f989ee8197fd5b510d5b2fb31ab9744144a5a561438d6d86f6997d5fd8aead827641cbf61d0af92e96866ab4d12a4eaea6d87b5df0349dcf2669e6568746460003c6614bab0c91cfd9e86b9f4b4f7837301232f6a383506b311d2fea12fa87aabaad1a9bfcfe8552368e5d68dec473069cf3f76869eb816415492d5b5b31a6c5a126868ab20a9a13007cd8cc42ce8491217adbdca88ec68ce6ab34a6ce4fe5c7aa05082e1ef52efd3c0d67fd8fb7ede2a299083601f7bba3d20a4a777a4324b7d96796b63bcc8fa4e3ce5da95ddaaf48943d8c7a4b1c59e8d8c11cf4b50648921e19717eeb67714a7d59f0dc4daf1b8fab3e842cf94b5c2a0b6c9092004e05796edf377e234391654b4dae0ee5040ced71cb7258327e4fb71dffd7d22c92d84baf6f3f02c48a6bc1b60cfae5d37b29be3cb96ed3dd3d74b84509d837775a19229645430d9652a06f964a81bf548bc1bef8b746ea83b385e68f271c4c84f94ece9d52b6ddbd60f9c8be5f00e73cc3c48917637161d317e1aed9cc152c9d8e4c99437547f330357487e470b6ece19b39364281cad0bc4d7789bb5d11eb9fa4da4ffdb6161f47883b0f55cc630a546ae865f1ccd5488c4ec90f734b18e4788dfa3e2dcec3a39f306f9d4a0f82eacf31c93fc3f6b43b229a226864a921b7e61062cc71eeb4a629f51f00eb8e4bd51d346823c32cd5f993aceb24812b427548ab721e259303d4f056137f76d84eb7fdf880f6c8e2a54d0345f99ad5c4f90c2896a138745b15208dcb2b0aec54e769ce531a16e4cb95c35a269ca42f334ca2d1992f6849e6e071951f1bf61bfb790d4dc28a31027eb5ca173f0d23dc8e640f6acafedb6e8220f977dd54c8fc31cbd7dc2c8b852b5251d29c943a85e2fcfd525963c7ee31805fc6fcf561d7f0bb6138d719400434c33f45748847509b4c7e8ec9ce620376b3d8875888875ec4f88cb044e0bbe186458c6e91fc9b7d9843774e982c6331afe9e87641da8724e8c76335c5ba1bca34dfaffcdf24f2de3aa8b401a95556e509cc8692afb1bfb563f5a03f7d12d300257a124ed4ae976483fe4ca0f52e3a5c2c65d6e7c1efff57bee340775349c5e1db40050a4ab5212d30c91b48bb3ba2fc06cdf9851b2fada51edcab22afc985bf0c9ed4a4046c7d0b81cf1e7cedf2aeb262cfdc8ecd92aca7712c262d72a5dfdcfd9337a8a79ad870fd2633c41ebaf474a23bd18905fe5d30491ba34516f6929fc72a6108fa8bb4e938335e479fc68b04716b4d2d9f96487819f67e71830fdcd8d126f4653f6767c43182a452f18fc004ac880f5fd3ea8b3012e72956b93d5423720eb34eec48d4ee5a4de5f765dc89422661e61826d4a42a68ab6361cb359291e92050c0166af1b6c31f974aa4598014eb7923788baf2328f9f003fe9daaae8d26db7cde27f7f713b4e4afe63c11eaf83d6e417e6df69dd52c48beb398f9b3947d325474d4558a3dac84a82cd708031f9e9b968018b6b0b04bb3c6887d975ff81bf212c6b507ee89559c245d7fe0df3b71e4fb1822f6dd5a088e14eb7264c749e9e9d71de55589b5615fd129cc9c8ce1c5a731e78ecf1cff3fe534cdd4cefb41a1fe8b1a608c16821556788e96471a1237371bc323740b682f9bc9ccfda5d20f2b5e4ee7c277990ac6b3d4d2e1618d5e678b62d2e0b2660a2182b9c27fa7019c6453f3fa0d3d568b777076dcfb7732a60db709ebb2ee8334b5732bdb35f539be6d428d5a6221b8cf24eddd12bdffe2090bbad861805c760adae98afef4e494aeb81c8bbba9dbf33b7f9b2470c2426bcb3c37c38c3a733be7d38f7e82b433ddc78a35ca183bd5a869f94469fbe68f18f20d8dc89f83a5ac083271464b8b5e448285b65ee99657bf3680df3f8a850e42573ba0bc0f22b8afc3fb7e215f0f351ce7ec53b393153f417fd558e953469b0806d04e0ceff49b1c76f3766a6d3d80738c574e80dc08a4b969b4132132d8a20ef3d6e2d5770a694679b6826b99a918b37781834337a7312878bc953052223af275f0e96d632b8959d8adb9a3f29fa5ae0f40a4bfbfcd40eaf16a40e961fc806833b7c0cecce60a73c62c6cbbf4ddec4246fd22a3d0a565eef862cdbb1a2b2cbd7d024b61a1a3e976aec52f15bbb6578518e2403d2c4d9bbd37208ef31f54d0fe017bb6c43085bafb747da89b0e63aa772ddb6d4a82a54413d80985ef9c4a122e8bebacd718ef4e03864b00c23a1522c412660f05ca41213a3196d73e55f9dacda079d6162d697b7e4be92454928bd05b3f85a8890e76d33174b473ebf8780fbd98e197f0ba9089c58cdba0b41dc496f0bc7bf3ad2102642214e2397d924ae98072e70d6d9b3cbbfaedf953119f0603044c6be89e961ceca5467ee9b6e32f164fdf91186fd7628f4a3c7c65098e228179a980dc1dff1063d6de6313784357a10824f94b477b8fe5dd3dc6e864fd3607b167994dd46eb1659609532f286aeacf7910777b8125f32ee649660daf6591855eff81abb6fdef51d6cfeb8b581e99113e2000b809cc63237f502094d8e5adae067fe9a93ff3d10903e706998e0328e1d4fdfaed4a414dd1de9a0bd32dde94bd91e0ef9faa5ee8ee554f6163d1c42494449f1e704b8c4a1df3b502c534ac61f04bab578fa58d8c92b5cda8bfc3d0241dd41dd2ca188c7b1aaf1c1fb5c5310385a38c0442eac5b98a9db1e2e34ee3dea5ba70cee772ef8a99d8f4971c112a6c8ed0821ac1bf8be86efacf954bb87e8ea4a883901711deab36f18989d7ad206a4f5ebee9df580c08fbd08b497ecffdfa394d320b5a762b62f807f9cc6b597490e34fda6776e2209444b18a187c4e2b77614a915319e86b43d7ff481810cd8be26de7f7fc146f0793def0b14edf5409ce9546578a808cfb80969ed1e2601601b1e84025110a2e77dbd9d9be267a13c17449ecb65934338f5d4aeedf0253f2d4d14dee42924fd5843863e242ef573da74d074b3140506901c88f182d0aad577307d14977ccbe31f6f25d380281294ddf2283310cb1f021a4f1a6d050046b448e2af9a09a175275b0b3e1392d6a16cc4246a4ce045398c5977e4ca2bf7919844abb712250a247326cda4ebb965f82803d22a2a5527517cf44ca9c0a3e59611b78ccd94519c32cac3892ea5b6caf7ea362051ed7e494bcec97cbe4d854be2bfcf92c55491bd30085cff7642374257b50a89b16d48b24637a980c4d6b1931da328a68950c67b307240a720e1f85b55c6d69e69bddd179b308af98b14be4ceb076b2d46f2c0eabc97aadce2fb3ba4fdccd173956344979acc5ce398885628985e7311c5e457a1587eed7bb10720323842c1048ce6f26028edd8ce5521ca778e1503bc3b67f4025e6dbef9a19b4938bfc4999d106d584b1cbaa3aab72cf604a096d75570349884bc49326d78579db9a7e683e845e60d31aa890b9c97bd021ffa56d78ae8a61e6a03c959eef0d5d176128ffb5ead2029a21a20a8a049126c5b2895b76c76f37a446638e3863a6d8a13ae3b2a71be74de5c23d211cd672c36f887037ccc659c21b0b05feb6f9cdf2f7eeb6c3d2f10e696cee79edbf510b2bdb1937905010bdc7b96a9fbd38cc0215c008ff37dfb9fe1aa84f6042891fe04d04b190ad3f3186f0b2a44438e5e7925e2675f0fd8319d32dfe74a6ecc31c1d8d68ff82c10a2bcba8eebbd8a93d765ab0f0cc63496ec8c19f209110e7a7db05d9ea9b75db45c53e97e69ea562a42a4fa581295b2a2af7be5f0025b11b87e3019e7cc617bcc9b5248dd6a5edf02545db1e042a055ad83ec9bad746e23ca7fedde82c8d8b4cdc439087a654ed203dd10792a75352d7179cd08374582fa9dd4e3c0ebbbc58a217712a2c2735b234d91cadf1ee4d91d645fca0fc2ca44c98b92d60237aacefddb5af20e37a0e3e7fa42f42b0d9b6e49ccaf0fe0f512fd8f3bc877c3d31e93e5c773391a8fda0fbcaed697b214a0f9e0c58df638d263696e9a0b2ab391b34ad4be8e90797f82a2585188e8e2fd6e1e99e1da383f999a6ed8b0df097c6e21221e61fcd550958d4951b67fc739a7572dc2b7a45797a2dc474a1513bd7858c517bac63adbb5367e98484b5b838a146d5174b4580548a4873d2288e68eeb38d840646b03db1840c77c9809185ba8b6e64954b0a726df70ed5fa7405008aeb651c5cdc8febc10ce4b9e54dc296854","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
