<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"27a9866afbaa1f64049c78f3ed5fc0529aad45c211e7aed95f8491553351d3216b884a1f74783f2302fac267c7b47e114723fcfd57f4089920ea386e49c7dbc4413f4967af85ebf9055ceeb81958f909ba7fc57edf569578cb470628424b181872f1c44c0c61ea25634e7039e9644a98f00c3086984ce31ea4026b3ceea3ecb04ab7368eeea40fa3f4055ce3cba1d5fc5cc8c6808c4194156f73a21c9dbb611e6f244bf4f834fe130f4f039d315e53b7a09186c56afedfd8844dba5556f6e8c89dd5fcd67cb9e97490fe0697552ef59290931a9d0e19464144f155ca47b6ca427026be4d26955e771affda3b09d17aba138dfa27ab94b0099d3e6e345c62963453ddd3feb3c80f9041f4382f50f92b4df672e85124107319cdc7ca3ffc43effefa49caac4aaa27dd07c70fa7724a45e5d964f193b5d7f7266434d9df4be273af90d0e36b8a26c512fd3c9149c2703344b3935c4ccadfbea486c19736557825379edc319ab7f61f0bf7d36f78cc88fbc98d57a9400349c82163f671723763fa7a1b5c6a8ec546bff544c3ee088dc1db0c80ec46c65182361648c88e1a331bd490ef7a8a660dc177f559649e45f3ae6bce2b7217adb96e3918a29b2afeceff9d02ba637f2045c2a33d5918cf95260ea74ce86e9474325c8b6a6ef227d41016cdf1f9cef8b250e96187a84afad129992cc9efe53bd8517947e48c6ce48512646687d82ff73b5d2400f6e1de37f1a02db2aedcdbb16bc09e9a59f72bab2de6cb860e372293dd7ebf273c7875c34ab9f4bedb6237508b337691be52eef38d05a7b7f2d46b8f29c8e47447f69540e8b99ed691a2b0cd3545236d88e8fe44eab55d30bf0eb5224bc98aea211f4606771ea99d9ae79bfa7835cbeb0c2e3ac62a6f6ff6fc7d5a1004128ab5191393f0f2b37220f89d0c6cc49891fdb84039653cccacef9971cb982597138e4acd53b2ecf2f34ac77167138259565bc6e4b537e438dbfe44c169d43ec85230c2f9af0973093c8a1c109d7c6861c1f892741bdcf6e00178812aea02b659215a95634a854f97bcc5306953806935c9d045e0d6225d22d5395319d8cc6d49f29c927f082ee0729ec90455b0a28835c0e7ed630a9e4577eeffac1dfde07a7535335919c395403936e2d0028c6743fa0e3f5bcaacfcaa4e91c98648bde7cc07817589fa9ce00b6f4b54bceb9af785ae148ebf35200d63dd68f6235a693f01e97faeb94e48c64c204122a572ef9973940fc2e0c803e7ac653cb1ed4c803524933b4481fbfb5241ca5067ec8498281e60bf4059974d251aac7aef6a9f8d924030fd627b4e9775ba9336fd0400fa446d1831b758588947141da9cbdbbabac73510c434b344fe629c5741b1d9664e7d973a079a4d7c24ddd83e503cbbf9358d3199e1100677fd581f6b3a39b22ac3176553385a01faf2307b5e76afbeea7beb8d8b7f03e62230c3cd9e35168792ac13bde8a81f77e2e2f0ea6634def54d5a3cea3599e1e01cc68a5accff267663c140511a4f1908193b89992cf93db39406957fb2f61368c0cc5d46fca55013de296440024a3d207e1b15b9c19596c3b214b55483a313e02349c07300e7fe6bb539aae6d10ca0c99a73fe099247bfede7529c1739f7662ddce1417ced68ed9897bcfce1d08321c9f0eb43550b83b0f7d571909960067a0e97ca4eb68df9b887115ee7170a3756d2d92cb2b18386e2e8c4104c18da07737432afb1a4a86a26c9f650ccc8ab341054071823cb7a1e8233a23a24e35011ff0c5a0426aef00af438efd8a20a3ecb063455569b93114668f19bac88bc4d33441582bff926c20cd140f2a462dc5149e4e1e3221d5b949ab066d60dd02e0c0f9a94a7639c7f3230ba2dca68e69d7c7f7c03e9348f8466a0f75c663f3d907ec60f329792c45bc28ffb7658968263b57deb259ba7e662c35d1e884cbe766d93192ccdc40cabf9c30fd63aadf0cf51c1ab78254a655aa83bf5562f5236741ad367f68893e73ee3e43f735b7148ebae74930d7998d3ffd19894647b1d1d5cf46488d8239a3a438464976d4dc042831c730840e87933d016e5e463f89d91c8bf0bde9b3e02e84a1a8715f911ee903b277d97cc214075f6cad151cac1821c047a0617e44aa526fa614fd0654a202449c6036f570fc7c89f35679a5f6b289778bce40373e8f37f8955e7104de23e7cd3a71b7e02ba94ccaa350e384413255abc608d0d27bd8b6c02fc2c38b1c7415e3c6b012436b5215b32ff806c794aa6731c5cc71a0b04f98a56a4b0f2db194321224e3879d0d1a0c3c961ec17189825764b68858b8cb3d219a5b1a72c76805c25c616a89539a6727b80b81f97392225e11df3079b29e82ed226290f185d7f44759d57270cbfe222679aa98f15bfadaf865833611450270d60c0bb1c514dde8a08493d66a042104c44be8c34eb92d869bb9cb6d8dd6ef3936ab679b5dc7edb4537e8b54a65e9edef520fb23fa0a61091e41a8335f684bac54d78215b698d9822e0b1b155cb9f636589b5bd78d13fa7b59d0739dff133a2da82d569b4db707347a98fd3b29998758cfd49c9e0ad21ac7acb0dc739a44dfa93dfb7b76d1f524fa4545b0930589a65302938c8286d3c5cf9624b91049a45fcb541074ce9dba50c270e3be794de2e7c6b31c2dc6c460948a8c0d8ff158b821c2a717d8f1f07f8dcdf6d4ca768f99f16a8ae273da4741e2d3e6ecb249e97a3ec50b87fc92a85ea7e40e7e405037bca245f36bed633809060632d218708466b0081520d66014aa72856f4458b96e6f1e85eae55935b62b6b30141c6ed4e4ef7f3ac2e04fc5ce0c6b02d6909732fb87ec360f0a03f76e18854db8f23307cd32ba655e5ca9e33f2a96569e71571af06ee086cb06f9620d2493683590bba598c42ff29338436d928660526b3f9cac229ce4e3fc0b8c627a85912ef3a84b49ff3122352fb35014548c81f4f14c61fe8677e7f1c9bbb8ebb6ac618a503ec6b044a96bc3212454976777b1a0fa6343c2a07229396ed9721c65c55db9bf9872df90826a1623a21af07411c00020f59d2e09332b0ee6f313e7de4bdfc1882b4e7225daf913ae2daec3803814f27acf69c52c9221435881b816c2b7ab6baa6a4679ca4517aa141695a9711fc533d121a84a4b243627946c68c7c705706ef3d84932003c40a40b58a425f7bf9bb9a96cc9ca28bf96fc6eb756878575a077cad44a6791ad466129b88e38a8fa0d75eb3e7db609bc5637b5baf88cd0a4769ca84112256af8936f58878f834edc2b11b68d1814284f454c71689c5d2b8c4151d1d3a16394c37030607e9a493362f2975719373169b74d1388d0b213691f4abb0c58cb1372a24abb755269beca8a642e0fa4d16a40d34ed138fedcbd63b1d7da8f003fa0b81f7b96b1a7e6607e72f8cf29689542d3a3246bd97531343050387e7aea1dce13584aa3f6a6b8d361c96f381136cc4f01ea9abc5c70a6a97b74fe38dd156a23ce6178f3e0ba7e8328d7a40322a6b37e51bce024b7feabef7d17380e136e7c5a84396f1d542fbda6842760569c510611b81aab427c950571f5482ae7853bc5429f42867807123edd89f0efed948a96cc4c258dcd2a107941bddcc33ba269075fbe46aac2f20eed23f67c83da147caca022967072bfc7f953b27ef5b8cf9ba50f97b5281b78a7f1fd372593238edb37ff037588e4c835f608571c721124117035540a327b481b337b5b825b8348ad0cfc81c6c12529d6d66d847c3089238a75c79b76e83308ad7f12a5aa0e09f632845050ef3966a1f44a4e48581feed563860097a74bfb06fb8e5a2e2435c44d41dc4058457c2d661e863d1666d6537f18494a2ef2109441962343fe35a90ba73af4347f287f026599056bfd08a8203b556e2425f54fc7c15a66eaf22efbbe542c46f43f25c160aa55a9dbc2278bfb432494f1d9b2e10285701de52d6d0932dc3c582d3dc33816360b931bd88b3ffe9f7d82be990aa1b3c6dd9572c00fde7265dad18b51f5d8259f09f73a7f3d9d20e0fe76b7fbad574f564f9838fc4511c136d004629f9604b3cd298d4b14e01577d3fe23bdf7c613448cde4a38f888fe685cd3efc9190bb9dccc6ca7f10a9d627d78260ca512955724ae5b692cef43b2fa16925333a6e3507a88a77678503c1a6563fce4e467654b805879e9b90f336ca6ea72df25681005b6ab0038b7633ac549fb2b6f6187520cfcad8491b010053dc773838043d6fa33c6cb3df3be450ba2c3f324fe1558075290547b51d4246f528f2fe39964dfe5c3a55cbc6a3a4c89ba64ada68d7e29333fa30883fdb42e0f8f9bedc64ec3beae436f48acc619511b60b6ff1616c9e0ddb0c651314055793130450a296f6f557e88d7c855a7f567cf3ef9ef547c9bfc36dd6bc441ea900c71c66ec1a41a53d23155df229b410cd36027134f7059381277831e6f3314fac3f4bca5c85c0f7b3772abd1a93f8ad51dd245fb6421531f41a3f41371c7c9401c99e57c9a851b8960c09f33518f5bc67f8b1fa14d61d4ed79c8a55c5b992e42504e6a61f35b7429b2518872b454dd6d28083f53efa79ed494e507424ce50a2b21d720d3a50d1b02f37fbec3de5ba60923b1acfeecaed61eabba02c8cf2378b7479a344ffdbbe9b67eed8cb26e4dd67613b46ced9bda86308b1582fb3d7eb056b126589da3f0352638248418313655fd9272212a8260f5e61a7a35a3cbec66060a03a15e3a5f6ecc4a1469e09b781a4396f265f579e1b7171a8643d5f6e7259d3362ca941f484ad0938f3efe57f72b139e6d9b921f3e9f2b091235a7e94a2ceff2a4f99c15a499837df0b7677df436b8eb7561a5302e3698366f4b75a917d5fa547702320f8f941eb2d5ecf79eab307f7840471f90243065ccf5d7166ef1cd8a8a6756b4d5f8e71819cfe75a57e8ab8fe672716a401c0e183fe0e71854faa26c393662ecd1a0d72f9a644f373d1c7df5ff97a5c354fe11c9d718a4ad9111715a59812401067363bee879109cadec2eac2e4c3e050df6ae462fd2c58aa26ad22a58c4ffda9c73140b56b685c98b5b35d3df146b740905671cace647bea384b8925c150233681f19aaef049a85106a562fe72b1add8eb557f97a48ab7d5a3416c93ae84c6c9ef2fde2087f8436e04c09aabf60e46f8e368bfed7dd31c676d3e891121bc8c7b03c734d752ba947f3a7e9a3c360060e6e99d5408ed3b983526c39e1d2b59f96035c95b89f82ed6f578f7348798956c65e410754e0718b8fc429a58a08dca2fcbcabf241efae76f1be64d865cd7785d6dc55e45022983c35e36475fa00e1d97bf737e10a0b4a3f98c63ceeecb9a0537af55bd149bddde5e7d6e5f4258bbc79380e9f0e906effbf36469661946436caad2bdc32cdb93f33b48291abe733422f8c5c54d6df983a5e95559afce3ab0df2aac0e8937cce2bfae9e027e11c91315342530f4a0633ebd8164801f4245754dded9977dc603470fa3994c29b1d775c24affaf3a4ecf008766d6052bd36dcca2a45cf73b33924ecb7b0f0399d1181aaac9fb79c50a665d10aae9ea2df02abf60c46aa9c7261a21e90c6c754247c5a4c7d3537cb1cf24189c32825758f17391a2e03eebc458197592d89b8490c4d622d5f00c4135ee97961d9e15857f166648a6c6e83f2d888b6db15e61f34f9a29fe3589512f61175359fc9b2d09cf8d1c6caa5f081b912b574da7c1df6bee08f39d5c638ea260b5ba6530edc2bf2d0de78154990d98615aba54c3c4ad3929bbba8830ab30949f6f50ea8e65af1acee50c00bb6b9dd86531b89d1f3a35564ffddf908d95f806cfe1fa0e227a32a7aa41bae05076d6be206bddc4c5381c0e289143a209ac3018a5144b68be65d4366a740087094c329790ed2d2c0a9bb714343ed871524e1c1007b45d429b5bb50d92ca07f9bb93181efa530d9f8a01f4654249250cc89380eac32c4c95ab342149c1f3361bec26eaf3ae43916575a7a0d20fce392e0744db864410a7d8494d5352f9743aae1be1463be59e730ab16aa6d9a8ff76a234bb31fe012952af3fdffdd2aacff8de3e121a2f29dc1e0ffa6d8c9e48e848e60807a7df5ddc05337d6a2fb54eb981fa9486b232d65a599787042fc59044d2deedc24c8e00cd8cf05046d4149ed71130878863124ff52a4f50ae0ce31283d0d8a822df256e00ee92dea029fa4bb0acdd5b2a2356f395c237e26af39b916489369cfe90fd2e9a136ce744ec0a9f0d2f281909f55b81ae83fe050ae2feb97cd9042d0d65eb01a710a930956bf3ae8452c3b461558839b9a4d6296054f711aa22ef4c98ffed624e777243ff463535aeae86aa886dca2790863e8f19cae4998f73b0098e1a95868ce71623f6a4fee99e5925ee2c0318b685f0418cd22da18df910c77fffbccb1e181e27fb7b7a6c63d3e75839043bb3bd45c5e402eb03cabbbf01ecd0450c5743ea13ea17f179fb052fff4de93a78cc2118e9bb06dcc414d440cbf1cefde1911f8c77ad8adb2f2b3ef4195d5788dfa7a8968e9c56850edc27d56d093efb619234f750e27cd0d260c000dc0e02a5d087e4bdcca75073a8e81b9199d64ee49cdb9bada5ab2f929f0a5f75999ef0f59e1139f724782cdb103affdeadc909e166ef2ab55dbbeea78b3597ac89cfb93226c965e9d6de885ee46ee88e30f5dced1c408f29f0016ca314c5d345f05c4d3cf0920555b29e3b1599ec6d5c26b4f7764da0785446feb514b1ad41d05712a46c8bc359b15fa0c099afffb2b683e749f351f6f6b6b3a470245a2482894d9b4f96f53e9fea5f50d8c380db5f15e16ec8043b74001679658505880ee982c7675c79b7349d428215f4bf1606fb4809d490ec86296d1e652d5fadb9a4859312540b3079e66b0c853d82410c85849d3b2260957e3eaa52a45560f6cc73a37e868076a074bfb5ebb7854e6190b27bbe3586bcc77cd848e4d24bd17517d74b0b31e59cadee6a6edd5643ef801650aa6ba8eb72036fc78688086cd0201f0b88320784dd7ff32b4f9a73b733fd3c7271956ff0ed72386a54c9e5de7da7dbfcae4a68c4b9d8905ab8618bf0ff83e6454eedce03b7447216212f49b7121ec43d28b2d34bcd1fc3692f8788510215c0fee6b6a7653e726fbc94210ab8b60649958721b8dabf8d47978188acf57f29d8ea9e518441587f3dafdcca617b7a7bad47c86b02885059ea695396b3b7d11cc0964b4e68c7dc64e7a86e94e5b9d03fc1c3cc7433c80f004ab2634f3cb677ba46a8770ab4f1ec7654b5a25f9b1da7aa26cbef2dba9756ac226ee74c8ef15127538d37d5aa27407f5647570b7adda884f27b202351db2d97d5c108a4106f70c42df0cbefc75700ba2e5cbfc1d5f1206f24b7061f8433734861965ec4288d8e3c6adbd004f551ebb71de652c2639d0048115dbbd2571c447239d6a8a4ce3e18ef3804e951e0de8953b7611904332093641f83686480f3b62f020fcc959d8d54ecfaa9c31db759a39be5011885fbe9a39300a51d9533a9c409f6f393236274f8f30cb4aa41866c8acda23c636bb772d976090b6a91c98505f5e3579a122e6c7a99e62e2dc1d8f7b2d2035230d499c73d4e3cd2557bf2dff98835f2673ec904811245512fa2302a1265d5d764e7cb5559240bc96aa3fcdb55c0b47b25ed786e418e5713d278e6ba94ae24a5aeab63fc3cb0655baf3be30933854106fd71d1984422b9acb2611d5683a567373ad570e94001bd294757333c1b75500aa19a4100cb5d1b5c45822615f0247efe33b41e8cedd1c3158953b937aa288d33667931fe919f6582accba8a8a81f496996207133aa71c45386ab65d1180953827c85531f2135f9b4a5bbcf4bacfa80636a88848d327f1b4580fdb8b74a10d074c943ff3bfa9eb6eefbb292f08af9499bfdde603573f70d7170369bfc63b50283abbb6f34ad5545ecf18e2c479f9327b84ad8115217e25603c8756d3f1ba6888f5a05d71494566b9a73a9592bb37ad08769bc00e7ef4e1d1bdb9cce71800ab71883083726e3d67c9f83d7e12c231a9808911d9345b780aa5596b3e40bd1a563737c95d3a6afefab68167c8dff802d4c1daab777ade42597169e3c2289a02eff13fe627f967399e18186cd8a946a00887f90aeddabbb068adcc782f873de2391b657fef7ca497f46e55902e3238552c4a89fb95f80bbe7d41034352fcfaa9efac5678a0acfa3ac81a0fceacabfcfdf67a33bf036336546dc535a190fadd1df2265062f04d266a3544bcff8728992c6e05ae4924b7149b4297b9d891c31eb68949b617c06b6beb627dd138d68afba6df7c14853d5abc6cc336e9d802d1b1e4e720cf04c34ebddb2f4a5f3130ac16a90bb260b98dbc163cf9038f362ae20f1a8a6a673b2cde04420468fdf17301f577232aef3f6c3c9f73303ed4284d20c46a2c80a5621ee7bc572eae95b63edf2d17cb257b65d16f5b1fcfc045e229acb4fcea11555397528e01162e8eb3ab542a8667e10f9f7b73638ae37caf025bfe677f0a7994c94025c9c241d9d191151cfee5686ece81b8626828f8d628b4691a92c7dd33062cf34216155a125479d86691223a96d784fcfd9927dff04e84f3cedf8d39cc0df30fc3d8b00d01e3943c5265fa63fa536c84dc11b26e01ed094cbd38eb3896afd259e9d438f5e0786b80cd18160f9bd4b04e82a27b63f15079cd10b95917ec28035e5c6c4bb015ae1d60fdefb63deca9516e59581aa15f00b74c8c464c65229467fec6f699550150cb23331c391391d5d9eb9cd506526b1d8af30fbf75b667edd9f9ee243f00277e6d8fb440e35c35bccd107da3383fa63243a514a4d1eacce48b234a8f2096dee081cc74d75f0cd030a4af9358dab6519e93cb929a5a25d77b0744167eeaa7da8ffb9055859f5b09bc801078d8ad466e8d972a1bb83a42c7e5a017d7ac0c1cc91e4398b09a1684d8552c135f548b92e2eb1464617d2803fdac3361d03df1cb5f4afd17f03ddba05ca2454f8688b8c927d0b168fca46ffe1ea77c50f4111e984d0ebd1ba6a06576deb436abe67e67a25ca615d13eae57852dcb71ea00dc8ec7ba09b50f5263b3fb6dc73e44d5d2e772dc380269a553fd558adb5bb6595ee001f2042c938c2ceee9a30fff50826ae4cd85fbeb92ee80ae7bc37db20a9026c9b740974420237ade6819cead2d900742ffe780c8af604f5d3f50f2c5c842beb706a7aa514c775d613d9b90ed9d08f8794b52805ea8dde035658823bcc6a2719d96f5db8862e853c958918f392f5da77e42c5bee392cf2d81b0830130bb57cbdc6a8b42f07326bb4f2cddbfbde4f1158cc48656bd3f5b4d0bfb34f14d1eeb22b5f9532ac668c56d9b1d040ab2077ef295e82ba5b0184944b1d795af6ba306afab712b23d8fe9ed4092142531f7bf5fd5c3b0d4ee87e2f5136e5ba6ce209e3faa506b1c8426f45be9d17ca0ce3a5b18c4c2eb5352d577690c3fb1578e3c800bd196a47ac2b8d69ffee60329b9c6b52f8f6d958024995565f1cd8b69af506eb6911e2166f6eb978991ffed78707f3be7d62c9b9d45b5309ce99582cea6e45988fdc8eceb9e7db6f2f3398f5e7ed53f7f21583ec455bc59aa75f1fe0e23f96b7b9ccbad7a22bf82ee2d4a2e029d2682bbfb33edcc43f313ee71309440d495b30b6d6e1e9f09ae923bc39c267a3d7551c5ea936d7b6ab958cdb1ccf0deb854ca52b4251ac22b5717ebef4d24ce5089822ff48f7946f8a021f3c93f6050a3c218a0b805672374550b12b9dc5f57f5cdc6d57eb72b6c47708ae12bde08ce38612264f719b700fe43e79b6da544ee71c25d84761c896db5b9078eebb05652dc51fd9956c71336aedf9097cb2e17d1ede60ec04bbac299c06551c53b4ab5a2eb6d7f3b7b8603bb410ee6428badb952a590ea53dbc63cc7056e4e51109c2212ccaf0d32df10b98128169e8808a1f9fc5cf93ade694137a6e5dd70400ef5b7b9f9fc843c3a3adfffc5960996e6a8558be7759debb4dc3f8d45e6b0256958c6da42968a0ea56b128b7aca590713e113bf5efa7f43f620691f7422e701ba2a5c4dc7c202baba338a16965178961d212fdd5d9b842190fc06d876563886f4b12ed2001e9d3601b594ea1b576815400c89e038096ac45cbdd5e9426395b9426664ec078697ade86126e8a93852f9fc3ef0e0276ded6280c27fc15c7486bf269b6fbc6e864798d836cf72f2114383d9444bbbd8e66daa7de59f93acd9e0585896b24d2d9c56e15bfe0e7d7964f5abb1ed9fd8d2e0af1d712111d02e70c6d676761d6e27f3dc50747981017fda917ea8555d1900b66be0ef1e10d3be5cd92542686eb92d02dc27d5f838bf303165d75040230a9b540cee047e7f8750c0924f9aed94ad5dce36c13671e617406c8216c022f6f5cbc3299ffff6f092cb6ee99c5ea37f7da9ee648375b034eb6a480be49bfe67e76ea106c49d784dec187cc3970838915b56cb207fec88b832053cc4be0a12a9268ec92e254c95a1157c4d88ce70fec23bb33d70ddf5c83b728904b120808fddf9a098eb966a6385921535b74fb1e99905b9202ad3993bdce5eb229b177318ca745805edaaa8d53e6e507e27d1bc732a25e3cf1cc40d9871eb553fde7285d454249630406744bf83ee1349d56dd5f0bc17940616d29226638fcdc6173a73c0f70237d1a0874e6fd456caa7147a688f8770673038744b2a058ffa4d16ae58a0f660e163783edd186ab3ca00b167d3d3ebb8e8f276847ff93c5a3986c33f220849a02dea764346e4efcaebdaccc183a825145c895e335193581c99899efc716607e831c4e240bb26f9afb3ecb0a035eb4e9461359a45777f6af642caf66311101c949a3cba9b726b4d8cdf18260aaf86ce1ff124fa345c6f4da5b051681d0f136ffab05c4a83f4f0fdd308228a606b0c86ae6f2213a2e3de9df93af4d802409261357ecf4439a6a46a4f13f0fdeacb31a2aa2d707f0ef39dbfe31b43d7556a5cea99437c275c04a587dfef6a39bc8a99ef7ecddfe9aa5c3015436a0df092b890b46a74104d5949bc12fa03bff07b5f1d73c8fc4c60f844369666d8463dee25ee6b9b8f2fa5b247c78caf7dba735d23b7fdff8369f8b1a5d1ae44f506fd05204d0d5fc56cdd69f849285240981e1589580e1dcb8256a244ac5e481dbcba484c38169319e10f3ef5901c01aba2dad0ab6d0a4427cdc2f65b14a5472698d2d406f2ff496ac197910829cd0cba8b5648ab23fbf2d4d06777d015e1c2434f7a5e6b4731b07beee245815c3466fff3efd9fea284b2f53fadcce18484ed2100a21b83fe97e75ac6248b47f165bb6d4d882d12d3e7c8f51e17d57ced62afe692599ae4800f30880ffc0f581011a6f0f93a69be6bb3ce78e5026af58c77bde3f0afa1f8e60371fca64d462e3a2341a5e462644175c1795357b62d1bb0b9b0b3c0b9caa727076709bcc1c7bebbf00b853e4740858e2216dd986b609d9aa4da17531f70590addcfcef6b1cfb58edc3f86d61dce77b25d0f2790750075beadc5caf8b52c3e354cb760ceeffc716cb6a070b63ae90d6d5b74e9078732f4fe528681527895ab7a210b2b55a26a1bab17e1edba7a85ebbccf0adf503ef3f498ef4afcf2a25ff406680908069569ae95da3eb969ac35f5b8f7a5b080514a8f2bc0b845033d4aef6c0eb8d61d9e7d3e6803cdca6e8a424cf1843ca5474050c01441e6bd9e5b656a24a3ccd8db5b80464e3f25de5b2941d598268dc379509e0c68005364fe126a3a6f40a7628f325769894c0bdef72bb09db16e10036d5a4678a1a1a4451666f8471cbfb46f1f61bf9ffaae9c3620da8a70738a5d2f8c635e38a3891a9a63012e72e377782f32e5097bbc24071728bbf9c03b9eddf9aac8d12b02b75e363d14c6fd8293a6843ed66e3a17bf4f77fb95451a0aa57649ef9f19c6edd58a07982d5884d1eee0eee70de29af35841d4a123ea8f22ff0dd0541182d3d6f26737d8ead70b3a8b80cf569df0f17f6a1a0e125bfb7ce781a54c7e18c9fb7de7b73975047ba6e94ec6d4f33306d11f4181c9ccf500b8e936393b255178bfa633026bf87255d94346ff574801495a760b89bbc9564b1f002a55cdbf1022aa94ef15d3b8a79d0851c7ce8da18d4706c58cc349bc0f045d51c7018b19928443b1cb3f0da7ece31b61b5c78457dfa63c7a6ab80b82592ec0a9d5523e7a4e225f1d02bc5ea255deac24b261d17050504d07358d881371a1b311a4c746f9cafc614f4968e03b8925cbf3b83d7d90212933461f30cdbe8fc6d482401fa1f6348d18a2ace20491a10a402306660d3b031e3dbfb2e1c882afe6d9a57f8f4cc048247965e921d7bf677a594a4acb076d195601ebe98d0b28d95b3d02f8146401c443877730d3acb20946026263d79a0765cd66f2bb6e17f1eb56cb1bdfe9c30f722e653c1aa440ca5979901399d045558829e68bb8e486fc52c99889c70da58e528fac49e0a7185e318c3b78a73a29c81e78bbc2040f7f82a3d1322553654794c6ccc9a0fe8778e731a8102ad87f2cfa2eba87042ae6022a5f48099725dd41984041a92459f04532d2436e5b9811a6732ac12e92063105d624ccb9dfac5356bc66cc6d95906cd6d80bc6cd032d3e1665695a3ed03edafbaa92f64fe0f3fc9320a236cbe59a0bd807c3600055214c773f5a0ea8619b2191cea086f5ee315565eefa84e3a1599557f6554d7079f050bcc7e82e6c92a95e59d79013e625d958a2beeb14b676c89b134e1853cdc416bded404aa14ef086ce1e6788b0141f12535eccea384ba690eef9bcafc3ae42cbe6611fd61d638823f21070eed55ff343692d689f77f844fb07708f933c4c5fc4428efcf31d8e7f17c0021651778a90e79b274a8a23e18e58f5b75fce51cf79d6213a4f803a83d4a679d3b4b7a06422a3a9747b2be663a31aa2ca04baed76ba5e5b4f4478698012054af66f668c074bfc494f10d7927afa222fbd3532c06278332fa1f42a7f36737d69aa36e76419d05e1ee3713613ceb7f27ed234ac1e46ca39c419519b9f58fa00bb72dd80b4bbaf949753ca8959e31482911a6818be08dc2c4abfec0997623990d9e095a74ede4b836aeedb4110f119e3f9492fcb9f9386835cfbeac4023e7d0cf9bf51bfcad64e0cc1fda499b3e6f99dee988a01e4fdbaebad6d2f670012577578b937ef105849effeb47f22a3826e0ce419bdb27c795a231eb1865d0b21039de2c7c4bbc38af3405df681424f9624b4267b53be968d36d539d33962d0808fa8bf1fa3f927696c61eaa9caaa84f1f5ae350955bc761761ff7cbb74c65566058d459d4645b52319be50a4bef569234467bae468b6c86be8122d1810355a0754a5e2b23fa63b3f89bcabeb7d4625d19b5a8f106a03d23cc7bf6e81c2d92bf6d7875f72fc8c4e2a096c446159fe4d99c633867171652034a4aeebaa9701e1532f02872b3a5ef508d704a760accbfebae84a35945e9320fbfd6475a1b7036f50554a3834a4b19dad6623cfb8fe5b0ce2949bac2fb574e0ec4b1f9040cc5730ea8d4646812b773feb7fad73b8029b9ea22a4fd1f9d469cdcf00fa10bc2a94fefe19a8886834ec177aeb86c3c4337da023f1805006c3d9541f39ca94066f066ae55c7c7843defa3e37870bb7771a051487f253663727c7364b9b90dc22bb42dcf45cd026ae78e925f185ef191a87a566988f07528765253c26f289b986d2dda90b706cdfee9c63d25c217afc1fe0f6e651ac984789285caacb8a6f7fe0d5777ebd733d2541bea8a181d877386b6bce358abc6a961ffca5e8e3956bb588aee2182ee8fc60149c2c3a3dfffbce194874ae179317e3b25795eb28e30ed9721b1dd46c4d514c65abfd41eb592ce6316055b5735aa7bdd668e99282e9f20d8185c41dbb69a0091b74152fe8e50b71dcf7f6a39d58d7cfbceac44eb1ed50b8bef325dee89d7d118289dc9e4746357ebb394b50ff076431caab8090c34ff6a0cc80f357dac89d633d958bcbd84ac402b3f7bfb2973d4a2b5d28e224a080e314f0302ab56f7542c65b49893a281b1f722040b3ab90c9377706d676748ac0f2fd1dec5e75213ffb669aedc0716952f3d36335c52c468d977506dd70b73ca3bf1d3acb8eee5f687132a17d0fbf26984ef4434f089f68d7adfe97aeae0e2c380c12589425bd13c390f701653fa931a538a9a6cc99b767d3ef6258866ed0cfef64aa799854a45d8f95556081379f65e8aa502ec0661f955fbd0005ef2e3830ad4185e19f62d3a5c1d0b1458bfa00d459a01969fb233f6df41e5c7a721870596d77b9176bef5e0d34594e46276968178c738df5c708f44a39aeac3ea157c4e9c3a110c5eb5bd9ea9bf96b4bb7690974c082c6f615315747004484f8ff6282821bbe0d810bd5e1ae3dcda1d300a97225749fd58768774ef601d4f6404f4dc8445f4eb245a648cac04fa888a5c3fb9a988e024d29b00e3e47b77b3f08b503c4fea434744fedeafeae8432165f3beb7bd89f1d98712b4b1f3226b18b7c761619e3169fab8b047ee8bbe755335fb2667583ec9983b4d969d5042f7c4ac81605bf6fbc32d04c3a8af3004d4f3512d3316ce37bde0bf98090bb2b428fcbd24b2ef57c717abe31f6863227f5641777e616eac3227c66b178e331055b608bb5e80d4bfed86cb0d5e2a11d41238fdc1125f7bc959cbcf035c411e0c3d804af79e3ab10421a1d75183caa34d74afa43a0c48764f837756c7b688d9193484f18c2533d8a9cf41eb50251f5c8c889435dbb57815119881797e1a612216ff8e2fe35f9f5d778c8a3fed82786b799823417116075e47421a866a01a0ad777ce8add490a0b4d8886d2a05bb978a9206045afe59a9591793d6111db4195b0f0d61cc4116671fffbbb4c7c1c26f00e7dc9518e75c5f2bcf00943ee065541b1a82b7960ab82b892a67ca20804546d376fc9eb70ed006cac98eca7cdfa0543f6fe08c8b05eb079df3e9900bbde3f0e30139c59245542bd113ffa90880f8fdbace0184c1156b18e28e26d684fe700a926ae1c354851124c2431561c191231d060dc6051a0a5587807f9cb2350ea1f5f18507b4da4a3e488c28f64084d21f38c088be60dc556d8cd890ed953fadd3ad1a9a5a080be40b67a5d0ae8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
