<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1eb64cd30b39b349748912998d95c3675e21a2f977fbd3a628df92cc5e720d43a45bef75e1110878335cf55f056ef8043d6cf2427be9a1abb447e80354a54396c179fd4b03433344d6d4ef71b6ba7664cf461950d1147f29dd1f167cb41af5c10f9b481c594ec6b594a28a5f48e5d5a18ffebb367f6c2c2ffcb63e79220aaad8e1313b0eedca3cd1e8a30bd6159051a8df8ba2084a60523027c53281403705a67b3b241318dcc761798829eb2ebfcf32b1ea7937f77f9603bd057a13eb8edae817bcf871909de614275fd2c02bdeb67f11c6f07f6a60a1b8c5c18b31b03b48be24ffe18678c90e732e2f07d294812e0223bf9ee18183dcbedf266793b8f5379763659167a5ae66fefb0bea6e663fbf14e8741d404ae7a17f3722a11726be30e70361f1280525715d5461f4ffd6237ad827626e11c7888af8902bdd516d467285d885543ed2b6cf3f54f671588254ed780ab7c5082d241234908ace05a984c3a00e6cbbd1758829b043cbe701f5b3b0a4255dd2fc721df26640976f9074fb0c0118da8693e50c4b5df6f800bb462a19f196ad4446e3944127c293dd328703da43e1502aa8465a061249968574bf34a604dfffb49e5a7e12cfd90bba55c80536fbc10d3cec6e13e8291012ed022bbcf509a90a96dd94083e93689f728eec74f18aada4a9acc758c6f3a58534b38df196bc4408cfa007e595e82cd2055bcacf6ec1a14193d512ae206045fd0312046632a709787813819c6d3ab0411670f8c85bc3045b81ebd16b0afb53c319c87ef1c4709ee8f1131a738277305a11350c3966b422ba04581a22b4ad00220868e73080279e023d9d5997bc35a7a2f2044ea9feccc4d8e01cb4444592bfc344d1a373e647c1dd0c9a2d2c9bf5d96ea53623c2b00ee8e33ba5c1e2d3b68aa76b5c5f668bee88220f12679fcf0fe4712e14a1dfd9410ef673f09092b5de755242a34765aa934141990be37f31f1f32d0e5bbcb037954507b63d1eb10c4fc1091f0e625b30b1cdbb0f05e52dbecd5db2f56940b75f658ffc07003eaa253775374054e57196c0f2e9e2dc3ccfe31c3562f0a98eb3c794759e37322f798ecf187ebc5a7fe8237eb9733698c4c735966ce13a62720a4153ce346c88a75054eb4fb7eb71c7114018a1e84e2ce2575574bba0127e3c9f395a2b5c05093d5d818a8c35e97a378d95921d704e3fc83ad485779670d39eb4ccb7498dc5b3a766aeecb9fc7368f97077d99b1c6937de131a60d05f11cc90b4eca99ba1c39eb7907b4cfd4585edf73042dd72c0ca03ec92123c7a611191c7001779324941d4b024f2a96ab69cc38452e56f662012d46120bbd8f21896a61e9f6ae7f545d3bda5bbe7ee3855ea56223dae29b4e6f190b843b240b9685e764f372a684f93b0a523a922c6bb733cd0b0b7ed3a859eb85fa7440015a9a64c86dc63197e8d902dcafeb3202f69f57ba7a17536190518a5b476d1cf4edf9af8f2c4f97368105d0f6c29336670301fa2eb4a36bbfaf2111a38a71d7b0293af6e8be0a2fe41e2ddda55d52feb9bd349231ceedc0f36bd62bc55abf38a310899d81185ad481165fd25334b7bc6631b69c502c665447ac5d58593f466dc3096e4c33cc5bd533f0056d8585bacdb3002ddec8df24d0c45ed8f744a178259aaa10b1b08cba16270f21cafd551c7a5ab18ceb02838bf965909dcccdae57818d4bddf147ccf229833e9170e0a3278f547b4a36001c1f664501a74e5468b978716ea2d9b77cf7e39d9da3fdda759eccccaf9213b398f1f7247bb10ca33fdfdd6519c33200259778c35d927bc8830a9cb453b0b44f03d1cdf912a6aba6e51d0c437150a2f9edd25ff3a04c7f4e2901d34b820f4a3b3c95d3a0cdf35d728122db8382811f99b0e9166d570282f34ab173d0becda206ab4c3b551b1d97c5ee78c6351fdad65e789481f85054dfb41751f55bcd43cf00cdcd4bcc0555f9939fd888020207f16626a994a5e3f96e91eda1723516bc692fdd829bac11f69ff85f3b49608610886351df958876be1adc9c0772aa52b83807cac4886de632d12e8b2a29ee4a6243c1eac9aab457b06a7645f9d8208ce267b70548da0721e656b065cd6af7a2639da470c92be306d82c4d23c29f33813602f5a15c98d1ad210af249fb3ddb10fdbe4205ea77b26490f43b676461ef144001534b707a458eaf45c7db8774379b3bbf38252495e517ef420fb1081e44f5296608eb9ccd23a24692c1ff486e22ab6ad06f875e0147ac082bce2634a3f7fe9bd404c7a549b0b96601afd6dcc280be484658b7a6ac7468d48a2ebdec02ff367a035ee6cb42710be35a29597eddcc997e1f2112156d04bd4d8dc4d9c9d536556d545d5fb2037a039a4f2bb048a0a9a5a036a89ff573b422f046f56e2323ff3019d2e489b740e1c6435db6d8465198615041b19a871e7243d65795561ec5a951be2338a220f560caaa2356c28aac18d355d0d229a5aa9700f6df191f9c4e49fe809bae60b3869a083af5c22f810bfdc3d325c5a4ea87df83de9014857beb388e28ab86c92bb74543c32802df3b56905621637f012a9bafeca0c3b3a1efee7243103ca92df782f31fbd42e7d05b1ef707e0d564a848cddfe7a5bdcf668b1e66a6d87d3af49b070f681e1ab19a0253db12eda6094134a5908acba149c38655f4ff1d06b0b19edf59ab63c39b1865a3c453482e832e4b5cf0724d03dae53dffca425d7e3e3d066fbda049114cb4bc2b2e5ef09904d5bf93d7449f7bfd391ed64d7cc334094a59d6289354ca9da42be8f847a0c0b7e359fcd6f164b93a21ceb036f3c5f9aefb0b4f1dd5887b4637c8d8ee4ba69ab6a750dda227c5efeac514b14a251b90d23ad8d3f73c6e68a0b972dd9a5f9ad326dc3064ec292a9c0804409e4a4424f97291781c6f28f6e1d89485d60635894c6d846698cdd0e40463fa77646e88a6af5362a98bd04579bc27589aeb5d0d43ffbad77406e710e214bf15bc15dd3ad7bc5512d1fdaf6865ec087b11e9ceb5a193b9205af98f2a1e4fe97f49148d5d332c8bcfe48ef9ec5918d5bbcc791647d1c131d2e33d2ec7e89bb8accd9743828d61ba1a3f765cf3782c154adbf238d90170acc0a8f8edb814f93e4c475755484e5743564544e92f800cc6883e211dfb57ee84fff64f334cc964fb633bdc576ba033ae190f5284133c87e38626af057ed1a12864e269f585417cef40c0239214d6763201228697133fb08506babe3116829d9be165f81f7299f793963a872b979c3ffd88c329ccf76fe6d6d8f529e5f7e68796e19811eb1b5b9097c0a16070b0d0b035e34e778ea135bfa22cdf89dbc0b5138fde19830a8d7df076e085fb5952a8711e0869775eb18f4c695a47072a46f2c77ba0bce59ced713ffa7f37b540aa49389e39df10a04c53d4c719604a95167f7e0736c995405338913d6df0bbebd3706669eabae78420fbd32025e36e0ba9d20a48373282feb1926e84d4f15761a6c339eab18ce824d4d9e1a1d536bb4fc1b70384a73b2edf798e3e2f4dc5f45b062cd0fbf58a020292d2faf1d89d3c1cbd44436a827a622832c31fe3e2d06e4fe646b71aa841e16e0c9028d194d9fe6b60f5fbd501a28884cb90812888ed3dbc4343f10d08ab11d0be03011539ac6fdc9cfc7c0b04d5dd6d686f7cde41bd7d77f6fb84233eb24773938c4f596036875f8376f2548971e785355382c7d14d7c8f803bf3014926212e69f9dd94114e3187331216b8e356d0795d06e1f13b25b46f7ae8917748cf93045dc3ef5ad9416b60cb23ec577bd85b3204a79cebcc426af1a93d92ee8bc727d81ee644cce3f3c498a9889f31313613524ff5acf8d5d73d6297a295eb79fa872a1d09131e18477cdaa4ddce87d59df016fb32874470313ac8ed11ded1cb98435f5d7b83867b70966f12a9e4279bc77ae430613d23054aeed5fcf6722ec8ea8cb7072cf2e34b53474b6d19c873fdbe2fcb6ff98f837e75411817e55980a9c71a8d5290acd3d3117c14047b3fa7860396f745195232a621f62e8d194173e864dbad3ca4cb890da181ee086deb2633012cd3e3046f1d83b44c9cc774fd4802674d18cfb9a2cf5a6a2a238aa4a9f9e4e9291a45c8890c41f42b77f3a0f25b4ab1b2d464b7bcb035718a1e88cf12c5ca2e82ad8e1e5d6a267ffd93f6caf8886586afb239cda1ceb317e72506f8decde3cb3753b3dea27692b2002806c01cf564ae30161902cbf6918732039b319926bb2f3e1143b7d6a313cc1c83350fcd23f7d203fbf02724e4846c8943f9029d4a21fdf751ca890c643ff87fc7d57bc4a12f7ee3286eabd0dc03cfb38c4d68b26a740d4f1524e21cb593b5c1d47e9efe96f05e3b2a10ec84e4f166c40d1fd705ee14d7eb67dd6d56af924612c2a245beb7f626d0db7e96251816b70c842baad1c6e0e144bc3d5d6e9a4adfd1bf7c3a608cff04e2f8b42a4060269d25c29b9b73260961bac2a3c7323b46f3fa7bf3f36a43c634d6e0a5fec2944c18f0cfd7f826f60be08ed4ea3c5589f4fb881a2a655461526f9f035596f5720e69b97c8af7136681373bb256affcd2cd94ec7c91665f105d4c55aeac3610e75f8fc2193fc47dbdb0e3601ba4e46cf0396aa7acf6574777bf81b38f7baa19a2ea6012b14c79523992fa994516939ba76bf1c2a34e7ce5b88c20429b7ec563296fb4f8ae19527a8265085b5181cf98416a6b3efd03c1812123ca6494a6824d561434ffa1e372c41f0d48dc4f8f6113031f9c8499e18cff52e1f38ae552a946be8b517e3c5cabe1224892cac1aaa675a2c8c19ed23731d58f38875e25269ffe1e48ad92d632c855d79ef92a837f181634346b9a967f49d03cca0f118833961b3ffeb3685b5a17b6abc640a47930321d490a7e1df8ebb67bb29e66d52f8c844186634aa1c16bd5284bc6f136c6dba364075183fbbd130c2e8f7474588699a26b6ea4337b09f4d622bf44bad8c35f03d8f83b58d0fe299c402998310ae0dd3cc3ccd19ce0b481bd30fb8c3ee519eebfab6bee028a3452abc8b761e17e07a18a7f4a1a9df0d04f51b58f16bca120e31e90003ec4c4e2e9864ed87eb07a31ae46022c3121ef2afab56fefa90a06dd668d0b92d79fc9493b01b997ecffe1f4e5a6c2927d228c1d15984e7cf5df07bf976d493bccb95246a71a8cbb2e46df5b3061069540accd872cf592b5168395a59324605ee12ea25ee52e1e74d36517270239acd1786f4986de0ec6dbb70af552afc7e1e1c0e3f1726cea481bd23a63a65f7029622dc48d15ca0ccf9d16ec37ce45dc3e6f63ee84be37c5089edacea5ea2052501e7165cfc6e3c47c2f2ffaa6566af4e0d8929d2519963f8e7b7fccdda1ec84ce4c63e90c6cbaf0177cecd70bd1b9dfe06aa3a1b013d6449be391c6b28c9237bd75b3558c5ca338c06e1cabf1bf98aecfb779c1be6424f3a044a293fb59681261ae5769299de2f51d2469f5b172ff2bb9c56e360d8f657f9d8f73c40895c7f13bb9639a394c36513765f647f1e3857b10d93eb3cbd098d78080d7a91b45d3c4e47cbc0dca9baf0308585e9daa5c056f0f24c2d69dd35ec969e3d1c07e2eadc0cd00ab096134b6c3a1bb572c28b066637c021b55512c63295fa4e95cce3078f23d4abb812f7470da22d28c17d2fa3ee9e8bea0b4678afef4ec28410c3d6ea1fbbae45f794d1bbacc06e1cc5fb2e511380d0de068a9276431f4058f08d88cbca59e9c2a0a3ebaf12059296e918d23a560e925c0b1a7998743e4882b436ebcd7509551da8465ff177d2455e95b1135e11e344f30758c12183754de5195d819acbddf072787aee65496f83be14a102792b97277ec29f40f38a8c9465d421ae021ca9a370326629641bbd3a8e21cda0621d654a83e54f7d99d3ab40e92d576218ba26b5be8557bd0e1ef63a9617809b8e193ee0b1b79453610465e5d2c15ae7c7269dff4bf575c3848462dca22ab9c97bdea57e3256b42559da04dfa746925e12f5191d82aaa4ce914bd2436d79a372951309b75f6cd90b1c5c5852b68541d41cb84d78248f4e13a89660e94fa4d204ef9de5cd7e52731b036393f20caa4c399d683c8f4f3f1a0eb0381cd8fbc3819cc8b933bdd068bdf9d458a67859e576a23cc3ef92697f48f9cabb8019f1904dd7e29d8616150204ea3ddb9a4d2304b11f817f5e813fc97bb124a7309d1dc99f2acdf9754fad4635968f9e16c51dcec16c296591cb18928234291f33ebfd343950e184cb2adafd0be2a478c06f1109f549887e7a6518fc6a37ac203cec19c059e0221cca7a19533eef9e643e0d0ac39c1e40703348e47cc486a3ab0d09072a1002977f4016827bfe7d2212c6439a44ad3580cd108d85e149a51ae02b330b38ebfae1605e58d498af7bde881f7740a7d5724c0d8d51728c55642f99ee263a751621c7094406ec8ec505cc7671783a2b366fa1c527a44501bfa5e470b4cae9f431a03bfaa5368a6a6312ef25ec1f3b1c9a6be495513883e57b838fb083495188e8973dda2f145b1347ee72cbbfb1657bac41cd74f3e9906f34bf78b0cee9f304a05a8a2cb6c8b6ad8a94d56253016c379579fdfc087afa5e640b8f49707d894d1479e191c0019d27462736fabde9c94eabbdd8ffc64a22cbd452c4345a25f2dc430b04f3fd6487002d88d5df67c954c2880e68f355cf54fa0cbb69045e0a49771703ca9090ffeb1b18eba92aadf0586d060ed5d6ba7004beab94b06662b22c2aec917babc18dd0f73f2609ff039c017eeebe05ae02ca285673261cc63b084baca023abc492a3bb9a71d3f0a8c5ad3cbe2f855d0e72a4a9454b5c4d469b9ec3b9e6aeac5d2b35238f5a5d8afa4ed69807030aa3b935c5f28992a1b5f2a52b198e75bbb7d07e8b84d626a63f385326d4c69f076be69b4e64eb345ed9e44acaeaad23ea3255c3a04075e75cc7fcb57b6c8f77e63f4840d46aeb4bff55d462b365374ec56147282825d9e9bc75ed707a88c934905ceab4e4aa1ebfc6e47aafa2db0f9b82292fef2405801625977362cc06adc54f3487bef3d51a645ffae1478a105422f1867cf092521bac299940dda2891ec9a8d7a23ea1d0dd2037b850774cb8c0bd5a2fc89ae6127c7e3b209eab85090ddca50120a3910921df40ceae03d1f1f8123562e2eb668d0295d23113b013f6d8d2213561e9971de78de38a8f3de8b104a449f6b2cdaaaa9a53c35a33b8826caa940ef5be0578e19fb616c135cb35452d19ded9850fc91b6e6dc7783fc3297ffcec08acd0429de03a5b94463cb9bae78ade1d9b94d5a62b96732c216d29785c58fc2c24d2a2f695fbc4ef1b05faa8b826148146cc9cd37ffa1d50cab8127663a42a058be6f9a39d5044405d8c3ed19e3f6e8edf6d30c244b9871edc11f7d92ab683bf462946f6bd84d9fc47fdaf1871aaaf14e051fa297e14f38e414907976ff3f42bdfcda546e5e965b030f8755f888709f2a13322b9abfafb3bcb2d53085f3c3fef8ef47289a0daa20f2246eea8069c06c870cb6d9f8638d22fb0f0e11a0684a2b5baa3a1b7a0561c90732026d519f707e498e11f3bffa22f97ab52efe8f303ec6dcefe562d03df3d1150e9d1fa6742e42f36851412298b95eb482d1ee73b4c986f8d97bd4246a0cf47e8666910a9202c5306e3f37b439b115f94455a26eb3d8acc7ec9ee6c0c53317de818455eaeb1508f0e93b6dfea8d6181aed663a988a2a230202f9733eabc97f358125303c4f6adf22b1396d3ccd7c2e0f31f35eeaef9bbf183bce5e948d674a2f42fcc3f5ac9432464a6be4b289c3b8a8a28a0e2cf7973274a142ee40010551c6ec9cb6f60fb1f8f4e433d11d896fac920e6cbb7f28a305603ea878bdfdefc7b954f8b6edb962c8bf927e1ff6e76a56bbfb3c9baba6d4c7a8dfafe0dd8cfa62fc50b3fdc3dafd31065948acfcbe2948cf5d891ff11813c8cfe487aadbcbe8cd751cd62986536c4dbd55a246ed6a4274323758ad1916519ed44b66a8138d43471099c68fcbbba72a7ca69b0612a1a0f323e4bf806da64b82b690df5cdd343abcb45bd8ca75ebe06391008f5801caa6e89fe143035aca4e01f9f96fa20aa95a31cf45a548c722abb42039e02bdb482690c428bcc19beaad18a0850ab45d039cb3acf928caea640a422d3290794cebf3e3d868c8f7367db18f2146be26372b087bb1221ad8b882fd2dcf8a9f7880c22a9ecc5a8c8699dffdf2960cdc1932bcdce5f4d190352665f91be8c4c69c6f82c1452da31300a3884ad2ede1bece299729858d75b978717a7f2c2eec09963f074eb8344819aca901a7c4fbae11235e08679c5c5668661368906e73736ea3b6df2be789dce6c43a389c71be2c443bd987bfde94ea564bd2f13347a801bac56e589106981853f12e7578bd3eb88ea6a1b6e71abb5538d962ac964fffeaf0324a24b1b505759fca1bdc75766065fd3ae2c23c92f459fc889ef38e1ea684e1d3fb8d54c87d81fbb908694cd935ffa9c605c74cc490454d5cf2efe22225e42910d50cff5a3e54b45ec653e11bfbde8a92e41beadd518692d435ba6cbb1039393b97e7dfc123bbb30afc173838860515ad3e8e3f6fabba4827c1c68651e43fbef39c6e075be6f87e3cc982c18233d191944579cbb8dc835374e3742dc0282cef8d300d104d0f12f6ae7fc227f231eebca54f6cd9afa5face3985409b5fdd32a0350b8e67ff79893412b2d416050efbb8084eeeeca238a43475715d1c6bb79727368ab83e3e4af13dafba9cc296286b54d4de61f5d0100fb3f888740c97af02127d2553441da4c5125bd86221342a594ac083c5294cfe288fc90b73d9fc28aaca1950a979bea64e08fe6b112a0996dbf391eec5722e25a917b0fe4b5301da2aa036a2028e13fb6dbee4a03f1bf95361b4b70aa83e5820dbfdf047056a2b00694a1b31db3a5ad63d47f51c71d1c71ef91e1a712c5059af64bb1075f03a305c22ca6e68361451003955da9f249aaf4372d3252d73d54057e6f11c775bdaa56f91f166653903cba7f02aa5e62e19529e9de3d43b36a066ab48ec65898d3d2325a168f7f330e99b9b932358b4ec74a5720048e89d2a35508bbc6ab48b59d7a0e809302921c8c4265ff4c5a73c3ef1f198f453edac6c0dbc8a91af417ecc96744c98379afd05c7d50268357130385c1c958df7ca85b4fbba4a9512f7ad63f8696ab5b18cd6edf5bfd4fb796cd98da13824d1d1e912b2c689ef6cf200c9df36e1ead7ce2eccdd4642c7f0767e77ebc66223740fb785cf34769ec9dff579cdc6e5278f08227f478cb31a14e503274de4e8e5126e6a66b8617805391ab3bdeb0202f8b393feb64456cd56c09ce8b1e27e6d0166e10650cab41edefe8d4485568918ca46335afe33bd583c4e0c7ab17ee8f4306e89f1443bc9f680d0acf76fca338281cad2600f5b4a5ca78789e959f37e21e7b5ffa1c017bd9abd93732f180e4bc1bbf33590490fcc4a7a9258c4a932b5732acf80823b2f5de6f4b06404c525c2cd6e7c528cb578a3520534520687d8238023b96371f7ae810812ed4a28436cf5507ce1f5fbc87891393ba5e054c687bac7709531f06ddf786b2bd6ae647e7b4f640792aeac54fa6d44e2e9d10dc700c9fc5ed6249219d7d4f45d0816970cfd3fe16b8fd96931364e6fa9d55658b1dd7517e3f1558e81e66ee49a062512f710579155317a226df278fd6b1afa0882ea2bc46821b9d0f627dc09ef04c90376459256e52f8699768090dd43d9537f9e64a0d417a5aa25f306de2159ad0d11f5102e63c1907b990a31f000904a0b1aaa502187f011275dfbfbed066e4eabcf80bcbec0ee3640b12acc2f65eb3409334d3b87724c8d666abd680110e374348bf489e14996e771324fcc1d72f2ef67625e7097a3f97982a16aac369175bdebd5d7beb0e7fdc5b6e339fe9019882a41c8b1e9c636186c111dbace6b4833a9831152d933c23050af74a61825a384476c06160c64386df053a828105cffa4c5033c82ac38a5229e8b76efbb177dce07292c6c20c18102bb5441b66787089c47e79ba5ad85a2c41d26303388721c9ddc4da60f1206fd7fd968b457ee3a33e69a08e10abb426a5fd395bc5e8c0792afeec09bc9572cdceffb164af21df470dbca74e3cf95767a28da671b969829c59a6221d983cedcb23a29b70b8ceec88fd08ebd6e7a77ecbbf7080b9c1fe351b98c271c2cf07d57f66cf525793eff14fb34ae53b900d8c40b8e48882f3d387231a883f8d1773e1b43761b7c1c69d24ce25cfb8e8226b233ddfceccc7c0ae260264a655d9a09863e4a9a73747ff6f3c38ecece145b8f753843baab22e40103caaa67bdc9cdfaff0bf3a5334c09c98320e183817aa6b17ebe066ecd49ce6aca1d07b40ddc13be0babcff59a34b14553952e0cf07c12ad62db9742619b5d4475bbd74db011facd541f2c5c09b1096ae26c184d98e2999322cc6753597d7fa936d7da93829505020a477be79d27b6242e7f9e731154e1c7511465a4d982f1b9d2dfd6fe91b48fbfb0c92243f36aba9345607034505151e8ba35ad54d4231ccd05c91817bcc84ef63e2b3227764dfa882a332c4c015216fdc87fc0321f5d9dabffabedb1d0db11357d2242da08ebdad6a0d0bcb1499b145f60b38948b13bebc59a3e24ba5132449bb3aea68dcd60a2a43b9936ba54f7b11c828e67de4655f6929dfbf888aa82237f620d2ec23cc6d2d1227489b95d4e45e1a724b76c4981dd4ab3b4e2da64b597b8676c5650695127a2638e84d826c06e057f9dc82700225afdb957b26520af4e6d9b7b01d12c7dd61111acca6d8af322be8b9da850d96c3f2f4c83b473a84435ce8ef3eae9b904e6cde88c1495393f64874492ccea162d928bac53cfeca539bbfa33fa64de3686c459ad6d37142beeaa6ad3ef98e56ba1e80af4a9a330531d7a1def34de2bee6ca90ffd7e06299fee604a3aad12c095fb79c52ff29bdc6de1d6852379ae1873f1e9e76b0ee4820085ace6691f06041a14a766197ee024978ffd38b887212173111cb9d8c8071bfd710936b23efb7c574609950500d047d45e1cd3b3621cba5fb4f2ec17904fc0c4539038891bc426785d6e24c7b254998f6b3ca594ea3f644a0b7fa3ef37c5fe7702e867221a91f9933a73e751479ed892024e6fba37e2007d2de683e7ba5b66300ad1cb1d66f98e9e9494e53a6d5e566d6d72c6fd9708bae36342e23e02edcde1c27ee3e211e4541f3e861fcd1a2de64e1be21a6a1de6dd4209c34ee80e5d438cfb31adfb95bc8957c2b9040ec39a1afd9c88eb972fa5cc9c886da2794f1395ab4410b1a9cc43d868e344ee65a112b1d29653fbd3af4803e0ebd5c105bf937acbd2b0d0694d6f98bb1e45ac38d5b52ed8206dfbcb09ffb330902a5def6f63755ecc77dc555e1543ae72a9454afc37754533fca7bbec20e60d23d7474122f93146952e1c3a99a4f864204f7fafcf45455185fe0c30ad7c240f94ef3c4d6ecb38d28a75b3feff7c4b2c9c9d1dcfccfb0127cb79710d9b51d3188dd111327e539c5aa68283f8371cc38a34a857db3571e9c8c85b0cea87de3ebde1ee326cf3444e67d14896e045c40ebe07eebbf09d7302a18a7fda17b2d6d0bc01efc2a31a5628a0b1187153063a6c6c0bf0c6b6b865d8fa493a733316e88f5a3656e6f6b5020f646f3aeacc122da084bd60056d937972287e3a29d8253fc513f51e2e0f8bfdecdcf618909fc136d319c320dada83bee58414e710d580bd0cf921e6e70a56187f6f629d183ad2d5d2d84bad33215e3dcb87b39a9af2ce5facb1ee1e0aff79a3667bd0774fd7c2fddfc70f4078af0af906ad2c4803a81a34ee230bf763cbba6df515ffaba647edc007e6567d2d8ab90f84d417438ab23abc5973038cfabd4ad15e8f6d5f726d936f2ae8f4c03ca3a99b30f11d95fe4cdb4f0d1f14f7e69c28bb6565295e91757006d9f4ca8cfa26ab0e6de7fd420d0d926116dbbdcf1b1e741dad5131040904484bf794c5f025a74423d552d358b0c38f694c22d06d1a3a0e6ee20807dd39c8773043c7612a5a58fd009d38b317a2d6753942395902b4546b253ae4031b319d281e9cea1c739e416c6a6deadba5b53c85babce7c154ba60c39351b5a5132bbaf4b69732c13b42caddc7dd18bca9304fc4dd8bf077a0ef90a3cf05e6ad8aaebdde32edbe494f783586db1c580cea835ee20801d4ae3806b609dcfd6e7d4e7bf50a0a0d33376c39e14d3c62f4ef129ab066f5b2d0ffb7f5a39ae7ec2c3c239036c9b35fbf60b913d2b2e3f449960163bf262549940325c05bc89519c47b5c48812e4c8c679824005e78c059473e53cd0341c403f6d35b6ba3ac0e9f4599f036adb15206557eef35f1d45480803397f2e97217d679c13850ae15b8c0df35d3407b4da34ca3efcda4d8d0f34899fbcb8990ffb3816fa47a364f6bbbbef1fd5a246e35281abf2660713c3c8340bfee60b72669a4c80025846e9187a2cc3f75b84a2b4e03d5e279dbe0e017c7884b539209e8ed3d396f7d148105cd04d0c0e14e7626581e832b37026e94da04072293d2d6f3b218f2a6b8cb9f2cf8571a3b588f18e3c88f574405cb314708c314f992dcdbab8638fec447c683d2af1baac81494abcabee84728a6952b7900657aaf8265c8188a59b498e555c74fb3861b9bcf1964881395c8348924443d5f626c73b0f5789b50eaa3d9c1ec014d1219a31120dae14ae2eb0e8084e1f885400641620290e05f32e887c33fd6e121cf1e66e9cee4c3bfc8057bc63ca5b036b536ce9c7cf9b9d04fd8102ae9d4953d73b6183a22fbbb2dc13992aec45a6e4511af6be6865398f100ce786b1ed02bcab2c833dca1a1790408593f8d7ad937981fefdd87db504e2bca1b4f4ea2f0e1ff0f9dd50b18087d96787bc3d3373070bb88eab6742e1db82a8b2b76a9a6bbfc6b04867e601889b381be9a4281d922fe09140f11ad26927750a63c33aecd73017ca2b036ffc1134650005b043bb17cfcc49caed7f6ea7a5c1860c1d417e2c9cf77ea16306bf1557a2dbf6d19d69323666f498aaaea1e771ca56b495e83b1501494a864bc2ae95a9930812183e0b936776c51b2bd589c746a6c222c9be88ed5d6d36185782243289421482c518e3ab54d3907eb4d87b8b60db223cad8b66eb909e5f8569185bbe597655c36503b620f2d6d9ffa97e7400c4edc8cd742e3b7ad65abc8cae449530ef65ddafe5a2dc7310f939def5ba6160323226a9fbf70f763b33a2f1481ebf4f84a185d292574103479acdc5d8fa0b4514c3d2756533e75c48f04bad7a91aea988c0a1c496e679bc5f6fc03d782e884a88dd06604637f768f44a3431ded786d568e9c5f72904d7f7b2b8e4f164e9d983e1a42013ad9fea91f4d53d90748411cad055741884a8760182544bed11cfa71bcbef6bf1bdf3018f24f437dffcee2879e7e6829d966429d0d9c598df0bbd540f5e1974610a471ff36193ffe58f8a532b9ed257bdeb1a4317ef34ae22e38d372d1b18ad3eccd8f13110219b8c7430a56db4267374b9fc98a36b05b4b3ef62e2c8824574ed419ed6e0c14724843af01b59f9ebe81d90cb87b42cd65c2fd9b5826458f9387eab8d0f18abe517ba79e1779359ed2346db44a71366d617034442c64ed2034e2fc4970a3dcf85e922bf573ae2f81d3b07e9e62b00f5e9de2567061d13649ed6a1624395498745c1c7bde76a9cd898e17f4432679e4dbf525fc400683dfbe9d9ef31019a636ad851a206275422a86bad27f2e04b6089d0f3b537d1fb17ed9eb77eb2654577e2d53ebe7beb2ef70447af1a3963f58bf0950034a8619a15002e4388471071b59cfe7ff4702337e621ad3d490b2cad52eb3069ad53bc17b986c59153f9c307383fcf0fca068c0c8187ff03bd6958826b2e9d5b4591c603a71a1f2b2cc8ef1111f5256dad90f12e0b23e9667f1bcd28d82d0f87cb40f93d8daea1c16b2000d3afd044e2c63bfe324c7ffe19ff8c523648e238cb1174d31828c311ed16bccdd847d5412845ae78d8ca5bcb2f31b8622963af008af09547b581141640f24b7b3b790d9b8c1908366f4ef85b86e1e9e782db8cec6f4a162e6e45cefde9ee4fca3a8c0807ab2afdc1cb1342659e2944cc53e0778e2ab4322635483d3333f7a6706b1e27f54e039cbc1f0ea6604d6276dab8655f1b88a081d16f4bd00165ba580dda2e8c4fa62eff8b20b35f586253bde17d2a2cd3a31fff0c20918a88f68074012589b470fa3f2eb2f36ffca2d22448c91f797e8f61989f4aa10365300c97c9ed258054c9ded53b05bfd6b74531997924b53bcf7f202c192cdba535d1e4223b51ea8446a032612985de3db84eaa91e9a86d8d901c2a486ff12ff44971904c0c436be9639c5cf43d695c40a56523aa8f7ae1d451e653656f5a7cc2dbfd97f3cd642f1b387089dd40452f4f7e471d2376d7f9ce58aee3143de38712a2d0808f4bc3ce7e889bdd992ef5d511dbfe7430efd92b7a571707148c9d6ac041e021da734c3ea78b6a1cc16aa34ce095b5fb372650db94df2a3666abd89b4591af8d880bb3b8702d0017ba1f55c9c45727f9289f35602a8f9cb06c474a8a099a3f45de3d1f1e475cb3dd871e933a0f23a5ebaa78dd123afd6c891163b2c3a61b864b48545dd7079dff33b82dd3acebfc45034c73664439fc92f8c9f4435593d4c88f6defaecf1e55769ce955937fa7017fbfa65d7f2bb5f25530a03cb7e1f4c3eaab4364fb33d98ceda0bc69440ddcd47c17e88df913c2e6c69a03ebe16e87a136ce27cafa41308a4aece32bcf66f5dfa93a3cb220a6f493564a742974796dbf1e41c75119237f5c65d5a9eab0c8f29bc51e4969dbd0c74b0bbc47fd8e2819eef00adeacd837b80b2f324ee232c965b6ae6c1366ae997c2c312c5bc5b7308e774c634ac80be5d760874afb0de8434895c58020be70de03074958f8a648cd7effbb89b485647bf3ef9a2f810bf7af0e37829d2a4e70b149901c1c4c5cc44f21a700abcd675a25b554a32dad972b28211f2c9d6017ee9eb165bd5bf960efaf8ac0456f9c36a11316ac0368a901edb871cc4fa786a2b573224f539b90c3869b665467b21677ae083d02d406d8c01444b081c341ad936fbc3b38210646b1283ba03b067e7826121822adc60e00cb04ebb2d25cd6341f468a35814cb4febf42fb46a1fbba26c881ebcfe43574416b4d88702c0a2f9fa59ce76ed0c2fbb70801e1dd40b6b425630ca90cd3e5162e95868d68a5ce68f3f1a0bae9a904eb375fc1a69c0ce61f84c91e6557b77e66cd9a379cf10a484db8443481f899cbf041c9b6b3287228f78f8ca67562e257d07b388fd606d6204081a3feae789545afdb43c7d7c2e8b39a946aaf85934902210acfd12cb4f655e5fb3ec4408c3d551482198a946304468b9c86a949c2184729173b2591cddc7721a2677c86ecb6bb43ef813c28d085d8c196b37b12a10dff5ee73eb7bce585aeac66a2f87c72dd57c99f2f3482baf57f1eb87e57fb45b9cb90840afa7e83231055643e1216bd758a1171e6f86106bf87610542c1ddd2f91cc1219bff88eba0cf4191dc686ebbee9ae49d17dff6b2386eee256cee5a8e3c3225b4ce5e94973e27e2176ff3bd91ad26429e66ba3e48d82a0861313cc20d9ba21a0844d86d0d874b95a52ffc77502fc87e596ea64aaa37b26537f74671683789dc07ed2d4a942e71bf9500c6f24d951dcbbdcd2c7911028e808155284335cd9619098aac3c807e83ef5a26088742b6ad376b0c020cd6cd5c3f1f7d4636e88960feae1164277a1659d2491ab1c51c8eabb7ebb4345b411e45b36730863e3b7339f45ccd316dd1906dd1f27a49cf486a80d00189d8822810db132277e5be8d991a9c9d8f0d2774fe1ad4647b46687359a16ce5bff69e44807fc0705fc21b2b9b4816ed7792a68bb3b2b9d1776eeb6f524e3f597396fee11ffa155b50b7a486b6600615bb003e709942074f99e4522b7d6a45d8e2f88379f22910ab1dc1d842dd9c13c32c35a4325111bb982d5848a3dd9108f274e788165b02445278a87b298bb454f53defdfa87d562b369e0984d9057bfcd2e6367e8a42401218cbe22c55071fbef155352500a75cc658f74c414c620c8666ce316989ce8a1c9db4ea984b4eb8682e59bd151adc9114445e3fbfec99e493dbd8ba4eca277cae0082b308331a18308c40ed631a54679f65811b94139778318842d225c55f04e6491aaf34f0729321f5b070f20f2414afbeea0d79ed91d9d064ae48c15124102e0fbf5cbcf10a6d100f77c8b6939b52c84e0c0753e380ecebcf5ea1372358e2b4dd8723acb3cb935b88de020e15b59b13c1b84f9fe2430bd4817222d42f930347bcf9f141f477c1dd4667ad52dad0cb141589ef8e36df3abc70df0731c1a98a59baafd4e288a5ce5501997217204469f27d4b20945b9f2d4f496567a3e31bbaa12560396961002f26532d17dd56b084f75c9277fb675e91139a6d5369608bfcfed78b4659e202723f1d5537930c0c48c461c3e81d065a913b2e8b46c463a525c689cf40570a3b2455abbeae8950c2d0ba2a9bdcba6c84d0ed7aae0f367bd93b28f7c107a68ba355ef2f59a0b14388f5895825b687099fe08d78c87f7507eb698276b6246cc2af7a49b85d931ce27e2a5008d3f1e28e932dea3743f2fbd2a2bb3a9d32e0020f7c200fa393f9d07864c32cf799b706c961fd7a887ffa77de9ee5ca49c3097534bb90eedb239055a0daf85da984e2d16870f99b14150af5b5446776259c1b9cd9b7747a638fdc0e2b091ea3e8983def048c5f835d7ff266496c7cdf884d5d9bdf370bf1da20e54ae3bf74152a92b989fda8c6185dd5aa83f42ff22e7ae68cca92fb0fb3b7d781b06f156929624061a3b6be3c31027ba0c9f54ec968940515b51a489374726dbcbb618f7e54132b97395bae7d21a5528244789979c62ed14c4d8652ff7bb9791755277e7dc86c8f1dc1218b0e7474873d96714cd85466a03c94d6294a0ab8dfd6688df530aab78c38a5f7fda4de1b0feb4a795353e00d25514f20d1fa2e9bcabfda6991bd6e37ff0ad137adc0e8893a39d45f99e8ae73cd7f58445dd2402a90e048a05599f9daebcb0db9aad2bec0ffa3560b53115725b681a113b2854ae1682c117eacd0b1c2d78a2788e2135653cc5a0afdd3e189bba80f59c1f8bd07ab8b1e9234693ab79d0bc747a576bede8d3ef7ee0b533994ee80b1d0bd1c890c61d53157c74e8d4e10c9e516b0c6aa0722fb9489bf45dc332a425e48b1a00b66bf84d2da99b54a7cdf0db27ea3771427e57cde5889def243283764d37fa03e4d2a4b678b669f8a0aed6b11cbe0aba425ebb96558be0eab726f19ba413a750db494884e07c082935ea7a6be7b4feb134c03e255d39ea7a67f57055e2c9f88b6fbcbb3551c74f3bae3dda36ab5f43c1b51f39212886feb53ed732a6466d95d927046d00c1b0bad434ccc1a9a6e96c3b09326b6ea84625c54cef779bc95d7bde728f1d999f1735de13c0d2de0d4125b75d2853f3c87c32a98ef5701f8904e66b34151c16fb5f34732eab47b08481ca23352d3e340689601df4c6294248562c43fe881bfd6f4b940604d89833e3c4b21814742e11e698d213eb7c73f477a8c05b967f47c744c02498d931f04824b90fa8546d1b12e8b5eca62035aa96e815347f6bfebdb5569c091a92d306f6c4ee6dee91182140f05be7b16731952d3a73b446f17308d940da8edf5fbb3f28ef6ff870d322cfaa27ceebe578760ed5ec9336b79ddecd59bfffa9bd61fb73844014ac1512bca099695749e38b8e619e55b1deac74f9d376406ca9ed5bf89b9a47a9f3a73f43eb8e2828ebcb9f95210aa151037af0175b5e093af0265301418c7db31f51304216416100cc8d26947e1bb681687f90c990d73c929eb501d60ebba6a87f68df480005b00a039587ecbec968a6624afea867c0201577c317a61d3c3f84ce5bf1d746a2d6c93595e4ba782a79372385e98a41e310b221dbde347cbe8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
