<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34699636ce4da3a065559673af75a20bcbcc82e43d611f318978c47333018c7f42030dabb2da0a22a99cb2ad0a3760541efce00ddfd05cc01dfc0f2a3f5b74b5cc64e55c416b0ae26aeeb6e42f67898ce8d86eca0a999073b11b7c41a7f48819478d7baca230ecf7708d3180f9115e71052a786b5fca7f3045aa0a406810480672e34f5bf344a33f0f961772e5569e08b550c33a2399430bc864d1b14debb7ac91039bfaac21ff187e7c29bb9bdf38284455a9f7036fc739183de46cba3636cd552a3939183ffa1b398f679b282d1d8db083369f1e481681ca2101b53c7306408925a23e4f70d568164390796b882c1fd81fd7d31cad247b567c9f52293d120604d92e2d3bf54a6c3d72b779d28b824e4f2804fab23b9d17e884b9cfe2e73719082251318133d5563f1cfef5f5ccdc987ea19ff149999c80d5458769e1392e10d78fcd4d9b4adf614753e38641f32d723b39b69c8fbdfbeb6d00ccb11a352fbe7e3859bbf11f000b49232902b8db3c23646d760db6908b66b153d20e565bd10a5d630bded49ca81ea305e793f816a99ab693bf67453666d39678d57a4fc5be9019fd01aa3986f75ed0506a421b89100263b29912877de134f8c05b88c29286bf06aedd2c7580b415b998028700b92ff4e4612ac03aa19a90b06ab9d4a9045a73901932a30c1f5bd02789f3f1953b858f278a459572aff09fc04ea0dcb25a9a3e94fd71fb3729a1ada179f5f8942995b07feb3aff58fbba092f0e3deb09f45ad6f06d4ac59870f2ea8fa035a93711bccf9e1be27f33360f2f440d7dd8a2703f0d964506c08cd07f7f8e9dcf288218781a8224b0391c9163e6aa3179ed1ef52ec0e3d55cafb1ab77f49befecc1b14c19f60d77f36b5fe6ee7bc4f71b83816f5e27a8280ecfffdabb71acae06dc28c1188439b258ed3ff832efdb2ef6a7e780cd22857c454d1bcbdcf60829dabfe9ca35c36053a853090233086e640af11087fb578dce033bc1d75ea67ba8ed508e65ed6498edeb67b03be68e5209f4cf86cd979f3d7f3e32e85dc91c38fb9e1cc4c91d1a86c9c6d8b0a754a968179467237205c73d5342f268ae237e0db3545e03e3d3da2f23bd83f693dee332f0455136b427243097e2fe38af2fa7a9a499605e40be0a80b0923392dd6246dafb48e2e0f0bb9568383aee4de65ce50bd8581b8496de52251b50b3958896c7d33f1a3d6e0f65a9dc8e8aa134c1029518312f1abfa578093cdacfd8fde0ac63a2d8fd7ee0790502364e206d14d25d72ec6abcc3cfc4fd439250b006303930eb2556bb33ab38cbe1aca7895e9a8d20b54cc8f6cb0f8d42c19c1e551ec666a2efc784656c9b67ce30695149f084262ed77d2b9a77c44ce8d22959271f63dd36a80dce4d8e21cf56104207f7b5c0febeba89e396c4d42386f8ff409d65d972a79d57cc50a2e9c933f555e43625eaddb55865b5f151f24e23bb392c89031677cc2520c4fcc44d2cf5060e56735665ff19b8b4c78d2df48ac57cb7b8cb34fb452375f3935c2898e99586b08918dc6d8bb1f695615b9b693332ddaf7922c282827326b025e3e8bc54e9cac6c27842b6cedb317949f2612727e0fe9113ae01d8ba3e73b910054f3bba46f0cbc202ad0d43cb3af263369e34ace8358621302017d8f493311424b98713519cfbae75bed1a54bd29073ed531ce653a9477f04b895a00c17014d8659271de25c3ee7ba7973f3abc34137871d0338a26c040e1203ab1a764e93958fcaefd5d0aee790d137bedee5c321259796ca7d82c02ea093df168b9a031ca5dcd3f54e9a2bb77a1168c70f89531165dfda0a63c432223346545b85811f8911decd0dec40162d9a35c4b74acbfe03f4b54946741a0a0c2c07d4bf040313804ab50a8fc7adfd8305d0341e64221150e46a6a24c6ea9478760a006a68c70214ea85d4dfac0a9f3831771629a92d764ae64cec2c89c231c863ad562ff608fa430588bb4d5a5d07c9881694b046797e790f38ffd414da0121ecd3de1623f47c252d68653c3b26beee8ef4c24b013d6b1be79d7ea993146abe5e13c0836282e1aa726195b75de92d04dcdd9caa48821f1807276d2fa959126392acca445193a4f844568d9a6756678c3f568a3af7439ba41b526949875dae1580d3ed76c3ae86f26aa0b9c56ed45ef432c673644b863c81b38dd37b42d0b08b18a0531e1ad985be83108142eea74f859a42ccce04722dafafb4a3b1bf391bf6e73cd10287db7dfdc3fbbb947c70df312f8f8135a4766b7d961fd13c31d062e78255f89187a8317dbc7a660a16ccc513a7f7d2ef477c71548596c6be25ebd3d0409820e10f241ca1957291c67d261a3d7572a86e308c161e10b90af40ef08526f78c2d74c37ac2df4504f6bbe92ccbc86eba496149f1e2492d3ceb6a047ddc14b4de49bdc4862de994ebded68ef2fec94e9dc88b6d36966e71d62f2e753c1c7838d1217e53adceea752f0aa6d5c13caa0cea34dbe8e75d231000a8148af9f4f75f90c0a3b9e0fa9e0ba90344f9e77472a9d94d82a29411ffbf166bc4df9e83894754550023829c120832f9f9b082d15a1e038812a9d224a66d6a7ebb19c61542cd5bdf9c37b2075f7250306e3f13ae4d3b1239af32f5b3d70dff7864375b51a448e5a4ea13340746906ccbd7b54a9eb590dd1399b5bfeaa214721f3adea229ba0d17924f1c88775595a6a48906b7ef646826b5a7fd3c0f38ba818a925baec9a2b60c8fec1b0d923591b53083fb44f714845af1d1e5d98f85c0f762fda58f71863867e78add3c645e612e060e46b0d128b6a5b8d0147f2bff84a4fec81bac13f045fbd56580c547208cb226327713b5d68c207d15e3d42d55b3dcfab4895cc47aa5e9745a8128967f7c1ab260cb19ec016794fb7f27f4ab694164c6066cc00c4989ac72e1034368487cab4cb2e35ba736eb339745ec6835cac96e41aaa9984ddb0cbe67f6659a38e542557bfad9c66e37a693a70735d5d4908cf49a6671f26bea82d0cb97e9f5af92af9742c67850ed17abf4cd8a9775c70aa6249fa602d7f3401cf7b3af0a985ab775ebf16b7a800a68bc5993ff5fc2145f610d3275264f5f6574b69151ffce232c896e478cb762dafac4b9d8a1e62bea92a29b87895a59c7fde0adf0e93f761af7507046df1776546504901e06741a1990305b2bd5a883aadd4cff0848d677ab7758b94f50c556d0e9be0ba4e93149d69b836368448cdd5e72b3cdefffd17cf9fdac612c5dbfad08f839353ac2af890bb53e19f42259f267a1743382557860311e8536bcc0d0f5eec9f663478376078072a49a17a7892cd3bd3141e8a21545101e9fcb9063e64f2b2568a6e99cbac97f1ad925b1f5f47e85bfb14686a84ac751b3be4bbeeb95fc705be80006464f77aa917dde939a39ed0501606d1a43f314bab5fdd61c0feac5b8e72ab96283615ea1cea052651b8936ffedef14f4ebdae83c0edf505d2b35d1990ab463bbd757eea3977e0d1145d4b130920d4e747b529bc523c17733b4e9aaa79f66d81f3d3d95852a61aadf7c141af3bb233702d667a6ad01a461666549ce63f3e5544065d4af31db11571683dd98751d81bad9aceed57bc003cbb4c1458b580d4f4082dd0bb14c024a1e914c77653242f10e9fa9ae0d1496859eaa6fa6be1efadff6e9b5a48dc7ef9b89a083167e18f3bc1cdb4ebcecf83f59c97d259b6a602df626c2630f60fd3ef352e148ab13ed05c69e1861da123f48f7dcdce8ae64488d91a1b6c2985746f6fa84e9d89993cf70bc3d6cc6559351e648659899d410f156f0e9b444662523c0ec53b2d29a5d85851abcb2855e3a424c169ada2b5bd57720a2b3a072141b08a6cd8d8a8bd3811974dd8f42ac1c0c4d869f6529f8a6527bf9b029313a148f6f3e7eef8ff1da178ae168419bfa3d06bad6a695b9a1b9b1ba59f76d2fd3826cd473225db26509dacc5fc97b559d18825bd9f79f5e447477fccf20234a8b540ff8fdd8526ecea7e67bd0f8b917eb7737f679c29b26b120b84b289301bd49b1d63f4aa0b924699ae6beefb4f0adc1fcec8c6ccf9a16aa938a8ee719d807201dad930e48b1597c042b987552ac5d6225b8da848fec171506d04ce2e38a47083d7b5998bbaa3c02dc0d9527db05f48649295052f625d0ee1a00413dd77f1193acc6c724d324cafc53b46c55d67bb93484a0e1ec7aca2e24d85e729317a12dac7ecd6d50ef515fd0af52759df26ea2119757456dd9daab6a9b42d9f773ea32e6f17742f446f32160dc2076e9c885a436900010646567ad72498cfcbe94057b4b8b3aca93689dfe560b5e09e1db7f38e221f33454ab43d01b5782484090ce7744b2da16745f6026228cff4241243af1c487197f0fa504bfa782d430ec67934a87c8ec7d70da7dd281ac2f3b0db92f186fd60549ff2a4dc5ab3eebe3750cbd768839a1ac4d83bf518a89ed92e88e2b510d5b2d087adb3e824fea75005f137f5782252a13d87b7ebf8291cf5729c043649e516303590643b8de2b2ac64db522e083a146bbf29d7d89bdf0016887d7d8e5e7f52b017cf68773ea4b28bcda8d630a2318c360ed9dea24bf3039f4825ce89e4ba4c68b6cc9704690e3deb77be124ac25b0ff1f975075b1f8b5d530053357a4ad5dbcb761932ede843fe90475d404cf9c52ec39e31e84640d7e7a4933b5572d5f94d4f0910b96ef0011d157f5579fe3678f372a8d0e70cc7ae30361465f0cdb395c0f760eeb8e22a6f9be4e191e9af03efb564dab47f48167791c54028c666ebbe2b01b34ddf1b47d4fe91c275351ff7bed95312eb10b35affc39b2e5db18f3886c42ce41307f5053330fde5bda99cdb60c234460fb4ce2ef46859281773e376bc23d8e18e9c341e8a2982b4a6eb8c71b250783777f557e844f875021019a5f22633e500a5bd70569fd9a10f46bd5b07c82011449caa78a73260df8b440932af82607424ce033064ed89b233dcb166b668e16b43796aa4185df417798c5c0029169b8427125b4022774a939d42b248a30f468e0a108b701cc6c03fc34253cde9aef4d08c91c0d626a32996e2694fcfde8d29332d67acadadedb062deae183aaa0ad253541b77f6f2985ab66eb7818f7bf24b1f29c84ac9da203ec36eaf192f0ff82389b22922cc70d83f4fb820f5c5251120053d9453b02fa7dad7f38a9ae6c1abee9c1171b5976031beb9871c6a20e05e75ed7df01f1ed7478ff7feb2fad163d8d0b3612cdd07095a717279e46914bb0a51f5038970fb4be005a3a1c595f88f7d3030885f8b7940246cc787c03b1335d8c31cfb4eb5310882a10055644fe01054263bde61349a11facc3ca5fb9f22442638a831158a29227dd8c9aed878994e0e899e32fb193a43768307124ba7cc2cde2277f0912474b562fc305ace5c4c65a08d2908dda14ab8e03e49e16af5f5f897a8528d05655ed3d58e01163c5c6b8d6467389229e0b02c1d6330ea819a6ee5ae2a0d9244fb7f00a45d8fcd845ff2ad6f52d54ad74e55034cc61d8832aa39890e1329b2a987fe8b64a2c53b0f10574bd9efcecd1ea57bcba610ba9c39e62a7f24154e0bc340eb2b86948bdffcf46a700d85644bf7a27b08cdbe487b3b58a491b6e735cab170b18c67864f98640d50114e57a80aa2e2f6e1b02d0d0177d2f1d631890905f895b7dee4d4af17151d9f19b27b09c72fdc08f3a0c70cd734aa4bf55fce073d159e3690ff2d71aa36670cb6bd0b5d4703250c7bcfbead2d97942432097f0f154af7c7a43147ec18d7119468bd0f995ce32578c6d11c67095621415f574a12053f04a30e3fa21a11cfd9703e445c1c5bf7217b04f7a4ba9716b9da1c6094b01a4f07893172f122c4593affc33c7a3affc9fcd6bf15b7911e62c0bdd58405ba339c08cde3f0f3158cf906ba64d48550d0079e4d4ec37724c745795ce33a9c2bed2ea37e068bb582c61724f74f09ab6284e4b1d83ef916cddc53183e36798f3a3883754e7877ad5fdcf55147963409c4e440ecfeb8bd3e0b105bcb948abea647e8dca7f7b03a0fb65da1b07de823e6f8389adb7166e60e767e4d7666812ce8bd729e6e1986c857de0bf72984a203565467892fddc75708df12530e081c3d99f446c1190b9fcd2ed1776a3d6b5302cb7ec3fe92216fdd77d85d1268d0a27db2ff5460683d226fe97d368f4f7f030d84ed8730cd217af2a8f9b62aa2e544cd2e4a173f60fcf5668622413b3572325b5fb6c8f5fe58cf0b20fa07b1a9613233f3c9a499f1eb5f2fbc98829b6302377300b83b9e6314fc4205d26ec7ebd9a8f2b41515fe84c59ca493984fbbc4930cfabe2f0447603ce141b717d565f1db344fd98700db98faf3e1f340ffa379219f0ee365005ffc07d309557ee5dac5663b295b1a088aaba561af5475be71019692d5912edc38adba2f95622d0f5288d9bb9af0d88b3a6168389e4442ff17a2f26c197205ac7bf7bf211c9bd7143b80c754318a73e2b5a5637880f30fa63c3259e31073338047fabf6216ddaf06f1871ec6267dcea17035da179f3114af42a4db4c605fe38bc1645ecfb7aa34c0dee64e4cce9645b55b96f1b6286f88ee56b6ff5eaca7a3b2757ed5adbf4a256c8c12bde6c8033059129eec451eaf5b83800cf18c0e55988592bd5c4fa924128fb1a07da8c19177bfae50eecdd002ec7b9212472e476320f3055a4dec5197e3b47e6ab779c9d1cda863ef210188455cba1b5b5bba4e0eed8bf1c42c2f13b7edc94caad212ef954a1fd9e34e658bad6210aa7a27cb60d9b9bf75415ff7e5179c085fa810e4568a4b03a33bbf47cc2db5290c7356fe8c4db73ad49752ffca50d17c7d2b6d149bdf6aca8b029ebf62886518b9918154f614e19819733cb1f1971e807c5eb0a604934b3306020f52bac4867034f769452568b2c80ae81c5406bc166fe9635db3ebeffcebc032dfe80dc2d6fa6cbe6fba74129c598d245324dff802c551fa9ebf8cbfc8165998d7d141bedb2049db7ab5a72c2e433fe0e478b157f6ab6d20b24a745a6f05370fe0d2667005d870635579af4b7822650dc7a47f88b711846f444d92d0375d3153522e220553835efe09266510653c00dcc4853262501e5bd098738b22533dfdbd91495044b53fd70faa4a0c2d25238971c4de671bc67fcce92d21043b1042ca871e5871455035a03c3965aa322df7d41a355969f00b5c2609788e05efcea31eda9239322dda89e416acc4a96bdcd1fc2e4b359547ff403297ced8f4290d74eadec40e08891b91c03382a9dc346a7820a5104c225cbcd89670b3032bb2f8f1d9d9baea202b18161cb66024fd72e10aaf553edb2cf8e201704e4af0634bc9fc7873e908b2d52e4904b0689594a5add0370300ff7069b424fe9b7ba47cd43488f81bb0e27d8e8b2380be08280174a9c3bf9d1dc7893371d1a0dbd0d3fa64ceba04a867c42c050e7b20a08345c1b434fe465a284a65b99f04ed484e858a213335f267b999a33062d4a20902071a6f96d0a5b0eb13b6afd89cbc844ccc204b4e331249ba19e6624b9a7685380146e70f8bde60cd294045a42e39068febee5674c19c71f9c72dcf4f0964f096d5f2359903ea7b28aa6d4af400e9a0cea979095f330a2bddd8d342c0114e677df5642063787447abf0943108900efce218c6ce3756ae22b7a168ec07d61c9b0f83745f3e8792a061091a54696c6d931e35918eaee88653a822f941b9988305a27daf5df94282919ba27b476f285b79b9dbb56faa91a832796a2b5254bc1d9ce42470b59f8c5cceb2ebb935d5155ade0f959a44225f4616de690ff8847b57f8ab7b179df0aed45e54a47c1551b6dbd59dac27b9195a145a895d8e078d1da2155166be28d212c7627573097c0aba9013446387a25eba2edc0a3329773de91d0b855e43914455ddf22a41c95afb8fdf9a005027de6b256fb8c4861a7677f3bd3e2793883fc89b47bf78712ecda0df2e71a7107f487e9ba18274a5a258c8e8ff118cf1c75b383e3c61d7cf8db846821720d41d4a4fc54b6878dee97e92cfa63e5c5e10c02239a1b3703649a0e125c5ff03620a4047a0117c79caa85edf5057fd45e18f01d50adb2575ca01ee7a1f5f46e82aca56d5116b9463c232b987eeb2bcf35e4534ac807cd11af7e2833074c5c90388158bd478185532b29d1a3683e0e70b8d89c976a0e8b603370ddb8d99106319d51321239a5c13a789162f8416d3319e722d9ece7654385f9c40e9a7c54af2c5f355648ba5b2a9a612ce3eac8edb166f9da53b7e48c9c213b99bd3df4424ab9869d406a1ee2676f6ad1140a169a81839f05c0186384a4613fb151093a628bb2228211a38886e492fdab502a68dfdcf05358a0c63623090ad7ef1cac631b05b1d08197233117630556e4a3b51854b08ec7e81c95b5353e87ed5e5688df20753ea251648b9606eb4aad327794c1158e39fb371badc68c9c1c16eff225f8873e74cabc83b386c80224df978d8b13c0327d30f3ed3e1108ab7be6944545cee6e6b092e65ecc0dcea2a7af2018a68b60ca5174d3f9d1e1a5e51650b4f763b38017a712041cef5c43ed5da9fa2b523bd130ed5f197690d33e76bc172db02ea6cf891408436c5430c2d9bab80e160371d84e69c4554f9d76feb26cdd268590685acf2bad5871fc8cc8203e4cff3039b6bd85321c676b75d00f640518429cf043854f2ccafc598ade1259109900cc0d6b142175a62b93ec6f84614d0b84006d93a4e661006674c384dd4b29ea7ecceb2cfee1bcf8f2e98b39eb2eb6af74efd7ba2186f1b9fe661f487fbf851d2b356ab6d48b1c53d10e6b63dc9a603ffd1148b7b80f2f2759876348dd1d5c56100b6b022d345d55e01817b010c671b3e8b74db02ef5448e85f2b9f3c788385bdcf5e7368a199aaf3f348e5aed211ea734a677632a78be03fb265372fc93911ab427e5e145ac4d47a378daa1a3d0737cfab2806a6fd263f7de11455be1c9b2f5689373b7eb28caed15dde2f5a1dfc12f98d3eff27e09ed222f2893d2a8b4490eee81d5047bb0f2135deda809d699980602b52677012d6ee8097d0045b09c61bd6a97216e1abbbce4a8749c0da1fd6f4a6644da5d4f04dc1a9482925421d9e1fabcd670af4de990728663b5b76dedbc46418be030ac05aafeefea2f7351a7c2fc694585af006564289942dabed67dae29b863a846b97b7d9584e9796db60563e067643b08763f2687ca6e2a6ef44e6f9a2f28b19ff586c3aafe53d11d0aec4966c321780bee4e3f81e2e1d5d1ca23393865b41b01c01e47b81b21630f45d4cafb055e73daa0d69f76bef6efe0911a060dfb6a59a9ac81e11a611b3562ebfd6f25f1cee5a6c2de3d82b3818d876e34958493861217b6dc36c18b5872bf252f8207ee3ebb2a5cde8edcc1e1b9e29304901e077aae4f9193d1921088b3df70f61ddec70ea0a520642ac5d7d4386f80405d1671b2ce149340428fceb849ce7fcdac5194aed09cdac7b75ba3b9a76e4d946c5e05a2454950f3ce8cf69ab7a695d749618df7dba81c7243804c50c82171def9c179a0225bde0d87b4aa6de167954316b639effa7e3044df71212e541d076ccbbce5f8761b6aa8b202d058907e792f3395dd90d2d70043bdddc2ec547a3e952f93b504903b9dbf6db7138167213c3462b9a462181c5ce408d61ac65940b9fbcdad57a9b3d1bf086e690d655cdb2dbe130fc86c52ede5dae1333c0219ea5b1e5a99d2f4c1e79c3acf2a30b26623b07045291083bb4cedbacf88073e77b891bf81383c82ea341be48e38be74f5cc159d7cf2f77ec70b3a61862db8b6d38cd0cef702ca3e9378c2785541b6a8ff065147c69b048ff7f4fcdf0e7eac3fa13cd855ee4d72085f0e305d55689023a3fcdd07c0f88f909ebe2b01ef61003a6d3b8723bdb6dacb788eaba66a81644585b7abc8bf38e274749fa20a0947d0b23fcb071dc2eaab665b272a31e2784924cd21d403bff1c596f5ad9cd4ec098e35d3e152a867a063ea63b59f0beca86466aca5165686f1e808db1d11554a5f4b9b674edfac990533f3a17064dd612116b2cafee6c68843cfc27405d53ba8c6865f28737699b669553cfe388ebcc139ff06863596609180f2d6db9210114b393821545a54e19331bfef01b56b4426705c21f281182d85db2b0375ceac69fd5749260c3abdbfb353d6529c62363cd4d2e55ade22b7798b259fcee32cc2b02dec78cef6c08b2e7848f450046b11de7d007442a48c85d57d1f6707d9418276950ec29eb7c9bd11f8925556e80351219d32e3cca82628a6409a3bdfdc7d345b841dbe199b156076340d729f86aa1eb4044c9f8f530a5a7dda8d95ac29b884f34300a2459572afa448aa4496a2d264387aa9cc9ec6e09acb3ec61053316273b1757c7a986e39cf0514d233cb90d92e058f0b7afe2e649917fe0fdd3edea5c8de6c4c46abee7de35fd7273feed69ac84acacdddfe5d41f9c4d64424ba4d5b46f201ab4934f4d254967490e59585a9316b0b55e235914466e2e502dd5000687a12578a6b6b7b402bceca307991f9d16cdbc1f197c7ccbb987b05be1cd4d18b297992438fe05d5fc5c163a316d6233da8a25be1b5ec87840027949298e358a9b63a9a9585629cc18a81eb50d643948a2e309ddad4b04ab456fb708f9484db1cc67be45c52477208c1aa1faee42ff6e7273a23a3456538dd6292a4e08d02da5782ee08a34d5615608163dea29aa55388507e3c29e7ca7d556e27abb1d05edfdd5f4a81e2b14c457877a1a304260fa2f3c2bfc8cce6268f01a91c331b01f66a0b84902beb7307eaac3ee7b611e135f586f413b977775697585ac161f3f5dfdfe365c019b5bd8293435c4e2a13185db12aca8ff6a51e86b5e03d994f76a6083a20b86dbf242f23f1955e8d6776f0e88305ce4bcd81d9e79ae9417e3770e70c918bdab8214e3fd0e7cf79d1a10da4001b5c12933d7df97d2bafd8ff5ade19ab446d4aa039df54c871adf68a13af4432f29b89e40bc20dd3a3054c36f6988c04a185fd3a239e0d33a22dc3b21957c050e21a9f3ad8cf3f4ec3d09231b7eb0e59a554e7ed79b143cba19a26764181a81262327507d88ba90b139a937f9b348f319fef0cc1834fe062eba12b04fd001bbd1c2bba838d75576c259901597515851646e53f9faea215fa18f99ec38e9b97d3ef0a3e5bfdb725522659e0d709d25510e7b47cbfe002b64e4e792ffa3ec9a88648f56928898ab32702c6d92dcfa291a81722dcd7826a2791d6b4cabf6ffd3d813e361e12696be6092b317dc49fdfa1346436e28db3eb9c2037ecb866b42662cb04fd2b4e2c622cd52df407b29bcd521c07c310fe39d8a2082217cf73880d09a9248c1b2fde7e23e862fb5e753a9293e4b737bc96c256d31002c4d14f4212a3ee4e087705d65cc98fd54398ed7a50270c1b0aa7e34dcb003348eb848b13cdfdfccd7e3dd8e6094120877a19c0eda24b312525cb8910ab25e4cace189e742f5408f9afda84564ba9d0372fe355b3fc93a2f51686cf33719336d97472ad7a16be350059163865e8c33929887c322c834c68eda0082a55d581a883ad64430eb60a7b359a29899d71017e55a3dd963f9be491358dd9409897a395355450fcc52bd3c609a17b5fea107597c1d70fdf3330f4c4acd41160b93d581019090223595018fbdc2b78b3210bef3262b8ec62a3549aa13f44e7dfda091fb89ac94a7126d590db7f192859a07c510fabe8d33f08fc0c0daeeb8f1509c1960be233ce3e5af6816eb255ff98b19aced7264855cc0cc07b89f77486526447878966580e6acd217323a8ce1f280e6f3e4ca75a74563925ac261b47f78079cc4c4728d8e292b61d92f11cf5a4b702bbb26db3655753b790c4b99010db1a5eeca110b7d7aacfde9b56eac1c727a3efa5bd1453b9e080fdd44f7253015ee9d3b91328f3c1c0b8198d0ec9e4fe6a039da181d5483604ee76ba0485d6c4c72de8e4776994253c5746679b284fdd4bb33b25b171c61837a115092e118a7c1bc123cdf09ed589446f13bc3bd0a0f3a4281fb092a5b79b23f0d5a747e42e155606f3e597a26f5255bcb963d40277dee4c42acd8dc1221cd9ce6c15356d573d032344458bbd46155c6e65e54557d166166f9b230160e3095732be5e02df594695f9ffe780fc7236882f902b7c5588b642505ec299ce3c8f79ce0fc7b423702e54789fcdb5bd9229746e3e822add42a5088f1d487ffec799de7f639e97963142739ed7c1320d938ad92e504a4b181af516c8e13ffda0f516da1dcbc6f6b00f262cb96b4fdd09d39474cc4cdf78ab34113616189520bb528427d85a546022f8326354c8df70f217a1b9c6bf86f0228109a22154ea60c81e1e4cc68a07b85387f25bd27491fca5a7921ad7ec3509ba9aa2710af71582955f495ed49179b5cceef3dbdedcb951d97ff6347de5240e7eaaf5cc1246c225abdd5509753a7513251643c1247573b7a5f0c99f4371c5053e7f36a48c19cf4cbb4d7a176988995189653bd402ddcdc29bf0a2e3fd411d13d788dcb07fef8d0929e0bfac7dd64edfa2ca900db6b406e937f400e43a9320aafcf279d0ae9a7d35686ccc31125c9ca13b38517afc369a3a179049487188ad20311794e8ae1b1bd6aedfa2b9f8e70102b01e5ec461b93dafab3dd8b82c5a4b069eeda041fef365d430ec69d86b6e6c37560ecfcedc0fcf902253bad8312b1381f8c663918377b663470fc15a8c0378157eb0c411cc95ec75494ece84995af7f07ad7ed0861c7799897959af6dda398f12dcca3453d3a945aeef42fa2360f77b575eb2c35bf1ed4538a17dc6800fbb2049e25143f0b27f38a9abe739b245c8cb0ba71acf9d064fa320803a0d8e11818494f33892073ddbf9582f259a3ac5fa826caf6b65eec747410833ec4bd0ed9e7c935cb43bf095aeacb873118a306b5ff8362ea00692a0d2d43a2569725d458f7b35287f402d2caac903850d3f56d4c7208d94a9caadc837ece974b1b68725a8855c7354f3d3aa2e253c9430bd4ed0ef54a97ea2ec6cecf2cc486627a3f98d55e834c0dd3a9bfda37b0a8f80fa94106650c39434a83b839fd7e75e84fa32ce995560ae0a60447760b6275aa40ea85b9c22c4ff236abb64406a413b666cf39545e9f3aca9cdb75573873c5348fee809194a8fc598ad4f7c0aa0aae491f5907d2a397b85534052728a9b3cc62bb362a1272adab2e72e41483a3acde1952cc421e8bf3510c18776248fbb9f9330ce148b4e4158cfb4ac452a843053e9c7140fd3e4100dc8d2f5c84874a9bdc24e676bcbe6d0e8e8040af3ef339022185cf92fd0547829c3ae4bb06fe270c1d03b7402fa3c733c74dc8fba37baa5f395588756d1c0e9b73487b4ec6ab6dfafaf9a9737c2d1a69a0955e2a7190f45b1f881da8df7d8e32fbf4842dd83f44d6546b6e887539922d6e1154251c9e13e9ab8c68eb58ea87d92f5dd52669774aa1cdde01fd9330dececfbae796f9fe63af13398e3d044c0549337ba1930c16d233318b9bd4763d66b5d4b2711cb907624faca3092effbd3219643e22316cae2eec1e4e3a53174baedc99a0d10f935e86ba5515238b5f7e2c39ab3b29d06984a7df0119440bb22c758e915397d63f13dba67c551cb0f013959de1d363aa167a42c6a2788866e0e50eee9685c1d500b3ec940ed79f23ba5e43671abeb59525aeec58946ce0728662423b6b5c8b7f06b0a2ef40ae7939086f923afe1aa9615c487d7e68b57e053699ff55e0940a394505146e522e9b23949c6828d41abd1a3167b65ba2d5e17d194f056ef2c021de894e975e178d3d15cfa24647e4e50cef78d7f2b594382fc2af4898b17ac72c6cb118f9ec872a5dd5d0b37c7fc4a48f041863c44d257484d44567e5bfdd55b75a1d6eba410e1201889a88d02a8071194259542a69d0fbee120565d2b9700e4a7297618b0a277a6760c5335b0d317786872c693598f2429b90553d2098c8c7207f5bf3698ed483911c6c96e570014ff95c5d0ad665f3ba3a89a7507b9aea71c35d1559eadfd56c648a581d8997324ae5f464d190bcb96e58515d8a60050c7e1864cc589a45c79dbd4c09000ff1b2f32cde4c5eaa5a6164a2f7b7d4ebec89d030e0ec8eda386dbdefca9476ed7fd92c60db52ee0d84c000727e893962f05c897675d95102b3f568703ce6e37ad8d309ad4635fc2fab48c1330c6a6857139e4a2b777a9f3cb8478bb322797a322ef94b263eb27e846421f0ba213f9f1a115e986ea6eb0016d38b59edf069473923f42bf2587c570bb58f2ea7a1d1d3ef69ce7ca7681db93834a45b45089c3080810d59de57588f703e569c752673a7b9dcb82bf581c2c38f44368314d867362e5478ba0ab1d9938be0d48ab5f27f70556edfa8549c9edd55e374cbb45056c290ca2ed65c7405e06e8165d884d1c2697960cbef68aac1a7c05557ea5a585d37e0a6bf3a713b7f2da7e665dac860fcd7f8c930c649464c548857a26e21a761eec051f23f70f1bee1e06c0bf6498d6f3ec06c0038deb2d4e7d38c733873dab3e19e21c582b3d9867c6dcdba3de02a716d80d3e5d2e74557c9dccfa20f9a98c105155e2f17b306f809d25aab1f4adff62e0a1ea69fdcfac542ff1eed26738c9bc107f522d6b6693bafd5a808d5631e6d7ca422fbe2c05077916d8dff5df9a47f800c3e0cda9c2b7e66105ca90317b8d2fff9766a7b19daa72c798745d3fcb966397c2ecdb4f94940b542db673d8d972cb7ce99ba73ff76b18dc34d2a39469c697289e86b84648753cffb9c2433554762f665e7179cbaa61084e0cab73f8fc3e12d16e38c52481f494147bacc9cfd3411f92047971f0d33f039e9851e32d9634a201702cac2d13216becb5d5d82a6212816ab4493c8a8069dca8459770c087687aa4722e6f3447c310d1132eb153895987f5195635c2c6dfb02d411171e01b1bcecb681144de0cf54cb7fa186beddfc45c4572d056872e36bc4a9c0159888d83b929d2a685fad324e747d7d490553004388cce9be2db77453c82265cf72cfce7f025afdc6922ce50a6ed6980990687ba0b4f9cb41f54b014dd14a7fbaffde1a96a82ce5e58ea98d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
