<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c14b5db5aaf0b5dd27a579a5d9fe1148dba1f0f8cd85ac0fa9400d97ec556ee2ce0e4b3933bb066854b78507fc5752df50b98ca5c1d5534b08c1c03a4a9f0ce66589cd654b4abcf725bb6736fb0fba6cb117f8ba9daaee2c25b8e43cf418d0bb7b7d13762dd895e6cd4f32154b0d3720b579898d0be6019e32b36759fb71cd554ea9d0b49c7ec57b83788999ee8cde111618c9f94f75dfe02e8c45bcc3a2fee0361fed4834886fe075a9e1f16324076df54d44e6bdd22e222ca8d92ee5bda22d57d77b269d225de4ab11d13e1ad44e61e7aacf4a12b31d5aaf15e4aa4a9b8c103e9df083f1f2e75f529456e16a4d5b4f56b314e9a6266330782875672424e001acf53cc0843ebaf5079a7454dc6179d75d536ecbe6743677b9eec3c3758542f79c317a8e574295116062d147c758e8eb833092c7f2c5fc267207a7fdceaa5e65a41e7cbf86cc0a53d76e266aae77f11c0b21129334a39f0a01be513d2c298c82595941f8cbd7e260d9ea1ad6df44377235f7730b523aac79bee77472354bc1e4984781a9d5b04f85ee798ba15ddb5210b7cab977c28839cbf76db3457055063e81ca05dd696f7d122c12b3a6d4be24cef18884b390688a693c2292ba0a2162e36a8623815fe95b0b53256b405612721d13fe8c7d647d1b45b2e1a665dfa2200305a81a304f8eb7c336cadc0ad115783af6b7c0952fa3b5fcebde3a38b78bda6bd3d2709811530fddf74d13ed1b2b842d4ce32ce79e12e6e4ede72636560e6b27bd49d8f3532e5cb4e755616de24e832c378de3213b4e7d46c1c00f8c17559863e20ebf389299dd7775b1c924d981ded7d7bc3b3dfee1feedbb39e14e3c514f1c02f509ca2c05de28bdaeaf38c2639e4ed5754a09df5f5276893e663314859e8c224a30b91be92a170d7ef3180d2ed9b6c53db90a8f441cc3887fdbd8f1b10f2d32a1b987b9de00dc0a342a4028281e55a7f24c357299a95199a6e9f5cf1b79319cf5b4cc7e977cbb35ec364183d5102d0f7426affcce9ebf73582f25f7801901fcdad1b7fbc9d7cbfe27c5dc5e0a74b57a5dc2337f880117ec6fb65258c2ae6bb3f56c2d664074e9efab8e0081d2aea311bb7ba5e9f1e0d60b6b35dc9bf3fa228f1a98844e9f6410a9f7b5fd3ef1c00879e9056dd28439ca5d1a6bc7a6771126874820301399d1a238aa6946f092449d45669f3f71099c64a43de2f7dd2e6b0b25b61c446592e00f624185bc95ea46c5a426e9d7db1572e028fcedcc6c01e7f3d33426a9c6f656ad4343599073df1926b7fdd44f833b131545e3dc3c3f534b2f835bac6ab8a4a12ef7bf660d656c932cb0b4444bba1520a5bb31d2bcdca9d2db67718533e4942a26c3015d27597c0b1bf79951ae7dbe593540ba9a385d946ab3c6820737c04bb8e422a4cb55a884b07feca3b69f9bf5400c5d0510a1a9a8cd0e5e3e393c465fdf53b5d0b531eff658c150925ca8a0172c039704db6f27b18a66dd481bbb8ed1a39bd5e9cf0f3452cf6ceda1da09c8c776e6878214edf865e77eca168b12c5083aed376cdd3fe9967264b2c392a913997ecc8cc8d2568871f3133a211c61c2b2d121e18a9b903df076dfade84b783360fbf832b9130846f02b4dc9911987faf76fbcf8c61d41865631df3d1214483f38ab74272450e002c9d49a024db94e7e0ea19fdb2c3c812e208db2370ac1acba03ce4336394c3a9ca5d452900fc079a69770acc191bfac50ecbd9caaacbbf0c9cb521d139f0339df23c0080fc0bf0b56c60212c500a8646009d9c9a34d38b7ab8950434caa115a9ab218a2f895b790e6c7d496d33a02fd4b651a9d8ff764a79d7a978b0a7d099cc89a7ce4769c7c2000fd8c3f4c6d4ff425140287957009ffe4eb55189ad8d834677b2df02693733a52c911c07770237a38003f81c68310b52b34204a822746788fb77ebd207c8610e395b04afd93c8900171cf8fef65996f8ee51b3d5103a273bb0304b3132c6d4065f3e2fe03cf302260f050395b901dc70bfc9be264f0e725d0893956bd4c4520a846fb91fdf4cb5b965ebac1652eb1de0d4bf7d309e93807f579e84e5c8195ced4ede5be803b3a16606fabc76e121a5e6406cb16bee3010d66bc62d9f116748fd255b77c413b14167c51d0db7d9fe8ab2de0ea56d08379935b12320482726e040c342d1c213b58b51f1d1e167aca47f14244806a9adae5e3481924c219abc10b821935c2da47d38bf74f2062001896a35679951bff5290b1ce44c53e267dd14942cdf8ec4a89b9fe0257d809a6502a3b98a69861ff607027c116808ceedb5b600efe430dc77b006492646d30e6b235fc249f4a7a01f77240850d977f5e576b1d89719cd1d2af007a6f3719b216ddf2f1895bbb144a9797edf31699a43e88bdcb3836f72e6d3531ab971d25652035b03c1390bc07bb7e57eba8ad93595402fdd3c546127b1169e7c12a529531dcfa568b8884a344bf2332d089dbff859b2635266d351abf20e481cc4ef73cce3a13f0a6ea8e30e18c64cd7b5d2b99568d0d505bb4cb5a6f51ec5c577fa0a5149f0a1fa5985052e8be5c5453cdab320b9fb2e1d034b86591144ab93732e97f08242b7d294ce92e38fe0725f3f107d73a9d103d2e620f57fc10a37d840340d078df909ae0ad6e89e76e1e81b2ef25c5c5d73fb33128bdd93cd593a15c6e2cfd8c1289b48d801222658c056720bcb02250464c0507eaee2cfae3d6ca6e7173a56b6741f5276aa46425a05942a7209bcf186212f3c7ad786cf44ae9f8093807e965213cf62c171e6b8c92b6003c1f957132c0652cc6245dc1afdb4b1125bdb340b583cfabc20ae9ef609ec2c2f937e77e12934fc41d969b14054cb27d9ba3d4af20914072af6d76f8086539b3375cf9c71dc16e2fc9f3f6332c181cf6d7a54548b7f8648165bc904c526d7d46f8eaf6dabd42dfd78018092eb69f9a9f2f575c1d92b02c9079e9be6a55b614a0bd0f5398cd3d660b5882f11f47903f3f083096784ebd47159417da83f69946ca193cd62bdbe93faabe90d0a01d276e3659052c33b36fcf9e3e220129411f214e0e44b4fad9d720867cc1da3b5bd83b55ac8a50817b28061c783715e77ac4ba2e3a6d2077acc72b0072d918ccbac5cb6999be52250b35ce95bbbe1ed87a700a4eb5467d756b7110c5ec579739c3e24cc6c8ed98f51ba2fb3e9b8dbf690920a8c2898173c9308029d988dad8a3ba0605ac2213e4fc4075cfb1507a2f615db6f45c9c116e7c7a451e050f09b71000fb4e76db45c244b735c213770b9a94fb2f39c0358b209687c19f25126b3e53b2c7737ee74197f37c90c222e43018089b4d23b9e6075e6034369d9d08c8a6c35d1dac685bbdcde7c620dd084e4009c076a91c506a53f761890ea55cc18152c82a34c712d39b5f4ad436c6fc6c017233eed0a03e3cf2aa5919b22ea8ab9dec284d50ac71e0006eaf8672dd4b9aafc5196b5e1fa7044d18dacc4b46331263e1863b50a318ce91586c718b58f045ceee2d9f3699cc19f790c8ad215c846905d2da28f4e2e4a4e18bf74d207d51f897de4dfbabec4365948cc5345b190ea16a21b1a96b89497f548f91e1995100cdacec42cb32f1b7d63b021122fb1f589f4fd05561cca795e0d1b6602d9a84e424ab22444889539c97bc378e5808ab5b4796e5ec6176746f335f80ea205e51bba08bff74422b1b955bd435610c06976d4db45ba5bc8684d655db95efd6d57b6a31d093ecbad441280407a776fee64625ca6bc9a4fc2d8c461d5dcaa7b65f179dd42ebd0d8b8b1a08203b1fd401053a9df7f701e0e265dab2ff07df5ba439e4ee591f04c6ef3644956d792529410b66f7322703e0cf2a17150e1734edff43e696ca35efccd63b497e5f014486b9f03dbc1d0d406e626a72caa27f8ee2bd74c553bfed8f5c90e1f1a2166937821479cd19bcbe748a2b547b38d1b2fd98546d174a7dd3af607bd2d0e1b826f1e8d33885a849a4ac8c3de8a33c0def9d0db19a8e0cebcbf8953d03d5a77bf8e34c94c09ce817a27c972d638b46602492231e047382fe026736e75bdd4ae572ef76911ae09df0498961438a4dd79f24614b11f712b36700739cff5e8aee3028667b776becf210ccb3561da1afe06b2b4aa050641707f560570e3e7bca321f397083ed33f12dfab31c74512751838db41fd10561750edebab78964a89644a1e9ee80b896ca1e536c3299fa3e9d590c5e26bef1bf3dc3b8779f86d20c6c609e46ea38b84f85d75d10f4829bb1b09547336dd7c21852ba96e1e2dda97d1969fd775d02e035e999dd3e5763736e01a3dd6b4d6a0f01e5cb4ad95ea794c4de6ebce99acee2adbaafc5f32e3698692a692d9d31df1c0fe87510bbe460df97040920357cd11a1939de4736b2f84ee49c14682207b590355d6bee09322289f5f79b0cfadb7af6d4a574368a0826b0a704198e3ab281275309aacfa059618dbe01af12bcce0de03b7346f670f4e1c2e81cb316500da517f59fda371be5c0507f98903e02b43d0fc6c879c65f1da6534ee488b2b1ccaa908c7af60ecb10ea2139864e4723b762e74c0df61fa61fd0aa936d137251c26f332f18fb408a928ebd3c3b9efe110e0fdb3219ae141eaf717cbaae5ccaff9ecfc9fb27f32e58afadec461b5a3c1bddb73a232622421049bb2c02cb09421d8534f83dec7bac0ceda53d5cad958019e4ecdbeb253ddfd5829e6476dc26ee69e37bd747c33101e645984b7c156c0080126d1620928f59371e9c91d25a51195f92c470ad4616932af06f51f8a0ba1111df107f699f7f9d6b23da3babee0b407bf71ab1fa3b2cb1f2f3f4a417c8d755538ab44c38ff41aabb4c04a715a6cf922efa3c08a1d946142c696939454e51f1fde0fa302aa6bcad4af00224c6611acb3a273f8672411a2cb8e0739ebe56f8237dc76b60ab6fb26ded4f1549a58896a11487ab0038e80d913c2e7a1c5a3f54fe698f65522d992afa01c388718111edf055080e69ecdde29a8bf0b52e65f7dc9dfea9e8cc7583aa85e1f74fe5d32ecf324c3d62dd719ab4a6f0042d97c7f527432d0868bbe1c045d92a937645c0723f668a9ad6514eadfe7fbfec11e30351ced136d15482c05839734e4eb8c70c4f497b03e15e988560b946d596a210353bd762cd45c28db048e0f3976227542b0d54cb48a3f88409a4c5701878cde93c404a32d24fa3d6a53b6604681fa0a924281feb9e8470e500434c0dd28fe49a243b9f62722aaa8055d3bb5f750f132a6e79bfb553df462e7cca90badfe490489ff3017280e006758e87b54cb50827f449f01bc55ac5b8a141717c6c8205b6de62a26338c4148ff4f1a621b79c0b73d8fe070009f7a3c415402a1e9a7cf08771f1149676c934995909158d763ddcabd650df2d9c1fd23ef80c68e609e54a778c45c12581e099ab62cd9045ed73440b30257776fb5717f7cbc523eba2098c500a5bbdfef6612919d3b45b64c52a4e9aeba3c474bc79e752f06e1f34218ff197c78c69b93f623748f45a19473349ba23320836c4441412f8a4b85b5687372bfbbdecb765c6fe654e100ba26193bfca43dd14e6b23c411ea7b8f38d2cc1c25edec028e42d903ef5288c5a0296053c7d8df296a1156be3f68bb504d0bbc6b00dccd2e190b951482b954570d166e43d72e8e842c74c144891756a8e94f5e307d19db1b2666e38550f82efefbcb7533f8120b423ac58f7976a4b601065fb8a7ef9e94a3e845e8c6215c4a2ef33b3784e79240cd2e5faf14ae7bbf5c03a55862d676027836bb9f255702bf8b7a8748273a28b19d89d1078e8d4e4c79160be60f58bb06e46fa2032c32d34c76226099865eaf96697d77c508f75d0715fa5838872f92e212f2a052f6ce2c2ec4b2a1e4f0442fac57483a532a77a5e6b22493c71c28c1ae35bacc2cdf99693861cf8b8bc0fca36f61ecf72dd228942c0362666a04badda4c0726e8590b249ae726a16582536195c7dc97a05868d43762b4f0b74c5ea09e0f2929fcd02451efb31924a2447ff922c09e6968ceb7a7bb09211c1f76a8dd30c5d11ab6939e1cdaabc2042fe0dec247011290fd8a8f8be9ac67d15a561c5205a586da0216c6bf141b087509de6eadf3c4777d901e2757aad979b5456e560a2e7ed7f17668726739c81cb925bea3149c311a07f56ab40a8f7e0e60a6c6761e1d2544f606ee20bdb6a568df852114575c65bda0d4eddcc323a3aaf407e1bbb750774d210ab541265fec7b51ef92bc2bf14f5e6668e9daa6f552a5aca9a0ad1eecd067624982a8e4aafd3ea4b3800caf91f9bbe6a923f1e1d84bd90d05047b34a167623a26260eea7cf68597999638e77e584d42f4d02fbd8c47f4acd3f5d919d1b145daeeb685e1ca3ab72a6beac3877470bd3f0e726b8c2c81e0cfa6ea20d2ec7c111c424a0fda381558f88db7590e3195813743dacf441790ee0abb37ad9df8a2194351c5ff8c955fcab43e11e60f79c4e5546bb47f6f84b382ec52f7cad75c9ddde218d87fbe95b7aa900347a884a8eb33c1c1e78a9428821708af94deb2049e86df226667e9f266ca28996d05beebc4d190429793c8bfde1b26c5b2a0000cfa63e4253386359058308619bb891490bd5897ce6ff2485f5a3f560f52281a11cfd2905098bf4639a12a174d5887287b1c11bfb2e1f9ccba56fdc8a779da9b43b58036dcf370e8704834f2a6e89718e4df8d3a505b234eaeb65853b0fd4dc0960ed8096bdbeaa5dbbf97d2a168d8b596de40084aef257660b24361e5a50944f82318a322f08bf5cb33411cd4063c5e05d56f815b0f25e376a79c218f0731f96acac534f6ff11441bfeb61ad6ee3d5303064c89a7671c55ab18d730f5657c9fd650fa33f224d86985fc4b61fe8d7ca3c9f92675c247c0d02f541bb9c26d4ccd621afa784f3122840678cfbc48b74285787088029a29bf5b0a96ed0326506fb6fed6b4d7f927a586f62b547551b26c67c49ecfa15fbe61a3065be1d063fc8f32d4c77689b44c9f06db23cc13ebb9ec8c352cc938481bf9bbff0c082ec64877b92141dfe1c1166a0d2ce5e3a420b4b851de81025d237c7076ffae3d2f38648eaba79d3b7e10e408c1144fa51d15a43d6297bb0955125d80e4db46df2f5d9a8b5983969223145ebc47fce925dfa2e38b08d9ffe60c8d44a2c01296a88d95b5e0443dec4fababd8941dd543a9493edf063f23c9724c39f219a7709bfc90ff7fa30c344dbf16f476104581d43b7bd30057856d57be252770a554c04b636f12064d068d7871d881d32a3383cee5467160e2b3c3c5b89a172f65a10d99b3459fe72872b4b50bd14915627ff45a1047159467591c017159e1e9e6acaf7e7ffd72f9ceea25305cf913d6d68a4343558e5144db855a22d22ab303cf02f752f83a45479f90ce5ef9184b79c18094ef9f0f722f02dc98276871cff8c37598b08da3d9f4716eb2828d7bb69819475356102110fd8e95d7aba9c21152ef0a0934b69437d1fabd5333c755f099f6677a16b14d54ee18c38c7eb0c53d32e2823600537802863361c7794cdd282c882e736b9faa9ecc934c49075312b80945d60fd76e565fa88dfce7047ce64acf17eb42b06c71b9fa1071b77176e779cbab2f2f92c544c637abb5e834517ff44a44c062cd9f7e319930cc2e20296a46e24f8c862327c1f7c9ca40dbe0182e0d22eda18b32e8d0cc2c8197430a3ac8eb8308ae68880d72c9d6a838e01b0de8743eebecce858e2031eff485e5d18928a18248f8b978bf14bdc35ee32240e5c32f233f499f43c8101ea0921cb36b7017f1c469e931d8955dcb37819017e68fd1ea4b11beec5d81fe03b53f72bcfb9ee284a93f69eb96b6ad91921e4556ce168a43f0082a3e73e62045f30883f351f3e2b107ac5ecaa1267b947ce096ed292c095f771e6bc6f0c496b3c1e2e241df2275b1993069467bc1c97ddc2172fd424ecb1f88935feb98252327e86f7de1000e2eac0d179d1259881387cab2663a80c4d810a4f7989434a05d2f50ff96a5d730ab7f881d895c39e3ab6e90309d87b76d17fd316842161d7994463441719e59bb903ab5c48b8f3e5ebe8c7e22631b6f536a86676c0802de2db59a7b11796a485ea6cbf5cb010c7a6743d01cdc65c032558caefb6145a6b63e256062c4beb74c135c33563a1db0349db87ae104ec081cfb26003db28b5420e1cc1a3a5e9389de9be67c0e96a970d2088ca1b6972ea726d7b826edffc3c52cd028955d55f374c53b0e31c84de6a7cbce680a599338f1ccacffae0ba95a0b80eadd592c0615125ddac1abeca16e67d7f1e99eed0b999d7a2333fbb8eb828a85c514241cbd5f6f1c8ad3bbdeb455fb92eb45a58496eac2b31d6509fe1c5d0440eead2ea5cc1d4259ee00ce3371ba993b5664afb2203efb3304b2bb0d0c77ae20a3bcf151d3f29a49b09f4c62af58f717dcb56c744b33237471529d34505033ec49a51fb06128e4f220808cec0ff02d24d64ec070869e3db76d4fa195d956bfba8e20b748188d62f69a7f1af209195a310316872e99e8f334e0f8e75ff524c0779abb704725d534d76505fd276cd4f1ca2af032b17eacc343c6ef39b60560c9bf892373b533e5678b5e25e3d412dde67fe0253bd5b729630f61ce7ee9786c6bfc7103d08df26866ba19814637888d3abbffa6e5c9233ec6d2dbb80e4c005638ccad0ee23584cd7e613cf8df325e0a93bfd9810c1f1d310f8a43fb283975f71734c0b4f2e50252408ab12225652aa6d0bcbe8fa3f9376960ca69a5f2eb641455d1d0332098c3ef6eb4c15181c8477178c3753114a5d93edf5fb06ecc8c4ee72e4dbc298ffdd668597dfc57856a0189a43305175b54f8a329d8aebb64181ec0639f132585479ea0e173befb7112681c1e3a4f2405a1d0ef1a29aa711595f29ee9c0018cb6fecd8b2fd2a267a13dd8c4a664507b88fd542e920e0a99ca1f78c76433c9cd0e480e3bd6c0b1a5bc3d15dc686f0f751047db92c10ffdc22e17ed9e96f7954076944028f82b304d00069bf0dc9ace3caca090f31c33057a344288a5bfc62d246b4207ed0e44af8b304ce7b7f0f43d967d220c3d2b10b9f898eab31c884f9d3b220d13111d4263e7b04466bb8424e5199436e3858886adc79d162af3d8a6799ece84fd0a4deb6b10d0b661a59d0b97d52e583364bb0eef3f2b95ee8813abbd9cdbdf3066d005317f46cccdf0f599731edab317f5018f4eb8ee2e4b1cd46f128dce1c130b123feeb2c37af4f107bf7f21954b2f56cbc9719334b18c3a246ae054a968b2addd4d7debf620e9f4c8e246708d7046a961a82293f67138b6e51dbe5b476f593168f3b86952df475b9e92e92874f32a64ff8221378bcc859345e57209b9da441b8e39b23661bb8d9f46491f3dcc33cd408a21bf0019ad22e0ddf5dbb5a7eaccb650ac3ccfc507f2b06329b13184571e9b59613cbfb7b53f1aa9bceb8f2d46a6cb5cf611379341dfad04bb95356c198a005c22a941672f984d18d38e2e87183f6ad6780c4853f53e870954f4ae6febba8c58b89d16f65eef34816309d25c89adf506305fa54dd5f2d22c6fcd5d537c7a2b1cd452fd45ec01b3b726ea17f582ad0a71bc30987179f3a7530c524cd3f8f7bea4240239cde1ca6c81792d26bdefbe058929b7f8794795c40d57cd82d68b96dfa4a6736f2a2ada12f7abbb9e47a426c10d31ac2fb48216e119f2424217485b3ff04d4a878384824a59e8a8c6988c2ace0dba7cf354cbd32e39b362d5c6ff5daa4bd968ba181fd742d9f59d66cb9a7e82721f222c1c1c6973d2e99fd5264d7085c41cb8f93870bff08b839401729ac9cc3cf92577ac51a8bd09a9e2d05b023d18210442f5318a2792049c05c09e4b4eaa75b7e7641dd785a8ae5632a738cf7f0f7ce90bec95994bd7b51f5be5b77ca472c9bc1e64beab4d43d445eccb41f2a85a32007907d7bb955959840c53aada4d7da2da12aef2e501541bd3d77bebce35068a3a54230d20a53a43f3a15d82d1100418a0e2a2b7bf4c412c940374e7de6142bde2890ef91bd58948e4fd3db785e8d2799a2464692be55bec6e365440b3b5a79bb3f6716a96bcd2cf6b1ebd93cb93be9682c0641b88bc45f4e17e717ddc1031276997bd6ede6028e18e8929cc7698a6a26a66e0eb712029cb0b0c3693ef18086a375126f256cca00d30160d8e31fef60723153a5454393bc51f3c654fffe6b2eab4799bd739f9a3e7c3892df86756b3ebc3572c6c7a0a0b4c4692147e9464c6e5aa233744360494551d93a76b35abd8264939f76ab924539af1c551e2421783182e5338b4e4bf89525a661d214876ff5022b2a626964ae72a4a33e01e49a10285fbee72a1727bed59184b59fec1c7356c818dc73b3c7de5d0f48e72eb39717d351c2760ad81858589b259648c17b62cd2cfaec1533c92b3c5bf47f69a90cd3896355e28faefad876e574eb53363c3b6ca3a15405a30aae2d41744178bb29a6adc9b019b6fc0a5f48c26ebfd98ba164bc5220e0a7190c1dc85317708bd55a57888da0a59ce9d9d9eacd6770f7c69bc3bad60ef4c2cfc861445d4f7fce3f71c8ec4e6041eb5b9da3d3cfd0ab1419da6d73aa039c3833aa98ccb66dd8246f0f0945c04387e260af9434657320588ab4780770c2e28188a97cbf1f94e625c32eca1a9dd51182f6edb902b7f085893fc38b07a741f6513ab9563beb06d418383faa9f43ace7283ef2b2a4ea87b06a372e8a391a7f73dd8a0ffac9c958b05d63c6e357ce571bbe67786af786f21952e63fc9ae2f5d36487ba9e6be30ac62ef7a52bfc0cc4df0d1664a150bfec452e848dea8c5614f3b3e9b3ccd51a6e06ab5a36a4440ff4aca59e4f6441942d9caf83b90947df5f23e000c5762050e9fdd1b950aa1acefdfb15768a3b99f7e293044d18622283717cd7df08e65ad019e092ea6a6f2ea7e1be562b5156c4caead33fa6842fef57c79d9254b9edd3c039e256a78f02ce712517f38a8a608d1fece1d52f85c0072c661ee3358ee1cad5fa4164c5347fad8161c63dd37b899625ba8a9640c89f47fa929e4789ca94c003cb66ac1a1d05e2417604d01ced93389772881c0075a1b60b98b7f8b42e948aab107c09645005e7b7750b64b4a1350fb4a55603f8e979d4ff9ef1cac8c789608e4c023821f59ac1abdfd8381279a139e4c8d919e36486f05cdab0ac935593537e90cc1a80d2b8abf41ca2202afc2f109f3ad014789183256a800cb31f8204a9923cff6ed8badb573417b6e559bc22296bd69ca4ea5630edc5d13dc43f4ba0c5037e30a01af20cf93ec4b1329506d10a2fc139143fa186eccb78715be041990aaa9a7e07c423bf0e5d32bfa8aded5f26f4e1e6772bc9f51d99847d6cc3b373e31431af096344714201e5490d8155e9188e2a81e6f3792bf0745fa3b2e33bad41ac053a445ecf629dad7fb94f741a4302eeb578a6fd73870a0648908ff7f675b3f54937548b0721e6bb99990379969e4534fb9280cd47bd8237ff5de616111fc7d08c6a56c6ccdf755a990134a61d1c6cc3fcd2ef3077e4930dcd962f70f77939749ac1331190782cd96af942127c3acda1de182beea8b190cea987b29f05a479f9d729e3d72f4e22abc559f025319a921d6ef7fa753ceec1c174f3a19391456cb3830bfe32c7a3e0cc6c220eef38431334468e13ba8c9e89aa3c664554e9a04dc8dab4b0671b6c7c7501ea8f0e4b7f33718828d38f7dc7ffd4a82cb8bf5776895ca2feb510b674add7ded225ae4ec4dd8b34246e31806f46a71e0aae08f06dac40d411bf81ba3af0473a6c90e1edfae76894751c769e0bdfeb048ac8766b008b41c666df9a83faa54c99e0cc1232f75a83d90051aeef70ebca6d16539efd9071ce31046864c251d0cca116ac6bbf9d6a3c8e345bf3dd384c1d03851ea10033e86eab413517f9f45180c1842ce6f7f14828e21f25a0ce9107b591f0dd65e69aa9e7f4cb5b648e369774d5710f46e2d776ada7fce3938990435a5cde1c859b09f7a389527b4f3d21a45c3d799daea6669ca5dcb2ebb6259f4f48f477a1a0f43027f4631e198b79c9226d7b847b8a149c55df164c0a0152c7c53dc162b0b2d50c0f0d88defcd0e8204a6b85db5d6991c00de3523d120194d5851cb6b3332f325ba0473f52aee9a83414f432f92c728ce416e2f8ff3a733bcfe9d74165d4e0dcd12a1f5962f0596c205ab6e82e911e559a2f4ae9617b2061eec2883c793278f4fd1ebe639f0146b42f45b4ddfedfdf68955ca1b70be710a668ec258e5c111ef426c70eb6349a5abd97f1e47e34e6a24b4b5c66edc1430f0faa0755e9b2dc6d27ac796214715d42d76576680d06f93ff93ff93c622f793a82bc4ec17058fde9cc9cbb6624ce04a89c31430f1ceb85160e3fd3c5b1cda9400f29a0c75478df82ac98cc2d7ef0e5218b0fb8cd8ddb4ec2e939c8f1093fd4b9d2ba2501f4399314bdc9823c678619add3d8664c250f27f8f0d84f5d96fce4c99552985f81919a72196cf279ca82311d8afbc34278e725f101ad73ba63262d5ac7281c4e358144072a3b9d74691acb88a5ad8027604e717da189d50cfb2d51ee984627ca49c9956e7940db435041e5c2855fab278b7686b9782ac9497344d32cff9b1248ccc95b32e4823c7e96d0ef4c8a316f4b3c040766c844143807bb411f121df79f6b1b845f24fdd122c315e0be5fb1183e11a0e7529841b89bd12ea9debcf5cbddfe9d224135032e7254a0aa2804f5297a62b953a238cd4dc3d077376020887deb213ed3346c3c80bd8ec97bbf31e82f78d4481456aeab8f1ea88bed74b45f41066fbea0ec79dfdc57a00ddc9ee0b2a4d5026f7ae9a5a6f14e0e696e9605912918774755056262317a5be6547e423628fca789f414230b0e64ab6fe11afd9436d3a69a0441b249710bb9f33f010e34954ee8a9d22e42fa62ec748cd061fead90b2ec1ee9d82d0c530a5383bf38983c6cb2b73ad6c826f7e45df7668d4bbeacf11dbf25c42442856323c2de54a5e35198c2ae2ef0858d95c5369266f9a150f7c7be73f2ac8f4ed7971990e906ecbdc3c7a78c7b81894078b3a397e7b44bc7939cd9994321cef8a4e0600e3b17a7a6e24723059a3d643169629b3cec36d85fd191f608848dd8e28b071cde2053fefd82096c9ab31aef11b6589905a3af5c41cc0e1933cc29b69ad1aaee5ac18d96e1a349e51fb7df4b0b6e23227c534aebde6ffb3854e20ca6bf80c7d4573e7fea5c71b2ce2f6105a77b40580177c89596c82d3fa2264b4d36d9ad17bc53f3d239228b0e7a06d00d2733eb6611a74fa7a3e439da180ba868287d7b5b0d36705f963222d18b6a719abfdd93298c1a344d2ec61d6091055b1f2240bbc8ec432be45f0c13dcc52b58b1ffd69f805f9d4bf9121f93c562f749687142ab924ef3dec26a2c536d7f9a46c963f37a0279ea1d5be190c5c6e4d1801506e21759d8545eb249f75bca0399e7d8df68aacfa961a88b35630753e087d7576d35b77ac63f11851bfe455cf795fb4741da0f1d355472c399ffd9882162ff278f92fda566099c9cc8a572cc84246337b01137dee6d5058be710bdd2b3e247f0b2589d71e5c44bee81dc2c1a969be2edb05decec783ca3ba04b6ce2490cc371d12a1b8af60e5de8add466e032d1ccd0ef730e5ee60ad61e102de8b22c401061a09630ee8f58c13b34b5d1890797387d0265e325a0be597a3a5656e4f1bf6e88a2e1f2c88e7635abe856e9b0ba3053f5cf25f61e9099d92ebaa548759bb84092b72be27636f21b315d8a8d5f4085bd80e5fa5ac8657224a6287a988a7b61f3964518ad0a3ccfaf2376668d196d6bc429ec233cfed1140f3905477c391b54e847b9e6b21e19c85392c545b193888ab9159d978c156115b1699af7ecaaa85b68e45b6d8ae47e2ac4f161e10564ff8147ec504d0fc8a68d4695b5fd473652e5a2266329c8a4060f6d25a65899db7d82d006e828fe5145efab14e9174ee585005eccc7e9db247b3363241010774a8bcd43659f91613fb5160f9f2b8d1551aa4017d46b30f8428734362f56280698e4a9727523d43cadd7a9d505264a810f25b4542c8d3ed6537b60eb123001e5129456f088837924f8df957b5bbb09a3255874fe4a31b65c7e4e9e76e161e6e479ca35f87d209d5c84eeb771badfc0705c9b69eb18b8829dbda24193ab3faea711c3d51ac2a7605d8ccd74e67bf48acba90685fc54b7d2ee84b7978087522f0d38842657c1b51a87c1fc650a67fe171277c1e4876b74af4e6437ba0b25e0a72df080108e1553d9a1b2af2d4bb28baf7ac1ad40e328a0772348e536178cf9427e8757beee30a6844bff5eb06024a97bc26b37f08a8d46647e41a65c6403cf9d31e2e0c8a53891d69bbff8e914807542e24020e43907f6859319fd33501176d99d90db2a21350a8190d813d26e73a1d9cc39babaf548a24f5f3e2895e4305b583d48a5db355a19dcd9a81b2b2312beb7283b1786eec99f2ce27c9c9585b206c8fd3a9177e1d123be438572c9b89aca30d6acb71225069407615b758dd7ef24863c0dda5a151377f3b5767feec5b54fb99811b125dd3ecd78c83af47389badac20f05faf8142c8cb8050d45153f162d72d924dc6a72de017c5c0df75c5c200cd5a209e6ce1dc348b2a9a3bed558341b97b94507fbd0968a2225e6cf77d96be3c0e37265880923da740dac9d466bfd656346466b0939a9de99fee8f5c9d8c5a78266e41fd75859cb14103b908474687a0d4be41a630e614c4398fdf156f4c2d9b0db7192a13646e6202a6d77185881ae85f0ac85fecb0d9d4fd092364113dca0ef2ba462a9d85e409ea2d8b0df79a9bec7010c0d49d17b2bed74ba8391b2dc2e6e6ea4f17f4ead69af08d74b301813ea941de050cfae2bb354f210a8358851e20d6e0f52b6429965cd5ca65f0389aa5444d027853b67e58e63d0ca98c0e4d52ecfb531df970858948d8c2138a5557e88a39e8fd5be6a27b1c91e62994367f6acd20f467255cf9b201674ea50545d5653b728374ddee70184132c34f4db27d1ff23333f5906307535004fd1ae4bd953d594ee80432ba3ed6601ec9e14b1e4063ad977d0dd5775b6ed2a5be22ae4d834a1b5cd60c6bfa1c5e9dc1927b7e85eb9402df36683af721543b6b6b3fe34909b1dd8d5a119af6df442df1f8cbe3c597e1ec69aba9dd095de709aa8200af9925be49e68911b75ca949b79cf2eaa55449871ff5b6a50b47550d3c09165f6b25d1ba25c606fe4d811b3b567cd0e286461fa7bf0a1ea4b53b50180a976f9d13ef4c4ecba983844e0bd3c8f16f4a5371fc754b178bee54f39acddedb857c20d30bce5ddcfe14205f47375c67daca2918adcdccb3a248e61e37da72235c4363f0446290dd611fa045936a5e2fe52bee0f916296c2b7cf5a4beb0b3c63519dcf41f640109cd2126686c76273f62fd3e4610091ddbd308408286e561432ce191e730d8576fb0fd7b4d2010787007202ac842bfafcd75ce732b68582f3ca3bc97c345176ea31b5497e141e3eacd52c5a592b81b7409eb1175027c5b1bb6ffcd4ad4ca2b604b873b81fb95301587b513e51cf3b84cbc4a5bed49d724a3a700ae2d04d54afc46577f36bd3d91a3f420801bb05fc172957efbce70a6c40bb53b7b33852f067efcc86b9d48b88e6fd020e7000c4bbdcf983a32542cbca23e11eb50da4dfb72a54a1ea87103fde170ac713b665879f5aaf131e50332ee48e2700193356d5a826c6cded3827b8792d4a6f2125a90becc0cee3f8b034ed40be1196f84198fba1c953905f29baa5cf3bb95d6a1441ffd4599d61ee9b6910251fba65de9af7077b706faecf45967b06d7ad013c0e63969acefbf265df10e622d3505c7e1994ef1958172cdb1e22253d5c3ed2782b34dffdf828506c8b1753f10e667dbba52a5141e745f4f346201bc16f8edacd83374997a8965d6fbfa514d51970227e60a7c937f3b9719eea1eab483d1dce667ec87298a272cb72ed16c03273b451137c3a38e6315e07e6a9c216f2f5961eccf276bd26909ed9d56aae56b92594bc63a851ad350a149d8a9867024312bea3de340d065f616eac9af2900c91175daf24245d801a4f11d8761895df5a19dc749594c68b97d26fbde36227d85490b74d7fdbd0734d52eb055b0d5e0307c14e9889c0bb17b6d60face24ca0ff87f4ad3070a9a5adc0ff61aeec58027dc007631687b35703b3e876192631feecb2836574906234898eb95c334ce55e729c39d6207bb6d00de03b38fab91f1ce3a4d85f843544667f0ea8eeaba3c03de140ebe3b670620f02b43bf80c201069a5117f69d223cdcaefd2d325ae4497ee2d743c4b66e673bffacd872149bb5034900d67a916611952b7d8db6b60aed20ff0876248338d1939c35a93e88d8d60fbe850b1ef47d84d9f109739fe4552ae14dfcf74e3baeea74c5b1ebba9a034df4ef2631bea95500893eac50ed4f0f080d6a070e71519b901a08b920480a276ef09acbf16585d8591d4ef6044b8f2c6d086296dfb856820e0ed5c0dc6e11186acc4d4556b1e3d2ee198d07649414d940ed2be2b46197b50fa52333687c7a1343486985281945b16b46ac7a644bad82f041850ec81cfd0ffaf9d9feee9596d2f8840e3e91b24f14ddc24f979a90cf802f783a4321b6370b62ae461815a5cbe2191d80c5803cf2b99547a6fb7ee2e2cc43f42b7a184febb7ecc2c91b97f4721e5148985909824ebb460859df9e7210c51fca9aac60b874e5d36c4128b5f1c46d4224120a4bf5fbf3e3aa3556fee031f1e42f77cba304c2d4622a853497f083d1c7d268415a5403ca2fe899ae1e8a9f9764c2d638ed3924c669756f5c42dc50fa590ca7e0ace9cfb1bfd206603b9a3c21e483fd8def80201aaf2ce8bfe6225bcab4e38c72836659e906b2d69ac1491d4e2f3dad6df7d854e74b801d4dd2637f89bf4c04c2a765858bf4dd99948e1515545115b8c4fbb7af7bbd763f3237699f2adbf9bd3e50383e4c9c4cf1fe1990f56eeda3014df75194b0c8625a762b298c54e692b0d69c818788a8e094783bdaad3e178de8e5bb5dd75531fe8e5a351325e51c626ef5de02e226c8c4536579fde1d33dee0810c5805400e0657386a4d6e6428a1c772e10173053d13d2a9a7d7df96938b17e5324b463b68bf11181b2cc27145056ce47a431c8b3842ce8b38c8a912bde3236d67ec2f3a88611d2696cea325a6e8e284de04035e174a7b1bb61340fe356fafbf1ff06d2ac821e27d0e0b4ae68abb69fdc6330d9c53082e845d02f85612d26e046a3d0c9c33b29857a50eeb86f1d79bc8c05c1e24c5a385698b63764ab4042b238bef95239875d2ba7b44541aed108ac81780cc281a8e6987f208da95b3b3c7117c8b7dd05c73ad7b9420b22ddbc18fc5e072530baf9283d9bc9be11dc3cc527d0d3aebf09240e32ebfc242cad2566dd2f9e0054f7cfcc269dc2e6649990c0170fd1eaf1fff94607b5ce2fddc91e9ad1ddcaccfe16087130b77d3c996fa1d5962991e3185581dae88adcfd75fec4c7580aa9afb178db3844b29f58425208681965179e58e2bfa0f9da255121d8dd4db0575758c38c8f582030c704fab7bf82e15600986e6dfbaa0e094dd8b9cb173f5d429656781eadbde9d12b1c50edac4b41c849a516891242f6df123314c652575c8584102c0291afdfa8ec07d68c565f30f0c2576cb1e462ed2c6a841c3df210734623d31abe8289c05e2ed3b3af37df95ee942163ccb53490c88f3279d4e81f54074f38e431f48cf571d93317963d8ac988e3c24e6b4f55633aafafabdcb7bfd12d325438920db11e3d42f05bcafe4625d42cae085cfb96c97904f128b3a86bc489c1a147aff06085d726f901b1f7dcb1849afa999c14f5345faa28622ecf0f83248825b2911f035b07dd81cdf1f523ab50c48f5e08bbefcd8517cfce3fe9d2867ab0fa73f137b9e06505fae8af54d4da27eb5ff06a427dce3700080aa064e33572f121aace5b10cef6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
