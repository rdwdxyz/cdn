<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"058a0c55ae15341b0f8af5b11ce41b400e682ebd8d702e6d07dca12873b7e65048e64e8babb0ac37ac6c29a0762d45a5a93ddf8a28cf5e7181b00cab7e18ef8707a7354f24acc231f76e7c81a6d37f476a8bd99d1c35884bd018548f0be14127a4007201c5d9f8e0611cab8fd681908926bcd77a1328688021b8cf68d65603625f4164a14f9c2c2b5bb46d1b62677ede4cfe554117409235a5629d902ffff818bfefe7dd7c550cd5c605fc17de10f41d023bd37479495d1b919f000be8af8a41d8a92eabf0d2223c4eb09a2a66bdf5b2dfdb86e0c2ff7a3e35d9af09230990518134399639770fcf7d3e1da5305caf88310f4930f39aef0ebe7e71606dd6898d7191c003b8b28d121765453af0a57b74e44d7d5c0eb62b42738b9c65abdcb1f402f1b083741ca6d9ad81fa10c004a7899bdf733d0380f24232ed6ff545ebc1fdab9e08a18cb0ecda1a8a66c858000cec4568b3e6dc61011c1519b94634ccceafe3a58e0e19eec9399e13b334f2a7591f454f54ddb4d6d21fa5605b4327fbed8291e93d132b73bc05e19de32cfa9d8aa2c4a837d3d4cba6fa994f1b057a78f4695670a3fdf1e66746f09f7e5b7c448944907537da3ae021b287cd20ded1c3967bf70c90f118cd4693f26f4c76dc7db1d15b4a4ea12dbd82ef6e7ebef18dbe7e61321acb57a452b78b7f8eadb2bf51afe6106df596c0922841a49d2178d7e71190706a3a9c81e6d7dff02fc6191ae73d48d1df4ce09b1b2e8ae74796b99270122432a13e146b1df5b63eac183f31fa697b85c5c9756e9cf24e1d3364a980f2339885fa6107a2dc74bd258192634662cea6ca4371fb325be8578f8152b32915b84af52da49b5601341fd6c8a6aca121d55d6e320482ae81500a1c0370187e30876884f66a841b0f13fa07fcab2163e97e5ed8ef8175a74fc88539576caf2bca04cda8fe2c329f579405d18af07279346ab39c470f7f6bd2120326acad53a1ba8e8af125b2376b65029d4084ed413080b44ae496d1aa81cf5c03fda2fe8502550fc2ca72562c461d5d092fba95155f93b15b5e5a930946d8de60afd007d52e5052eadfa75352c3e4871e159979495ba85890df719ffab7c9819a2dc1a542801c06e6b2df9cd8a0ac886cc5888b5b71c7e62b61bff73911a45f4d0d69ea2a09e3b2ef75f6465383e6428d438a4486b0c157cebcc650bab83d28fb2c9e31434518626489c9f4479b6b1827128498977da4b846a31a30d937c9b66b5d6ed05c31d734f2c8afa7aed012107e0b7bd09116a9c1d4a502e864901329afc9ec29ee3f081bc5386d0860f497cd95dc0af8d70fd23b6bd53a1e0524b6c51a889ed46bc431e0c73a03ee23876a5e3a67ea4c022eb39424d9362ad4f5b900ffb5e4057cab3f8eefca6cc609ca7b3d18fe9674ac3e95b8b5a3a67850ba574e3942212ed99ee878ced90e707297d28978a70f01bdc6c2e8054b294ba6c125661353a133ad0cbe9ea9b74a93760e8ed4dca1be3849c9c2ea3914ea339c6d2570798a2b7de2c54c4115cacc080d39d993e7d6b2ad3ca63d63463a72de1be9db7d47e3a46d1f6971b45cc5e9378c1d2700e1d6fbe80a9bbcf569f0c21f984da061bc50e67f77cf618383b6584b8cea511604c04f34a1f9ea1efbd6c791313b9c61bf2f835a4d17eb627f1b3e287430e883b008ade570b2d532a95a15dc99ac66d54856b697a58cd1a3d0392e18819a6a7a7d10b7592a7d1529367718ad50688084ba217759341d55fc0abbb40bc3a8a82b5f14b568709755c3cf03ad9f6825fdae85cc7cdf9c4c1d118f9fee3e376104ee8337d4e16e8061da78ec6f8f143d3b65211212ffdcd7ce91c4cb74e2aac6ccf61231bf95cabd518555be1a4a0b3bcffafc37b6fbcc5d798ef84cc2ee6f6921244531674e5ce3704bad9c210cf3390f7f99820385e8ca1595e0db02e6355c5c25691a8b2f2d94365b2fe518cc944927a878deb3db533b5378f0b345a9d9d327b5fa1bc1f6b7e82fc697232c01dfb714dcbba1fe423326c9de6a02d1ff1beba892de36b40078d8e4bd4d6fc58d52cd4bde059db6859f341fdc7f7179322213eb68fbc89185056022894a01dcccb9ece1cd597355e307639811c2c8749ad2ec3d7681893d7c465b4c7ae37886907d9b596a0022fbe143c3e6793d7a4acebfb510cf6bc987d48a6ef11a7eb32364f3d4f2e077770cc247ed5b2e08809b81fae8881b9f168fbdf81091ef038503de7a20f746b4a66cc0e0210b57ea159b903132d9d45fd6d61f0a68b1bedde6dd064735bbcf230a1749f539379ceba83d2ab2662ab0456f3fdb8e9ffa7fb190b958055e86fbbc36613384d4d6b28f719254bb110a86b74b2fdbcc415a015c8885a28304ec5d958f8f3b51b9116d3d0a669986920bb6f8848df658f9ae44e65012af73879390137556423dbb7b29024403005a3bd0bbd412af3828a32e0ecc53866a0855ea921ab32bbc063808fdd6e293ea4fee8d63ef133d4f088a00a7cf3fd405297ad235cf6ac891e2431b1c83abaef8e8d87b7057ce4cd4e9348ad5adfbcc518979c4e14712de270ca30377a270172f0ac445a38fdfb9118f9a39763081e098a2ea346214b0ac9a9a20f94535f24d950f1f886d7540d5f37fbeba7fe5693906018b7a765b75f028a77ce8a213f469403ad4a5d8e7c8f15e9d0c6684518121331561e536c2462aeffa4d7ade0d5cd1418540bf2bc1aa481bdef716e9059a0964087e95de607742e4d3d57d3c18db0758f3f0db9e0a76be57fd9b17ae4453312006b96e480e5eaf81fc0a9beaa596b69879cb8fa16471ad1b914089cdd240bcb74dde6871e4c90e24d36c83ad40763333df3a094d2642f70036ebb6089de15857d2237b6a2a0cdadacf318bfd57980bacf241abd2412ff28c9a971ab7627c16fd7476d1820da9af52b0c49e0500e40e511a6e4c62bb668617736e8e62ca69293224bea6aa2dabbe5d64df29f186050aacfeffed13f44aaf68f7834b4ca4aefd4377affbd36590b42ebb28e930bb04b13cb1082832b3800830dadb7a8d3cbbdd3b4de6630e768dcc7b29bdcd21817ad6d23b69fc614cad4662087506eec3673cce729c7f2e1f0e8ad79aacb5cc555ea773c21e9fb8d3c94d9639ef9a7a89a0e078a621c7282c9039d6c95a552af2e26837905366299acb9c16e15ffa1d2681e1ac7d27bdcd95b72acdeb9aa038da2c52c81691e029121fe0fa436f268c5f618bb0116bb80c66b9eec3077120a2c5321f76934cce08933a4001ea2418431a7b8159028b2a39456fe60b5221d0f4e3684563806df82360cc5503e2fa014844eae021d9cd1a37016746405c5069c950881dce9c7959eced81313f4e2cb1f36b273dc70b724f55c25d2022e7178174fc030ca1367cccaa28e942e7f8229ee5a590b68c75172ba3b9fd57b2bd1da62518b5e9d6da9fe4d8a4b4c65cac13b5faead8e44e7691189fe5ffc7fc0d1e19c9e2051b4994fc8a64527efa71823edd289a70c8d4d46448d80267279a3684e0bcace8296e3a45a836882da8288b1c29571e6f8842583b34f2fe13f1b674c2ca83f7e8bec5558ea510c64d5cbf9b11591b1383782bddc908931f19a7d22e5a8bd2b5d9b03ca010d6eecc9e786fd0012a7f8b7430ce6dd38e82cc15546c9f03d5ec9c3009cd5b269788feba781935c8ac606ddab9f1a1f98df993e6b30023d887f25868c949266a1ee1d1898ba85e1bf67efe1cfaa221acb805caecd9e466e80a9a09d8c7143f5b28a8c9aa961cddd7e9b511930fc4f924eceb9862e382f19999cedc918e12e124508c52b4b1c96495b2bd77dd4d75abd43ef12ed3c44d916d312fa97b68787955c2649ae67479a38878979e4f44681275b5aeeb478149eb4b8cf34b5d92212e9b502ee1b78f641153bf8dd750e4f6330fd530aa2f03efdb36085cbf72be2326faf21e6e64f596f821ae09fc643f93534dfb84ce59382f6cc95b885dfdedbfcbd1ee4cae0fb043634272a379f165bf85fff857ef43acfafae9aac02f175c9b73b5cac9a69170b3d568e7cc211e8cfa9baa7f70af4af5a3fce2ca3db5c1b704f5513a1253b7a55440c4eb3bbe25cc7a39d48a252d20473e7c144adcf3397345c07f2a086b8ade3641c326c20ddc7dde4dcc780deb9ae808b0e869bd9581aeee71631a7125f921fa420aed87e1a15c5630796bca8454c5b9088131acad1a920538917eb31af6505ffe4bd77864330e590d0fcad5d91bc62913a28c0d5959054bd9f55e54090fc8a463cf52ef6a35e4ed4286b6f5f7a8399537204d6244a6550bf457141b771b9a79c30bd838cdcf2d295275d24c5130784ace8172fb14ccaa9a037631d5088828976fca8ce74a60cb60e309b81bd5a56c6385632b77bf767645c0632143f5d3196a04abc526d294c678b463ebe630d6bb9dbd10acf845cd77ded4f539c725be196bb3e56d7e912743e37310350be52cb0c3e339c00ec40a5ed10223488d10adcd5ac8adf7b4b17a12f4b197d776d663845b643cc1cd7940811b6a52c2b066f4d7da47a9878e2db2201fc90c249363960e82df298ff069d7772788040345fb898777c4d75b51f8e44c7c26301a03385ef1c27ea14f9c8abd3a0efbc9dd789eae91e6200b625f89935028fc54286fbf38b3ba7adc853a2982b798e892cc5858b710643eb7fd96447b725488a36bd4f7a1dfcd62d7c70d8c3ac202cfa85b725b2b12e3addeae668ff021ea5a6b4aa3b691e69a49b8584cfe038e881d69f90c96de615a990a000162f3a39ee2399a17bdd39c9ee10c618dd425662db0da85d67cf8d79ccf6333f2dda93b0ab0b45433c0783c1a0869a45ba64ad68fabfe95319145d7e685cd7e93bb59a887d4f29d95ea0bd1858eff2abab65ae64cf6f6aee33d7693ec40603fbeb06244303082597d97d952338aa56cff7891520d5527b666d12108260207f5dd2f590744dba8e82f1c4c35f732f5acd3b9dcb2da7658d7f687a2dc18b9941ff1347d45e916d8de19866bb4c1124909a9ad8365f1d93185bb1554d18bf0d0b00a72a8acfe45570e404d219d9bb855da63ad273861d3687f8065a19ebae936438ec93f26e11184d56771a598d868f362834ba5aead38a68ee93e7c359fc9c21bb28574af1826f725624102880fd89a4197b5bf0d66fd8e04183bb80001924349b492f9eb27f57537c06a25fd3f204fe36465c7e8e2295d57634e1dcf2057a7e52106e2acf5eed19cd3ca248a0e90fd21bbe929a52d1a1381170dafcd1d51886becc41130ffacf22352965ed24ee30f9b1e7e2b9689a858f5ee4c50643e4c5b55cf183c22aa50e6b4094fa300ad1faec107a4b2c0ba62e3da3eaec78ea73c04913e926eb17dc33d311bb69d9dde702f53476df81c11af35565c78be5712d7edd5451f39831cde0ee2af990503420d8d9abbd0b318fd26d94327adde0c29f52cc338ede699495553ba67a9e73b0ca2422d7afe6c17b84eb2705b7d4f50f9bc627c91d94eacb6b82e14ce32762e0fae8ef39361e5834334a6c31074737296e25dd2b21873816398dfa8dca1e77bc068b83bedda39f17e847d70b8359b9f48e2bbca97ccfe4018ac66689e23bbfed9229153d01a749c313566833c364557003fa54a6a29b0d9484fe01cd28c27513a4fe7293b8092844e965f94fa6acd25d139b27c0c54b5544c6831aa0025d8a558022fc6940cf5b87763c9bb49ed548090f7d8af90d11b9e80c57c9db5c26145bba49e382eeaa7e2771a243c9d5ef40f688af2481046fd0d95266fbf34734a8e9bba6e3bc850a27d811d3066eb7d1fb586de6eaeda65906a4ee62f04f4e4b1d1e77cc29412c1ec3b6e91b59055f9beb48cb988f3d845157d2e9fd1c9e717857f360fb3c8bb63d1d02b43ab792ef762b8f8cd5e6727c0515f3897841a4e2c04f1eb3c519d71877189f5c8fc13948dca22d0f6160a720667c4e3abcbbb7cde719e65c956d143eea035e122a4781a89b513fbb666ba7a06903600cf25dc23cb8d07d875ea36a140e1b75ee5c9a1657f0ab73c248e10c1df9230fd844381ba14261ace4bad23945d344bf92a7545116d875195597ae2356c9b4a6d5a6b28e821d9c57b953d24019140b49c92c56bbcfd9cd650309c9222f0748e815e3d01f5d3459404a2c3a9523c2662a782d85f9244e03f93e44193ea3b6bcc2ebdb2d0c3d8027f24e5b3151afcc5074034927f9e493b1e58bb1b7e05fbc0dcecce77a323fedd46baddf02522caf938150a784ed4b2edfd3ccaecc8cc4e08ef7fa08281afeda4a37d9c4c2dd109a31c5eb4f4f8c4910e3c5d7792fae2ddc59d7059f8fcbc3dbc638c1e2d886ab61a61eeb419ece3d63cb9129d88293d7cdf7f47dc439cfc67a6a4cb699012d6c706d5ba3e1adee8c545e2c76cad29b68f05ea83b99c18bf3a9c89f1941600761dea02c0b7ba54acb2006bf7a269495c3b9680efbf01522d687ffe0f9c659d81414afb72cd6cd58c493750ca929246e88f3bddc2800e5f6c3003af3d7b904acadb6956a1fa362aa688aeb1b90ee3ea27cd9dba313f2c97bb30754c2bcae0bb203a76bf318ef5846115e50da40e3cc45723e3d0d447baa0e7566e6a54d431c18ce47d28cb5b41ba74d6e52d40da6c22f105f3ec0656eee6736fba6c0dc83d5241c837dae737fd6d3b2ffb635bee0810787be7d4980cf33fee847a3751661c7fdc3d579a792c6ed08800296b278cd9ab047f149ec4f90afe57f10671ece05c25fb924b86acd7dcb4f35aaa4f996eab080904f3688b1acfb421edaea6657cdc0d02b79c651e1a67f29d58b5e98f68f9e12bd9dd585d48b854820f5586995e6328a67fcbbac9620e8e6a917b6eeffb5abc72f7e11e167fd532eeef6c3bf2370349f1f80f1ef0284e51e3de5b4072d78d077d872cc75367de4661f36743b07ff04e6debbd6bd6a5673e61aefad5d19eb9431e668b8e77131c969c588fc28b8f7c0ec2d33a7a1ddfe8079d6a1f1f5b1a8c5c8645a848650151fc408470a67c2ac207ea917b17c09fecac607b10d9df39e7b5d9f5b81e171ef6ad01819765a7c0704274a7a2b70c24d92a4996fabff1b6e437e0c7e8663f3f0234fcb3b73f91f149d74eb2b8c2f045bfada237081d3ada1ce0303f17eb599fba0ae4f6712d83ccfc4e21d432551a446ce71f52a6b7804b605080faf797081ba4eca18ab29195a0e70d300efb0d2047f939c0edaaaf44d36cdd9c7c0ad5f0148bf4f408a1107b19e813d498f7e040ea2463ee8e023d20f9f796a3f29ec7b3af04107aabf192ffa41753f5554409dfca1ce5843ca20d4e5590230249782cb3dc8adb2ec26f063214cb9fbc25f0f96e48c48a4205bad434506050cfc936e50e7a4bac2cc3120ab18141821d86cf486f697fbb647ab9b8e6e2dfea717504217f55324c88e2c0724318821e8445aa26fae611f57c0fc9040d756f11d472179eea8998f0b9439c623f00ea0635e65cdeb5973cb817807f16531a9467ee5034097a46a08c64e43054b56a2935b37bbd8b5d1d645743959765233d3219062e92937d28606be1d295b50944d5ad38c3ebcafa0861f1ab57496a226971113920d1b165b50d05c55b4885d0942b1e8f6f34d1f08a816426bd436466feb5fb60881dc8cfae428d1181736335b3d779a674059addb2cd2d781f1cc2d9a828fd4ba2f2aadf84a7d72b3b83a9b46757fc99d5c083d28aa4b438a957faf7402b712aef3a25a9992d76d27002d703d1f95f9dac4bd082e4c2044193ad529e06bc94fa455ddeff5292b9baa880fd882a5945aec49cf51deb5427fd27c1916ed5e29f55e731f3dcde52c80dbea5927eccbf5eefa86b6545928b54093e4668335e692694eb7b909ddc37558b541d5602f19163bbbc796564785704906624146355c71d71acaeff5025b3da46fd9b8612287b9fb9238be07af42b2f9e299a3aecce53fd90777196e6977d0edf017664cb65e8b01deff6702ae7cb04a0075b6e919199d7d32a3376ac5936e25a25cd550c7addb3cd6ecd2a26f4a2d3b92c64933f6e8c28a916b994913a2da09f21a1e5feebf6abc167fca0b61fc7c594c5dc0cb412455c14454107e1bb3092efcbdf49f6f302cdb617d12f7e4f2f82231444dac2dcce60616d6305d907734341f58a6f4902a93d6d4e9f48591e4624506130964a52025ddc38f6c11eae44d2bf8c89a701c9b393e21283cb3cd14a4828ca413d74cb6464c66d7ea9b57a0437bdb1b5d1656da0c3715cb488e80b10ce826df3439acebf22b6ea732880f3be1d70711705b03fd876a78a4e562f9d92aa7927cbc359d7315f90e47de134a8e893a99b21dc309ce26cdc4026171d5844e1dc9a4599c5028500b9fa638a8b7cfe9a107e9e44fb824e0e3a90f1b36c577d742cabcf09feb22f516d926a406d5315916b8742003f6fdbf2c37eaada509d5d71e78ed91a37c09190e887f5c2f6422b4f7237ca4eded6a8c700580c2600aaea35094b94fd91c9ede04bdcf358016ddd99310605a1ed73b1e3607ce11c70aace658c2d6f62dee17b5044cfc2137556913bca56300bee85e81bb77519540ef8e04baefebd3635739bea5f94019c81be0eb4dd5b04c0eac398eb704892f17d53cc89155bc4e913593a201c1523bca9598acbf8f7ff59677c65e6959cff1e05497c757517fe81e1b3062479836a8bd5680ceba1832f13140a858aa07606d9568c0899c9801497f06f827d13b9f7a4cc2ed0e1973a9548e1298ce9e45803c2ecabd4d9e10b45ba025e05db4ae36f97099c829cd0970349084cf085d2673daa1f9b12f35391b1cfee3978ac5bf4b0db8eb7434a61967870658bc9153d332d90eb03eac69f19c68882fb16f5e6d35816172c08f0c9dc9f17e40414d5eed010a1a15eaf763a8ea2039d8e49cb87d44cdd2499465610b91e19e23e3e005a4f5948a1b5556283dd64c4c244229daa061c430a5e524c09d225f4f2ae2ea7aa5af82ff949457ae9b7f929f28112ba35c3cba3627766c272ecd8f92fe0bb0447d9c18c12907ddceaeb4409b1dfc737cb993bfebcba87288a1bf61bcf9110dc41d2c9686c74cb9365be17ae5b5bde5e1f87ac2882433f5b9b8c6d5db7478d6940e6329d280ae169e7d89c85220f8758a31d26783a620a8a5d28d75ca4a6d196139ddd1090f356f45c15038b3f44c9f40941f0927b1069e446bb2d83f50335b76abd7569ba0575acbcf4ae985c028c728fd95e25e4c8aa545edf6c01116e2c1a907b8c6da2c382ca13e94e0d5bd52b74426d21e30be11fd7ee5614071564e3449eafa0085084017f4dd06bab78ab61bd1faa5cc405018e9b4c47004ec9dde3a0761d39e1c7af5b79bbee409fd60629138eee72a72cffae5615bc0942442af96e27a5c3089db12727d3229d065da76c06a7e83cf7be12f7cab882498c0178966564b11a4fee9a7570af1d9207dddb89c900a785e820c552deed3a9f6a6ce988cfb55aed6009cd71533b1819eeeb0fcdc4dfabd25d7a5763d73bdda9f957697f313b48ee8ff4fbcbdec1d608e79c60714e20b618251a68c75ced199060a4cc06d0405d9d0ce83e00e5a16c018401a4c0a683ea58f8de7e22a7bd5fd8e992618fd51919b4330e4c4558b170cb2de129dd0e7995f8c59dad5c359ec5af1b0d48b17e0f8f8b1cb66b729447411e49f65eeabe50f9b2e3fe8e146313ef9f9579fd64d7b4625da883c9b64a633389a3aae84e117b9ddf9527ecc5f44f5b229d5379e29af7872b85cb1a2397a95e96f552cc8133f4ee7f00a4f40387119906018246d36c0d8b00e47ab7132030c36f0030bd37c711e498edf32a4b6f53e0449debfe912866e5afa48375d114e2ce473d4a4ece93eed9040720620b65fbfc1929784cdfa44d152759b40d17ee1c384d15726a18a2530d437af0933f9818c38d997f87afddc362409425d7ac132597ee25d5828ab1601bdefd09f10155449c4d6ea6c67cf1697e56ee5cbc5664295c38ed994e4e66ef676bebe7281e5f6f1519995f85927504c1afe1de057abbdc4e915e0c954ae660debf3c2c685a4208abf832e40ca5b7809d6b0c62f3832115cbdce928848ea417ff3e7f182b522ec35d3ba9e4d7152d63e1f12aa4c269d6099715b9b87e9eed685d413e23af269312190c536283982f5d2b812fe2d1effcc86114517ecbcce585140c0653848d54d659b257129370ed59d9069ad1ee1dd3440634e18a97cc9cbf18cd4ea448321c2f494c44fd9aa960dc334a949def595b7a81b25a7fc43357afa7b21df07149c9acb1d5fa88a14302cafb5dbbe4bdec13e6707b33d22e1eeb6f300bf24c3d353457a83111c55938467b993808df8987c8b975f0bd6ed023b33dd7f2c24281db109f09384863962e561e6dc76f7f77fc1ccfece1c79d845a61af839010a5e14497eb4b36c7018f696f45040121e86e6eb32b861c0a2479658ca1dfe66dedbcb125de9e58b0ab93130e84f75f44eccc96a64a5c0a9a4162bc3b1c3ca316c3c9b1c0d35100b2363c2abd3ea21f36c310aa237a3c7992ab63cc26b35895ac7ecbcf9e2313ed57f862b84ee22ddfadd4bc22b1bab4fda550f44f09035045cd20355fe2c9d97503c413330d0e8887c7ff2bba88734b33ba485b9c3f7a433edf39575e7aa2548553844d33e024c93553873e92ab25d778b19faeaa759f3ea500317eeef2bef353d1a94aed810d752bdbf5537fffd31036b3e3c9104991fd384d8cea8a5f4038baf7667fe469e7cd34816cdf6ff6f832b8f22fb560f02d5bb1b101d120af712aae36021cd90f600bbdbf13844b85d31473c6a78de67baaff596b369b34e17c789d957f24c3b96452bd28fcc01399bceae4120baa12fe72175e0981be165da02c98889808aec279e84f3fc9770b9cdbfe3a3512aa4abe6356ef64be4c490206e571b96fbc4a9b15e737c4d6784dbfabb5d782ff90bd640a9b05c0ddfef7266bcc92dae02ccaaf20004ee65b01ca246115c3d792ce12182616b509b5a9aa8cc9ae3601e598d7111b38e8cb004c8271414964ae3fb54ffaaf60d42a421f582213969793a8121f0d5bf52c7d5ab3f2984ef7918b28244eb552274ef5229b504a27895eff879be1ede1926e9c51afcbb9fd17634441d60b2859e9ff691e857bb55e6e98e7b6c2181605e6d22339cdb51790c834b041edf82cdaae921e13e9f43181df1b494021af5773c50d6c83c88c10d5872799df7b849d278dfd7867468d5d99fc23b3da2f43392b36353967530c189a1c0e24ffd0aba7f159580db58a2d2a9b1ec0ec57b5595fae2a576192c197244d8c7bcde5834b210976b5d5cee7d787b59cdd56219549a60e672eca4ff649e80e04cd37cc0b2b4d2fe9b0fe06ff8ea584e4597113099bd7bbc8bbffcd7e72ba2907cd5c4438022a78fc30d2364eb11d98836179b8bd9c62df9718ba5a9babca9a00e1b0c8674926355e18c7da6666eb2c6e0ff1220c5cb36eba1e6eaba8b04b2a4635a09fdd0bda752b2797a1f44dbbb18df9b8f2f718a0af7a8836a9773fc41f0974ed1f256e5f87e327546ec9533dbcd8cb0cb7a719ea47fcf72a66d13a8769fdbfbff8df4cc2a5906ebd029bf4d84573baacaf83b500e31b32750d409fb29a33f2825317e534b028d10f9d30cb621cd7fdd729c15a05b3614128b8b27a24c08df347ea1ce6a40be97e7b06af89b6b9989e080be4d297618637f13dbf368807333c5737c5fb3245b65f675fd59414241ff60e175deb07976a6c692912e3f43fe64ab3d7f204bed6deacdc849a75e7b0be6741a3744f58e92e19ed146f552fa91b2d5cda7d1ab1a0f33fda65edb5c405b966034f8c7884fc9ca1353d119772f3cf012374b9177cf2a13ded0fbc3ad1ac2ede256d147686f557ed616fff80d5d62034070d6cf0dce9043dbc30f9b4dda75c42893ec7d5febfb6cc4968906ccbb075297b48797ddec537c93fc12ee302d3bdc4b3f7f3c611b2c18d4f256d512e8b399f46590c56a23eac394e8e7d7d90aede2e7696522067dd8d57d0cd9330e74efd42a62ce80c6daa4abec1d478b1f28b5bdfdfe3e58139eb36a24fd9d78de29dfe1179e2cd2e3845b9371022e3744f5d4cde749daa72f9cbe227847960319b0a3eef2f9601a928c5bdde50637186a8c02d49b602dd7d4d981fba6c7905e7407063a77ea67b7b76f2a3fc3072fcb026d3a5eb6080a997d76c997fe83f0940db68ee66dcad0e95fa80fe1edaed1f3b0b69db7f82a7caf3512bab8161414ee451cd99da80a9940aaab7c21ef2eac6e28bdb82b5e96905eb07e85bf38f99950c97fdd037582478568160eb0bc821c80d6a9a1cabb9bc73f630a0bb0247e024dd781a56b32f5fdb49361971b1fc2d33a81e933aac83c3b4191ab55a3f40b3e9fa9cd314375b2d25f54d6afe375b53d51b0f3ef3cf0c329d4e25479f2b21c7df75238caab3910bbdc1f5407ef02b2f232646a3b1d0cd88ab9080b07fdeef4bee06c3e7e77acbc255b4c2f20b4ae93a6529da6fec25356841200b9061ee1b8f568f89df5d1b4d11b8a90a673446c8e530a096877c48b7146cbb4edc377848ffe82ba30d081e19b3419f3936d3656e035f492a2d6439c18097b10bf04a8eb344a56c62248b3d7383e0d2422afd5e089be608768d76b52dada1ba4fa7357a3a0c8afd0d880a810acccadf993be11b869b1773e68ce4e9b3dd9ffbafeee0bd94b66d89c04b072509fe171ea5dd7a3b7bb33f4cc525593ea4916c4f3a7d0599db104108bf61f9234ec14def45929587804fa8084e5fa02cb7e93263fd47446ddee7a9a899deca57988abb049fc9404a3fade7fed8792d74feb2170c9ec0e43712d2439b2e22390ea01deede7e0995659f299df615728054d7db74951c7c6f3804f59102c5b18131b15fa47111be5f46bc42882649070b22cf021c7de1bf410e1bd5d09f52a78868db8e217c927de504e80fd87e487a491660d7aee618d60ca35d8553be0e28c4c6cde683555061cebf0799f9ebdf15ce922dec9d7d729ebf035b9fb0cad5ea65deeaf1244579a9ffaaf243edf5eebea9b705be054339730d77bdfa66ae4ee0445c85cdc4684b21b64f1861b8399a22df7e3de955c41eaa91bb5f17457d11cef6b5c4e3a0e641ef8494ecd8062974f7dff7a3c39543c03f85ffd1fea73c2e68f7fb52531c4883c87f442777793cbcf61d588de5def065442a45c42b1a5c8dfac372123be8019777cb1499a2c66d4331563363dde93a498c9405f519d795a2e966b840c3ba8ff399242c3fb82c1369971cd4d63f0b09d9272981fa879dd26813b16a592abff3467a5017056637a31893d5e9ba78ddb10131d510c0f2a16ca827346a077c9ebe98e32596f31c39ee821531adf2d45e063c9e4453f21dd859d8670aa8907be7368eadba2d3512f3dc46d5412691996b0b0fd6e616310bd82ff22d1ca8021ebaccdc21c62cf3b9350d26b13b7c48392393fe746ba8213ab6a50d57e3ebf0ad2e741d823972cfc636a08ead90cd16be7773d81ea20ed5112ff3437c62b492e8a566e5b0d652c9dc02ef7a8fd9c2605e1873f892de5ec274bd899c5ddc0adc9c8e67fda9388f93940e299cfac53e17453b14ee08cd1d699146882b07f6ac41047c886e7a3e2c00a9fa57b202de370bfb506251183dfe7fb224edd8cd2afbb79017e710591515065599df19cd32cec3dcd7b618c339675fe58f6e02ffcd8afdc6ccead4b6f6371e61aca52d8bccbe5e09c01f95c70cf9545a9ba50b721fa7793e29a7cc263155d89beaf8e79d3059f5ee26330d02c51711ed390890b26f51f5a6c752039685350bbdd3f8e33f36c24d8fc51d61bd8b83a7045a33b05f64789b970dc62bbea652621f6ce441d4f6279e4782428829b066a6724c2439aecdbe0d006b9b9a8de67401b56e2f20b0402e8db46ed82bcdbb6bf28c9e66ff27f7eaadca7e56cc9bf952fb1cd6f2449ebd1e6586c300e37304c2fa4a8db0220026566fb12676adc3bf8ddccffac7c3dbcf709e2b1f52aec02ee86de2e55a0af31cb81348c2ef8146524a9a6bbe83f807db58811dd4bde00b1001668f400c2bc97ed69e60314df66c2ec5cc5f51991ca702ae5bedf940ae0784994d2f9f5e6875646f372b32e52a94aedf00a0d09ff82f1e66b5c7da15581e9276cf0b7ba168d14c949da720a8e992054a5027961670fa1e5f8f58e89da9ed1cf40f0dfffb638e5e37ab71f00c54134a74e552a38105869c82b9835da4a6ab317ff2086b02e51ed520f528b142f69f6925611a9a545d077f97ed22554a1b95b2b9dfd084cdb2cfcc2635eadfabe8c3dd07778173f3f53d546a265e0f785dc91465e588f87b1113fe7ef6aa2f53e69c4a602c77109dadcdfeea2369388a2d26872ab7bfa516735dc848098948d38a2a35deee91b7ffce2bbfd78a3e6d62102d87058e91fb02537d8af92b676d0cd234a2478519f3b10eef26d07dbe262998567c8c0a6ea3a1995bf1e4f812130ad5cbd534d35b0a93c47de83d7c1f488485b34dd7c393055acd0e088bd09c19a9d10c801c3eadc2776f6a7fac3d560a258d3ace17d784ec8be17ca6208bcf2b77dbcb40cecd86c9201704dca941a14d5b9441a6bb04a94e11addc4f05c73041e51fefc279d70550842f1db49883d71b7c5ad7d95828d36271cf9b7c7f88d362322319caeb3aa708ed8ba0be0c4cc1ed1a3cc946c3ec709aed2362a3b055b0dfa0b47662f55984a6d5a381ee96f43bb46169b9ddea0d085639e52c2e7e4c72eadbe7f4c49dfd7592d516233b111cff1ae93ea88421a94900f7a324ba24ca98a745cdf330bb3c019f350b94b48e2bdae03fd784ba67bcc0d38addc118f54cdd1cf29bc9e53fc618880616d53c48407126e9d15e36bcb9b8ea61bde1ed44bd83fda99a3b9cd89c45cb25980e6e96fefaecd5f3249faffe63602823d50781a2bf8b5d924b3b44791c7e6eb23737cef419a1307e2a97cdc616dc2dc053e74bc1e73b99d13c4b99f2a28d55592e081a2705dd567e44993bb2a13b1e26193c8fef297db094a6204df569ac205369dc23e8b99cc1c866b73c888afdd2105eabe16be3545826b43bb9c4190aad1d17d92e6510f955e8cc91a7bffaf62e1e848ce5f51ae5abc652aedeb7feb4c02f680b733ede6241c32b70ef62fb31958cb4220deb2092acae7f3862bc0466e4737f02eea00cedd8ebb8045bac5bdd88a9a824e0c98dd3b3501b0244afcfe1a4f3f0e8d05d9c5fc79004bd2fcb240e411a58941dcb5fe2311ff83bea1311cea56f3ea98be9a3b2761335f4c8376ca75e303d22dc913a6960658abffd7ce3842eba9ed57636b72615f54cc6571b102d7bd084f6f4f1bb03a6c41da8e8c2d2b5f1a0014b4e88e6b92f1472f88a94063dfcc8b7c51d387dfd2de054821f40c8c21ea28c88e5c5a5a2c70bc666ce741ee768e3fe08fa6b3fc283f434f744434a9868d92938b2f7167134e78dfcbaac2c2070e133437b584e024413fdbf01b2b2d410b7390a61a0f47dba59230a5f31ff34af39001917de3ab69173fc33755963e4e4670f2a89ad1f70b5cc6562d6861eb5a48cbcfa7542c242e6ad07d3e0615acc6eb1cf336fa53d546764469d5888086d7eabe80d3db83ee87626d2bd3a587b702ae12cb94fc9e5d39fe7ecf829a270f21b5cc88ced7edaa6389b8e31eb9b473a19a8db5295b2259632167f6dc936553f144d32bf4547140d292e90b6d5856cf8d22171ba292caa9c991fbdece3f0709026795d0dae23d22bbd3d5b0192ccf6420bc55f602fbb2e27d959e7b40c72b05293d3e73538f6dc9971a9a27b67a81a503c1fb6b4cd012bf6909976d8460ed2342f506235bed70532e9e9bee27336ba550dd3886ebd7098026d33d8f30d3d964bd1567dd80ea255ddad5ccfe79aafeeed45416596f013a70916c534b7ffcda224281748762929c67738ec8b37c924c634327a5ed15263f1f98a26bc9d2edbfe52134cbffb36598d43b91828aa540538d2949fb70bace676bddb9c82da8fe182928bb44faa2db0bbcd86b97d17dd6afc8163aab7c323ef286b7ec0368463c48776fa476e0e6f0cb0e9cffaef6c2cc1b2ca86443f2d1b165a66f47b39d25a26eae8a3b511ab6ee512f9c55212dee46d4d2a048579e7fe6943958828b6fc9378c0123428adb11a745ea424da71fb067b48f5570e860da8b7324d243a65b415a000e385d3cd9dc627568e1f0d8c6f8e3ed54775e0abc62310d3c3553545c325ae4b2a8d833223004a05f723f62f53d9456edcadcd396aa9caba863b897d3b999c30f120ff87d79f0a2e79fd965c65c34a3fe9504e70d4839de7275ba724a5d94864d4c4a7106aa6cb98345af2f13d93075192bd19c1835ad5955065855586978cc0fc69fdae568a3a3e43bc464b71a200a45ed1b561ce7eccab5abe8d0c1c63a44e417032081cbfa5b79341e95948b29d235f39ade7698786f36904b7f1e5cef01d1e81f26159ddf43ac758995bc88a2b3e7d443a941f121eef5e77c6537e639139149ba0c64ee56a586aa8b02aac337d9e7105da75307b6fe758e761c95a0992ab48eef7900bf9a7f9d5c3d8bc2b1f7d508fc6f2ec5919bf4ad6e2ea6bcffeb1de5356ffa39d44f2fa42a0ad73111efb744ccd04d6c6cd154087a355ec8317e80dca710bcbcd4fcf240cf36ceb3f979d4c0c2630da846a3cdcef09b285cc9f5adc00a0679122aafcfab0ab02cb0b1ca7c1e157f069e1a3e1adea468b29843a58148d7fdc0d7046da5af65e7cd7e85468a65a1ef7f751b273f03a230aca8fdd182c18e2efc1dc4e53c86b0e85263bb734066a0641288cd5c3dd891510be971a18ccdd0795006f6095d969c96f7d503b56bf8d44dc7221795b651db7a800696dc7fc1bc4bd0ae034236cbd2e1dd850cc43c54e9974b767458f883afc35081bf36f1ebf6ba23572fad91efc043440ba3b3e7d61ac84185741c721295a7f5b9d4a2127a68331298b2fc4987ced5daa1e26fd1309771ada1478455ee2433801917eebbfdc6cfcae01ca684e6139ada352adac0d0225e96c84e5c8af4a965f7f63dd386fe083cc62e8fe998ee0e825d265a2dde3f5d1efc384c67a787dc1be47914cb83e76cf7dc41a544ae91292f76b49796d804de9cbfb7f5c9cfe8052cf44ea3c1a50deadd4a616c64b5d9c6a9afaa7b2d5d42f836ec4753ff62696c651de0ca8df338a113dc9a6b75aaedf7ce07a70e1429a3bd50b7251ea344e1b387022144b0d7a364bd89a0b255cb6e7a61ddfe55ba83dee65fa0e4722538c5ff043b85467ac189f687cf62853b5cf16f7a25a6d87cac8c226544445940988debc022df35e20c1393317280bd05bfb926d564087c5c84086439ff0c54fe90ebcd9a19fe72e236e560b45b230d048d81260ebc5e6bf94cf6b2fcc802e38a559ef92e42db2f34530ad5905cac770b13d00e93b1220c857b3e1a3d04f6f31e766b453d8af8f7622c8186505a8c6eec4ddb5c76079e9fe82f10d289013d25f70c6d9baf6d2babffc1ba8f0735ffa3c46a0033a38b645a7094b260f710a2caa36d0ff1604c4a0750a7579265c7a6d8c971b664f5f14b15945769d33ef994b14ee4bafe64eb99255304b987ac9eb53a74090422b79f93ff5aee0e22e914e6cfadaefeef044638960b84d4d562bd7f73b3b76c65028b8312b27b5d8271d3be6fee46944fd90d94e838d3f65f59cfb463f4c4264fa0f2b9374e55d9f983c0c92f6067e4132df4849547634e3846ccd5a5bd033822fd1ef7bc4f61f23131f810c3af1df03f37298f47c1bb50855f96367e7553db5d9f22278d3c0e761cc3e02de3a7920ace4d98959a5b9b6370cc6622a899b58a31066f8265d16430ae928ec23f970b93bec5bfd663ede39f3ff612c7a63c67b22c1e96b46c6724fd9fb1483032a99accac504764aa1bfd44258b181cae406b993742c342cf351050d37f2beacf952c41063eb1a5b2cde9e222df1a53784477dadec35f68827c72a6077b480f5668475a740570335c53dbaf8f944135c1742969f5d134437c855a00248d8377cb0c61871f538e737","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
