<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ddf72278fcf535081c36fd1b1e5b156251e8a2130b5f18ed2cd6ad47a0471250643c5e4950eb8dad2d5efb5f0d0e52dbab83bdf68692a350cf968582d44f46ce0c8bc1c3134bb4e3c6785deef91a87e8200337aaf19a09cfa94e6b6e249f22a12d170204eb89078a1440b568174eb160c675f053f684002a5d1b44d8ab55f894b07a3ccb7388c7c36ba062d8e0d54afef64396b8578713e65991e0cf518fa58f7f046f98318f7913edd68c03ad73faa3e6a658e69cb56a0e7a0512fedce05fd65f2f91b71a80f987f34d9e27f07e88861daaef8f2b464ef194c3823855a0a48d1028114caac8d96a0638ee36c9ace7e12f0fb2d190773c1bdd2ab88814a4712ff433f2775513ebc0678ed95fe1c8d980d4dea67ce785461cab4ff0136ea85bfa969f43914eaa2a6fbafe04afc131e9908c1d06c3d8a2bcb1718eaaf40156da9d9b8c769f04782f6bea7e7786fb3071305a7ab038c15318a1e81ec0ee9b81ef8850fd6f7d59fd415b06e31d3587ef3732d302ac6d6934a87b88c0ea9ed38a5734ca369f27e7dab2b04a9c91905f05e5c749ba2015eb196386bca0d342b9346558a4f3441663ca08224e821a7d7d7bc5f260e4e0a29e09fc626283618fc1933b7b943a716a0bbd590a900f30f2a7006e8f0b04938c189f6399adddf31c0e97040d387d3c687f082558408367d529dae67260cea4d60bf80086f1139411ef1eb0a8189538a0e8e9351178289c48b9064929fe7479eb18c08080501de63fac5fa68c7f5b45ddd88dde0fb21ae28f00a0d6e1d14f1ff802deb9081d1fdc27fd201cd18d3d7f2c53d971b9f37997c14cc47a4344d35df2f83e88e289e48949319a26be36a30b98234518d14159fc4e0b122cd7b60b01bd0063664558c7066635061d015e5a7b535137da84f9cf3143235f01ba164ef54b5367f0a9cd191eb6d1d85da0ebab04bdff2672e9cc1a4e75a45af80b1c87d071ee2204753d3b54f102371c4bbcb8820a200802ccdd5469dca6adba5be06571af0406497167d6cd01cbbad30191af44926f7610b4d94f788e2104685674513e13b71bfada49415bc56fe45f6d3ea09b5b25f735066ed996ee595fbc6ba433927d038df3870f6250f237b88e64a53f8c29b113139892906587eb843af4da81eeadf320627e6d1e7e61e357ebe590763edc3e9b58bf701ccc51883323e6c6354a69537855ba728c44f8263e39e351ef481d479ea32c85983ee765af353de1ffb00e13184ed2de4d7367cb722398a1103c2972e3a55f3b937651c09c996442136265cd008da1f10e891141ac4668307dcd7c0bc17e9ed96ce42a804b2d4d45096e99f8f5724b7793f53da8504e37b02cbe3b16d6eb68744951a9edc6690aba63ea38878542594c7b0e8a78f8c87c7b64353a7e946104341f3115b2a0bc4305598415706248a3cbb1ffb7f98a2301d75324c87c728ac63c709db11b6a2e224f76b37fbacc8edd92ce4bc37c39fa06a7bbc898d1ea997f29f9debd74ca2c5d57abd669c0d27cca621bd7f2e3f8c80fd0ea6a52995e300c0725b36d9fbd3a1c96d30875eb95408ab9b892bb3dfd891c83e6fe6532175fb6d3b4ece6bd5ffc949d7dde0e977e0ce40bfa2ac078d602245ec8f2a6f1682e9dc5a25178207a3a6ee1ff4fdd96a0b160bbfd81b28df8fd39ee254250df78cedbdc7957ed2ee759f7ab4102dd0f2933f49ed21bd5bed5b6ed098609a25db9388d3b9e147723a461fb9e5c6dfbbbc691f6b3e2e999a4fefc9e7247ee38a21f20c6f77c227846c74d2961a3aea9e25784ba9c9f772f1e40dd9c96692ff73f39fba5789ec9f08605ac96dadf780d27f265c7e7d1b30465fbafad24733b85219ed08b321b0a3fd483206a1dcd0b60eb2abadc2a14cd47562a6944377efffcff7ab70b076ef087bb1dbf9e72b6e8ec1aed1d5532fe926249086daaf4cefc5dc6de0289df8fccf39620dbc491adcdf46fea6f676980ee685f4b55abf5c58da5395488d7dc588c1d04aed29957046db05e3ba4389450d208e8b29bf92fbacedf8117e9b51211dd32e0e1191b3a7b688513799dfe9c7a50499adeaf0106cb274c54aa549268ab5b6d2ecbaf7e975af373e0d07e68c367883035d65b95131ce62123b2bb3ce51cd4b8ea7e7df4b2328a0a575977b818c6cd65559c3d62f9a5ed073e55987e926c994e1625e4bf0d5224010874103818471a7a50145059d6c87733f05d441c463e80caeeba273a1e5e69d916d075334f2902e0585086f1eee9ab29991d678d39855076665038035d1b8b7cd3449f21e4c9551e462afee16d747c8831c53fde2afa908ea7a88bed43f18bd2966066dce3fae4a07d502d7ed5a4ebf79d221489b9caa9607064f359ef4da9bd53e435d920201c9c198503bed225f6dfb515f961327e848819adef925fda5b89169a361892756e16188a060fc733979db112a2a9add52ba39bb30f07d437a29e0c44602b88a384780fbb97a08632d13261b3bf64db157fa8cc8d7b1d495410b7378a84924b1f67d27f6421ad242b42003d2cf3b5e482f48a66776dcdfb03bfa8b6b2a3d7ae0f0b21827c76be6af88da0a06a571b17ca59bdbcd84d150445419e8e3310e2e02f21c9764b5ff1372ac3f438ae4877f2b0430607d9e62468cdb1a629a95610a09aa746b5bc44c5e5c68ae58c64e18a2ff773c65e9da19fb82b962c57c7cfc5561f10b57cb0058f89b8c293ff9b653fd5ddf2377791931586daf92bfaf4d07aab53e1cfb1a48b64ef215f8d1a50f2e3e520cf83130ed8b98900f81489f2a1467ade4e204fda383149027d9f06337b72e5dc48a72f864ece9491c820fb51ca6e11bc035a886e44d483b1ecf80f817757a5a9a9918b0770a2d72bb769abf8855aa69a4ebed549c96084a09a06b76e6dd7b33f5fc924eaac2530bb885d39193dd67550565a523f64a0b0ff437b913a7bd71ce4e24b0d8714b81dbbc4123711089f7e72629796664cb0d494e708d6665b141f4b0bda844f303f5f9c623a2537788dcd8458ac982ee80c349727986b323677fb9c704313ea1a1cbe64b7f1143c538a9157c5e73b463b04bcfba7d64c858f75075207121e7b8b228b5d237ece50e228d726457c6522ea7c08bf46542c423bf5b601cdd71f94e771bb41b67a2f476b76d6b4e94de0b62fde6572856d44cdd6251c559f9dd6b8e23c62f309fe1356da6354946c93678b3ef6dd9043ee81e6c7bf54acc02b3113831a889bdb9a970f0ddf47d22832d9f25d47d9253f4e3ab4cacc0721ed75db66d22a6cdf8ca1bf99f39c26d198190ae524ed2e7c3e481db2199bb5f7a7db7a988083f292477a7c5778e5b373248007b6c59a919039b9d299b687e9bbd2ec7bd9ba835829f7d94195ee8561b30ba098c51585a6a9593085740915779e43b6a0df97ea71f38e10cc43ce1366fa8ad72184e86fd00640314decd233345a7213f4914e8c70d85be9bcf887a4a58dec5ebb2ce468bc87a29063b6a4bc0a8d7237dc41aa068d9d701a0057811a622049ecb945ddcccd1bc8c9ed4d91048805405429c73745aead66e301bbc560428cb54d05dff26fd3a0b51ef2ac025e9aa4cb6f2c1e317a5658daa812b8411431b009d99f067cd8032cbcec5de73e06a202782c5fafc54451dc9c7523af9b4e68c3df7d4ac021418bc94df5ce2c13e84c96c703a734051a3b7a2bfd7d52dc6a5c0954c52ae920810dae9df6dc3e52fee102644712ea724f55c35899b5a62a5e23e8a32b6f9421d5fa78104c1f616782cdf4a1ac9aa5938306b555dba0ba910f3045c0b6e9e629237d9fc268065a153f7160783928eb56e9a9eae810f1638419827c2039dbc687ecb68ffb942b68a5eb14ab40b0a73530da5831dded5c70a289966189a83e0a501c9df1d287a437bfe226faaa2f348b1ad5481e958a6fc45c22372bbe71aab3ac9f0d55ca55ac537c95d543d44b7edc1da2cc2b31cd693451e7c7913a07869560452b641512da00c80ba3c4a390bae989e2004379d2d1f8e799cb6d5667a5473c4d55e7eed2d024e07e1b00f40f774177b4c20c2b1665f90451b77c39728f18f89e9d0b20a715f9646d4eb260727af76c3ac3552a354ce2269ae4c2badc167d51ca9d24a5ddf64ea52b901783653e5d11a87ad348bacd2a1a7cd485a32367e7053520afec8537eb1c826405e707e9cb24ab1c9b672885403b5f4ff90f8e1a1fb046682cdbda2244e989f0ee370335c51dac55381391c98d9da2db6017bb84301062f77d689ba2e53a22861881ebebe639b980c5b1982a1840d09c9b923ba81041ecc23e6ab60da0ff283fb22a590fe6813f78ed9f4caf964c453e2f2dc5aaf771b9feeb2db478c37aff5ebe7cb7b0d78a36a1a2e0262f4592b4bbb61a72498faf488a0d935580d6f4bf5d5a45bd63d073440e7df619755899404df4ac1f011744699b14c674f2fa5169cc63ffe9d03c4624a58330315407aa74fe860d607d1d70b75d0d8ebcf7251aea30b0e2c7a9da581373e6e6f70cd98436e57c3554c9319ae0d7bd33513e08ccb912c3aa15c4ca3b89587ee10004eafeff67b954abf2c39bc8a3de8eb0c0129d4a0f852276e506a59c55bfe4389274535eca6f573d56cc8d69d7d6c8dfba267f20e604a79aa2e386b3fc0c6fc357238b567f501b835294349076f166af7330acfbc99b346f76df66cd5625ac8efb4a3c8017ff496090b82e0217efd8598a5951e9434e7afc7c2b59ee44c1c5c132da0cef01d945925f1873423a3807d6dd57999e37768efb1a33e55f25abc7ee2fc6b56fff00b33188a175e239e2a8fdaefb6a3c7e3165e72fb37dc71ac5b8184c7fa5b4ef529d23580240da39dc9dbd469c4b6f75536da0f3b21c5da201ba67cb18a41aa64d8ec56207204e3bebb12b382b9efa43b4d23deac0f8d8e772a3dfd24948eb712856e073291029325466ae79466ea0192f9fade1981f60d7fb39352045f4db95e82ed47147fd13b1a84541d65d63b63eec538b22bc766cdfda99f9e1c140e5871b46fb884257d4119233eb94221188972ae7a4e71c3335c4421df140f319557b8c2355fb632f55379f723497035a80b8925746852438e3b47186041263b13e3118a8da0701a982c6077b25bb341e17ccd4ac921e78561c28242bbf6fd286945a78fa0adc4542dc0355bd90862caa5b18844c7010309e2e545dc4887c1495af571200b590df40acbfa580919ee034f1b04dc84035751bcb14dfd582dc535661b3831f37c51740df51b2b3d03461e1b17cecf424d25c78ef2453804417058a9ea43b75b6fb2ed8abf813042447ff1060b1082a47847db96223f409c24a12f431bad20110e08a3328723522bd96a35226c01416a380e5c3865167394ccde3cfb32068237d29bc29bca5c6e6db05d3792da07b370e769bf510ce5bf9fa5dc3ef60643176a329caa5fec0ad012acacf9c948473128b9ec7e0be89019ad9c794fa58934653ac1f48474e7b8dffd830da1b37f63a0bc45f11e1c3d9251c24862048ef2300918028f7b355b27d7e244e8b2482da4eebc34bcbca2dc3044ee147f8dff8552b446b91463f4358fd9760b094c6b6c244bf4d1091fd7a8b9621d1a90950a91e379c98cfafb1e5bbae6ca6e2e7071f17989f8779c174e48e01445d46d7f77057f0d8717a03484e0cfc4aec91e5db6d92ca54ef983adbe7e1935d61c81686a2bc72cf137f3d0b647ed5c70ef75f3f737337fc64cf4f5de58bb946f6475921e1dd4be8cd852210667b8fd207cabc40449450019f68c643b410e51eed00402c5cf318825fd5d0e899de137ede346629401a53fef3c7bbda8f7e2b858912cb4088a5e730b20a6dc3d91da8c28ff082314579793b69612bfd1114a972c345fc9e4c22971a378c0359949d6638ba20dd95000c5a99cd759fcd2822b3134dd27cb3e37374d381ded746c65561fcb18afdca517a0444273b134c5e4e72964a6b9bac01d6259e55bb9ce0a6fbbbe7ed7905baf5c4240bb6de0c204577b0a1ee7cb5080f6e78f08f27938949b34dcb34009ace56d52ee7398059b1fc916910c46d90bb3b617427c95ebe251b454fa16a348662ef7ec5a96920b834eaa035ec15f2a5fa01b537034c80b58d6517b767b5c73fdcde2821080a879a134ba06980fbe2bf5be7c4133776868fd21c0f514dbf3981bd07f1c83de524910e33660e1a89480ab691b7ee9b7213e0192acc419a57f81d4066a9a33337f3c2497693018508345eca0b95896a68a902a8d90e88777f983b0ecff67772f2ee9238446adca05bd99c33e225885207eeaf4805daa8c8657227a18380a41b5718dd6ebbb91e156273a5f84ec9377710ff9adfa3dc6c63446a54411e5795790ed8ec31948780dc442f1da0bcab8a40441ce34360fa4e9625a0c29291fc3e6553aac08af2bec287e1866d289aade696e6bbbfcd5edb146a63ac4dbf319a63698b6db599536d3f1c8a21a09a31a0d6a91ae9a5deca9f02e9fef4caf1b1280099e9c88cc06e1a7e347df46af9fae42b0079cc2392a141b1c6881dbd2019ceced7b93ee7fbb55f9845daec62fe4e3d5e847440a78ff69ce5b8e9c70db2e22b4654b5084d7aeba68ba17b08100e30bb54888a9c66cbf6bdd8eaab46e355330e7104fe55fa5c230d274092891c2b8079f518bdfe07b01b9cbd2642e832c6a2b2b3a91d0f2c86c83fd0f270eebcbbd50782209209efc3235fb61b7b226f42d36bd784e09f6c48145521c6ef6e2a020533043009b12163828ed2398b3bfd37af9632418f8070001c60d250d74b72cdea04698de2f714e7b6a10097da7dbf2e33f7fa28f7bd7e12a5c3843bea96ab64d8f6b0149627b1410aeca2bc9c27062479d264dc9cfdde6a157e2e1e1cecf940f6fb8d84cf0f523f9ed1aed0b021b1f10cdd53df11327c35e66832af3fc01d953291dfe4f719b8cbb337eb10987ebabdf82e1d155e2ebadf1586452d67c2bb559d597f3d179902fd66c57bb1ba3656d28d9a37aa3e5a89b105deae2c67c661e31925b4c6a7232ed159c2aedb652422f6a117d55acc7d8e43bf7813f515557c00878c8f66a765cf5a1c886394ea33765ba4ff856b601d29b722fd1427dd10d9789ac07d0cab0cd884442b957aefe17242cfe5b5e120432257dd6ba4c0eb12a474f7ca924903e347037752145965eb0d8c7f0562a292f4cd189bf97ecc50df2219a4b7c4262f23bdf02e2ac738b82ff57d5db3cc54697773221aff11c4f1a3e14fe13b8f7c48311998d145ba46b39f43a277d9ccc253130298642e831322a5e59be884f5d926b54eaeb6b16adbe5c861528e9402c779eac63e4c024600d61435c6e18740f4547ed2f98b06f53fba0e7fd967637e950d83cc97ecbfaef96ce89d7e21198fd9cc7fd2178588e94784e07decc61bb0fbc255afa2b798f38209896c0eeb29cacdc7804af8fabcf14ead4fc8db69e81c47aef21a48c3d2ea67248b15fd50060b18698351a40b8a878808cc51b5b31d63498a90530f0f0d33eec7ccd4d1bea29bcc6e8396de893b1221b3a6dd93b6a35ca620f309e09ab4c9a73b7d7afc9a12cb0e585c6b64ed5b9120de14c9c599f387364675486cd57d05f2f733253ef0bcd8989b2b45830f77af92b0074bdae05cb6fbeeee39d4deb25193c9034cf4ee043c09c413e9d2669d9a33d9ff4a3c14d1434bb7fac9bb0ef1f68877a755d19b7a94c6a2cc074be9940f2928d39e52535779a59329ebdbbb12fe96441b552bfde6cf7b14a812d15208bd1562a95e761ac359862e78b1baeb4e27f64d0b264e99774563b30f419b06862c5bad1bd4bbeaa862c7fe17ef677e4bd115fe4d8785d241b92b2d2c417c45af8266f15cc0039ab82af10f01d4beef7ef02de2d5334cc88d6adb74edb0c7138dfcebf894069a5417fe14341fa5009340beb30bb190efd36c694590793f2a1b96051176d981147db47a2ca91e10a330644a44bd7b8073c39efd38f7f0dea622b206d53d794fcc7cfacb9d7890b1b55976c843b1929f27a5db9f3bd9472b101375c8b266eb084728ba04162d17bbe34d455f4917debd33e7bf766ccf4acf30ed6a72fc1d447542ba1fab2ddf4ace64e3ff2b5b1aec82778bfc35cb5565beae6e3112c2c4740eb117f943c894db7cda65b5afa57ed048475e825c4b889b48efde6e85862417ff4fa2ec63cac3b2a6a660daa8d3503b10d6fb792defabdf6ac70482d68d2a6b25870fdeff6064444a091d81bcaae305be4ca5bbd54713b99bf3c9b5728ceb4a9bc203ac98b626fe4c98ffc340bc65835e51a40b49795e1234149f799c761f1cd8a3a19731fda4d3297eb59589cab5292782800e8638740df0a43311734ae6386dc719633f153335ee12250d1b75518a193aafb7b67a0d798848ccf382431dc1f1baf3d8eeb5ad533cae9719715ff9a6db542415e3ca228ed29e608f972d1fb5bba2fc0285658932dfd5612e22b4d69e38425d9977804496790b7fa4f0ebd274a44d4fa2dbd75e7de5c3a1071d80c1b5ce647326906f9674c004ba165e9487711b14981c6c1a4b41e020557c0bc38fc3e28e339dbd2e5ea846ecebf0ca77e7addca9637f9abb30209d718df267cea6e6618c08eb87f0842bd2b4e9aa9d7452126ca806bf0d1067aa31649587538af2cf11c11d11845d328a7ab5e8f14418aa80869d1d19a94f579f170eb053ef71b291038f6ee75943b865f265fd86e8e11ba5b8afb542d0cb30c4617716b9525eae5139085deb902114f56e01c4794599701984548a0d7750c4c9447a05fb6af892e379936897b71b4f067dd730a8c93e58225906e480426730d5f0ad2e14ceff8b8f1fb0d66d21ffdf1e2dec83e2b75b6c3962ea9f36f83718160a9d3d9889b76aed581cb154b5d52f138065895d89ed3f337c2f6070abe2fba00e2aa41ccd0c797bf0afcb8a648637319470a955db8faab92ca57fe5d0cd39e030f1874538998bd2350c14d4f457a8aeedc6ad63ecd5f2a40be23c31ed0b885836741eb8833ab25c31cfbb0ce085ab1dab4780a940853467db42d3c863e354f307404d8868938b6f712aa4a937ade4e0010eba3e99f7f1240d898c01916abb5629696b97c04f987dd39eb4d8bd87d73b3c24795759b6173d89a3becc92988fd2781b19c1126768c057670aade0b9ccba3809f77692c2c19e669ffd02df19b066aaf6e05118ab6fd4adb812985a5ad8af1c26836d5709a26926a47611e0278019e3b4bb49cd5b8a4a81655bd9e41b86bd09cbf9e447d041943b714df0283cfd8a21384c31b78ffa16a3626aaa9055b6bed9cc67ff44c96090c3b8102779471089d73b5fc2ca2aa1a6f88e86be633554fdc5e5961d6620699540f09d170bd682cfe20f13c99084084c6ac8d89b5ad7aea63462d3c0790e54177b82b4999acb0b0ce56b9f776050b54b41224fe61e53b3b1e71bf103582ddaa5649cd1265819bc365c411dcf00f4c4f0eef406e5b86f72b97853194c38bef4ed3d810c6eefe494624d1cee6df5c271f50bac7ba8e1896cf5a002e28c07d9e65ada58079e81f34b5d145616797709b0fb28f3d3d6dd145e3d5d744f77a9bfd49445ada49b32ab2fb1b76485c296525ca104d97bbfbac2e996ca29fc449834972982168f14f0fb484caa01674f5d13b96a1385754cdcf47e8830110a818c887a44de82e33fad34285d69fb4cc92d89c317d0ad010b6b4bdea7165c59982f8ecd24a910203a811a926a977603288053cfa8e6da4da983227c7f95cef1c352a826f44c866280bf2eed8377d07d64a6bb56a8b11a6e20075609c7f6fbcbe8af4fce66e91407175db8671554f88b2393a48cd324070e19f9487a0d3b5ec8be768b734a6e19580f16c366b11b93e2e0972e0ef36219eff41c05775391daf586d8d7f1383bd2b5d56a2d864fad7b9f68374e555ddc4f397545edb8f8a6ae400738ac23f85dcd0a960a96a235f8a7d1dcd3289f279e68ed9088928765322214907210b9299188c241d1155320ec747c8cd766ec2c0df081007d59697c289d28b95ef88c635e23520cba61513820ca5fb6c92073082cc4e14608394d3bf10104930d950bc3999a003768ac00d7c19c81599c1b736c6ca43710d8a19f980d64f86d0a3a82819d5ab72e1f6876381f5b004aa6cb0bda42e11087f3b3a5cf2bac9e98e8a5a8e56aa5ad50dcff26f599f324aa487fa067f20d9b5673602c71ced00cce0c7be472204cc28c0413d59a91268ae699d1b8a0850ae352447a5c3f26d04aa83c7c11cadbfde06a5bb687ae546ec009742ec54cfcaa97abf25879e8a72903956c4424c6bbbd6cae8e902606778f753274e912b7baac134da44766488a5324ce000ed43c14b90d1c8862fdcef7b71b5d3381477c953cc9c7d29c3b9babf7c899ad868c4eeab455166cde777b9b16ea28adee2cd14750e1db94e1ddf538dc4e7c7f20fbaac07d92dda31f57927ccc555a01dd90adaef5c6106a02f53e43453865c9a25435d85268445353378a186e9e1129105ee4f0e941cde9c6af6683ab220afe24205c28afe5d593ff7a39e79571c761af44a302d72e1da97a79ee1646d0c3624c8147a7560d8b8997854f96fd98b0daa4dae964a15927697fdab1b744ebc02bc3a7f6bf5699b7d15a4ace62092a6a3718964c92b848efbd7f8efca1589dc6181973a5c9fdd51eff7b0be15c1df7134274d3c6488e299b5c90d3b7819314a8b30c038559e090806b85e5b537c44a4df38e5a9a3a880d21e8e86c49f25ff28b046ad73ae25690ed1094b5e5afd3eb587ac9175997c43d2e075d7ceabe883830a129aaf3fe0dde939fce082a971c54de239f87e66f5976da3faeaf89cdab38e9d6f3e5568edf4e9c9ef37cf42f88952e718fa36d729306d36457ea443a77efad4cf9ba11b2a307ee1da2695974afe1073ac7f6476a3bb4d85c524174e921692b729175041002afef84d70c4d67a42e0bf3f5006347b2dea448bb2af679898a3cf0ec50c6870b80105fb25a15785a5c5078ea9ff682efbcfb38ad3781060ad3adcd4c6cff73dc7bcdf3a18e0adda9b8214e62685e0f2131b6678993061dbad7a554e4019930f125e63be625c9b4b13a564c5d9079b60ab07eeaa87c41e84060b581338771fdd0b29a03c7fd1a126f13b1344976422eca06d387d1b96c8a170f157b019f2acf73a0a4c5eb4acc811881cba6a1505b652f0442bd06fcee5405f2ff68b2e23e8463d88554270e592135fba89602b059e6ca70c959046a63aa8a6895f26e0cce5a027e5e2233b262b8513f8ebe498d43e829fd4d22a730440e17643bb84bfa52b21d5e99d8b12c53ee83bd619e2d68c09cb09e72020eeb24a72c701549935d81186b35dfc4fe6b3fd6e25e6c32f2589ffd23607288f13abaaaf8a387306e53612143d5f167c59abfa219d8743fe69acf49f90f91c06871c95fb133dff14f29354bb2501a5e63c7501081f33f5cb1b14db30af394b1ee3f96e34cb35133c274704bd1f3e5e6be785420f51aa24485c1e4726f82b013748a486fb074ceac885ff6a9ff5460b41a695003ee585f1ddb8094aff3700ba6428cffc98d75f3a35c6a0091ded997194e92ae6a0f4bfd919f4ae5e5af9c407845554d54ff74d5b8bee8ff06f159c5b364ddb0181a4c8e1d95e90f24ac13f7550f5109e7aef6c25c0e2349db5f8f8aea0362264736149e1b534bf1595b6147b54ac41ec5379a79f0f5174f785a1c66636bf94e9d65a44474b782018533f8c8954612889b8840bc571b3d251a93eee954ee001d8387cbfd58151817d5414faf346303f817f5bd5941f866e240d84fe4958fa16c4d3c26cccee9145c5aa0586fcaab54a7efbabb80c2df748a959aa3b23fd3c29932727d8a0e7026d8af47c3f78a8962c4265e89a6bd4989e6785a5e225513cff180ebb3c53824257f81df5756f6c431476b967f9a0cefad75481a38649d6d0d20dad94bdbc151259ebc31b9603f5c28ecb8a1b11d5ffc2fce9ae69fa72429b4f36e3942ccb9b5907042475ad76b06496e4d7fca55ab76abee87e3ae1f4aeafb5442fa8bc9e700e95ee8f3e920d41a18bb617881084f03583d4a67e3d89d65c84e3d6b16188ca12f08233f9ab0816b720439d9ac1b684edfdbf109a6e774295048b26548d489694b793967f58d98da22546970d202a25190fe6b3947fe035c209de0195e2ee91c369155a1a1e5948d227d1cc0838a64863e74e29baa9925fbbdfd68a782462fa772a1303d1f7242dc131a0ad50974f398a8309d98c5f0610676ee9d93c8c568c7d398efbc4bfdd958b0383c0c56a8efbf3b6270fd4427362f68a234bed2f7e304e3630d2a44c5bac5153f8b236d53ffa8963bcc6fb751ff810ceb635f066dd8e634dec1f83a17f69d508f19d61fa977a2dd4bdca914a0568b2b7d11adcb7402f61bb24b12e0f86206a52d0b2eb4e70d3d30d7894ece91b8dd96970ea20655d584490ea0e225635ff09f45e9488b2610aaa9163f02dfc6ed51853cc658f1138b29e1dbf5b63f39071bd2aa881919b7b19d724e1a760c6634da151dfdbbc77befcdac3a929cc599b6cd21be6a317d0592e661d1db1a669f6901771b7c6497d16c12c27bcd41b9048891ddca602eca87a1b2237d7c03b0f17e1e9168969349cfcde82fdbbd6d58d3fef34386f30cb065d3030145d19bbcc2f67ac44715db61454b2650deb3d27de22e15dda42c6e5176909b0ec1f291d5d6c9a53e8c615d6928767abc90b845d27b0e94e5c15ad6206976556f6dbd575a4e21e31116fc98466aaa695f9146f94b63468d9f8ff39167ba492f875634b610689a92895a370fbc76466093d6047ab9ac002ad043c2cd8d417a4bdf31f6722f02705fe36e5944ee46a0f448d9518d2f8aee46a72c565c2e8db398e6d7cbe637792afbdac44ed9904b3fbab8861194d1bf8185b092f6246de957a52736dd0edca7fa457c1c1b42be6ca7f2ec7f978f2b0cf00031f314cdc9908cddb04f47a9c5d1945be9b94a54764eb755fdbfd558ed7974f727b70f4b72b4532c1c66a7d4016fd0bcfce1dc87ce7f779f75c51442a573e4fbc0cd8df203113e9fc1cd33f1ff69be35f64c777f8580d4db36314e4e7716ac66e70b34c8e250d3c492cbde94495a3dfd1cc6a9a2d620112d0f62c8ff8af150f634b9f95aec47e174b43603af9e5dff8c664e33a6f77601728e3fac355ce5b8b6db9e4236459b49e3f87ebdcb4094bff20067bdfaef012756abfd4e6700fad1d45cf87fba8e09db157c7d503de014d842f64efcf8bcdd4b4ff59c10cad1bb1cb735096180ba07038fea7ad4c2d9336c2d9ce9b524297fa2667d3860d4e8a1c00934139b17d250538ef5224fdba7d9b7f2a4456cb0edab8de5753b83e0f26867f7c3bace5eda6921b261f0ba5836b5cd472736fffac0c9f2b1e2def0e586536def5f9e09076899bd3db955cb97ff6bbfa303a84cea71752c5509b11daff7b6073d6f5c473bb80ce99733c0cc00e040dc6fcd146c5a35b52b1d56303885a96af96e098ef99d26c433b1ed2ba8ea35dcc85a1d92a87d5e0718807223112b2a2cb7e7852de3821043a67489ac181aa4c3acf75bb3d5ecc3c204539bc4e27cc5222bcb9c56b6f627b8ff80c0d0e880b3afc04cfde31c50f8c5ec81516d07db777b39bfd73b2a979c497cd495882b0a04f27ada36dd55f8861d035271349498d3c51d40c1163574ea086fda87a4b9bc7349dbe0e67c61a2547e548856d71e4906ad80434aa1c98b95689183ef80169a56683fd7e8a4382ee37127d76d460f51f3672bbd429594d94eb04295e9aa66d9dc4047173d40eed628bdc729e026faf76b49a8585d8d0671d2819b666831c821ea060c8e9dcbf631e86717de6a6ed04a87368f660a245e80ec18297bdedfd9a0749e71a6fe7ce335ca5a3a4676666b08595cf07445fd6dbd2874e945862111186e04c6d93b21b50fb7ce32bd9584fc817b73f14ba1649fc635c64276e6c59892e3406d85a7733435dab4ce8ed32c7093e4904eee058ec7c32cbb400d71f644246765916fb0f55d5438c9bf1c268ddad01f233cc3ed04dc53411f6f92e139356f09cff6633a09b9306a96e9be6a5241f7cc3cba71717da37ea18433c9b2096ca3420690bbf12c66f7c25c876128ec0ea05e5aa4e5c049631e842851f8811b899b34f4b6eee0843deb3ff516fc38732c6c6bab14ffd6bc604e1534610a7dd35a7ad0d31e4279b1750146b0ebbfac6ed73c961864e330f1bb00de6746e88b1703b992ea670dc5cc1d59de2cd55612d42b0fd6bded87b3802744235651e40df6a628b33b979f1af0cf7006d046ca638cf8b17cc8a052e83080e6b476576bb91b940637da9c969049fac86fff91547b4205138079933fc0ef9dbe0c6f8b728b068550ea4c92a02e1019a50304b92ef49e9392aeac5f3b078c0e610507110c71d89e35e98e2c01168497da608ec02e18e0e7e1960ba693dbd828213a05533d5f78e00905f56e39abf6199ca30457b53eb678c75922852ab36c961b9bc096e8a0de2022423132e34c7000d6dedce363e15c8669ffc8f319506d82b6f4c2960557718ff68360bc63c1d1ccfa7478c604feb6c6208fcb640119ad0fa81406405348060c675b74c2a04a2d480c8e4d609d6d1b0ce19af92c1ca8eaa10e9b91147f06d273187d998fccd1bbb7e9ed9f472ff702bebc87bd67a72b8397da3860e93c6bba1a7b00b78a711cbad05c6b9583287b6a5c213ddef843969b6972cb0e258702d2cb17ddca8922264b8b608d7ce4ad97a6c665d3aaea5849efea07e368c2baa833ed9010342dfe006003e0772a9484b2f9c72d54cdd0b587edf0d210735d44bd06f001838d10c4259465907b4ff3241b34b51da0e997d49259e922e614e2992c5ced13abf0da255cfaefc6c9b44d8c9954340120acdd6f2815ff22e170ac8177198ea163c18e93f8eaca27199447dd579942585995b6a36ca8abba05b8e8f5bb2a431fd66c27f86795da540f23e842259321ccf615c63a1f67adb7528594383e598dc1493e54964811a0a3a40df01a975b863527d98af3bed36fd42d28a2b05365a2a9eab29f657c5c501bfe57e2999536af5f024c0146ace7d8a296907936f27d6471840720089b0077704d8af21f98ad0812ac5596eab46fe9a7b511a1070048d60599c7853470f35eb4dfddb63f8b39b2eee609c31bf9ca1e5601c0e043f0ac88b678d9569d0fdd636dfa3bd89d4ddcb862f637e307ea91b3c82972f680bdde049fdafd2bc15e1dcc26e7178ceae9376c27327e4fb4d0911d900cefa70340f0d0c568cea02464f338cc9864c928017fff6f40926360c3ea7c22f5ba9a9163bae68fd26bb50b17dbdaae5c362727107e5395a29d9f1c131b24a548cc004dbb7389b165aa21c1db6bc4aae9f434923513489b493b83ca589f50000c6cfec0c1387994af6767c24fc4ff6cfd6850194737d5b15d17d9ca63bd811a692780336c7e63949d6024ef57f6b3ef10656bc158f0a18a9d0468f5fc74290af94cf7d73b7e5284e0e459d3a458db1064b67a85efb87ab23654fbe8dc2efc9a8a5c85feee4b86ff67afbdb8485f04fff547c2cf0729558a6d2035bf944819fe6a55bc89b4e8a6360a374ffae22d6f12d8f766e9b1a93e25a259ca01ef38a55f62c2b8d8ee752bcbae8a21bcfc8c78f5d30655f2a4b1b052990325459f1d52c09a389c195cc9730dd76d3b9eeb555e64db6293eea448fc5b394762fc5c801b95967d58ef2fddb30601b1e9c2beae5792c787cc08c285a383ec515b9675d14e798768ab50b23133dbabb9975873598e8ab2bb5de4bf67bb3eebfd9cfc509521e578ec36271f9f7cef75b16da5d96bfb26ff45f40cb8642e0435a3bd0f7c5c4fe425179a5a014091b6c7837494954db759bc0535fc9a6cca2832b85bc4f4f849ea2b8ceff77e9fc6672a55a41a5c4b61429cd7c03a302b8181b65a83302403156c7573c96274c715c826a5be79d600b48fb4efcaa7cf3d267ba488b6d534356be67fa0833d4b8dea20b17e6662ae2a7c5d77daf3a42271b777e79d05058607b222fdaa30adfbf740efc5867f5d0c63dae6c8f80f883976c1f2d7948ce0127fd946926ddeee9ba27be8cd5b5c731471078be371f12eb691ee3ccdb2cefff6eaef082c08ea922926e1d4e5082bd2cb151b8b034da35dd601d38c491f552df61b811cfd5980dce1cb1bfcfcaa1d922d1c86d8b5d147ef5ea78765f2ccb80e2f2b43641b507411c0cc061b5a8801323e3500fa0bd27e38aed9f77fe6f3484d2d6af767bf5d8aa25d420eabfa8044acb3565b897b02410590e23a889fce24cde01ed09d836fb2282af159159b28339e0e6351f92f5f9bbe784a1e90ba4edeec3e68361d5a41de98d4442ed8c4cfac1f297fbded30ccf858ffe23325728e2305a5f178a2bb7f329afa48fc168d44692a12b23936d224a064c43da8c16c4dc011d42840e127c1d93cf77b57eb63a9307b53a146735431ad22c0c65ac833cb1c5b163aec978476674812b4932296df2d584affddda1140f3c5eaeeab1f3f51da6a34e4b42345df047ed1054a7da3de6ef34e133ad3329bafec22434722090e16261ed287acc4bda50777457390cdd842b6cd34b3792e015ddd4cc320ae6c8e7101bdccff74ebe61334f5ede6db6bc954ae0dff4b24252e6e7448ea0b3504033bc352cb12da692e55a13512d90c7716fee41f6a473f08a710fe1e47547203615a9b8313a1ae1a2b5a465aa297d0bcbebbae66450de692c650e11f0c0156091f4c42ae6c9490ffc047b83a7f3ac43b6fbb70146b65b0bf0b7b2034ec2816cd9c7c08a3cbeaa7f3674e7ca623384817de0fb269f81b10d15871dc3fced5301f48db44688457b11b2be5f0e0d8b1c390db061831bcc2a0fbac7fb0ca582b9976536859a6a971d9756133431e76e2f4c7d171b2900bf6af6804812f54cb734c9373fd32dfe75e7423ff3d90929df89adace8d65684dd0a6f080cff03a4eb6224170558917f7239f252bd96c71ce232c9caf5c6ca547163928d6fbe52007eeecd095371c6402ccc33b4d977ce0ebe6615ce54cd44a046649bf37fe6bb48814ff6642e225c5e2d1530ead350954fa94dd85a4800c11996f884c90fbb01631d9dbb124fe39c8e6f1c137d15da8dcd46514a8544657670b59fec87913c3b7b36f24f3e8b4f2ee7f75eab53c9bef5570a0ba33969bf0aec6eb3617a0644ca7a93b98ca0c56f5b18d973037c7ee5ff4fb2ffd091b73e55c0286a399b66de70678a8fe88d4546facff1502b8abcc6548e722c18d617db83f65051fc4703a9fb83d9ca119eb970a3060edd374224a8043381713e841aebde9b579c3a1de794652885527bea016999f365a2d9fe6ec7afae908a6b7ee6a9162fa8e6c6e82edcb3179b0e74a2ce184fdb3344595814b8a99b5cd8a6980194f06b1107d322371a61315d017b25aea4c74423ca64aac5d756ac42a42cd53982b64c9ca35e15403733e42e4535190a1a38381d41b3a56eb6b80b40f3abda3cf5e582db8f2ebc4c5efb3e0b9dce4d5ff858ee18b9fb7d8b7022ee82aaaaf70ced91eb0cba27ed22ce87df5d1f3f76cc97bef6b3a17e44297cc288f1ce8dc2271f01f80593f6b01ff34f00390429f7fcbee0996aabc01c17418c5925ef91e8e3df8168b94508994ec0e05b32f97e5a80f999d5fa1c54af089c663481e89070a99c1e124a3bde4591a93a5e9de17a34cd769d6a43477e14fd72966e810bf28d518e1f8394b058672ee7409dc0852c878676991fcc43140553e6dcfef0e39c78ca5e46bae92e4b3eff9be4aa40325918b0a414b8bdcff892fa77e87b89fde64632cdbc9efd5ce1478ccda01b86dd267cd91d98464ea37f2273fa3644f7fc9c32f5204896206906a81610f50bc2f6c82f689ea470d12c8b862b3daaa2f235959f5017b24155e75cc5eab5765ecc6aada0f8878a5ea0c3f232300308788372867ff6bde213551fe5ba2e8e029962642f2bc650f74e5b61f327700b7940802229938a295cdb6c6495a48019a8eed5ee1640aac3adf3960d7b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
