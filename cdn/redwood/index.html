<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e8fcfd180bdd1a9c7ebd63c7dd4e9ec7e3091cbe3ffa7f328bf60755fc90c9608a7ce96cf744456ab99137ac38c8c69e67023ad07a826fc6cb40b80936988922d3dacb14fd5fb31835b8b1788205bf132d175e67ff52a8439d343aa97d76bbacd1d258d558d73ae8ed953d51e9a73aa3813e6c975038d5246cdf6c9dbe040a2b37f98bb5a29e3aecbe6d6819cfdda9345eae8f228da804d3dd115a2acab547bf2ae4e9c896b568e0bb99a4011a15f38105ad243590033263624b5af68961904ec090423963d0054c9b3bd6b4bd03d52bbb097b6641d1ff347b5d35de96dc1d4c74848e15d37449444bc807681fb9269cf2bc98ba14ac1d1e5e9384fa90ef0d4ae930e9ed5ea7960d627fa2e1fd5ba46ba70c343c95b852c6869dd74814ba9092fa7c85c00d165fa3177d597bbfea56ce76f1c4d3a1992a9de088aa148091e6d75fee70f39a7e2c79c70061afe333ec39b6d98cf1103d29f646c79091b6d0eecf156b98691be9fe18be273cba66c256b0b8be005fa28eafc561d227b58e37df4f422bda965ed619452a1ea49806d26e0f551d3a62f17d4794f8185b83a75aaedba7759868180eb6ecfaa0820c24b6168b7fa26c8c0e58ed00de0bef5b1f2d989a4f45949a49ec60ce716a0e70198d60611752aab615c8513d60131e171748d4f777fae2c2162cfb2e062124d229535e4de5c1dc872269296908e1300bee014f486d0d3dcd04af10a243ce819937446d4d28faa9241715413a94d71f48b938b859abfd8d02a812225b2a47407b9caf86fc8714f43ac2a26b099209c97db87a86c55aa21a48e245c0a1fde0055dc7ad1f0b500a978c7e821e3d2cf41c7100d6d487d7fe205df261c4ec95e3f3a3a6e7a92874cbb02cffb4f8489ee38ef15533ade3835e96ead90ce54c8807bcb257ea8a814524d9a3ce451b2640ba8832358a8d2b42344d4161b2b10fd44a2aa29dd802f370c57228ae02d4d8412aa7b3e05a210f2180ae8c766a46b3713437fff91b11a98333b34d90b8f9e86374144fe91cff8e7c9701f006c0ba34e502129de9e8888364a97aa736997f4803d38e741f062e8b1d1e3648316610b4b0a2eb6ecaf67a090022b47455df075bde0df4a07fa63d8daa7cb21341ed1c8d8bd27b2146df45599c98192bafe0101270a7a28472b14db6e79165fff6cdd6185fb6c3da41aabe508dc428c0622d5a165e5c68d195c6228f18128e88e95e69892aa218a037165c053689aadde22b00596b52d0213b70ff9070e3b2c42546847c32b61abadecfb697005541d5eec357ccec0aaff1e33347efac0e337c38ef44d6ee54cec9cfac343950403a6c397cea06bf6a4404e438b1fd169d82df2545de939f323600d157424b2be2730334fc8e556eb0ef03df916a28991b4c1671e632833aa25b2790f57fff48ba66da55efe07042aeb89def2cee11b53ea0f95bccca7441b373983b8ef74370adc523e3e32737df9b4b9f186ec0ab6ccfcbb96c56542a6f7c2ee8ccc3b44e1a025eee50f85b4ea5e4d96210169025152322d44420cb1240b1fd32f45d595887772e7ced23fdacc276cc39ad44220c933875b6c93304efb4eedf5b77423ea3684d18ba0a79d43bfff963b2bae6a3cd9f2326c2c0c838d4974dcfbf975003e1ffb1badf36d40b12088442822f930baa8dd5596beca11ce2b41eff7c063f84845ecaded3cf9f2c90f601bad031685dd6b9789b0522e3a97572e72967128e15e9275ae6929061977e95ca79bc94b6d91892d52ad238100bee720423dd9fbdebe8163c852fa25dcf53ee65a196e788a8f5b45fb72da3968d4501f8a5baf3aad4fd463018a29e02c3b4cecfc3c441bd0a7c5a240765a8a09413f268de09cd6b2abf91dbfdfb3aaacc602edd5a794d617a23569911db3b5f3299e0db68480d791b6675dfa0abce0d16953b6d021d7902e4f7d981c892d5b09f7a4709fba884fb90aae7cbe359ec8d606814766d0a63b32fdfd095daa8d3246e48cfaed71238ea529f64fc9b3a0b59fc276b50720fc4781c0b185dcfd2415ee311e630068e9c7652de1769da441c45307f45659b276a4a6d76b6a2a84e1b4c19af358216324b820ecb4f0d0b499193341dfb788847cd0df6dbe0f765a232598111ed9c03095b0befdec57cb21822c4f273cf72376d59838e04a141f4ae8e4dc724c3bff04a62579512c805fb9cfc8164ed616c5c26101353a6aaf2c14b1f792a1aa7b580a4088fa05b3da3f650e5be27340ede52104aa838013dec8c48d78efce93dd8a425e0b9e509213513a55a725c44c9dfdea035cc4a50b03318df9257468bfc40b2b4152080876c5a9e3dc2481b4eff256e7c308a29bfc06abef4b1cc3b17cb68a9b3598cccc7f70d39a4c890d8e66c83d835998df951dc48314dd6c3b9254ef11ff6e0390fede928aac7a830c84435e3ff98724068fcc5bfd0229891c6af4b4adde8c9c21c29168dcf97c6b5515688b2be46df5699650c5c9cbe6d01ac84c1360da4339a4a91eb63e38054caea66d4b459555f6eff570e160c30853922f188e6c83a16a2638977b042d2918fe5ab40051613cb298843980a1f8da7672241764f175f1b47da1ee0f423633675f87b0949919d65354ff26d918fb76626cdc7eed0c2da711fe3c409af5788b53dc128e3c4a2f2c9c57930652da6965a56d9ddc7ddb90eef185c9ec00e529b98c2230ead22c09358e5cc61704693def078b0aab728c8fec0ba9b2586da44e49af9743635a29daa3570b04a48f4801ffa17e2345ec7929cc3f1c10910ad7fce8eb6998da4deeae74a161d3c3a6c07be28994198743751d7a7218b163c94243370c26d5efe80b368f68617156bc863bef178307856c863918b029558819d07dc6fe154430fcd59f6f8411f6400143ee2bc4f3332789a57613fd79df7248ff67012a8235bc2183b83a136623b374aad891cefb7a872b200cf51d12e71d4df8e908f28a868eb3294a149c49c98c3cba92d48633f3aba8c68103a06616a9352e1b5b3ba6ec5dd4399e531798d5285397e26be6f7f9489bf3b9d43cf0d3760bd6960d9826e5263e43de7a7c88811bd9717471e5bed644843fbf7cba60e56a8a128b98b0fa3f17d1b2c250b5a5099e6fdcd44585318b9d34ab1748d90d30cd1e6ee0417cb50ad3540633a29e2421dd2217bf7db60a9beea85a7f5764392586b38e497533e89a37ac14a2defd9d2c1e205ec591caab20c92bef61b8e6a81c91ea82aea937e071ecfbbb87337a73caefb7bd9e4c82cbc7599395ab2b16108c00f2f702d80e44c533e05291557598ac021719e9662a5d100919e2d902c33873964f02ada366c4dd0a52f62f2954694128897071c10c902c6cb0daf249ed5d30ad985470da215b81526872ab4bef1c65ddae7492089df6e111007ae5fbc9f7c10c23148c6287f0093592e1e71700ea37e2d7e18492bb3cea87afbb994e1b383dbfcc1aab217700bf7a3f9a1ab07ccaf7246d1a63534bd56f142c7b49b8f65b9a5abe83b28bd7bc3b49a012dee9cf9738de0ed1e7af217b9c9d03c5de416b4000d064d5e8ce1de3e5e284eb85221282edf57c50094ef4ecff5871c979c9f9505ace42dc406ad0a50341eab85a2388382119802847c57988b74ef94440186a9c3d6691f198493ea7e881c08ef5870198259870105737c583416cada46e58e01920217b6ece84f807e6426fb43561eb5f15ea1cb4bfe595e5158c2c1171c8de416ffd5f468c81118415e57c4c29699deaadddcdc4f8a6aab126ffd9e3fabd20caf963f336a24e9b029235ed0a84c59f2b5367f67329634027650d9a0b56d44c1a350cc59dfaa32a0cdc24ee77c4233b5fd5aa7b8e91bb90d4b5fe7e6a6affd806c2ecf68b342804536eefd8f641e29f3e43e099cac00a92e0e1d249c9af4874c5e329cd678b78e7072234c1d86e57e4f0b2596d2cef523696f06b52f11ecce63d46c19667d809e35beb4bcaf310236694cb5377d9453ec2eff9e570f78f86ce37c4f2ea15af6008c2f5ef371cd4cebd03c6dee67e6edf3624c4bec50e7b24e847571661ff82e6836e9d18a3732e425c54ee767a8cb6a0b4c273bca84fa84866567d283aa439545fd055e2bc814c5debdb226be6c18e7f84cb12eb1f201ed586a0ddfe2e99f15b4e175f11344fbe06245b0e2ef40336825357a150004d47e31fd7186e8984fe5544841903c567e369106af2f095813d9ac293f0fd33fdd276663959a9ba4be2d14559b465c9b4a36e04df36eceb3dfbb819ae78f666f0272fc0b87d2c42acb5b436c32f09a7054c22c67cd424d963cbcd8e3cf3867cba4fca42b86995c7a2ae029d185def2e5f6a110772276b56b0072e83280a84197a3493c10a68ce633c2359afd857f3e84daafd470c1ae01d122f2e3784ed5bf65dee0d1cf64db7da4cdc57a902ec1a3a02c53a035f610243f3a96424bdf8457dc77cb1b614f2db6b419c7237c20d531a5cdc368f4be12fa4d237d4420b90b1038b4f57dbe6eac4d3d08aae42334722cf89b20d9200c33e562b3e7f349e49cc12742358fc07b2fdb091ffb05bc17074b97f3b71ecb1edb5fda16889eda874add5d9f04ddb61926112c4ac18f2fc31570924cf0104bac8f5a849326d54b11fa5bccfbb63174543cb21a6152846c1675451691fe9d4442dd26d01ab1957e51049b937f2959f26661c72fd59e3e2e467381d4803ecf27368a2c55a6a870a8e2abfd445a4e2aa139ce828592b0b358dd33a868d6f3d6fd2050bb9b8c129c0c397034aa5200d5e78208a1c2b47721c5156bb7111cfa2f0d236a961aab20e83b5d1b3b6ad16663955aa4ae3a3e3af6adec1357f250b2cba24ce4b834df96e2a42edd6b514ee42bc843729f302c9ea32b9d4899c4171f833533083786572080e9c56833f443457cb8168218cfab7f97e70f300c0e3e0c6314609f03462344da5fe2e3c1cab697583222210b6bb27926b6d376e20d65b3d8eaf6dbaf2a47d79fe24cfd9cd63605c426862cef8ff252271bc87faf5b34fafba8bc2e0603240b0bd77fae5fb3efb5b68894f35e2e7b4c99d34ee3be0b39e2c508c752fdd4d964770f616d90c401645d7eb64f9cbf8b537441cc69da8cd167fd80b3fba604173a7e196fde87184a89d4e52726795bec60105876c44bf0ccf3e82558a66ffaf28f42038c71bc1545dda026b2760c3ea4a94688d950895aa4858689b8f0f354ef423455898d64e49e0d73e102dbd21e1c79abbcc058b9635c835c153b008c078a882cfa4bf6812635d255e68353c81ce3b3409c67e0683061b5db8a17a2b86acdfa3a74ba016d980f22b57cbeeaf1a8c1f2791adc133f61ce18a7c6bf403541b6cf16b75d484c3c97368a69a4c0cc664f05be2e83bf0b35ba1fd1b5a891e5be18eac28ca51f1793c1ae8810669888dbd08a479223dda36708abb176476993e2b15738ac7d3650cb523d0855f0b4309ea1dc1bec23f42d1593a570f47924f4051611e3559d61e56eba5750364ae9e2b1689285f728431a3b828ab57401fd89475c2a418da146adcafdcb7e2f7341477a943a4b92365c9deca5949d207513fdab5c48928a56eb12d4e33ae0cf3ebff13c29f1aa2509110f1b969278c5395816a6350b5c830279392663bc497247eccd848639a9eefb594074bb0d643123d7f09bccf5ad20351876a1f18bc700d9e6b27e2b6ad86a4c59b200e605fd078b9c746679ab19839aa12e9d6b69dfca72d440f760b81e3c2493b50aea477ca643945f772b8ab43c0fb9f1e959d4b7ad78be45aad1d0a5d5dea039a1f88a469f1b92d798bd277001d3177ab7ba61d98baf8de9656c36b4e6f1b6c1fe3504237873cdba5eb89a927ac3d078544fe6fc8581c5e9c1466e423502144133723b88b469613ec9fe52cc5de585e16175320a68275ce9b3cbb8b1b33eb3e706b6a2677546b5602b08dfe5b92b070c8b6e382d9bbc92b201c0571c86fcf72b09c618564d32f953c124e08a24234702452eede397f81213588d0a1b2cb64b25a1aa7761ddca49ae035d963c81d9ebcb38c71159ba53ac608bef23486e0dcaa4a9727b9a3ab62b4ad5b6545214fc65213af9fd15d303b24e842c0d0c8e2debe10deec987c09647c04990d12a8ac10d4ab4c940be403f9239f32dbabfaf57c3eeee76038c34eef164200f53685ee69b47918c691d0162d2a0a3e9e18b3953b5f49fe56299b330ce804ef2bfb322f27c176118f9552fb1641a790d863736f3400ff84add5240ae66dfd476c1c24fe13a8c751f5501154223ae231615fd3289c37cc683ef6328b54bb94ad71df1a3edd696e1808b6a2d9ac810f41462463259ae83b40fb5f155cf978dd067716e332c695296abcd061578c86d063840a216087559fc2c7a8b754f06b253ff5bfc5a08aede20bd7c110258a79ed3f3cefb490fbbf47a8663ccd148915081020b6b90797351353c77d65938f5446626da63c7ecc2c71f7ddee5e092be5e036b387f52a2b1c5f676b5914ee8b27f765df030f5bbe7f471d2ade05f4733e03e6f362d84fbccaab7a2261148f0bbfa292e0dd55bf29fb18206dae4dbd70b8147ed0f13e38f379d6f6247d50b82b4e36684751feaee04211017eaeccbe1961e27f700fe28a1d89a5785ea9db933e559709555fd183148ff30e17e7e0fef0d2e40a13ed4360888315df5fedbf3832ea0f2a6fab0cb6c08df7731ab05ee78a300260b086e3371e4c8d2e395f03ca4265c80ff485fbcbc5779a081f8baa2f5871a23fc77fe3d2abaa54656d414176cd703cf33f6f680a0ebf40baacaaeeb97874de05e404676a11dd9ec8a7157dd4347db560cfd385a6f5301f14ffc776331ffeb32ea276886ac8041cc351b26700e55ffaaa3d1a97802e3f415f5bf0ae4b6353c130b208b399d1d8e0829ce0575b1bd3f1d8648f1810daf4816ab6b8c1f5eec965686bf76d45e934005a19b19d1beb4e9d5257bd5ca4591976439b1bf3fcd044532c4e5c41f4688e50789310c6d9968c148d49ffdc4e9ddb099fe32d14c337cf720f455574ebf98fcafbb38cb0face818454d6ca679dbe5fdc850c7dba7487d3211215aba6f9ea7c6ff82e3e2e8ca685d122c76e7df1fd2c6c674bcecadf084ef7a7e9ae8980d5857f42663583ea529fc96c6034710c8b68a9bd74ea5dbb7edeb1378a3420874d7c9454e675b31c8c47da5b6182b0110f382765e26939167e9b695c53d663f41fd6bbdda086fb97e881f15d8dd9ab0a9169257e077f08f583e904a4a06381391d040d55bba8af98ffeee54dbc28e7aff4d18b156990267af64a453704efb458a1b8e702a2ced03f8ac86ed987771673df7462777bfe9ce3080ebfbe93e9efcd22ebff12e0125cbb81f504d14ada6233499fb7efa3f31273ec61a56f9761b2cfc1bd24e4b8cfefd2f8c633023b66a54cf82a7decca22e2e5fb900a446d07947adbc9f1ee6edbdb0623b1c46914c7ea04f29815705f451b84cc3d7fa9b06045cb361a214efb20b4567fdab33023493ee6ba28c9f0a468497c1a2ac866c853c6e7a51dcd5b0015901f1f7ea7f39a7cf24376b6c4f55862eeef48374849f82cb797522825dea5781ec8cde0d93f82ebed4fd93cc53fa01402a49a4f459acdb53f1cc002d5c50a52da93338e75512524a2c865a3749750138987cd4d3fcaa0ecec5f0d169a18d49de24f4d6b427c471fa33f544c84c1dcdf9e6cbbb25c3fe8fd678d86510b917ab3c4d34ef4b216cf6255f14b78137d46c71228553d35a706ac846b01fabecb908590445194b4afad04f62ff673d6ca04fb7fe64650cc7c6a3ab7f5a809992135882bb12dfafbba03d7200e913055835e762816dbbe95843bd33cfaf62bb85da0a24d1aada2509afde4036d30edbbd7205030baa4a8b11b92b7c674da9f0567f80ee89d23fd9bac6f940f35b625b9dd2396c1ca48f27403950483ac256edd2b21ae0743610c2794edf1c1a11ac0aa8bd214ee8f71e97a3864b71eb4f16b123cfab67252c4b14a95f768117faf023acfb27fe1e4fc1e22fefbaaadb2ddaadfd8aad380f34596697f60b4a7834e435753e159e1d918d903f97a174182bf4d46ad655f4deea03f327f8c385782645a18d0f329618174a11ce1b37c0711b7bb8072b64d643a03eb0bdc7086928a34842a654eb7d93a5a10389e94eef88d4977a3d66a2ed2ff227deadabea76a7cca33ab6ded4206e9b0bcef9bee3ee05b77bd8211cc0fdd42c61a7b7c7e7fccbd416e1861e7e8d7106e7faa20a658b6993a0c2d2f4e93e40719267e871816d61e8bc8ea6dd6c6ec166b1569b1f017c5e365df2e25532d83f382ef34ee61f3f71868982418a5d8c0625c2d599f63948317dd07f3e2cb09d075cafc56cc561a111995a09cb93cc12bb535f58499c6fd248d55c89bef0152c40429c88aebdf65b497156171bd8eaccafc1a691f88309275587eb5157e2ba6bfb5d1fb234c74e1c86df1b956fa5fa795436697156c3093a1f65a10b027f16123b883d4a5a077f7ca769f0389d9c79c3af324815eede13fff4af4bad98777d1b878d220cf389e33253dfc190780bc9fb0856dee9586ef0b1d69fed2f2c62c1dc726f299d94ce54ec08427609c642e8752fd60118d17fc39cefecf7854ba4157ea87be1041e988376092045aa401382ecd26afc1565807b3e1df15802c5bdd583fb828ea5bef99483c8ba5270ce9e0866634364de191fd00f18232638cd3f0e3bb80efe64729d7e63a3cd89cb3f915f2b1bf14a68aef039472b165813efa70ec6cf94a7e1b8824b8fd1955f2625eadef0961c42a9c7d6a67f70809941a4984f024b98045eb2eadde314edb9b15259a835e2acb69e7dde401156c4fd0c7c142ada5c98ccfb27cb00aa059c158d13a8657eb605b4a430a063ad33cd377bc5702e733ad1d3fc81e471b29bf802db7e58cb880a037e4fba87708db9e058d5c9d70e015701e5e84bcbf481981e8f280aa41989f2c00832302c6b5e403dc55ed6c4df5f0fcb4085ed972593c195482a6f447e62df0e516d5a8655d4e472b81391d92547a24e9159d32e6843c486227106e4df68e6ae183e81f8bfcdedb035860a487c9f921415af15d344df6a6a5462530666802756a9261488578e6c969926e45e435e7405d3a7a3edc426095e3845a37df33d2a0b8b0f2de5bb7b6b5f051fbef8613da487de36011288f1596c38fa0aca7313cef3ef5d7637a0a631a4b0a0b3b2bbe83a808dde5acc8a4a40f0921442ed8216168f31cd1f558d814cad74e8444ddfe6efc776a3c60a5a1cb932be6844e8cf74fbf72f64fb6c83cf033e6154f485b899010dc4d3da02dc69187d3492a531effd7943d43c68dc4061991b5d564a3467675da3c8009b2b291f0548e8f3b91d60deff4102a7fc65bc315c39f177a745960fff64e698cfa959710a7805d3f823d6be0394ddc7bff7279a9c574b125ab3c7540e0c3fbadd42bcb6e765d67420ec3d381c938ede11a2a551994ce76c348f3170a2888f58d8c05e8812a6d9a7008ac3109f1fbb5760ff0a2b025303462aae4a2432cab0b9f9d997cc5b5d5907b7b4527692f3375960a99ebd7c3b079b83d1b9f99c79c5415d11f58d28f8ad732bc19f0ff34509c0d2683d9a0edcd9507b4f0b06a9866156bdfe8fc76163679c66e8140a410cdda79cc7a589573e2fecd240b914fd323e50452aa9ad809480453c6af2cf557767dbc47c58a4d883c5c35b828acd8e7406de383ae42cb7874836cf7c579af8956850e8e93a17cecbb0eefa0cace8a4ef316450025d876b182998053c68b4da5d606018f9c8f2eecb5353b9ff3d4fcd536403f6b8738074cc6ce4eea042b5082b885b8dae564fa799e3537f6e9396784be76b3a30c20a1bd4d62296f7058389fec5826cf88ea674c3fe784c23dcbf427988a80ceff5db66c9df096b3071ba5adf9267f2bb81cce8c23038b251cfbf7516539d9150bb4e9c7d6995cae47528b578f33f11942adac72caab0a69d152e75c46f217ce2c874ecc344b0f39c3e13a94f2543a6e5b2f14a61c347cde41268dec16559975fd9c9e08362b421eef85fd7ffdad8e3e500dc1ea1eeb6d16094b91136b26679ba8cce6d2d183f121900aabdfade65ef227855020bca966d4e9630edebd5e76d6e69461d02b378c7d31cbfaa5ece741109a30fe7d4c28cfb762316f9a68d88055827967f24abef6ba960b5f7601d33872ae6240dc931db753d9a3541f81de443f48f53b45a9e479db285732818c7a7799111f6bdf4dfc787c436665aabe6dea19e6721bb712803d1df9ca2f5337f50fce7232df966f7e91c137b5bb3e7dad7fced2fa44255856e3509c2f13452818876b9a11c2faec3be677c464b6571f3d2a4620609a42346b6a15b91afbe8f4617cd585494b8c9be83dcec7b3c66117aa5836066c2d549573075194eb02ae420f504d5774e54fd635a837405acfd075ffa4a5920852638f7907218ac1a5f8c2348fb44ac68facad50117fa1cbda214e77d4acfc3457f226c8fd04007c3ca12795834d3df886f3ab63fe355b8dc0ee91ac66148fa9d4d0d536be900d5d2f224ce0e663f424ad025f47c1537c6679ac16e9beb9900daa67566d685c4dfa034bf7eba4ba4433ffe8ce26a87b8b8b0009a3bd4cfb82667294b2c92a70c0d6987b73a3a41ccee67d5a0d4b85e0d3d8e82dfb8e83673a6aa10bfdeea957a0aecf481be6d58bfc4e6ccbf2d7693f2bb6f2b713b16314e4fed9eb9caf8d64b6adc9b1d56b42ba1d3c955b78b89cb24d99d63a159c9631be88206676788f5ce8c0973d4ef31537fb61d7c6399b9ece8e2701f848268a4e84382ba6541174356cf53fa9bd753140acc7b500b0a86b84aefe98bd4ef3b720774d22651f784de945d223ecb26e9194832652552ae5f1e780d3dcaf6b3a384f2f02995781ee77cbbc3472cf1aadae1db42f9f6355dd8414deee0a98fb4dc40e4a6efa862d87c63eb067e102b721054d442e2b5f5e2aafbc84b55110e800bf2c8bdd121247f53d5bf868ef5c53dcda0d3f48a3587a8277bfec2df7e5e8eea107af188929089c91211c43962a4123853b0d49be27db04dc4b18fd982903a2c4645f3c45ca1f853474ada104fa95f0559b6eb933ef778d742da909c69e30b0bb8d0132f1c10ba530e179c1078b64a6f2af67f3dc5a8e120db08b395054253103181ae8115506e3572ebc2affc154ce9b0b7e91ccea20e8fda6c0d00feb986073211628d11b8b253447f6aa2fb926ba11a81a1ea0c069f3f6ae6838fdcf1234ab65fcbab85d5657598f711613856ce03466c0fac36034dbb4cde37cd73dc1c35c89630a9a8048286fc3a0088c0129b114589d64b6dd4303d75ddebc049db08c662dc58758714464813a1bdd04a49f86a2cf0464b637c75a6cac75baeb30d867cb4dfe16594922339862ca86c5156c87678cabb0bb03eb60db0c3348a0076d4afe9c9d790d546ae4421b702ef7cfd62dcbec72f49696492e7dbe2e6658a3c7a7a273dc8e61fec6f2d76e9e678d95281a18eea80f31763354b99c4e8af267b3cfe5aa45dd9f8732090acb5e40e65666852028893aaf080920cb97c318ee2038a44c1e6a141a971266aca25a63620e4d05a59ff4be50cb0d2e9f1ff4d56edc177df291f98fbae5581c505018a0b28fcc6e2924a227505a4422f5cea51bd0e155ef8eaca73e3494250ce180671a9cb7dd7c8f0727542474609c7764f486b02cd1444ab712c2e7b4f1643ecd790527949244cfda14479c0c76bbe01eb0833e6b32e3c5fe2aa89135f9a587ee3f8ef4b7e7a8da336da221036cfef0c7dc2005a053506fb1d2953497ba162eccf3b8f907142107f5a64b3cbc380fe99ff94c6bcdeb44bddb4840f1e5effed9d5bb9608f3a05b63716db961d68aaf7d0b61f9dd433038a792e3888f2e2fd173a562c1f6f759d8f7e2e7c03de011583dde830a9a80d1fc3628b663a76a9ca374fa731a996e2933144d99f676b99cdbeeafe550e8a154935619fbfa835c9511b1d7cf1f9516d468bc9ba3ad55e62ce0b96d40c05bc57bd8ccb9af8c77ee88975f59b86bfbc5862bed74645b122ecae251a73735a48b120267db382bf9ddc0ff447304ca3406cac2e36f35ccd2777d45c5e8b227b723985199c1c5fbc92adf506ea6f5ea74f88d4f7f941f94574cbdf4f3c620a72b3ffc2e7ed7f471af8602ba95687e894f7216e9027748ba2c7cb46e9d2daf564ba7e19776c7657346755be3eb89d754dec7ea5fb518f6c55a0fafbe80bcab2f5b2a5824fe7c46fffc27016fc4a22979cc24d1fd2b577f12252947dac2514a5c48f36aa88b7db4ea5524f23a3ce9a5b89867dd1aa7d6a34805547d433162d5c0a04a941307eb1f2c8524d9fba0367f4d1a30f3b9aafae3d83693ed079a997fae19dec76b68dc814f7df0adfa1ab27fe36e0aa8a70bf7d8bf9656f0ace36ad343e12f319b72b62f3dd782fb2028ba1f4e18bcfc98ecb69f6fef373450d8b18acb404e74a96082f9739bf7436eab8871a16d6f3d54143930184dbfa31c689cc14b6d8b55b24bbe325fd7adc89c0c9dcef6424143c415b0e8a56fd7327860f7a3a300428f39a4d5294e49885920534cfb6f13b73a27de42294cfec5b96916066bb99e2e9751b464414a42f57ad18059e021cc265a36a84dbdf7fd403a3360556da7ae2fb424185cdff9636b5c560d9368a28030983872cc67393727eedd8ab79d05ab83c908148c97fcf9ebb0618ac6a6705eac18653318e2130e7c13fe3a477634012c43e9210a10d7aa413ef160523890011e2cba1da3d5289ff0200684ebe971a2bb340346593554bba0828c831b82106a67b8579524bfe0ab0c7605ab532e78c0de349a4170e8165a355553cc33fd1879a6d1ec770e1f1b137ff834859a2d4a35d1537276a3df9455bebe1fdb86372791801c97728c71439dff26d6a48127dfe6bfc74d2f231d79484dfa3b9b00adabfaca7ac6ee751eb26e2a4ffd2c748e1652eaab30b1720e1436ef5732b37f106682f0aa50a1e4cf7061821476fed90c6e70eddd25e87efd5fe26432f1ad9c3e6e7a8da28d71460d3944aa444cdb8dcff0ad5413e3d6943f84b26505f90d09bec520a5f5faf7de776b636889b3fe7201c08fd030378acec1deec147fbce38540df1ff60cc9bfb09eeed2bbf859f157143d4c3ebf224afc910cf40af93eba2cb36c80bebe961dc27b963660590470f54326968b7a50dd2406a891b0efa2589f5a58e57ac080f38a98f79cb45a0f2f2384d46a3d4b5872bc16b051e5efc99441173262d2b0607375cea3a81d77105dde639ea5689d3be8f62390d832abbbbba8e29364bc4ac71967db838d394a74425fde29eaa72418381af9367ed0a4de0de5986bdaa9153e104730bd882444b40c0cd07dbf5db9d538d251fc8d50b1d1a693140e636e39b9296b629198f6406fe9241d546f4fee8cfa83b8aee0baf29c69893329b0830737ea039793e518da7ca73195a6464809fdf17fa00e63b12a943b3a5773c40a53e0caac3b42d892ab3943acc9de32a9e25816f488b5eb4fd7de11dbfd145b02d57a78d175d5903b0cbf5b636b7b7d48ea875d7a1a8b85400a2fd7dbe62dd2e4f480f990210cf4f4e7ba36812f66bfd9874e6cd573abad2260940c01077e32256f34f5b35bb394039575d720cd83f3859b5312daebeec2b9656510de8013aa8fc6298ef498513c9b1e1cbf278e4aef5f7828c1df98663dd726c621b6e3fa1c438fa2ad5743a5b0f6f58c8488c8ef689b8a1f9ed3700c2acf8d0d04a65a836803b1b265a1de48328edf49e233b6d75a75ddf2848ac04c10d3528ad47539bbdfe14bdf7da78c24f7425b893146dcc783a0ecf8884a459b9a0fb23e9625ddda61f31f35839211a091149a1b7979ae528a5b54bb10ef61bdd5b35015ec53c5be9cb471789cd62d422f733ef5caec1ab153147db72383d3f060fe366ba2e56ff255f2c949d86e1dcb0118ac195587d40b2fbf7687ad0b1c816fac2ab77a12895c33544da210052bf826e6a36c127d3e8c8b2b9a9769a15208d12688dfabb38423257563038c945d284319285adbcdce4a1fc51697a1f33ab3adadb5f944dcd11bc8ce3010d152d6422efdce1e7709a0fd3d2748d147e6adb93720a121fd339a2e25ee3dde399db5336e668f7b3e89a17ee7bea09719ad5430913225527f5e13446c441d91f99bcb7ffb92dad455085e3879faa181670ad50fa96c906c37eacc8107827b03180908f532ea2aecce2eb5b36cd8a8c31e661e79e18500517ce2771e8ccc051788d9673f16ca65fc95a467254ff6b8b5a2dda5ed075d9bceeeb614c579be28be2df8d1f8ed0f53d2a6d01ab5abe81a3a7cb4a89160397192d469b31df684bb05d23edf0f5fb5d331f558df8507c8f1f2227d4b7d3227f4c5def539b96af8e09cb5fed12effabcf67e5d550660cfa13def81a561781a35712f93b8e43b077bc6290566df401eafdc00083daf7ebbfa938f85dda1a9969aed3436a1c226f1e94d1d583920ac860dc5586bf1a3ec6350c1363d2f327351a4d6e40e71a502718c00f2fa0c96c2fdabac1f31f57c05757802fc297d0b07e8da9116898659b742690f11deb5dfddb609de2dc335dbbecad81933ea880a6e28e62734bc32928fee5cfd014110ab16c7fe8e6b03313034e570e49c2082a1dcf2bba85778438a99aa69281221a1c286fdeb14b9c82d75c12192bc11637a84896da8dbfcdb408f9397a80e9aaf65e98381759142d6cc2ef9ff0d830b64535bf8199ea34bd9923c1afe29a8ddff1c39e7cee9d3c1b58c66996e4f20e779c090709e7df6a6d9bc35aa075eba4e358c88b966261dd81865dc2fd183c1a0936dd3e74ce64973781d485137d106b9e6daa6de7b448f7f7245013d455eb89207b8f27c8c707759a3a58791e400fea10119336baa00b23667e31f4098976e3110aad6a53ede013b5c5074a9bd4a1e40b96573354091ecca4d8004afaf609f6f7288a09eed7a4a7978702c29aedf2bc43129719cb8234609075de09fd4cbffbf566cecedf9398e990a916ac76f87c26443e24a96ffb70087c34b5e17c051ca0acb9388328a2579a9e3a055c26a1f487dadfbe41530adddbf9febe4d251d2c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
