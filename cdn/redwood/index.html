<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"88939cf457410a09aa38da1b4062c02d2b922981fd5381fb75b38fd94ba0514457e1ce8c4338b5203daaa2874307fff991eac5ecd39b7725d0dc753d1d9da7e20cfef6723d7a4738127940616c8f7e75bd427fcc13a86ccc136a1de4735d989e3501d6be4db523ddf413e5b52f7edf8bc23c9def5071ed5898fc5a82306b0f9fc087fdacb9ebf0b44b2e738939e4c751c74611c08cbfa69ae343ca7ca0b9277eecbc2933e9f31d64a8a221e8d302acf89ec4675fe59f98fb0837795c65a54de84e4b6ebaedcbb543470e33b27a1a5a4a47228f2af55d438abc187a395730732adb1ecada755c8361e1815e1a9deb43c866c24296c28311f1f6e1085b13c72b4b90f726690db27621f2a8f62b15463e777aa582513676f7abcdb9eb25d2b5f1f109d61a5b94bbafc4b3f3f045652149fb2aeefc8bcc6cd988c5a3218d281b564ce3899c1934356c75a47d63934d045425dd0fd97814bb811104c752ae6e6cc0535cb693f858868181edf8761dba30d5618036041a87ccfce2845bf2bb7c4c98abdfc7f649ddc4f2bd053bdd40500da2f2e5eaa8db2eda7c13ef2a06734c4cff16d27b024dc51278d38ed449f7028e874b509a02337490d0add26e2f066ecde345af03129b96bdf1fdd435018033f6226c2025f145fbf407e802d8139576312508c967e604a520156229b0690ef431da81c7c2cfd23a8e2e98c100adc07c1be8b0f8491b85b0c30f47d3670d2b6aeabbe967757b9497ca36e6d0303dd27f34ce2da7925a7daadac1331128627c25d570b6995abd4228540ae56a40cd238f3247cc70e3d8fb4a942585c337ce4209ce70b2e5b161633346ec6a0306f2218ded2756e9fce96ede29a23bb33f4d6378d043e9d36c4719c541517455a3c4a99f1abeaa1738014bb67090d3ed7e19a76a62f7d52c703914207634e06f05ade9d0074b644308fc42523df022c026842dd718f9ed53f3fa8567f132552e5b2c31ba1e52d473c2e27dfcdbfa2a4c4a893671713407139a7b79978df100067d6b965fda7349ce015f05b75a51322148f2911d2496dbaccefbb72fdb40d0ca03551a864d2b05af02ba2ea453a9e3ad11580edc8a6fb989f3563f469ea8f61aef359951473ef6beb82fe28d01571d06d7a6cd4c019917c829be12236704cee0220f8fa8cac7e2653ad612c46452ad60148ce55c2862aacacc4d2e76a9844c20971bffda04a944fd726addc32852c2dd4f3baa8465680321e3af9e22cca9ffe1aa72f158e3fb08279fa8fb9dd28993df4797878fc982ccc4959b3b5880bf09cf97438628e345c8a9882084e8584cdefe9d08d6f6012abb67b6bd371976a1aaf0a05d335ea89e8d235614f3d1e616417f7d51be332792d01495cedb2e4317ea930053266bc06e1692c2deaae0d0cc7888352f9ec8f4e58f673bd4e7681c8de246c815090d120a9e26211bee6d38c328dbba5e1b3e762b7eb1228d9aa2ad80feefc4c506ddae18797a46cbc0e4272294cdf93cfdc9359766047a7240d9aaeccbc90bfb94f423b5de5db307c5aa92b027cfc05f217b19724a4dbbd9539805fd962ef9a5ea438fbfd5fcd93dfb89220cbef4f1b59ee72f2caed1036b18842621249a09804859f7aad0868edec4bc790051a2e2cd351585ccd0b60da6beea39546f92456138143bd4cf78a345588ff6809202b07a738ab7a9eac762f4b80982f646ad95e025458202691ee677f57d4fa6ac76a19647a5e5ded47e963111eedf697717d5af0402bdde978c05d92db673ad78e03bcf9b2cb53184548ebc50b4e5b146089382a7d533551ea05aa877f7bbc028c5ba6621963ba93b3c208f24c727bcbd592f0f8e827fd027323b13575baaf4dff519f257c6398d9dbaabde9cae55bb20b135e9c172c8c77bce918835b7befd98c2f8166961d1188eac1fae49fdf1401a6bc0a87ff87adebc42f2b64c2bebcee3fbb6d8e16f6f17fb7929c351f7f651888a4d3260fe01dc6ee3cb186bcba8abcae54c153956b37e5ba606dacedff1ec2bddcec929168884be5fc71878d9b2433e2fa6d555955e8c9d2acbb57737a7ff628e7c0cde4953f9ea30de509b4cb2f7a5653d9a767e1a575e9fb430b1b3c4a3989e9cb5ef57b6fc4d58db80a7a31ad4fd27c963f14c08a8656be18d67ec5383d290de983ed004ff93001d69552f7e0d66b6994f412aba4099b6fd3fadc55cc37edbc2fc6e53d7949e6b4d062c35b1f8b99eb9a2a723841ba2ad504c8e16107cb7e1bb878d2205ca597eda337a085ac7c8e59ff02c77b1e9c61fd1561405afc84aed3b61cfff4ea1f95f773436f84d96f7b2cf9da72c4521f680253c0bfb75af7b86111a4ba3a752dd49df6fcdb9ae98459d7a2645b3ab5919ef663810e89220526e50259b5546cdbd538b7d60905cad5e4bb565b5f335e28af01c5a01a90b3d92675ebb709933d1cd6935a79feba2dff0225606b367c402fdd19c682cbcc9b4f58a23bf5debd2b93f358804dbc9089648fae21a62658465bfda882e8794dd0f8de385abff3073b185ce082579aaca494e5e7a102d322a1cf32eb2251d477e90c3e748ee94f6905a3a1302c7bc0a52b79319f8d15800316fd188c9d6f6dd29b9e6b1578a6dd756fc4ccaa4b09d2f206c085555bdd070899aa7f0f18bdd51a4c3d0dfb46deca377f89f59a8d663138901cfd73622eb7b634c92fd6fc41f4db42807fb1aae5f4e27d1eb2540ed23d4f44c7ad8bc7af91cd35bc20c95d14f7e9124205283616af1d249546a05cabf12e65c18c88982c90df92903725068fe30115f8b0e558777c398248a5090b81dadcfc6b183fc35de161f0953b54b36c3476e13b33772bfa73229413dd17eea3a87b2f4760429e011c510b843b0c2c27557567a1d50a8ca02de2843deeb2a1c0a4b984d3cd62ccf095ffffd787f2e30fb23a98191cdf7cd2d495a072c787048c887a0e75a13332c1e31dc517bc55465293125809d5fb998749831b74e9cf31ce0a086c85e747e05d66ab0d01bd0356b8e6a47f33aa54ca50c32462b4158f39919e5bac8316111fe3c8f05a238c21049648809bacacb0418e49314172eb02cde9feedb37418e720aa13ed7d216efd119008e5c8f61b1dffd7dc6ee559e7b4b92540085abd365930c0a8db163fb73c26fe27167690c45b1e44ab53979a120d8c6ec57ffa065613a03ae8940a50adba0fb4a1d0b303134068f70ab88333a63b595cb6fae51deef1c7154cd6bb932fe28db6e7a1c875c301c85da3cfb22ea03e1f3ce41b9dc3550a5478277d1658b3aee7ced67199221510ff43f31b4070a19b8790343224627ac59ba095ae32a456c3bb35e8a8e8be887a3a172be881866666310b445894b1f6ac226a3836ca535efd056301f3c9589fda13c0003c5c0042ee32a5e3338265579d7fc2c3755985ac51f3c7d3dea5825f202b4bf22ad5fde738bba56fdc22eefe6b7bbf0a66ea96bda1e4c0e4bd2c3373d1da1986ac6bc53f414362b3bde8cfc04994dca93f0ff2e9799a58d8d0733db541a587a6effc54310214bb90d4bfe86928afa28a001337d7142821e1e49fcc586dea50331f1cb2614bbe071e8125b873e6a6062c51f8237612b93ef0f40b356b9cd553cf7820c49ba212ca1678a45b974f4a2755c2f467bad71b9116e7710d6dacf707c08de430768074b6c140f488d52bddf7b71b70065dba17f54807cdd647ed8dd0ed1defdf14d14afd6947b86fc8374c50b94def7040fee8f4f88943366ce577be8802e676270e79397098e0bf740b3e62d9826d9e0a3f9b0d5f7f2efff5888a4c1a5659e2edec18ccdbe41d7fa7901f3a129e6686bb78e46c32bad2e46fa82f4537b08b72f91c76c559e33968cbe54692e20da7b56ef37ec4210281a4617bcb0140937d77fc90ac5a5498367350c26002ba0e890e0a9f665ec5636f7e42d49df28647a3c55e945e5a1b1a4bb9dbdf719e7a91c6683645a5a85dfb631559e148479b5478dba852a3c75abb262dc3d294a4bfb2365198ff3d27d0f992d2fc7d6ba63c64e25f77f84f99cad462bf64931ecfc823d65c5da3286c93361de235e5a9e7bcd351fbda878adc229ad3d7ef2027651dae04cfb4a0c7d239fce4868d96c2da3b0047921bbec70c372a0b437896438aae8a5ae9fd199516d7f5cc231935e5aeeaa5226a2ae311bfa3cb68abd2eb6287620b0e8edf7ebe43e52504b5835e95b8b8c89594f4c5b13e5071e1af80179bf2be72264b74774a36d0ee46d6c775fd31c67b25bc1ba3900140be43dcd7b9e43071cae32cd44ef83a743375a99923007cd0331ab75708ae5a4731bfe38b6a9460b98b16bb4287840b5ea310e6a7ccf0e9dd45068d22dd3a77c79812374023ec229f8ae056fab897cd5308a1a910410ce37ba9ede38fa09ee0f2b719e2f71e26eef5551a9e7275420331d09d4779bc65fbfb469cb49f498945a90eb812052e9347bc5c269846f125dd50aeb6fa116e96d4e995ef181b6f40e2a49d419305995459bc48881bc600318f2693c4862840ba01761a2fdbc2b1253b21f4f7a79822501ba29b086c103f4c11185c3836a8d54028154eb5693eb986d91d54675268eac8ef0de00057a22547c4027ad9e8d5a9dc2231c56c0e65bfa74224a104edc2125c7c7d7ae268dc69bf7a9d3649e82895f7366ca7368c58c8f5620200ee296c8ba83f525c6a4d6d54f0647225a115874a42a76d127aa1fa88b4b3a1d371eb46a21df7f8637d70756d8fc843ca7f2637ecc9e7a9ffb46ceb10a15a8bb31b9454c96f05ee958e1205ae4aa6636de93cc13cd54af489a8b49ef8077a1ce8da2204ea6af08084c4000ba20d0473b266a60e9cf8b8079527dec8fcd8f4bf46fbb0fde81473f8fa9aaf7831169eb8235f72aa962dde0faf0d24cb9ddf6ce19188df9b37a1f861be934ee149f4041b1a5e11e0e2c3c70652fab08b5e7321a49e524cfd775e5092ee8cb784c1a9c2fcfc861aeee69e80d3a9055d0979ae665aa4b62f930b85ae88bb91bf642c956dbc8c116b817b378a46e7289760f7ea7c5d570a6b5f664485ffef1caf32074d6d1662bf7584251bd851ae9d5c20c42dd2aa7e3f91dd7e8d08cd847149cf5947e3473fbe474c1246fb9bb92c10e2ed6c4e19b889be8c4ddeed5307524f9b308787d225a5fe2b2d736502b1965c6500003dcde1d978905b234739f8dea7e684d0c331f579f5a963785c6259f6c397c0b148bee7a8bf93858fd616d50b13c84d5420fdcf4ed2fc4720d2b0a37681d7d928168cc0026ff5ea4fce7a077c55f5efae51e8cb47d3ea4f04d45124aa0e0fe160c7f22bdcba0a7caea16007b2ba19cd97a61810493165e156b64a784085435f39c268833baa70fab5c847f6a6b39276521868f6a03a10e36527a4bc47ba3134ddb35f471335e40b530a2a3d9b8283b6640455c1ed8f59d0f0725c3758a0b066089044308a8c369d96c2f022aa01f24e6c6d981f084a854bb259228656391831e5487138f538cb89baeee221d92dda5a56fe2da4b9ffd8b915ecbdc05d22c4c1b33e0e8040a6ece04d07eb563c9c4b00c0950cd5be4436bc154e1f5f1c0f5b18ef66b3846b787dc3d4a15f81f115cc318bff1b740214a56d43d2a529a2dd770b2cfdd77ab69465335159bc6e4d95240f81e74ff3dcf660ad4f7c71ef77c48d2765f3caa690ef96a3e4abb55b9bf6bc6ba0d7cfb03ab05e296f5b61648fb4bbf71a4aae83c04258b8178af2637671d443b4c9fbf3efb5348c8d8045e4b803c4df0eb5861b22a1a087df1c6264527d589fe9d47a5da4d4e9c7331eaa4cfba735ff3170dda7cbb1dbcb935c383172dc7c3be589a61f4eee2fcf12a9f20857aad425513ad799eea00224e73ad7254cab8b4bd2cb1492abc90c8df1f7fd5b0bc43c7b8cf14841c91944060ec82858673d748f57c3854822e24db9ebbc824f28457c6eb1c4d8f92fedee6c6240d4b7976751753431fbaff87266e4c42f3aacdeba398f49cebc58a4dde5552101208e0e5c554d8eca86b60a2c5abf0d405e00f61dd1b10077341be6cd09c6f1d8424b7c889ad3791d0ed7a06ee498c967ccef844371a1b7048b80e0e39ca3e2f80457b563ef881b7da91c30bfc95830f59c889c80589edc6dbdffa3d4f92cd85bd299354dc74bdc546c0d915c1e1222a7a740e9b82ca0ba445039ee2b15aaf1fa2f3abee0842cd6ff54a6c7027a9a4814436534a480680fd409172fd883e7e37e966c5a50b0c4bb43497d53ef3ff57c37a9ceca819f1ec248e4af3de0104acaa5b3027d6e39a46c4eb02c5dbf8c5fb2a549b54b7acaad6d1a407d131a6539837a558d97df6c55007f6ccd5a3d114600a5ed6e4410d86b3cc6037da898ec6af24fe548bfbebd8e83cd5846b8fb7fc7a098d662e99dafca57328f4211bd7a04dc982538b111754c49a48f329dcd42bf9f6b8ff642ed6eec4093b9f76193c8f86a507780c661aa135f9969e1540817ef6a1f319008ee40f4947a8263da87b4b308128df5b71bb584c43afb842d4ac59ef5eacb66141d377f4b4baada71475aa27fbbf85956a82fd50e880191200372ad4f94ff963d50812c9cd5d42e48acd41ca7e48103bc07c42db6f90527f15008e71852f699153b6464f06f6982079b2a031edc66462d948b2960576e0ead7b069ef9b3e79434d7753f91b45520f090fe79b940988d179db563f2375d0ffbbea5aa6ff783b55fc1c7bd4ffe21128276b8279fbd30059bab13659d54ac107575bbc52ba098717901737f4e454560990160636b3c373f14dadfb7cd8a51c7d369e6d46aa1ffcb1d58283c4a98e6054c589cc5b573242ec520033f97ec40f1220ab87de75a8ad8b92712b97fee96e97a0c735fb71e2b7ffeba66275c2df7fa5008bebb6152860b80c810cad5043f16c2f76c499838b208118aaea19882f881d442f0d98f42ccc8b0652ff6c63bfd92ceb7bb29e3ba0c9a56a5dd02ab8c9ebb84206903b02f606f51fd2e1779a29baeff6b0622475fc9b285b5aa55a2fdbaabba2f565dd8307ecaab7e0075a8a4035cf8ad9919433cc8b321ac8a7986cfa5ee02611039624a593f529d2ad83dff796bb687cb37b5a74c9c497105d9748e8e2ee900f680219e36b817ed4abed3b72a88f5c518e3b107325af4b4412b64f2d92a4a64ba950ee12969a601a003e31bf2cb693bbe33c797ee1bb66d1281d70a643e444ae0e132340ea427f998df829435fb25b816e490778794e807e52648443a8554bbdcbc3a41774165b22fc9d36028d51f5e330d8c4077b4390bcd731deb9953d1915b68c265559af124c1a1e63685b2dce17d8d17ddd0ba199fe64514c23b00cadb358130e27ecfa853dbfd3558233ed2383f5a644a7da00c82e10f34b903ccee745682b9257c97e4083e9ef44fd550245d26ed31d2ec2049d87a63c65bc5cd54b698e3e5664561f1a2fa54701fcf00fb3f2a909a082b4ecaa8ea75f2d5a9b0af0e63a65610b7eb8eb57dabe7eb2aed1bf2023943839ea3e488220a17e3dc3268f3f6a90470e497f2f5d9002112010a7eeb42eda608301c89fe61ac710490e44093d2d875a7c618012a5870fe1978a666a44a1a800455f17584de2f3e1ade5eef84c9f042cbffefb85b74ed06c9bdfda714695e612c18dbe4c1ae483883e7ed4236162aa78de887eb9228d95e0fe2076a56a0c44bf22dcec895e2d66fc25858191cb1498ea71f21e3c8aca6505723b23be78921811904173fcde8a4b28da81c6112aec0d9fc46d5690c56a971a55339186fdd13099487b5d77e4e32ee651f9342deee3c3e30e301b775b14cd3a1fa964b163d0c6e59f58a03bad67b9fc50256b9aef2d7b07fb26abb974745ca79a96ca6d83149a88dd67ac69855ac2504f1772ce6209e3c678b7a3a0dfe16950b4f231f35592a84f5968f2b29ece20713d3add5fefa429fd8bac1d1755fef9c5863e3ee1874597dddf1daaeda12dce03118941967f7e99a2d6f38c1c450358b0ea7823a63b8cc8fd249178fed0821e5769eee9faac2800845161babbb696768f6b006a63381650aa61906e1f3547ac96b17c8fe6a6d096a9a8ffd04347014f1f0f940bd75ee36cef609134bbc4d2ce3654d21fead3e0c9b75c8ef8efee19b62d26c88c015e9f052d509d6f353740b4ece764c6450b87a46d2ce371ed96fad01b57de71d3e35c8c4f560172b4e8319981f438ee0b54ccd4aa45c75682698daffae33fbf7b73f76fe0f970f7e749a48aee26bed361089d574b1cfc2c61881eb6515861c5a955c01413b4f1f37b4ae6e090b2c7e87a1f46ea1f9f5db50255ebbb876b6f7ca03ead44f8ff79dc249cb2cf40bc9036af98eb9a2c859265a568c6627fec9d06b099be4514f21374f0eb9ed0706b38ade5f7581e6f82fc38ad8667decddbddbf4c69b96fbedcf5b1aac41171f14c9fa1f2536f654d9e704016f514a4fe1438c9bad633b6b4fcb1726f6dbe8226f4fbd02d14b06dfa48eb94d49484b4ef9999c96db663ec34d8aee72ecc58d3c4e5522863be48d5188ac435dfcf71b417b9ac9a27803bccacc4adbca4023b6f16d96e2a0e2b4d98fd53e2f31d1198753360b2aacdb35491b42846abf35adccee57e3ff4ae7a3e1c1aec504fbd13905adc6d05c17f2a9518aaf391488c6b56543cef9d1b4cbb40d387fe057ddeec7432a336e4a182731bccd9d1f38f439e5ccc35d752c5433535ebff758eca3ed0568c750e2758d6fe9340be771868f5564ca0840eab34b5535c994e2f559a4d9fc48619fadc8f9fd166b5472f6f57f6661731411f90cdb0b936999beef6902552e2b411586ea5813d4ee746ff9b2b7061d6d744ec28f21726e5ad1bdd525cdb22d384e2238609ec71c41a31b9450a8e0119ad4fddcb30c118ded0afc351776f526c2cb3f76bf106a3ef28bc990ef0e70ee605f0c9ca2f7ecfc7aa91c9e4b6c9c7a8b00ee181790919e8b69c5905ca0ba7af1003218c5c43e88d76b93f24491001daccfbd0b7b26145f96d9934066536296b3ddf2e33d9a422cb4cc0287d3ae3ef224c7aed11f0228272a15759dac8407fe6559457d556b8988816b116f023ea9d20de812ce8e28a018cc06005489a54aab6d3d3f6d69c7f19f0fe119016a20ae3a28c72bad666ad6bc371434be1c981d1b94af2e0fb557542086fdd0623b54ed6a4751befa2e712e08c66d7a3e462ce84651c7b54c527be5e3d9d7e03837b5b16a5c68841d57feb4d5f8e89dd8247ce5ae436c6b8ac2c02d530615482b838abf1dc1611fedc6196de468d3e0cc88b1d00051d1c05b95483943baac5f47387254e87441e02387dcd2f3564a978d3183d045c70f142fcfab76c9d7028135ca8e3f64e4cb3898e12cdf2d945401120eb7deec4ce64acdd9d8dd10eccd6f5edcf4a9d7407ecdb034f62d40b961a706db0c9064c6c3cbcd2d001e4b1a95db9434076dd7bd38f479e47fba788267139cbb7398170e233ea78b4d98fc67f998cd87b6b53d7c6c8387a8c3189b5226878f5d2afeb93a4ea9d0bc1d547ae9e0dbdd6877548f3f79f3f8358db6baa4a7bd18428fbf0050c2f6f0ffe0743089f8c5491551554a53313d2f219eb30501151460562ef5e329bf72a3d8cc837c746b88f63d137c831eced02ad69c41512d6c5fcd2e09bfb3c41a1bce981ce9a130899ec3824bc737fca8b46200640542bb89904b2c1511c21deeb70ba6c4ed0cdae978da88d1fca9463aeb4943bfeefd33b54a9adaae8adc214e60456369a93d6b69666455df17735e7b28a92b621eb1341c4cf3460fac2296083aa662c97f78ffd131222f8a48e631c1573d263e25dc80a73e7c9ca5b70d772c69ce3aaba3c99be9cc54671fe472d0d41db8d3420233c700fa13a59b5367268db4540c28d533f11b64ae470b6d86500bc7f87e49b4bccb256c14f439ef668baaa30f859557faaf1b0f83637d0e608711e8d69c03ef1e92282c708e24b10bacb78824991c6eb82ba1659e6a99f387e290e4ca496b5257f9cfee667a212e9168877b913c072e744ae94044cd48b16c860e86bffa318bd3bc2e10f6edbcd27659f8acdf0f79b0ffa8812eeea8d24c71c40bb3b68514f6782a76f464f13134344cf842f420e7f2fe8a90856b942eba1b1f11e9adc5de3cbd9ea1b5b8ef51edcc1c7b98233a1b82c591cd08d8b2beebbeca39a894d51804a849ff943949c64119869afe539ee18171c0799447fd27eb5c40720b71f18b2da95937808b0a4e926646e8b45399956cde69f57742ae6a7cfb1371871a719f2ea1edbe06d82d002bb866a69f8afc632da4bbdc55fb4441a22f5d5fb97452af3b7e55deb66a052525dda9251a7ce606cbba6bb3d10baf3436536c04fad5294dba3962a31544e39ec679cf644d01c66b1997166c254d86b994a05e03f10e454c607ee7f29d0522f633b33fb6c391d60443b98424d44d3e0bb1aa80dd790139803e1b9d2ec35d64d2bc647683e4eca8866508c64eb614686779651323d257c8d1037f5588979373528d52daeaf1d4dbf9cfe031c7fdcfe580ed7a1d1e5ddae87d0519058783086670543e6f567ea010a8bd8c97bbda6e44ef76af9bc4403608be9bffa446ac2423f27689d669f19cb132f09c8ac2a8827d9f32e6ba3efcddbc51458bca27377ec5692443656937212d93f0a6e97092a871e00b87a7e778c3d8ec56ff312e369c13e2fbd420fab8e58581febbac0ecdf46adc8aa1628cd45bb80744095407bc2a68c52b9250b3bc6717762b1d720e14522d7d982178462be77c2effc007654f4f8ddb06c6dfa98f9d55c3d2d3962f94adb52bcba4e411435c8389b77b7d568b9b6a9ec366210acea8cdaf3f3d40cf176066bb0945a14ca4825e6c307a3cff0d484b844f612a5ebc746538da0a823ec439443248c5fe8040da6ff0439736a4bb53f713606789711cdd0035359ddce8615b4572d5d2219b390798f299e773629ef38bb39966a16ee1bb94fa4d372957caf643aee49082ec94eb12faa032100c14faa8a53f7a27e5eba0f97eba59a6981a3f2b773eea5c9e0422d37f18be01a06641018633dc39289afa2bd6bf845c6d7e39d6f3eb47f87be855204d29bf1b15ff72007ca80a2465e70764fce8e9eda91e66496e1c2a9772f8f36cd58100b5c0955c211d60749661aba3938787c514ac1cdc037538543941ab1558ffda2b51128fe654ee5e77597d18cdc09297754f7d2f0984703fa78b960f53afea759353a10713447d62dc49fe3b0f484ec18c4e34b8e17d8b8625beee7f570056e58ecaeaf2a96fb66d1e05d2488f9f6e27e9f1bc62f6780a2b31323a7ae6c03e3217cc0ff4c45dc707d3e3705998edb97d59bf86a0307eb67f5f1a083321ccee9e572f71f6ab7371280aa565210288fecf97105bbd23dbef43cfe9a8498e7750b755619073be9861f3f69d89325cc6e2c0c203842408b2475f148656b656bfdaa91dcf43099067e9d82b7480cfc1de347c1c3b2da07c4ab213dc32a74479a2ac2a8cfa784b0e9ba737c77cd8b0626eb49074e3077a2a91564701a8eb7c9e3594307809327e1ab1cd5ea1f169bd193d77de51399c14ebbae26031436c0e3c8c864daa0164df7638db0ce27ad175395772ba6c96a3acc977452400b77f3b7ff034147bdb1a7e1e672dd85b97fb913be33f25a3dbe9ea20afd20e48da0fafcc588b95f71da0633f4dfaab806aa389f2029758e97790793aea0ba7d318b64a42fc5470ac9b877a3bf9af3825f708a1754d54e44815a07fc39f2e53d581dd3766ef32ff334c928bd463fc8cfc882547ab48bca2222dc322724f8828672e87ec61d63542de71c44fff2dc5170c562f69e782ca910d78ea2c21e8971c38d88384b82fb0a686f1192033ea85d82dbef39965a8bc4b11f1bcb782460b7253af6d482629831933d8922e915682c49da62d30f82609520c2168b57b72431ca76cf76c834c2938379bf015aff1aab7255f5924b43fcc79c6f405b180fb2d5a8259b92741b49bef4de505839c0b4c7c85fab35957ec14f28ca2d3f2da3977a81b0f402f6cccf4a133bd9af916ed2889a3da6a3e946df8bd58adf0fc90c7e4c67c0b2c2e3728093845065803a90cefa4b2c129b3637663a713728e68d7d538af547eb43fcf0832ea70dd396a85c33dd473317512255c9afcd3a5a3aed7c04009a56740e0ece1ed83a966645a558dafcb26f60ef9eb792dcbbcc76332b081bd522bca08144ba3c3b2118eeeee02e1f7b7c21f9e856c7f39344af0de162221dd497e4147844767dbc09c6c5892f0059ad61a75e597702d4224c049cd4353dfbb3645fccd620c59bf194a831a3d4de6fe163fecd33f5a3cef85934ebfe8f7c582bf60f6b434af2cc969c1f3eeb3bc67321522f1034ac0e8265f1d32e71d31103184a1e3d1fe2fbbf20351d21ec0e604b7e9e8ce3e6dccaaa4d5ccc3207d2273e6f2fa611b9b74e9248dc9dc3dac57afc5480bd6db4b77a1d6e88dae0bbf214fa458d9735fe535b21a9c73dbe6c22ae56ecf72bff265d353e486e82fbd33e4ec3e8ca88f031ef27cde775830a49b970b3558847e97eb9772e4024d53af5e4349599b23db90fbc8be16aa36a691bd65df2aaf507e7badb99ef704b05ec7f376ba30f4f14a30322f454711d9b43df45b882ceac37ce448e7b08e3ca128b5d024b115eac28b76e7965feba47189f0d5652c0d4e1d6eeac9f49b2dec248b267bb91c19fdf85a7b72fb713d0f23a3fd597f4d904415fd36670a54c2776db6c2769952f725930c9de38e14d5e7ce82c0db67bcebbec0b3db3379f1bb4095bf0e5099f78c473d7a485a9f358b7821f51bacc072ebe4b9178bbaccc188ab1b53eea1ee5d0f3cadc6d7347343e0c9a251eb1f58658005fbb7807ff65ae9920d9e5410a5241bbdd9a847e2239d93ff6562551a904ff1df9769c15252759310c079dc09b5c218752988536b5ca0a57ac6a7446661bbcd029bdd98173a15bcaf8f217ad44443649756a10bf4d505a0385818ec4a1bbaed7e53289f3fc4afce52bd3fc84944936683bf15f189a53f55659ffea898c45cfdbbc84a62608bbd44b2b7cb61907276031a5046a5114b50d8162e846e05048584fc6004e19a84d23301b824b2c948784318aaff8f14261518248ace0396d7890190e66d824fd60832dd718242414a57299cd705fc5202606e84e47f204bd9a9445366a8e3177e9a7c6ab0fac160d49ed292bc938941d46725699aabbc9459a9b8beb7cbb5ddda16ff1044fb72c4244422db54e645a61b7be58ee8feaa301da6f8aedf3f68c5b23bee778ae853908983269e99e5ccb4c608785d2e0aeaf3708d0ec68db6a8ecf403d9a345ea47ab1bc0a890b80c22ce040e87c6e25e6c254f60de3e12d93542989cd44143d1243311f9f25e0e0ac3d50ace543ee575284fa9e7a5711c3400514d39b2530eefe3d31a0c59ad2181d2b4219434241e10b5f9c646710c19061f09c6838da6fcfa3ef2bd6ed8238a3fabb9496786b63e95192c13e0d733666a28e7ccbc4203981f45da76a20f908a6fadf1f7bd7dd8371fc5a44c7ecd480574c1cfefd5720e9a9dd9456c461d54854f9b0aff6352ca14d1b217380e405ce6f8e0314e4c37151143a48b0ea0ce02d8be456b0cc8ee18778d43c690ddf91bc5740cb2f20273724234cc8db7e4f59f374fa0ce5a64469a7de647becc680a771b87620ee5f968f87b24ac2a196815a1668936529a8b12623ff0cefe3f5afef0b4c523302dd4791617c96594246acd79798b2e50d7a59cb65d76240df4cc18c0ba0b857eab989d7c155e80a0e89eede8097b7e1d3756ab42e19e6ffe5ec36840e8bdb61f02cfba47d716fb87306328917e2a7c7ff4f2daa1d58a94f4e474da2830cef2166f2b56b0f72193ea3ae5163717d24272fa18eb5d6d1c3bf5f905e70c61edee7fa79749bd4dc2b93e07dec3973bb602332d95c46f721c52330f082e711f5a35152ba3d783635605545f17e4701b47ddf3d52e342806d176b956421d0904d805eb5b97d0197df3a37cabcff6a7881aeac357a7a46fec83950098e8b2959944b2977a04183c75a1c3300c44a4dbfcfa5773c09399a51aea2f437da8308666ca546f994a633c89c7ee41707680532ad50fe9559f1c7948f80d6f585399868e7c3fb06dff45be6c6101f9cda93e6bfdf67fffb9f96c89ddcc6d611a4c147331172e07bf88d9beabdb2288df02e2c85019160e4f0c1e0ca276b5897dc5cb7f98a4775a48689f3243036d350ec6911cb60d88d0932c68c874274ff762e9e84dcf6698c0e19ae2b56eec58affacd597eb9ab7d7732112e0f319e53e736dd1c2e34556fe4a1a0e1955c462c569e9342585505b257d2fcdfbde2e9a91e909a4956ef3e183410672bf5d2d4dbe6b538d97b15de0dc2bfba8191171fe6a129df3b4658b5374979306cd415416e6fc95a652570e511c4b24e69911a03cca132a2f7baea3464e807431de16c7fed909c3cff933b49e102418b6df9b713104168d512d370de25a359bf54809a56dea55286abfcf0b67af4541e9146d134a64681a74484d9beaf8443f2ed3532403789de4132ceb913d4634c6b016151ad86ca299ea85817cac713d7023a60c4def35c7e8c0f22f5cff1bf378e1332133aa8df8fc8c8b3d33f347b138b53d130c9ed60678a72d49050fc34f1a1e3dd92ed78fad88c66854d31a36cdbb936b2032ff378358aeb87a440369769bc7323feee234348847b8f216d3da556bbfa1c85a4818531a4b31fd1b531b22bbdde727569901064f7ec12e8b956197475a9f6271b5a45d731e5c1f6307380cf7362f4f8a37069195ff46b8d84d8dc1fd9a496a1826398107f9605443a89bc08cdcadd65af9a581a7156b9c6e544e6ee8356cf66646e589372c04b507e91972f1c3370546a901c280326cdf228a06dd1a623c78cbef32264692646ad1d9d77e337d339cc47c0ab1cd7d435662a50d2ee53322e55c87552727a13a99cf3aa6cb29b534e06fac1be0a485b730f3df52a2dd98cb442fbdd3e232f58bbf1e3ebc70525133f8bbe1bb26fa726d3b08c89e5fa98b22ef6b9c7f2009352b91da3d8b02e9be07551c5dae2ec4781ee2299f9f021709802a37af159f0c78770b9a7502e7c0eda15bcf57898da695ba3bebdf61b1924889bf3f591718010177ed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
