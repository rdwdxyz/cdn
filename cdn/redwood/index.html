<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81dd9314f9e15586367f29b6427ec65040aea483adbc85ab7363df073150f0c30ddf8ae71cbff55998ed42ada4827265859a7dffa594b01ac8d023d98a74349c95049128c2d077de2f817b1f8fd57405e69e4a3a3a284b56227d0eaad92b526f1d9410dc0940ebde80e8dbf592b54c60f5a1eb9419a01b5df772ca064fbfc6bf36e24674981e218c8f91b9ae081d30882cd33259a51b4578be04f70417ffb3d4b543bbec215b059c59f0c78a17e9163b5127696e3020723d3277665effbdce4cf9e127b8498800cc936975eca379a8c2059af3fc628f7501cd10756132e5f0467a9fdd4d507e84e843a1c84376e9d96a13b397a0002a52515afb3cd2896d24ba8c87c3357103646468f366068411782124230670cbcea975c6a9646fa67f51e242862a0e0ca60a4647296802b7cd413394ab2302fcbb21281d240496ffcbeb3f7ac2eff475675694a393357b7e6df882f9a466ba4b413aa4f220abcdc65fbadde749bd2e277aaff12c87cc2b0092e7dc287c8655d84d1ad888709676eedfc2ff6e2558272069330d56b1c58933b74f0e7ecaac9e61b90d52f6702e1325b219cf3fdf12dd884a2abe07970916152d5dd8fb6898ec5b868ce6761d6ab2e297575faff8b8d07a20abbe2f8146c02aae79255a6d505d5f43ca8894d061998fa99bb76ae41cd8f65d6b2aa574764c8b738073498facdd5f8771b5b2f0321ee0818500fdb76b8d60afa00a6a15ec9cbc494ce7554ec1261afbf2e888f8e96a1d65e02aed46db8dd4c643b3544eef569e54477dec4a83fceb57b45a7e31d2c44b76efa5da60e399a1865c6ac298d02adb4a95cb196608011fe11f23d2235f3bdf190e8a941aa91eeb4c9fc187d4b124e4a625dc97aa9a45688ba58c78e9bfe39d6ccba538f52f7cc4300f8c0a80f86c5cc11e79ff16f426ad9d25806da748b136a37a1cfb7e662f230e3abffde2a44ffe7d3c00040735b9122a256793080c8c7aaec27081ec7662d8a7935f4151d5a83d6096e0fb645eb04ece3596891811c12cb50bdb2fe293726d7ddac34e26177ec9eba9bc023ae4879f379b1ffcb5949d250968a7bc90d723ab7018209eccbdac145e6bb2c5b26281698bde7c2a0ab2b8a6fe43fdb7d73fcc1b0cf83e62ef9bad3487b518427a5b130f57ae0c4ecd7bf018da01dfeecb1c3c01b4dab6fd1ab87b49efc0f03a055a85cfb450a22702bd6c9be00f9dc98f746716d416babcbd8668e3bfa6f6fcb2f4f14359232324b32bd33c7e33d9471f23c1f356486f307d10536a0b1947441ebcaf0baa5b8bda3e255470bfb6bdffe4027c49c739270194e7948d98dab71756ae4eb300444177142cc9a567ee052a6cc78df0bf749c0fc6dcae66ff78d066e3d04821edbc63ad0ec7512269a6dc016d2ccecc454a7a923115de8f61bccc3424daedba51bae686d75750a6859ffe1f6742cd0945b22773bec9a0d37c4fb048c2000928dde71c94e888e35746c79155c72e8af9c83a6e779f9c4e125b33ea4baf2f5c75dfdfd75eb6626e9b7d7f9b77c5a796551f61aeba50aaa871fdb57189e20403ae825751f9cbf3a2186c0534c1245779190119cf584516054f7c6c19cc15d463752ded3c778150f5768cbbb73b72184ed36784ea55ae64307a962c2ea30b71f29bd18ec159cad8cf5f092cba8fac4867e9bdcfbaf677e1ddad2859794cc2332b298e86c061267c11c6866d5b3941d5d32cfa4563f50111c46803d6cd464f84e1f05c683c1c0876c3e9e80f07b4c5676792a7a06dc49a3a172702c8491c3310b3a5076161ca7197740e9fb128a74c13f01f422807849b9836607966ba757e1eb8626021ddc8bb0a7204b07a86e17d62497066aaab7259b0a35066a1d0b2abd4ae8d2eaf1c6e4307a6b901f7449054b6895b78436cc6490020d1f12c261a0930e3c599611491b4b073e390f97c92f2114c56a0e4aab641d97018a01488eb7a9ce4526225ae82f82b2246b6860cb4dad7a8d3d1d7e41f700dde58284448ca01d4a86341731e190a1b3c626c456ebf6dc6dd4bf61f57091dc5583e947f5ebe0877e6fdf451d32eaf64078256efd4ecaf2a9e8b6934ca45336c3e47f77780ff82e0d82ff009fbf67740ba6df53b5f66f41af41f9ec19aed96ea56b36d8d5bf5cd97c20289dfd2f9ee695278ad4c49a76985c3b339b219ddf3194cdde3c7f68a876f158cbb292007f90ae84090f3461fdc1087ffb1ab2031dedd663a01eb96991f7aeeb81a27a386a4e9e949090089199610dcb58757d803281c3bed82f991b86e833072c4ce34a8b57e6f9b42127d8bc38f6362d834e883af7bba56664af8efac48818e2f1c8bef5b75416f7fb25f864a2463de0f4fa780dadac9b3452992eea0a98bd796b0e33645d31a1b8696431160080746f5de3a02fe13cd6eb9bd5c73688f8b099375364a7b51bf5e3a6414e8082f62fcddac8a45acab43648c5a78168c234d02407f2063f0e1dd6b90c1ab287bdac184b1902a2cd1cde110fd9f50c3ce3fbe5f880805201287cd1018abb207bd46d76201e05259754418e61524885e3507e2f312ea8d508e09b0d36479449633b578ec35d1b267fa0e39d18e050c54ffd2a882ce2bf4f344f570640881c4407a44f6bd7ce75c1c7047612f59b70ee0e98364e8d0263d890e4f40f59f2483d5f0ceed8dda0ae9de9109f866eb3ac0156118f3c39f5f558c14e641ec8ff94cbe5505c3d6b0147cb8f63adec9f5e201240aa87fc594cf0c770a100dcf9e95c18bea9b3a4d33a78517d4d449d69a442f20a00a3fcbe1ccc0b6b6ca85df5aec7735b7cdc3e7a752946f42a9a13d592fbd959f938c4743c80ddd222c4f1df0a746aba6a271bd89b2494aa82c34be68f4457ff1104c2e871afe50832e2b640c8909437b5970f1919971140d17a46f52b77932f531b9f3f8d26deb938e7a6df71d2fbd1e2895792a4814dd17de98b703bf230668f513a462d7f4a65b800f7147332e915b024e437f37ba214e287dfed0cf6b3ab1f2e097876a0a3cac57bbdaec459fbbefe0c1e9deb49eef9fe2658287ec4b9651a9976125c1365993d0727b66e27af96a9584e7898244553a71d91447d688cedc2e8136314521b044814210250d86dc8546b332c5a487b1c94c955626369a19f2b0e9bf93b9708934901f6f7acb7c825fd4bc18a97f93034244368a83ae1b6520c035e1ac7594bb9c4402077a67047d4ae48a1f866c604074ba3b037298105eb633e2c6250ba2ca28e052f9c8101d82bcecd1cfeb44f0d2abd4adaaac5046b8165fb8dcebc333d6f40e3d68852243192de327e3d4eb3ab13dde9bde1b769b23f9684c906613968fa36d16dd065119aec71fe463b054785374892222c4a09ed9442efb0127e52de3dbc52364122ed9c2dd55f826a7fbac6cfdfdbb803290451bcdcf8a0d6df80beede732bd961676f3d4be35a672ae554b3ce6215cb1ef4d78bb86826bfacc626a6ed5cd4b5ede87dac9aad47f2b93ec35875c3a670e6f04bb4d82dbf40ea44869019a0cd4c1d4f888ad8e68fb85fde69afc4e26f01a7d004d8bccc553a5957d263ad3e5d42d572231e4bfd3aa08503a821c02bec97e2fdfc314d3d925dac5006309ed108825bd76764cc57fa04118aa56e5d9f53f0604046aff2a42620dea284d5bb07587604a6f37c5696204a048a2069af3606b13c24cb9933aba0e38fec3a62c3a0f1f9db1bc32834de6ceb02c6b70c9fad4b1d9090c82009b3e86d2007961e7b1525aeddbdb3192a8cabd277ff725ad5620e2abe3592de33bb8d8a46d6aeceb59b2db18c8ef89e70d0d224f77706fb71c8d7a490fc777ed36bcee352b8245affb03acc16486d513f72da1d08022feec75086e1f481b3ca2888cad3e00d2214ee47d92fd98f6dc2ee8e14d5bf0a0705c1bf49884ee1a9cf3bbc6efcb71104334f79962b2fa5c21b6333755bc88200e1223210b9b7998a71baff357c1deb30b6e4803e44afcfb6126d5e86affa9ede20010a1f52dbd4f8724fd25905803adbcac4da08aa2f534792ea795eac81abbf76da4668761a1987e1e6cf074fb73bd459328edc074e1218e4f8b338e04f1f26f114f0be7abb08ffbf4e125625ef4be8144c784aa9caacac48e5b5efc18f878f0c005895a9cba6800cf11092ec6e1194551af465e3fba090f156fb826db619e1d82547d59f83d9d583eb24fcba55838a47f7314ca50bfa5e74090cde8487d797766bac71a1fbedab37b22e4776c1a2eea9d0e531f02125dd256affbecf79ee800c4448f72652c1f585208f20d5a03b5cbf53313982d6178e98b81591199e1e91db984f10a2cfb7d15d8ca5846ea9bf13b26ede860ca7b82f1a1009cf36eb7737eabf3fa2808236a576d7da683196682fe55ad9927347654e9f8f986a748557642e1ddd1f64aa16dd1fe67703d6bde8bddf8b2b622b0b82c9a57b8ae118e62ffb4eae7890567ea32effa13713ffad598f3b9da693caf9da0768d019713b9139f90413ed84c04c170526130274ae2b55f4cafa8addb370256ccd6497da5f0a1a70b7725e39b0b0fd331e36bb5ef5d2e668584fc711ee456e748e7f173b84b856c6c3512523e3b0f39b10ef83542ca4bccec97b88f4b84a1c95f7fcf0f340d8865563321a992fc3c9da43662ec3f3635071b409182bca87341831d284969232f36f7179b543891d282d9a3a5efe1f1774a4348977591c3287be0da0bcf33ba4109c18fc3e745aa0b29fb5d210e6c761475b72e2d46d1baa2b7952ea6896a0954a6f225962102454fb5aa3f23cbc66be859284b9e8bbf8da3d8dac448ef1ecdb8e54d86d79b50949acd7d3bd96515c086d18c44e57a54d660570cb41cc62e27b2821bfa384a5bc5c60348b4e3d4f76fd856f28f138ce1aafb54e3289b139fbe947bc7bd0fd0a51ab2aa9674f7acb52033e2ba645322e87a2c99a52143aafebb1cc9de9095b558c1751511db524d6afb9ff0a9cbb2768a00b1fe43d40880cdfa0b1cbfa3e564fcc1777ccf9c9561b4ffd20e5524aa76c2f05318ee250d5f5812651b08e614f70051a9fdc6fa6580c80af316654fe0e778ae29d76737a89a007077f52d1e35d1e48b54a342212a3ff0f1e49f0b755f6f0066e6cc2ad1b115cfec8735ec862e3f206d17931c6931eaa1281de8450a30ff7e39d6beec78d66ed45d309f96322e4d120d4b81013fc771cfcfb32b7bb100d9dbe96e4372660fa6a700f4d28d97a6ef03b4fc50e887141a3571b52f4ea0f4e9a63699f24ecebfd19571a26e6f1e4cb87629964884603ad77633430f80bcf96973a1cbe40776841b55bd10e4ba9ddde7c6d10298c00398808c9515704a3190491fcadb25d32b697cf2cd0d2883a007e9b89361a70ee1853dd1394108101cf244c4ba964700516eacf11398fe5ec3337effea48d025f1a011156be73812b9e81b1fc007d786a9a661a4d8a5cb8d4c4c295bbadecd1b644a531ef0a04bed1ee1c5bbb0a041d51c7a92972a34a4155b3d7588f8d99d812f46eec755f2d2b5f630b514756b30296aea755d2642ba4a01b218b6882c8253f55b598f0b64389ab256d58a90a7425963ee1e8bd62bd86fe9e53d54da7c04cee590efe04701f62150dcb5a5cd211757169c17667f91c285ebbfb45058131dbe0bbd5077e4d42125891dc78336caecc43377f9b6f696d65419786104027913b30e03a54df63be1af4906adc62302b5548eaf09300caa3529867102c3c4aca282cc9a48663a77e049b648f27cd0fb72b18ebb8836c88b0d2bef337def910cb1b98352b5caa6b081f99dc35d3efbda03c8d79f176ee6d3e4d8765460897890109d8270766f97d8adcfdaaf8030e06b45b9e9c80c7114e656af197c8efcb9901963769af2b2b1b49d1032b387a11662f2ce9edf8187f56f2224ac326a31d864a5373711b5cab0f7d50a1c389b85f3296cec734398df8e969d236878ace3f18e86e3e76cf5eb6642afb808608e194289f71c9f53ad961dcf1c0092d00e13660c5f9ec9cd5a2dadc20dc9b497d7ba3d517aa949b6b9729d0c7ac776607cfaef0ce87c2f074e3ff375e64a88ce9a95d8b2acfe4d7a8c0134b1928b1d07657df47647036f9f9e6803a055973b1a377f06b4bbff9978e41fb4b6b2384057c959382e5a22c2ac00b13a6fdadaf2d3d5bad31935fe44d8e949af778ebaf03ae09a122c9e3053df67c722e7e1d36332dcd784fbd9d7f78417050da9195c0a8c4ea60e3d633591fcec0343b3f1c4e16dc980e65a3e1c794b1cdfaaa3612248ee35be4717441a115c106ac1eb5e5d528b0cd165fc4010a3df3b217d0fd9e748a57d96f8c49c17095a663530216fe8e2cde796f6c01671a4c68a88d582e62343499fe2dc6b63bfd2480d1f6cc038866b7d24aa9f52ee0eb84cd402afc62589f0074d90f791bcf91b4c886aba0046921e331e3856943231cc8cbf1b572da96c240ab37199db328b5972d808540901ddd1246dbca22c33c9f38db86fe53d00f9120548c301b6bea9e94f3b5febd85f485b97c0672417ff4c8ac8e8ba9d35a26b94b9d45e64ff1df32e5d98a756b15666e70072f50d52eeedf0cc80eb2d6d35afafc7f515f519c77f3709bd436841b01a8b024954dc99a1d76a2480da9565017ec4ea729e9d327a0786e2de692eeaecd5b0c59319ff283e3b47553b420a2cba77ee81a0fe547d2a881949ed5b4a2d50f9e3fe55fd78923c7ec79b1194eea3d9de6bc03670c1ecc716369e7060291f6ce9c23f6e81fe7baee23cd34906f2edea9bf421e2e05c741e69f5091ca52e6c8e3576c1202cea10d64f4a437ed17d76a98dec03ea46e46be528dfcd6823775ff4282a9be70aa2c6ecab942e185542de263feaf82b67522f8e77d10dff2faf394cd3ecc4533545330b643ad7dda5ba5a1c261d98aa9e6d308755ff6addfdd9a8233565bfca4f0950cd1287d012659dcef56b3abfdaa2094ee4fef5ba78fe5e110e1d2b432b8f51d58458803612c3d6a6038a5a1628dab2637677e306c44fb5011a2162faaa5786fbc00c71e9c29d6df1bffcbebc6e7aa72c1c2be4f3edf938f9765d5151095a86aee899d056fc3743cecf45c30e848d0cd3934b877c8d79275a85bb52dd7bcbc975b659401d18cc606f4f328b5216c12c955ced963e16d3d4380deb3436a4aa97400da5358f97fa1424ba78990cee5c1f26fe6049a8a4c628a56a5ac089d6d2b429762fdc3bcbca14471a8031e5665d7e102f173669c9c8a69ebf04868830ebd9361d8009f5f91aa76d96493d594cc05d36e0cd0aa7d51606ce3e17fceece8abf1b2660c79ba235da3f83dc48c1aac3d4a3917f8c7b55f810ccf3c0f7071b1d3519c0e8c10f07c5d969cb369686968918d86cd497f1cf01b49c487c2b98749135113ae5cee72132c5004a52f1a0d4ce1067f4f20fad87df4c93e8e70fed18db9f2a3d588e1df1691bf4b322de3d36be1f06519666d40b6aaad9f445064ff085ba33348ca86c1bb8552de0076a869a21eb8dd5782fe8088a0a3da18243cf807c42155d959370be30e351eaa74bfcf91581b7e30e7f29b6489dad0d0c4691f299c6898a5b38b67025e5677a2e1087684b2b3875cb8c4eaf643467298f05635ea0ec2d14eb7c178ec3c12244b20ca6abb556c13c4ab3bf70ef507133ed96b69c28effa88903620e46a5783a3264d00c3b285610e411d8d91cdf4b9b5587587b2c79ecd4c530c180246644165c1badb389e8b634a9e16f6223803890a6fa62bb1a7b8d363f22381ddc6ca490a8ed45ca63903ecafdaa0ebbbe7a31f8474e1ccd3bbd0f9ef635fc09ea0d5524c27978407f9a3492659ee018247d31566202ac7085812023638788affd44fcc908a2114b513e28ef6e61be04e7b41735abda384b02fe315d78ef1877ffb43717c26b6ebdaf2ba52c6512e7769fb8d2e77c6443e87b6e53f24e0c0263b8c905195fe144eadb54de67763cbce6c3af6ebf69a157d8fed82b3d71b1c5c9b15997e80fff9498f7ba092256a9feb1e02969537fb85b7a851ba58568b3c1c52b8a0d14c3b7f0d8b67ec8bf9e5207c500cd088d1c9f620125c087621d0cd90d1543e840be146de0b1d2afcf9966c195eb86c345e09284d4473d56be9bad099c3f75d51b1802faefc00d24db2a358b725afe79f3ae82ce0f40bf3ef55a41191e0b39c060da624ef717f773b009ffad473e01fc9152a0cf38684b89f6ccbdace93c190ad8cbaa096a7c4983bb9056119470dd7c72e99ab6c614f51acfffafabe66c84f69f9dcb4a710c3a7fd4c0ef2db029b52860ad6820660e984529841093428eabff35871af20bf1d8da6f57e021eddb0c0c1b733972576466ee3750457bcd32c23d335de7559560da8ade910647083ca99572c2e6756f694114b34f6345979e5b8ae7d3ecd784b052125c3d64da37ad9d5d012bb1be7a26cc7bf90cc5b1e6e4fad8093ff98603edf3376938ed5686cc24abb6b14ef5f840100b6706529f9936ca167d9f6795eddce213deee63ef7302b9c61fb4b622a0a255ee9b6b59223b365007104889341ee34f40c025bf8b582ea5447f86021293ab6bfd80332bae7598a1105fda04e1c01e3dc42cb9d0c560052b4f7f64fa06c21eef14f6aeaa0e988f077827945ad7ec4f81c213d50b3b0d77319327c52b2d3b28fc589d67e77180ffe816231e3943615b9614ced48be81bfac65d8423de85ab4e92270dee00816c80677c579976ffac17901bad2e1ccf474c406a8b75e0fcb8017c7e65d1eb067a57dbb135f401881af03baa99b88f8b55d1d04a1f67f5fe881a1cbd516aee187394306d696efa9f9c9105e99f4deefd6d1eeb846ed444847f3319c6cabf0c52f571b060a017a03907784a4b32710c011c3b490279c640e41ab6961834e66701367c8046c3e8c0ada6f1e62edb77a44e7fbdff527bf64d154245ebf4d930b08dfe4e6aba01fa4175cb9082f1d41d0296cc3acda4cae1a536d0bf1b015e35ca0935e0d12c572fb578dfec58e5afccf1947ce5c93e3d872c9d311f913652b0a8df0b2cb132f4dc47cd97a17988fd3aeee592acc21dd848b9848cedd5b6e7ccd039ba851b9300c9c3a30d137e1bcdd9e7cabf7fd37230cc5232c0ab9cad2e4cc233cf3befe33b5f070e6d1f49416ff4883b95cc2f3c15388f1af7174a6aa541d9be0a4f97c5d02fce07c42fc974bd51a7202d58e4d29a682d3c58deaeacb60f2c7c14fe05b96b3fd91f2c0a81e6cb66ee869fc8855cecfef815e17191416836bf5ce053e750b8f56bb1e5686cf69548acfb7473240a3b54602a90c062271a370b8c78fc8984a8e97a974e1f41adb0d02460ccbe54d372ab92cdae0375756f4d67801d2c7023666790d80d1e68d2c29d28acffd15fcf576210e0710df459b2875bf6c1a11032ffb14e9a989cb50d27e59160b472a1734e61da9030ba5de3c86772f15508ed4a2ee603592e8063b933692ae54a8948f7892318dd2172ac94c608f67238e6f5de3fc0a02c2d35a29e08ad15e88aa9ef37c7e6592eb75d69deebb5bafb3579f1f399adb554e2985cb9a7c490ad8f864816aa805701a2f8ea94a5b7e527a2d57b207bcdbcdd02140e76de3c126d0ac1e54649d978e3ef247dc0a92fde8296123dff526fb7c49d699dafa9ca215ab068e3309d75b21f78f6e011203dc20d7b07dd3845d1290d277d3ca00e152b9c213eb9ebdc2a0639c801e52704989de04fae262375988a1e2b8618d6747d0cc122604746332cb34846f2c4551c26a2719000aca0321572863c64a3afccff7266ae37bb3364ef0f4b31f2fc7665a8796bdd6eb478c204518e74456135faedbad5835ad2253abb49e43f61bd62f4d57ec736d1f98c8674445a847cc0b199ca3116a8b635f074624c92efdbfe87c078889a396aa9509db98dcb48d5288abefbb494a6d7caac62f6a2fb264b84e0a8b6b6589237c371d77d6901d28bb3a4197f44afb5dd291de37204d3db564ed9ac07a01142fd3da874bf18c9732fb0d2c595d0244eeb00f3d71a46afad295b0c74a9e9c4edd2013f432970d86c286abd38c5747480309c8905be961953505f4c69ea61ff3eee3c01c7260378b1485bf25bca47ca3fc634a086006a5974e397baa13b1005ca87d5a1bbd68ec68a7fc818efb4d5cdca8ce728c4fc4153e718d439b3953279cb4807cc5d476939c5f4d71be08254d119b8589a4e96746a23ca07273e88bb60275c975c15568f4b2f580c82eeb0589cf57be20c576aa46a185aaaf41aa566fabf80d3f1a1e75833ff3023da71a705470d3db265d7009a380d422acc554cbd9fb59fe9160c8995ad44b372e741d0c89dc8a13e12d3b416364040891673262d60cf3909dd59f8bcfdf2ae2f4c168f9a2aaa37b184980d45ffd5d9408428e8ade49638f82332b60bc7b30241398dfaeb9e3d95bbaa93f043f3e5cfd23b12c5b805dcbb6685dd76330067a40ea5b3374ebe8ef049c8cb574c44dd6598b62cb23d2b0a5e5799fc3091ff0d11ce3236e633c36d563392de20242eed1414ff2885b2230a0338ba2cb3f3f6c13386e335cc19d2daab9a8121853553ec01d8a33e9129708ab15df4481213828f48ca0f79ee98519dc09186564e73d47b4bd661ed852d997ca0d6e81c175be3e68d0aa77906e2088b8f144878474dc6fc8ef60eb20b5713a034721904713128e10d93ac7cae866bf098ea07207942bab702c024f2d9a475691f142db1d301035024706911a9eb817462ba19e9ef9c369d3755c1bf44932e6493f0b23ad196738f3d5f448c9960376c89ae5c970c72e14249fb2c17eb5f7309f1ca9b30b09ad303fba61d3345f6697210ad3b6e8274280c9a25d9db5c638975158f53b71476c1558629c65a583cc39863b8c7c8b38f9af4fffecb24e6e812472838ca36bb114fe86b5b47939389f2a166955a5b4ab90cd623f69f8871cd2f376b08659119d8f67875c65cc50a7ad83b067ae775b653c3ccf7876eb044d4232c26fad0532c84abe4a7aef8d8f41ded757ac6bf4baef014e74b600e46fa9c5ebbaa2ba51a4319cd3cc9031cc1494fdfbc53f4616cc3477fb5bfde7c28253cef703e2068e6829c40af1123e18592fcd3752ce96287e1f39d6a6a5525b1e34e1422f6f3bdaf169048c16065857171c941cfd6d12312576746f65e7282fb554806e1b9abe19d68babd3efb3be79f2d2c3b0c91d829591a3eaed13361b4726cc4f11f336728568aa7a42f0c86f8f241fbcde815193f41321fd05ec9dc4f674318bf40153300941be447f93548001aa8a6dc89791ed8b8be6410a69000fe537c5f4a90f8eb08d3003550e65b16f4f32546e3e0152d58c0fd01e2b03b80c58002afd547d7992473d72cce56ff10262b975bcfea40ff8d251516a617836defa5d3128109b2c80f8ba046d91256b6e6d120f3d1bcbe9650c33ac32d9665b9dc8d165479ff24bd3c45f73120c57c42fc65adde1b2dd560ab3edaa5a453e780cf53295c8027ff1aac77750234f5dfa843d9609b2e52e8eb9eaf1c0a00267ec13fbae072b1f6816375fb8e8f25f4b8daa55e893e8fdc75a72effc67bb929d48c7f317575d2f05727ad39d117d7f6d5048a4ca52d3f8056adde920028e4a8575c452d1bb096b8272c491507d80ea4ef632073cde6b9d69e78a74ef613af46ef0adc27360854bea0600c951c2f292c67ac5f0fb174fbd1f02b6aa7afadf1142cac8cb719580bddbb1903dae227d86e2baf5b9f5d350a33e7cae74d12da2bc3e127c159ddb23d1e1701a1bd62758fc836352337fd2f52d68432dd0151940ba1330b94bae26a8088c481514398464c5b3ed37de7f888903af43d676ad676d8144c55e65ed8623c7a2fcda754972de8c823ec4b5c01c7e1178ea3abdc5ef920abb626c7b51fd350af7f1331c13ced9d153c1a267ee999caae4227f0f8cb079712415b4b6bd8dd624f97d2b3167d6dba4d5e3ac40ed0a73a574e3e4c59422ea0aa070d3f68fb997fe795d037f994473a78b556dd63659bb6798de0b0dbf0be4b28d92a136f9ac05f1a1bc483e47f83daa214602d9d27ea12602acd4f8c6ca1d9e03dd79490c7f731578680777924a73bc690eb3e670f3ac3ee14efcb671660150d893b4613f8310725f6e5bcada46737eb080698e1fbb68bf2ebdf5eccdb077dd7a849e8720378d2dba609d73578dfc5c442efad597ebad245477b9603f544319e646fdac028359b5e5d0d13cad020f19e15d64d5de9c6cfa600a79fa81ad74319ee5bbb193dac1662219e3ccdfd3dc44d34dcdacad6ba78a3b64af3c219a92fd2cfaf68ad15a03dbd7e301f6fd14fc50c20e274d90b2e2dfd1799b0a667b2183a2a82f027111f9b883c58524a56fdbaaf5ebb5d43b41e1ed54f7e084c261df4e15eafb1a9f6fc971fb508dfa678292e4c6b6e206a28744a915b8842dcc9620d3cc380bd28637930d13f7342bee75b0c06db62a5cb10692b472893265e811bea25abe64a807eb01f1beaca772a0a758abaa80708ed9f2b2ebf1b19981166925387c6ec616d34709b2a8899bee208ad35ec3f7e359cbe3d29219439071c851164fdae3cd1e3a302eb8d39a1bc9e9a3084448b7e21efff6553e439bdc00e562d12c810db298697fecf810e349ba89634c9d4b5fe55cfdad396790ad034c390531c53fc5741df8ffa0afbe91e9dcdaff3cc672ca6e67e3bf2904bb20dcad1d2da70a42e7d9cc05a338daef9392720d03b01ac9dd01999c9f240e44a9cb864312faa89c5f3b154f98a1cf57c139bd28582b150a866467a15646963ef15ce880869cc9d9999d3ed5a9f7d821a0fdb92f169c2f861d115aefd6aaf1293871a9081feb41b2baa087ac6d860274ddabbee7e075910467fca2fe9d88dbf12f93533a7afa648648b4f4e2096fc1b671ce838a061ee4350b217f10e13ce04af08a8ff1e11965094a17c789d90ec738d598306c2d7e31744a8b789c36ba6fad241a2a6c2fa02f9e6a9bf20fb217524565970d62003835a58c9226f4039252a657991cee6a728708e2fb3f4d58857736ec97ff6954d0849b9f56b7c45401984f19694567927f05ebda6cc14ea3a804b1056441d8dc53ce51d7c89cf34b386494befdd164e7770f5cec6cf882106b1949aed7ada7b63ca06200af3c12c68f722a39c88cdbd2472bf575d2c50ed8cb6eec46d79df7a59ccc6c4730daea6ad59d8222a3b989435871a6023ce616e719d5bc8079b6cb73509a5a1d6470c498717c30b0b48d9b59f3d8588c873e0f65fe989b94b8f8015b3aa10d63c5ae890e5003c099546b600999fef5e92091fc71cd3758732cb1638dcf039b531d8e821a1d4a514622ad139d64cdd89332b72db10a4716d88ffcc4a106e5777d3c9c3cee8dde78922e7db3c91efb1c5e9ae0ab3f7bd673fc99c33e293cce43436e029710090add6f09fc4c3abdb6fb4bddc71b15f761eb52905b2f31d0b00811648a86590e24d69800e8b4e4b6f28c32eae3fca906817704236cb2bfde314967577dbe263a5b9f47d2c72f993eed354ccdd25117b32081437161e1e57db008e6388f5419640b2b617de6e77adb607d95c0153d0f5ddfb5e666e36309f422a04294258c24c1eb6a43cbee91039f0cad2bd21db963b7599a3eb18a5f52745ee6e6df3c2dec20f7982a8581ea89ee54f381f95b2ddc9a1029b786556d62d02e4c5bc354c21442b8a1292609961fa6f428c6931a707fba78e03debe445881ae6d124d104b0c461802539e8d5ae32980b4b54f7b930658beab64db7f84fb643da0f7e25cfed4f8dec0187f4e500fb6f59bf5163abb1154bb64b49f2d075a7221ac815a9e608edb8b10413800fd88e9768856a667b2023001d691a33447eb2153256c45f8adcb16515eaa7cf3ebb554a842ad7bc190c3475ee023ff1ca31e4d896501132a178c9f1f8289f33afb7106f98fa5a9b0a7f85b9171593353461b150e4473fbf8bddc3121ed4f6b1511555cb093ff877c91324abbd41ee064bdd6756df3026631f4971289a2d1e616f4e1e6026b72c5778974107725f119af88d86ddeddcbfa113c60eebd7872094d00e11400f1f28593b31194c6c2438673ee2e03c5e9004a92683ccb7793ce432a89adfe8df553e98bb1144cbe27a1d948bb5aa0e85cc4b793f4d1a190baa0b94c03274c642ebf96b4e83229e94d842dafa307b875c9093a45cc13370fd3f7c8af74ef1fd9f78fd72477d916970af3757f7f753f89a6caf613d88d8cd0fb4697527c45eeb3d7e3088bf97169477cd91f507449e1476048973767778f4b3d1bcf0e137044d49151db80f60664fed2175cad689f8721e42d95dc073d84ff828559645e1322a61868ead6d773cb7195d36da772af2af6a1b013aad9fe16a9b3a6e4d73adc59f46628f1c3c09d9a23cc682e5903dc8aa5647633bad898e0c4a39fed8a9ce2e9e859095c013a2c98aa57c355ec1e9827d72a50aa98fdac24ad7103d64359577cbfa9f356095163e2cc66c04d30db943d76dfd598aff0ba9978b1417d40592b535854b99a64d5700b7862350f5625915c4e1e37b2397a808fc7c594a87b2244496119caf106b79457fd19c1186206015064cacaf292ddb9bd792928d9e6c0eee5515edb66aef7af1367f1d0c87af13c5e3fde6fd91175d2335844b23db31d4de39fb5e2f50c2dd234007a25fba82bc5f27770a670138b6f5c246bbb96a8a0b8f0bd921fde60b2772878f796f4fef380d850e0fac636de40e20505a70bf57800dc8da0a01d4117fd8d12e7080f12a24e5ea9110c38550eec7b61a4ae77b02ce0b8a8a52f8add3b62877ae57f6c1c79548e8eae79600f388d9552de0081109a3b92d47fad20ffeb41cf380be921da5f8f3d312eddbe781b2739a5878ba70d627f95f9ae9bc6b399f358a60c5bbe4dac2c6a9759ee3c8aa86f3d5912c8397b87094466cbf2915592ad995ba9efca6a1a63f8d15bc755c9c79d91c904ee07ecd208ceed54918d806687f1a6c166938c0f99e3da3731beac45bc59f072abd7720300b83997f3d4840fc01d2172656e5e0d0dd55744c7291b44a3fd673dc3311f1c7c02b31df5a90f11df4de261f44ea7b14a606ffb946e7fc9058c2679b9870493585fd6b8c0b2e767f071acd0d29b224ce15564c278d688c89c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
