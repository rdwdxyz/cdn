<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fb7f006d182a9e504aab8a51d179daeb137d0d51e4373cd5ae140e54695db38ca2124413426fbef0a8efff496f7303f6b029b93d5c36f8c99e4293c453024f63e71a2f650e9dba2382dacf03c605635da07d55014aabe94fee00d2a5ce17b0d691b47e8ea603f53601acd703656ba5771c76199badb5414df36d613f3624eae0bce77af4515bf092677822ad971003f2afb2a1a3ea511bc9c61ad90d205b637e1653b01f9e2fcc5f3ca7c356d84ef6a5415ffbb95f4d88ae22aac88302d8520c80ccb07de318592a22adde5ae47a1f185dceacdf35002ead33c4257697311ca0a7ecd4b4e0dbb192589610d30f3285ae1b42463d89635b2d8be44d71a2dd0f07d92f8eb36a455ac613a92f13625f6deda88edfed806e2c8ffedb6ce620ae647883336567b20a6a2c92d9d863139018d5e474899a8fcc79d81252df36f75c0d49db51b770c30f78e3fae8eaafc0fd63682cd8f8a7b56f50f9cb521fac5c48453bff39c61845ab3f8fa8d078a61bd1569922702bbf2ffdbfbd6562e193db703fb2f9e22c403c7311e22be3d8a54c2199ad621cd3d1d595d64597a50e668d418f9bce03fb35e7ff0eb85f5efbceda46e93a18adf1e7665339b536ec900fa319bca7a8047f91ae1d29892dd7d27d458e725d0d47182e1694d5ddabba776c6049121340740c4fa3c6deb088d0ff52eb0787b31bee3357c92b1a48696637ca8c108747653d266626aab6f53d08985c9ebf9e767128f18de83e7f80d1fd23731c9782950467d5b2a0c08adaf57a18e4890ce05f122137260b5b42d7e128172e253be27c7578b9b814b134c6530a820189e7d8ef78dc90c3957228ac03b308458212607879da90f1dad2e375ab493449a8f34630c5ad3e65705de6ed8284d2bfe0e6598734785c5096bce6b34dce40b074fb280b04903e8a41938951082bc675e8434c2632dd72fb08ec6f29e93abafa08a2dc67867782a002bd5c5afdeaaa19fdaee680d58fe42a9d25c0311903663e5c726e4181b06dab2103dcc25a121938e4b9752a7d8250a0ac8df8667e417850ef92a41503abffb7ad26d22d91deb19155bf4c40449cb5cb4b62fe87b550dc018808b2d92dc2aed5af8546e65d6bd302acf32f95fd375a7d5cb0462c4d553021f09ad93a88f3c27dab384927f469bc5ec17bd3bc6d0360409d1f6299faff7b418555e95f94f81c6c161c1704e36bd752785d208fa699d11fc9ba25dedeb337b5364d0dbe684c67f3990f4fc4150f8ebdecfdac8a841f3b48b8fad2f7972cba21ac9d4845d8c77350daeeb7e0036cb010b7c1d8961c1e31251839f7f80a2496ddb7f7660e6e5f4dae55e385aac1f06541e77d26514013cf9d028b6dad41cf7c4ffec4e90c16114e9d11ed64046f89d7810e89e3716a0c4aa55013f24c5ec13e5e527a6b9cfa7ca2bc329c0ddba4a0b2ed5782748a8320af2f83c42934b5b9d063f888ebac9abf2769e9645c3c56e37351b1008553405055dcdca3006a31c24c181c7a7a67b87088afae89f1de7060677b4f696b1ab8a8278e452d3b48abe1181efffe4ddc86c11c85f7514f20d247ac0bd84637770327d5abc42706d69e74ef2dc378ff43e7f3c0728549f07e36481eb5dd3ff344c8c2d15209aac4f2fad8946608b89694ff809875f3aab47a95b5dcec23a818638d2a8437949c8fd706ba510b4894b18e8ce637600df203c0ca356f37e129892bf047eeaa73920850168d56e3b17bc5b3f3019391783456057aec37ba309d74f2266f931031f25f48bd3276b1e5902d61249c5cfb1df578b5acddbc8d683feb879c6dc4b6051cee29f58c76dabd008c62a75af0c2dcb988e7f5000cf1df7b2d61932eb281a29049a82c2b971b263d3b639d6d7d6b8edbd1c36895a18f65a0508ab2f4024180ecdb7f11c39a21fecf20deaf5a5fc87cb352792eec0a84fb9a188d2f3f21122f0968f18c778af120193acaf56c4f291ed78795f3296483b4b2220e394a9db947d4b7d255e089bacdfce8b8c09dba6fc1694e6cf5404888f8cda5098afaa395d1cf3ea91f098913ef53dedaddadae39c5ef44a24cc50a1c0b47ed361d176b343bf6a946608e9281b90eb879cb82fb485a2e403d7f715ab427929966307d8016dfb631dc6ed59cfd874ef5d1bc2d200c3c9f9d0d5eb654799fbb1f1b49933dc4e136fedb6149976067a62ace809bfa6a831d9dd00cb3dacaef2a1875cc4b1d71e495ffacd7fe053c3c984de7a3da72fab26e134ec58c783b42175e90c4fcf126ad0d7aa67ac8d4863c64147d68e01e9cc280447b52632b80ed4504310e94d2c23f1aaeaedd7a3b842a045ab5c83aa76e84c026fda4a12987afec6116d471492412896401fca75bbe6148e66224dec6ae7c21655c825f16ed19a5a9b4e99328138d3e98dbbe4f642382cf655cfdb9f13ae90da71caa098fee855e5e9b17f6d48ea70d638d02612f91f643ce0392b3c5a3dd3a7e5d64142a27184422987bfeceaf5930d4ef6ac5a5344256be4da98ee17f25de4fde7227e6f89264fe523b3e1f4a2e278f45efde1b3fb2620212793923ef8e34c35903a1dbe2c6e3f863ffaa03cd408e139c3d36c367def03a7ea7e788b8487fefd379a654e1ff64f3336eb3eeb1183f6e0656902824d6c4d6c9d5012d5ff297a774ef93ba2ed6f333993fdaedcce05ba6f98604a76b1d4ba54c9bb84d32f1c2059bafdf1309e17bf84c8eee450d9bf5ece57916c2805b324a63f3eabcb10e07776fbc3c180262af5771c0636275739d22d30b9ec225bb88fb1266560b9db398128272a0d19ffc21d5b04f8ad1c3bcbd8dcc166f1541ba3236a7bfe1d168bd84b8f3ab7056419d1f5deca20178362a272911f753441529dc636f00b3d4f59ba16705c5fa47e6e720bef50709e48ce9224e350099a9c5f6c94fa122c0b0d945863ba2a799f4304f5c7d289fab6a78d596849fd757661d2097b02f85596dafc2d00b78a49c097d42f55e741bb9108a0e3a73755528ad4bb8511a047c53ef3d0b20d1769c7b6dcfb47da78f6d385f783576d76d8588b834ea1d63dd6ae3f7f1c85c06d52be40a9fab4d3006c665c4b21dbba2fbf899f31dc6b9e8c0939addaacb116bb0df18862efbe77ebc9a86a76dc7ccbbb381a172fe555d252be3a78f20e5339effcebd5a94798c5b757e17b0580199586b4768af51d05e49b63c375dfda31adf39889ae367e49665890fcb56d873d1d44b868f0b96e093769e125d93abe9515c1b62019a0be62028e4eeeb265d500ea2987ccf206fdde2db3b5fc86c899349d428734f32c8f7f5673dbb0f8cac3d46128d5a564740b785efa30ac14c1dddbd3ab470c70691b0b8e8808052d4579bec7b537d62a2b4ad0820ee78858507f07345dda677739614414e305313ac33609a595ed5b404fa0a7a6dcb0e40878599694bf1655f63b88e1e3b0d4ee7dbe5b569324cc103460d162811ce807dcef9ca3785449cef09af6c34b6f3bfc0091de1c5c3bd08a8452563e5bae5088f6539fe04fc66bcb3922ed2e22f0f10915579ef95e6ba196cc31abd67d7fd74e28b098111d277bef3d7b9fafaa52577e4bf2ef972813555c92a0df4fb117903cef7856dbb84d67bdee25fe3442172110cdc2b348f6b44e74ef0fb1ab35cf2a1ebd95163626c36cc411845bef8cbc6d96c8a5d826d77c169781b8a1d4e4a277b16efe6c2e40e2d8f573f05bc9b0a760a33867104ebd701278e3c41bea4b24f644bc8debe465eba68950c143b7d21f84fdd4c794522dec76c0bcc2c2e43250aafd9265eac99f87d7f9e95e5480c1a4325ab220366b87112e2fd04929172a4a49334b7711f444b390c459afb8fb823278e3a59576825b93dfd4c839d9df066d7f8cb8b49970cdede3395dbd1ecb4e60ea46e31cfda5adb3ba3bdfa3866b8f2fb4f75223fffa4e57e6918c4953c36d7e41b1724b5ed8cf46d75f642f76c37ef6c84d5e9be1546175f629a552d52bcce71b6459b6ac923954e4f293267122b5b2f93d08fecda55febe129a865b8989634145a8b95008e8e8fdd933c62d7f3d6258b63eae34628409d8b5e290282abc55d7d8ffab7ae468fd8471f6387748c29ac9caf2f7b11eb604078b2fd6290a0e97d2bc18c88585d761745f02e38545c8ec3c93249ccc35e3e00ada0535f4227bd9f4de92c7155f4d59791d1c918a35d684e612c02eafe9dbab88b538a19951ddd98d3a05e3935f2f87b3b6ea7cf095cb27a3039ad3343c621d8c4a8dc0898996d78c0ded088b159cea5866d7d652348f7eed96a6e80cc6a251738c3b2db6306bc0fa933b6a90eb1000e584b035f67cf355d2f5b405b2f5e8d6116cb525996e34cb2adbbf30aa68e7c9c5e04ab04cf5e33a509469c247c19cb8412f870aefdddfe30b353fa97c99c797de9aea7e698ab3338d47df215e930f2a4a3923743ea7ed17dba8424fefc923e1b24fb49be37514d78e3ad459408b17da23376860b4f8df1b9d46473f24b7494c94293f633d03032516323fb356cd41e1de15e86e6f0db97d4f38dbd82c432da1ac9445a10806b98a043eca061fa9087c4f47fa84d45ba5ece05f0c6b7d39910b5d00b86d585e8ecbbd1adb55d162c9e97e1fb77bf4e1db44da01a662243bc82dfffad90e760d02c10a09f88a0112dd60f3398a9f1c3a1769074e672c7f76bea840f5f907e546e5c424f8d9afe49ba11d2e743a22e1bb5f6f5171d1e663df5a1e77676f2f746c07922620d9ac1073ad2e70923000c139d1bd7871c62d84ecfe01ca838dd8a33c7477f2ca8f833c199689058d7c64be4f67398f9735536fa37df5cc31dc74279274a0d991545ff9a1bb5b94baec0cb74e22ea4a1c26059ee863066a4b0b610dadd1a8bf57ca163ef7b99f6bda61132fed6247ed474377dc5f7ffa778c2a95f0e8f6589d7eab3840eeb6b8fcfad1d80742557b022e6c2dea14c9e32c86449e56a7e35cbc125fb1a12a711de620acf7d13a54aae92dd0f62cd6067973851c7473484ec58b79f077f371a9f91f27986538f9137ba03f62c8b7a3a8b30ac713421fd117c122e8b19f3a5ada64c2d49995f481da18533040012198a3fc16212c5e8acc344b6eb3f29be75b5515f2d1657b5e01f6574205b73f9bf06913f1bf364e9c41370c5c3c4ec697890a2471069efddebf13b3bd48debd1fec362743a14317d986bd11fa318fadee9d2dafa138ff808ae53cb1897ff0f33a33e6846fed09c8a6a9326780716568cdc1c086441f02fa970b4b0c767ca9e9440782c43ac34d79a337a55c1d903a0b3af537b8c06c60f0e57bc4aebfedb813b373a2a40a24d60394308267ed979d094b0e01c390f9cf70d982b1676533fce13c34c5ccab57ca7a00a3d5de70f472698d9de9bd13d10587d6a80cb87224f66f2b474233fecc7ff9484b6c16e9faa8f90e394976e3a52d946e9b02e0c72a1ded03755d96bb4f873c89c3efc1f69930bb52af5d4a77494d6ebb6a921a24352b73033c4a5165022e12ff9c5d93d99e2dbd036c76608d38684149da9051c50a11601ddd2dc0a754a0832c38c9081694277c3011d2a1c0a25aa227db13575ee7eebdb67ce389dc52bd1b105b12735355bb5a70397ca0a687974eb5b4f077c1ea83bceafc4fa690c569d70f530bb1e7942520cbff545822418c5d7920cc97bcfeb6df94fdc3741ea165442a7f45812ab68fdb5068f1535234311cb8b45146d8e9ff11714f239ab22e76bc0f720a8b6a04cc8e1d162a93d45552450ca1ee7b6eb7bc3fde208406340b5e84d9ed5cabf1cff2595cf514cd16138141399e8957fedba0a5ee806de954b9d66609e840f6a8e6d27b338d704515b77d4ac019d6c596ecdd5ead017c00e4825cef1158ac7ce64eec32a48322b8abc17a9f2230b488219e25631de5b75e826a9f988a56a4a803184c1f2f527e32a290e532cb73a0ccf345b5f2252a433465ddb54e01c75f15fa2e5a2b80700862015b1f81c122b14d83e86302a8cb6add35a7b5f2641013cb394cebe5f7af54c789c73399254463affb058066ab07ca411b8dd0356416845702ac70d61ff99c3b7d5288ec918b8a815dd7a5308a7bea76d215f2e6c4e50ea36ca744b1537aae84b0386c74259d601320a59afcd30bd4d45fec750c73b7f35d3f78ec03cc9155c6d25281cb9d581bb8397abde03bfbf493e7a46be92b53fe3092a903a1d637c1604c7914ea64e751b8d9151179e06b97edd9fd22f624f0f48003d30a49ee3dfd5d8bd4ed3782dd59141bb2144baadd38a6ce68969b4fb5da8eff12a8a9bc9ac4c7660db800c92b906fe6210fb9dc2f2cbc9a7f7fa182fb24a3e7b0d16f59c08f8b5ffc89010aac4465c89492a989c06f13c04d1715653344ea673e20562c0a48a696f5000d24bbb48ce2dbd5628bc2cf236ee18ed1b9187df3142c65433b60e71dc30535b0f636f67a43db7d6b489ef44ae21803d353228e4d5e7bd75e9e32cc7587edb80c073f800d1f30957036e13e5ba943d1660aa84ba9b02cdd65bb19b3724c550adac595fcd43e61c36055371a3f76e825b0a50affcc610220d42b2cf916d121052f53fb680ad7fc25b2ab2c817d78ab28e61459ab8afe2758c570150023de3fa1bdda657769379cea59601f6d1506334f25bdd6294aa56876d67347783cdf26d7ac014ba7ee93e5233589f5259c467c44d0023390c754163831a07780e62e0b5f7d6b6e3d5e26137c129c871377d1f97b13bfc93617fd6b7b4b2e0d63edde9bbf5e50970d6456556d28adcb7d73d1aab1d156fac9d5a60bfc006da9e238db0b1c96f0c52bddc9232d5299e78507b506d66a24f111406400abff7d79e590b401167ea2f977c5dbb298284bdaf368108f096c4c2266feb597d689bf9ce301bfb20820fabed1bf8981918fcb09ad4565c69f1f99a7e5d12c471acfab998e72771a93745955de90f460fc63568367dcb7d291405beb2d7f13335539ff5920e240fdad4171537b5c14941dbc89892f0c739510627ef433954bd8aa4e5cd3c3d0f0c5ee872db44e463599e27a5f0fd7828025810741f1d353d6e8d645f77dfe519b560a505c0b4ca88dc327fbe01fd366d889336e151f1cc745cfee373abf4363d3c1291f82caf09d190820d666e14d6ebba57da58c1c3118989b94ccd12b024e91e8c3a8d3d4bc16b104c33608d211e8b29165812987b32ceda73f27611398658bfb093c6b2595ef0f387142b1e2c1c44287b2eb57adafa9ae21dd2b5d66251a43962386cc57f0dfdb17cd221d525781405e7beec9dfe85ef16d2da8191a8a669fd2991572f4b857efbc956948ec2e68acf941180ad0b1fab783d128f515dba27a57f9c12453b1463d6a26bae0820b566bd03a3e0c36aa294fb2081153de958f9ab8c5c15786e69934ed653c559b85258e7843d96732ffd26a236f2861fcdb7b91ca93d3a1b5ac5f0fa0b6e60acdbef4bde3a6477712e3ba498ea5ef2fb46107184817d2bb9a0e070a9b7bffc63ea07817bbeaffcc0369c3df42633c93cdc72d511f6fa5455d791355f9cf9011994d7ccffcf9423f3a4fdc097077e91c913b41fb32e9baca742a170a0a79586d4e600a19d5c23823335a31755099b30431402e2b77b8ba734fb564149b52a529b8dd6e67bac7ea4bbd0989470b54b5a2e9756ae593c6235934253abe4679cbaedf79bc365dd97304f14b0771578b4a57ad0dffd79caf58f1b7d26781951144106c80fb117ad1582e5515657ca4af9723114c538a3987ad69908a2a5500712bd6aa15456769c0a2b89e41bd0e2764ef9c5cba52f46d4b3d5c7e5810296c7e5ab2ea3631ea0d69a80f40d603ff3b76ffdec20c14a072a330eadd49d91c782a2c1dee40cc761055f31ca59348d06204fb33985394fcca5412df5ed5e0cc5b75c27bf79858d2f23a4939729aa3d9f937061e87ea9c9c3612db1c53369613fa2cde82f958c520191eee4a1d4981e4d4892f62a7a06c35a8f29e194d9e93b057a0d2c10de6306203ba7479be96aa12de982919b17f724695069688386842db89893b7294ff856d6756be443a61a140f07f99a7f73de849924260fb99d734770e1bb38ed471cb090c574bdd760cfbc342e387f0fa79c1d4f54aae299bb9bf7c16c570331415a0a63b7c441e1e7ff98357824c2ef0e2e48c77dfa54682dbd7de8c4bd8789c8f375990b88a0d5a98a7822326e33671da4d0e7fdef40b4677580f879b1093b8eb75482dbd406849302af1fc413ca6e5e20c761beabc138b144517c271d4dbbcee2ce10823eb221f6faf0a87077d7075a891e8499987d40a74c016860a4b5d651019782dc179675779945e3f763f62e5fcc9aeec2c1ebc5b72dceb81c1be4fd9a25d0477bb5108b0ce2d9ef02471d9b91ab209e22e232f5f7ecf61ad44d2edada75e724e8602f8fd92632fab13e8982b90bcfe21fcc4c21718b961def8f63af509f11c954c6eb5af85dff62a4e5652ff68ec43827150aa4da696ebfdce2e5082fc6c18b763dc3f1e6ad541ea5eb35fca9bad7506e40b3e31981cd66cf51f7a451d82f3d2606f914816181a989ef6615aea25f9d3557127076e46fb9a319da4b08fe9e3980e65021bcea3700126c6be322333b4184f7ca25d7afca98b8736ae6c789f550320497c19ce8d8179b3f6a3f035781d6ed000027c4bf9f9a3b553a58bf9f1065ee8e3c96597a2b0e0a5d107e613d97342bd5a3d296341b457d3a9b63c51c30cfd6c8ae272e80802d2eb417f643dd49f275e8a79f682196bb504d55b071aefba45c424d9888da42436d0a46bef842a360dbc294601770b1e8dd954cc6c2046be55edee079dd4338f2a6164b9024b55e8775125e532ffde1478e02d48f601289d4749934f7cd35f81b14686b4e133c76a4298fa563c50dd80cdfbb1da92ec21f33149c184a7453aa559ff9c521e981a64d8c0ac72f876600d8c5217f67557c82608dca1460bb8d23dd9a866b4e74bc1ab6db6e2c9db20933a4a71bb4e85b1be55951b9a0bde640763c25432632f6aa9e049118076fc27706ec7611ebb1a011032b828804fa495e09f6a012d052e880f3348cc50ac8f047c35731e88f3b3f87086137a55f430d131de154a927e3746491cc02027f9f740f9ea9f6f44ebd4ffaa18f6b19524441c7655d12fce7e47f57fc1cec2cf170bef20eb31ed8da467f8add7ee7113fc0c437a81abab9e6e26376eda9f9bbb02754245f7393630a468930599dcdc3e2e31e09d956f4302bdda98cb135a07fda7f456583ad49b623112daac1529cd1ff5d2b921f0857439c5778856c09f66f9f13dabac4af280ce196764bfb97cab7cd1d04f08dd1b7e472a7dc7e947d3f05748ed1c6cd7e3e987b140b07d65d1db562377ab76047283c0a742451c66ccfa19a90bb5882791f3b2fe007c0c0cb38e2f7c265457a0189b17d40f1f306bf7b9b6517c60310d27562361e1e9cfba01af22d09dab549552949fd0d38277ddb1c6a194221f9134b0a6abdf6639ad607542ba338d6260426c1ed5019e600ca2f77361513b57c22d00b5114c4efb2e91ebefcaf340fe78ecadc3bf1367c24e4f66ebe2e830c877a3761818a6b3abb22b14e6806f9f475d0ed37a0816c4a841673d05ee2d5346a1acc9eec8fb9b9008a263c85d8e51fd9f827dc0bcf49157ee99e67d8324841b1d110ff1938f1d9f2148622eaf37f634d3f6da9e3421c77c406e431a4dcaf891e74d761cc3594d08d3b30b7177b3a0b2dad0fc1d19f0aa11c655dea4de91406d60d568cf552b467d35bc23e38d42844a9a6f25dc0cd52380bd3a2e45543d5dd5a5e88cd9775888faac1341bd961c36fa839a093f19045d2dcbf7a67c4ef1819e22cc40f25df11496d6157cdd2f6230615dc051fcfa704eb114ad88deae6a0982415633cb7b2791d6d818a4175272b5d51e91b264ceed0e0b8a994a8ffff9ab7b8a10e0c114c119491667b29f9903a0df402a3afa0567d0dc5f2d661cd18f6f32bfcf79a0d6f35b47fbb9d01e6619b7fec251c3c6c002baae09ee58e6ebb91175a0db2fe0eb1f89d90429f1f705d42f83c16e91106059e6b034f6578893b44627ddc96737869b0398c8aeadc380f1b4ec360a8db0cff0a56916bd70687d0d845479d99dd0883186b64223066eac861ed6f93193568d388c2e25dcc370efd1ee923048cca439c8b19fda6a1fd6d68d42fca7409308ad39bb311c550a832f0a40b3703e09c86b8cdf274105b7e474f6c870dd514d3ede7b030a1e6db177cbf2c78b70ebae0c8a747d615780ffd39d1080f982547bd3cf146fff92f353a28b960359ece004a084e27ac376b5b67e245f67671d7f04d4d5a5191ee168bcd479ba423d89996a4bf8b0efe5c18e6d2ff3f2204479088628461c6320fee34f9ae1866ef53ebae296ea7051bd02a8b93f66dd049967f1e19693bd591c957a142d938cc7883e4761595a7e1b13d86bd862d536bee5f610c15c46a09623410c83c710faee11a8d126f00a0f848b1c3f4a1e358b5425b809e57958d0523453efe991b87c8449a0c42e299406b680f0dbca98160a57b605f644a4fe18e31986ad52693b64215032bdade9d2d21ce6ca178aaba186e28c0bc4ccc11bf7b3704f842e7fbf4e554529ce1d995d62625d934312367f2edd951a78e52613a22b00f7c54ea167a985a0ac39d877d259acd0ede52b5403de62a8138caddadb9f62b4665a97fbe0f34b8391f72240b8ae7bdc78bcba97527b2f4accc928c399caee265ac3836ce8f72f990668a358b5ab22e418ebe2f9add7fc1822532cd83567b3367607b971a7a7457e068fb6a48dc39c79ed7b82fb51908885d4dc450d49af872ab55bdbcb2357ad144bcdbe0f151ad7dd9abe032d33c0331b6a074f264276e7eb94b9fe1d68b2c411e46a73b5a2be72f1ab2b82fa7601a58177358b070d83845801898784586d6ab43b66d81322cb804635819846e378d5f15e96e7019233b44a87f52e1c7514db4694da5ad53fffcb3f136e20067e8743d04b921e83e8107abef261514a3a9d7dffc837238daf2b48d8e24026e0ad9f8a94c309ca298375dc1aa4f54ab7c2b24e606503fee4e62d5870195f6d867006714326b9a6b0a749788f320ec54a8d18c6a35fd61d1ef5aa9208f319fce34f68b747e296cc7c0fb906dcbfaf61878879728eae585062813b596f883ec9b9b00c89c6c303ef6e6246908a9696282f44e82217a06d526d811b653dd88c635049dc2f074ae5bcb8de56c27618b08fd3dd92093f1a741d3219f295e29a66db56617c93cfdc59c2dada03191e4b859fcbd4594092e31fc8f19022fcc269a8552ace76aedee6e1e4a4da4ae6022acfeab2e5d68262a520c78672a4d95af6df514875177f0128dbccda6e6865f6cd9fd2f3816302443276513cf35951f8686f45e21af6c637a3bf886137fab12fe31780c3dc51a9b5172e8808f27e9ddbf38ad9462bbdaf142515f28e4f20e634a951703fa1d9683bc1bb03c0ceb4b17cb05a633e3f403a7c18aa06c1af1c62e8fe68346f265d1a0f87dd47b856c4ac2384c3e2596bf2ea3f4825a39eef58adccd454c8f7331253bc23a2d5e0d966edc7006fa04d6f3631f8a8d08378ec6de1f3f77040a4ee17e2eb13d25df736ef52a6610614eefc1569a2eb1c2848869f6de4ad1e61d4e1a0fc71cfb4c919b3e045ff73f35b9811a59f46316925fcaa604cb4b9a8ca2e717e7d8ce1aae6ee6006925ce763934cd188870064a30a3fdd40913beea3336514910ce01819523d3c75104bdbcb4f84cbeee660c9af17032332f1dc95f2b51e5464370171fe0b34e1954756b0d1e440924fad5ead7f2da2401e53ef4155d2af234b8f15ec0f092b9329fb9dde60094e296db0dbbf0a1d5a02f19c66c44d73e6f61a7e1b7ab2a39a88b1ae9b0b6ae3a78e1f5875cd350cf4d3c5b21ad59cd45abb3cf005e0f69e229e607c004ba82fbf29d64f18f3eb8079915da86599d4d207809ff34a69fc3612db690df61a450c549416b9c9feeb5de03f96753cb910490e6642fbe53f64165e825495675fbe5f971819da5e2d9d5edd5c6e81e217ef61ea7380b7739c915d747488144a82bc5777ee2c831b84d8546b4186c33328fe9d99746a993715e0cca4458ed089800ce1c48a1e390fab49104dd622b9e3f2bd23b0bf2fdeb5eb2782bb0daa05ceb0715f11f4cdba6108d5fc298e9d859f615123f198f89ee3f69145add9b53f0eb5d59be998775974fdf49331d4f999a07c0b15762c429ac189612380b64c25a87a4195c48f931a70ec0927b6f27b715c23f437360d96750b9b3a26734cbe6b1fb99d549e68d94c87bd795d07601c0af0c596e844ef0fc92f86890ea301847b07bb435bd6e936087de357efb05bc05a78c18c5d22e1baea7cfb84f8ef4b56391f2a22d3c441bea220b2e1ddaa9d0404bec0ccc0a43219feca264d3e35348ee7125d64bae9467736c093901155e1cef889ce926fb32ecb550bdfb3f7f55733f219bb6ef0b62227f17fcc86f86a527ed57ef3dfbccfd3d85b460ee4550b4a938773e8f3aea24c6ea180768b7f3853c4c25d764d7d9611b970d056d820335dbe3201851aa71c3964a9b134698fc1c62b71a328ef7030e1d8f25b1e8d86135c539971cf05f716df085cfe1f3ef57e2337a09d90ae312850d064c997b0ab63f8b1ed7b00447a02327f89d2d6d1394cbd26268f1ee7d0fea30859f520555599aba69890db7ee0d009d5ad0a9293ecfd91358baab472609547aaecd43f3a1ed309ac910b3c9e57ab0c7afe9dcb64285361a7d23609a9dfd61a128a6fbb8315643d5129eb0e120142f398335181780d683e5b2f1e461e04521dd5268a30dd201b928a5e0f37a71eb9950a4b6a230819255257c204cb2d1d3c1ffda9810f7f745ab6879604ca13fe498109d55663fa3a2f55da98a6d66231a9bbab443d565fd137055d4f50bab9c36f06f124c789e3dec521eefb95307ef973aff5dec4789d26ff328ad14731a664aa95ab243bb1b60eef670f820ac951bae19f9ee67a66aa3cdee5e5c73f42c90a9e47fc58e9b4ac4b1a9863a204fd483589af2228a18f2a7ad168ce380b9b8b2ebe5eef6d1af0841b716d20430debde0a8c1a2b30e8a77aadf34b7ec699cb5fced18f7872bf987b3be6d0924fa6fa6289b1eee269b158616e1dff59990489a7b88ac026d9b880b43d2787aa74ea858a1187622b990132e5e0b46bf3acc164f92d5fc7624145016650663efeccc117b659b0a1100f9ee8e5b2e438dae481898e5677cbb8b82f71f4010c6eab0a5d48209179d9cf32cfe7a436bd0fb9783f379a3fdb74b381609b56f725381ad1afa4bf0fb026f8204ddd819b7ce179a532b81dd4c47eca5e154d98664ac2d6647e9f5f722997b242fe8c5e66eb47c4df9b3c3defdb4fdfbd44ea54099d9af2916e0ec88288c45e537e4e210f56f0474fb0933154dfcf8c4d451526ad40d7d251209b1b47f22ff905eb43f66649fdbcf7c8701d8586693428ccac82a0bee5883de7cc51564a9012b665a73d5f21c8c2e9c47b07974b5d0a3f74a10523460a00b2d046187ba8cd8d6d0e64b5f28b57b33f5f3cda315e3d22c2e51f8fac57bba55dc6e05a252675316f47d840ab83034acca59cabfbb1707b0fdb45f6a65ca950247db245eb17abc5fd8305d38ab0411fa2b76e39eccebde0c1bf58b34d08a0ca97e8028b0715e9d96fc80f9bdf579f71b3e41b9f38317896d45bc0159234109f56bcef1ec43c113ad00be87a6d33c6f1be99e7a917393f925e6e18e77962b7c2c8527d0b31dacbda4ba1a63a3e7b6d8af703291ea1102ca87611e6ba919f5d1c68bf0bccfa263d43a035360fbb94e6aa050c926445c4068744173da1c25c82e20d7923c97e5b17996efcf47c3675187a0e9d1063eb7c30f336340272ca3910a743d7d635d4263b1879ef63cfd3499366a824ee3c878e0bf95717ea888ad0bb03429a494c3b6588284d47d4e553a2afceff103bcd5d779b0668770728421e6926b6749adf683c4c195addff7c67e6a7ecf5481c5993f32fc39709530f92316aa3ae0610145e2d53e18109ba04e06cbaa9933dae3d0b83c61853a7e6a9a65ce2316f3f0c840259a098d28e8c353ba978207247367f9e035825f67705b677bcaf3876c6e48013150429c56941690b9b13411c400ccab4612b89b95a18634dace7cebf4bd86fd18395dbba6f88c8f7fbdf0f11bdef912e424e7e9061512215ebb39c2f6496449602cecd2b1824c8617948ea0094bcd00d55d0fcd7a8235ef83a3ead3c993d47c7b188e5dcc6ff690dc4bf94d03233cf895d8c3a2e89e2334ec18665f2353b40e8d747a4e6153e4aa68c8105cd9606144307d7588183dd7f68b03115316f55724dd2d8ac13053c584d4012286bbf375a79414cf5b2b729628eaea63f9470996e19d26b98225c2eb6879f6409a52c57b9379dcabd342fcf6900c80ae140c65fd133bf5c55b83fff422f2c7966f4185a8c0207d87deb676af630ad004b05f72561e1f77686c21988f5e60bae445bb4afa3baa599c15a0d3c4debca7a87f68e49be84a92e2465ca2f470349355803e2197fd9f0c00aab70eda5761b9cd8d7d2a249a501785c9cc0b0c42920605fdf970dfe10ac179e06d5a14f4cd2ec60c6ebd90203fa2f7f0c63a39786610e1a7d890434ad88b86ed7712e92435fb0cd0fd9286a64374695e3bbd8e89bbf2dd7bde91f8c0b887f1f54aabfa5a7f4f20bcfa1b2495acb5e597fc52da267ecc96c77e1889ff0cb3e9302698958560921432156672f08629b433e2a8694a41b519d4650c0577e6555894bbbd408c00805cc6ae66d9d01e47f5e329f916997d9a3573211be19afc338a5d90c72498758b5fe57677b9b984a2cf896a8f17680d5417670b97420dc7a77560e839c0e922572011d8433ae4765d3f28043c684088ff07fc730df4926609e4863aa81d977c9589ad64d5c427243e89e99d9d578b11c2cdc3aae395da2563b56a4201007dbf437f976dc950377860952cad0ab6666f3efa164c5144d7f0b2c2ffdef09cdba059e5dff8dad77454827e39cf9e332ebc40e01a03e1a2cd8545d4886d3e666cca2bbff90b88b73eeec8c4a89c70245fc7b08de4c9f815cf23b3431d38172b689f18ad54e619b494de86e1ada872122f1d7c8a0eeff00513605e4eda02a60ad201734f8ef6bb5c060e37a0fcbc479f39fbf225d90e2f65917fbd0adfbe283bccccd8f6b4e37c97ff4f9a1e8bae0c0b9362100242d2dce16adf70cb41b98a76944409aadddff10f02ec61e98da748359b2eaa468d233017be2b99f28a5f2eb7b913dff8aa8c87becd4681932e04e96979aaf77a29fb8fe9e0be9677a477f5d9ef346b753219a1582122440659447b9feccc3037b98129b2f403366348c1d4f94ef772e936a88c3852c0d502445af09f7def9b4d6ed7b57c5da8c284c693f99887926662937a3a31bbd1ba44b5e0b2b14c0da1310d8423174c34b62bfd75d02aa49aff5ce4f82441e0a186fdf60a8baff769f4211cb569ccc48a8fa7b107b03b1bc64ec432481b6900a34f0155c2fdb9e3324aefa27a5b2606d71bff0c5f24873901048a1ba8de532474b45519e6f63d33cf9634162b03d091bae109a3284ace0152f69b039d6f4113c64050421b12b8484355acf35806965f3e5c193d3e12ded55ebd667e3528da7681d0285f6c9773857fd546e2c133f2e97eb98ecc7de6a1662d7d1b43d92501249455ecfeef7ee828e1afa820670fdbe6e66144deea55aaaf98dd5a177212a21f79e1cdfb6d5ca4b28c21674c4a029e6f1bec1b3b617d174c3311d440d3d0d17bcc30516570fee9673501e32bb88c3798ce47bcb87f852fd600bbcf4db5b4be1f9d8e54751970b0a3c95d72e662d1e6b48d014e3d79a639e8839651dde4e84d2ed4903c68498f94680f3ca1f1a99b1a91d9a8e05332ad2702e0369e78e0a1331b0957e13791a771a6cf30c22056e89cb5ad7a02efec6ce2e1b9b104938a94b8627b16efbc1b660039ca503fa9ad639db4db9c20950bb47d0f29df29dec27e7a0c361ab115db5696f9f40d86ee11d8e014611aad6e01e54a2b4fe8793ddeebe7663e7dd705243507f1816352c86013562d2906bef6658aec54a54569d4af36d3132ba0627161771f33cb7b219f4e283922b45dc8984a7270015e10de13d695e8dababc972de96a210883d7fe142b9cf3280d3d9e5da211c8369002621585e7be9e7193aacbdb6f66ed8384d66c8eb9cc2e44e91d16be1633bfe84dbefb3ad8de91d27fd6f70e65f47edc76afd339171973916540f3f6f0f104a4e104ea83f8837b15d32de251511a904926bd836cadad2ee60da323a6823e5ab09ffc015e7dd0f4ccd3f43df9cb4ca44376aa892ce89351583f2a036f3839d6304a2b96a8b4daefb30802ec65687de91c3e2779df922938224eb1dc8fbb16353479eac6fb81470e78471e3ab53d5f824dd0dfeeecb69e32207d91be58d3c8a92578664a0a04de83fd04ae67631c56a8e456f4dbc56429b7b0d2fe55326ea4aac51ba1e86fc0201efbbeb6f2598542e046622a8febc2f662539d010506cae9ebfe63fe41540d8f5df0d5600efaed0d881f029897b050083b169fca2ec4834cbbb305b63b15af80e503763ad43d930d1f16bc82a21b92a5dbb95b5e179bd921b8eec5e323f238c120a117fc32fe456fc7dac059f3cddfd2d01ebdbf2f5461e979fc9a99f29c98497c46dd02dbd17bf2193eca1b0a7dc26491ee8d7b276c90e247ced231a110ccfa71197a46b601566d6343f184fb9e2ed6055ab32e63de7cc924c23502d2bceaf49ce57c30af63bcdc7cf098c39f6210ece60b0094260d1ce3627f56b179eb1bdffb64276ba60a5a5811eca269e3edbdd2828bc50a800e6a4215880478383d5101ba0baec1b611703de61a91a2eabc2633e2433f3d3afd42d550aec79761a8bdde10980f9caab385d08ea2f493a48c9a043b856a722a7e4d635c784a2d975be2f1f589124ea118f6fb38f73ee42afc5f47fd294042388385f570555693c37ab664210e87cdde34cb3195c926e772bd13f8e22d349062405615b207f0aff5a24702426d0c4fcfa87e9b7e357db7464835ecd15e832064ff222d2c6f34af2f3abda111c4c52f8ab5c61e4abbd61d51dee12bfac2d6de0db564408edb7246b6b0ac959f4a55082661101c15e5aa7d50639a36917d4c86a7b163ee8117ea47f917e6bb498333096eaad09e676c1835bf670da99043fb062342dbc1cdf8952328653b28f4dc59c00df2522b66ff388ac0ce434b782729543c8cf5f5142da61da291be2f5c7e39359dffc9a833a9665ee6c7c3c1d1239997c18e05c5d3e77ba58f825df33f5437e785065d3b7556a357855496582ad2da6084189e077bea738864fc1aaf19029eb6240db11272369c88c1f132ef4b4613b73d9337258b3e8f14b98f2ae601045dc4bb1544b3d2d0b42c91ec539cb83c985ae3d03c96d8b8aab21640db8e38da4a514fc596822bdcdd1bdc76986b24af7184abdcc65229f94124e6b61d136008cd6c102abec4283733aff5ed2ac0a8f8fd6a942858adcd17ffb114b0f9fcfa213e000ad5dc79f60ea4641e022d4fa082ba39427650f65276656f82ffec354ef25adc811d809271cd16501892c856d0a5557569479e1a9873f0ce8c54df4fa5eec2ec08a80c2dbcbf03c94253c4f5cf78c81087051a747502375afae8697aff902f304923f5b53fc580ae5d7875f44e804943fdb5a87c382497b0b59db783cec287777f1596276ccba33d2a56525bead19229349b0d9e4feaa4ada76b01b04998d7192b40d218eae2fa28bfbc758d850abb19273aad6a4e17bea584c751de301200b8d05b47bf2285a13e9e379bdd4798ae03da163c7d43982793569bc8662e7d016e12e7e3b89ef4db36ad0137980063d303a359d2aa1d1707155f115ecf05f332cb7448eba7bfd9dffaaeee7262c383a47caad4a75823977662c64a097635b08c7020b1cec0d78379f7a81e9666c6dc212eb48ea7301706bbf69c44b076740d9708d6ca69ab8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
