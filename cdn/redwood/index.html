<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2ed59efe4fa6eac55326c551b9c6e7339a91cca5eb86a1e0ad565d5d47afd555b0e3c06d364596b4fed8990fd2129fb6a94b7ae49ba835c0c67ee091880fdd80b9d70d0eaf14cfbcac014e6878435215d3da8fbce4ae0eca792595a5b23bf097f246bda8568b3eac31cade4b803fafc6da0d46199be43d484fbcbe70a6043fc82fc45268ce9c2e467601aa38ad4b6f5be38ee49892b87fe690c5057a2b091a737e6f97891ae9bfd4fc28dbc3ed432f843069d336fbd7e72f29e1570ced270695fa6d31fc4010af5ca371423431cce0e9d38da27bede9373a650475ab7f7c078842e75215b34af2f5de920fb53b26d0a7e21dcbbac2ba484bf0b7c4d5f5f63680b9f37f1b9c9cd9360ff9ba36751bf00ffe41069405d0bde1635edd24abebfe71fdd92f5154b733c008fd85578ae381beb275d085e87f4050527ed9bef8df0e80a71b72118b10b4aa4bf10dd1ea011f95ef81cded59154533db49375a426fcca598cca8e7dc512941cd46bd6472e79a57b598b5684864312665340084d0e85ba95989a836517ac3bb28e758047f4613b5060030c3ce3851982f8137d75e6d34fb852b73636181b4d77de47946e5b4cb72601d515c3307bac6a53c609c514b8ad790c8a33e794f03b511198dec737f4f5ef9576af28c33de97bff86dd3de55f3bad269e469e1ce129fbc71ee80bf69e234d976364df7e896a10e1cec65bf97d8838d12b311ccc141e148898bc94459a2887dfed1896e7ce2c840d60bd2bcaf4540342dd278dd54cf418da9210d24096f934ef0d9ba0ca1687174f1b2be6c5cfbb373a614b4c0c87d8f2d74c95a8f66a76ae148e8bc20e374d21529d1d1dd443043a20799e95055ae5e6adf77be2389a9e58f7cad7c186bee05dfafcfc691e1bb805d75b65e5282d08ea1744d1d1ef04de577e3e068ea273eabf714c2206458101d82fcc89e7336b3171edec124edb0e03f2bc3698a39ecf8bb44b9f25457b571bd501f85fbe064e910a9771f966a2484613286323c04f8b1c6fc7a6844be5f77e50449f5434f35736ad58620f9d4dae5aef6d25385dcfdbe3edd0848c9aa9a702e76a1355b54f82ed946b5e799ca376e550d6a4feaadeb7a6425ba5ae4ceb7ff4529c1ebadb8687c362ca573a665ca87440991f59d6b06ee263dce85c913dbbf82e29e4494e6dddb25a020e4ac9a0bf77ee0eac71673280569b4d17c73e4989a783c1a0a4ca19ca8547188a267694f8e29ec44acd2ba0011b2e0d375967f3bcb774ecf57001c6585057bc21b6197d82ef2b6c917ce510ca5a3cfe68d94b32005f5418c220820517be92b101bbfd0fc6b859727284d49a07c57aabbef6bbc8261e96d1e69ebbac1136ec2e58cbc7bbee2913b5994ed3975e4df1ccc7d164d39289993eac10efcb327e41b40f4db18fed88f928b09705856b296e5b822e1952251e8bc8e832033355fca40aabacc93c9923907cc8ace6add80a9ab424a7fd86433717455d136e377fb6b403c063f169bc0437e1566b16399f1e70a56b975b4d0a4a5a6484aca9d4315a00b6ae71ac0c9b3d7359d7bbd1df17e22b3747d232bbb91e216ca715c1dfd28dd090daa1014390140031048d22308e8c3791dcd873d73f7c437a3c77f474fdbbd3cd5c95c4ca504d339e2c50cb3d9f215e4fede25bfa22156e6ac6d6d257bdf1d95ed24bc7064c3db285dc1640cf276bd89ccb2ec342a1a99afc892899e8b6c0a47688dd755343f233d2551c5f3f517bed5dea5a4150ff0e06a5fb536cec472acdf41cc6cf2f3d91dd0ba56bb9fdeff633f7d87fb8de5d4d22bf5b1f5e12fb8e9ecbf880309d0af63f045718f5aaeba5125afecfb1b8ca8dd8e77d2463faecc51032b0d98dbf58c878892dea7ca6d945dd1ba28b788d13843717899f044280574199db0bc123b5b6a60b8b834283b7623ec2f6ab055153ebcc39975cde89fc518ae30948455340dd95429fb2979eb92126c18d57ae0e52b7b057060e46e84bd4f02bbe65b1e8ca560a9f24b21152f3ca4fc4889174b5759c699d202a319fd30e045471fb9dd1427f84d7f7f2f50010bdf579fe7b333dafb1dece3fe83b063837ab7c8db3683b442da573ccfa3e6b3dae94851310afbf7e9386c4592a1591c9905d1dda097d54dd3508f0237d51cc71654a9e18a53800559f71be7d3e352b5853431ff3336cfe80b15e77031e9a300950c7d930429b936733bf409caf7de33bc1c5eb3bccd609d1c8ac974df9871e086ba91f3405f1c74e75b0f016e6f64736df85ce8437086aa4110cf65d5daacb283d9709a979526286dc62f0815ae1733b00452605f7e9107ed521a4e1fb549de59178e419d6640a1e9cb964c08251e8196b53a560e228acf3cc31593c4015af6867fa631a16aa1a1fb549a135d0d9db52b24e7ab5304eee00049c912eb5234c1fb7d54f237ed1fe0b8a6c2db9a159cff75b7759a9cb668e635285fe11f12dfd93293bb8e45c48498480ece1af5b55e681c537ba2958c9cbdccf1f3280f1bfb912bc6c55900c6354cffba039012badd43e0b451f4cfaeed2978b223525e550f8c1005ea0f71678ddcf2a7663953aae9b30e3713d0afbe8e4bb8b525b2708bf0da40bda81f59196eac54f51aa0933834af5f3896e47e6fd633eb21f08980aad49fabaf4cc113f9dd59076bdb37b6ae90b23b4f5b9444a8c5414f59abec7635bfd87b383bb05da414735d151ca43357148d573cf2c94f021c11c75da1f1eb775a6eb68565778472b35eb2f100866e476a04fee478e266c6c454d9564a2f24d04fa49b485cc9bed6feea38cffd135a577863b9161b86d6d891675780991dc74e357aca78fb4673fbecd06dca50401ab607b56327636b354a37f596c5d426645b40db02971d36ca1a4d29c8db00ae6124b13f70432fb04b5471f183b4ed1688c2860d7cbfdfc21d815fc002000a4e1c7f52bd48485f19117979ee924fade77f7a11df0cd4d7658ac6524b8241e55083bf5e052d28fea0395e069b0400599d16713dc75858fbfe74a3b05e34a45d35186219a11abc33e06cb3f7aa1bb737b9dd44297dfb8df17325de03cd67198b1e9bbd1690c1642aea659cbdfadefc123d6dd0712bb747bb6a8d1be0e61dcb25c6608a2dd731f0b3a671a5c99c492dce328401d85eecbe970319d47990f85ab6eb1047467dd990784143a1a2f117e0b2593dd57ba4b461107685f739c858e76659ae52f9388095c8ce17bc2cb782e048c647185935cfbf71b770b35108c8c1ec6d95d8fcd5371ce1f2781ee064d35e71cdb61e4c7ac968edb6c1f9a7334758fa463912c0ec86254480adf912c4f44b264a73b63d5c64b34632913606d0a21c5db234252ec4792dbdf1dd5b123edc64252f1fc9513c6ada48960c2bd7f3e1e99cd1475938fce0510c2de3a1935cbe10f91a9362c3ea08162902dd02c995518b7373138c3960da9f454d526d436baa6bf968a378d09bd72c35455360368b963976feb85288c00b78cb54a9a1fcae879029ae4232fb23f24bccb5638994f449906de1763b562807a8e025abc21a48e0ec84055ebe394d6d502bec7e9c03fdece48c39dc81208ef93d866bae1b4e833a600e536f9123b7fe141a2476de2e85c81c6e45ba6959068cdec6e574cada6315e023c433525939ac2f62c49ceda755fe67ad07ad483daff8bd56e8a4af24a398c582fabcd4c43301a8984ba03bfae9ea0478091f381b1adb936e686281083cacda25fa271ee5e58b82c6b3bf7b51a832b122a84eb8e586b3dd570f472b43228d42192b6e72f29fa5ea37b9443a2611473c5e0a5654dbdf6798c6670079e5a2209fb3db748c3e0f5f54be68494f281dcc7a478f6d1752b81f0eeb4960b0e9b3b5ddaafd0fcb80adbdf55854012b4380c24451682cff5c4b8735f6c308f11fb3a76a913febf8bfd3ca5084b0c39d75fef55a8ff1be0f76925d08691832bafe7a6289cd122f076ee058357c355fae08923e5a54301f160217b66ba8bc35f3f541f4823b6ef898d874f895fb2654afa5821359239aef095e61d9367d02bf2aa202ca858b6899986adafe6d252ca52e566405a8a2fef74a8cd95c2a5b7c0ae96d1f14755497c4d67ef6cb93b03e96e7ffd9be4e3a555e4eddc632bd31b31e72fe06c83e865db2ab9653a4bbb6489dd5d5ca27c270851346d1ef3e6e793d2256175b96635dfef599578a2ba3ba101990bf583ba7c8ca3b25ad96045be0213d2c9491543366c73bb6a940105c927736ebb1d508705183e54733f2d26c692eda62aab10ab140ae525e2d93debecc4df08496541338b1423e3be3b2e27c39dfc64e7986e9f297c2171666e47765f976d660465fb58f0c88db26ec6ced43874e46c739cc4f3bdfcb51734308be151df2e4d1f9d090f4c838ce462bb34791a918e5511659fc0ec1a283b0b0e8238b2716507c2354faca5a0ae8ff4a32a90461b6c9d13d8f1721a5f02a8185c3f4684444cf273a7a1985cbfaf6d07bdfc147696c4948e364b2c4f39500fc5c61dc8d775f725628e4439c91ff1c15211acf6feb53d3d53ef1e3d9525c0d48c3bf38c6a5a0e67b2c05d367e40f3ed3fa4108c53f1b9f20f9e95cfd6d04424217657b5c0c8e790b4950a1e68ad436c00e1c4554c4b387a5d20e3bd429d899c8c3807fde17a9c6d2d042340e216b9691c87b861b7b64e44fdab9a105ce80a86112ee9c19dddaef404ef8be182e8f049ef8edd083bb46c65f90ff6615cdf7e213dc1ae98244931dba254bcff9240d3ed42a671f0598411c8327748651cdee47440b58c99135d54a21d3946b0957d31fec72fda91617f3610e1533f1c9e94b6559a2ccc6207e7de6f0693f2ad84942d9e7dd86b2f5887830d8449f7e42ca68c48b23c0902b441baadcafdd8a1ec12df62ca0690b1674321dfcf77a19a0940243dd46c14e17c87f0567088a243be4e19ef6758dae2d0fd16e417a61c1edcfc5b98abf1574eb7b9ee4a8c7e5a7075901bc9b51a4849d1f74ec4e83d887e8aa946b988eaa9766c91f1454e101fa61a6bb5a7ba1fcd899f5ce3ee2a1b8b40685cc068bddd5057924ad08bc40730f1e381195d187d9390748a47b77308b9d336c546426261b5777b04af55b9df455b6a5d0a704984bbe9f06972569effb65a40af8dc7acb3dcf9e3c57a39afea7d1a90b4a8fdd264284c43697deba08d4ee906647948e1ea589ff5af276d4acd977546bbc7785c47f675a1c55a3b3db6435a057b221048f1b9dff51eb1ee0cee19c1243b8bd7831f6ee225166ed79227942ba501f4c7c5c49bd3ac2cb07e5462b3e4fa493abce7fe0df883fe97439ea4806ada1d6ce7ed1061fe6a662c7497681a311d198a7a372d578168ee3a0c0ef5442490cf87a2519d4abe240fcf6e92e7c9c25e10050911b483c14e2d8bbd087f1826d74d6413633d3d7d76a6aa702529d1d4555586ad359ee736ab989be05150bc733b49214db5ad6909b286a16474eb5cb286c12ea30d7086c9abfd896c54a566d0c0cab370d5277abafe5cbe496c21698dc28fb91a52551e3bb15305b26ea8b0816ef6e21008a2523706108aea3119c7b7dac2edbf92aa8209bab878a6f824f9e08f309f8f305cd106eacf35d01056ea65de449b985363db9ef898f8a7e172eef4813f2a4de0256b614a7f3a04de7377041f466356071bcefbb9de7179da78ec776d7c396b9dabaea8c7909e52c08eb1b9eacffbd4f7645a237f73107507f0eb8a3b6bfcbb5ff6d5ba634b80ea903766665fb2f1510278d5f709df6793d5cf587cb0acbea87229e5b01b260efa775343bbdd22d845f3b1f827c984858f71895cb247c56422333a9251f818863a8d4b9f3f5003958c2fbeaa9e979b3f4ad7395e962a89481a3aa26879dca5cc84735adf41f199876651a541f86c0ba51426b873f8cbbaf4486a36237fe0bf8192077c19b18f3e2e029657143d866e25fcf0458cfba6873f789d0db16bedd1e0e6eb169381a7fa8c8aaa1950659aebb63a0352e14050ecc44a0d965f45e9f7cd5aadcb40ebb5164c3d3f3765f906b5472274f64148385a50fd4d5b0b45af1f49095f898880ba5277f59d6a45ec1c04b004d59cc334db9b6a387582bc6588a433c36012785ea55549d6fce7e9c604f70d5b189c65370fcbe0fbfdcd7bc7f2ec71c0c4a3f9e662bafef4069a76783289e6a09682d0ea25b495c0753aba8c6af955ec9b07b41c2ab18f47bc909db382c3460866a3f59f4dcb9126bca351c73463da1e0b69a5f4c414cad8df6b2ee1d4086715fa79c7056640e7e85413174681cd8739205ca6dbd0fa9a880c384aaecbf14094da77d89c5de08481c45ea3fc775b62c561238d21280bd90cf7ac90211636cc7b2cf20cb73079c3c78fee7aafa4f09695cdd688ccf7ebf5e7d2e02f61408f91ebe6cd6dd31124f55ee2ef99a5f9df2296fb59f420e83ae59230d21d07839132212467f1845d964e47b5d44f957dcee9d6011bfb7d0056453d66fd000658d7e5c5f53d0a9df822fa0065152ccc62bedd8c729ec7290a5ed2618cb9f860b996f8d69960c92008f3617bf140e9e3a76174cadb59d88678afbc2eb53dde94a69361741fdf18b9dda04c99d563a511bf4d4630ec96e20ae11c3270f98723b05cf66e5ffbf835ded5c3c6ac0775c591a7086af24ab0e1bba93f87ea52bcf05ecc030773ed3c3d02809abde0f80c018127ef25e8fb1d474734324a6c917faefddf29e0666f258aae09670152b96f89f19bf82ff541af9a46621fb34d4b9fcfb020b95b11c6d20d5cfc1b48a1390143416820d009cac113bdcad68d05478af75f1ad8bb9158ac058063181e05fbfe74c0f76f4015746c1ad487c024e2e0492e4d0b78ff325d4addf3b38487ffeb53168e97b50e8bdc20d544b7e1111308970132dd662794253361a0787fc7d623786993e9a13ae4f0106dd465f4bba41d6d57e6cfeeb620e6c21fcd8b27f7dc9746f2914a54aac8f69dd45b0d5e5efbca17f942b532c268205a5eb7b20892fc97bec59f431b0283aef70a7fadb307e0851cd326690beadb77ec51823049e7f3d1dd80defa7e16473ea8ee9cd5552b0d03b5e0088e07da0ce5784ea997c3cbba23568b4df1ecf0e0d42aeaecf0d869183c013eb07bead64c9ec0dd790488821e58f7af1bfb6e9013608f2aff279fd62e3eb1e88ceba18a4e153f3f954ce3805fc819246691e68dc308b3428fc2350c411956782c3e6ad9d5068f76258d744b32a9a4880518d2678a8e24f1a20b435c2af143ec959069b8f5acb35dd90e72c3e1902af06144cc028ed9ae67f7e99b65e3075e62fec2e59dd5673db807d7e07aa6e249ca44346fd431e4c44c19448a0449c5c8dbcbe2536d680458ed0d94a64957cfed1b1074bba0ad481cca440c55814e0e74d5f5324090fd1ff2483fc0dfc5d7c53b759e1252ba8943bbcf3bcd35c25d9f462723442d80d4d6dedbb2490601f6c6dfb54f78ab98390ef90a7d8fab4184cce444fab9aa6c19d9ea54ac88e7401c69db55eaf9b42553865b72d0a4ccfd03434a2ac499874569a8a4492d574fb2b85d0d8ad0daf2141c1c342967d80de03a26ba8b6e6b913b32cb42b89f1a25f46af6da2ebaad1912ff22cfd81c293313802c9d9f0ee33dbcbaef1ec523437cc742ace5cd2fff6c2d8b66ce69f0c035942a390004c6d87df6eef04d0e891a0e0cec01e54a280717deac1263876d8f2294a6d43bf84a2ee1127dc9efc4e91720250ce8e1bfa96f5b978ddd7388723a9325b358828af28c2a84a92bcb548db1ded16bffa193d2106dc7fe6b366a42d2927bd6c1530206706e2b853df785f40f6b023234a4e931bfe1b5d098c720c8606740674adc5337de87b42714c47e93496188f36539ad1515e11aa0945da819cb27b2ce5388dfd307b3a157762437da5a4fbc2af2fe674c7e0817395a4386ae3148e69428ee6bcd80eeeb435f160de5c4cabb6d6d7ba36dd153e7d8d810a5dcbd191e358dadd4d0a0fbb6d054c8f7efada9dc8f0a0a15d8e160fa8ce5eecbafc61a3eb6a176683be2bf6cbf37aec7491a1468bce31284dbea1ef9323fae175ad6352d0e06126d8a17b46cd4e7d3fbdf640490414995edabdb7e2e1a8377b050ef70ae5fc1896f1ed5969f3012685b471760a7e85f1679f8ce4441f4fb486794a3baf90e6761a2472e9ea2412fc0f4f8d41da9e20844c273f20f6dadd80938f3d1d18a2dccf452f43c509ed98b29f114267fda0bfe6438909c989145feff46ad097bf26526fe0e7d88f651034379c63ff1528823c729646d8e568d4821199822eb837264901f70580cb7ef9a99e6e923fa3f65151993abd325e2ef788f51b146aedcf9f59257b0a5ab2fbf4f7acc313a19055a77df2636df4977ddef13bea366e104ae0f82c6c44429a83327fe7a9f888f6d504ddd20e9ab34623ee85e43aa94dd3024fdc02e4117c601ce4c7ae4c12b93003cdc175ed4a80217fdae23ebc80334ba236c633d7d878c87924a8aeef02e223303b3eed1f07a9ffc9db3013ce3ba3f32d1fb49f2619c53fa7e2a59aaaae2ba909eb13517788204e75556059772e826fe9e431ad129954dad3619cb7a14906e7a458e26c12633ef22245c2535e0d5deaf85b5f96aca1df75917bbef7487ddf1245fee978151e5c1433fc79a4016dbfeab24cdf6ed03d02ba827029a2eea13c406946ad434140802a5da75d84ba2a7364d05f2cb392dd60abbc595ec1bb60916600caa4306650343d21558735672a5420d93d94edbe2ddde82bda284dee18b3df94f3968805d9c32fbbb1012c955150f8334e665d8c03049da3c1edd35d56a5e8461896e7399baceadee03fbf6fa290177e3908bf47207ba1febee0615d0d849a3c2eab44d58155b0fa57da97236cadc80e53f52422317a954ff0881c04ac3f12d944853ade43f94e4bdd9feb7a05caa426e5f2f39f0c9eb01ca526a52dd869104f973715de55b806b4329e017875b80b843b2100f00913511c8b56e957a9e5ce0229bc4755f3976e84426c3af647b740b78447cf8a010cffceb5f770ce6561f988dca4ce6f2d372a0d910ddd4496d9152e3c52736f38f876dd8cac74a2ff2d566c19ff957b46baa7c544f561057bb6fa1dc38762a8d80d470f7b32505ceba9dc6ebe456d6304477ae98fbf26d70d5bcbef00d7a3eed5d9d43dfd8b206eca9cbec01977e7a0ccc761d1ad386a9f504fc99c89a87a0e6a5dda43ac6fe6815cc52510a84bbd5eb3a425aa6e161d7749c6d0aab221ca5b1d6a267bc61b70bdf749844f9121698b8b23ebfac7a502c674aac6a08010a5302e811ed28a774112e85dc64b2eca95ea1c6fc0684092ac67decff0fa6b4931c0c67d102a2e3732c51e23fd9e889d85c90e2b9248c9bd3293a90798fde2a916058c67d972eab42c73c28376281d1cd6f8431f230f604df4bc6129e78d09ee99c50e1188ce5e5acadb96a1a903917f4d66870d3e07e670a41dad62e3e70e01f698c456dcfa7fb790124fd4afbf05522e57cf73e65b1db3d10cbdc3f192452ac635004ca70a23912d227c8069989426d807655412fa5e5ac2b98460cbfad553de8b35d11a437f424ae4cee2167174300ea3485766217667eb475c9cab3651a4851ee7616247b55b67c688d933a8d22b6f0e087702fcafe4ff7e725f2260639474a5b793872169dcd244dda228d3a913748fe0a8be657645e255ef08c507627bcb36a63b1b55dd3aeeba3a64995f917bc4690f2be7d04606d8b5dc686f0e22a53a965fa8926bd129d908b1c6b55605102cde0721ddd4e498c766a25c959092d214cef4c604ce2ef0aa7d69b6ef32a343bb90500b713d02e91b8a3f9f31ae8118bd5898d0634b34c362c4a50dc4ab1da524b9282945aaa65ed96d9eb3884316b1a21a1c1ad0ec3322bf13e9ad66f776473700ed5688677dfb67e356aa22e90fb5b11b2764f01001b03e4641e388e68415a4afddf89765617aac829c8c32a5ffeeb55d92aa3154d6eb202745a5062a1d53746eda7340cf1217fd2043cab12d83ad249783add079c033e21160b9c77bb587fffcbe2f7b3f1ba44fb6051330495289de76db832be6eea65acbdf46bb251ab5fb237bac99e681d566398a8af73b634865875fc7776aa98c98db6faddf0c595a40cb112c28be004a73587b1534c95af6b9343e30c7f7d4904273c0f027459792b10d6df30ef9530a500fa0611f70d073f001305764e2fee84400b427bdb2bfd6c83f51899a634135243aa0a34a6a28db8174353ddc34598bc1722c7fdf5abf5f9acee095baa7ec8129fc214829850b20b4b946bef2e7ecd2f86633f25fcb25e696ca7fc817314a9ee59ae6152d28ab0623f1da98eba7ec2813a12e6a34ddb70dfddec676f8eda9a59af92aee0eb395c39e7eb7f1aa7973c0744b81b7f67f1673ef1821f6d982bc9c411eea662a20e6e10350c0008e300972768caa7166025334765cf9d4f8d1563634943d0ce3c0668394c541c6e947f1f85e8fdbcf7087ad9aed281360e2a2b88e215d7794cf8845b178ee943147c9cbad3e04a8736a498f37e3ca5db527f9f2d41cb542e038c98c54078250e9598e0694a9d3b05347a40e02d4ac03878fd06e8ff79b508490663a9b66ba35678602d6e331670cab81ee388fcd7bf9fa20125f420892adf06bd372cdd9205e77dedb0e8410ccde0d3af5ba143fbbb98d94c79dded49bdf8c8473728b3638b73959be87cc3bffb5c312290303a90d29ea36ec736b7be56b499c4474e78a5a0650db5552fcaf8eb4e0a26aa0037c3eaa8918baf200f678c066f73de0dffce146f2ee22fddb989004e5d200528cf556f6a16fe8ad98a979ced4c49b69692a447a05557b51ff151b40357368a10798a0571e6aa4c792c6d2543aba697583919fba643da2e5d76a4080532d7d7c49fa5cb23723fc4ba070bd32aaa240b6c5d3f584ec452355c1d803a553a8b56c18157aa4869487840e086901194bcdc4ded2aee82914aad3b33da57cc4fc8e5cd08cc8fc5b255a917fd985e543638d437b366a0b446a7f374125cbbf43cae7805329ed851dd1e73e4fd38c05e24c562237cdefd5da36562f8fd9a7deb0c1d2434623d4971a0f143a5d170685f98a84f201543056c37cd35978aea05ca1a0e40e118b88520e54a032f35a8f25f99ccd6bb18355e2479e95d9f83c5897f903d4a4c813ac95969efcc1cff9898b7d703870d8c57d881840b74100f2bef6b0e77437b5baf920046967d2cf02b13af1babba722727e1210cb593877400996cb454dd1eb1dbff0f5bdaddbf54fecc7ab98ec29260b86b188127cce3f9731234496199b752b3e241684757f4f1b6bfcff417c717991f8776760fff2ace5828e44bf6b7f6a376f6b2ff20b14f27aeabbc71b4c6a766613e3b9da26f12700236f8a6143b051a8243b7bb9037d71a86bfe2b4a7eea91c3e1d731248ff749449ffb243af4cc64be74dbaf0bbe8d5985d980af3d128b6e27954550ab7268203dab744f10608f01e8e57693070611f542140386c38c62c7d362206f718d0a28c17fb4d744d092c4cf41e54ce3083df0a135b47daec2ebacee8d6c010da258c6a7855c48bd74de900d408f970f640808eb35f5bc8d2b54b06cd80cf8628565710a2862d685b64b3dbbe4bb440c62833f671b36de9472606166e3f0ba5d305b7b473d62367f401b28b7327d678c1297048cd73c46c570f9b465eb0bfd4cf87ffdecf6ea7b0ac885c8d4160e9f5b5ef57ba7036272f6318d2b0ddf105ccde2a28fb553fed5129ffd0cf4064caec14f63c30f61304283d4b35162c7bc87cc66681bc47c13d4c23b3f810b11c3fc1272ee7373192be3080f83c14a329c4a8ff9009043317c0643e266c2998be6bb25fc4e97aad92bc7d617d8bec6f8091098b3aa34d914f7d51e998b6064a10767c36ccb0fc40b11689020383838cb744303fe34269ed5f0c535c0629b40814b05285f748f95a283bce21e0dbcae382ff78cfaaea1ac7538a4b60fadd88747f3e6118739a30d5de29ffea07f301c8a769a8e166f73275c1ff4d6039169ccf1bace919a68dbb56e8863fa72e1cc277e95f657a41e3f588c553bd8ffb2d31317609bb344bf6d2f50e09f9c281402087d7ae939af04433d42c3d3671dc5a9a4793eacb62cd5c41c49233c89fd018ec8bf024b2924342b2384a664b21fb1691afff8787daf8db4ae997dc639fd00e894acb45bf48be7298b9ff79c10af02248bf1d84bbcc5f13cf9585f200bcfd5f8e18f89cd22656295648485b01247d6426a61dd4139640faec76cc2fe10d2a1d4e8a5fa3a93061555597fcb58f2d8723657826117255a5e063eff9100f07b9c68ba18addfc46d8bb5b53dfd5e31da484a0907e4ff8217b253af837d4efe892c5ec1fb70117d33a2d2c4288e4fcd60fa6890ddf5187466bad3c80656466a35d43aa5b4ae202d04e92b5e4a600192c95c1259bc48bc8e4d9cee9e28ce8650b6bb52fe2e34d8899de3aa67dd66732dc3ecf38f81898f61566cde35899348f0bdb1777d3bb2f3d259181e5b93a07c4d10920e06d0c449057b5eafeaa496e74b680e656256f0bef508f0cc6693cc362f260201fccff95f35c3c4efcfcda78176829706a9c8343f5f3721c227faa5899c96eb59ffba6d0613817c33df60cb84192915a58fa8f3ce0d82e1ae5acfd8bb4d89beb947b4557504f3b6dcb231271c1999b3c1618bd2c0e73bb55e34c0c0f6574124b069a35df385641080f5c7aac05c2a7f2e3ecb0104218177e2245841924d5c66f08cb6926d9ad07cebdc1942e29728c2098f24f876a462117b2bf35505d4d364812c84a98d9452bcbc289dbb9f82ca8d03e075391d94a863bd1f4004cf1bc840be2dc85a1d741cefdb5418b310609d39076bf29144ff1a9269ea8cad4899f8bb5e05c24a67f03dc535eaed99d94349865f3e1e484dc67a03bc02d2e698244b6078156c5a9e84ad61896fd5d4029a0537fce368e2a010b9181473b3d91618f9ef79461b988e4a9c6e272add1d9404520a4476c367439f419070c1018c72b3ff3a3c3fd409a20c5047922b0294e768499eb0aec5d303eb5512b207d34d6ff4e5873d436d739e46b776ccac41b352d7d7abb75f121b9cf5fb863b6c360969dfaa5e43dae9622dd15a03cdf2aa98f64aff65f47de7bdc8552ab73af9185af87e822a0d41d70aa633f426262a8fca2b9e219a0ee0726c558bd4ad90312efd275b73464331040dda68949f5d1f4e4ee7c230c97f615e40747a3e46357a953a74d037b672eea9493ed808cdf565cd2f2bdcad34e1d5f97934d12560eda6c92459ccb22bc64842cf60a522811af038fb101f83b676210ae918ddb7153031065d8eeb0925ee95182599e390819f021fa8ff3259510ac3059279aa5ed5bb530cd4b4f894a4ab8d3e46779bcd3367705334e208496ba80b5e16bd56089f65905ae2e729baeb346e6c26a9af4914f40b351c88723f1938f7c69f98804309d43196b4a8456690e26ac6610c3311063a47fcc1e4dd90d0d4f66c151edf4b9d08f22bdb474701d03636bae6271f162ba20265f2ef053105c1b9f119a233b68ce5b3c7294ad0ef575633292615073626597118b57bdbfc59cbcafb2b1dc797307e3c198d4097900227a7ab131695a7f7b0e1f9888c3ad019c92f9da1e9de05b6e5d133af1ee21361a1450e051c613374b32ec26c28921fde1adb2662677aaea7283b185305daa99e835c1b88db8a018b55823e3bde793bcb629841f2e0b6543a92aafc94307cc83adde6b49a32a3b80653d5bf1b1abe81c7c147afc41b8b20464e47b96cc0fd9992fe3067c9b05efdbf7941fa53e5cf356859d2b310f9827fcfd8d5ed9d840358b5ad74d959e2ea86e9c0f44499bc2c936a80d1000acdb6acca7d6e536d326eb29994bfb7d185c04d98d146b59beb241155673e8fc8531cd7170ecb1688fe02ae2021caf408131c946d8a148069e3b02fbb9f1ab59c333031a7088f46c022ec15c6b2a3bc5314953449c38e8dc5648ad2ba09b0a1e792c651429c210f41fefe41e2832992bacae21acf6300fed581f22550cf273025e360907b54a2f3f6bbee216007fd14bc3f107027bb873c850fe9334f3afe978a3deee079c746d60aee4ba179cde456f095d79a9d800c99e164b45be936032e2c8d7924464ba5c0f3424cab4defba1cae3512b7d50aebbd23651f23a8732a3e3236a9e2f83b2b3f47248f039c341375076b89e8a72331a1b859fd702bdec10ab027c01ccbb76fbfe16428c0347b1fa777a45827974ae22cecbdb68ef4f4ada3d5ea24e5cbed4d4bf84bb662da4c0f8b0586d78ad53979ae5099a5ecd2c938a5857c26568b4513652bc6bf34edfab06f81ad272e33789d4bee8c2d3184f2c62941466998961d28dc4068c9a47d7d528e061045e33730724bd80d8d41376e7f23b52bf462ff9a3be87568f883feb2dc42d0a5cedc80672bf4b3985bd34225c4bd6bae4f5d1031797c1da4d035593ede33eca8cd4e9f65d25fd0eb66940c41d01dc6dfd1b8e38c96298aed75fa27ecd0f5f8b3d1f450c6d6a664e1d76fe5c22266af22edc8b61d33c6e168aca8f07a8dfc4cc9e182de69bc6b5c2e28e6238af6c183a33ffc72b5574dc9847939c08c4e2bafd1c2613f4c1f7f06cc36f74e4f3403ffffbed6458666d7ec489ca3fee677b8e93225852483a692edd01a48800809b32dc4623b139649aa746ce63e242bedfb234fb47b4feb718dd1441e6b4d32b6d1b4ebcd92171c821c6c72354f796728f832103fdc8dde2e2a3ebc3c04a96c222eae7969c966163eb7a06238f1ddb7f930d60c6b077132e89ef225e94153c4e20f49c8edc191fa04d03c3035ed5ca84a66399c6afbc580d2782645774312c1736d6c5d39fbd0c63a378f989dfec0bdc56fc7adb4e5a64324504d27a00ece53601b6a8653cb9506016dc34b6e8808ceefc639beb8d8739445daf45929fa09eded8eb383aa6d6b396a76741f26d43e0a24603a5b7da5ca1bd7c2c6ed5dcb880b95eb1d53c3b59ed3c2ff2edad76832bdc51a1905cbcca46863244b8e3a376529374afd60621665b1db7f5a349602244082af0fd12f769e7a4df159b5f0f27c504938b36dbcb7aba4f30453171c5201ecc5c1c65662911522d7f0d3f037a5b31ea6f82a03c8fa2a8bf438ed4e5d6fe7917c21282a7a0c368c9e157523500d8187cb54305602158051cf99c3fc5fcaf8d1e3d82ece09bd694d2431c78cec266fe231caddb17c72c26520b652af231bb20d3da74c7f73bc87482e59cba6c0d5ac44767f962b8e0f86a7ab08da4217adb180b2526bf3f71cdfec86f5dd54e2ce32ff3c4e05a3b2c59070e1cb3b5054ff9f666c0341cb411fe317db3c1f53e8365fd1c2a9dcc95d43030e3e9b0235c920cb485179489ccd97b3d833e739780bd8e5a4359601d0d6e9ddc86191352ddbce45733ea069941514354467ca1321100b0adf28e809c1de309766a16d95233c2d2371765bc122afb2e95c22f827c6dc3f13ce4253ae9863a3710122abcda25d7c7cfd563dbaed865a686975ce7d7d2fb2436865fea1cbd8a90e003ab6614995081c6774e36c385b72b1b2a426a3408ffacb10800245d39c1e09a98ff8b0bf094d9a33e5188ea318797594dcc14c3f12ed6fa8f08842fa2e245888f1553f9f9e89d57ee9b71948e1ad527fa3c97e0052d737bb63c08ceb782cadc942d6fd0285f161c12dc5bdf70ae7a949418c9c0c92153243454ef48d4db8e31a1c660abd73c419bd3fd3de41acf128cdd40396f9dab553538f0010116c8deda4dcb860d2bab8e98938749709095a485ea3a5db26068e36e1536800cf2757347c0f4ddbb56e6579ee3c3aee400bc1e8413c6ad6ec53297eeff066ccc4a42b2af7549c492bd85f5e5858e0e196e8b19f2baceefdf6014ee7b1beab3075cd1a08421f1128ba8848d0d668d4d593f889b969e75d438444322992315cfcc3fe4952c4442feb8adb65ee7572d67d738767feb8d2d57983ddb97d51c7dc9b749c1d7dd8a1e163b5e37bfa8b938ae6b2d13bd8d8d13f83a4578566110b1c1bdcbf247272cb16a05230b56d11798741b4138e8d2d34be8c79a01a421431700850c5a8e825228894c39d6449f3eaad87004d38a36dd3982c8dbca50daffc96d38dc57fa40dc174d1f88e2d6128dba8621bc18951e943be0923f89dfc850bd0555c8b864e8fed1074cc0d082329154682809448bdde7aa58125fa2485f5bc345473bfbc9ce8f8d693a29ea7847066c7d20b0651afb3bb8db857aa234b5f128248e97e8cb7c443f61ed29e431f6aa71beb198b12f765764a22806b8e18790529942929371c7a8a320306cb36d9718ecb17920ffb533e8bb16d74a5f4079b0b9c5fc7ec0a0a644f411a1bbe7a29bf6a0d555496a33c305201344e1d23830953bc2a578446498092ba4bdd65787549b4a500789513eb8cdf5ff552f1bf79b74dac90d4fb0075c0e1081473e40e380fa2c223739562f176bd635069bd5a4bb8f273af6fda60bfacb30431deb4f5fad0625b70590921deaadd1f2d8882747f82ecdd7117511ad26c4475b45c13f9447860436ed710d659d567aac6d2ad966f8eb9a467b9ca9c34b975b60f124511b538b6942501d60167cb9693295b4c613761e667ab942cbd8d67143b6797175656210f51614b40290b115bb2b03fc0f90a6b102dcc9463c4ba17be7d1f59cbab86a58e49f035c2251656430e3f56e17943b42da7458306ccc7ff56d807b5f24d06e2c8c155c48a96e2794809d161ce2143ec58a43dcd430f9787239147bf5aabe4ddec14cf0405e5c719f8b4ca586209ef916468a9d82d726e13d137816d538122f9969216dc66e3ac2cd410fce87598d0f5262616f1cfb84e9985f1283b6e17623261e58e0fe7185db58f20c3c5d84e35228d6bf98409825152c7a06b1dbc0117fcce8ad945a32db5d46cb0af034a7cf1e872fc5193372db597655cdf2a7d41197ff3144eb2eca1ae965b3393bacc958d7238755a7c24f0ba6fc541ad95161359bb39a4ecc6244d5236f012897e19aa3c3bc737e6666b079bfe5003f52606a2593aa7cd72fd70a392c494e7869cc2ca32fbc2df1befc24da7f05bed599d81c538c542545787b645b5883fa10f949a5164b4701dc067cec96b034ff54ec93fd6d3975edb5ab194462dec37a19bf0effd2cefd32bffd585b2893885c0073dafdefe16e7b7b546443c2182e505cdb94ffe7fdfcc253750c09af6a45f05750fa30df5475e669427d64736159e55f3b862ff04fba2839d02a2d7459404e8a1febe9ad32e8e1ccca56d6181ba9bfa2d66674e5261a6f364cb073a0aeea156ac8d3335e45709d82f71141ca9ab5599a8544a967fe71c715cd221fb33c8739da270ea2c7b68475ffd9eb9351ab7503c2d86df597e8a322bc4e1b038e4ec23d535f25b62200b40fa574f70dbc825cb27a5e10856665d4d599b70c59ebfcaa0247709ab2e300a7f097889c6dd6cf8b975c62d451ae19ea2a869de77393530702df6ae11c4638506a970cb73013c7f50d61f3aa229251df80f788ba4689213e7d48ac4f95feaa21aa6e225f5447d93e0ac830c4e32821bec8118c32e7639b7e5b5b7deb9d7ae7a8a602ddafaabcd2140e9886d3c3f0b0383a8b0980d07b201d54055b76a4df3564af71a2808858ce6617e416a71c26d4322f2fc623bea9437c96f4600f618decb96b8324c307d441f19e998a04f0e23a3aab6f834a501b295e5d653fd9c2f7e4344dd0bc112fca439605c8900024c3c5ded4d7b0af77e3673d36b3e73eed2aa4103091ef661056664c9ad7f8f6104218d180331e9a9d3726f46f175ab5d5a2f7d9c48a3de47ba30a1611adc91f97eacd9eb516a9e0357cd29d45deb809bd46901f75d3413bf8b231d9e3aa149f331728508b22b5455c684888695766b229edfbfd96793e853a9d88d53e799043850955d2feac3611c49383f2a19cb15ab830a7e0fff10926f1e1f820c1eeccf3896afa4609915a54ff13071810c66647e135b0957f0eb296e135f3c50cfd323","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
