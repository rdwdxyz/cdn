<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"12e4a0430d53b0d00b4c26d1c0872b3cf44ec431aaf9bb7eb4b83d7c523de64b3e9de2782a52a869a02c0233d87b3af049b9b0fb65a2049993c8746066402acfd5038aa2f417593d2e0a2e1b6802822e8fbc5fba78f9907df23ddd4e287a28f8e40035586d9b0e10994177774140f8ad32ab2f1aec7a1076df90f0e5cfa6324ed7e2b96a0b1b46a31d689734c6576b178f32217a59301f3e5a794a3d02cef25ae5ab63fb0b20943de3f0627c4a578bd4135746058af1afb3e362b5de63b4909ef2741855c819a0cc5c88ec405e8d385a060cd7dda1e66b9a381cee136977cf788951ac2ab27c4f4c2fabb8f5e33969633f043b564f9bea1fef0d8bb04cbd1093b2601f804f43acdca57ae7f3028bcdc2c5b4f086502be1614ee4bb62c69b46005259ad53728236663e4c01dca35cd49269623047c28c259aba11b36883738a63271ad9d6fb56608e43cd41b2a9da7991767813320660b11f1ff6a77cfd2c52226c32a9d33a6f0952637a0ac3e25ef665a35b45fed5225155c7a4ed88214cb742cb09097898276c90a9b8f6f32bcc9722c7c57a2ad3a917179c169d9989506c46fff4654ef5d90779eafc063de4e8f7721f7422370a16b74b586cb2390e36e1c200e96c76531dfa810085848a1e7d30df3c21151b6acd0b99cc5d3248f94b6f7be42fc33d5a1d6dc1c672b91171d36f8214241cd2f0703c773fb56e13fea3b14e36f52364941d5588e58e0f4392b286d51bdb7ee502aa194768b5f92eb845cdc811e3dde5817568380eb69854cce866e3cb014a1b459afdd72ba1b01472f5508fbdf704331aa8f7090c352e18eeeeaa015b252e6b56f735f8d4c6ba713ecb2c9a07dda2efda007cb62d23702dddd1c68c322e68d41c1396a223d04d4c3f1e246098850122429707037aae9b48dc6596295e98b4e1d5a65ad7c2c04e90754e9cca11a6b857661c9b0700be5cb76a0773a3667ae8baaaa6ede2bde23b09ece8b5396b68f306900ce7a5bc9588f7d4d2e642050e90e4f14e1d44551615c2ec8a1a42ca4e9263fe11a99557da4f9e031d16d603a371e9e51b44e7e2da75b5ca378030beff0c1942781cd1af62b2acfe345fb04922546d4790a2b3c4fedc28c81971fa87a0f9c7d0df84c7734168e40ade899c6ccf3e68a92056b486bef0e3d7d2499a2ea816bd6382a10fee2f34a590227eb7268e94354423caff695daad47f172779abc37c0d16cab856bbee5eb3de18dc77730a28faa80d0da8e041689b744f5330bc6fa2d084119e967c0dba80d0ec545906f759794a5c4435a9c4fe1a2a9985d857831da93bd1b369b25b2685ec908b552c98440ca133797faa1e7d4d9bd60f9155392f3c6b3ef7c0ee0fd51ef1722467c8d561af19424cad4804a6581a429e9445ed2f5bf71e192c974fa0d67efba9dd0c122238046148c3885f3560c3e87115d223537f4a6ef622e36733b9b3ef8908e060ba6b51b8a79cf2c15b08d44c7f434e69f7da4247a3c56415ff8bebc27f0536e31117d6e1aa520ac420cde0e7f249bc049820e1242b4c560a522c18a0f6c89650bfd805d24e1acc364e74c71ae12963282fc0eee2dd710107d5200931791a83fd9f4b0c0336287348cdc1b68d22841b240cfd4e27e53129f27e5ec3cff3c9a6370b23e52b4d1249b95e84c00cc83a89403c0028c3b5b59c00f766672342368b0aae776a6b8ed58770cb9d23f12177b22fa273273cdb4d9a9b32d0ffac5686bff4e9f42ad2ab06422f74837f85ddafc81ddc6ec9cbc0ad76f6de6b84898b44ea1e226e44a596ad9b9055f29cff9cb1b78cd607e1898f07aa5e535eeb1f82fac948f8c634b5d5eecb380ccb509edc25252d4f316226ec79d9da2c61358f2a3d11b2d0bb935850e68299a2d3c7f658833a273c320e62796648900f14872b1ad4a44734eee1b4a6aabb3a9b6c3f0ae826d83db2e2e9bfb6f7f1414014ba9dd6ef44398878bcb22b59bcc2ce265e0a37fc505de5624bd0da37647b77f7e2321132ff060707267dbdc56060ba106c3b7e81eda65c4eac6991a4e49f30c634c00c7ad237faa19f776dae858dcd03e0fb7dd014e378df1bd8b6f3d53ce71595b0816302d488a1c8f7f9e45b35add0d20fc3b9b6ae456c2e664ec7ce2b1eac2e691c1b6a33a4a42aaa0d808e5c6353290cb6e2ba0e9f767a7e88a909ac9d8448e82415121c467158ee0e9adf7d5407f2a014d9aa471a5fb448adf2689d9f18d0ad388653eb66f5beb53a565335474b614d5db46d44f7ed275404f8ed91995aeaf21d611dc60ecab7992aa8d50d8e51a023cb06e226a71cd20aab89283f0ab53ac8fe1eecc8685131282843c0853e37aa6e6a08ee5dd86c29daf8d87bceee0d5f710bd7ed7a7a5e2d1675ca987cf71fb763d8969b67c689ba8b471de0fdc0fe217595cf84670833bfdbe2087977ff9a76a34db62f8c8c4b1bf2247c6d2a2bc92d9081724f75d3ba2e69432662271980786ec9ab92c8776bd5cdb0fa3b5ce9b523fc8893c86cd9ab404d57183b0cf23b64325aaa2ab6c0a4951df45dfb8a3c9a655811516a64c35873ce5fa4006434e34a580460715d45c2ff8ab1a086e79b6008ee4f56b34a06e2bd20b85cd3b49119af93da97be2dfd15dc1816a77dc13425bb3b092db8648e370219fdcb9b68f78f60cf5f059070b4da47dfbd425183379603ca023b7cf0dad11620d7e19b1ef4d0054212ffdd6965ab2607e6a01727642979f46cea47c0d89868dae85a00fb26f1c6c29369c92dceb6d50743dee7190a62bffe960cce063889c4c5c5d9499fc2755c48646832b608cd2ef2b366c1651a44f5b4bbb5bfb249f3aa95971baccf6ede552bdb6e1f4bd02e89de505f2c62dc7e012e931eacdaa84a1f33541723e8df945953a27546e71f95eb19ed31291b794e67f98bb740c0e6b8ac2b5d31537a20c7fdc417c6df4c657dcb82219281e6681cc730a57bda4e10c07019974ba75cea5240c84e3cde97fa1832f02f8e50c9273b00cd50fa8709cb5f1781f4240ad8fc142236ec290c8f9fcfa6405b0304524bf2267045ac6e21aee1c920688095a295fd953265643b0fde6e994ea2c91b1f7052c8dd4bcb44e530c2c88355f679638861ae59f1c9321c030e6ef38ace478a1dcb94bd16ca7373099873f73ea0b4f1e764c2d3c002d50d2ef81fa0d2f8bcb345c6e446da0ce971ff09bb7c9e0a4d295bcc69c42b86bad47285cca4f955104bd2933ea4bdc966899cbe8cbc7bc781ca943572125fc429981a5798475df931aa1dbcc87ff5bd28021766959fa879034e6bd678b83217d40abcfa7cab31e148f355afe8e353791c2a94ff00a1ad6f731d7974b430960d5ed90fc01f178d6a780892b8a10f3402d9867aa667c23ac2cda1b1bfca98ec525f93dde50d194f37d53758a88b72f5edae3718914577ee27bac63eb8e9fac25d24835b715583e5bfe05fea3a27a3302ef25b5a8dbd02186d6ac810c3dcdd67a7e3abb00e4bf765980dde1d64812e657178b815cc3044dabd2b2312bf2cb10cb0d5fbf0be7e1e44cc4a83ad81974be31d257b80e7a6ebc73f99ab1f139b249b34bf3e1ab64c003e948263aedfbcc1f34244834254c8ef5e0a0ec08779116cd6ad26dd7793af274bf454ab1e2f2c8b16d214e657e4e1a4014979b1b285b32a3b364583e5bc6178ae3c73fdcdfe27119a6e704408d72123463dd34c735894fdc98804492eb2452ddf677d383533618ce6ebaa03b85418b036a24686b207c2de40629b3e341c45390ee52802d86a77cc07d0ccb9e99894a1e1805b2f1186d3ca85d1e44a911bfff03ddfaff4857edfd3d8f3c268f7f137ed7ade2b0c5d820dc814893160e8870533fcc5849bb1c176b882a00a040f69b1564de227b3f78611cc669ea36af0e404c3cebe5be69e7109aad7e2b5f2827d8b5ee3e0d65be94831ef82dceeb4be0f3b6ed2c9823139e6179c6a3c01d2f1829ff87d7aa815060b3f4012d30841d892be103ba30e206139f3a35fbf35bcddeddf566c7621c91c66eee1560b6b9d4b4457d3981917040c8d65491163a880c6903529dd2b39bbba1331cc60fa9f5537b633e59f731f75cad65634b3ee9e47cda922882a53d1c0954b0d287399c30361368550cce7f2fc3e78b1fe250cdcca74f99cecfb718fe433affc53e5e395f149dcf72b3d929bdd6e909e115fd93ab7e4f9e4dc5d1445761e8a930795c2918c9f79a15de864d86f96b454efd5f4e533b946751ed19947c3ec4809a3af3647dbb0a96ebf88bc6749540d5a150f5155fc973454ceb46417b8f680aeec6cae8081bc4ce92331cabdebb470278140d55cd96cc1fe508793262a7ad2b5ab1662e91c0a55f1ccda5b54c8972c627dc8099a16f6ea6d418074d4400e60e2a634c47e7b2537c8e5ca80dadcf1adad96d60a2e7e9134f010b63c91d91f0f0f90ec4e6766f86ba6441290324517e852e3d2ffa87c55e2e643034efe1cbf7fb7209656b66761e16aa91ea01df34df1936b53086822ed0e47c0d2e350ecd4b4a77ef0b10dace448e9d1b1e94e029a01255990fe12c66f12ca01662a74935f93bcd2db9dda0449a777ee870e230e4439e957381d01d6b59e75ca4eb6060179efcee0b200e0ae1c33dea6a04f913b1cbc399fda4a6376669e808815dbbf9d3e68ea3113a8137155b52affbd5d363883fc0fdd0471f84e711220f5d736b245c3da805bb2b2afa6113657958f790b8f74b4edf7c937516ad73896d0bed25bad06536085b82c264bed98e15e240904afd738b4ff2614eef337d785255d9b06f2bfca27ec3f0c0caf242568af9dca769b7879ed7f7bdf229f8dc16be22b457c8a3f51ef719b7a18a48ffcb0fe10b9dbf19cb3b0f91e7994f556edb838544cb4599102692a6eee54203e384a5db3604a81d3ec884f932b742b041957e54717abaae837b5fe8e2aa7e78cd89a6247ced59c14c48e1c1730432f9c16f87d50995c438258ee137d92a2f5327d5290e118996bc5dd63b06400ea6f14c5a17f673a797096cfda243cb3c4b37d2b5d02f847cac8e2f02e679202fb27eff61b225ffed99f361e0789ef559aaa5338eb78a4a75f680c10ef092339e8504ca0db9a1389a414753d411f4c407bb966ab83f52912657cbb24c3206e14638dbe073d9ed31db5ab8640d23b92876fac3b4abd944a0c8be5177244beb8feabb678ad69ccaae57bcf9ac5337b38895254c37edb8987551f360023d32794932e4fa32cfa0bd5006137aa6992e19a6ab623696d249765125171eda83fff4c8f1e6970e785e14833d7959651b040f486c69c5ef6d6469bafa6ddf489f018dab1ad4215b7717959051da783d2f6ebdd88c79f9f332f26e7d1a44e2bd5854e8e8446926e8970178d4e92d033261214adaf10089b0c7ff2a5c5f5cbb9421de76b2a08f4d49d217bfec2fa951e9d9cf81314a4278da8b0824269129251f4111772147eb3091bfa7dd8f738373ce70cdee770b4bf1a5c80107e56e4a92d0c1018cc6815ba582ee54fad7da1191eb71edd6d12063e0736f85e64ae7d89689f91ef8b652271bc9b3312151703e114a33269bf822e713b25b734e3fcadee2e444deec3e3f1f76eac627843c93932fac09fb81ca556e9e11cd31a44a1022d4076144ba2fb5d0be83407d592407924364d3428bdeb600df14c866619ea561cd1ba93f4519672421fe3af50543816586047e6483091c93de9a84ef94a74e03bf4d60b1cb42fbb4a49b3c654eb22f898c623ac6a4e0f307f0790ec227a906c910af767576754894a30023fadcae7fcfcd0f6b82f9d9037e54a2dd529fbb15b268723bbf189c8b3ebbcce1eb4385ee091ffa9831b8786347a2791b063a86ccd29a56e5d391c08bad2481a1db231e70206ed59baa03ccd2891423f45a72ca32d0c9fb786da9e88daf6f0939c2a5296eb65b2f79ac656ba0e155d70a06c79f80617a5570759acc94ac576c3645aefffe42278dcaf121deda7ff4f13b211aa3ba499e2d9efafa7a20cdad7c0fb94a14a250e8c0127cc623f76b97233b0f2c5fa03e04f0e1fbddf740e3d3245204edfd23a0657307aa0d348d5d79334ed2a268d76776bd002a0a8d9566a8a0f381e774dc6d1a6bdaa8c7e4b3b591163ec5ce3f4c26345ad59b248e1f9c145d1f1f443b06346959592be4907dd44a3629e2efb0a341a31e2e65d6adae40453876b31523c2b250a80955d861b4b0c36c6dfc87ea2c0c7e1044dda902b0b738cdef4629a6a3cd84703f30af5d3a5caa27460a173778ae94085d86f5b62fb7ae6a327d4af10ea9e02c0a22829a931f89dc9d1a516e514c878e6648167667967db9f65b968388166fec286c8e621c6eac21e1330442364c935e45d6917d4dc6e9d2e7fb719c718fbcbe1697c79015aaa869d6db2b98b506dcc63b85b4dacb066c957c2a77e1b64119103964607900c1a10ef87be54bc35882c6d2ab359725fee762a5ff49714ebc30f91e378fc8978bf4370e832a11b038703af0524e8085b90f9b7fac48b80be14079b651eb20412c844654d9f713ba3561eb8053df69f9bab66aa8a1da062e3bb3493a7711e3e7e40cca6bd8bdc59a09aac9a0edf949c92bbcfcc239d71e9d8d6b811aaaf2c85a1e28f5add6f19b65c616310f793884fa3dda0753bc56c055a7dcbb956a486787a83da9fa05ee7496b174e5d7aed8092c64287810545c722fadeb472f20dc44f842b6e119a858f703e667847ac574fdbb41a960dce8e2515d44543e4b48fb6928bd21d4136b9c04c7a46a6428a8f3ac66782fd876c096e4dfe25cf6d54c7d261d40e4771c3ef21c718637bc0e1d2cef44b29a1b57ee8d5a3cfa4d44e1f3239a029225ef693f2f78a71cf49ee894ef75132cc54e25c8de6978ea317d6b54bdb3b29e9da823639514ea0396d76d0beb43a5b9a9376212c877878b7db885717e0ed335d4f29aae1fbdd53d5f26185084fcde86bc8c780d3aa0595ebd50efeeb093fa007b7f5cb677a870c0124d10b89cc92ee56ac3d91d437c30a6e3dcc284480526d3839f56f1536d2947279e50400de304f181e4fc865056c955200f65aeb89d225a9f1cc7e0e7203b58bb16e985447361bc217a001de3dd2729b373f01951007877ba31ec1cfa26cccff29bc6850e4712533ad1ff4b6c2925266befebf7d24af7f500908d4cfb78959c19b73b62b84a93be433708001154d8d56432b9f7dbe22f40add4cd28a2b0a5783dce0a6d02f4133ed79ff39b7bfa601fcc99b7daa8ce610301d3b3f3877d5978299e0bc2472d37f43ec92902e4d1e74ce13618dc257e8db35ddb51f43a24fd40c53918bb862e459044c877919609ea33363c962205cf6071f76a3a699ce43e27c1e352fa41f731410fe560e5d372936bf4890a9752a8eb6bceaded282fc9c5cbae3b6c8fa64f85843ebdc17078d9708da5a364f879e46fda7e839d7c9446bb6a4e6fe5ec5ac9d6ceaaf72cefad3af36737c9d39efdd8fb3eb8e48b905654a8e38d6f9aca25db21c07ab016ea59e34d6b2e97348645a45fe34aa74ca4fccec375d5127e542df34c377e5eb432f0e8bb403d1d3f550007aee9c84a46108360fd70388f1ae294b73772c0896b781664c8a63a0ce4b322ecd5cb8dbe2839d0e0ad46ee00ca49b1a4a2b9eba0ecaba8858b8c04d27494a711542117023a69a6c84280bec3af17367c74680a8725b21197bcd7ed899a31a6c2c5585573fd20457ee98bff1d8c2424697f3d4ca67058b991ac41bf86fca4c152ddfc4fcc42fec65db4e8bc66558a31e8d9e65536b7d33b263c9519f84376ce56ddfc4f3d99fea6f12dde32277000d0a89bc5c6f5cc4ffb092530be144d141791a76db47c98b4e33ef551223bbd62a4b6ec53920f4bc2984eea2e22ec743a44b790d0e46d0e76615b30ecf4dee95deb5b2061dc75e488007d666cdaf86f4ee15a838d9b4015f2880482f0ca7995d7ae7ef903ac4f037eaac5de80b87f95db65b046b43850c04d5815861b3509f4ab79bff3ddee8b8add64bb7eaf802c7a67b9beecb81296a4e462246ff1daf5af26db7148bd6534b5425eecccd0f1d70a28c423979ea1cb4c3fe02bc2ca36c7e2f8e82f6d9cfac21e05a4be22cdee966244d9d8b2ddc93b1685bc9953c7aab49482e46c33c39328321f131fdd920955ef0384456145cf3fabb3393e6be2071aa080bb8cf10ab6f351186b1e92b1de2853f6fec48d51f6bc2cb3f1e5a22c23138c5e102d2a41df06f764fab495754a4cf60f20f85035dab53807f3a146e5511d4e1e9df0ac5dd3c8cdb5bd5e53d0aff50100c3b27fcc95f6617666d6b56599def4d353baaf101a7bbce9203bd3ad56e608ef80a483a2ca4bbdc67032da3f3d0afb73627724c1d1b41d50f70d30cdec731aa2ff30298494593203684f1f2b484d71287cc75bde04beba0d3c14002382ce4ca5707fc4f1ab3fb3964d410d46dcadca40418c15f0fbb4ff31feb69ef07178b581501041eb6a953363b28da3d25ae1cb2b3c3a6bd7b7c64dc0885d40f79c69a657eb0ea6537667c973c62641c1611653410ec58ecca0b88ab1110f856cfab694347343b7c33179a2d4d48945378ccd81b39ccb7c6731ba87506c56067cb924d216d15f62094b741bf506a8a8ef807044c6e0560ae08a61a207b4e53c218277e5212ee2b80444435850d2e4ddabf514c6060d6014b6429a6840d713f9a1a955d923d06ae50d31b75bcb0dce3353c521a22334a04ca04a7f61e6ac8ab34fa56c4805654c6054cf648be8e9f2162aba85dd593786389a22c59c2a24dc7af71c79a28d30357c679c98a7376509ec600374de5802b82e0a485c68ac12aeb22036b8bdda75288b4c2c1bfb169947e7593396fac074a5e30c485d9e7622352aabe65f270d2fd8169f4bc602845287a937135ffba1cc212385e1894607bd8f6f5b916dc4e6fc5a0c8395654d13304f1d86755169176909c7df17696301919297cb9a9a269f6202a686d875220fbb08c9d77a7a0958f4490b171bf7708e5efb481dec8c65de0dd408b3ed974446acc15d47784d466956eebb2561b99fd5f0c1c4d628233630324e0e0b242681aad1ce701b15abbd7c999d2c536f35a2bf37ca5f68dd77e0c4873911b4a5709824e82cc891a3e106ee924064aed78ecc348178a988dcae1742f6ceaf4e82f2a292f0f70c5561f831a8b2dc095d7747b4bfd0c6d84f24a6ed41a5510b079f1361980a19cd30204e79aa481a96bfc860655e3ccaf77e562476607da242794c31ca8d91974f9254250a36e9f6a84ef048521318ca67c1f709ac5f0aa0984a457d2a396a9d244f8611b1a9863f7a33be4d86d280e417c3cc1186e31d53674f827575bd1508f92ca171eb9179543336c07a30b04372cd6ff3d232bc3ac4a1f941fe911dbe20a99f5f4036ebe19771b40836468aecebe500782cfc4cd1d627b4a52a49714482b140ade13e004346f6f44b741a7fd89432f970c1f8a6616b38c82e948e555c48cab2c98c2579028e28c4d218dee260d7fd9be60b46be974289504436b55fd9332150dda60acb9d7060133f551753e4121cd09607b56c9e7c634a7884e9413168b8832f5c186d7a2633455efeae8739a1fa282ceac3e31424214c9937064bbdf9e4d58e6f9bb2ed8486f4d7f9364c092d7b8dc6779894da52721da9761c3f3056c1c4ab075227bbaa22993eb6eedae4bc1a946331803abd351f96663fc324d47fe9ab57ad8238a9798957ae81915758b282064e41726a2e254dbcd11c4bf9fa5bd73b48ce9058022412581c3047cdc58f4eadd930deea716a724f9d1705ba66938c8307c890996ec25c0262a977f57fd7fb8b10ee293a9f02143bc3d42b33e7b74970817d907ab2f618dd6eb9f1aa81527b069fcf7ca2293cc0ec974b2b58afccb41ab85cd36c2e2782a6c7f6d529182d2308828b1f8b82b88e451931ae4af32ee4c077ee78c020f13d64131a4b5c540c109f09a1b0f4fb8b76e1de274945a0e74050ce723e6a619e2e0ed8029df622eb7683188ba1336be4eed8e48131cf6c64f4b6af84c3519711c96b4b057d7cbe6f14f32f1451928a4f68b51e155a8ea036105d7f4342272c0ffa7d7b2d050b470b7bf5e5efbdefe8fac0ac70e1ef157b636b8550f5bc74286b724618616b2d1ed90dae4344cc1557ee13e11f37a80b4fcb2ee6b9a9c4e616b0769712fc66d52c8adfaf11888b56ff1a6c3630b4acbffbe4895c7d1aeb53e7c8d772fcde7715d9d272480d9b64e5d63c3aaff8e8ef1956e00c9c010a08bf9e69a39de47710f994b2255e6b4228a1db41924322e95b53aea214cfa507e11808a45d7ffdb7dfc17e13c85fded587780ce32d28c5f46cc0d8e99154dadd562088cf1ba8e6deeebba1d1e3fc9dced641fcb4687366aa648819d2ef015fcef5dfda69fb08368e294f20983e0dbfe36e05797eff7332dfa4ef18afe7d823343ca8499d8f71cae23a80a8e3138d08800c92b85671fd2ac309c6063d6530758353d6c00556fb0a76660312c7a8cf49cd924cd7e7ba0b91c0126d99da09dbd1425465cc34052f1237cefbfe5b74d642ca84673c58d29a21e9f4f072c44dbe959cb8559b276e99706b97a563eebea9d5d8a7438efa7040e746243cbff5b747bea37a1bbb5b7a0a32f1a8faf5d929de2666addce8c1649f8d56c2ccf0a71f5ca0690ae9d23af488ee455d8f5f6e66ea287153571cba1600dc32f0226cfbc01a0e90ae364fe74f863ec94e128a4aa053b6118bd0c88593dfb2a4493ff14e093e540a6face98107ac9df192c07a7d471ac03291e0481f0c92e8d2fc359be70a598575670f66e178147366843465bae55b815895d6c30ff47cac5352241595ae35fde19ef97a45ab087819b9c81bac033a21df80df0cdfd27ccb75e29a2e3882b1dabe96a500cc2f932a55746b0af3d6acc7699695bf43c6ef531a6e87342f7a82623ff3443029f64f5ad90b9fbb6741b71dfdbcf92292dc6ec4b28a463fa940bc96b1fe11b2f17bce3ebb83d1d90f9c499368d9658c5678c10559de0efb5ebda6c5e9a901e73d2fc192754e8d6a992c5b18750a1c0e8c870fe8f8755efd083160a14efaffb2a35f8d4a1f89e9ab51bec208fa0bfe138ed3739868785181d2a123d627b826b461b1952afde1df09c5af9c238c38f5ac9711efec0d1ae5aeb9cf09a59cd845d19d835fc7b78638d35934d713c0ed3123cfc1ba32a65675ae7f97c75cd2c2ccdf81e6de3958152d34689dec440c05c74491dde414d5f260cb2e3bed5a003ac8a69e3449ac820cbc22e2c044e90f9c42cd24c296f6852f357f4869740e8ecee26f8a8a6b5ecd665b6713e5db47048b9b5136e3ec43571e60a8e18b70880a6f37cfbba51cb8154a1bafb96a00952715af6f177903a009ac3c40952e265137dfd15a1a422a857e40f87b98f3c066183a368a404c26cd9f8ed114414615c422c63e23eaad60c87f3fbdd7eb14e8cec3118f8c62cd98649bb410983c4558bbdc39f5b8e5166a9f93565a8919d9b417277b04c39fafb60b0fa655c9f70aad92d1eaf7eedd1c24a37b4c87f5c85098e102f2a04ce87bc17af5553e35c59662ac0223814997fa8670e23959abe01442749bf94897092bf94969edc6e9743c69c5a0d68be8eda2292db210004d5146de54ff2f517e4fdd3ef2ec4ce11be76ba0625f441aa08c4bb29e82c801fa4b8b39a4a6717b89c15a19cda3bc3a066a69f32ceecb9452c71fd39c53afa86230f8f213cb1b5f59740cc5e9e98275c49fe1c348f4d9d49f6392b4be4c5dd0b2d93b7c6acb686587d7e003ebec9d9c6480862b345be19b05d95452dda8580963e760d93bd142b71edcebd29c10cfbd77e638cae6829120d06e5f4910edc0f892f657c24ca92dd52abe33efaec5fa979a66758414449fc2110c78330d4bdc90acaec77fdc5d4913674d97438b6e3abe3d7c99e41c8608febd57202f56070a4819e6fadf7e6962b773fb5350b7aff29a11bd9f3737fab3ca3fbd968195d091724b333ae0498087f4a8857ff61344f8e6b6d95ba205fd1a44fb04a561b393c6b7605bbed8dfff1aaeab5f76a0444a943d04d4d2780f1a5f82d049d3f7f6835b2a2e6563bdd33e23b80b67f21b8208d8abce6ffc41f8e10975c34bcff869da50819aaf6551becd97f88b33227e190d477fcf7d4582d370cb5a8b8908e2895dc96194c47a7e1f51c5d908ea2fee3bd884273f8d1867004e1b40409cd878372d4e675bbb55a79bf69cedab5fa8a6adad831ab9e26a931982ff609e6724d7b82423aa086f7e0930cb4fe7c47f193b395a3435cf19732f05acad7e3bd4f234e982a95b0390343b024d5a8fbe1196e3daa372488ceb38732553c5d0c7a18b27a3ab9426772fceb8447b2c6e9baa730909a94a53e6178066b6c5857329a38a1ac6ac4d2e6a779e56cc4b3e28ea0a92322ceacf78fac2ca5d4e5988dce9f387ee9f9be6e14bf246ce11936984da1bff5387ed03c4570f8a173b6c22312f3551ec893eda6df372a1c313eaeb13063bd5242870ca7ec0dfc908328f8aab049b10a84c13ee72ed239ec2a00090898f74b9688c885a32bafe7ed309a5109e0cb6b924b5753090f97d29a0d77a97ce88f05729b08ead29123c5884ee06169bbfa62908a48dde2eb592f0df0311fa54fd3fbeecc183b50998c152b69fd285caf3341c6ddba72a2ff55c28fcbab1eccd18c1c28a16168ef12579372a6834bc8bc1e28119971de4081609e8307aa63f9166e7c2caa376d7ef5bb4e174e8b20b127ea8f3a5868a85cc79cfe2c043a3053477b26076c187e220d2b0afa994e79b0d59f613ae7c8dd8fa6be706b179ddb751f5241f1871b7fa5aa96bdca73e69729e746842f61f60c70634a6915be3e5147ff64ca4cb0b62e601ca2e2de20bf5e22d7a16f161d470b9d5e5900860819410f8c28bb8c09634a768903e1e9fb410fdf4e748ca3ed9fa957e689d8b644b357af6608987e03071e7fd121697db8a3641fb20a1715c984506ba8c058e34694f89820df475f10dfcd67c3e3f7156639c7fe169084e9f4d8e8d72c487e135129b114d59a7afa247e7306ffbc5a3672f757838fefb739ded7d7207a69ac8dd81ee4fc2868577d48fc14e29a884d4499cedde8f6445ef31c1230540d78fe3e90a9abafb7a93361528d95880642f7dd91ea599135a3741f8ffdbcb7797ab2399cffff3dffd3401e9478ad0bfe0c8d05a0b95ce7ed8450ce50a2ebf473962faac3922cefb66420feb1ecd7e6496f3120d345950d480dc38c2fc387deb4007f6f679e6eecc1c2d68bc9be7ef3751c5d6d69e4a0f390b5aa617afbfff13f1073b053b8bcff818a19589d0e4ca2a466f9f42bc46d40ac5b077967d46282955ad1b01dbacabadbeda8af007029ee2c37e3ef15c137f0587c1511043458f0f186013aae0ba3f82edf0d05961137f0cde2629dffb3b79cc2525613cffbe5b517eb1bc949d86f58fc93f2dff335514bbd8590dbd450a610d58ef8bd8933c3cc41353fb33f4c3864bc37466a85649dcc18e1d10006b9ceb12eee57fb0c7f7dd329adf8cc660432ab6b579ce3fe2bb4c7e3aabe7cc572f1f2796a89c98dce649ff30be7683e1d4afecc9f0cf79d56a402e1634d6200b4fd52e6e1a3fbec8097fb0f69d146274eeecb37ee3315fdde9dd2a4ce361977388f0c88033a8fdb9fcbfb8c80440e45e38c5b7003a502dfe34dc576919be2db2da1c83046f780c40eaeedb7dd7f5d26c9f0f0791c00253a6eb1eb077acbf6fc08ce0f37bfbe8917212da12a689355e333c9a96e303fe6788892e89e9ff3cf83d878faed5657b38b5074dde5c3a3e534203d5814bbd419e9e17aaa486359596c55d4946891f13418ca2b9f0d19eb3142bc41cfc58b79552d772ac937116f6f846ecc93744850773bb24c5370bc641883ddf0bf8bc0dee84159f0cec76d9e1944d707d2e7a794d4dd943c93a71bfc346c7ceb8d15eae151d3859084fd8ddfa7b06db1b94e01567fe6d34fc61dc506e7720636b24c4cab35522ca3010173195e515466f616741360e2d5569b4f061d17de283fcf16144b70ecb30a52b9ccee1ab5e7198d6db93c5679da01e37fda8d5dc802d034fb793afb773c6ff3c48a7e1ccb904c18dcacae944da7ca4dbe2dcf2cfc0779cd0e7d67b3d7462a38483fb270196270ad9bf500ff604f48c829c2950e0e4f08650628c2ad8df51f77778a3ba606f8c29cb99522f090dcc357670e21ed5eb6918c7be4455bbb3e30c0a2162f6ed6cdb76b0916421b468e38cf2e5a7c7424cb2b4133960c3837d62359a0f778d97b35251cbbec54ecd3122e72ec594dfce1f3d9e91faccb43ff6b8610081923269e0b6c20afd54f8e945a5ef9d03f7c8431d5f894a326507d3fddd83b5a79452d88d22bc7aeeca494637fc5b647683822f57827a5e87871174cb206c2c06cd5db0099187b4b2545a4e0b2e702737b2d20c0f9a2f9768242b6ddbeae689eb3b81ff79643c33b007c5dadd999e569239ce95d4d1519bd778c17ad3d5051b880aef98d9c5f0e4b8fe0791bcd20a88c76792e50265eb7be6ae2ce9d74a2a58ab787fb48b57ef1b282458f2c179f71bb3cda89ac2db2f25d0432a26048155182a16007e8dc1e4d559de59517bc4ea82c8b89f4a425860b877ed7dace935a7f9c3c7c19fc8649327709d25ae78e6fbc9cd21fa964a6bd952481fbf8916b6bd612c236e73d6f06098e17c6adb0086c10baaa1863c954b34ef8558ea0ab0b32a397fa84e17b57ff3f73cd7a333cd4b873f0ae5934179ccf9d6c3885100109ff22c53eb01e5ffed63d3d7fb6d11452ff3373f14dfc89ccbe98e1fa4d0f504431e13a4bab02bec8dfdb7418cc12c7be1cc9e1217d00295ba9d2f2a521bef3a12df5e368591f5fe886571fa027d81d55a7a8015f6c52401caa54576900e6b4999560c58234443f2b3bbe005a5db5053e42563378b17b4a4b9c69a118ffd7f2b3d115bddc06673d0ec535df4264963061440f2ee1b005fea37768c1dbb930e485200ba3f353cf409c907b94bfb1c6a77338c2e9918bb4cf07c470a1966e50c37b3b6c9d72fdc6d62a149edd95116770d46d050c2ecdc68f1a70b6734261cb02d655318373cead2ecac333ff140f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
