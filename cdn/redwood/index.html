<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f17be56125a73cbc3bee4a1798de1534a5cc64a1a547e125b115031a4cad6db769b9c310a04a84cc1cd813db6f012cfe78de23a4140c4aed1fce4a52dcc76803c9b982214f024e01143ec29fcef3e74a052c1a09377452346b7332c1871c0655e69268b58d4850ab91532bd1c4d3522986454be8e81a2e0fa549fb2aa476a89e8c0088b3c543094ac402fefff257081d29a736dbbc89f8d101c6ef6592768766450f2429919a659f593e6922113be27212437acb85478f289ebfda73bd86d95813fe1f3cf333b7eda3e612a5c4ea690f720e1466e09041e8b5f640f87d327fce509549b33030e47047e65d02610ac13c946e0db3261aa0de34e0f379d8ecee403912e232b1d79d973c9adf630b17e04d9ea3ba184c22ee45fa17fd19a9a7141065444cfd6980e5ca41d8d80680379287c0484f81decb8623e781aa902df760337abc84bff397078c754d1b19179a9e9876d69502f098971b762621a7aec15aec33a8a83fd43810372fd22eadf583c7116d357b17d17d4a5773c32a2686d43ab5bf97cfc0ba71e324ed127576fa54924e8c7d38b7c6b251ce8da2f463b9a4bab279ecc34b9722457cac57f9bea8f66d3f23e9452ca154e754500f786edbc7a2facc642600142904324d90edc0e526cd56ffa70079de7d95c8e32c93b43289fbcecd54b0841e756e676064e7851d640acd104227944d82ecef1acf41544e5a811470a0f2793cb2a84aa4fc9a92f0334fbd8dd029dc6bb0efcd046871af3747276a0fd2064b3bdfad051517263fdcfa86969b8f3949a29eb0eb4c5e36827bd694588952b80a0d3a72adcd98b273e9dd7c27e2357e53581b314e58e392ddca8d2b4e3b6374cbcdf7c7e2b5a08ba76e7f72f42a462583377b7eeb9024884e7145cf341ad5cedffce563f262b690fa4a28ea0893321ee85eac43ec90c95599667924bde2f8f5074a5bd54b9e7580976dff9787e4d946338980620ea7da2b3a541114cc521a6195646c32687eefc48e990751d038ff8561c105a128b3d6258f5c5b08e6936d71ed5a25e20b62f4b35897384a0da2858a3641365f2a330dd1200c6a41f0fae75eab8f9649ebf085a0e1334dbf988c43b4e0e972897baeb65fc04eff8f6613aa1290afe29987ccc9c4cd465ea024d0e5d08c3e9aa4f48946b9d70f9c1fdf8afc3c0e3fe6005c284482907aab21c55ea953c4c5d11c07caa4995aaed225d2048f85f47556376c0283e6e150d0a42e8a2029b7b8814164ea6f968ad724606a0facbff485d6b06e62b3206d6d983a00946430bfc17f2479d825940915a9b5650860d197d615fda035fef0b5d21b233443cd0c40e1ede28030f7e0f042de7a0864044df0beb3d8e3989b479fb72bb0e0b3b14e03f46384b5a92231a750c6acf6229dcd3757b7f9bfd41bbbbcb65d9b7a2e0cfa65bb75a1efd7d4e66179e8184c120c03c5349dbe3f9ab8fc0e012a10d344ec9dbb887d2b533009152b9232d40075055d6d72b1300aa07d224048d22cb5b3c9e69729b315b218f1ef436eed6428669ee91c23d3806d00b173e32efa790756e98ef4e19290826668d8afa5608fc25096b883ffab93fde3a39aed98eb247c03a898d564b479a64a8b818132ed6b07b6b6717448a69758523b4d85b4682200383c84d11c8c1ea787fdaaf4fecbd39d189315cd354d673155b2a31a43c8fb381c96c0243d56a456adeb89ca753476585a46d083ac9e954331d68337b9f051b96d7321fc11847515fd62fdbc7afd97319b36fc9ada83dabf050397eb3d3966ad55036f1c1495f720c05d1f289974a8ca53933fe11a44b3efdba1390f8739bd5fb81d62effc48b4218f010fb3c95e058400618a9f430a7688cb60a2254ddea3eca472c7782b1f7c5ddfadc0a15919c6c329beb94762a8fe0b00be16d0a971cec40ee27c58fbe45b2008903d5cb1f309b93aa1210f431ec393b32b23cf58429b6f0a25f1d179e3ff692d3c5dbce801f26a88247f78ae7a60e0178bccf1b93f84461791e6dc97cd796b5bc44c44f91b61fe2a341c98b1fffbe6e14d14e4024ff4b2e4f42e4b5aad316099314b6527c1ad37775bb403f7a6690386df3f893ead6f0a2263606ba86ec57881da38132150ef1955533537a4a6f8da62cae89c14b408659820fe98306396537cc9be5565ba1b9c0e7b5986b30b63e4f953e2fe2dbfbb3a218a32851a1bab424e055ee42526322de0f0dc715e2c76401e9835464483660a933dec56e5b61ce31e076f69657ad2fea418a40e4020a2d7fa51c453497e22e64c04cdbf75b35fe163074d26a4c739d88ddcb710c94540940e30bd350865e72684499816e8d97ec5ae7e6bce019d8f210b5e1989803263cd2985aa54db6d2c371f15cc25d49fe34b950f59042d570a837894636820c8a362e490e5186b530b688bff768915276d33ac4d9982a77faa24b302434a87828163994566863816ba9e47d65042ce9e88104feee3450f57f3cfa9c37dc5b03a03f6702e67dec0044046d549b681cbac7996e9999d1ce15809201ca43a530ffeaebfa87515c7b2219ff19d4f1524ec76dbf3b5bb1bfff794755bced053f21203ad7d79f937e7c2aaa54f6c7c879ab7690cb4c8e57bc67db849b308e86d3108d41862e5ab225a8a5f166d520ffb17f9e9449cdf269217b4ec7066dea42df2b7417bc6326fff14e43359b4d968da11e6835e19faa8343dcd59227f629fe98f3b8ffa4a2507cdb412563332d5024e0113888d04cef95e1f49e65d1f0d8d90e55b5f76d707fef31dac91ac11aaa00aede76babe67d45946c5c32cba9a16b91d67cc68ffc92e029d5c8c787906a7bac9d95212463ebc867e0d22d43df9c3d5d997a91633ceb0f3f49771a154b2798c03f0de47c4cb2376e58d3d7ff6851340c07884c742a4495d89af6306ae5bdd0613ca971b5015c1e4c2e227beb0cbe0137d104b0bb303a6f194f582f60eba98e478eb3343e2f0a6ffafa300577c0c69576a89c8fd6b54bc2d7939a5be9f741002de14102f929de156d6e667ba0b066f02036afaebf5a96e4b80f7d0f37e17a96c2712c4f4a16af89e5f29ba94cd192aec40515425dc82790c3f61ab375f5a7cfd5044420169da3faf6b09125a11c8595bfffd09186732b17a0c97ba6f1db0ae7b8ba5d12525fb7257b56bd0f6b8bc0744e8f8e8134c8d69fbd1e21763d475d96547e63971eb3ea15ce51b14782716ad8f51ab4cf783c1cca1de429d29e9016e59b52a580531395d91ed057ee91c77c3e12fbc733dc4b32dedb6f7523ba5aaea2ba899cf5208a83256be311681539e01f19a1b61d65a30bc12ce8d8b9c6a33d5e5b995d36840510044429aa309257f1719078c86d8b618bd9c43285bbbcafc9ba834d72889409bf057cabd9c003c299455a0eedacfd9a925c28cd7d3a9b2877fb679e98e554260510d450bd0013cd171d0db86c6f31525fea759db23ccd86ac3cc0646f50967e1154bb8d0e0aba4896af1958fd080d27e3dcf88fc07e3dda577ad51de3483d7ab7c7556aaec927c19a16961ca85b6a657c581ede38658a727020311d9456f7c1e0d4ee842d613f61f90b0d6dbfea0103c79df92fa0f0956a84c651d55d6c2e085fcd141bdc8fa1f550e5785d3f3dd5ca82112c878f3001acc5632b4211acf599f07c2e00b4657588b7c9e1a32aa5cde8205a12514e3733a4d6e34fe4642f2e5463d5505aa372a5ce33c450b5f2e86cbb142c1c6be90ba5950a7c2e1e1c87d6811f9679c61c4edb63ba1bad879040d652bef563d208c1ef9fb08a70a40981671efd06f4136cd15bd777efd814ff5e00baab5b2299337f663d0a6f3348fabbee5d5039effe6e183a512bc75a2ea5b4b07e45c9f8d3a5685e741a507dcf94034580a19168844754832ca2164cb428b80eee8baf609ce52d8c192720c788c4dd8a3003b81fbc606cdc2693acbff3c75d2047b826208608a0fabd7f0e43861ace722d6f5c95f3f8993636b26c416810b7c55444ee1b00bdf44283a03186272afddda24a6f70a9e60be1807eaab9fc532fe9d7a1b8917057d6bc2e779ad47c37eeca3eefa0eb688e6eb0c45536affdb788dad1d7be5c5ad49ff268168e64bbfa6a47d6d05ae2f9682cab65c9049cdf564a2768c359887ab84861c1f25869aceae2b008a00a779398a81fd475148a14f8974173d655a040da9e540fcfbb3e1c97a45f6155c01f58fd974e3b54447831d7d9826320943a077adace50b5edf8bafac08cccf9456cddc11f6c6794313d076437afc47b1aa01ccbe801d949315cb18de35233e8df62b05b56f0b9398888d77b7eb5ccd82431125a2e658350a20a15f727fb212d6277edc096eac9c31f66d7152935abfe6d865ef016e0a637bcf80c67611b675996f41736e9ed69b06cec978e0e49b1f58cdfa5834df018093d08410f1f2a1112bc47eb0743a84549f794da36ddc5c71f51a489555cf590b0477130e28f4b1e271d93592569db02e4c4590bc0f5c5d4ffe4d7372febb2ce2c3e64cb44ea6b4270114d2dccd20c7f34b9491688a5bd8eb13bbefd1abd7a272f12e07c4b3e5b3d9e5050e9dc0be906dd200adbb259fe1d2035546c3e1c0d08574e52d2ba93ad2b03e2ddacac1627372b459c0bc288816412cfa856c7433f04f131b8e1de21527b57af3935b8c074f5d363950d59c5e5b1af8c795792159b593201552a3def5a0fb6b4c6bdf2306dbb25e8966da7ccee610837128dd147b652af262c7f6ee4af691bdc7196f2fadacfd28d5f0151a3dcfcf283680ddc83a57d66bf1b89ec2137dea865ba19ea9393d42761cf00245c14e59b477f1f813f081656da5fcbf8d17eea46830122fffb8c0791f07b0d80f91552356a2119edb5c322abdfc1636b88aac87e71ccf5c4be0ec963987a9950ccd987426ed7157725ac72baa3c26736fe793e76dc74231dc2143f3a688c3cf3517dbddce02f213e5cf5c014dd91d41e907d1330b1fb56f833b4b4df9bcd4cfbf3c8597cec8b707e6a92fb259b46f3d936c913228dd961065a33d103d18c6ed753be3c60e153ad64c8cc3e471416d70951e6e5208a2d25c07cc65dc29de064e08627c23c88b29cfbb3388173261e2cdffcc3f8dc9ad2e2a8acb73c2bb2456297b074b34f2d17e249ba114d72c5e7dd1d0ee71447abe1eec3b83a84f5355e5b86df6fc73d396bd4e4c3bbed702c20f3aa70416bd74436743f92bec9bcf2f5fbf6da766ac71e23a7f72d30c78ed48c0c8b1fa0ef351a6581178e3b99795498cd271e798698b226f42a65aac4109adeaf525e338d0ea752370cadabfe1f8272413d07e8aba5d707d046ceeb4e912b2aec8502a407c9a4c30b4bb89350f9edc616a001af663378ca677a02f8d126aa2ef68ae59330ec5edfbe820cd522d08200c513f8c0d2dd1299a52b253d3cb7d2fa35048a44546a5b9851bf6a74753439892e6edef83183350531d24da907d5b32022ccade58073c2fc440832067c05accb4ef3962e738b996fa35921fa657f6d3b8a80342725fd9a0827e47507bbc7a2447ed92f6fb2df7d6c50fdf7440d1e221a7a710e546e4b23386befce850c2db0cae55a3aa69e65828f374b5288eb3cd74f2dcef4258b03d26faf51883a39774c047e77e786ef4d23fbb37e95cd453db60631df73f18ff7f040b481c27622688e8d30b67df8fa28648c9137ef9bf00ceabdb8f9456ee087ad7ab5b1052815c4479e98ac548110cffe14f4142cedae66cd9c63eb8d9049efa12e2f37ff26d31f89796e115abf7859724adff12c8ce00939119ba11890818fcdb4321c378f9b8459634d68ebc654622c66ac355cb40fcf99976eed32da38946a0b78565458d6d6580c0e91c568aa2ec341cb01c7b42659a51a8af1a50598ab64cebbc67f3971103c24f246af2888e1ea72639de6314ed8faa25ba0e74b346cc279651906ee9e438e05b78030f8812e1890f161e8422f42c4e84ac46204ffbb95925836b9e8c51630989d7edb1d3fd1a8db3aaa578b2a50d8deb379708d112df2ac64df366bf5337f44b40dc0263e73f18b214a2ae603c11f6a8f961a128d5c2c68a4e058bddf7cd7cdf689c5b01326d62d59409e930e41c5c89ee87c21fc2ebe5b5f1a0645bf5a763f7987a08e69672eb4161bec103a616f1c85665ad3ce45bc6ebebce4acc78cbba601da458df076a734f8cf21c27a88debfb978c0931149402d21660591f7d10a1fa94b60d417b72803f7309b6ce1e8cdcf5513b599c9a9697916ff823e8e45a787a580e6bcbbefbd214aede22e23053ffee23ac74b76c4f6179df7d202bc42bd70322985bc3d7829afe03389cab67a4a2fa9adf8ac804d61041773e3ac691e64835da463a34ef9aa898d5af584f6bccce152e0b7aab74ee674a40a5e5cdc7963266ef81d717b2f663ff8d4fd9e7a439b4cef894de8c2d73e57a9a0891ca65086f4c2150a68a896087ad6a3acd6a2d57eb8a0d183dc6cc4ab8cc2da2765d2b5cda4f9734d62ed2cdfb18475a1cc142e30a16b34589615b3ed04ac317a4e3c5c41f20907728be17615a4c11e2c297787239fa9f6d6f6ee89e8bb3a2b0cc7ec7052e2ebbaea9a3b38d460111c5639685fd160abcc7a120d33b112689c667b6a4c9401971ee7a3ccabd8903921e7981da85167123a2030365eabf0c6b38bc1e227deb08897b42b3c31b2019fbb41b5e0d3d86d032ae3c34575eebd7c96ae8687945fc627693e583f55d747fe578cb61fdbda9a5cfb0677f72fb2517266b79397f7e56c4d6d516cc412de9257b84209b5c53b0a5f85ae17e65e2089e3cf73d7ab03c4f6b4fd6779b13030f3057819e6ded6999229f44d04dce22503e585f679d776f65ccd57b8a0002d4cebabf59f22ea6221a6b8cf65a18ee6e590f53ba33ffa473b70b930f6570b2294951621fca40a9d111cd54533c67774571026fb879511b71681d9af0f6fe6632156db0ad32e96434d5fddfc707cf7775db023237fbf2605c85ff4ab92eb18c5f6dd04df32e4fa6d4eb4d8cd7bfebf70d7d50d61134ad4ae0c22f52c03055cc79c7cd766af4c0aa5adc3cddda883beefb291a84492d523720e4e01f96a023365e7d2cd8a5946f4a72d44b4bf3483c51551f06913122d9ed112db30699c7fe6cd2498db00f5ad5bca1ff6a4ade9bd83dbb687891218a33163354bd38914e72414cbb43ff9b0236a165734edd6e288188e86cf7a61c8b67fa2d457c40f4d9dfa56c7222fc16cc76f766e833e256d0c0e729ced5103b8bd10f443e18e520355f23d2ae1dde78bfefcbdba4fd45ccc1a471a4050d1b077165ff4628146e9cf0677b4b974ee1aa6a5755209a43b96ab9d21bf2dd21007e5d067445778abe0dc5984d7032837ff72224274650117a37a8268b87f884b6ce28bf4c3adfbd3ec6d00ca1af5d58902983d3b6371881bd852934f5c5c18b8fd622fad76a7cd6bfa31e4d93c91402b302a5fe0153390be45501c55674a25fc17818917802c2e556a580eda20957b27f6ff7e2adda83d23297270151c45ca24517b9c3e1290f96e452100bd97cd25faf49e58e9a9e488b11688b005f84439d4c0f501017f8bdd8c66ac9c4c7e6c65f689cdb8e1ff5a5406d663d3a7f2f30788335f60959c3afdbc8f3543c3078fed5ff5ab658aae9a6ee0d76a1a44df716d94d1bb14edc45b472a71830790dcd8cb1f8124481ed2be50cd1853abb6e64ef2ade62e7e494647d0e59ffdbf4bd49769a157a2b74bb3aab1f2fe0d5b3c6236485ac0d8206233da11c1de8c13b71daa56fdbd9693e8bb584b0bfc0eae8e6f0741991981de3b286e48d1ba5238897bffac630e03b819bfd2276b715abc3616f6648a6c6ad731d2498cb195fd053362bdf1fdbf30ed52e1b97efd46dedb3f2dcdcee7619fa02b693fb7ee2ff85ef0a89eed2f0a2c2c426a4efa622d6583a96ab2642ae3a9887e196a9ef77cfc03ec114f25757437787e73b5bb235f317bcb6574b23f4ccbcbc68bc9318b6b5f4a535faf723b121fd7fde2f21c266661e1bacc05ff30e397c092651d13586427cbcfa86410c999840ad469128de7a7ad790ae90c77571fe45305ea14da9e4fb55f439887054ab7595eb49bc0ec56c02b67f4a5069fc95ebf70adf2e16cea6618d4ec987a69686581a3226a0576a66d907290d605274eda3be808a26f59af8565a9d51c5f60d57765029973f5b9fbdcf5ff7388187579864e964a5dbb69820314fea224c41a36fd962c4aed55bdc70d5511545ba0ddc181a24dae7496ebdea5fd183f2096dfe9e19d8785b8308f05f96cf737cc0f5ba4090114cbc2c853e6fdc0e6f09e711a08c723bda3042828c8188e089a6bce99dab3f51e84de8933449b590c69110c117fc29700e952d86352283bd4ce9ad3baca58c384677c3863a0c73e2d3da358ca1b862458cef54eff44503380a77a720108fbfcd1f54a8141e08f3951956548a92f73c72d532cfc1bc7e7cbb40dabfd6b933c06fb1e6a45b0665cdc9410a2024786ca987dddc13369cfab9f610e1ce1859aab79084c52cccf586ec41845cc279c847575489c4ff25750b4e3dcca69beeacad8d3e19ec715d156765fc150b1df1a7ecd2d18757046cb19929544612e5428be8c4b7d67c9d62f1224dae9871a37087e661d1fbbf232325906504014730159006ba26c2e42a2cf330364d6bc1fb1ebba79da4956f1969b53ccc70d63327f4b71583fbf070539bc68d49cdf85471e8f9007d940a1464e8377ec9aea8745efb220a5e765af2671eed966416984fb9c2f58a3b11bcd1d127477b6005476ceddbe38bb576087cc5f5fbdc156a56c88a006c43164a54a79422423329f863679f9ec8daf15bfd2d6ab8940a568dfee479d751f3bdab5bc86a6b6666b03e777d839c78e21d8694bab457a955e919c58a3bb737a61de91be000be2a5e55f4076c303300e990160e675ae6748cb85d463c617ad5c2be8564578495f86172af976f01ef7b83f52963c06034c0c9da04d9b7cd8cdf87518830d64f95be62e65ca2a27ed865d4a663430fd99822b51fb7e1c67fd45646b4770400513059de3da23250e0c73f230ea408d1bd30d68b23511fa7abacd03f16b44c066fd43df6b915c67e12038e3c7b49f7be34a2a90c4bd08a55ec0b37fa41e9c8e41f90114cc40cd56974e41b2582ed96d71f2e021f83c0c3b8ee225ed081f1295084030017138d831ae7933810a25dcae9459dd629ec0b00cb50761f1f1aaaac0c84413097e65b9be8cce0fda8639eae4b31f63a48c66dfbf0ee679d3cf57a14726c8c7d3c25228134393dae4a9345de1844d66bfb407c1848a7568dc99a4d82bb871c1cdbc7c73d739cfbfa301a7cbc21fb0ad5ac2cd8fa556fd2d808431512d6818fd005232ed67c60e4395959ebbf2d6aa90f6c190c8db90294bb97029fc56b1e0b1d7540c6dbdbe1e55639bd34a8b493309992f1560a5079b1e6c950e105beb500feccfc6e7154f7e908e5338d655e628dfa24229d521c17fe6214f6830181d8e7093d7efa05137519e05a141a87e1f7e5fca1976c14751bd1f9a993d5ed10f56f213a9c61f980c287ef500e4a50198b424b77e7dabd45922b524defd11e5b9092fcf1f50031d28f0c3050a912c5efb991f4e7a81908637bafda730044bb0c19bfffb23993239c1938bd4ef38c3cadde88f990bb9a0b302db153a1427520369dc1ce136f6e40689129353f04d4ae9920e5ac2a74805dfe721486edac2512accc41adbdffe6caf5ff07d8ce3268c09333fd80c904104b5605d21bd888a9120febd18cac6697af2c82438d6d480a3feed25cbe510efef76ec0f3bcd06bacf3e5f1467759540345da14b59431717ae1ec8f1f3b605f8a39de9a00533754243025e5977aa3c8e61ab9bec8f72150206dd2a562d1618de4eb35081bf55a3d3dcca45e330ea6aa21970b7d192189c32cf51a987ef293bd56010859398449bd4526980c0a08f013f48af220233cf0b617eda886cb58c5ac6142e6305b96bb9c502ce1b251c525d0b008e8b225c6c76fa362b118e1821c4d1ae213d9668f702b282a2e69bb1d7883e444588f87b47b6c5ffc63992906120f8c61478ea37dbd8fe5e57fae2b8c1213d95e092ef8260e1afdd1987b7d682f338ad2856b23a8bbcbc9e7c8cfd9fe844b580ad31e555448b60d98b5fa215c32eb50cdb8e523b10793d5b8c1b8c4a013ec949336bbcfbca4343e6000d248fd8ddc55e931d4384c8108b4d9c4a59b71d0e11f7efb0df5c8388315a811352e030954541b0def5ea530a30cc2f11176a7df2acf9453e06526055abf21e6a3efa2c52741dab42cb47ec79185468a24459be619a33d649eead2958190941c49a7bb85d85694ff1d8968b0da2fbeb27dcc81d5d2be669455f248900929797bd2b2403dccce24adcdf385cabba2cd1c4fafffb01bc4bdbed3cab0f0b7f420069c9baf41e866ebe188fd13738bf33d2f135debd8c0fc7960afdb6aa414470b10fa496647c8702fc1e7c9f1fb9302c642bc5eb12964488350ae70a0b64ffa10f28cd866b4109a6b03c0b0713330fe18b09120177870a77c5bb55be18e8f5558b386c9e32ca8cdc4166c88cf739542ab206e91cf67f2b0be31375354356337d5b899cc2672001fa6ce72fdcbd43425620c7a27b1458f2ae11f47a855c0568c2569d59235cf047403096ddba8da1c0cf002d8cb6772db525e6b33fb3df7143b455dbb9d29b9b28473cf97623d1a53ef3702fc40a9564e531bbb6634168719fdceefe85b00746554627197997b193e145784d3042a1a87056c1f29814a7896fe0fbad422f3ee3f7e1b376a1d837d61cc9343f551f4cd90f13df7035b474a28c7ebc0573ee6032f342ddacc21c934fd5f0d028749505733908fc12c9b3b27e088f622753173c7395a5d031e34c30278a2bb7487325ce35250239ffc39942d95a1b403e77dca5aebdebd8d9289c0f618b88ad2524f34be28c93ed1a0c97d6e59c2c38f967d2e83185d7043910459e87f8b788986a45946566c50b68c9eecb24563c822602ee2ef67572dffb85d527530a3bc02131ba3ae6d409066d1386ec7e3ad3e225a361d2def4db4557a9182b694ecb3ba47821b8bdb94b2e91cb0f6d536fde9725c7dfd1a4659d5cdca3b2526e3d4ea4269990b466049785658dc8dd2493cf40e506b72bce78a8812cf7c6200412e325433ed7c30b29009716ae17b3bea0f33fa772ca671540d08a7b47c1f2f6c8073483c6682aee408a03686891cfb3167155515d60793bc6765ee6f507e609e13d56d659fc60c77e9d28b009f706d6fc0e845004f5b4883a782894fe9775f559fd80f693376e33621733b7051e105d9219be3e603ae65e6887fb2bde68d3bd07339e9438afe1a2a63f41557df453427dfff7fca598510004efefd84c2e22fce9906cd7c831f9cb72469910890f052b6cfb61d47d3ccc9ab372436435c45fa8fd2587c29bdcb2c46acf45270178091a81ddbf090d693b6ab688e58fd91f28653c6772524ff9c53ab9b2fa94bf393e113834f915dae2012118d3fc83ba1956b7b20c643729a718663676ce4d67300f192bb3504c11028d37cadd4c9413e9ce534191266dce4b4612b93a7486008a9b97eca374c274771d5ef180098e5f1c3674aeda5220881952651c9a059193f8698e715cef08f063473531547113d9ebbc1c3831c6eb6efc04c11d6082637386c334183a1b996cf88555f0ba0253f1bc7cde30ca7c875465db5a51e3cb3b1f9bf9a20aabf333d757e454fbb9baf187ff4717362bccaf96f5cdf59c5562e8968352a35cba1e4eb3cd91c774b1ca58e93be429a5eb7a85f29558d4d72bab9df3d2f2a9a202a1facd74bf6a6063b4153c79bb09bf8c4d559916801c05ebed4ba56a50c5a7483323ade64bd9912ea380b885763ba675c1d965eec6d2cf5b4660caa634d80d289d963eff5267884f58158c9dbed3bd9b7712a87e43d7a91a151c33c2a0192896594cab74ac8e766c275733dd90db06e89a883e6776f0ed00b9a41bdd49881e7a92d2d0349b78d7116a286ee9d7284d17aa873dfae73890c683b5abd1ccb7f68afeee5881dd28422486c8f6653ecce734b1abeac94a738f6de2a3fee9e438b159deefe8a6891ffb4a082fe8b22ba086c70b2a5529a3f2e8563e9bd382b0d499457b4f2d7a63e67309d730ef20e60b47d8a000af9cba847b238358f70d6a62fe760f0a85229823d4c808e3dbe63cc8a8d6753af20a713974356e01877e2f5bc7b6ceae3b2518859af0d14664914a911f6da46883729e3006f4dc08ec10d4ff3c972bc99484cf01a9d749319e9ec044c1e89445497939a01ba424839295902502c8ea7a669d913066390eca25a634a04be396a43f2092cdf989e0f4b8e56fd4a199fcd2adcc28ab3d34d450722fa02fa1ef73f411d2b0ed3ab564633aea94277c6a7411e1c301e22aed6d1a536bdf05380b220124b07861d4b7fee66146968b5b25dc96f728a823be3635498917900f4177b4361f09a970d97a4a45b0b0a21620521a40620771c4be279edde86f843bda37750f1972c603d4496fe959d657335ef055ac6de6822b0d14bad09c261fad3741d9f5f926c9896a7806675962e3cd038bfef1669d523dd6403d35027e507d9225c0e0453ef9a4758a50a68f54893997ead1fa81aa44050b79a7e48ffe046483d86c89e11bdb72bb50add945a1aa7ee78a8034b0ae6a09af90c490b44a717cce9fb0428dee01090b32a06688dc7aa8b821c79ec6cc22e9298efdd0120a21b3cbdc9c13caf60dc483c9f372e2fb8cdcfbdb5b440e308cc191645e91b417b46128bb920cb62475488404afd536f0d98606b799862e5dd4530b8af909a053f3f523f6ca71e6832542eef062ac909012fcf9a0057ca76f798df9e1f8b32271e70619d28715d1f0112559c7eccae706bf2ac60232a550e523d058ca8e0c63ec055fce144af7e3f6fcfd23a2faf1c3442fb46c81f82d3a06f2f469bee4a393ebe91e2db845cd4057be896b647f172673144ecde4c6147ebd1f795579ef336e34000d5ea8cf585afc9edd23fc28c86fa2953d9fb8dff1cca0c9f25493e6f81f7ba367905756d1a712bbf8525e93323b221fa16f35e03d026e026f5b280d11c239f797f9550f4a45542825d43f0f87af0163e4ecbe4a8dced52056cbae03f2ba1940f56a00b8965c975a6f5957046b1438afa4c64c6db7bd8744b5da9093ab5bb5e9e31fc026218316edcd2bc4bb539f4626a2da0bf38b64979d592d797b546da79e41ece5e04bcc316dd607a4c8a8c09086a1daeab9d26634f88b498c4097fd107e92d42adac046cf3edbe17491a66354f2fa324fae9373bbe27d64f268f2f72e256822a82dd3dd588cc9939ecbde129aea1c41496b85546d3fee504a08131a4db479b1887e90e93ce9ef4e2e55a6857856373d9d1a498dd452078cba25ccd471b1b8090beaab3906c7121541976f0cab84cf45040d7330f7da03d2e553ae9181b3de7d442a1b8f0e0fb47ea704b8963f130a48c07cea969fa15af03dbdb9e38778cd054831fd74c173d49cef00d17fffb2bde3bee29da8ab3e1f5131f9c13583192d0272ae9768c0f0f84be862d1ba12d7584c0100128e70b16135c333b47ca22f241b4a2a44197375d133934db6301c362d79c4d8a5d19bd023a6785787a1b55c0f9712a1f9aceca0a9129039fc9b7cf52ce66261d3d17c2fb2850595c6cfbefe32188c2ca8af04e0f4574fec5e8bf456eee14a19fa9b8de2446c9f04a2e3ab327d0284c3a70e4a2a5f8ef94631f9d6c427aea054db76a10056c50ce43f77c31928340c60fe09cd348b84b819a743f179b5b4cd2f60359de4cc5f9e01f92de3aeb98770c1f32ff70604301a73ef6ee9243016db783c0d3edcaaa921c1f769ed5843fd837f69a78ac176c045cdcf51404411db8490c4ffacbe9c80fbd8f06c51e2caf8b467107506e65ab95be5ec3cf1cf60b4ace13798d853802de91dc6b1d1ca077f07025b8f1ddd99ed3887b1a27166577cc125fdf29dc4ac71cf587e7f67726eec29963066b268b13a22ea447ae0961043485b1fa6c88ebe53305a98984fbbd1879cfb07d01dd28cd778214328f4d7bc30d6f0c293251318c592d80feac8334ce38e636733943041689fa3dc1dcb85a7bdfef61e7a90314d5284d8e15c7fdbf08375ea36f2c1731163a71d5913cc0a81e11ca2563fafe3b67fb0881f53d3c45291551f96401e723da6e0f09278bc6e2dd9e99b2e8020148898243d93e5572131101c22fd0e4b16d81964e57d17c4f27c079d0bab871508b57110ce3ef55df6798d855c1a32857415d70f530ea3652fa1349c03e91a53b7fc1ccac8af2d3392ab23796761d8b9aa7ee4e92931a0cfcaa07ee3119888ec58efd213fe99a2705f0604dd803db731a73ec9512d6c0ef27a5bc36c27ced7a0adac431f9aaf1af2f55ce75c6568e83fff12cf7812e7b94279918c2c022e619cd5a111c82a811d31ee907cb0b6ba9074528b76a0076f50b386fceea75bdb776b744fab9b2def116aab81678f9b1b3c54e30b31b7b77836b9695ec46f064462afa58063369fc75b38f3f4315f4fd60cac7192b591f273ef8557362313d346c1f95d7724dd256bf5026462e18b93950ed1b25d705669e65d0b9c64768a7759e2f5f9b9f432c8a4103f663d3f8e268b15554154e2e47074af21d436222b810c34ae4023966abbcc3cb58e49e08b383590d8ee5c7382dc92ebc3c0bf00412081e4a78b8353ddada704e0e604cb09069351b2da7ab3677f72fffbb80e138a29e2327d4dce2e6fdfec40adb76d96860fe0c12eede0bd4e770d3226fe7f703d4e776aafd51d7db0462746fefea916ecbaef63b640c01cbb05e3fff25662e0f15ccb2244e665f26ce19909987da59924f7be13a26a42dfc9c9cfe8041e26c924f2e6661dafcc0659ea85ccd6a689b53311b0d4320069c52e7ea3c072991a34f25fba63313c6e8463b0a9d9f3e7df98edf426c5911bfb16dcfcd630611de98a025564c1e446518c943a99eadef5d3a008653ece2f36c5f505b26e1b56bd50fdd63c7913adee32ab8ef42a2319dae8021b287deae41b1cbdbc1d570963c9e3f912ec768e6d162e608968b021a8d30d5bad5745a05a486c4b22c7a41c8402fae6599aa0941285394c93a5698ac7c0d1d76e5c54235656705921dc9a919ed9ce3f8a33f8b6be4ea30a8393a40b775d2033465331a7871dcfd4a1f3f45f554ee83d934ebe41fed9c03efc57ebab1ac3869dc2f02c52b79d9f54d421d2880881ff0c49275a4f5cfbd2de5aa5b97927a691150c4272d4c01c9d20da2dc65ba5c3d6282ff0b55b90dd7d02d9b128c29dd967ce3d27929428779b1af506897d2511fcc3af28792825a21ab460b444201d0f29694c61e650b1b14f15a1b688b53f9990e2da661781ddf5da49068518bc53c8c3a63b4b96a17e0450cb81584f7ee2ac157d1c88f1d80e94a66673a82a659ace398c6a599a5cf134568bb46ada9c61edb89b382da9300655706bac3be670df4b749c90b97437d1f3cb41d23d59cbd4775031d7f92c4793c316c08df9407997ada079c109cf24692df6ceaca312332f6f130c576ecab156c2b39d7157ffee5d10f6810e74ed00da15b74efd743692f8e98f9e8e01a3fe722ccac9994d8d2b8686289099f83cea60724d03d0d953da6a464ea5898c768098edba7192cb452ed98e185c8bca32913cbdc4c2f236bb54fa3407278039386b629d9bd4c11d595271d8d2b4645b36fc3c71d00dd62b8b7ce6716eaca289c8e25fe1cfc89f4283161ea0ebd6503882403c3a87eaf3cd4f69558d608af4e8d7582c0fd5bbf4066fb5b37d3a4f598a40588346744db49ed294e414c70473af3fa8fb8cd8955a5c685f71e95bbc7b90e99c5081c8452a8987e8e900b17f83a3360cffdee86ab7ba7a6a5203cb4f5de3c89549101edb53cb3e781d36c58d004cdb355b780aba3ca803e8199c30f50237eefaf6b16b5aca581e946b6c8f1e992231fe70d26ce9b2dd7f287c8f9e5c8fc39fca642fcaf1f388bb4a68a7a0759e67ffdbb167b3fd34545ec79c43a3631c13bbe054a8dedd01d702b715391f2b9be6cf7fc392b5d3a48b1abe97beb98314f1d117cc0459731aa09be1c8a01cac2a76d5eff7a75855710313f7e1890a783e7536f4a58038810ac811eb4a05781b0016b17ccaf04943c18cb6093e49985887692ec22cd21a712f4d44af06230d86ec924b4be8312323c957e77c05a94f5da8da7db990c2bb2479ecec9a858d67cabd26d2e62d9f82102fead1164cb1a14156828626c675e2753936f649399f26e9ac967b138da2e8332b2c150671b2f16e93ab9e22fc08625dce0d23a692d18946ce0bf14bee90dd236bc0c32e25d9d12eddd127494e0d13c60e3c31179770be424ff61de0ee0c0e1cda03d83c4918b3ccc4cc22225ee7be807287a3e571897f2f6012877428daee0fd7a87d4785cf861d6a78bf4dbfdba0cb7e7c2ff93384690b67c00cfcbf0cc3d6aacf1be5960f7a8fe7d5ed1537d94297275c10f455900c74f24ad10924402d7ef6dcaf76c9b28dcb041a10f6125d8acb1df4ca8855a603c835a99558576d7c648e06bee990f700f0ea7ea0cd6c596c572c5f1850ef225dffbdc3a1fd471bc3421e8853fcf253cd922c81fdb79f9002056820dd8e58e72c10f2863783929a3492a40abba724be1887cfbf04d63da8cba303f839e6a0cc67b9283f6609967cf88a2d2ddf6330e3bdb1a5df49bc3bcfdb4a6a3697b2878d5c05b2acd10a4f38167ae32247e600fe59a2df53a424e7dc6cd613c077e8c2205d64f4bde414cda5e043b6ce581899bdf6e87e865012c3c5b952ab44554ae3a6e4ab502ff72f74d051bc9f77b4b2332d5fe829b5eb7eb9031c57379a9c7252ef944cfd4899e1687ba3bfedc202b11282b403ff2e8ca91354ab9a914e6b6ded9130fcebe14dcaf80ec3c35310a3eb052ef1923b4097c9cb0b3016d16c44e3bd97a64535017302b310506b46e69afe8e3f9a4ca1ba090ef5da72cde68bc0af1041a4b7487b6b8813e0ea1836d6c28a3b210b1f99f3d7eefbaa077423d82cb7123e09ed7fdc1e8130d49c36d4fa5f07069996b8e60369438dd4340457579347fde917d523f1425de698c29698c962223538589d9b2f5c667110248e08308a026e73a515f927268d4ff3a803f0032461cd1a1e094da4127fe9781451ba5970e22187bb8e6dedc8affe99e2d484025d8eee6e936a699e5604ddf2e9d77d8970066e07d0cfc62da5119f86aa304758b39b2b369f8f144805410d9f33bc37384f239c1452446caf492087eed1eec604499789ee6d8c95ec562264f9af75069407f3d90037584e1e8f7cd327d2490a7a47af7b66e069643102d1ee69600724fc0bea41cbfb18b5a332dfe4b517022b06f6025f6a7ff4aacc4e97362942e626aa9ee2b5941a798d343f25e36316fefaac51b54d3bbc896d6c8a1b181c6d6c74650c72245d5a605fbeef4f6a81c692d6da6b1ec510f7baed3425db4362891d83ebe44f33590fdb560b6d8c5a20cabce8e45f330d3831eb7a335a9b0aab4b5729b2425ef975ae8a2f8cc5a6ed07aa1c62404928dca34048eae1ebb880ad797df49cd456bcb63f68d4d0fe4ffd96a4643c2c0c0e3a00683bb7a145a1ee3dcf3ddc457ed8a61507ca5a330c2358bde9c343dca9ede79e0bf35238b2b62be46243d0215ea75a1dff485d1d89ff1d180b43c52dccaeb70b7a1e9f522a4b7ca78d2deb6e840c57ef9df271488a1374f734902d1b378724971de81860d17aa13e235fe1aa0a83d36d22b2c76f62f927c02d5651026695b85287cde42d3351acda965f238a069f438469602a3c1cbe850147812cad58a355ff995251dee6ccfba5886b894a23f4103bcb013124327b68e12821ca712a49bd3cc4d265ab340188cca772d045ab042636fa7fb4673bc1cbc0cf661aa5385ef9485294c8bb29a6eab180cf1444ecfead86a1f1931ab8a927c8d35be4fde6ae0dd5fb7381e72daf4daf2b39d89c68c0f95f3ebac6e8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
