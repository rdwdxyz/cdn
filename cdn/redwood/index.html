<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3bb05dbf630903154b7f91b059d39b890580a90595e7b28994e1d77c5cce6f72260a3828f5b8d96ad7dcbcae2b58071577a132a1f5f4541f1b99449ca808cb5106061f45e98f1d580280304b5623b0f4ee97b22f48f569205f859009caaba51978597282a7703ab49f2c5c4dce9cf4c7f905b6f9d9c05b1faf7a32911b3b8d330171c6ec4913a800c7014d24e77e9dfcc3ce45cc3c6a4f77259a41ea3aae1b18378129f774db3a2a3968a3578e0e8f54fc8b8998ecc876189cea01da3c9415d50ef39ad257dcab6823350e4a7c4f81a9760328c476c181b750216bfb19f9c93f003b11e019193a15ce1463392d2336f7a705fa2d8a447aaba14c16137eb6a9c52c2c296e39ab4e6b1cc2bc476e977813437f78936bd5bbbb59aef4a0c054fa145f539fd370f36c4d492a7d066a0eb65754892b7e7728c58182e695e2107accb5081c1e77f807c51f2bd5ae8e1edaedd5a376efc10ab81e8d45e2a85d7a196b0c44c029f305dae59863ef77cf07a69b1573eb138675bf1d1661514e322f475a3058f87cffc893e532e4d796838ad83498a6be7fa6b363f2845c9921d2f637686e5404f593463a2b0275a39428f6697e339c6536bfef4739e111c4a0a308ba39d14d4a24a37e794fde84dc5b6c5cbc429cdbf8aae8009914690450c0ecbda068587de5783f2325ed1bfec93ece0d07d2ac8e8dd5a6c50a1a8810d348d0befa57ae2473f337419af3993798f26407b45612d7326c57f966d858090fd7babcd71374a98ca3269ac9950eacab6aa23dd3b9d9510d5828c356bd1ef854dfbf183c2242ebe3ddcdb683d08a8000fa82f91ae27ecd6835981909ae0e30a05664293b3d5d9af2db18b47e59cefad70ea88858816f0ea5d3482f6727ba6921709ad8608d0795d5f89c6e9aa26541fdf6a70bf33ad6e55d84217b01ab017d253f9301caf0a421df3821742793310210d583d55c65567f56b4688586c24ec5d9d347d74dea33c5c245b011229305fc85248511369a32a7b18caf1962f9a128e5e7f3d6865e6e16cb2aa59dea7decef9267307313893ce050cff053548d4632082d69201bd299b1aaaa267f187500f548194e6e4fda02ffc926d41479343c8fe97ee822c4bfbaa2a45f01bb801d4094a99ba613e02df326cb4fd83338b29fbe8c19be5baad4ccce9c2d3e5b8b795be03e3838cd8cfcec8f87224fbaadbd45d506d4de400d2e879ab23ecfea70bbcbaac0b58810f269c2e419ca6e70e2221333635a2b09c49a14665cd89dd446d3e54e32934c52479d7dca8e718a0827212daf4e20ec00a0caa4f4c81ba8ce2ca725f7aeefcf4c1877aadb3e3cdb7dee08f95f0b8cf45de5da76da896bff04441338f338a02e5ffb58365d5862d4d19f9d2d3672e565cbe09dac82d1bb5b0710ef1fccaa970c9fe1ac5e79a8211ee0dcff07c4beeb0ca5e0dacf5155a14412122f87fd8de4b62c70cff5877607102510ffc726d77f9b4bb76fe44bd1c5758d1e61ec74abe64162461911da09103edc047f46129a03bd6d6664ad694f92bd0dd7589c8ab3a8c5c5182307979409e44b5b734c942e1b7c57dbe2b084ae6bdd61e3e25b2d6f20d6532872bb682c7cffbb921f9aff92b168717c8c76bc8f94edd74df8279df367023971af06dd6f142603ad215cacc5137d95211208eb30c305f41260e1350c4605c4b0fcff3145f94caf0767c60666e185775e2e7c04cbe25da8465ef938c3f67ec8394fda732cc166b773398441b4ac4c52d261d7c4f6026ce9e84eca607ca4fe2fc88ac4604819eae1bd884f432e0bd154bc19cf6fee8c5e892dc8be25dfac3b984eadcdcae13473d687aaf484dbcc7bfda228513f6316298ff0d5c6aa385b12dc56994c78a44b05bcd59e95cb554212538fe05853917a478b4f337f89f2b17f21a32789312ada862a8916018649339f5c625d0a5a7be0c8a03b52db9d4e7502e5b8301459fdf78aaa79637a46c005bf05a6fb3921b61de65161f6bcfb9b0eab46fad3f5abc1ae14fc70519e03f6501470db656460ab6316e4cec63836ed3f7732d9b8358b58e6f7bf923baafa00218ec354a41cd3d49a49288027915e3aa111b55ebe25bfafdc54d5d829f0f95159d1a23c42112805033a6a1cf38ec4bb6990d18cbf71791ca0cd57993982b1d90f770edc1d506f12828b5b0c489e0bc03bc7841626e140f21d83a38acb1687909834ce1fbba4f64804d2caf465074b3b8697333bf273e06022fbbe8dcadbff21380a2fe5509a220e3496a33202859a368848ce5c40836cee7dff7f46ab81b1edf8c4c0a352a963a8c23b9d72623c509f9b431131e709b7be9099c7aa5c5d4fba09fb02912e4e875be6c52013216c2f83b9a71b864aee506ba2e556efc4ea225ac28fe15df501e473a9369d7d4722aa26eacec5d7a6c53ae1314e4cfedd3ee0cd60b55f1e80be06dbba4ddf187842d43970a7214ad2f689773d31cb7276e88c22f4271fbd684cf913a7b6ef4fb2d2767eac7c0c29a4eb12e8d8e194bef2a328c3f71c6607520832b7a9edf833866da57b71a68eff27748d1ea9ec453c2e5f93795e00f8a9c2001ac22e97da4da7f9bfb9f9bb420ccc0ca86c3a45982206f2cc413a70f580896768a7ed18c3be4657f0dd985d13a701a9adf151ceb212f1e1ea2645161fa6523db0c5fb5bcb28e996fe5abb339fb8218c7a85c8317f255ec22cebfa98d8fb0c64e51b5d22e7dca3e02fd37d990d7871fe34523b82a0423c5bddaa47c64137fad190a85db7b60a734d5d96df3c464c2aededf6e815a9011b0bea0c150d896c2f7e8461287f4691d65420ebb5f8143a7207040dd9e62381250907dd532927dc3580665eb7e2fcaa001e077ecba59e19361ee7d4d0d8f14b06e480cfaca04b69769e0d0494c5c84a082d2ba03816c0278852e43b430151e80e18dbb9cf90a95a665ee6f015d1770aea13587a7be9553b8dbc7d73ae632f047cda045e23f6219ddaaf7c2ab91bcafce096609a90a7cc8a17887408da1fb02654209ae1f8fc1d6530729ecb4bebf4801744850db3632162051a491f78e352aef8123ca91f311b2d4a12c3aef5c88cf91db27f1432f38c08cc46af444cb952544e67e4deb6fd258e5da092b1450547cbdbeedc8247b21459dc23add09cd6fe306b029203010f04106a480778ed678303ade7e369d7064f7f8feab1e02dc37aeb292116c228a04af9037371df9da71ad6e1eb8404cf26c983e7637c74fabe5ec3d8f8d9164854a253c11061d220585954d9296fbb58f1818c1fb38990d392f74fbd5bf8964adfe57585b2f1ec1c942f206e9233c40529f8cd9933aaa03b87c4739cccd41169eadf626ed4bcaf7e14e5f8bdde38eddc0f726a236cade2db920462c2d96dfbb325762493706e240150af4d82e8849350c6dabaa7ec2d35113fad910a6e6d4aeb95ed49978b59e006f2a514f5417965811142d661b9ed50dec5f540a7fce4102a5519bcb86c5c3fba3d434141e9ce9da071aee4f061c69b421c6f55dfc0696d0bc01d5c255ff677ce227a17e7fa7232411ceb0ec0734ce6d32dd167fe0ded208d7ad26d6d16d14c6b3337b11d38538a8463a43b78168e1eed2fd2e4f948dbb59f7879e0b4667dbefffa77ee0fe7c8940a37649fbb1d125e5a4f8ced9cc091818a85a90aa73afe80ca9730ae18d58486abdf5c298bd6722955eb1794e464e870cd3930b43ab67744ea219e95c7cb3a66cf8022068bc78082a54b84f5d62b06367de2174aef48b82d4ae8a7180464a69d715831d1dc0f2495a324b188761ffbdeac977a7f66e45a4494e9498788dc0fc8a5328e21dcbae853c0b711a3c86f1c8607ee8640ae36a7d76c5c6a706b63e46911e64f1b52b63e9ee497524ce760246869079671105b4e9767a089a76c9d975a8a39dd4bfca6ae6ba6541f1e218cd3dbe3d58fc1586a37ceab6bc3d94464af29a99accaa955714efd838643e61a51a826a2cdf66cef2c12678a658d451c5cfca9a5de91a71b511e234270ce464cede24492ff31d12c1acd310593b8b497390985093352c46d794ed71040621f6403ae0705d449576c95e91f1a437ca79650e9123b03d79517b3c98d1f6faf44659f7739b91b63bb3eb80713be24d405609dc6cd398e092be83e247466e6ab844286656eec6f3f885d227de0b619d26a766a8db3d9e7f5034212760619a3a5d94b152e5a5a6f83c229741617f7d0b7e63298ae6f8dc43c4acf02bd08ff9c0f10a4d7f855578fcbf24dc4a73e93aed9deebc4f79944a2f03665826f15986c5fbf828f2adddad9d0930b27d4bc5ddded3a1e1152d972d4b477440d765c07e61973b1af48d6c8485e53494054cc69509ad7ef8b5702db32b19028d79f84dfb6220d4d0053ed25a918af2aed84e5cf0120ff19152f34c8ac5eeb26963c7fc46b9c7487210cbbb3869ce911e7c2403d8662eadf297db029672a84dda453394e3d2ab99fa13008fd748968ec0050652423856f06efad85c29bc3baec6841fbe5789861efdeed9669dfd2216ce38c88f57543e4aa49462cba7712bc982ab38f71e682f8559f2cc968a4afd8c837df9757ef9936dc03a51f27e040a4fed44823c00c4b11c2d1374a0f8994cf6daa287de13b2d1a43a2db60b4cd481fdeea06d8ecf7ed7ff2961f5877be00992e51b32141e889a7203f1f18fbae89baabf82e236297b6d2fcb831e7d3554c32473b8b23db62e5f983b02b26a8c24d4084129d3fef758d9fdf00d7ff3633f5f2f8283ab026c60fc223ba39b79975f1cc9a419ffc77ce0a7a1fc79f81441be1ba4d8bba1c82b33a836b7594c6bc8a6b5f4665d655e905e0bf35f270e9cdf9645248a0ab8540f57ed11b206c9b0077606892a9508a138272e78217cb4bed36e689735c48b2ec592a04c438ca61bb18b75a72632f2cf694ee0535b9b776d250a54c7d5b7711733062e33e69dd3d153e38f5586d34c4b2cdf03189c15d2fc8b76b6c91a11d79c3ab51af3c622b66441c24864cb172b19efefa8385c50b87c28e57d1234b7a229489bef782e0795631508f5580dd5349c4f0dfeda55ba8aec3af671cc72b51a427f5bde6e305530e3fb6b863adfb53c815bb08a7ed53516f71af0bab12cfa7e8483d5dd6289ca54f213c8efefc77870039845659cd22283793cc58ee089800d8e26b1e38452fe2504633f35e9f65e7a0d57acb67360cddcf692b20c8c664e16a3d3137762320b16f662f2428ae787af16f7cdc016d5cfb425e0e7bd0cc82f642e2920da31d740cb425742c91f4b00543e1720a0b35c791b0c63d9ed21a4f9581367b9dfc3f725f7bce17275f7eba3dbc81e822643eac345007b463b6168f1914a8b718193e9a9687fcca256f648f30a14f654aa5e3f181f729e3888ea1231765031ce32c4b3f445b019e16ac17a6298033bdcff0b31894e9707f57f38672f2815cd9709f23bcf3f6957d6c4a2af3388a27743065d9f651e6a58367c0d9e5988e604b9fb3d79b875053f27dded00685231dc97ea24b78750a6273ca6166dc81640e7b63b0cc0d4cec35a7e14980861273420fc6dc421dce07e1fa18d34bda5002e2e1e248e214cfd078e11e4b50a11298fde966898bea8fd95667fe627fcdced25992a834488b124626f4158f8545dcc0134625ccf14df20ee3f24cdfce9927c6f74a58c8b4346241ad351d1fe5f0c63526da9f5965a2d14584e71a36dff4bc62a7b59f572cabd29f99a4a5c5db00c1e542c1b3d2421e89f115049442dd9bb5a4e7aed6af223d3ab52c512b898053b0cf94ef8270556812d27d9319e19eeab721f995470917cc306d494c372ff3221112f3a11836c422aa16ce3018acfc506d6fce9ce6595cea30ea749182bd1f8f0413c09097fdd029c1312f97d0158baa03885bd55674ec3da3a81ee511f6720aa1e63e722abd1eddc1849eac35d4045a1521e25c02131d827d3102a93b4053e06e785b8d1275b9e7a707efd290359ddc427d5281ac77dac25c6c90d62e46a2d70236eb9401fde368ba6a5327db7e059eb679b2d6c33e529fa193318979686d9676032afdd005adb7dfcd1a8802ff224cce00e5b93ba14b9adaed568da09cf2daeba42045bcfb1b95338ab70ee98b3cdcdfaba1aea01bfb96366efc8c182cf8b60ecc681fb0cea9dd43ae78daa74302156a2e5d6bc971ab9947282536a7eb823b2d3cfdaf35f70be462005b782806aeeebc8904bdac48ee5369673fc0cc38ab733383d5e49e683b0794b9df1a3332cbcad4069df72fc25f2673195be4db17647e824b97f700f420819146c0f9a7d0cb4562aa9d235992b2a9156532668e8497ddfddbf42102df199391b1702fba0865b53d8a7ff0a0580727c74c7da1adf896664c3f534ed2296c9f021a579c5448c62ca2810feefa5f60c700ec284e8c1a3ea1eda9669cc969bee3158bcb9c5d1c35d657c2d4485a5fd2dc647ee2846d04b7ceb15dfc2f216c4e38dd2a02ddb14def91f0cafc6f61ccf2bd965778fb39dab03e3c0aa1dea7e4fc67fce378d7a41ea136e03c380624c5f0df06723152301a7c92b256ce839d01a5517644389dead9c49c44a03bc7acc33a6b8ac9d5db244b26522e14ae9b30308d04c6a82823769a3f3dec72305edcd7f06a544436522d55136a9d685fba7eb4a805129ceba9634f3718f34195d2a7dc4ec4c5d3f7b7bf1543f9e2d3f267bdbe6f1137385fe42ffea5bea1af08c048ec969ef78e2d74ce968e2e35152387281dabefb2e6e0e05309aa7ea09bd61c268f6a15e7e2e9abf8735192a1640197c10e382ad82a2001e3f7d62d92f0470b4ef5f922e3ff582f875c0ac64534e77e701116a8287e07825672409791daadd4321f743a00b8285109d513257484ceb801216ed0a9d01956168283d782683b3748622818e230f1f9c912b06680e709511b9afd2cba782f1be477489b228bd9eefd5f684766e3e7418242aa225361e04eb82ced273cd6d62a66fb347b1d8df8bc5eac4cc81cc0fd41b53571939ef95d67fa68bc0917928ecca06b4a5c3ba7c155f3fdde079de559719cbdcaf2a86b6bde38ebe543bcd5adb71167f729b86115e6f809136af2718c9f83a69b1fcd482a9e93c803871e770d444e3c0c34491b252c83982d95c5f874b0631b33cb355610167d34b87ad358b57e70c93b2c6dd950b336fa279af5181ab41039eaab1b07ada4d89da67f83f84f1d8f43b420fbb0ce3924f7812582ff0b9478cf589783d354dfdf027aca2fb3db9d783b1989e7969a50eadce4347a16b9161a201de67cc84605ec000f8aa459484cdac1e52348cff6741a3e2a507c10bc90b94ead9ab429a9506ae15b4290d2f579e979ea7829b4bbb36a8d5aa2dbe8b2af1337fa23ff62c44815a88061394a1c8c99deb2e2f9267c51a52ca64cc437d19dd4e270cc57a6feb43fb28860060ae6a4299c602c1d04aac3a01906cd3ef1d53cfc117774894a211db34c44e8690c23f34120939a17f628738b8832bbf8587aa683671fe7ad80c2c9f783d007a8aee8e9b9badfe8fbafd447a752d8884a1b19d792cd08776ba36cd473166e2258399e12d59695368987a5380f522866269f7242485d23cb480c5affceeab4c0b7d77b901c4af31108855a5a6ad411dfaa3b6cfef9acbd44bffa97993a1d1515ffc3355eca5d738905b56da20b298e58800aa51adaadb31ee154eeb46ba47dd78ffe7f3536c491a23c313888976ea25a27173aa5bbea8567c90bedefce5fd449d3d1128820e4f3b202899161d95ca7d780c15e9ace98b056ff77105652e8aa687e4fd58adc07921885150147370443e93bb927d79641bafc9f3d747255754b7abc334e82cee214db901f3eaf37103a28a964354f6d4a7af7d845dd8f53ca2638f420506de0a95fed5ec085d33f0617d59dfe5e4f2ffea9fac58a409b255e866f0f344130698068d90b129644f0f863fee1cd582928e53d05bb92b80aea3c796294ac2081924b78f9aea3d329daacb9f364b121bb275d420f2cc003df016c9647bd93981dc49fa9c2a0f49a82a6fe9c7f938dba9f619a9ce59fecc9dacf403baaa28dc8c7fade3e3da9ec17c554859d9364b1317d58f7b27f29410cac6dc4c5318a363c61dcd3823379be15877e81fe42d33c9224dfd1529a8c33755882520e6b14eab91ee71426055ad2a5eb92a8c1b056f7f5702751a66602e7f04724cc574d90dfb2c6580fc409ce8ebfeec9eea9707d01fafa6512d070aabb7f071f4ef52ae1db437ffc9fd93574181d859321aec528353e527be204d798cba3a157273e41b1306166964faa0034c0fd322112b44c627bd8d93ea834b3ddfd0f47e39cbd04a49badff74f8c9f44212a491219b521d3e16d249efeecc2736659a69eabe0ca02384a913af67b00506e4db0edf27d0d8d4659afbe4f5dbf33fc185558610e6f990a3c96a328247af04748f51e4b66f6160465b279ace8006b5ca5ef76b4a71ee4cc0cb8821aceb701f4af04969fe9cf5be6b49b8605b56f0b98086302c042ff8b999e9d5f406c0e00f60f650d6229fa8584e979ee0259880f368fb4352c8581e3b42008addc78b2fe249a078a0edfce848ccfaafe445fc3b6409b647b553373a2a47b1675e18929c22da275d956155fdb3e008cce11562e7cbdcc1c21d74a5c5a5e423d1c9b6eaed08d69d877ac110ffb6374cfb701fdd3e27b270ef0ba884da146b1a861a874289df9fa545a02904067f27648fbef79eafdc4ae6bbf4bf319b2c946332f5fad3de3df95a41b6656a5420b3c3ae2282c511b00ebe4f2ff841c3d9f051ce687d8d3005480133360abe7d3bba95d9543daf3ca23e421439c21156793c4887919260d4f8f6a7d53af005f16b751e5d2483b50c31b35a868e75c2154a858acaed1c73be792c7907fe5c21cc01bdc0ca04bac59d5aae5200301ae3b23aebf76475b1bae5c3eb50a4c0f5cb10532f72c5d3c6e802aa5dfa9a73bbb480b16af064ec1f8854052ecd5000a45a985b29622f9cd29e92a559598f35cc3ab0cd582cbabac2a672870e64faa7b2d8081fb3083270e7d1ee58e905bfddab32cc485c5186378e3ea03e8d0b72cdbff304670efbbecb6af773ed953a7caa8af4e1b1c89beea8dc77d536088dd401fa8e9593f93df31eec9629ae4fa5fee0a0bfd6912dfc8280faae74cd2bdbbb5ba151d2ab2d973c565817f2561ef88af67561a54adf9082f03b389ca99f89d5a4959bae189b3cbd9fcf31aad18142c45c1e132698cd17c09c38d0b748f34b64d4281713b74af7104e71c2ee2520fc0801c4fe5465d18c83314d2e0b12cc04d5e5fc672dd61d780e38f52cee10c18ef0f27c3f0810dba4d029f0817c332390423728597d793825e58b6f31614a7916c2db71a6c4e8996eeb1f131fc7ad8fcf26a76234825a526d509b3bbb8fe35f36a14311aed239b2acbc0c383ff47bd6be13dd27e11a7825f0925f77a4407967563bc5b7773f73b22f3acea6c39de2afe7d31ff92ffaf875d4bc656a8e7d44fcbb0f714e0df4f87ab402e72caf86170eb96d5d82203c778c48ac66e9709ef41b71738a67725a943e1952c3a07ae7826583d8483534486d0c4d2ad92cca0e35c7651fe95cdd76286373486cdc665668c4c20142a09c2d0f8561ade753bd2d735bb99157fa48a119e8a658f048b245e0d1bf99b11bc759f1629b1065c3c2c7a28a1416877ba12b2728245c287637621ee903a70c29780715af51193d45b52206f600e918a058e34dc012799e2ba1ef689bd743a8f2838222c13c6f0761967c805c33317b84fa8633db46cbdd99ca155ab487f596b8aebd3dc32eb4948acb456298610f388abfa1de7e11967777fdeae5e93f1a16dfd4e93ae3e7ad515299b7b3c9f44857329f22043d847fb1f15b936a189666f49c1bd37690978d367ec94a5f75912adaa817c89c564210e09fd54adab7b76037f591b30160e98188836532682de13135da702530c5a27ca7bd398119a7444f91286dd359fc2185fd4c02f3ffd06a1603f92b60b95086e4f05d80f3d34248a06792423631ca83f64adfe8eda4108f90cc9f1a91eab930fb5816935305e22d55591352e0f99afe9eca8ac0385e931cc5496c13059b4f1041775ce2d2d69464260a3090ce4400cffb70be4e7e45d434ca3b602bd2eb43884817df45853911cc5604a1b5c2343c7c2f4bf19d84b3fc9258f05739ae55d8737f50c64da6d16c09bbe8d8084c673490aa2401967d30e9d4e242df671d5eb318ec8c1fd1ae6f26e1934730d185ab5395f356c377928c6a342779dd896bd5841f94f6d8211c39c642ac952c022298bbe49bf76d7c4687d35b60a326a3ac480ced2aaa11ace4836cc6993d011bd8b3e3959d9c5fcf03e98bdeee2d22e69318780dc73b7d4c6ac704e6ed2a030187579a3c550ea5e17a42e6fcb6c0ef2633a70bc8ad23bc696260c466e5afbd39086df5b799e0372af26b2ae5fed37e28468ffc904e6081a7babd912ae9391769c19ed0f776ca747d8a4c8ba9c171a42847e08aab40c4a9c0cec759b70a3ac02bffc66fee8357e0cfb810991a653a10dd7b7881fc43b18a50793235850ea23ee3ca5c01324100602d864b81b431d120a8689eb81327500f7dd102149c326ccd7bd1884497ec779da6802d9074f937d8dd5f5f3b4ecf3bf2996c4cf2be85a3fcd73fb08efa8ff315b07ac1d4a512b19fd7b4fa3556f30115a20e5fcd8c78defcc33cce11a10d55efd317cd1b5b463fdd016d65d951747b48b32d6e69cc5a1c59fd3a87ca6f14e735c7d650c5b1fe6f7c541dcd7cff91856982b0396514199f58fdd03d88bd250621f1065e226c6e41d292eb418532e3f403edda0a971f0d01dc12b9bd8fb13675bc5b110f7ca32fbc06998054c10aa6972197867081096e640a285c0bc6e0ae3633d63275ba2bfea981dd12f6312eb19231a22d435a595e5f2ae140239f847f9b165c7d53b1f03e38aa79a64fcb4b0422e9b9c6ec84b9e2a1f56f143f7bd6b14c61fac171cd973d17d24eb1248fb1052b52622de7f007948dbbe0b937e929a111abb4efced309f0b11de8bb7e359913c014fdb1364ca6cd87464cdfa2d2855c7dc35d4be878f8a2a1f9e128d1c49ff910e2367e6148c80a6cffb52f694f1b9533a62cbcc05bed7544ac639d4b8ff2d98836885d6daf7bd7a696d53da55b07f84896cd76503df3e07b09ffd6a0da8c5455807a80c3212d9e1aaabec1ecdc427a9cd6d69bdc60b29c722c3993983a14d968b3e487d4fa6098f3d552ea6e9a68209b5087504bf7d983239cc7aad4ba4b7d7147dd837af9f3ff1c71ef6040808b813eb7aab8c5e90dc05a5d53f894a88790aa9180d422af49c7c53eeb017069aabc3285edd6ae626077350d4fc6d8963cd6f6f21db3ed5d9645ba35b203af622d626afe272047f66a75d5e16ec39bb3cfd3478a496ed8cd30c691ba52e7d2a9e6219d1e04f29af1236656b33a47eb3b6bfdf42140d66001870f400d94c26988708b9cc4b112692504d75b252172a060e4fbb562dd85e95d8a71badab9d0e96df22795d2cb4fa1a95d48851be244b5ef0c7e1b862e86837c9f759383eb20280dae48a197aed6243739145fb1d3d3070785a799ee4bfc41377df9ef27a1560913d80dc060537c0e5b334fd3491bb5d890b466a8dcdeba2b4375abef5593bc8a580ef8da3d22833af59deb0c65d7c6fd2639660f5a12278cbd07d2acb982f0ec9cd4a5749a5adccb1a4fc285734a3451059cfd00586a25655ebd3f53932643f83109f435e12cf3d9273514792eb47db24e22ab243dbdef8b2ad853c8933a23559d57fa4a46e80aa10ba405afc7d15f57d192f0830e604e45afde414d07cf79b2c73aa11ac6b4071e3fe6a3b02b6606d0459d560ec28de647b3233421698cde80b1174308c8bc87a89ad9ac30129cf182930a99735dab25a153e9dc05c61f067e5a136f1351fddc6df4a7c327db2d37d3ebb15ec4a17ae25b6b9a8ae9ef03c51cd23d2c292397094ec3b0c64c13676b6afe5366610658cd462a54bed3b8f525c39142931794f3f183e3616c753f0be34b66bc6921ae892a096f9fe05cf64397f00273aca48f479a105895b700e18deb1f97535bd0676d296444c4513acbd4b01235945e6e4a1ef9735b46f27169eb2c8a5113e93ec87412430e74020375d15a83bd5dd63137f3b865212ed21ea702556f5e078e887b89b5c87fafd821946d54a1fe3c974131623c72c0162ef4595c20d7e16d4455a49a45bf7112d3441ca9150a20de58b4e57591b0f133708557ff62f4dbc11987a4db149e3e603f6b2702e02513d0c1241fe5aeb6fd3feaa8f3e3078ad2a7d54b8356219b30516d29898f65cd286bb17bf62b1c5e4c1546689cbe9250c8d6e102c40d2095d30c85b7990d071bd250340d5d2a8f9de9b5e6504d957e548deaa496e6619230ac181ec74777a327f7dff4c91885f27f80f6162ebbfdee550b8aca79e12759846f1d2c60eac6403063b001d57a27d0e922dede2467e7cd5233f1a05c70fbe8b22ade7b1a6d961b141f827561c88da38fef158e541206e9e827cb9754297da6df1c8d9ec3f9057430baf37a22ed37cbf4f171ebfc7ef71593d8d91885a4e7396782ff95dd5973165dcbac41dcb0b94fd6c097bc5d67586b4bbfcdfd27e3241782e914c309806a50d8f8554a60ca1f1086ccf45a70dd68f7e95bdafcd694597fa07b46d621368cec1dfbf701160e7e92d95904c162fec4e98c3b8ba136427e95499f9b5e6e0454fa6fa90ab5eb9ba05c42c7f77c22dec8a6a6155788184a09367ad7f9a21d2439fd6987572904b7aabf243b68cd0f48d8b2adfd4e35c9c741575be638ce14d1864356f790a7a7a0cce514c762a0ca30943dcffabce823893c98563809225bca6d69483c4410eb01d279892e5f7d625af6c1bca2b7e2d8e47f9c2970be5799d640dd77c9f7f806b889bd03dabda64a4954d8735cb983f5bcd218e3daee1d6019ab3a43579723230e2ee45559bbd7252d2c2827bc83bbd5c2e89486bebad49d6d5acf19d9b186f3c2a5354a5da6c2dec6957b37b1e83c64be7c0cc5937e9d587c651aa4fa4799d3c1f59bbedc7c9fc0304d1830ddfe0807bf620970c4309c5ba32162e1a421fb5f5d23327eafbe1db8a45fc6bff29848dd04cf7fe6fdae17986565d03cf2b6c0d0950ed800c14279ea1a2c0b37ba3cf9450ef699703dbb86f3bbc3c1959070c5dfc0c094407cbec26783d73dc20e2b5eac6143d6c28ae2da99491d2cff23651d04b7fa3c33bd655a4345df3152c2381d0276cbeb56b28c85fbd93161b5cd5da004861f6e7a2771ca1c2b54d958178e99f249fb2fb889a10aabbb1d75a655aab268df5a86b638ec098caba32ec24f6af61a99ad6b496f8af72bd69c6c9a5dad2a37573c2f84bb6019ec8f25bfa3bbaa2ba9399caad4c7bbd6761e4bf8d2fb314647a0db049fda354b1bc9e0b48bd8d393fe683f70de7a7078fa8d420842dd52536060929b22da8df3769f57c8a3220c9324cec17a2a9001f4fd1f2b6ae6169dacc46de6d832b0843cbcaaa0808b0b79b2087dc8ffe46cc81609dcc2123ae0a30daae604c6cbf1ba4bd9ed0feaf4821a5e38ad3b0212ed3adb2f28a91269a83b71dd75e5737c28536c4f68ba6115fc1a3235f5d7b514aec123267627e0d3aded0bc9677d871aa945e86483b4654245ca6ca3841799c2e2e43dbd9ebc87f811a43331d5fa81022d77ea39a15fa2e45c920a031820f5c185967355f06decd1c0899bb331512d27892d0e3323d61a9e3dd91a7a3e39127adb39147c76c6bfb9ac3f611925bf46d25db2ccadbe60877bc64913cce1a7151d3ab0437f415a342e0f4e95c03c71d522f049c2dedb2191c1021b6aa54067d39aeb6abbc2d53f317ec986f8c4f79ef0fa610c14e5e1283120cc7ccd60844c2d8bf4152e013a85219d64ff8d71041d7898bb3e99f8a2a583d25e2aee5aa491863ff2c57852174c9c1beaf1fc6a4f26e848632c0ddf41ccf50f9a906948005b7382c2ebd8f3735ac96c3b5a40fecbfc5ad56a37146a95244656b3e9de8dc5a83b83a26cdf6387c4147af1721f410803c11cbc5c308d0b919b35c117b3d6eb5536991be88c7066a3b53897802d2377155cfc3eab707da4c539ac69fcef3f06cc72c0ff6dd33f2a2ee99203606f790f523791ef13bcaf461865687c69fc0246e298716978477a7480e34118d2b423be7cf154450128fda2aee690d12b1d018705d6d980b8d8a8e2a286e4ad13303b5a8b122a545c8e8c2868ef4176789d509d522abca16c486ee5d735b60751c180a1d895cfb81cc4408f24280256c38b1919f6fa091e98e4bb87db5164503b69a54483582330664fc35385f6ddee05df2abe69120bf077c932fcd8858b242495d611319b31073b638ab48c866c628a1bda641aa5999d2feb66397bf6438a02abbd81f86bb08775471ffae3afb2842cbd873f64b80a317c131d199cd1fcebd96ee3b69c0a07d43e79326097b0b3e92d1449e7d52273c72d09b08efd2b58a790cae6a8c4880037061762d95b7722ccbcc3177207b8b7a3d20c1d82141a994cdfab6b921c819c3e86d526e893b8ba269e555ed133bc9c45ac5beb6370e7ddd3ffc2631471980469b17f06aef88db8644f75c9abbd13e81b6a337efb09dfa72a85266b8bf4b255ecda37696453968d60b1c0d2af04a081d13f3668c6abbc4ca0c80c8b8c586ba6cd8120e19c616e17266d835b00a038e851469bdddcc3e67f70ec06df583a3b36cf4c83285754eb595400c00aaf7fad42efbba97e37c93e1edad4ec5a2cf63e052208ec5d9c54fcd37149972bc7e8c94ce6f8973ccc181774e183fbb9854d23985db98658330693c9e09c08a1038494276721aa64065bc2250d7df3b2ffddab42f34f15f522a4b8b6db7739226237f46a9b94b7cc1560657d56759315af7552417f907746b69b2051ae40b48b2c94bc318b1f4fc220c2ebcf1e96a6dc0e1424da7f6dfcf97ee443459895e948a8b335003f7350962928fa68890f54331d7292c70f1d2a77b15a48b3144b06a1f3e8b7393b77b42da7bc207bc764bfe52cf67bf4adab2103798527db529a85806dc4769a11eb0838824659e0fba4006ccf8f6c5b6e0e6e58c5c729c83d0767255e2c3653ddde5dc079134f8f6698f6f48cf895657b13061344a3e73ae87a4dbd42eab54535e6f4da68c066db9f588c53968a562df0b3a4132a1cb24b75135d0b5d1666163c305a95bbc5e6e956b1b3d078e5d3950c359b13c31435a5027c7797005708a8c3da8fd387f736af0b916b74a651f04ebb302d5647e315f5d68059f6d976e61b80e668dd0172f69018fb10f4f11a337235e5683332b941e27bbae74551aac23e4ae4969ebba0ed32a621a6e45d69e5e34772db735387cec3979556ea39cadc1ceda34dc1ad93f7c16b0ff6c43f7e7b44d061b13cf8cbec851c64125f32ea64baddc196aae9ad5e6d5203eecbd3fa487c2246ded13996f544d42b3ae50bd293886a8286a491d3b742935035bff583a4da93346dc6928538e3c7ad1ef5030ad0c6b1fb1ce56711ff4a00a64838d97b3c657fe33e6af60749ead93bcceba5b592bf0a3d77eb19f9ece7d7887be2cf283e229e7310eaeece7a67ce8076072908a5f80d4ddf018c07b3e0e23340bb9a676f73ca5331b21a48efbdaaa6d4c5fe8b06ef0167596457888785c638c83ef7be311c0b944d5dc62b13c97373dfe6eac3e0ebc61f10adbedd82a5549ad8bd04dd60e45a96004e3732354d2d32b33522e51e85803398e0047905d21ee0ce402b95bcbbd5e938b537edf2193883f1ce87b070dfe0721702c772ff49fe6dcbce2160e11b8d77031556f518efb38c649d17a28e759b447780a37ecf5dab1264d414943b5064d793c9a1d343c4baa8ce24e69c97b7acd80e3f3bbfbf1b51aaca85fd615fe3481cb8e4fafafc6cc966dac5deedae2377236b25986a84e0a5b3937bef2687e7b1300369fe32446e8160c1121236819d4daa4a4d228599e1f7407c3132ad63a84256471945a5770b4e2e00c264322a136ba026ad5a3429ad7b1c9a423b5e85f765a37d7c3f232cdf79c74df90659acc0b75765ce781fc7e3136029749dc9a41b3ce98f021dc9311fcf38ebb264f6b890067cbf6628b8065259475450ce18b276429b08be9416bf31533871692de57483f37135bb8d1938668497c07ec43ea8042f38ff6ee2b784e7be4cc5f459452794bcb213f97b589ca2cbf53fca296f5fb893e940ee274f6d4a768ae12d73a248322a4bb42cb4d24825e77ca33e19cf5d7ed16a15807a11e9ed7249ed568a9e8045b07e8fa65369155836d12136799c6121c1706154b39932f7df23702170f104f1cda2a50e578f38d80e5627569441a56d2cbdc8a6afdee44467fc82487a2ecd0f81c4afd6c52a3e86eb997f3c3dd19f231efb515b110169456034bf7aa479e5b9df30feb3e9e7134940a836bc3f75e138188811c291f3e553c5018127f64db832b2838a7106d53feb77ea6ee1b16a2d6bdcc6a28b14c1dad4c02d0a40fd77f7f28e1cf8137cdf766961e1489674464b6ede212eacc2124db8aa108b160052e937e94a2df0def000b6f431c9182198d10020dc4ae8786a6933668d7765f50363506e52a8f6b8b1f1676fff8356045102628bf2b6717def2960dfbccb364c377e79d8d08a96e212df757c832fe1db8c2440c90df36f2046205d6755c26cc72b3e9f03f78b0d8e3ba684bd0fc6cc84c700ac8029fc8f9393f9143f22f831a395bb7659576885d7978f00da6d8c1a9cb95956341aec5daa895ade6fee63c0d786caca8c88d8a2d914ad6f08744e4b8d6d30194c016f130884d0179122771c8c1bd2fccc4c986e26c11a7da3058d521b9d8794c91d2362d8c147190b6980274d5166cc0c87ee34f9759dfc307153493a0732dd7f349827277bb377097ea9b972f662ed177e98dc156282abc84da6b7511b8ae5117a41e2e6489b458f01d9556920db8e0609d10b27264f7ecf433da0483ca70d79fa67cf20cc45c492b0a64866e3f87866a5b43fdf8e839bc1bd8ac9b04ee4075c0c7622d6ac5a166a8fccda4d05073a3b93b57bb38617649b4ab8680a4120a6d1b46f2fb13b427e91791b243d214390b6838b9a00d950f19fedc7fd1306dd1207cdda3af820f1d7048f534adbcae2fc6e9961d9f2cc48362b03eab3d46b478b145fb93f6bd788259a5ccce48db0d64a02f69ec3385a715d775c8c0fb26fb0f64da3b7c7f54d7861db15d2917f6b876ce5af1a1e4e69813aeab7584bd0bb5ab36896d0c4eb92b1324377d30bc4db76a9efe809505ff0fce8261695e58c1677deed9017fbd4ba65734f0d1bd770ba710d800201b4034b3bc23af40a37c02120cec66081b0455fd2e4736b40be9cab4e83acba78c78693bd4fc6cc5a6070fa3fd981e4b219d95d61bb4241607e1cc76954f8ebc30e5347b584ca71e42fb2173f3711f6e557cffdab3845235df6b4ec9bfaba33ef7306decd5dc56a7840c3be11694a8ba7c08ece7454c89080c85607cd6ed42986a1d8f009e23303327dfe4535561936bd18fcdae1bac17255181b2995a9823f26e56b15176ffaf3ae68ecf5fb4d1ff737d840970b586978298768b7884cc4fa4a377b90a62da1f652bef204d7148e074b0b04af75bcf6d4bf639292eb1a9d0857c2e7f28e5812712a90ccd16d756183b41692db908515a26e56387f4e2c5efcd895a5d62e0792eab8840f2b0eb035c23115c9e2f5449d6e0d584f58db7555c336c3ca3f2ad87035fd4c0677b6a29493da303197a745cb9474bf6320debd0b77143d4f3a983cb264ae4ee9e92bf8423e7414095e9b22454b05ff8f41fd9243f5fc7c7c7270dbbc07f9bb06a0ac0e1af900da02f4f8aa61df496fe284cb1dbfebf23495cf63be8cf88d1ec37dd08acdd7d6c89d42f768d3f541dc8ac6f283a748a423fe20f6b25cfc8641f84f22cd1d88b0aaa2e136c537a6f3d24f82e0312032123e3eaba109c6270f08d8a53f68f579be62a83292e0e75b28814f079","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
