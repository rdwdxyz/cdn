<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"252ba067c04403651e73e7be26f643a861f09abff6139ff8240cd69bfd6b1ebae6bf82a01c8c851f35f835aad126b2be05ce53af8d41d662709eb278bbe719e6dcb1273c412b72dbfb9d418addfc3887796e90d444128cbe7dda7169c9508b91bbf005bf9a1d308bb55658300034b226e9662937d447bdab3dbbe349546a62e6ea0c32311c16f49d86f2543238e07f4696971bda4557e88b449e70fa7e8b3934ab4a0b0d7d3b5797e839eb49c395007cf1357897180576ad8f4c51936e4e716648cf54be2cbe27cae478f9beb88420999b1c547cdeea2ff0eeef6c8593f1055bff94ae22cd475cc49f9fbcdd8b2f96917544d09040698af697e4c7102adb6006e71a8644c90f2af0c44d10edf866a9dbd01dc139af9d4593916f0d3110782f535449d731b43102b9102342159122ba465a098c34c8ba39c0bf515910376fcc31eb3b96be1c22ee6084c422837ea7183cf48a6606caa0d93adcf9a381a1f062126752f6ee0a047f40530041a2eb3be19072011d4d6f75a12273c07360df448ce1779880433d4f5504adf62d70b96588c3a9479f059bec0cfa752da7994b2bbdbaf0658e50f8da107f40fbc83db5eb3950838bd0adbc867c4f82486b723dab473e747d3682c24561f3d5dc6959a8173f15db4939c21b91a504941c35612082350a4dfffc33dd682d9c3b3f447e4bf6b0b8ab553cb5b96bb368cdd1248cc27ff9ac02aedb04bf6f1a94ff2519d30c985382a14a17aaf92b1ef5c6fe20704bfd7a3015cfaacdfc29e1b7a2661aaf9723a3159fead5629526c152555a05b49a75ccfff9a6839ec00f7987792340b69cb6496a5a6d7036ff1cea07e174d258fcf4ab8f29e7b2b9653cc11fc34548afa2baed4e7dffd918617a917f646a5c0d0dd81b5421c46c1f6410afdd34db474f734b3fac08c15e3829230b281aad61dfba1e11eba22017e6d6efee1b9acba646cdd3ad6ce57738dc21b23cae5043e3445c12c5bb6b0b19bedcb9526d65822d4365f9cd418da1abe09d2d9d98df0a6d418125f08f34d79b5f13c52156946fe34b59f6b0c147ca317fe06cf4f963ea3126d608f0df02d708334d7e5086d86bbf0d81e8b7dcc8ce39ca40af6fa1e919717d2a82f918429af04fbb3fc9c299e4ca89fcae11bc43e55453f6ba50ba17940e4facd6fe0b03eac056f6de6d8ec9717433718c9814dd0790109b3d48943212f76e6af5cebce9d3b10bc54512f36bf52af2ae9ef04f71cdd4da2847420dcb6594b9eba6170100de504df5c8c8d1ba1d228f9e5208a8597a9b9c8e8ec9340cfb8eccd1bd53c6f0535e2cbc64f211bc48315091118f56422dd9eed0a3b59151e8af51db941d4e9f2781d43424fe641c5399e9948e008840c9f04f6c037221ce4428fab9561722bf51156ad8f6c63d454334d86c2f9ceda674249249c4f6449c2287b0e82f2b4ed51cb70d01a078fdc863f5cddcc074013442d5eeec4129ff6e44e2e219e6d915fcfc91f53bc02ef36323293b651dc12ff792e56381b2adc90e5882782ed8a54b07385e4f73663b28e8ecb0e06d7cc9b9a62e893526d9b5fc060934617ca0e02d7dffc3b98fde4726a4b04d67dd0acfcf92b0081f764a1dff9a1974ebcc57d8b07d921a340295eb8c9bd249a20a2e4dbff887d72dfbb951099cc075511630062781ed968e227edd09a4cde3439f22cc27e3990a42bf7263a944085f2c86a847a03b261f50c8859fe9a458439049b1c769a81fc2c707681803a94f7ad009fe8bd55e3e9994f4b41e625a76e75656ff91a142df7b61663e5ffe87c438b4de40348f263bd77e9d9be18a8d61cc2568248be6d901b55f18e59ecd11503f2f004153bab698a659213e86c452e83dbce4e1a62afb86dcb90704b71c4c6afc7d8b2e885a2ae8850d30356888f595da31f1d8d301ace3152f9dded945bb8cbdeb2af5aa01d4e3fcb10ebefcae30e9c4a7b848418e133a76b144b02e1ff6920fb145001e880336cce56d7b368278c7feeb81f120d9086d410c748c150eef7dc50bef4830a051b7a8e49b1486a521912d0f4281df08873a09c233c944115df7e66c878db8a665bade5f5a009ff129727f2e0a920255c569b7bbfb4da1aecb95925a9adbcca9e24d42a9acd65abd574bb551435fa792ee3d644064062569f147ea28347923ea75a3bba69d3cd408d76ba4df24cc69043f6f4d130bfc841f4163175867c939e803f42f9d698773105aa775f607bc3b4ebe33cd64f4c1fa848d1f38c23d17843f91952b052765ee505660bc0ce0d47b670d1598233d4fe2cc8ea584813b8dc1610a9809e6e6cd376fbd94569a57c3de0833624cf4f51fa2e82446f124b333cc663b0f2b3342a814a3cdb4ef9f61939cdc5053fbd5de2728192e18ab1a5829c85927ad6c5a712e6c6a8de84c8449894486fd08cf38d9913d763474e87b0169780c92c89a0e2dac47d52096bfec21b004d328117bc27704dd4f843b0246155133c5abd88cd020b8bce6baf69674ce03e4a12139adc4fbebb0e8b058d91e3ed4413b6b7ab13ee9d15be212e6a7f7ec0b1cc8515af67e8a9b782f91043bcf3bf4d0571060ef2d453c83f59537e191aee41d6279268b9024935a71235e5eee314a4636c8c6b8414bc7bd95a71a01d9d5698b82a1128f3944a64d4137c37b6af7b644499f9ca8e9f1ff7717c75a7ca75927bf8b1d89ae7c785ca5b7f083cc50f246f391ad30c6fef737203b7ede2e0c5b2aaf8b7568a9e9f82edd4b5588617cc9c9cd2264214818ba71f089c1c8a9f36ecdf3e8e7a8a184f126a58e3723212fd402ea52d6f6a3e9d228851419e1845a47d55a0ac32f452460fa98266f47f4225f9d70c4d7342c856facd08eb7f479a58b43a4d8058317d747f0a043e8f69f2a01fe12f57d02f7b687b3b10b8989529a61a1d7cf7b2cb6bd6880d0d79dfdeebc8440654d2c46fffe1a0de8c2d6c207709d41e32dc880c86e396157792c62a9da23a05fdda2ba2b7990e9a18a5f5dd90b8b98f654f3885faa64fe3806e0af3c2b272bc0ddb1424afe161262a94b880851a19e7a381597d480c0e550d05b1811c1b6eaea1e077701540b1894dca7041d58c187bccf22e7bab9135077b9dde7daabc2b9f29941273b9f4387880592e50e7449c25d2726bc9bc0429d71cfe5823a8d7181fbb606d786479d805cc6dad948c278f8218a83cb482f97e1bcc729cf840445da14b1512f8585d7c74a5aff19fd4a7296dbd8e331afdc5b66e6a1ca43cb376b1f6e7fbd4ac5923f0f29f9f81cc8f45ccaeae0a456c37e68d21e9e82bf98a57d4116c7fdd5bc60254a763a39ab7a5bf63f2dc635bef68cf30052c00694a18507aaba92bcdf693fc3123b4c5c37f56ea2def5e559278859d0ece50a196e6d2b34822f4ad2d8866bac230916a25cd97237ddf696d759165aa7266b0b56630e2f310cedfaf33de1c03aba036a7c257ae502c25451a9ff0ee7d77c36e922714084acef742e3fc67fa0c48acb97eb60e6c4b30a275add900725ef163f6c3debe4b6b3bcd25570b0b70bb673eca6cc046ca7f9f57647c81a53bfb778e5f76b35e9481ce33cf34fc4ef253d6624601cd70e31e2e100b8f6ca92c52a47c58b7f0eff52b1680e3203554f49ace173a2a9c5706f6cb257bda9de6de79a2c1710b929ba6d3cf848c23852edcf678e4e4a3407fbd3cb654cdc7b9bfd9bf3c317aee69a79c7a1bafdfc8d5dedafb4677b504c7b301d539215b43bcde0a662634c1e34b25ee8183542d1e76a2b04072a0fc5501b4a3c479b2a78cb5fd11869782fcd87ae0bd62747719812b3eb59f4aaf80277736209337d9d4cf1a702e4cc15fa4cc0b302fb5566582f0a7f93cf2350498125b0f1783eafee67bf01a4c4b962d19da7f65c86de6253f4f42c361de33df272f779f9fa24aae6bc18357c27c16c299adae01808d530290024b69de5ae4fa1fba3800b199c3c3241174eefc94f76317afc28fb6cac6cfce38af1286d8ca461c46de70b44a72e9845d00faeaeb79505a1fa45b216f4d721798299ca6b7e7c54f7c5ffbdbcac54974414b1e80fb5a825f05f180c7843e01815564e1241a555395fee70b8bd037d9b2033216afde52cd447b90e741be528fd7843edef72aaf58cf9553e7aabfaa24ad0f1fd5cf4753297636ae85eaf0d515c98940bdb53e0ffe12f00072e89b4c9e8e691c0ac0ec34baef36ce6e77fcf181954ea6b127b342c1bbaa57df4a8e77dbb73acda23c8586e57ed88d47b56dcce0e14325ebaf8ae51f5db96ded75a12d96f907fb918f61e157c39c24d6809d3934830fa3f2b1232a4833707b7f53db8fcc29e79801a203bfa1a062d93293c5994cd8dd5869f9999b5f36b1177bddd4d90258b42fe8edc0d05f37e79cedf102bc3f526bac708aa328292c325143a9bf2e8a02e90c5cb2002033e7c3cf8075e4ae6e9ec6beee11dd2640e8f5ef92eed1acfd65bbec8546cee8e3467250cebb2529835f72a39c04921fe642c04ecbbbb6ee19d6922ef8d21cdb2f38dfe885c2a35163e55e9c1123dda40009e2382b41b30c9986710298619f667431700f7a3c2b7f5ff41fc670cc3f2d42e2041d626878bdf60ab1c95265ba76806114f71149cd2ac49e2014e971f080379b76467a1707bf7d78cebc87b109cd00d157792d913a17076e4b57189c0676639e715ff5a17232d2a44d180d1d2edf208623aa9232f71bda404a1143190644c8118760c08644621866ce054bb98427e52670726932ab36b8d5774b64f3a313fa7ee7773312e1b6738fa1716f76cc73c9f9704e4738c26959e507c3e24d0ea7c6a52406cea10dad7d2716f9cbd65fc9e8a8b6deea16793355a48bb6bbae4713cb8128aef1dbdb22fb828f15b517ffba640e1a7361c141cb6383cc4fad149fcc18620c3eafe4ad10a664d60545a4a1649465eea4fa74b13c99e6c7821f4608f1ea254cacc061674b28fa7981def12d84d81d47f173d1953232a75595010668a50e52b3c5fe4a41fea7e3c8efd5c4f58d89f9015a5b810cf4b8b2eb4ef49806b56b2d387623d7069571c9c092c5a6abb925548a32527873e65c1e2a3e972b4cbd6481e7130e083de094e08bbe12759d6b88aa12bbfa3209eb8dbb102f8e44e9a261cea2081a2f517e98ef5d27d6d9db9c6ab964e782a3babaadc75eeda30628ef45eb532633d2b78b3e46172890d5c44a221062f0d8d73ed2ce5b0b1d9cd2723706b77d35599e171de54377c79b33f01f9ed5d1815935ef9463570645734870523f7b0c11f803bccc24fba26e9bcc8455016df07091e04ab91d9ae25e3f87626a1cc5cb20368ccd3e30de65a6ece45c653f3f3673b3344a93b1cbfc06600ed9d2c607ca4fefdf6fab4d112e8baab18484f5589360b16d7e7b53700a5b1608d4be3359f50d915b8f452a9a77e17ec4403f92f274b10e833c113c5821701573e1c5b8b4c1b0aa7b0dceca1a0eb2e79bee0fb4d8eb5a106d0250123163dd1c7dbbc262202968065c9b0394432fb0cceb2fdcabf6cdcb4bbb5b2c154f6f040c93a4b99c74dab82bd67ee1811848be6e332b5761630a89e027cb154a35231b091cfa640515e3cb8af02f3a3a570c640553b2d16aec110b367da26a39e3feced83a9e0351fda67316a383fc7d8099119a9f2653fc8c025074fd99019f7191fb388dd0ae910a3863b75ba9b82be2e27f1778fcf4948cc1fc5c1158582083d02686b47cad179a3761a67549355af254959e1bceff653c7a9cfb51aae1124fe36a83178e81134cfc78045e6a6b0b64c9637143af727023813d1ae666d134f946f7c09bc472642801af110d7bcaac7db7762b2fa39c8cec34762f2c26585338bbba8fc83ac22d11b873a1300af1a67f66956a096df321ba3bb1c5375f38fba4f0a58c454f2d425f1e86ac828d5412327b468392bddb96759e40dea90baaa30722df17252d6a71d21bec20138dffc3f920336c9fc8a06046ee28791cc2b232808837ae36d3d3f0dbcfab311224cb7b04aa1bbba427cf0a657682a489d4b478eb7cbcf019708a4d045173aa0f85079ad6b2a6a77fec52db358da44baaade8ba2da17c0cea2d93cd04acdfc399a8bda8d6208bd46809aeb2c917ce2882fb744f6dc4fde616a36cbd8eed96c42329d84b503dfa62417a3260aba22101074f863ec836c7d39b01fa647a608ff54d4b038384cde7bd161ee7b0d2b7f848956d6d138cfa5a96ea9760faf1abd6e782ea907a0e4385686860c3e48bf55b0ce8597402e4ce092a666000a864e6186709864370f4c74d5b5bd1ea4b16409069c35e95bdb5570f1a0007091f5e597cfb3275e8bf73286dcb4a83da2072b1134187a9a27c7cbdb5904f59b674801ea3c3a1489b03f448d7db2fd5ac56071a8049df145a7c5d7fbcbe682f5031d7510290de86173da19e0ccba0784e7fabc83707e0fca4b3dd4d6e73db18380bc0fc449165fdc5c4de1e2341acc39ad0b58d5b647e85e5afc6ac24762e0051ab55a5bc931172535237c3601889ddf4709286343174c40fff33deca5f8ea48a4cd0314ef0ff3fe8290d14576fcf4eb9c1af364bcc66b9a852acfd11d746a73d159d8db106851183c663911c0e397cb4734207e985fa7138e07322c20adbdb20f42f9744aaa7dfe191efa2c8ad11508c0caabdd1a593d260663687eaa081fdd9a5dfc9f3e4f9f11cbba5bcd41587c14d13ec8a85d2d0bb7a728f526aa741028e08b14ba06c6606f013b170d92455dca5f9a2a096f9018517ecd5a877fdb1413783b9f87d1012e5b811b00d7dee36542ddb90ebfd1d11f56558488b5aceedf83b089413eb906f5a1291eeddda350cd4c747d1eab371d589d793ce038fbd729db28449ee23fcfb846bf729b36448731c2f42f49e2bb2b3a827c9a82fd6cc424caefa5cbae8aeddc39f8688846c414ab76064c5a70ce71306142aa324cdc4859dae007929a9061c27e4af1736b1d932854e29579a0fc13da3b9edb25acc571821470d954fd520de48c2c0161f89d636d82bd8ca249d1be4c234e325e7b877d40bb2fd1ff9f3719cbeaeaaafe42aa53fe0693038dc4f18a119205455fb0bed7d2c5fc69a48c2122ced2184de005a97bf1edd137c078131de9506311714290bac41b38377b4ee95b50abe881d2c18bd2695fe653c7a40591628a357efeee64c4404321376888209555fbaeeb091e9bbc07de5f7aeaf1e29123d8b39f92a04a38e7524e5f9a644fd61e3a471170fdd2c8bfca3c41ab84b234df0e7576b23e1cbc3d1c775bad76d3543a7773ff631bdbf054d2aa5f54552a178299346b62dbf71db09c6d59e4649c585518355be3fd064b07fc1906818eaf72f88302a3704aadc92a532986e8da43f3191bcc1fc0cb88d990a8800e74ce436c2d1bc3a6b4003559c7784877a4a00f7c26823261a7d1bf90d9c47c118ffac55342e985a24402095f6ec2fa62c6146a5cb85305ec69d629047f696e0d217bc21d6f87cb3caf299d1b640e70490a3d2968a8908bb13e322a3e4e57b27524bbd31770aac6af477def78f958ae9f4d356dfddb64075fc22aa4f9c63c5fd85bdd0b782d18d0a4397d0ed3b712e89c7879e6816bd3c2204db501b51abe562b0f795b4310b7d3a7f09b46ab6c7d4778079983d82a954a1afa62b8b1aeea9ee66810723c9c9d3d31b5d7c6e4f994d78a251e21765a78ac00b199c81518280bd3731b985c7e9e88844d42432bad6d95703a185d6046d29a2487da0ea05259603d6698927e5b204a242050626c22682690c042af6e5a0bb40392f0315cbe630e8ea0cf58a8894d24872056e8975d0f53e720386aa266a913044f34c5a912ce382942b77768749c7708aa67266dca86f9b7bdf990ff3d46bf491dbfc5ea088a2620119a27c7e628f2585fb72674703855823414cb9ba010e94ea7d37551d43d1f120ebb3653701ce67e804c7155d5f2eb07d9c2fbe4db00ffb419708ff31e2bbb761621012cb4040ba5ed7d302aa11e1b9879afb815af8d79209d6e1a9ca816103c0f5e635d52dc15dffe44ef40a269aa6a3c7e1e728532498466e6c5ff400834f4709f670d9a28ec22cf13e65abd681b89e13d0a0a0b820105f8be74c320f7e4ab921a9c38153b4e727c5bc06ca9d1119918fdb7813a9502d566d476f546d59972f2bf4533bd2cd8965f010d561e002cab88855b135277234392c2d085920302f4bca4cd45b5b1bed01bd1c08c03cdca803fe1de5f8f65ec1e82cf9443a9f3041a4887dc0503c64e42e3a3f0db923110a2de0a9229de4ba576335602597bb8366169a6d576f9000d1c85eb7acf9cc2e3d423cf28f56b4ee3ffc4c72b0918a6eca39ed6bde5ac1a451bddfddbd096c48db9921d858d1f3f63c6d4ecfdc292e4c1cbdbd9848561d6332bc25aa1f17aa76aae9e154f53f6fe4fa8dd5e642e2c7c45a42abd09c93b7f273b812e7503547cc426065032f4fb7d6fccc9dab2dc4efa6832e04052a3f9ea8d7dc4d38644a1a63658b5ab9d7eef8bdcbb22e779f1f87a4bbdcfc53b3585167666e9a6030dddfb8cbdf383d698bd0e98fbe601f0f406c55ec2784552eef20aff4d72cbd942d7ff42390dc4ac8cbb725d88687698901a51a830e698fad308eaca17cb0453cb86921d04b0c972e522bcbe45cd9216fbd5ff1f13eabc0b75d20842126b7ba08d6f4ac27368b633ad10184dee63f1f0a9337cfb45abec4e9443dbb697947f1b27fe97a5e64403a939bc2414fe774e942f5067c2a36663ab966291ee3241da07a944301f186d123c75bf6981988fb4feeea46920704bdda84e9c56758c3328e93fe89be486937511f8ee3f6333f409561b2ff9e8c0292cc182828cbcccdbddcee2f415558f88f8903c53fe824b96aba96e4f940cf1f81dac80c7719411c003a13bdd9496a8839dbfc5b5502215696ed1ae4f525601b8561a5026a4d0f4ed11c226c378cd5b0548cc9b0c2c5401dbd20053dd2b516af93cf3052921bb9e935045db8050105b59922a8f255ada5db458d3cb43191e4b2b44072fccafd5a131f60ac476e349643f5d44cfdf502a79f443e6adf334a854ee248adeb928ab063717dd8dc5798bafddcd6fc86d17c9cf0c659dad0eeb61db9978433b5a4999df91957cc6583a741266254cd1fcadafe4b6e518a9629385d090ab1b881902fa82eb320e3ecfa44ff2787610ce1da62089158fd058e0ba666275bc95297901b5426dfcc40bf6bfb635a527894cc3a3e27e58732e155c11a1c1197a5480a6f3560a1bd0dde584b577c3e77f31b9aa12d6d9e36c5c657d6f14e186c3b8ee0055757ace498e4dc895763417da7517570c512ff50c614f635844b780622945cd1feb954963e88b9b354bb2859bec609d542b5b6ea7c6fd166f33c0c92f70ea2a41bea7743bcaca6d7cc4fee10b1d818ba246bbd153e89690a4af99977e50f0763b07d437d01396f7213c8ea51c33db994ebfc2ff44a4fb3702ac1c524edfe64c48e1ef6f9b94e5858ea0e5918c3c5f48d1bd8e8c2c5ed4403ffd74f53010f85287e9bbd65943c7fec23f17c8dc72d792446c953fd64e770092bcb2b1a8f7b3fa5d79dfa908a8a5ef208987eb0c2cb3b4eab817a88026d39d6e96e2d26ebe90be4bb3e8ecd7663bef19fac3e167d11205c6e2d58d1b00139769fdb4bc728d443d81e4a7e68cc5b26223aebca2648d9c95caa6b2bd2d9289a8062704278f1ac45599b3500e00e0862de0015e14469ea85ab613360d3541b13ae5fc7edd4a1450fdbd10ef62c54158747ef4204514a1ad32cb5d07860c3ed7bde71a60a20e22ba0b6c10a80705975f61c3344a04d9769b192b49a742e065edde13fdca4e693a247b401790d66676b9e324497d9a753fd415570c4dba2baffca45cb9e61b33a447207e6a243f5d66f22a945170900b2f0fe78d5319689a0a91c85caab0eea867892de6276cf305518e80c81584a2dc3b58e7638efe45f88f91f1d917d0eeda2ab5f4224933e75d5a6929ca1a899f6cfced5e26b687c40e628f80ca6e26669318de8799782d965121634c4a09d352f4b092dd76718a0f438fbb2966bff76412e1fad0ffe20d61ed07fb6e02bb3778f06b7401895e2d5a9c9f9d3d964b3fdadb1d89be13259164aa1413dc721a7619a3187267d7948688d5e7b588802ec623c16f3f28d443aa829d367d67f3a307fa14d2193f49ab70832a332d7926e24f3f000f7f35e4c59ffa53f2d0b5fd0d02d87d64789efca912f9d2c8ea8809da690f60d3257309aa0cbb4d479e2bd30b14461df63baa999f81109f9c41bf943f9a18e994619a9e965a9f7de9147be87ea435c1455a52f58375fbe552a7870f751b7368b2aad08c916186031aa20bc91509a924b1971d2ade2ef6563a015e9cf3db716e6de0dadbfea3a1d97665718f9d692e102c19e2eaf6dd3f0729f8117458c02560bfb7b72ab80f8453f4bea725e5876c3659cd50b889b357bad62381c63f8c4770d80dd633409508a6debe063953f9bf3c7ec773cf40d7946aaabe42e3c62f65e4b4d8298e5375a6d5eba0bc1ad46f764c35ad90ff95a8637c18fea6d011697e4e3a8fb2ab5ff35a7059f005a843b78350188600ea7671a06a5c74806c9bbb4bbbd0a67e395f5d4c12c21eb760478d819c40c01e3b67e0a86246a553c03963f6c003c240396831e824c01d7d7f525d9195f643f03f30569234836b589c1d5f561dd884b3a54aa00558b67173849ecc06608fed510a21e9552a2854ea35f0d1a40c388eda75a482aa5ea0feae0c32ef7bdb9cc12005cd9288d90247339c677db15a53e055ef092afcd114f76296ab703067aeb022cbd6dcad36a1a208097a13132fdb994c5e47546f696bbdc876c3f492abf66e96fa6f0e5837a572c1b4a1ccc2f316bc95b0473d94f6d531dad99a6aca517f237aa97258d1845d867a8183d6a834a13d77c49e5ccbc0f63fcb663d04ba13667410f7534e01e231fa2b1cd71ebb9618fd543a68cfe623bc51b939abbd4acc3b18cf354037aeade0da6b1a24c121d5890aca6cec67ed058e4df7b55418d2f83257d217a839a95a142b14dbc7d562083edb66dd5b8c4244dec3c74dda39363d92c4e2f4e635c271cb2f180f1824b46cb92066f35995bc789046bc2b53b40fb81d3d395f416f2f37e6a1d9ab08455fdd084c0b558546014de5c116e002807bd4785b84e19b95c47d7b8c5d0839d1532e971f176c43c7bdc42ae826b99c5c347d295d0797e77d43f0865665fa5e9c66ed7aa9370537cb29b3cbafe6bdf69ba37307052b2dc0eacca86591ed303dbd8dbb32a2486a2c50a0abfb72bcbc8d357cf2e456163910f37f4e867620c3eeee630a92f3ff1845ba380657041102afeaf80748504dd6e5afefbd552d29f525ee7d77423460438579fe0f77480d26cf569b4a1d4853ebf01dd5a76ede181ec3db12d117af81491d79741475158157b894f8ef573d58f2a024a3c0322ae589164c7304438e2de617a7d38662ef4322dba29edd08a4ef45643cd6819c348702c6062194969d86884ccf62a4e8299388442b0c574ca33659c2139e4a998dbcb03000428e111d23acaefe7818f17ccd8c2015cb798a5e655249571948cfc43fbb504e4eaf0a2aca52aa48f914cbeb35e3cbc4a371085c41739ad3c0b1c13557a95634ce12cc5fff2b12657463290fc2955489de027eb9c5d1a6ea58a1de42e4af9dc4c445b9487b8e8cd995bf7dd89325d3b03758b1c5ba9ee230ffb458f15f04db5bc342604f70b68109ef20f7063c468feb0d3648b283af8b46340965ed29d283f135bb8da1fc25c90746109a90eede945e0b02d8d2c9ed78fa2f441b42073fb1615a98ae79f2ae56b57c19030854361bda0fd8f306b78f860636290d851c9397c89f2f6bd0357f2b285e4700aafcaa3a62e7604adad9958714bcd5ee624870da9a5dc17dcea6b064236eccc97119a03431e4b05833ca509c0a41dda5d8b71ada9e234a9c699367d45632d09047e9d7a9713c720a794c7232bdb0062a72b7c37528c99e3898a5de2889760d9c78e108904f613ac93dcf78096e5918c5c3574e67cab4f5d6b0352f2c1f6fe35c1b7a3187211a78d077727207c22a50f684fd60371623818704470a0e0447535788563141f3f07490c04ab8b76d133035907c19494620937561a13a4a8dba3130beb7068bf0ccab835046a0c8510e93c98508415733dcf53c62d19ec2fb37baf4611cbf485ea58f2fe81457a7bfb1a94c994e04e869a39a5d13e2fbdb7d0eb74d20a6a051f3e982803794f8a0d626b4ad732d77fa1621cf64bf0f757106694d7eed70dcc58a33d19d72b5dfa5560839d79caccf5443ec491e5ce5947be6d8f031dad7898451131c8362eb4bd3385c8a043458b4e9f8e8889e63aef3ea7a428d7467a459d1d07e756df111f1759126fa8c3b336349449d998b63ba517a768f8e70a866ccfd387e9f6adcab793fa4890e0750a57407ac7f217d4dc31527af4b6a5ca6d520a691b98025cefe9a7f7d035a592f271649f4e118ed65914ee4a74a721ed3b3486b1d3306a5b3a5703e8f95630d7087d2cd7b597a62e482f30a05c9faff8f87d60654ba3c0f12be12cde1de07dfa39a402c907ea5cdbf00870df4071d2624263f59504648840554efd4ee5e02ee3eed920b2cf97f2f922aa2aa4d36c54efede717414fb67422732e5aafcb571344d172c180142faafe882b256c5911aaa1054149b1044f51c3bdfb5ccff217f931f4bfcbd240ae44aab432a46ff7effe30109f39196b859c23e53e94026bda126a5622f8c05272b1169477d8519a5037299e9da29c1592477639093eddc9d9f70e542d0a89872cfb0af7464e8f3ab74b22c198ceddabe881449caa8dc8984812629b729e30eb84edbee0d7cf7b975d58afe5a7e1b9cb3007cc6b8bad8ca6abc5d6c942db414842664bf3bd22d7d57e6a99877f60295d333adb88ae0ddce056433bd05057ba18171d7771073d9b981ba6020467521da54203df8e365d0615816b006e162d795a873e67872ca9e589a525d944cf8c8efbcb638f90bf3abd52cf96594ad45dfd1b300ce1c754f6c135857b56429f243db0f404e61b68a256b3605340061d1d00558221717c1a700693f409b835ad9b675034023fae93ad6c23bc6cb0bde2ef9c636316a9f917557a93c109db9ef09a905ae89a3ae02a56496354837728e5bcb1ccce342199de4a70d070f6c3307829f96dd8e68f7c42b17148dfca4d93155f51c84f8fdc37df538dc9e692b8f2297561517293ad21b38b1108953f0ea762948e40d957c522f309a500701cb8efb26edf81bd9ecee7f8d0f133128a912fa9797c9cfe91902a41afac130ce6d9aecd692f848a53c7ef516efa9b4c4f588a309a597dd232eb63a19d43953c38181384f6203a720ba36d17dad1bd4e512b6979725e588393896a42f0b2eabe56e9f3fd1b3a068bd4104b07e5337ccb0a24b08fab7f43ca942d799958761fc418d99f8ff86c4cf22aba24fa03bf3ade120d10453b5ae642cbb6d462ab7d8213d124449b3a8b5cf4b4bebc657d9e537864ffef77288551b0aa405b9709f548335612591802f5cfe9cdc6236f12bf4a27059c3c8037c7c4cff7b3b135045268070cc5b9bea0b59322d8dc46d832932c298a7cbe63b9efb94ddeca61dbb901fd0b4bc8b0b91559cf707f2f57e6820e45ab840466101f3e54bc05c6e3e06777634128a2bf808245fafb5f935e052e599df0e333b1c0998215ae8e24209415291a9f6a1d7efb34c16f529ad40f68cf56e01e4794dc8f1a79ebc339930f24e21e6fe57e2429a4df267bcffc1f265813d87313af63dc156283e6ce37aca6f230c075013d2f88fed5ed970b73867a577b5d51868ba593f7c56f3e2692092101a8b9887079c558f8acd1f080cddc3ced782ce2f417b5d11ddc6d8ee1368117667ffa54f79319091f944813b1b94c92287cd926aabe1fa2372850a82a8099a9c9325233cff68ae3cc80a30f641415c91d5df62e0888e26711f180288674441eb27fb5e8e740010ff318a7c4ac9418c11b07eacf542aa84d4028b81f26d9f88d9701daf1e690b6245cf375e9e90f2629605d2a01f453e3955ed15624c2fc93e5a75c265dcd186990ce34d3f9933ca9996eecf83be171208fada30c9e7cfa442393010463adf9658fc6bd9489e638b7bb6796ecabc199e83668b65a98bad5f60470b61681debdfb789d8bfc92f84f4759a07e3154cbd9342778e193eac4fdd9e4d422412d72c4d2eaa07021697cb5e696ce2d0b7a550032de13cd3d2703ee9581604b9556c626f9c7c5a5f7a02cf8abc8c3c989395cb48859559a4571a0803e4677d19364bbf841b6a3d2244978a1a657e3bcbfa4def5b86a9b8958912daead36294f985bbd152914cb03e07cc3fd170b288f8d3fce68efa4fdb6aa17c79279f5a382cc777d04a8a3b52bb9920615553331301e1e0009a421ceacfd016f2499f5e0f7348582ecfab93205c27a1f8f56349b2999873a78205d7315c33fcae83f1363a5348a09835cf6b3b755b4bb2f47cb3ed0191896c7ac3aea2101b757a6b7720ee7ebc2dda86a89e3b5b80cbe297cdbf119e0279a407b6b710720a26bbe27a53b84e5e56e33016cfc913a2413e1c7015885af5d85aaf9e5ecfa959227d5d429777edc154af38f7f7f094fdb9b9fc7c8cd312cab97763ef18ffc16c5d7b5d6e09037c4a387948bdf5dc1444b5e965f46a2839fd1cb835c2a6fabd23726dd4ae5b4a7137d0343763f0c4db79f9b77888dd53cda543a04d9fba99f6635323058f977e18ef5feab406133e832f7f44c66a2d4639a111e1b0e709c7b2de6c3ccefd6e5c218648b8326cd791c9b684519d078acd64dedcc30767ba8cf5a5a789eb1874e9ba0749ac0c3daec4e183e6f7ad833d57fa6c1668c5b01fb037a977bf2700d5ef802edb9931dabaec6827e2fbf9d6de05ec60f8598f36f2b028ff94573197ba98cbc2346ffc506dbd10d4c6ac91911708330f6d0297e91f28f77d7e5f68e5a754f3f9e83154b1596758f3343df69ccd3080ae2ba792829a1a8eeda79b2f058a1dabeea3376a76db87671f53260488085359d3f8a965be3d10422aba2089d10c9ad564031809fbb3d622769ac41139d25f087ab663a5d5cd9b668becf86a26f90072d903527a275ce14e17d92f8a0562b8476fe9f761b1507ab2d54f90ab427f75563d61ae223f4f1425510e080c9cbe59c82bae3352f99937e187a321f5d679e48c4488a88359ff337cb87dcd89fa3f450ad3ee382a376f1140166caae6f7dcd5b6121257daf4cdfdc3d7a81d324a7749f06fc2295cbf025bdf3c1a38f9bec313d02848e77ef56f9d25a15135f0ea67200f126e78832436beba46787e8fc11c4b2fd301d379eeda9f908629ab96945c5ef33e114b9279678e48e8d69c54624da626111f540301cc9d9c98ce6946ea4dd4cf92ce9bf876445c9e911bbd4cdcf052b716642efd99322a924f41def543bb454a0cb7280ab2399dcdb3dcc2dfc5239c54b8789e38fe20737acba06e78804bb6da0598d4649a9cdc1568b9fe4648bb0a129519baf167f9fc36ddf3e8e05607939f0ddf61ceb32a0bc31b2c6f15f63aedef840b8817228698e25d130459961fdcf936e29ba08e74642a81ddf1cf05a5357e5662e78b4a7d32249b3f323f1dc6138a5e6637856fbc9feb82578dd35d0594a436526450d7393123f9d2bac6a6d1ab5279ca585aa736a11c3a63f16f1adb27de253a5e3ce72716e35e5786897d4150fc2867292c7d126a2fa1525d2f762d66dc3217a9d9d4775b135f021c79420ef4103263840a576b9b38fb6cab181620009fa68389a98c8187133df70386cb1672b029a6261028c2a1eebf317088d1e5833de5e0c381abe7c698cc91f395faf9642d13458e8a65de327333702ba8e01056832a5d443403c81ab53c6028ddb9ced9d507e53142689a6cccf4fcdbfa82de2ef134b4bc269499764a0dc746689a83c4ddb84260184ef7728a252397a63ee5acabdf4f7412b27c613e495b676d60553cc32632e7fdc01810e032665019bf874c512ecec4c38a0a9d41b6134a665892a3985ff2cf53ae1be5e8f700cb4f824f7718f2912856cb38ad9788b298711b27ada7fdb753adaea6eb59f0c02cfeadd46df4d0d226f6431a27b61192bc43fa07aee699120b435e9cf1296d4fbde29e1ecee287fd8486c14966f5e5b7de3577ffbbf04bc37e410e45d9c13a350aea0cc5265bb6108661f477a95a9b142871851f3214a893d0238f0a12c9149af04498b6a0d3226f7a5e3f59747a353985ac2cdb5806bd8d91fcd6f24542cd4ab41d167864465eec30c09a90b27275e24fce37bbe7490ad3417371aeef6f239f1958b7c31c7650e49f3ed34154ecbd488ce3c0a89f4598a877ee2c69590750b734e099ac833a5ac01216f5bf22fb5cd1aa24e5febb4ad9459d092b40e92ad54c411ad4c22e74f889fa4943781eb635e58f68a4ce639a392f67651bc09aa0aae0566b718a49df8b418a4fc5bea4faefdc68db44cb8c3bd616a6936544e41fa3a76312570cd9c67ab1f12bcaf867c3ffaf7f013aefe33c8baae2852dc2838c5ba86a2e8f71e882cf6ae29cf5d8ff67d32500f0e4994953e708c9234512ba85657acb9d462a0ba05ea9d820def03ac9742b069b79497f0fc3e7672a5a2d288c5334e1830e3a358f93789026ed7e573994bf62b3244a8f66ff8ea0cc57cda2955cbe6e45bd616a7b485670d50166f4ed4049da5bbbd58a70bfafb5493bae9047bb0d61a2531f85cba11c13f89f5c127bee24eb49cacb32efc40d8d6d92f27b81f61daf85c62bf42731e20555aa86e56acbd4ec059b794cbecbce68740d445ce89d21ad18ae7493cd43ba43faa010ffe2eb9025fc96fc8af0888d4ab399106a5e4619565c0b3799ccf768aa2caf483640eae4129dbbd55f2a92a87a5bccaa0f920b2c29857d0cbb63b6844ed15e525da1721851a530940f6b38fe7570462098bc898451bd25ac53e16078f8ab344fb278f81fe6fb13f76af8e0cb779247fa2e27d014da6a616d56d77093579124cd56f70cb456dfee8beb9959b0e31e0417e72e8f03a72b8844eaab4fa9eac587776e0318595072a7c8b2b3afb3e3c8732440465fd043e92ea307dd79529f0fe16435209cb182c381f1590da78716932f71255312426cefc5f1a39012a300750a1c9eb43f0062dcbaedd0996a6d70545b0d04021769982988484b9ef1ab1a949bbac21d2d2d3c335a4b2fe920ed2ab685f8b17a5b361841f76a0e23f44cb83c78f64057316d81039523b5ac9dbe095e568672771aec1432bb3e4ab2286ebf4036139332edf7fb9bdcb65e21ee3af92af1310c3a2238befe86139b8d6ac067d8729e3c44a1559ec8856426918c531a3c32227dd24ea0385f2edd6db3161e3755754001c18dc11602d5014982b832c1e242c003d3dbc3192cd3183768a696a7a4730f722569840e2285103388323c381531481747e9ffc444f37fcbfa09d4bfc5ca9502a41f8367b3ea4a40035f0159f3182fa5cdc4489ec4e5cb94ed4d68b0b6224061962d379b0a807ea3d94b3359de8eda41458617f0461caf626dc08556ba8f95faa59ccbe1c2373ff4ea802bf9c1754a22d862185c250eaf36e67c4091ba948c73543d32bd8a8a6dc00e20a65fbe4dbda7294020176122a7b4a391688f567ae422cab853e2d58fd6a5c167bf0cdd32351671e1cfba54c975b18b3bd47428d21a980215b9c90f879ff40688af27d524321a52b8df6adb875fd15f65e4bfd9c9880d3d5278ab7cdb0304a6b7d046938a187553a04a8a29de74846e0e32d88e2024fddd7ab9f38424913b7b7999b959160b13297f2232a3a1cc378f7d89f421196a38f1e940244514b844a277f063c643af300d6c118316aa1f0b46f74839b3875c843ac1a61e5f26c2b49998697028c0b8f5b52b0200a101948b310c8a254998b987ab81afc4f0266cd48a06c6f68e41012ea042d9547b33eb0f164fe4376390fcd0ec3c1fb6c576601c72b81ae876ce26d21a55700b096cbd96b15397","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
