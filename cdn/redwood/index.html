<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"12d9ae1de52228bf5df6e4c83ed55449893a1468a985bbe739dc0582705ef28a9319b29a9631050a1d9a07bbc03f31ec24f564ccfe1f94531d0cd7a8ae39ee5fbf0ec67a790def1ac3cb9d22758f859a738dd28b6d9b138e9d838a6a4f836e9daddbc50245e0de1cb1496d0c89adb2cf16fde3b8d0e0fe656d43bca2aeab1e62dff921b659b30a0c79fc6b2fef3b50ac5e5a89b5ad8238fae5138fe83bfc4e29cad3d476e76457d55e18c3f9f7c38022576b43a6d660d5c23ed7354232a2de2e92b40705b02a6d033d6bd12a537954a30cd13b2c5ad4b190d68ec7acf45ed87aa40f70860fcc830b5253f45f78adff7d96b6ae53e47d20e7071f8644ce5e5b7f33121790bb644d818e419b6d7f27c695a26ecb63e4d46997486ec88f876df7466cbb747c8085d0d12f92364d5075500112ae8f493cc422d83ca6da0906c8e3fe1f2e1492f9bc8304dfa4297a40157ef8d049df3b38b2e8a2fb2226593ebc2f31a100371d0e02f3f7fe61350ce17cb62c3f621044f62132c595f1feeb9eeaf4e9eb59f6267b7ae5598141ff446dadd4b0898510a87bc169a050631a689d6d1672d03cc5db124b52529bc08cd6b79144cb463d03aaac2a9fa2bc24cd8474f5f38fbfd8d45ba42b5c45ffcb89f216e4215c28c7b0f31a03566a79e4b92421d99a37833dbe6d9507732cecfb84aa46c6fed03fa8216e4c5d3f94b2f9a38e9dca2dffa7997d4aba21a0d73ffd9bacd523d99cca677dd4c8c4b502c55f8fb38aa558693475042425a6fc1dd9549520d27f20e2b879cdc7c9c38d4f79223f423e6e125bb80fee8f0be276c6426f573bcb88fdcab27ca6a8a42535200d134c3891db878e3b6c013d316703f97ac1e2a22401ad99ad2dd8de571721ac504430a1eb3f6271cc9f043923c1b67dd9b24b118cf3c589f5a5199ce17b2ec9833aa3cc1abc0b26ff107e1323cb1a25c65d41d54482f36dc5a302b4a89517bc87337986899f7db2f38dd2913108daf82ca2c8576f9c2a824d3d619a0a74b3964a3cf5be888c8b568926efbab4924c1b6381e6fc3d177130cd0947720e12305ddb30c12ba2b5c3f1744947f98a1883456f368b496838b4cea98e1cab2d7bf5dda9eb4c03e2a1058317a52a13a4206418cf949cfcd13978f310e3fd5d9bc335d99a135618ad516fc44bab84796a33c3fe85e396dacedb6120100d4c5de68a16e30d42ced882f028b76c07884c494703d7aca22518ccdce6e14263c6fa7b2f82e27329c826d65b4e2061bd30fca2da05ec73f09ae94b71f349dc0c970bb68f591f7d82fba5b4dd83aac55df8b0bb01a8286e7e7428afd85cfece4e03621907149ee56b44f0a83b0732c495d02f1555502bb759de3bf0864b79da33849537cf45f4dde4e7a24e8624c03ca159ecd0f1ea4714b4bf5a7e30c6367cadd79afd732b45769612e3b422e6d694d83a3dd91dba3362bbfeea34a44e30b8f8b820ef0e051036bef374a053bf09cf08de038d0a5a363549a59847f1f9e91687d81c15f7c521e84f45e19929c9b9ef1d1589c67c050174fc301d47353678295fbcf777a083a8d9372df5bcb3b55508d310b302f8556546dfb5bf4d05bfa67f46cb59f819368d85fd6e438c061de22c113fa3868d870c3c4b43dbd241f2b15f3dbf197ab709d07cfbf83a5da1d727e91d62f3a64f5c4d7bfe7497e89b9605e1b6b2797615fe389cb766816fbb108124384d2077bf25f4913b773ab798f5d208a36aecbda8b80121d224c0531bb58f8860d55746e66c04c0018aaddd7c6bf208ff64aa59ae4c22516f72af645a68f1e9d92cdcfe2cde9ca0a04c8728ef1d822c28d3367e91f621cfcc77b4d61789355fc6f1c0c6a8f224e3f8eb1297a5447a137149ddfa9b330a142ae9b17375ab1ccf32eacdecdf8fe6b45184fe2668a043930700a3619bd9e7c118e822de1ec976cfddbd2e8cf337000db596c83ee0db2e560a9a1a6f0f5d303a95992bb3e50d4adb337e840c6e05425e44754b602abf7bff3363277d3115551524668f7e6e2c4ebcbdef5a33d1514a554dac3d7caf0fb0566155cdf9f3c7d3596cb6155a86acfd7de81eb936fd5319ace7f15a18467b9100a6b819c59469e3e0525a9f19a28808c3c6b58a7ca11b022497429c951cba184126e69aaf5eb5369570ac039e9fed8d3e90430d2cdd53cdc0a4bd266eba8fc6cbcfe3d014709e8aa055a517a20d11aaad90458df2ba97cf5cd538653422e99ada73fc515ef14dc4771cc5a3f9c2ed0c130565befcb91ea12dc8eb601aa590103be810c17eb067b0b879b78ac9d01cf7738082aefcf111d45bc12e1244029564e1542997ace33ef91acd4264820b22b5fbc762be489241f41ce4b00ea86e0db11fc10f6fb3a24380e80f88a88a48f76e642e411bf02e57a8b5d43c6ba9b112571ad4f95f906e33ef8a3983eee2471d12af7824d7b36ce6fb5decca61e9436c41cb9853221bff63910279ce959d7f2033a02ccd3b6e7c732f83e6fdadcd3b4f04a22639520fb3dbae1528d37166cfa40000e05c31ea0af3f26ac4b288fc73a46decdd02fff6b61780545360ac25f01aab0c998104acb1c433af79578a1501e9ab4ac2e7ad1433aaf9e49b70d6e8b7f6a29eb75546bcc14bda56b97a07450a0e0cd1d9528729491d084eb841b49b4a87eff27479ae4d0778c4a32c03b9fb374ff0432365c91748406a36cced28f4d294fda523bb61beb0d7ef30850a07391bc90536156a6e17d64a9358122d8577604e451d83cffeef24d1dda42cc1f86e1adabd66583245e13b4bc1b20e2079659c75d08cd67728ba91cbd739a9b983cf44b5df70f2bfd2087024196c2f2a830889b594d5ff40ef0274395800f82db08040d263d2dd901c5d8ea2cff85381e6e3912e8b0b46a87b0155903f826385b199b203d13ac30e5ccd2091acc73320d7d0029a5813403bd23827c46100f1260847ab395d1a0de6f48c0d64b8a5fa776bd97807f430c41c477b4dc1fd9e7a6faf74b18a3b15e34b8d33360029ddc813d2c775275c26fe28e607ee37dbc73af3eada5ff795e5b933c596a6bbde6096bbfcce6e67222c7a8a80fecb48f5d0e5f34f703877eb7133088c2ff39f431cec83990646e99fa52dc7c71b9ba16d493e4044f544078ee785e95b9de13942c265c12627271a5ed6cb9cf782ba20de9589ee7e0fef54f0461a1fdb71de97a357182ef256e15ce922acfa29e1ec793172d9f45c26b7a29140adc8105849025324989a0b8e5c0c0b58b455075b86f922dd8a32bf43d0e0b5ca0eef3bf09122177c2a3dcb7af02963499653f3067dddd403319cf9aad8d2c9c5d24ad930ffbea0f9244e6e83adae7e45156ffda09fae967d49ebbf6c12b57e5b64d79b31d4a7b86d9a9d6082deda660d48782e41896b71d579c59371b58660b6a2675c68295a00fd779de2c37cd88b2153777aca7f20aea2280cba30298b6a323e0729abebc0a7015e2542968ad38ea5f39e3ceb73e3283f30f4f0ce9ff3c7ad02e74dea6ec8089153b6133c2c8d25560dcf0c4813e571c640de1dc3bf19dec7d6e20dbdfab0116c63bf70bf56a4acfced3968dee89311a737619b927f24d27235fab6489a47a387f45fae028b672c10b368a0fe3c0970d1011f25c4e78087346c31c89990a62c7c04be726aa2a4cf026c1f66c66c24d92b5ba51ff31e6745d952ad7666ef3e9a498da11cf2e7ea3e4e182c7f637d80c5ee6eeeca8881ababa0b9ab79ada84fde998bcd4cbcd93f9a648a76b78d3feb8372425bdefbee73b1d1d8960a66edc66c448c7e0f2d9cf840de52bd04d92cfe6c261ad58db10ccacb7472022b0e65c7efabeb6d9499ae563c33615cc06d2078c22c3d046d9683e4b0ccf5d4498b34bbb44b15d9c57730ae62c5c53dcc9ce618a1470b3603e60bff32855d95b881e7fd2a0a174d76dbb64de48a7a30ececfb13fea09dc17f38295962682caa85802f2aaa0d049821add2a06bd8ec26c21fa383ee51a286ff57d85fbb0735e974b18cfca99ed6b72dcadec7f11c4ed47e46ec3d2d4aa89053ac4fc749f9952e68f88241f41ee4533ea642d235075b93d6630b248b284f823bdc9142ec183e2f886dbb7dc39ad0ac34a5e3bf41c4fb3850015547e93826fd04098ce6091fb637be3ef94ef939465cf5b0848f0ddc3792ba9d58d958a772f2b25da3d78c3fb7d51a1ab631d1cb2f6d4b4698cf5a5846d09114fe890a3a91d43c4f817a386f8e17fe103eb4e9887fc204c8ebff607f94ff45512d09a0252bd233321c73875a3ced5d3025aaa994b7119b10fc12f4c0a1c18d0eb273b112d2044b4a8cdc46495fc76ae27612da209faa657b67f6cef470d4af1d56a3f8e9f4be6378b48d9673629d64da60e5e67c8f22a5a375bac2c30015e24ce75a8c8dadd7e9254473316b2393a93c99498616f8e4893adf541919af79007f68e365daa62fa6f06834590d3e4bfcca06a3df7a8ce9ce898ec8c14bed694fd1677572970db291f0d7d775a734a6e8b497c10068d1dbe036ecc5f21e6320010ba255708e8cb001b6923086cc7e306dd84c4341784ff2126aa26ac17ac42f80d05e9fdb40453ee25f71c8015ea2f9243877716795468632e5bd5301a577f626effaadd1c55a5045366f578118248cf7939deb7111b194db119d6d4e4df443a01c44c00832feb2231014e932e71b8330bb9a6321ccc46c0b6a62de4cecdbb1bab64aa1cb3528e07943e7f498874175dc830c3a80fc4fc025e902005c74a681addb419e7672e8d8af2f2bf7aa648128fde68bb8994480d6e9cbc645727b4d28315bc0add58f8208fccdb1a4642a0a0df2b1f92eda219ed0f961a2bd76289c6ac2665fd25dfb2d7c98ce6bbecd3feb89a3a18ceeb88ed619a067ef436bf64f9a2d9c92505af621943fd722c978491c52d6bf6ee80d3331774ef6ae6b09987d18ee068dd40e5b7dbbc90aee18894a93d13e396bcc698fecc8fca7b6479ddcb92897259bcdf25fdf2eaffad3e6aded88f8114307e8287e4f40cfd1c5dfc80be4063ad211f7d05a49c76d881fb5ee8527803ab726f074e38401a5d371abe236c3d9678f70cce645ee2c096718d182fd5f5601407a2a5b50e950d0b23ef95e80087569605066df9a7b7a7297e4d63238b9786d5c7bd6c42e4d93b04a0ebaba21a8e58f35fcd49a03ceaebc9770555d82a30c1a5e8635b56133ff091e73a291914a0bffbbd3862576f433c04eb6543de1b569b6ce5574cbb5c1a1240660f275d847375c751036cb7830770ea84eaf714dc6350e69d01d65712266223fe5b1d2b5c740571963d4bcfc0833dce99479e4b3c7c5ad6a449c9dc7839a935afd98f4f2483dfed5aad4f773dfd16263da5234b6635c8ff30c5d4d8fb14336195528bb4d72b81270552020d23bc34d0b8813307db566eee885386062f85f2f7cfd4ea406f26185be3f9d0eb60e9fd59e227a845fce0c9c172448a060068173c029579c9862daf0959b9986db8c091027e06cb816ceecbf1715353c9f49dd2633a5c4f509d97437a26e94ccea337973355093e91c65ea6a5b0f233c6b5042737b60783977f244d77c725f7c64bf184012c68a6f8c2ceb9a25b04f71dcb3c9eeda5341572b8d7d02b26aab5ccdb96dea8cc7b2a3b92b09db02c535624aa5e2d5ae8ce69ec8a647c88a0814d21ab9b1d63123ca8ca726ac83ab0b8a1a4b145b8d2128e4b7da65f62f38e939a768e3757042c6c9d4fff7b2359cd6f695e739ff71b843d82ae754c929560788ca61fe7bdfe7b005d61dae14b7e818817b26636f5f9c85d3732f7ea9a2de7cf49af34149df35f00fe74142703706136c8b0cf6d7333492bf86268865fe2a2d55876da0d850879c830cedf99a6ae6a58d4c0b56861088a1f8469beaa5cf287726e5e853f30c76642bc3cfe654bb8894873b7814d88133a398dce9ccb1a77ec9afc2461458442ed3e4e0e5fae5fefeaf1bd625b8e4c0ac521434bd52692b7f727b88f3a8fa26b6971df4c9fdbbbf90f55f460770630ab20a38f87c54ddc1a4e1cc60b514782f8c5f3faf3717709bcdfbde7d78e8bd804f6da0a76dee1a2ae1440d8f0686d2645157baa1701478c3220f7c904b5b3a68dd08db474c45f5952af7503d009889b6b99a78a10c0a17d7f49eeee8c87ca83d3ae1a85f58c50e0d379565d8ac23566e70a8e7213c478639c76e67ee82cebde2c639b9ef61604ff1c4ef6ebcfd1df77123fdc13173d5ccf58ed48c77e156941b7dc4cd6a407530d80611f2396dd818e78cba0be3b7815b1884db795a995de23321c4ee34bfdf496e295c4c17ebef837519f17d0761ad9f793f900f04cf0a28f080f780d1901afdc09e23a89999b9abac69040f6acde8370084e020b2260c881b5d04f4a9f1cef39a6d7462f8d73369b8ddf0982bd8287568558c8ecc96f7280eecaa519923b2e0af661b1e67107a2ddb0765d86fb2e7d01cdacccfe71093905233257fcaf71217359ee35fd40a159c657d9eefc1b43d0c9f43d125a31e892f72c1a53cb5cbac757fe152be79bef067b3d5d79becfdf248c175590bb0cbc9694961e7ef9ec6faccece4d8d8e2d0ef0cd1e52576dac21bad37a317ae83e6e73a4137d13c20da90885219091cd2d9103f79298a94be235da5d6f450fef21b4554082d0fc8c4f5028ffcd33cf00fedf2b12216772ff1052f058b0ee2f7399c917463198d9da9ab176212571155b7f7fa46e2a9a3d86996560522bd6309b9d5acf2676a3d9ab5e372c1d2cb893bcc0fd08c283bced23e93c628d2c44fd7d3fd713c7ad2280a3807daf4fee32d26a71dca9a904d4b9c0d192948410eed16217608dd95f10db02c395ee9fe1db26f1fdfa99555232023288ff81f6d9bfabfec26b65b2e138109b17541ccc91c408221ab89abaab121b7de2254f890f2510d5adea5196a29dce5bc4f5caabcb551f2bc0d89e4707237ffaf2ce7aa3d38f85c5f0e99b94ea9144ffdfe5d066b19927f588b67ac79de55e058d5049c13f87fae61ebcea562ce2dc7b6f83bd1e259bce68a8486e90eabfc4ef1ef8ec1b5c367376325b118715e51298b9e745c3bb57fa8993b036376096669579ec757178b0001d32bb05b1160bb7c93664c9846745a851c662e2167724472bab85cd75365236404b5baea1ea07be365fea3e9e58ac08f5fb8a98acc1b2b4604b140490ad9d07aed3344f552c3d9f8094afd6b32ad0854f2134190fdf8333786e937fe2b7fbf16161b97b162b30498658df90e16f0dc6c1a9c9c8adaf1832b73f50b09ef1493b3ccf20f7c783c0089007ff592f54227a3d4456afa9c6692283b189822d8466669aeb14daf8ed686569681ab6ce411eecf634585fa4033e90b26bb991eaac270a3be8ebc8390fd7b4df3ebed7c5a504ce6f8088af733b429e694fe2a883d8a0a40359296f0ebce0a481700604f0658dd4d1ed8d6d877ea0858dc71c05e0cce0a809ddc922bc131136ae073ae73c7c16986e001be60535c7dae53e782e315f49291a5e8fb4a3774985efaa921888717cd1a21a03f4e99ccbebfcface17ff80f9315779d1bd37f2817ee977afb374dc923a5c6aba594295a9ec512e55c345e065108f8a16131f0dcbc3b6ff7e12f9b23e261cc3e7d2ce6766c5d65f91a0646fb1495227078c20c80b3f8c7fadf57a1f22bb5ce8c4170090279fb386dbd1cf571b02d6029b1435cec0e6240aeeb049ec7f30000e9c89d176ab4c5e84c945708b8b77a4857dcd70f7c825d116e98c0d9a258b5dce3ddbbcd738cacfaec5ac02d518395ae5f7d3a88b8c52b924e63f331ad936318f6f799369fc143267257266a4ea7e3455b6907d4bbd68d04e6baaae1b76bb37be8c4c156d04ab706f1430f089d11f464662ab188aa2e53f3db564e3c04a161e82dbd517e916871267f95ed9f93ad2f08120b3b9ffcf61ad7c4348f2b5b3a88daa0fd3da01dedc0977a17043053204a9beb5b61c615161e8311325f62130223382950316b09f681cb19eea695f9c1dfefd7e89d187ab164ffb8c3006e0269b62f456142d39260d6260ca4453d94c87c9c896dac2863a3f9321bae61d3d07718f2a123913df5feb6b279918f1ef2d1d6ddd4347346111a3f2388e0acb11cc45d95d33770ef76d49d30cad3e370e31959e39fd8b2d1a5c586df59421772b4862d9ed5ad508b1d08f55ed712fc75153405ef3c37edbfc8fa884c542812ee628c88d0fd4c55b7793283b2d9ff3750e1bdae05eb55bb71f8de593de47fbdb5841e696af421f8c9a0dab495fd6f33e4f54014aab7f58b7330dbca53b0699a623ceb0a3ecb7f38bda7190fc81f23818856394e83cf69615072c875b1aa702528714b0be93788ccd67d773f746a435aaa9ac1718de4c67ce47a2b833713879d0b06322050bea1c23d4bd19cce261fe0cf395773d47b15e315722403ab49f2b7876deb6eafd6d92de65e40b5835f3a68e631ba8ce30483b82ed6d9ff05545054944c805e7f848357d021e57dfc12d4a10fce53b9d0742f6f3a4fc346bb0710a58b1df972af032f7b00418eddb61e7b786c8a1604a79392748162cedc808cac6b57964ea0e18254a222284b5d1332b76d2b2607e73c31330b13cd54d9a50f0fc660e82b14ec8dbae85b690c65a63e4adfeb9ef898d4100dd544bd8f960ed477760903850399f72ae6405d92889a622f00abb3079a046185dd4339b2f39d723f7993a149ef7ef02c6240ee3598d19b58e7848890e43f9f968e38844bb184e3725c4a474c3a628a6258b16953303f6c16551528232eb64806bf8b9bfae67c337b23473054ad51998186b56e92689f5a3b88759a80ea69dcd733a4512656271a1b621cae2b1656df6476b2bc443361962cd68918df7b1156b36b04403488f59cae609dd3e57453a5473be2e76ac7fe320b8d13d5e095d5a3feedaf8831129412b09631221cd39a135020a0c382ac467fb8f4487b25c8976c807d83861673d86820f042cca290e4479f81409b002f6e6a30e2e6bd17c0b829c6441e39c43354f34bb3ebd6f6f9247f45faa0be684a0ec4f1440b57395409520622a47e8585340dc9585e1d0a86d6112d199a9296d928d5a07460c0909b0aea7300418c57452bb9aa06d2d961f7bcee29fcdb250c720ceb67caff6ce8385e7e0018394d233c3f8ea7693b654aafb16ef9ad7fe0dce02846d8e9d3f05b40a824d5e31feca28a171e5f9a689b90e3a3d51ab289404e2cdb829884b2c7284e6a6b5faf7f55986f2be2cf79992e14de2f1c1ce1ea816d2d1edd58fc26599a1cc82afc0a49ea2756aa7bdd4675b9dc521553518866dab24e26efe2880b3b6938b06cb5fc9a1f89496957020ac2ed1c25c16491c42c9df205ce6717935bf01416a9e5b94b04e5ab6ea5490f5133c7cf29dd9ab805abe57ebdf883960bccff9822d25114db15d100158437aad7642466ab572bba2a187b6e11d6265eb6f829bf0ec86b8e39cdbc97639e1554b9c4b70e0d3b5f6618508306f00657ea2a1fcac1d80cac524eb8dc9fbd62c19445daa3dbba24ec168beae44c0bf56f1629f0891aee05a48bffce113443176423ea2d97322b43d0fff783d333d642ebb5ce61e2a344cd9c483fe8658f948ec261ec22543e3ae1ad648d8a248aa09e123fcb56e72b35196b5968542d61d0bdf13be6f9f3f09b518f01ce59dbea77d932d0e21a75e9820861dbfba0a4629511fbed4eff989a720cc5079df9b7a00e45ac3c7fb47e52041313239f92eb8767e35693afff6e6aebf880089f166d934752cebfe066121b0c0fcb8c0d0ec70b5299f991c5d15f1a4e547ca09537aef57af4b27adb6a23544533dc306b620c8e98578c8e281548bb864366bcb80b297a8f0a7d37511891ecb57dd8a659740596b173d0f18ce85fdc50a3bafae979f93f205bc55c7910d304fe10e1b5fc4e41296ab1af9f4e9c09f7a64cb849bce00a5853481809027083148f3127867ad6327da0d37485ad2de84b6d8d8ce0169057f4d860efe4682c6313da382885e1b4b1e374cdbad7d0081cb0786ff88b44abd4facbaab9719f09c68356290932d3423a6283bc020ebaca8bed7d617a9454a78f98ed3888b443cd44bee07965901a0dd7e280edba1dce6f7984f566c5bb2f1ff0802e50dfa2b578e5f17d19244d1f56cdbba7e7ec6f7281ae23fcdb6480caa5d447f8d2b0d002935ab4fc0f92786cd7f96c19ff103368f028f03f39a635330d6a1da389f183fac3d48a462e432d99bb172743e3258658262a75429cebeb568eaf72fe8db5a6e53e04a40ec232e8c7217a07ce7c764da5c13a5295eac61c4e17fe0a95aff48ecfe6488ad1cd41baa3faf62422b37c27b4d8dd1fc2ca0a9c0837c2be7950f8b55c0dd5d821385c8c9500bc2c162d423a9cd91e976b40974c551b2d4d006e1a0587b54f175ed06272545635df08b0b824b1246577a6a7fa8ee57e95382cf9595e32f15a6e620c0786fc06265af8e29c7797b0ecf771ae83012230cc037a97289df3a083327e84a596cac9b9e560b84617e6c8685f8c80aebcd099054bb62d2ca79f0124ce2bf488cc613b7f28f20714533e5b0f3a4f400158666b25360557dbf1bcaab49184d73be9697f9b778034e9d06a23c4b72910b09b9ae9c18890b83688d8af0e926e7d90dcb0558df8298ccb4694b32af80bdc95efe614ee9079b3c65305aa8bbf0dfe5ba5b65d60cfca5213759549a91f654df5019f10e9a327e7fc480d99f06fe32feb880447e6b12d88a63a2a327777781990503821c88893774d7575f6b11593d10d0caceadf25df420a37433e1837b4999a21ac0a259626086ad5227e2f0f265f1afee8117e74ba14628634ad9b6bb2720b9dd8b3d3984a51f97cccb64ba38695f1d6616625c7be2d1a7409039f807da5df7931705bce61ea6b2a6f83f2486535e835fa6606dab7ebc2c115ecacdf003cffb986a20576ea6c7057f9f4fa53f8f73db3cea4592e82049f85f760ca193218a316a4d059b01ce2d70acfc9643307db27c9e4cfeb6e41dd6976e42ef1b2cf5998c1fabbae346b8f6ac9d61c3c9bee37df283c66a84433d1942be28805b0996b384a6447552114b87a394e3084e80a67e9b412d1c619a688de18faf5d01daaff1154ee94643bb5b10a545b01411f8048ae752f8a054c2779a3f751a5a53eeefa0fb2424fc2915f55c1d139fd166a526f2ddeb94518fb181542ac2cf656203a1e381636061ed70bbac54b42008188a9b6010bd66b2d606c17b76c20fdaba9c4514d46576765bebccc968e54cec273b280ad8716ecf8f71cf006faa137ede06b1f610ec5316b216adee6ae87c69e7a2f9ab8a800cb9e4f631863fd145bffa0ba4dc85802ddec761aa8bae435cd4a737fc0ed4088ccf190b2c40cb69799bd10ca334b23a8e8b4dac446ff54e2113e544f4971559b3b26435ecc97fea19556c9ced78dbf7e1aba469095f3db7572b7a8939e583e624b909209276ec9d1965f808b901f4a9dbbb4aac19238b08526dff3baa462e501f0cd3b555e775ed25fa0acdceecf8196c4e1507ff4f2cc484ab8b55e79e39c450794f514c5a5bbaae2cdcb30f83e0c177f9a13c28437456656862b658d0b8d57ca54a2ba6376efea8ab1074314c54ed6aff38af75d670014f033472d6bd28e018a5ae40acddf66a313bba5fcb37ff3c09b52c16bd3a5b0048eca3183921ee420170ef22354c440f00fa3c9f8f78279a44c5fab46b158c8b6bc716d900df8725ac4b58ebd09b0e78508352aec0974d4fc0cb0037d2e8d5435ddab536ec44c3c7d616f548a919ae5161dc7d6efb584ec5823e8c6dc8b606f2820290925caad64cd051a3f659ba50cbd7e7b10f240b92e75b7d26d9041eb9802694d8c720ab4cfbea875e4a6961d5c1e1be0fedc00dae2616f2e7e7ef13ba1d2d00cbb262ae5cf67d15cfb973fb34f55b4bafc299e5896dd5143b75f326842224ae0f2a968ff67488ac5ec4c1aaf14b5639dcda37d82fc54a5af4c2aa391e2093d1f8a20060c98092588422fc5564b8d65f79c182450df3723bae635798f134797e50db4225b7bc6a6203dc9abb9fc1172810272a5b7d348b3e7d8024bff5103db1986035cc1e3732ba80d42d071dc2796a6f4904ea1182f6f47eefb00f7a106146d7ef1f642f7c44d3fad31ff561e56e8bb87c9aaa138b4d4e796e38c364e1136bea0442f6a6d5337a4f6843fd0c2738448c3351977bd6d1d3af0b9fccd20d982f90bd3a5ce8387902b1ef470c8d5b24d679c76dcb44c571754221e3dcc2ecc0c6e5eac52ed11f3afdb41f6d29a08aea3a947689085ad36d9c9c4789943d52ac39080382900c043d601a3383bc0d7e3e7f61a34d0420d3df7e80a15787639434e435dcc7a051f6e30ac12885ca827150927c0838ac11078df2f0b63513d74e3e9de5a245edb2c6055fbcd4683b81c7426ec36eddd9a486fa561a5ce2155bdf6ef5652ec3149ba8f869770cb1a6d999dabebd0eedab7ea3584179e2de225a062f8a6593a7e84cff0807a3d8bd0d7cc54986b8340aa60f1691bd1098162f7a9538c3886ca4a804d7a77cde6f70a160ded06186c8280437844efc6c5db5c157716c8584dfb97b46ff38fc9e65934305f0a5d52f8595f0a000341a24a69ad50f9a7f0176035ee9b1e303b43cfae3416733bf1882fd4392d0cb473c95481c42f59853b1458c1d2b686f39b8f38574132cc2d92a94cf3a243d30debf72a27c08a4b1abfb445b9989deaa90dc7c5424dc7b1786d87fa1842f9ea7edeef4e8977ca40e92875f1051fb4c4d58e99eb18888bd6d85e4ed8262565f809f321161e66449618b8e9e1c67b12068217ebe0286b09db82a0dacd83347d3b1a0a202c42b2242efbce23bca688e751b45f40cd2894349e7174b3a77bb33dd3c40941a460b8435bf29a93f9d006563bc2e0fa576d91c02469adf8709bdcb4656a0468788d02034e8240f65e14ac316e62fc0096daf69a9d1f9d903694b301e5d9979339ce24b87de3901507b45e2c134de7d819b826cc7e23d66196aed2cae7a633e9da88d4dcbedf3d157e4c85d7261b553a86f93e7041b865378f09f85fa77ad5f337943ea04f60ed6ad60e675a06910c72c900ccfc6204c5ce6a3bc6a33eba66ea8829f7060eb5a4538000f2d3a6b9dd92aa66f4f00e42823cd2c86a825a871890138d57ed3a3d85cbde93a4c3b6a2d0a48302dde9a2a0e20fad91020236fa19d2ddddad1800417113463bd6f9eae73f5f27e621c3c6ce78ba8c934caf5135c774a43b8440d4f572d8b6f711a72ef062130baf96c73078405e2d677bc894e5c33d7e76a3a7e3d206eca0ec5a54b7d4b8a176bfbade4bbcc6a45dda0aef711692664515d32f01212a625be5146d7592d82d7c740993e0be2ee206db8a9314b9b0ca45e5ff01de65972887ff442cb089d60ce7704c925b727885e3397a05ee981403b66c8367cb2561914321a2bfdfdd585bfaaeb11b5ad082b9945bbc5285e7e44679e3b834b1bc4467186a55703f2268683d8939136aab89c10d085ee8804fbaf0084def74f296de388998069a26fbccef3ab28408f5d141885bf9224189caabaa267bd47683af153435b85022be2369b2546323ed2f5f142fc0db26ce2d93bd5299a278881a5e2eae082904d4c1f3ebe4b304d7c4e5f1c448e29dc2b433d009768a5127bbb570002dc4c70a617a513aa1017d2c92ae7066eec42839b60697c60ca4d4f52be80a23bd246f43d07d82b819ff4d8567f3d79da0110014a245cc476c0174e18d045cfe60819fbaa21c8d7634a1579b713dc2bcedea97adae6021c8249df61b0894b6933e1dffedfb4bd21b9409682fc2458a981be1ab4fc94d6754ad24626e55da958a9c091e8a47752f6d99c05c154a17bd6a3096f5f3a08c25b3194285ebeb8b0207d63440d739ce7db719fb42eff9876296afd6f9040ed619e7f3ae00208f7e1441c0e623ae768036d96a61a0d97246307ca6e95db16a471ab9c30c40063f3989d6e45981d68e65988bf59477ef6b0fb1a644531a2071c6df402491d93948f6ae9655a62bedf4eacabc555e93c2747b83fb9a5d44035378b3521a4a8b847447f9071de0ec96bf1eda40049c627f1ec5ec1a29b7854512dc200f51136d8b4564c1d230ffedda13e2cc2faa061563cd3901bc5eaa834da05a89a70358e76963845c9cdc8af9ba46506cb1d6a364da51b11d0f6f5379f51fd264727a3de9c980434a6da8713fbc7ef4376aa30b60d78b2a9d07f8998b55d9abb970ef922ef1c0864ac499e8d969310eb46fd8f20690998310935ab582336f1d698b95687c76054695b8923ca81471f52a7a570192d3d8a324a8706b382bfc024cc02501be2bdfebf69249d328a174c4d35adf07531a1506361ae09ebd07b24036385554f754ce4699ab31344347cc5cc7446d0aa1a40eacba29f98899ba4316fb10043b37b84ab052ced7050de46c74046bfde9c303186124479b3e92a17ca62da0ed1989b2fec2fcca40080be021971b24d8081628559c1ee932b3ea2e17295d451d82596aa1c8535e68cddd2022b2f0f46823e3d1af0dd695f5b9f340000e2a39016ffab71ef34be31701335b5d7a0e632379240a3578591c0df6367b06f0e7c0b17a0bde861a62c5aca4bbd9ba8b41186be4f0634c5eddfc80defb447faf5172d995b497d083b7d0e131bcdafb12d1f94e6de808211b1182536d473f0a998d6efa10143c25c14a396a10cd90fe7cf32e193957488bce5531d3462ba6211b25e3889e71776c37b157e373ba4c5f15a9067dc36978379c252e9eb2c22202b6cabc78508baa7246542ce96adde536f3979c20ebdfe3109fe6e9f6e84c2adcb1db5b8fd493b9498b60c27cdc4fdfff0930a190384186916ab15235beaee245aeb2412413c683fd1534207dc8b78ffa3bcffd7d41eb90223dc96123ec6267efb85f12bdb9d574679e9cf1359962ca91bb20714350ed2624fe9b05fd28d6b12508b1a6392fa1a4c3ace87430916f8dcd86bed8f893c64e84ab5759f4549c2abf7137f724bdeec1a0ae1ac7e8436be10944bfbe0182732ed53ad53aab48ee9d89200e33c8de916e4c7ce36b93f4baeeb017a4d76f0e49f3478ca9bcc3966a47d72fe977f5c4706fc493ba612b25085d502d10010064115fd9c4addfe13235ff6abdb1602df84a45d1b8ff7162dc783817b9861972b1b39d6c3ad9412f57f617cab4ad988c09de4f5590f757f7596cec70625fdde25aab28ee40b4ed7fe03be3c91d554d0e19009eca367d8284054b0b3b298460c808e25365dced66b8e33fe91b71c4e9ee03c34fbb3a748d40083b4da51b5e421c7759a1560adc491c5cafb409251496719cb3ef62f65d87e5f342fc81e0b610cc6c1fdb86724485af791c160b9141a506400a9219a3927beaeef2e83ef9d93b93f079b332e5bf251e7dfe7e439b2cc514b9c8ce7cbc60c9dc84bda28446f231208ef316002d5ff34bd4bed7a36a71f5a244459985d393109aa87b786b4cb0b2c971bd7d023e26fcd7f02d0d97f550c2782f18570d18b63ab8343972f4f3ac3e6d2347e044d29c9cfec8abe43a2a09c80c18e67807c4a6cea1644a249b4303647b01dde1582c3095feb3560f6ee299ecc117454f84a99c6bb5a307e5723bc238119205662c10771d12bcb73efd53c3b78cbf8a21443f9660168a329fae71458daf50c8bc1bedcc318f2f9ee376aa6413ddda0124225f852cf0ca248666c61ece041cae22f40013257d5a1159d628af52412c9962bbefec4fd84e7af0bc123d6de36c2a56788cd88830b923d70f3d9e2c7d7af40b4a073d67663dc139589061958104a517825605e3dba3b9a7378e1a44b43bcb7b98d99cc538e379c8d8c1979b1ec9fc86cbf134b6b5197ad9a3cdef178a280ddac5b1604c4341752da1b78832bc2efec3c04ba0936b296a4f7099ddbd0e6de836af44a3d0fc2339034d9eb560b4934598bcc28338bf7aa71b74b6b12198b70d56b246bcf30012032f29ab1de7d51adb50e8a9788478c4377f8e0268862aa216f34ae8664f8c6d4b82325f4989847cff584a8c9236045a58d4395daf78b4e192ccdb13d1d5c33d484f107e4c374fb8737efc3fcd6ea2d7915d2ed785c0b45d027e6819c57ef24441f3b1518a2cbb2e61e2c7e5b20671e3fa80bf6e10d801d868f2a2e6f8a0d4750dea830fb27e6de847b8c7912b39d6e5c1e2661838a838e0bf0d1f3ad89130af82cdd43785bc588998b6b9f4e49c6554b0387ad453942c6a06f9e857a091900a54dd0406cc6cadffb4c872615971e2b97581a8b9b4b7d21d4899859889d2544aebe7c2dc4b65bff50e749385f731afd16549c72cba86e3d16fd36b26260c741bf60d44e97698e4bb06d969aa4e864106108f3e7675732bb97a97f8f1984de1528af1cf654710aed33700abfde86951d5848aad75deb8994c525242f65065ea1a758f59068f87fb24c14c282e40f458a431b2e149226352add18b0d92d018a93d76c7b6b43c60400a15b36a9585fcb20f2afc66f9361bcbeb2c4659082f6b35841b55e212815f62442f63f510eda9d96374ed816acf5ac88ab0cae0d9674221ddab950de95538e72afa59734de369ef8e7609533eb7a596439beffe110da359d543b5ff676e50f27145a8b72731ad240493a2e30ccdb4929e47535e0b73d60ffc135f41a50235eae79efde2c678f9e3ee1980b6223a757320a264f9ae7332a3ecf305bf28bcb5415c96c435e1ca9ac9f56d66dad7a2da16d87655803d2b9fe3c3c985a8d9245d280e9015bdedc2d5ec8cbd4ee79a0e706bf1cc237183b85ef01afba83e2a5de09bd2b54a5d23faa97baa9882dc06b92a229b037928e3bf2c049b47a719540cec34fd8c28bcc596e2c43586a4c7946be9650d2d9aad4f667f4b17234205cdbd5cecfe9809be736fb69eaaa5b39bc495433b34dea3cc0d23e5ff0088d0139ef2025748f3ba95a979ab2e0029a6cb7e2763bcc7a902610aae52af7c654bbdf464b4f98d2393b246cf8ab87b83420aa198c79b426ef4569e99f2f48f38973ba78dc4613f88102202960d0438cad4bd8aa0970c5c813bc1f7a834764849afa1bcf8c0b0055c074ed687c92bc4d477ff9850420971f2f14c1e3369a8cf6b2a918e5bca3f1c8251b0266095d631113edd41cde7c21feec7a92f20ad1803a0d862348ae3cc0f2a6a6e108d2facfe59e4c90508948a9face86532151bea56694ac61a60c194e6cc98106155faa2ba5a1d1f4e77bb163a405397e6a774362d7481392af756a5b2e206c75acd48218ee32283c3c510627f918306edc84abf99ef8f7413c3346703815b8f2499fdeeb4f2baf5a0eab3f4256f729086ad65417eac0d21d907aa2d402b64b41d401d16fb7fd3def2d3a9fc3ec1396a5295ae88b7e48a557bc0de99ba67533fbe2ca1d887c2f3e10498c05eaec56b70af57f9decfa9ba77130c548486e207c563b10787d8e4f79effe3f0c011e461ebfeb93cc3c1e7d7d35aee7b026fdfb2175d3383b21e2e9e1d2f41e5bff2c7d692e3b40278d52693ececa8315c4b4aeb8bcf9adf9a8aedca9bbc182250b892fbddbedc45e942811d34b849be1580f45bcd1de5be9296c3fd43797dbfe55a4d69ae20c6d4e0133cfee9ba8847d7e49819da0e833d95948b866e59b2a34d03354e1012c8f02f7b1c2f27cbaee3c168b7d602af8efc15a720812ceaedd6d6bc5a9582d4009234aaf74d5a04a8d8d4b07a5d1988ebfedc0a82ad02ec71e117d77fe3da6a7ceb1f76d9d44969ed8ea57fcdf695db6e3bbb92c4465606e1b72904f1a5f20c6f04d0cedc986ccb85c7f220315ae1710046db8046f22491816e3222fd66d679937ad0093ffd4ea63150f1c0d8ea84aa943726b8392fa1a9bc8911c75158fb128f8f31f90a973d1b375ed8c5c834d686ce41be3bd6337125f588390d3848239db7d283d9df58a8c37755dc3eee5b5d749054d120d1e9a7df69a34b271aa9bfcd06146b7086089f41405b2ec86becfff63d3ff372a8a07beefb2385d4be594d02ff3c63db3aae981bcb047c8e5e5f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
