<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6498e7af4d589c6fd260f4b25731d00ab26061dd53598d9ee29ca66d63529c52264c7139f2cbcce4610c2fe04115cb04734e9d656d8c3cbf47f2c392632c1f0bfd60e952ebba6c97f82f09f264b7e31f730f82a07a5b214f553efda92c7a4a98fb62b0764b580d28c3aa72979499d931b7b6ed1560c39476a15ad7122bd16adf5a9544f8ac6417ffe5065ca309fa9d304fc45b88a27854c7b13ce8a607f933eacb5527364b75ccb63955c141637f132777e561837b6106a2a7655a0f055a5b310bab3a100844b04e402178a846347ca5c332a8e7d267aa98a57b2158e996609cfb2a0d5629b5e733cfc1e975ef3fdd97f95741871c939e798e9965d023ebcd5ec235c6c07332ce8c55f0a90fdf09e3e2aa30ae8e7875eb41cde0601ea2c456b1dda03ea8ded564182b5728f10a1c88ebe1e0acd57a7abecffa0e3e7ed836794525831d49880d5a0612de7e59cd49939806661b52f6c199fcc8a5eb8497ea80bec76d04066a71312c150ba81cc180ca70bc455aa984a6ed5c562f09707a22344c8504464a1f6c90608c22e3012c6d58b83c11f91ab9ccddeb43db5842e1de41654524eea8a57cad87bddb685c458beb7781629d95e59adf93862d69f35d5f8d9f33373a2ad6a62990bd31722298463f8aee89e98f79866c8bf664cacf731ff0b429ea4b68613de7b7e43cdd8ab4f2d5af9ccce63452acbe1573a7441a43da8c3dbb6b643f4f5a471c7a3f050c3e062cf92dc9eac594154b4657fd76a598375cf4620a5a0c06a1fc3d9487211e6cfc57c844fd92a10302599a199f44f135a2cbd9012afb590db15e5e158c039c806005baf354ec9b5c3da833a06fd50cde9791510c9aba17a567e2c92ae29afcd848ce6311ec4c6498ca9a4c21d2c8da05fe359a519bc8c0d7b4f9829c38c1f9b2ede62182a9a2c93c8047affab2d420c63d808ea3f26341cc834e8d76ad0424035f879e8b36070c6e84d4437379645d7ffe017c097682b2729bb36b6ba47e14e9f3c9da2b8351e26071004e37007e48575f39429d6cee4b2b7de4a84a866a96511ec7490914b673981010d67cabd0bf5635af56fe8b55369b9c0c23a623d528234c8f2fdf12f5647cb6a1895f5a09120800df6edd16f1192744d9d912242f35d9337aec7752ab9e656a2830c6cf6c2c7b8eaae0a5a95216bd131a82c3c1ce0cbd12fbc4673c2cfb124944f05c06ac0aa01f6fc2e16e017667acb492a9f231401f841585b0db62d9eb3c26e93e142db5892b1dee87b83cd35e48e26dedb5ebb189ff21153c1c9b6ed45749c9699e8c127717ab90e0fe94dd8151c993e9f0d261100fc2d896b09f71c57165cc6e38e7f00bad12ae0d86bcad5493690e79f87738efaf5b7f8c2064891d2a35375860990fde95c0df200b59a3c23211b6bc3446f8369b05495f48508b020f65ecb7924d5b272fb9ec8162f0c095629acd8e52359ad3770ce29722192ece2109d0b73f9f1aadf5b84d8fa0e6c24b376003dd73cccb8ec087dd70c998f0e3f65654637f6360b68ec2b4801cbc937f38d1bead9b97d3e0d9859d5a267a8441246d3405911d44855363ac8aca2d3c50fbea8a84700dbb00e7fabc8007bf6c57c3fbbe3e46611b32846a0d84128d2b75015f0cae884f35d2999c830a0332e149c14658ce5c40eed37ef35cd61e987b1d0125ac1d0e10f9ef2b4ee697db6cc3c5c3faa3df0500b923482e1b9855ffefb4f90fb6952b7f510c90baafd1ecdc04529275be43a0721d969c3855872856e9d7284fad0c7460e5e42cb10cf671db41667b2e3350f3b6413ceeebb6e3aec10ebc1c09c54fb49460e6a840cfd246f509019f15b145b58a7441b9dfd191388a25f8db62c1089853497e91f06924b907280044d2f40d0e32eaa48f784865cc9b3c7b7a07bfc658f1ee116a53e681bea4a1985ddc5c7aaa7bc6317f931747c4fbcb48727e986717da6b4351f51f01408bb3b805f5f96c64c58bc0b3c51c28dda6c61bff702f0ab77e245e6d8a5fd366202b3131bad4126c7040c323c212f2052081d4f277bf2eb8b75c77e669143510fd565f402012733a8906a5c302a8fac3aaa1db4cf6b0774a858e100bf2a62af51af721feef1a20dfd793e7a8dfb3c7f54d46a300f573368ac7abc39ce4ffe1b167709f09f8176a3889e068bafcc68978420a305850fa9677a76e2c0627dcaffe958212c36a08301fd9074b0e883154f54932ddfc77ec1e253674c9b06164c3b636921789d77f4bd5425841cb7347c53bc99c4345703934b712fea8521f4842f9f27e669f743baceb6706a511013979b50fae0af6e258426aa3ab69ffb300044467984427eecf325ef09f045c25bbfda5b421045b881f6e0f223bc8eac99d317324ac89b5faf91a337fb61fd062c73593a5543655cbd31f730788fa9554234de9e860689086d8c4075d6e47fcfb94ea620ec36a8ea7e563fa72705db636e76f0e684a43f5742184e7500ef846f1a9662ac6ea2d946911c5c84d15e34cf326abe713ad0524c0b0cace039a658fbd198dd274da63fa7fd9de4492bf3bd43acec2d3adfdcf36b6acf4f9af76d6c26f733cbcaec790065072cb15e2fb4cd17444dda10a6020f8a83692edc872775d115e549652b2961a76c3aa2c4f42be30f8d9b119f976bb07fcc26cff718a18bcdf109d503848465984da91fe2a0eafae95415dca328ab0bf0ee13c7e2d685d5daead48ee13343a47d07338bd71c7659251b1e8094b1da723afe55da0f0440ad717cc03ae7e0f591cafaefb494cc1884b1470aa0ac52ce7f49df4ff78a3fdd872b57eadfc97e3dd4e9d460fd46736a1a5b12f0c3c461eaf23ec1dc76d557c49c926f0bc9ff664aa679acff89cc52b273a45cc33250cfc7b0bbb81450a1f98b85dca7ff385ac2c707f4c82d7fbbc9ead968e24931b492f0cd0897bf2f798eb636a153a3a551eee7590c0bf9c7250c200f760690baf665c42a465ec4ada57338125ea4c53f5b8c29b1e3a74e5e6ca98b63cf9a6dc8871e591d8e1921187897980c497f3e5510f556ca00cd0f7413f7bc1f13406747d712db59c037b0bf70a89cb92d092cf02b2e68a8b0db82849d9f68a2cd3644781ae7dc09918f094cbe184790ad5306c95f3056d16a9da2161c347f63c5f6a0d7aa55d29263ca06b73b66d60854751098ed2ee0bd7ecc22ac7c24a3f3a491f5de58f600315769b4fe6e2e87819f2bdad0fc735fee10f61e341f88f25c73cc4b19850aef8103156054a25bcb1725ca5a09c7e389c566d44d8691f0bead4d47be7147acb4775354bf0fad5a079454c8839f8b9dfcad3fdc6c84b430736f20a79a63a1467c40dc745d18a9e21e26ca60bf832b31d7e464c7fa679c071a93f6528a51ef767f1a5ba9fa94a7c153af8b511f87b9412b75b7f90b2f29583c5c34cd354bb24ecfb58e2ebadb00b22a32425028e573744bf58b4ec0af20b97aa523d06558647332bf8cf21494de78d3baba7fdb5acf25de6dd16740ce2bf94b51f52419481f6f21550f01a912d6f9b8cfe94db8a861e1fd7159fc040390584b944998876fbcbe47ae369153e6ef56c866c24f2b1c787b3e299407ac2d2e49b44b0a6be0c3fbf4132a91b372528e8b29b106b32cfdb64814939a171d768c27c269e13574c4289f204c773329c89ae610d41c4fe027b441d5176c65efdebdde19434e7e3c2d21be83ee3efb89cea0e7379bd1741f3fc6814504b55d703b27f5c830105852b9dac3a4ab90dba203cea9abf526bf45a2006d64c7c4fb5639b3e19ed25aeb2e9aa73eeeaf5ad48ad1ca70a114204b9ecd7938d722cb7e36074d1fe280571773fd9854422d527ba7c0cc639a752ff0e917fe8c280cc193a8a42bfcec9f3d6e340662c787eff59ad2b327bcee428a4ba4558b59cdf8f88eed7bcb8fd643b3461839177801e36afa8978d6fc6a7f28ef9abf1cb23d1e422e3bf064304ada5da87587a507f49699135476735a08c5262a3497025f188bf809daf081acd8790e2392545909f8657cf739265e93141fbe1dcaa4100b7566d8dd3c36af99c35b9054be3e1d0c465301482e1e58c4a065319107819e480c0a95b667dd3f0195c9f71218e7abd55d7041eb08e4b35df09a2f9974bd65c83c5ac327e054126ade1fee6d6ea6a4d0578adcb7ee122de53ca76fab8278a2e0c897f07be4ab6efc9d43a53daa515a80b5a0f1e3f870e928520949b3c103ab750cfe8ae089d48557bcd4d4bbcc2555bae62dcc09f7892ac1ab77c5f0662c2693dd050f0d9cce77eab48fa4c6325ffdaee5ddf1b1aa79b14ab296c0de1d761e7dbec96f5c8f6edfb26d4d954695f9a20f2ec7310531465cb671452a383bcb04ff045a5538af44756a0d4fb51459c1ee676105c1ed6358f239c912726bc5a0fba8e163dd60d841732ca6ca8bd2550373d0f1f9993506de35c378de677df4be65742f7bf1bc3761a3521110d38e24c37c3a1d123460936853c81f9b72c9b9c63225612aae1aa21dbf9513d23dd3318e8e247f2a62231ae7393a276b099c83d30c5faa4fb63051478cf5412b4baf185523d0e4f3033f73f5d80930321de2a8d8e9ef9d292a53c56f4de9ce66de89fe64acebb9201a47b753a36229bb078b8360733250932b5066f752659d2345929b61db29bf3cf984ec0872f64746a4eb5f776131361b8ee42f7fabb3f045718aadbd83aceffafae8332e4c70e78f03f60db39ae300e7734ffb7ac1d987b8f15a9740e32e6d64fd552a9d2ab63e9bbfb0b1c658b279aa0ad09b57a2604228e035791cfa6565a4386e7b48c30762a16571b0d892aa907eb20ecca299a8f1c48d7ce7a8b51d933c4e4cedf1900df83fcc530673e8231cdaa9c32b3bcb9d89ee5441f88021579c4264677223c360413cb4f064f559728911a58964369a27838ee9a917d6f104357603d1b7331497c8bde400e16af57556bb3f4829cb9a3ef5379e231c7a12337f5e7ac45f4945dc02216072ed44836d22581ecff80f1301a6f7930330ab50bf96f4bc7a00daa583ee2fea97c04741215b5fd128e5441d735dc25a33e5e8338d071383f9b6cc73ea2636ad7f85f43622a10cd106677e75674c6ba37e9c03cea8306a3eb3506f53cc552bfcfaaa99016e4cc89627e26bd37602e59819c10b349bce7b4a4fa6e3ac7e02751bf23e4be568a782496dcd58f1dd53053bdcbb2c36cdbed415a1d81c043dd0403285b83fe70f7cb7cde01089a8b7db9312b5953a473502c845cae998898ef1d0103c588a038dfdf1f7ab38e9711b77364485ccf3a69acff369483783bc5305bbd74947a58cd43783b0f880cfb85a342589df5a0c2aef351357fd7685af698aaccefd036618cb1018d683b222a90ce8ac1fadc6159b3e01ce3c2e812a857984dc2e2fb405663e455d3ea9644aa3e701c4ce1b780aafba415516baaf2a3cbe26837ac0ecc74014bd1a82bd3575597b42ac809948efd6a2b51a3dec3bcf5399ace499c8ab22e0da8911eda2171cd500d227e45d20dcbef329da91982c701a3035843b74afe3d78b24734666307985f9f08df6ac7dcabe4f36aa79034f826643306a38103b698993a323bb9e94167d098dad48ab28cac21da048d7d07c966719e1d825f36a2d3632709af226a1c8e21acc201654a81f58d9569a121467e2a9d1b55bede3c58a8c63635f6cb990d033a116fa25844b921e1b6c3ef228ccbc8711e84d0bc140b6db2b68aaa3732aa5268dda007597d903910dabe8c25e6d57b247798b1bb63709c0a99a895ac0e78b9ce081c97fe0587c72d93a822bf13957762391ed468802e049765d4439c1bedb03fbebfef2ecba65761b58fec0737c53c7cc5811e7df4b490d4ab3fad3e734e73f85984e442f72e0dbdf91ab7a3ac369baf2ab833aa2b04f44e6244e8bb755dd52a95fe2dbbb4196ff2149d182dae46cf930ce469af9529c15f25505c1fabed5025af2736a429c56b5af45ea5e8ecaa01dea85783d7d1b2d6212d2f1ef59719a451350f8b07c95e14e1bd92652f057865cb751fc9c3acfb9855f6c1c1a20e0239c80ef829c6e452df4cfc0b79fef9b0f616dd29fc07cc8b77115e1818b5cea648a17001f8f28538e48777da0b3aae463703b176cacb872146453970a0f7a00e6ca855c2d2580991e1164737396684ad5a34e78e7d73cf5e29e6d02b4a41ac3c70f9c49d4e377b9d98db65ad99c89cb19ffb0522af087425989df949849c4c245617bae846e9dd83cf38f3933b2616cb9aa72f5d25e66976e4ffd6c59e8aaadc0224ebda207be413e13fb1df90058bbf0ac1eee693a3e8c5364c5202bdaa624b49ce3df1e2e09869de0fb236aa66676034c0c45a16e5049a3628e9758aa45182950cf50085e00b8f9ced859bf7060d5b550892903a98d05b0fd859d0c6e4aaf6ef4f611ad906044e4d18f02d3fbf73ab116b9c4d79dd5a7b9d105e66259867c2cea354de98c059f9908c37885bf027424cf5ecfece632e5ea09d47a0592edf8f21420dcffbafc82d9b3edc0f319168361043b35778a3153bf02495ab268e7396f96f7ac2a228868bc35622825ed4a83c2f3a5a7f288a761f857535ce4a5033945c320c4854cb93774b1efd944c6df0cdbd5204f85fca347ef969ccd1b2ed44e8f041fa947b5d6c5fe0c0e6696865b513fec96fd454c72aa698133dd8e77d74c8b67016d3157d73c5a0d014db112508d19e6960e613576fdf9b96a7a3b42b9d4e3fcc41e36ceb85c7619b6608fb20b95c10b2c36fd390b9e9c4036fdf73870e5b0a76b0761256693a092963854a8e6cc5da70873368c37599a4c85c2083a05d8cfd871b28fd48a18374ae205ae743fefac8726a849ea7bd9f7fd442b5156f5c0eebd75c388a4a3d3312999aa0477b73c637c1cb323fbfb07d79d55ec2c9f729ea96e851365dff12e190ed828e6ad7d98c71ea6d923f1554aa140b8e403ce3e417195ae57b4c0db268f27f60eb709bf3f7f449cae1a9e33e3ce5426cee9db39742fe31b638795738d4e793edd5544d0f4023e75e7cf95515367ab952bd88f5a9626e1f70a9f8c797741be740f190572ae060a5bef433f9f39536253884eed147fa889b77039139e2a529b888b66a457602f97f3a2ddae348327ee7f71ce8e6a1307fe81188ea047a9319b8b018590a425ee84dfa12587055151dcc7f59b33595f7e5b303057c7d1fd1972a388d265308f651da1869b1f73fe01942160f4a3f8abdfb0da7f9a832727f1da5529ae045a5df7bad88c5d4aec73a21b1018fa203bf369d9c585e8f70d5c58ce1af0f01c47d7f8228b9826172e243d4becf14080c859643a75999c2e875e7269b46f2baee8dfcd7c9e8c10bb1cc5a0c18200ea3fe6bbceda834cc8353942deee92376f510baee83d0655518b4c7f9c9e0c6f4bdb3cb0c47ffafe043f080369322683f08777814e973202e4571369e811e22d821520dc71c0be0b6789f84986da7fb90bf3b9cfc395a88060813f73e21a48e6c0b79b1ea93cf9cad89940824b5414a7fdffdebb85c949eb4e08bb321f4e140d0689562b62960b825aa39481136786cb8a91baef7e61cb8d9917af1986786d9e5c2ab7b07b5057124f57ffc83284e08fd0e24975abcc9c6d351eba3f63e1aadd790a5d42d35ad99866db18f7cef556af5dcd005db4c0085f19afbfc7c79841fb935a08c045c8879e2df0a9da0b144d5d733111fc9d8996a35002f136f00379c9e0ddc35ab80d9dc9b648e7274508c1dccc0d572f671d114c8dee248c75ff1bf7b4520a4cf01b6d96efc915c2e15e8696cd50afa7d8802ec7d50376cadb684b2dbf210ef08723148e637efb6e526231d881b2051c9e808fcd8755bb804340bb73713ba42d7f722789d3e61b92c9236f989aa1e45c582c885ed7ef3be87735426c19677d3262cfab1aa384f7f540f31d7ad4ec8041604b7c06394c9da0921ab1b0d29567cd8c2ad0d1adc333fb15851c800de7c5184dd726af91cf346899b3224e9bdf1ad30c0084832b661e66edd953418eb1870543099fec474167024e25d5352a97b25edfae250af4c79cac0301667c0bcd71ee05b01e07f0693a9e88d0d6ea7f05d13804f10106413a6afafe582dabf20e56539f925eabc33bd020827b868d77c2decca8cc8b2dad8134c04d820db5d9d48e2b7cb6887f79c6d98a86a4fa24df26b959ccb4b88e5860115ac948646820c8a9595e8dbe37bd77fca6d665a49b086a336bdb99e015aba57ed7a9615bc58bf9a9939d132db5690641af292630bd88da5d0229971b947c5683dd35556b97aa0d80dbe299b674fded53e6105625f5e208cb65e2242aad833ee48b7027cc6c3f385cb1c3f5699e008758002604e3bb76cabe93e42ba25923b0971474f4c92633378d09d21208896d49af7139d59b3d5e1d4c82c5e2f66ad36d38c7b2f20dc655477f6bfe00a3ac454a1535aa510d23f9a15347948a6e5b94b3dc2cff83b614296069e321104b4ddd9830f137903596409428c73ee0184978f46cfff0bd2979712c8e124db9f1ab60543f81c2b4846ba84106318df106e9a61792ae06484efd4fd3186d6b136fbf380ee2aa723fe97ec3a0aa3001d7e13331de2507e9a18c4e8107d39dcaced47d56885f0fed38d2c4efd81301c395883ebf76fd64e22255b05b3fa665cd54577e7997f1b590187db062c1c8106279da0fc4b79d4785dc227f79f19c27c00ff3ad7000207ff284a9ba3706d4dbeaea48b7b6eba5fec3ab327c5ac6aad2e707a11ac03c17356212a8d7a8aafa72954f6654979beaa1aacbb8a88c744e38a958f8235e83cea7173d1190da3f8e48775a9101294138861ead110f0f1842e68599d2ac06906fae8b99d35a29250725103ad3acd49dd48f21581d933d3e642b203b6230909d599c61d27d4d5bc2d8449506ca385d9243118e42c455f52c8aa91f7a24c0bb75302449fd3a312f1658c36d30ba61ac09640daede324f9c8e5926078b2407a4748f2a8fdb13cb21858e7d4e4547a6a2092574a7bac57eaf644a6f5a7d1178b58c3f8f17cd019a44918d529016551c720d1bea8fe3357ea853e0220a9cbf9b7a18996af0f8c4976a9e5332814cd7705f524def4e4f2b55cb1004ecfc1e0e28a9f938c55c19436ced2f0cbd2de536406b746c5cd41b474a5ee6858113f8ecc29655a5216570689b76646103b71a60a0a69910a216e9b767f4a34ca7e4c9fe37f40dde95749e7f8214da4996bbc161173b388369b5507d8c1a3994c1dabecc88655129a9e63e3b665cc64f7cfb241a2f44b4abb46de0fac591f89253b825cf2e66c18f7304455481b0cb496bc9dd113b9ff1f0609e9ed45315673b914c13753d8c704f1c9187cfface4e5da904a8dafac0d4b0b3aa0403633413ad26f5e2cfeface65feded46d4bb8334b08f1bd856dc83ac667ec63d98db575c999f02424dff5203d4f2632355e5c61bc77589a85baa05377f673f2272d6c532d50b133a2b052cc750565e06123f4268c57d6d05dbf7ea42985c70fcd4460f985b91a7d2a40bb4b054b0d6297fc8db4a1b75b52ec36694376b04482213726d3d87666f2276d3e759bd939e9aedd47de40e372b0132ade7e872bc2a5f3b4453bc58960798aa3907ecf4a21c0453ed40ab746843d79ff66e6826ff238801ff45a3efc95ceeafe35691dad86b16bbfa460f8dd42c792f0917ed8bb01b4c6ab0ae6437922e5397c0dafe019612252de5f2ee389c83403d849c162ddfd535bf26a63461f7d2b6d9bb0b45f5a64c59d9704c7b627891237d0aaee3feec8307789c59e48a5a642c1360a569ac8e73b1b1a2f163c5a64ceb26194815884d71242a9b8a1a3ba79c8446c3bccae9f1036e6a264b74f6f98564f9caefa3977dccd9279cd10c8f2c01fbc591b2f9aa86d695a6682d9695999fd759e717cc1689f875163a0ea788497e0394125b563a113063fe5d349916045f029d50866317d325cf72dd3054c68008332bc68f6502f8538c7aef824f2bc01cadc037272fe50b72bd619cd7b88d6102ea865c96abe779092335b14dd2553ca32a502ed75260c458435afba36850cc119b91acd303f3a68925797e740162d4035f0046fc534ef0f010d2dbc2994e00307115b260ba43a57e4433813949f6ce08fe4564771e9292c7a27d169398c5353288890a9b901b99bec4186fe71c2fbcb335fe51e97ed1838f4ed698d4f0a2774b511774f9016de97fdf789536d6c588877922328ab6c7284a48e31da403c712916787e54581aba06025045c4c92018ecba312ca53bc5d980c58e863b68ec58d3dce9ec8b7fb476ff813190901d046fd627248caa145eac05d58dfaa9e888cfce5166d4e53ee9c53729bc443dc4bfe94200fbf9a88036139349fc2ed2a2356bc8566e279bc48875e2d01cd463b0d1b2cab971d16b88dff7247d6c446b08fa36e9703cf88e28894352438c81f8ef3e973a96d3262a08aaee179b63740a0a19ce06a3edd7a43158c4b95af5280caf869c9f2347365a32f3050b99431b28036f0d1440343866d02792d24051473e59c56ff9e6ee523985f1002e394d61419bfe4a472a7b3c4292c801619661afc0d35ee7ef30d7beadd5d1e36a7b666692b68627d490e7116db376d5950414df5d0b4d505580576451a0e526736ec76141a29e70446035412b99ac1fc371244e1743f49fd3b3cd098dc0f86f49ae7f318593f67ccc908316ec0d0f3af22e66846122d27ed40462b5b6b1367b605ad1162bca67ed423a8192dfec2dea61cd2520bbd471351365d1bc278b87b619643225113798c23e49523fcf62bb5b5c7034af065336809c600ccff3ed3042583c5305fda08f640f0d69ee647013f686cd13ef8086d98cc5743fc366fca8303352dc4fb186ad2147362c26f4de1100fde08bbfbc74e22667a45738fa8d0bf039922c975112f99cb0a1ae7d9fb6579a477c9a9571eff9df6179738c1b1d462dd01a65dfb5dd8aa4067fac49cf70d16020d07717f8fe841e8e2d2026f5bb7710b0b76004a59b460620d0840d1e74bb06cba684c83e3afca5caa6448111b6668981c9f01cc94cc5ab11a6f04eb127f7d317ae6f99ef9ec757a2fd075b0f74bbd56fbb8e322973a65ece5bc093a26f13a10b896b39120e68aced6a5b41e628d1a830460185bdf78b8e9bd865c9ce10dfd0792b948632e26a1c4bcf4e8abd59146bd4c09253c47ea49617362c7da583c38cb9fc26bf8f2601196370869a86dcd3655d5e580212d25046f214ade8d162cd824a9eabd8fd04475a89eebc87fa4f575b23f9f24821698feec806114376c9a805e9790eee2a079b0d5a3b1379d209b22c7f327fe08f9f0a0051e568ae4e7a73c4d718588a06ee0f39ff50ef8f3a7b94a7b313ca2a3d1ffbb291627dbef674f01b0dec6fbc1364ddd512c3034c2ad8a8d109f75f6d8f477bdd4a6b03b51abaadefd02a416aa1211d7e8147398ea6d8bafbef399544073f86573c68002869689ece4adb0c88e205d3c4fb13a1f5569f81e45d72094795079303819f5f23e186cae2f0dafceba36ee0214b0c7bad900b8372e8c5d544fa576222ebecc201f3af7268db3bbba5bde0623fbb1690bea7e496bad7310f3ae1817dc0c23e21548e09d20109ee7ccbae98e9dfec47956ff500464732d4119892e77d4d82f0941d90774561800773eaff3f258ac4dc542ad6adf81bb91f460e0892271b5866b6d17c42809504c18db346d1e318f705775b7b85c327f6d9b5122bb26540f214fd722b33a651ef15dfa814ad2fb97efb78fe2ecd910b3c8a4d2bde2132ceac65b31e051aecefb9436938b91d3a7fe6361111f177a84fde6f73ebb20bbd5a94d4bc9325a9e923f4411fa0e25c0054ec495495b8e4f0515841fa0b0be40ad9275b9e9cb0d35e62951734ab22719a61d3e9f6945caa2745e88bca032e1f372ad2bb0c0dd405fe84d6eb8d8de785ad1e56172b05dc8f8a4b6c5b69627ba2513cc3ba3d1faacc9d4c8f862ba8c9f9fbfb133b7d86c09edc7c63d4836b27dab687ccdbc995e36d162cfd95db083e05807378fcb769b28abe7e9e22da1e225c1654351e496c69e31e05a4dfbcd50073ade26af5b10740e896769b19c5a94a0c333f30212c8d6eb21bf54e2e35a5ed826c9f185313fb87aed8b171bdf0cbc01aebd26d61dc318eafc5fd3aa284ed9a74ad3b901eedeca413e3eb9a50761131e381a2a2e65ce36de1265922f34c2cecbd641fee920ae8a26dcf446f192a2f01abb0de13a26ae2f0547d5f85026bffa7608a4b96cedc1493cd695ca0262faa0be2bc8e6aa74e770755e4015dc8a07c59255e867d67d4a17f6306b95b2ea8586ac70211d1dac5394ebf27819f774fc098d090d04499c9cc5aa4bafbc621652034abd0365e8fa2da1b3ce7c725bb38ecff047d5ada69dd2ab7e131bc894ef5586570e6927355e612b392e5d5ee7184db4bea84a84a9cfe824f07dbcdcd6d00d44d0389d9daee6403dafad6066c972fb38af091f50ef353fe597b38b5cc3d6428f4212e998e52fecaf1be152829aac746ca09566645c4acf2829124fef6e925c3a74f872b5e6713ee454de8293f494821c585cb2633a7d62d5eb4333f5c65f91065621475917d53cc87beff3fd29bdd9ac888cbc4357e73545f4fa86489744ef1bdb99afb984a07962561bb34dc7486b55d8d555aa5fff6bbc41b18b96aaf48c736890fd780e59d8b108d024115b6de1ed0a4d6d5fbbb7d70994817bbe242a685efc87b4e776db5d96070237c630e19e3d86baa1b1b4def9926a976ac240dbe9072867b9ba3fad8db098f36854cd8922fac2ecda5096625ddc1b9a009907d5ea8357d00055eb0c66e5a6d4c72130e72cf3239767a7ea7d5fdde66acab4853b07a1f24360c4f24f3150c0a93f11bb6dadfa875f7256d06bda985e803f23dc2620fcf8ce268c49301648667c54c18ff64c34382c558b1b8a69323fa09aedafe1df56cee0897cbb2fe6400a4802720f00c86dd67a38e30f8f02512e89a797c8d37a52f93f785cc1f618f3c7bf36f5ddc0094b33a3c0ddeeec7b244fc4883f2884adbde6f66bcbbfdfce86dba3d3b18af21a57ebd81eb9493d3dabd1f621e4c227afe3e57ea54393c23e86fb091fd69bc0ac48c6b301bd49bbf8f9520f2f44fdfd5c5ab66e8963e137d6dd7379488368e0e904b394f15793a3f8b085fabd718a14f634d87dd42b690afd8246f825871bbf3913006c2d632af4957f85d52da150c49f4d445b6b9829ec659f2a9fd1f096698986694ecd33c4657f31b27d0e784fdad50c00c9b50a3f2b8555812d935a9c34f1bb8125b7bb8accde19a7a3c58a5ac398feb3fafb5e91c1d34cbd0cc045b94ec46ddc2fafc0583e04b85fae3e807f65b76e39364bda22ac80e225cc530e7b24bba87af2957adafa515319857c532044265ff1c772ab8ff032f27ac62a02f4912451ab5f8d64f4f9729654475422a2127bdfbaaa2850efe3225cd456cac550083f703942134ce510b5e51fe64898b8d025094533111f6b6d3a9626bd517e8b7d31fa46d6dceb775a9dc92b9ac1e74cbf12ccb3acfe1dec75814a63a33fc5ac921e3fd5d4313b09c5db8c33e579f4b97be63214304e71c3f81c2d10d081b0864168672d2abb651c621a8dcf8cc1b15bd8d8a5a392c50ac7b703f80f48553cb807f1e9da160769abe4350134453a111fa219cbe08f16a969f346fba1cf23bc71f04095b90827e64676f98dda6649b51ff0f587ef7526c09ef36ac055f5a315cc67cf885fff3dfc0990f37534181fa5299551a3f9a28893df2177f063e93d0ce3675ee087cb7850647e71c155fd7c2554f1ce00539924879a8d62dc5b6a0011f1c3b7c63f0ab82aee21375bc397dfb4ec185d801a90f49351be06240ff98b7b4566627a79153ca480d422217aec571aead7aa4b4bc353c2c613afed0ce350c5c3f13e399a9fc2ad41c8c9180735d9581a7ee3900be974a80d3ff6777484b554b393816c33860416944da40fc8dd63cc74201a24f1cd4ef9e3f99b193b38aad272dfd59b1543e7b244807aaa9d38b11626ceb1f0d8688293b5a44c3529c41a5b2e5e3b8fda3185322c64eae3faed5d913bb01e8141fcefaad7470472b46577dd2811c6fa6980900e0441e299219d3cf6789196be35cf3ff24cb39afb3e28fe0627f14c94ede1854dd3f09a5d1aa1cb07e194e06a6f304a1948ad29dda94bc59ad17971f811e52d4a7546c70acbc93c16ef5e288bd79b6aa103970fd579e89ff0b5543def32011da4d76d05527d122127cb9a2c0e57d97362a4b49681976e3b746d91bd8ec81e7b97e6de86a4aa22a1bb3af4bf6bb90782d841c664c97475b14ff86d071491cdc42dad2aeafc1939b1aa61ce9c97bea6c1748d9a134821d0b8ab50d23bb187192194257df738a72a0b7dbe8963f659864597c3b0cb6886ce721ab213f33c14b71c9cd264c9506506fb878e8426b44e84257676e1b0144675d6aa117758f206693efc404c97920d5da1a1495dd5e5caebfd52e851479389b5ad1f084fbd6459ce0e5d53add2429f574ac82e6b8d38f855b4344624c28f7599e4d37faff4b5032782a40144da3077f90dc8120373779e822baf16659f0f9202223f966de29d852ebe140ec4a156baf22f0289ec44ffd0e7e9b49725c74d17e166400b6a45c5967d250b99da027f135e576a65e00a60271747cd50ec0a47ec7ce0e0902f5a40fb58b79acf6e30a803c36b3fe938f892f0aa125e63e2d9c08ddf590fc70cabb231ef796de0b968476566932c7b62fc4b26bf0ba940303e6273e697db46f582fc2abb4b463df73a6d5cc72201249820c7662fceb8a8c64602ab067de749f5621cf50033f89ec936b1062dfec178ff560a9eaf1835b4344f2cfe7f3952e69630d683c28d7b37a9f37851c73074ed0ffa6382f7ca35e2cc9b2453fdcfce5628b92357f2e87d98eb886b966fa81b91ca83d1f53d997d5abdb0e650e7401b675da77e3dbf148a8b514f2b1ffc950b8bfa90ae795594c10059f199155348b6af910e1e6d82bbef84f3e7733faaae89260ff50f7c9ccd7da1d5e77fd814f7d403f01c51097767dfdad0f7b24d331c9a7d76a4b9f71aec5d47184e9ff4d15d4f5a5958d74eb35be2f8aba86f5365614c90537758767d4ec76966d275d6e1ecca5dd4cdfd6605b8c331cf097571af95c90547d789ff0504c36c4271c2f61ad0c7f7bffc15c48dacab4f8ea51d2baaab4645e72ed33560cf668becc3aa0fb8e002848036569db57b7b46c63ae4c4dcd5fb6e003a0da526fd6bbfa57270e138675bd6ae6e95f82109e7d78b36993bbf823a3c727eaf731000f013f716f8ded3d98739e9af7eaf166591c591116e12a9df206b5b726dec99969ac054af6173e8274927a2b4553575047955822084d3fefc816afb5e4a94b6e15f5075d582928177498c58369ab09df4c01bf5f98d89a2250bb2ee1a99c94e8637f48261ec697e1613e3b1ead70be047532c66cd49fabe24b06cc34189d7360eb296122a634a406925bceaa42f30b6c7e30e5d4e46de7c3fc82e538f36186cb3611c275f27aad0f41464e21de8de4ee3d80a53d69bf46bd00d343bbc040da83d9a14857a8c7e6f2cb7e285c5b3350f237ba386949ae608b3ee1da0168f9cd9ffd196c410ce995dff87b93e33e3603e273c49e92ec3eb5bc34322419bff2f62979ef75254c21a9169bc58636953d70a246c2a77afc35ec32457fbed23035f4bf38579a5b05a05e20a15b721278dd92e5c82a012622055c48e2536c788131c86655ffbfa2358c0ba1025aeae824b450f9727abd01d6a498ea6e0078f06a2d8cc69e9641d430c64ff4b2bb245cf72f14b7e96d436f72c01aeab7c98fcac614efe6f212baba7cead0e621c68a6c3445d80b13dbab92f66289b1d6d71af6b0ade6abfc71bcc2dacdb6b7e45cffc370d34a2a3a23ee14b0c095e6f4b84da4548a713a2e6bcc3b833276b639496b4e01b313ec55c02bb5d475fc0de0509020fe31c21cbc60f1383645548691fd092d91f0edfea904b9e608fa75c832702c28c86b2f53b9510fa901f79c6fb32f20b6c0a4e231f922b8f5a1b814c0a07e1b6668e8c3eb14f5bd5276593373773fb23cb5b1f013f42d6a00e9028d09d32e9965129e63d6755a355097fd0a5de04e4bcf017b2f13edb41d0d407be6107e3392a5fec7378f1a9742f40cc40f9647c3dddcca3f872c0dc22b26bcd638bba1bfb16cceec9b88b0adf9c8591d85e1c8f4b2eeb86810176b21e7656f6087e6f6f7b41c877e112d2bfa2bccd4459cdb99748512297014676c9d213094f7057cb5c4aad76536fa48c46ed5d6c96e0e86c6b5162b5f8f36207314609c39d2177031b60a6f7fb99c8bf144e4dc370cc6f6c5d228c28c73cfb8bcfea52fdcb459ac8c11baac1efe823520544b2299c92c9245592513f17650e70c872b3eb1f44b36374a9c18ab9ed1f84f048ec6e17f342fee05a5df2fa544ae9e4506884e68553ae147dc66ec66965b62f0305b663db9f0b06e1894f1337e072b406c02482aa37c77c372259562fa7af3ed79270e6684b591bdc627dd28f29bff03c6e53cfdb3d8c5d7e67143ecbc94be3cba99a0037102fa7ae586fe5225f405d10076df9c3d12937d0fe5a9565060709904bc9c8130b68e71f48de72e9033525ad1d85eafaf46fdd3750c7a5ac5b111059e3cb23efaba2799a9e5ecf241a4bdde1c72fa37a7f150e1536a1eb099174f38beb1530523d6d8f8be52cc62d6ba76aff184fbfe9f1b3293461c69b0ce71f8cec66c13d3d8bec474e157ac231150d4e8e8f5e3dccab7d7d36c25ed7b58fbc22d006c91f85f438698b425ad06761288a2744a0430227d46ee0467fef671596c0e4b390a4260901d696975fa3cc32c38dc1d9bfa745153907bd242c5967929315170cf16165785aefbadbb690605020b3ded1b6cc0ebf5f105af2c2c61618552669f8083c22d2736e8faf7330a4aee2fa13037b0ecefaedc0b916a02ff9a99182b14f21a4ca4035a31a2dcd04c9b9cc0331164736525999eff5845135549862d77ea98b75a189310ea2f6e9308f3903727e6bdf65dc2ab217d5b8aa7f838f59fb4c760c6f57de74fab25f2da845437c2ffc325a81332e074b474be975d6c7cea4ab67355a69406176cc33cf69c33ed0d726cea7788ebb0bec19ce8ed862a1151df809d74e32a833f82a3bbe60421f6457a1e14c38238cda175591209a8973e2446655eccf5c0957effad968f210688799fe7c5ed333ad08056089918ee764ce1c25f47a91ceeccaf02a7294b219abc89193f7e1289c6fa314b2070e698eee57b1308f7383b64553d58b6e6b42ace10c7330b65c30ee1c78021e2d8b2f576d8976a1c3c18b698a1bb14d4ff97d79ae770bcca8887c6b03ec60a29f74e6d8d761cb072f7e6aacd3a06412849918426c0e8f298db2d8c0c8ff8dd4a6c0ef89d4d8855193029b53eb794ecd733e673e5216bf533da9a1b2dbf1a0f5d2036ad9e15b81e08cfb8cce3e825f2ccf6684faebe95e19d3b05ad7a4f4e4fb9df5c3106972073eff0662d56054ca7fbf57b61298f88f1d53ab62d94ef042c7d7eaba19c835e5c7c741283d7681cf28147379c586837c1920adc689703fe60878406220147e1491adb159af45793ec44c3efa0b714c987bc0cc67bdc19aeb5a90c2a34a1d7e2e39c29796b5e19df2269075f70fe7c72d361b7daa37afc6483c427400072227de2f4e0059d500657546898ae6d5acc2b8375abec338695bd389a2206ab959d2ebe0dec48c3c18553e24aabea2e9acc6852279313f9a1b4a3a6099346c95e56270729588f82a77f61c580e71aaade7f54d3d500f7ce2742c8d0d5c0896da0d62cc018bb45c6099722028cda8352aaa13f1d5e12636f026859a590648a49c19658dabac7457134904c4153f57ca42d71c4e43138b65a83e17661e051c36481e08bbe3dc01f60506c8f95ffa4acbd3161e3af932889975fcb076ab50d0a1e66e5777a5d48e8cbdb62020ed9fc6f7bf664ea3bdd39f1473f0127c5deba02fe7080ca4871a8a5f0ee39b2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
