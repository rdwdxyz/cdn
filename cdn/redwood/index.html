<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c3298d73727bdb3158abfc64b3927421fa4d4299c670b246c8e0300405aa78873bdf4878da2a5ea0ef9ea8e280b8097876f45f6353cea10b0c78fe5e23f0e9d99a9648df15ce56c0e19cbff5b7aa2c782810b8b1e1def4df6a541ad6df395b25008df7ae846c99c2675c229b67aeebd8a8a1f24e831ddd9ad2086f4d17b1c86601dad93977a7c889296e2061ad61661d86203fb9b3cbe866af1be5e4810049b92b3108c09f136d8fc81400ba4dbaf970ac5b310c31bd9f21e7cbdf8de27edd0caeb7bba696d589d099c251942452ebb0fee69052fb372afea440788a04f2a5c3d4fed4a709216ec9eb702833fff2ca371f433ff1c5f8f02b2c98f7ad1c1793d300de20a291465b149219a9305df4f999179bb544073cb4e4c21c6c804fdb7eb3c85919087a746aaec1314539bfcb20cfc758e70fa4c871910ce5ca90fbb54c7842ce5ef5c5b117292c43563c31c1c71b1e925ac842237226668eed2ff9cd7ad8497464093e2995315ea7afc33ace1805c82282d2508bbd89a2260e81e6d884b3a4f3f576646643281be21198fb42b3c2cde75269202e33653f79f462a49d113b3cae369dd82ddbba37b83509a1af9aa0e773e00b4b4414f7e85350e07bea6ffa3f6ce2e4931daba12c58cb952e065732d21f122cf455a85d205cad28c374e7501f3048e7352105bbe3c4007529679d4d4143a561a59efe1827fda9f2b7dfd18e95bf46a2551305352b5fce1d83468ff3b41245f14fa292bd59d189608a2716c53f1782b6615c2ac7455634adea46e724c19963969e01fff8e56baadc43614dc8dc776af864053a21d6311313a219e3c94b0072f93e446eabab94b933a3812c274d16145e3b400b9f22053bdde107cba786f45eb21a8de21265017919ca129b7a5cc7b5005ced03a01bb7e183c97044fae27005916d8208e92309ed3c952bddc60f23042e1feecc043ebe5f7eb718471e1c383e8fd4963698897cef5b2268e3df9a012f96da62706e1e7b8104def2bafa3196902623c6b4a9c4ab5b663c4475de116b15f5ed197747a9e0ce1aa6a7aa8c224b442d529fcf086452be01ea4099a1ad9630faba566505d2e79c54fce3011dee80961a200c83693bb976d917efd2375f602ac9b5ec231a0337fec1811089d1f36240138a2e2ef0affe154abcb8275c5b28fab7f68e3bdb237055972c17c98025a18caaa9107586252b49bd9254be9cf09bdabd8729a9fac498d1c8a836b68acee14fac1be72c20a7b662b8958f18812582763616f52f53bc8a04cbb7d5fda094c83493dfb2883c5e67ec5a43c0ba49d15680fab6d7c67c8382e96484f839cd26d2b7b80d281d98de2bd7e2e425ca04b436db72911eea8b0d89e76a8d433bc9069da6bb4b1698b8f366b5825020a8f6c154673c5c5d7b1a41203c9bd87163801bf24124a8d7bb16062fbda03053f2fa479a53eaf0ebf00025ed749aebc1eedd615bc0d6288960233e25eb1318cb86a84c53ee9cafc261e24fe06e83e771a4eb2899de55ea9b04b3d7ee35a1ed470c209ff6d11dd53ca35ad7fc3d432c32d87dc287738fae740eee9ac2f86842a19eedfd8d8cfa20cfc387ac7f9597f6e2a6caae0547092ba7d96fd25f2a79dc284812233e03911e8049675043ef3dc870512bc994d1a1b37be4155ba34236610e3a5f5ccc49b3048434172295540c035d61e0eabbe3824f6beec4176b72826d63d0f2de5cd177a9c105179b1d86b1ea6b0bf51d8b7edb20c6895d5997f5e837f278e2c017744857850ee6c8e8166061a7a9978214a039114190ee9637352ddd013e506c7dafd78fe520fb0ba3ced98c3101cc000c87af2dba14ab2d67feb7c4b6f6a2a3cba2c3e7797fa731641accf1a0bb60f3f6512dbf6a5b6bc3444aba3003d3cbf78ca44f9672a41a8dd8047509d58957c02ec4cfc4470821dc5d407e716f833348178be90900cfc304131346d69ffb2936e0683dc9edac72cf1a7cb93f62ad6560db03fcea228e04632e870bc89e8b8d454ecf5696b203aa6f1ac896619ccc0bd1e5b5910063df2bc3fb32de11d8af8f9c9a8c472974df9d33964d0175ae201a68e5b00a28dfa81d0f77909138b52a14c85e98332ed036f3ece64208026b438c181c678745f33ab37d02f519154a2e8fce3a3b823df8f1fddecc214b145f8ab8707d43e062e0ff1e47073cc9ba75d412bab15a8a5fa80aaaec2d0da3d43c036ee614f2ec0f108929679c3f53017dcc98c76c7c4dd669ad7a9a80bd05022190758618c805c9b969261017dcec9d6533460f2f1f67bbb08e9b8dbb8948a7f118e270a7cef8cc374173e05cb582ab1f119df3bb3454b2ea0ad37c1b2f746f99d08897091383c236eb64ff6e10da632eb6318b48d45b9f676335b50d9fd21bfa6a38759f12dc5f9e5a74e7dff1d78a029167c5cfeafeb75ef1c2e0b62ea3a2d6fe19b11da1e48ada35d00e0e56aae16cf62358d56b8f3fa7f4b550837dfec834b23ae67ea67a40ad5e03a5c73f6e7d4107a9cffc5c6d5dd5cbea6a38456694b43df1841fcb149a014dfd35cb402caa6b9c925da452a1ee84a46aa8d728108e518ac38ebd4bb0ff5fe800c5c8ce39c51437b1878d4f33ed92f740c43b3ddbd207b979cfdc153fc6285a7e064606c451d1ece4c665fb85b44439e864b6a744464e55eee77c9d43652f9fbeecb2d3c6a051060bcc91b1023f612cd31e5b13e431930ad5f080a3d881a8208cbda49c7d00991ba17bd9a297fd6c165082f94024dfc69c8faffc6d5fe920efaefc14ffd1a44fe4337cf8647c985782c65a0db4ddce0e13949150907f759eea640ae1cf012e57fc0ba8d000327fca8a93691dcb252b16d086397847eb054934e86b9f02de63d006b884345e48acac68bd428b11ba3422b99dc7e8f64b4130f89a2ef6e34e8deb05cd750075b1a404eb97fdefa5f09eba725142e33b843ed92b273909c0e6b2903853f1f89ad9ab41a83858999496faef449e594384872f2dbeb45c4abbe53f418ded5c4a102c3278ee97a2af6656ccd13c820591beacacf0c885dd0dc6d579cb1c7e761281c4b833547aa01c05d7c57874bcb0985b4bc0b425561ba09f226ac177424ba911df6a6ba990dc84d1bc8f57410c882bf285508686203fbe9a3dcfc0d74850a51159f3ee9aa9bd31f0e1d2e5cfa036bd40990c7903a3cffb8ec38b717e139045beb0effac47822bef8f558eff688ab5907081f53265ea1f3ed91b7505b9886cbeb4952a35c984b6bd220eff2cd344b81a25278050c655f6acf6da43984e62ba67311d509469585b65924030ccf7edb67f84ff90501c0e8f21ae015be1ffb295d19ebab80b79ba8b361af843006d177a45b58649535b06650ab5c88e16bde49ff175fe10b05de92fbae8a1fd40e2adbf37ba1346bf0c426abc966313211312993d9de18a354f9c606388ac9a88efb480bc2f554fb5318bbe599b9f9b2826c93778de162f5c1c17171b76f73465886b9997cb6d0f27d68cbbdb83e46ac6445b26dd6793e27f713e269cb6c19d023fff84a5e00a8bcb24c6c8f7333b5f2ea62f9b2432beece29231906bdba9f2f258dbcff4dbcec8d822ebb1d2ada5707da05e74e5a9aa3c8c89a70d49958f0296f288beb68a2742383abfabb18b3fea041faf4f8f40930c150ea0ec2157a705f6095c2d91ecfc4a2f7746bcf6a3a737b5b42c5768b3b4987df45f6066c2d717d6b6fe15fdd07847482363de85ec9ce1aaaf3004c566ea2ed983cd27f6743cd6f31cd7cbff3ed996b5aa0860eea3393c7d2a24e9655b72f94ddf8bb140a2e92303426793b7ac68be6d1db4048bcfa9899939f28c5f7e32b55cc9d7debc0ef6bb712b4248a34ebb913681deecd13a91ae5c3e1020afd61b32685d34b0c403a922f716b60111903ac932c074b938279118cd37cc1514004a3d803c4167207caac0a7ae4fabcd5a6da05b2429d4af19fb7508ac60b757c56f681ac5ca222770605624ef87d2e9e77304a858c8eb2af9f7a1acfb8a223af21c10d2f3afbde71112b38563e9ab455729a01437c5795852786406637161790e7db46e704da85be6ca29721c2e3cdac6c7f6336c38a4be356011ee609344ca14c106df999bcc1ded5a9a84d339d90d3f58ddab0aa0c9d7e6a33c40703a1bb12503d01e3726204d083a51050e93b3302b384d780fd89179ed84ee8a2a3d2dfa3df605c3c61fadb57f969078d19d6c66e26736234447efcc52281820cf46eb4de8f99d432e8a8f2616b835e6cd9201835678a04f75cca22818bc05475c9291b8591f0e1e2133d8eea61ca4c9f0490fd8fb7819ca1a7034d87efeb432749ca9af44f4d93c27cfc6ecb3656a9c260e62c451fb158ae50b41dc06d82864f3a8449776d9cdf786b3081aab3c96825a040e2ce6d663ceb283293af5ee3a9b878fc975cd1ba23cbcf1737bd45abe8feebfe81520759be2e9431e4d5a64c50bdceec05f7ba7965d0b059910b0e4369a5c0a6196488728ccfa955887b79ca628bbcd9f13bfba877cee6df4a3e8f174b22b6d4219878f30c9c417d9a8ba65532af387ef84618c5214b6ed0bb928c31b4d6c5ffc5013f9a1642c9a79bdc8694a82f5fce5fb8ef7d79da150f6953c45b840241d41ead592398646f9a812950c0aa6bd731b9a0e05bff765a8baae4b69ed181305293faa901fc8a793ff31579d407fde657d0187c6da68c38f552f52631e2116e9edf39d3d7c611a50fa06ed5275f3604c0a8d81f0b534badc0808753dccf51f96fb610b4f403a0a8d06381a4d6d652e782400e7966a1a4b13ff254bbc153d693c1c7fa5dcc3ae26e2389aea6010391ee050a42bbb8a53a77d08d0f2bede029581d4b755e13038a5006abb74144db5d2ddf7ba1cabc9c998e23829dda0df730e29e6401e3b5121e7ee887da622e84fdbcdf05110916acf98e99df0c33a1ee23b679e5e739b687b34697c6947cae250d7198a524d44131d4a73d4d1fc79a68b7f967d07e7064afe5f70a774babbab726046c42e9c473be887e6856e47111efd41df3ec46d08cc1595e6a58dd022c661f15fa4cbb9f36b802ef1722009ebb417af6e53f100f7872885eb1febe23bd10905d7085855e61bc13ad609ba454d2866e138fc9520ea67cf2f874abb23a849df0f1a7e2a9f1434f5188bf5f7b5827481f92b7f81dbd8fa20184e147328c02312a953450e9d054736c620a6c6bc3856743edd3915ad0d649e305e6268bd1afbcd824d9916bd84bbf69a64f01f2b0aa98b810980dba14b09a3d6e8e03e5bbc113fbea6362f3f31e8d3607b305f5996ccfcd2e22414a72a9ad32c4c54dd6e4ac12cd0c942264c63853db4fbf081b4bee650d2c0745acfcf4043b7a09e0de2a953ec8ecc90ed564181a4931ff190736f14ee34fe8a6ca92021ad021726a9dcb9cedd2908b6176f5b41c5247df2e0510e07c1d57415165e6f00a30b03aec5b709751affe429e94728b9788ce187b4ce3a7aeed383aedba1356aa44da644f2659ae723448e8e28d1e1259c286adab61bdb433542005f6771252eff77cc2d3d944a93064f603c6e7a6abf43d6883025dd0275f1a6517ec3ed8b50d89db4b462a37bc1fa1426dcafbba76a99e7eecf5186774a92a1916c6bff9a755d169da539598c03989e28e63269bef8a4f319b73bfb9a95496368491f0e030b9f24f1875385f7fdc23139e80dc9b63678c84f671cfc1e504e79d5febc3e021d8b53c39077032400ed4f216cb28f3cf873d1b0fe13b22d3953ccfe3394c5154e0371ba19d161a9bc89aa3415d6f557cbb0588afd34adcb53d0dd0ab40e7bb8ebcecccffc033e7f9287157f637784e32bb38c4fb33fdc8078f87f89919a6c749721aee7aec0f29f20040b8a8205e350dd9b53dcddcd191f507a075fecbe9dc0c13063b18b85d3ff6527dd98871c5447bb697488cb5d0f7242b81b1ab1b735f78555d2e7bd9ac50c017191fc4aeba75b5fb4dbb8316421ce49537f3285024d2644601c9e0a116fdcb173d6580da8f834a8d4775a74976d38647237c5ae9f9e065251d031bfb36ab6c65f760c84afe754991dc804e2cf89e07043b563f709cf8141585e920797a55d626edcef1b5b062020e208a16f9732c4be6cf67defeef60ccae03f10233641667ecba22cb2a4b10b134f8831237224eb2a20f4066677f5c36b8f536d2371eefe2b808ec2256792734816b2ffef4641057b00c2bb8d867bd150057400238df684839b289dec8be5c7f77c4013dcd07c467228d9cc035b1355d7d2aa6f4c449c0e86d88f3592db6337f422e587d28360864d85526fe08a446d5a8bdc8b1a5c18d042ff1649e45789c9626917ecdbf6fc97b6e0ef856ba4f4dae95c29b51062dafa20f6b5a9eef0293c8a6b805d64fb22adcd333b0956f66472f6cd116740dacb05e1ebfda3aa198ba23ef13e9e6c31c3c041ac3bbba16e858afc9c21dd962eda665893a55dcc5d76f7b9c9cfd1fa42b86278634d897d9c7394b1b50ae974c4202c19aa04b79d57a9de497761ac5386e2ff2313bba141aab98fb4a3190a1b2d9bf4a699649025ac898ac0cdd8753d60e9887c6ee6f4cf69abc455ca1b82c456c047a9538f91e4921c57b4d80567218158fc7ed02c70670b355abd90760b8739974453d41e299eff9c963959b30e478933edd85b4d4063c66808f60da59e7fbcabe0b5683901c391303492c1dcf12013d394c34d1eff17743d3131f7bceb3c06cb9baf1d06c6f9cd0fa4b9f9bb6465206844203f1bf644fb1c6d2579929f1c8d96cebeb6c0ffe369e937b2ec5262deee019f4d10165030228e963929bea4c42e8b59a090e130e8f5b5f3f86f98419eb303db9224cf8de4b5fd0c1ccfa6157662a0592cfc37e78587fc43e580069956baac34a104ea1bb64c4b2f304056eee26d2d865f1027b622979260ce6add767b076f0de0592356d51947d862c57338cae3dd390adc742e781c9c8b7a1855a66584c75afb6888c7011b97026040b56b8f8acc3b16b43afe6c33a77546223e6b32e80d5bc8319b46dd2b311026c8dcd196d3aadaf379a174cbb09f045cbb413441288e05904cf2136a74b63e66f058e3c0841f04cd5224f6c25b2c665060e3b715fd7476107caa8f91d6de130677a74364775d8a7c4bf93565228af2d24bf18e2a814fc27a7fb2cee0a036a6feb184ba77753a0ce1c78200f5eaf981e3d81ff8b8f300b98ea8a52885f5a383e0210fb7bc41ff5b27b8be7c8b5610598246202fb5095b44b0da49d2af79b742676fb045880eb8a3696106aeccee446aa8c9ec95b974a32f6fb913fb3f1a61bdae1ae415f572cc994a32a6a1d55aa75a8fe1689d69bc05ed49ceddcad45d1171a0ceabd5b4f52edaa56eaae4006702c53dad3469e0ee826b46fc666e6d0259f0ae2f66e4381e7c878c99738518f449637da7650afc36362f07cf566956c23f39828e685199e315d8d6af06b4a19a5d293b77aa5dce8df511d8981e52997cf977c26bc7c896aa3f0ea103fa14980e4242bbe8be53d35fa615e95d7d54fc6368d143fc79545ff990d5a0976681f52d2ee8e8850d62841bb15d931b0883beaf871a6d3e34ec417a1d57f6b80b1deb358af101e8e9a0fbd19df8689040e971a209b0d2f2f5b3f577770e5cc6d96319766d699a0f5300271400af386f30854f619604ccadd21b5ff805980c690c528d78936ffe4fa24b5b9ef7ca180f454868dbde79c3a7ae58be014a9da5d80128fc1a658ebe461da3859f4ab8ef890d264b6b84f6b6c87f0930068a4edaf2a103ab174ac2aae328048cabee658498531bc97e44942b62747a5bc485443e5863d5a555c2783bbb4f99442ede973b1b255df79323c2381704a7dacdde9ec5581672cf0d4d8423df297447381528af567b52f0858b82add786dcdabf9d0c4537155f362d271006058b9e8c8c0c6eefbd2c6d60fcd7448d34b95d5bac5547075c815895f2a076b0f1ee37fb236926a9d1eb0a8c7441085f9378171776157a2a3754f58f5e431ef6efd7de5eb2f2c9473ba9b73eacb8862b70c0e15bdcf59db3f82f70bd952c3956f0d991290cc0d646a860f9f2686149b96e17e4ec86b1930dc787d99ff0ef2c99550aa80b035ff1e40e008cb6e08b642f4e02ad09198a986627668404a3b96c141919aa537257e3205a7feb505328c2e46d3ec4905ccbd8f225ffd045e34ef25776ed5b492628ead5473fe74c572bc37f192cd041fbbdd7410cd6b70a39dbb87db019210947a9262098d4d3692527b225282eb5583547faab15e09e5a5239ccef26eab3136a13791f7c27f64a5bb2f63e9742bce6818be3963874f1869e388e9e84471fbed1d2536261747bf907fa592585c2cb57640f14acc32af784bef17453815b01fb7557dc48ea9cfc8afd192cc5ea9d719f5d00fbdf5afa6745ea8df7323fb4b9fa867ede243428a3fd5918525929264bd676f1e9089f459282d78c6650544d033c9d1ef7d175dd632814f72139c1f8afffd3713f276db5c36ac0f9ec64c5ea20a7da2ab2e6a1c4d6d4290598f1dafac02d2741f5c210548c7b54ba3df852772f7d1794a191cda57699fd5b7b1f0bab2b8dbd72c5fab24a8e03c61ba04ae3da7da9433db34345e719a58058e0832c3070c3605e9af6623a38b8c3397cbaddd3185568201a1f58a2eed4638357a8a3291459816ab9ca7f4b0358ee391cfe2fb6057a34dd77e10c8c457c6220456aafd5809f8475a8d92170e3321693e2f27a43d1d5c7d75d1c189449419fcc971120f2cfa44512e8c3cf40405ee5c3cb963e5754adb3d9bc806df2c3f8b9aade49503caee4f5da70a5791e2beee1073cb38e20614bff979134832d077dfaa9f4be65a4ecc08f0b3cc86f62666c5973764c7baf6089a8ff8532a3598adf3b09094fb16df7cf50f60378835b445fadae13e6846856b8c85cab7f8a47d41b0f092f0c6a9cd8859309d9e21d06bed4c4ece2cd49460a00fbe0a9b7dd2b2157033ce7ee8c15e1a58fe4a146fed6227819ececdb2762fbb83aa365253c4047f8f64f47ba49395c85049f7b8b6bd06149e90eca77f357dc78133a18bde0bf9f2787f52ef1430e0a0630b81baaeefefb41aab574f3b1cfe946fd676070f88200a848a613e3f6be79e46d1c4e99da98da4cdc26d98e64f140066e98b216df71ee1c0327d288e02adeac86f3eb74a84b2c0e6e1e0f949cb21a68d1664638399b119229efb552133790a8abf91ba0947af205f52a4562693b3596b8071f19a878ba34f610d51d6d092dfa09aaaddd5bd6a4c1883acd9a7eccc5eea3d22db4a781f875aad9f772638aa150d15cbc8dff7a13cec5e47827b9d8316523d08b6f94fab3789ef710dcf81c80391ca167b2593ca321c2f21afbeca74a757aafdb8021ebfc1844ec2345fc1ac5c7fe0c4998f53e090ccd9b90ab4c2a69e6b77d4841e2ef7233a5fe425f9361b57156b15775d856e1d93c02183c6a79d03cdbca44814a485fe447d86844c7dbce1df50410d895c3d6af7970f3c2edd66e1a26316b26b7a71959c78eaaace289006ab1749e5c7f7ff975c927b011dc9d4cf6f22770619b4178938a8ff21f6f579d146884458fa3dd906c4eb356ff4bc404ba5945d7b337e17fe58fc63d407dec7e1cdf3f7eac9b6385a2c596c7eb44efdb685fa96782f8340b4d205b057f0d3bb963ff5b46b05b113e1e6d35d69cf2f6e6dd6ac148651e34e61c1bd2d6802863eb6abcdc4162dc84f3217b71e0a6cdad35731214f58a6b5712254625d19646efb437c3fb4eb469c0c720efdd1d9f4362c7ffc540049aa42e25a9e3fd01af8dab0da97c788820f23a2c9a458ed380548a789f79222f79eb7cdb821b070ce6b206c7f00da46397226dd0e599c3cc1b2ce214532f1477fa69dc3ec62b7f6ed4376720f456015a6d25b06973daadb877c01b3b2f14bf45f93b8819cf71641ba7037ce5238c8ff3a80f2677b3337dbc9356fe3e89b2a4fe6208427f8eab04a8ea358182b1221adc443fb37234c48d65301759dceb286d0a757d984b355286c1ff4553493b7c11720c7ce97da70813a06eca5c878c902e5657bea0515e1aceb94be0d5501ab1845ccedb6406bb2bffd7826787f41fcf1278e6fb82c2ecd641a37d715e6b6109d5a6e6ac0d66c393200d2d4b68836f50ebbe6fdd75fa1da28d28a9dfeca6edb56b6d0672f93b0c022cd7a914dd470e0f45d29f685acbde271a1e2d66074c01777fa6ed348787e886c9274999ed40eb8ef8cd6cff362a0d2730e9d0a314f737a5718d134a8e98ce32df29662906b596a32d0cbf831e56498344c73b152734ff7df85955e78c200d35efb65b3be3b3cb46b19d24cd847ac10139e50babc0fe4a3914658b568b345cfbef9b011e3509ae664dd0eeb056a622c1617acadc976783946737ddb4b12230d2fc3eb1412da8b2d95c5d131356c4a882aceaffed9cbfca3e63c7d50428388a5e65cb5235ebc50b0162677073fce92a8e3f1c80504442937559a496cc7bd7988ab4d50dddcc059eb499b8fe1d2f3edd0d0c6f7d3dee4dd459c960480d20a00ec44d057a325e29ff607f4f9eba87caaa65b57ae86f41ef6af9699d9c7422cf0823dddb398e5dfb9379b1badfb5a78a8be5319b0764cc46e1afd02551da6e483b0f4941319c5021a85b0b58973191af4da3f8e96aaf41cc74f4b997a724a8d1808b29d78c531e4665b2940809df503df7655ddd93eb2afaf9eff7ee4d21b0a736569eaed3fb9acedb3c40ab8ec4c0aca9231d5cbd0de8958222f979992f61bad21f99276a57590f7115144400016b5f6cf4d6790bfbcb464655c4e83edc100c32c3bf6fe30d46e7c9d47bedff1828a71b074106df5328212e87db3a9f41043cdf205549b30a952fbc8e2a4ae59e7cce1e779cad6e26a40efd8a0d7742ffbb558a05138d660b45139a766704eba6a920e4dd993340f82d4f57579554204ff35268c2e07e5e1f9c15cca8d6709809501fa18e212a2efee88c95439de74b1246df787ab484faa1f7f1729f3f0794b6cb4690b20da4745ed55c93c0dbde36bc2af5e80694ef413d3112e1af411e2fb26c4318749145732a677a89f484beb4d6a114a0d231c0fb5c2bc705591baa842614bd6e442855a93acc5efc700c08a1040c8e8efd160982da5f887ef50d7c1ca59d076836acf6ab54b0272d4e31c91e6278dad7f6fce487597c563b4cf97a4711a54390b5e15394f4d1ad136e19eccb2a447b33522ddf606c0dc2f84da46a89e65483aab0a13d5fc21313e0397376ac2c3cf7e3d389bc1d57adc66793f7df14d13b8db87765505758f8d709f25dc5b0bcfa081f9f2081e4bbdf95b61f7a23fc010d6c6db8c1b746c7d142c43c80c5d81f6f9902be6a690e95cfb58aa97a72e59b271700883e934b8de3465ccd1d0f720f0e336975ea9f55914a6dfedced089e36de8f3f52783b705d6a7333a7a98310b5ad032ee95922d39a3ba056019cb921b85660cb51a1486ad386ac58db21de45f699d9423a4d1b2c260cb733ceafc4f6757489241531061b681d376c2c3312ed2aa9b5cccfaf472bd44986cc57ebcd44a88943b0b87a90f6f48f8167b76180505acbf7b927436e3052ce1436127e6e6301e832aeaaa5b7dd38d77bdfaa7ee02ba370a301e1e7b87bf2d726adc95d59d49b261e0e5ad4aa942bc1613dbb880e565e0480a13594e584811bb7720dea7e2764b5d2acb45f419dd4be63e77cde7b01594f3a48568cf5c2f9703e145a8a160a500437a8ff0a3595e0ba07290b6df5b4800e8cb44941231221e5adc8bbf6b8d8ee2fefd90952025c70783b3f35a3919b67aea8e9bac84fc5dd8bf868b6c82922e30434b7216b89f8949bac786689db1387a0a64c97f064ac5881e171456ba43eb5a557f3d4663dac3c2cd8dbff315169e6e89280e8fff8f5970237376ca94d637a8a887a62f2b01bf14a723363fed0b902a29fb259c099b8ae62d9caedd47ee78f2d1319ce0e965e2cb5f5830971d88c4eb3a77014178c629060c8db4f563c38a451129f85939ea201cd62c9cbbdeccc6edd19e47d0aab655b49633e692c5c4a2b60c893d1e64c96e399483d1fd160a308f5e13a07d48997fcbd07305db428f802e2b7738c9fcab96b97215e0502c68cb8a1ac342eeaed8e7626209448be173cb3fcd26b1b633838ddf89a72375719565fd0fa74efd6ac593a2b9c5cea04a68a93660fdc41f323467a60cc5aa5990b31d9a074dd4932ab349dc345bc244abbd42746bd62b080cef5c31f755bce2ba3cf704680d4f53737e74de82863e35b8226ad9b33e0cd67d8c07b5db093a65b7ca4805e6d86afa852a78d21ac3831a22087421c445e02ed3e9a60eba9a72f08319ad6f1b7154e44a8b40efca2fe5b8777a7673311771c788bd17c2c7e0b706c82b1c45a66d7ae187619632789a142007c40fdca6836832c5f4e6556754e218d1627e01ebf723fdf728652648eda2f04d412cb5829997d26dd339382f3e8f06815301dfead076b69193636688cd145df9dea4075a40ef445d576e47d103798c424c8152763b2e46ee1a7564b41e03954e0675a9ac48820d583a2c00cd417e6c22d73913bf1c04c68eb432dd012a4e5b5c699eba349510be322aa8a8dfe136bbfdba96fd95f9b0d54d2d99f2df0bc5080f6243f58b61b3eee35432c52228900b92c655baba7c851bb406e89f461b5299b42aff299c2dc659c3782103254fea51236f4579857657dd6b59380f864b9b04ac59c3aad219794430bc09491d768cffefcd2445f6591073bf4f54d598793a8609a6faafe92ffb24fcc8220c1a20105929513d04ab52f4fa071aefdfbe612a0f6df3f9b1fa6f0e9db7a8d195a9d6a5fecda7720d043c68f8884e87f1acee756fd53cc47d30e401130ad5cba6b7d1b0117dc58895493897af6b8c0269d91224f3baab70a0514e2b10f9b8d7c642a90ec5ffbadeaeb9d4a49f831ba6fd7de3bf07ee71274b0c1652be7fda83a841b6d51a006f0586a7ded13198f04570e546d20ab1ab1b29542531256bab8c9ad862fa0b1d377847bd17fb84226b52ab8a33be03ae6b18f3295765c2352794fd8d349b3f4cdb528045572ca2b696367e056267ef02fb22a02eedada78b92ee381f51730f5e0f020c10c5cc7a419e4d53098ca15846d675cfab46780ef440fb8dae4dfbbf2c08fe2654317fd3373d02acb52f80aa0daaec553ff767b56fac23c28d9ac99cca9061ce21bc6429e375963bb68cfd508670fa575e32862939445fefc07080c20029c9509d6348ad2ba2cd8edb2fca1efbd3ca7f3ac9995c63dc595fa82b7b02ff8731566521ce19339dfda6a5e3654c0187fdf05307f53789affa427ba6600217fd3659fb74b56519a6d06ed0c2a49fa0587ac2ddb1aa318aa2553301766d30271d1c74538634272492d504968fbabeec440ba654e3cefbce321e32b7883b0b69cd89e4a67e5f6aca959e14a7b91b4b4a1a5bbec2baf216f64492d5b360b15db38e6280b29b746cd12b768f86d45c739d450a2e4d395d6ab89944d45a0192c2fd43d44b3a5a672f14d599390c168bb359018fc2aa6bcc6a0b900f85c864a6a85a5797524e52414491165dc8d0847ed2b04cd55b2bd39011d576296d0ffb0a8b8561232b74f91b10c71a241a7504c58d04bbc958a91addec9b3b10b7e54d5e0e0fcec8fbcd2b6db58d6351f336b70ab96ffb40d7ee51d03162b8fb7df7261c3ede9d60dba76a628dd0fcf038ed40684db0760fdd26ef49ca636bb9c3b9f04c2a97647f0fd079bd3f230bdbc7b8cf7747e1c2810fa82d63115b654a445f96d781528734c2538dada8314347bb0f077be808bf4b62a0428c63f40735404e591ce899bdd824e57ff74404fad3c25bcf31d263fffe1034ee39b6881bdd7690765bcee17eee53429a4c9380560ceae37667c366485bc7af6fb28e7c6e928a58b87ab8241f8ac2dac7562169c9506d651e0232f460bd553842ddf0e078215cf57aa79c50d7f46d43a36bed4355f73a5421387c72e6dddcba00c5db7ca283ba15174094ed1087b2c84aa0a8ab0e9b5ca6e08018f92075b4052954e147098c0e4aebfc0ec74282c79edc3315a2ac03153fc9ae3285c2a9aa6c4980edd2d57b155e739612a744f4240466a2b9af038e51fcbeeede12e395c13f710f1844d5ff1880179e30a5a8b62470e9fe1bebb3b995897cfe0357cfe97928234a867d99d4683e14aced482bdd3d2d4a9bb768542ef2b7170430ccd2f2ab4d0578b01334bb3cb045b58131ffa3d94f68699b50159047127dea7826e48575597519cb7a8055531afbd7f30bf8f51eecea72cf4bc8613511681303510f6099353f13a04da3b3fc894add986ed7f6d128112eac8eae5c9ed146400c649c3166c969955b0778871f9ba5a8b1219726494af8a5f8c4f0d0043be6fe485e95ccde2608820a339c9b8fd09b990372f9a795f25d5156d9488b3634f8c58da366c099fbc6176153305a3581d0583f7cd10d564aa5d071b225b613a366530e71172f0363a678a395b6faf445a9003a23e312510c73dba691c3a4829a296eb8a6847c24775ac1e44c2895952bb0ad76eddff4874edfd1ec0ffa7cdb22fa730a3c4e774b3bf89c9bbd98fb20e90b97018eb015810e4102be1c7c11057c4b262a74d93d158cc2150e5617a88ffa8e7084515d8955d421d50350aa322867f22c9762d8314c96993b4f73b5886f6d9bfce0624002141171eae3a5ec9c42fe44637edf6252773fb112da22f5a8ff05af898807cbde226ed1f7e7158ab67ecfe59c1f717a9514289c396a1ceef25c60d823a2321b09cb56b4f6d2caf73a11686a49b654d2114c0054e3779afd7f03ef12fe609a834e67a65e28d73c379279e6c987cd387525c662babc095ff5225fd830c91988708dea07c1d431dea1d7dd4b73afd97089e16c39e8c8abcacf4e8a4538f6438ce586100243d68ce259485475a7066c7dd6f0ef0c2547a5ca049134355a3222201cffb7840401abb7c8fb91a4c8a288b21a9bf47cc918f806143d5d6214bdd22ea75170581dc2f3482c6d55b0acadd66f60cc3e44d0a1f5912394253fd4342a7f03b7054ac79134e5fee8c389df5c34b50275bb08660814ac38e56a8d8cd5367192464dc1da499e824035e68bf6e1aee650bd22e4895a181d69de70ecd849d1c3ce0496c2a240c278ea2b6fbe0b3e0a68f732ad971e8fa9f2ea3d0e64a2c5f6947b476a8596b363fd1df69b6185b118c118e2be33471bcc01dedd2169cd3351fb9f07f02eef256ba0999fe4943ed21a1866bbd13856da3aaa5f75cb3f67cf6455e52e715665a3b87a0753a81fb7b280f6e4a62375980b3aa073f1f3c844eb6d545115b2baefa760f2c307531c117c9fca9e628e13057a6db142f06ff73a8cc09f682058fac64d0fa9599911dfa3a8d36b31bad2edabd3d68355b2683143d1ed4eb0af4278d464acf50035b0f9a86c95d508e3294466738a15d660c12a58974738896c7a1f775d621571d7523ff79133062987a012405432ad0ff316544879d7573585c599bdc639d3645f2929d12d35c771286454f5949d4c167548182347a88fc5614efce96dba0dc56900274f468899f6065469782a48327ceab9e3f2f7b15b68d94a457ac0871e90d637478c62e657c0d1175084a2af1a10f4830bd423744554f0f79e60488f5dce5d8454c136403800fdd41b3bba8b3c74dc267a87175ab7a7b69c068864629f54d6aab70bd772359f9f057b19b6a41ab2d03ce14b60da1d4aa517055b2dcf86b16cdc50e4c4e424dc491b82e067a8ef4627985d96f89b0fe629c5615b148a664e74e3e43855a8a6cfbf20f0e70c60efcdb920f1a65d6dd6f93f473f59df86cde06da3f0f8f42598a8d798afee5ece1963a1f167271d576bf177a6c4848f2962c0ddd4f388fa037ed22a2ebc643ac2ee1bb750fd1cf345686fd693e138d117402a0834e8054beda296a7d6bb404725b6f98d44e81b85c8ae69b07e2ee1287864c65859cd389a781c52c70d51943efdfa2d5fe758aa2900401107e7d67aef00a8dcb00f2fc6edb874b6e9937cd4726c2f103271e708c9924e451704ded297fcb989ecf340541ac0e7f45c2d551cdfb2dd01f28e4f7fd03c4c011ab8232265aba813c3a777bb7f6629d6aa87a51915e47dea5a42d5d02b95f0ff34b686151e1a1b5e44ca0ba333ce5de67adca5a70c273825e440712e13a08dd7071b888a777bdac782f85be9f60a923438aae1a031174e74f99e5b8394d0d4d04259d150261f6a57fe992541b94c7efe77f98c31c9dba992bb735012fa4362b51da8710311ebb1cb1fc3fc59ef9e95b0997e31bf6d941555d5522339b6384fa83b94f087490747f57442c1ce46e45425d115cb0d3555edc7ec3217ef530f76a954ca92b3c7288251ba03e1fd4f743b54eaf76dbeac33dce1e3ee0ca84958fd4154ea628668ba7f8a91f70d899ce164d309623f220b18ef9a792cf015b2927f4eed22b9093225befafdec0ee642b35989f4d39ef5b743ba956761d574e8abb933f2f553acf87605e4c9067b3c33f9f61867f3b635e17658a8b19965bbd8cd8743042113ae5f2f2d20d6b0e69e4bde5988ed0fe023b97d09a0fa98fde7d16b7bd224003d2dcecfeb6e2787fe3a81273a44253e6572ef80b8546fc26c8b867b5520afe9ebd44f34d75ee4b4d056e6417bd513016f8c333b568887dc4f89d18bebebdd319852a115fea39e1d71b411615d2dbabba64a1cb833be95c13b1f9f4860677b2f995e39022209ebcf1aaed54a94b4d0895e577fd841c8d6eca65b7319272d08696b8148c10060d66cf2e091853f9693435261a8d44132a108f3e6f248992e5e93e68d45bce81bf100ff8e6903fb69ede0f32dcac4ff896217b707fd04f5f287f8281ccdde313a29b5b2622dca59d57073303bbc49c209da67a91f1b3c574aaa43e7ce6e956928b0478c0c84920aa23485a572c984dc72f8093d281f0c65ccff90601c7b997c804d7f25b0db76373d29fcd3376a76130f505b871d0acf62f1c50681445678368f255deea9aab49b15f6436b2de1370b8a0bbde337aec9aafa182cdfee53d37693f30e5738e9102109a6af44898f3a1a3125948cd5399eb59e29365d84dc54ff9a415bb72564c09be81c4de9ea504a571c48b3d6dd2ef3f0d1c9da2cfe06c498757ac0769bf42d9d6126d07d6a4ec8a774c2ada5cda39c944cccf5a2bac21bf94fb8623b9f0498a15a9ded24aa082a8d45301c9db3579d26b2478aab49671509d46777f2f857af4e64adc2ed8f8a3e36ccb03c6e6df9842d4311c6312438cd30088daf5d6ca3bb6c890f792c7ffbd323d0b5b3bb562b58fda8d57b721ef417ac2babb8ad228a95a99dc3a9cee387db455b142ab133f43a08e9b758f7ff196333572c63c0e03677c3aa03121b313038826572246edcd7e14c3f2070948350d303052e88dd729f621338c68952dd81276802223b35231f5a870c219084a8418fb0fdd1c0cabba8079c796b5434540547742bf7d4230de4534af8cbdabf8e127b1acf3e266e4d0beff1fc3da2d1c27c10525c25d12bc006814ee1b9c2ad161153671efd1185e00635a60c20d5f7251338611fea06f103f9500e6bf4206e827f360dbe2b693c3bc71f2b13b53cedc2f93c33cd9afe26a5ecb1177d3a66adffee4578b8802a9b0c3151c092e9d0fd048ddb1ba07945576d564e34f8e67e68a8b379dff97fd1dee06ae9760166b317e161a60f1c418edd83088e0c47c7d3f995143398515daaff1b3756b2f859d8062de0181a0da1be83ffcfb0af71487c6be560090a1cb2fd97496a83e16d1d8e4871e3e585b2e9026a6fa1bcf10662c2d5e596a48ac8f131eec611a3a702a17238f9abd416fa9adf196d4d8842cb90ad59e4cbcfc80c5578dd0796072be180a856d97f85c27ca101d0ceafb3b7912e7ee0726e84f176d2309b69ad9895cfcc7f4099a29172bcce8ff92d4bd4dabcd05d517eba3b7edf9d4f59a67703108326492d171b9572fd452ba3d7e4fda455836eddeb156e06007f07318fd911adb1d5665","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
