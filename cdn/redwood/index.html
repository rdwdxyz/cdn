<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34396e5578c7f03ffb47f6a58b921e9c1c0a30d6c6fd19c18b7e29d057cbe6360fc32499cbf93517059174887c70909ad64809f5ae391321c0b71b61a9a14f8aad3906f0811b04a7ff5ab97b4b5dde5878d267f57be2558888321a639f5b88e50e86133281992b8370bc5570ff80b1ea708861cd3e51930cb0120a4f76613113d78c7f6abad0905c0a14dfb55e486fc39ee09ca8d0b3cf920f8bb0edb32e2f60429a08d8c781f18fb4f50541fc9ec6ce357375238873d3ac409b2d257a592c1d22de5fe346dea8ac19d7b713ebea9e1f7666b01cc04fd8de8e8cd31a880a5cdea7732156e27d64cb3c8ad01e87c5a96c02ee84cd92741b422ded016299273801435323fd190740fe524b361bca1eefbcb8b5243035536405ceff81d9ff82c00f6f4e55bcc68aa582c02d01317b25ce4541c1ade66e337763b95ca844ffb265ca3115cfc73798e38cb25f0da91ac577ed3c336eff3062a2f47361d7142f8d4fa6e6a6f68f9f8086686622e9fde79fe00b709f301c2a1f64064604be048713bf42a4f6ba58c2e84ff7d45a19531aabbb898fc77be922882f85c54cc6e293834ce1c01b508065c9572a8e1257c37ab99bbced19354632af5ff5c8c7b21a79cc96d8fe1b602120cb3a4c4a8e55a8e55b588dc6b9ea2b101fe0247e6d21499bbeba49ea4fbcc58855baef9de27df5f2837e5bc13c0b2b01b821fd71d773850f5250ff0023a3c33d9ade00d0d12c7bfc1c18cb9cb758d335fed0aea5a915f2cbdcca539e2a2ff8b881077275efcf2abac84a6a8fd8bdc7da5ca599cd51bce9452b0105e2c719438951bf78c5d271229f45092758102d5a622dd18c1633217fdd36c97db9babc1925d1b40f47678606c2b140517147b363ec934f6ef2badcf13843336b7cea3fa60371468d958ee34e4a5b87c12c5b2ca96d27098d714032ea0fe0bbf77a65dbb2ec4c4e61f729273fcefe0a0c100d28e898b3157140302bf601cc7965ef64d312868ff509b1df2c76fe0ad1f4b63643c55d3807220ff9ac2f3f116debf94a0388bf810c2d6bbe148ff28085a51502b9e3b4b3e0ce17a1b91238f3d0cfab2181c9c6c0cd8432e531987f0e7104ef83f28892a6813e1680195d1a513e0707eb1ff5a867728d79e10ae355da3bd5b55563ab086d5765619bd2a6030c4c6c704f0b62704e6a0021ecc1a6eb801a77089a70da461bc4a8fbc7aea3e3ae7dcaa703a264169724652b10186987c37146f97b10e0b911e2abcdd00c94673818fd51bc16858138109c0917632cd778eae0f9ff8ed80315c4344591b7f659e45900eb06c7b750efd03b22b3d1ae96668af531529426ccaffde43b4bf4997b83c51682ac61cbb133d5c49152a1d6ef0d20ca802233447fb7d332564118095cf01541a653a3629f87384ba0487fda16cbd0fcb3e33b5291434fcba3eaf1a1defa8d85addec90e2b83b2b94c034977a9208786edc9c84d7609612b6592eb70b26382abf9171fc630d536d33b6d1c6abd37c848ec1d0fd64c7644a6584badeedabed1bb4100b9b5b848bbcc7160d4ca1a2de58c027ccf90e9db1db8bd391473e8f24aeafe2e23b6015876aeac72b17f2b1825771c402aea32dc81a8fc0ffdec379fd774c07886590784777ee93293d4e347596dd2d49f5f6380067f8a93ca1d514dcf9880d5b499b460169950e373d7e72a7838d89584f75182148b0d6caec854ad8b1c8bfcaab23039494bef977a470ade29b1a5fb91beef0e0fdc4b0db6b8ee47edc4a4231df8c0d546fb4b0496c621f75d5f852b0cf66b310f3d562fd26e2ed3c3e575c8aef3aa75d29eb24e5ce8e7e1e70779cd3024f8edfd92109352b3a73ea54d5d41728a3d39512660b8dd598f49de26ba6da0f424a7cb454d7edcf2f6e017c39b70333f7b132e38630b21d985d11aed23fd88de673ed361ac6cd475a21854b7bc3c3287a1a0f2da725b5e5419a25f07d0454b6f9ad3b7d609966a54863bfd260ddd7794e783af60171664f44d5e747491c00676f2f439f3516ac28c9c4841b1c64f2be3387fc218e9dc55b51e9a78a519215aeb37a5546a8ec0d5009253f4853666a33eaeee5075719b34d6f1c29d997eeb1e819cc1640eab21ac1ecd6cf4c197ce88a89d4d665fda1362e2bf1e4d46f726bc9b7715b83b77d5da4611f5d03556a0fb97356593a5757b4f23b557b824b3d423412f1c6a3a8562cabd1ce2951f6ddadf828a1b3b0d168194faa29b103c58071164c744a4d4d2dd05cf588763b7d88ec59cfd4d3b9a7b109e8f6234d11d60975df452b04414accfe7c4bf0dd91de138d5af3b824eaddd487b1ababc6a4167da22b9c8ac6058b8528752fb82331d5c88e92bd3c61ef5b6d92b0cc79706a88808012fadf7006cae100ea9629e812f7ace60dff9677e7c7ac7e385ccf852358f7a1601df33f42ea0bf60112ae61327b3d53335d19aec80ef87355bcb72911ad593fc08700b7912fed2c2bb900449d62cd8790b73ccb1320674040320857fa808a171d43edd8bb091ba10bb456560760f0209ff6a99b55b96f4390a18b019d0079ad3f3b95565b124ef0caad45760f6f5540569a5370734932a337e928d71aec05d14767b841d0a09e141573adc7fa3084a93adfebdb68510796720c143fbe1f44afc5d9d4653a45af6021496616be7b08baa5ccb585fb5eb18cb411e950ce308f4a2643ca98278d406bbcf9693948ca778682ac095a30c227a86191c18842039f15fcb0e75a36df8cc906046fe9b3feb06ad2978849b41ed248f6c0187a7f35d96cb18ad02309cc757135a10ea7ac880553b251597c8b07f9d47bc9206a847318a7d957a64ad7ed28eb67463ddd2a16454e9ef2cf9aa1df0533ee55130bff856b0b3e52829d9b87f4d541939f6242173401534c9d3de7e6c8ff2cdf816117caa2b6fa568e9d3884489dd793666aa7c9d34dd983b3839a4a7d7db0f1fced41149b5eabdc5ad284d60b771b96a44d817e3c5df1774ec585f15a7c7a62811d919602710c0283ca9cb2f60a7fb2193c53d39a6ea48341eb279e233920d84ef9f79dab50839f8f4c121a09af324154aa43813e1c64de7d279c174bfa17b325550185c2ddd842db5dbdbc5cd04a6d3747d53d140ed2fe36aa196d1987c656030035fb1f9882f40bb4597939eac99dfff084fafeb4d0bec4158cf6aa4c54fdebb6230049317cd79bc224b0243323614a9c7977e93814a526f18b7fe11b4397286a42dfb4718a51d25f54ef024d7c6225fe8d5541b642622a5e62c720d98c6a9363ca761be2628eb271c890fb5e271e6f8822623f71fd8eaf7aea434344f3a2258081e8299e8b739677150835d807123cae153c67148c96ccdef498ec5abc286af53db71620d7ec0726385189cce10ef55ccd6afb3d2baabc98dae8b13269eb3a0b66c9d5dc901775b082144c714149c75c0aac09a81693d818a48fd131415b7c9f793378e461e7805d0d29cb7c62f6b5e3757473d1129f7c4a4f530a8bb91b700eeb5f2ba3cd6e1da1330b2ddf5758769a6f25890f2fead93f8fda45c61a83a8ca48524dfe010282e7dfc465d5784ddd763462f795df3ce4ab62b7346c6f49146b10285a976a28b56d54a15f58a7f2ef75d615c923fe7c086e2e06ec3145a345dcbd0130edacac4de6095e6ee1e542027b1415b985037342857e720dee732cfbf0e279fab1be77c4f214274afe4244def89fb4a4263f878c81c1623da3cddae8c4c16f45d619839f2257b30ecc61154bba30d81783b9d9d4e28f139d643a9dc093689b726ce334920d589798a5388738fbce4ddafa3bb04223a2d83c0da7f3bc5c0a6c85599bd38301beca35464a5c5ddd8f8866190264eba017cb61714699ac03f3ee770343df1ef5f6f460acfceaf86b3bef27868fb9434e36ad416bc708f72004a6cfe2b95d6d9ced92bad0572b686dec1dd13a35d306b622662eecf65fe02ef88434d7f86bd2a6314252501494691eee5b3c0687c86279fc6fb45bd9e505f4a31fc6be6b5d8afef5517da6a2504ce6d6bc10f4c4a9e74811b8949b296276ddd59d23b4e43afbda512d0916a0a92994da085fed295e476111c8dd0c4c7bdc8bafd9d93d9d2afab6e2a30e8765ade33fbe3af80d5f8fc7d64fa6d70a4b5ec58215c5e18751569c110afa13d0eba8f192efd2c5260befc39b1f3e4ac908a28d990d5401be3361c72e32ba65dac8ecc38fafeaddb739a3cba15b27ca5264e4f4371672c7b063ba7a9603aa8abdab0a0abb89e282f344baecb380bb3edae3dc571f948cf74d67e876612f9800c86930030adbdb193cbc9749e795d684b0b4b1c5a5b0f33254774e32a84d77cd5db1d23fe9f0da2355f5f185afd36a12432abd8893dbb8d93b49494894c7d83668ec28d802342b0aad401cb5295b2bd2368ef720a7be32dc85a60919d7eeb453ef4ea27b34aa664f6fdd7d8a52211ef3c63af7e73851ccf7cfdb8742a6c9443a0529eb2a10e48a86c5de4542581f142a4140d790897e54b2bd630c03d3e429b553cb2120b99cc88f9f2f7c81a94beeff6b0dec09ac9011e9168ddf78ab3604661e6a11e154593d1941ba642b885af611c085b51d0b192d72b501a9a01ec1b682088e21d3edc80f045838f0712fe25cdfe31da1b77489486ad23b3ec8d941170baba43268d69b80b77b34e0b878dfb490b57f4d13ee587a12201ba84722c5464a88f1243db3906e4b5c444d2e5ace8648bb8433d3d6e80060953164a40ed68c5bea6e288df36a9b5125bfb865fb36a25798a7b6418bb0302a00081397ef1a546a475e696164d7a30bb623aca2210bc44579e48cc3315418a974eb7858d3d01c3824264dca61a31ce3f8342451d45391649be66a08ede9af1ae2c8bce2e618ec6ffa1db13abaabe6900edc3f19cb55b1cf5ac086bd753014d6ac53f0da75dc77376c2dbe05a2e01505ecbf5ac63321f5926ccdd90ca4ae4195c30947b1d4e45bf8681a79a18ca0703386447b5e2a75ed94fe2db95528fda79510a9fe00e891e21e6023df756a7158b509f8369290e5cca09d5674cc90cb643b0bd00f9a0864ae3e7933c5c64e7cf14023132575689c35d61ff85d9c727fb0bcfbe1a4e513cee242e74c178ad21812392c9241746f316d882a561eb7af6195505dbe8f008d68169600c7a83108ee4dc0e1b4e0c15a91273eecfb1cedd497c58c7c3db8417dc151d36077a46d2a2d13c85bf70af05a9df33121117151a58449014a1374cdc9e9aeec70f468e16c8feb0f5a1f5f5072fe2c00df6481836e6fc2ddc79f666be81c8ef16e5f46f6d6e6c833302f8d29fc53f60eb8a32a638f3e7150afcff44949fbb9cb180e49667c1f9215edee625e937214eb1150ec3f3c75e7127d05cfb17e8041b3189029d141ae32fa5881aa8633daec46b1c2b12704618c7c2b73e50a3f8b966c476acc1ba52d4ec223c2b8e21076338943b82bb6304d81c610c88dc34b793bde88b441eadc697ddb3b0a804302e16649707a5ce497a65af84e2ffac4d9e6215a61b305a8c82c9f340baec0929f3835fe5d30623ec6810290b53bc0bef090527611153ef5f331e81c3f9ca260f9fc0388ebe00bb7ccdd6845a091dd80d9e4cc5d21f98ca379412b82dfc9e091e546638068ae0b63504cb4fc41a06e9239b6a7830af239690586a8247a984d2a5bca43ede5fcc4b12f3b36c6ef0b96efa48db9045d93481598ee4febe50453ffe126fb486842a0c018c47a75d6b6e7b56fa62c8d10844077b66aa218955bf728d1bd1119cee66d8f41136a867a6d14c50af7b118196b2377ce4e07e7dc3493d596dc2526054c5982777f553cc2d433a071d5b6a8d58df4981a753655590b0ff8f33f7b0506c2ec145bcd400ce89a56237dfa092f268d6d60a7c5d28a06eb9f08e24e1a6a38544826775944e23678002afb4589481d61908fb8d1251cc1654068f1bce3da807073405ab51db41b49c127998a31007c0d7bf0a04329d7afbf12a4700894ee7c266a16e84dbf17b42966740a536d8802b2dfd484493a2fcb945745bfefacb86daa13ec7e280c1adca3825fc2f88e9d1a5d96f3bb6abfa5bee50aebc93745e1e88aa2f9782313f91db03adec3e43ef82b9fb90f51b8e9ee353e225df2f1f1ae3bfc426522d4ce977abc846d99a530ca76dec72f24e662a3beefc6b605bddf4fe3568bf9b8bb845f370d09c5a6e4aff8f3569dae1e6f54e0ce39cd1f33055e62101381046343132f16437fdf44b7407fd3120b264f11098bb18cb2f1b23819639edfe63b288d9b347fa369eaef604f057313dcf3fc355d604c5a70b4e903c9ca5d1a34ee997f16287aa4e5db542ff830a148081058399bc8eb7927798f8c529684f51ea8ba6d3b9a38a51505c3aa36682382ef3bcf49fd3f4bb6c15b31d1e8ef17c7ebeee6fed990c901a0dc153a0916ac05b59004adfc035de90fb81c136b81b9da1b1c2ecd111ad834e2c7b0f7ed52c98bed0362f23731be3fe6424702f050eef1b218a0222c64d06414b7e304766c9111033b13eb8e9828f553a09bbc377fa982c60723723646d20ac4e848ed86a1ee8b4f6211c9dd32bf0372d306e1286906deed7b8eeade07cdfdc9234ce93e11f284092ebab4d41caaf5effa40d3df4bd0313b777e0ebbacff2a4726e8368541becf36af3846380e146432efafc80a9e860c1486bfeea40cca1ffb5eb6d62e880b8cdfe47a60ff50743da3ddd5ff2565e5dec7fd45e23b15f6bff5dd5a2b7ded6ae20d12323eda54a55abdd05d8924a45588a0a75317a0dcc1a16ac509d7e4b289af542eb2a8e8832b58bc00c2938d3fbb0f9b7055ddff89382677ca6bcc564b3d3f02da6c26e7b2f68341515f628cdbd521b2bfa4c8062f2a7e36fb94dc2f8da3874501c8351ae073ad9a20ef9d457e0351812a5e07dfb183f7cc168751111c9c5db2262dd9b7b17fd1eae278ec9b9eaa7c357744783331929cf2b497c888b204ce17fddeb18328c9a65fa962b85d5222716112dddf206ba95717988cb580539be8839f91dbfd54bdb20f3362c3689609dd27193387aebfc531199fa5f87cfd8082da48ec8c342c50fc440f81a462a3003ce559563de9a5575a73dfe7f31bf37af578d1e2d2c49359e084a178a2ca8e28691e0c714457ed61d0dbb23407c04dbd0febfbbf01cfd2f8afef05c49169239f5800a7794bc2de3d044f7a79d42a811020dba362e4e61a75549efe1f7bda18230040c2009580c710a4959bb143ede6e3a03489ee68cd73dc174f771cdc881fa06dd272bb6462b65acfed1dbfbbd98412f85a2d6b0ea74ff301a5b42b2024441bbd382723e3f39cc88fa5abdaa644293ee4dba0c100d34815214e25dc9076fa936357df1d8d98013b2c9017bcf9c79b83a82a2d0e4edd28f7083f3302b101cd7e508d119206e6e44521c6977d63e4e594a285dbac1e174d77eba430f4575521b7cf22b1f91e9974ae2347a1535988151cf0b15f489b8495125d3a2558058a4e55a7e5ebf3fccd0e3fcc73202ea8675c0027c5a7f9c7c799798e138fec8e0586284f1af51882f0e690691d3d446d37911a25aed0d7925b4e68548cc2c8791ed1ce47dbc8f9405ff68a534578fc3a61c73bbeb601f1e30a5bdff4dd21e5a46aa345a30114bbb315d2e9bf68c6f7f875f1a6c613cbfc5c8f136b187ab42e62e3c72eea8b873403db74ff847541728131e831d98d565a0895d68cad333b1c6e929387e8527d39bb5fc07d83e5ada0e246e5635d4eaa8d69d87eb987d8c9057f05a750d1b3c25aa2e7abd296bb6cf9e2bff626a102b97fe720971a2249df0dfb71c111aafdaf900b23cdef9794c2ab0f875e7dfb6ccc464caadcffe48241934d1dd155740c6f2ebc3000f88a21efc5351a986a7f2ef562bcc1aafe1ee4b5fae1e5b067447fbba16f935ad2b661829cf11f590cc0b110894c0d1f61e1841865210c4a44b722533fa05f11392c6159c47b71e9130785fb15f9ea787f214d0854926e6e453c682b6503ccb2f95a257ec977f83a06bb3ee8a5adca5814a0358ae7af90b1501c08e43a79c55a367e35e1526bdfa79e2ba2a60cb6ccc852a597d0d3b2955cf699374e7a2b561323dd03be7972edffdf94af036c76e7eb63d3b35c5de807208534663ea0ff0fc3f8a6fc68a1d8bd7e9f4a0cac33cb238a5e3ae7f07e9dfd8d012a6384d9a4959923dd3616de32e5d3292bd26b8f0d418e3d19137517c11b6730079713a5f124ef8b90e7da3820cea8ec94acb508e9c8e836de3900eb6d32a300e4a8e65a219dc2e999764cf11cc5bdd475c604279fe583f96028ac39046b0bd4d9f1e13b173096b6c37c6bc19bed1dad5696b2bd09d6d40efe706f3214e9414da35121de4bdbf1d9fca5f8a9fb6f2b71a120a98a01999701ddb36332910ee086bc08b13665b113c325e5928ddb3381d23eeba41e88d40ca40ae637c1c2934b09ac86041897e6a11639aedb16f85304cce78b954ea453899425ef3046dd368d3fc52fc6839852ae59b3850cb50c78815a9689d12c5b64288ba253b7e3c777f79006f4313c3f757bfd09e734adff175d72673004e8ab826b21fa968f546765a334e0cd82c59933594c4c82d169857a21afb50a6b691a3413bce4c89986a745cfe1a28920254c1634d2f60b2e59abfd9f0e00ef958acde4c3cd42457b0ec2ed834cc70040a4bd880ecde38451bb1ab862207e5a277d9c44d8e346c0edfa24dfdcfcd85acca6890531ea83d0cf8f6a207bee6244ddba97078bd54a22cc52e3aac3b5082c7f15c8ec3d08e9d3b6c73eeff74eaab572076c29abce316c7f37e9bb9b96fc8109512ed98f0692e007328c9fb771541c43dc6d68d6930ea615ac9f9b9c59553382e2272fc9d69fc10980c3e534642ce3c01956968f94329ed9fc781f24dde46d42e3172a5f51c04089db77671a986e8311a01e95f889d111541d13deb84f5ed8f6d6008442cbd2cdda94d613f058983327df7b765e8704338caa99dd0572c1de69ac6638328bb3fe0a60bebe18253535b1098f4dc50d23da6b5753de204be755a5611279f3dd14fb441ef18593cee34feb703899586c6f7345629939a7b8575a5c0867b6bfa6035a392d420c56d015c1693d6cc4f9e70383f64e960c38093a151677e8f3384cba5867756951a1c10da431ceab3878dc4f1a7001ab6d52023f86acbff38ef7a0752170bab88883f3f875110832e13f75b8a4a7600144d17571e3c45db8f279b9b205fca85f2566d1bda8ce2de907792d724c2146daafe1c4e500e758894f6b4873c25ad0b71ed2f4ce87a62d80066883849e0f55ed90d2b6e89bd41dc7c763f48a28ae20bb4c2b4979317b277fc01161583b9e74944ecca3f858e546f2f2f854d5c69c84b0e8fcafce63f253e1e6526f5b8747a6d00e79eb28ff721fef0949f944b5039f4281cc99979738333c7d2220bf91ff9cde4e76e5e07cdf996b715fadb3bd25e7617a661bb223a5cc832ee97a0b76a636190f3453d774ec4a81fc1a07268971aea2febee75451837c98df10471b5f22d934d8bab771d8fcce510acdf7d6aec76cf2c9bbb468dc51eacd93cd5976ffb8d0c2151c68048a44f07646617f53e68e6ed004ad3f0b7a62a7de7bb893d8427a484555189325d682dabbae757d09b8c406f96bad744e4f29147466222653005b10ef5406edb869456d9a5ce417d34793968db207c5de215d40d69638876fcc267152a40d45cfbd8b1bf96dff52ff3ad15c1a038165515c21c99da78ca644c9c236a65f2111e25f3df76db8c0181e1a15f9ab899fcead801732ecb5df05934b752043c713b70ddf4c6430c45588892367b417025ce7837cda4cb682259c785e14db3c1314f4829d3dbc0b2c8fe1b79cc328ff52b6992f227612e011725f8e74ee42cc693019e26e972f9c1980ace2c796acdda7d6a8dc049f6532eb69cc65a1cdefcaa6b9d9addbd73eca8ee031b972475a87d0070b47c2af7faebe8dd1f896f5eaf3909c545b640a76151bf7db2b2ab26a65d4c2b4f978d7f003531c9df57dbc6a59a130ef7200b3255e3333c9cd6ccff634450eae93a27c72f8f7fcc31bc8cd2c6b1ca59daa3369c9e208303fe864fe2f3c66ac51c994dab6971c621ab4ee658730f36fff8bb7c324fe3fca8c79e54cec539d0564674d27856b322630181ab31c0ec0cec8307048356439a73b81437bc3207b19b14785dcf9db243dc0f047e4579bad4ba7c1a6aff2f663ab6ad9f967ceec4ed8c35da79636decf7507e9bdbffb1e15c344f8730b80bc0f8be41dac53e7b9dac3c9539a1c0e7b26d9dcced802d2d4f23076ff365e7923cf704e0406d03711ba2b9bc461d58fd3dc8c9e19e951b2ef1e77dbddfb97c35bbe6542efd7eeaadae1cf12537e3a39ee0c0bdebf27e08b86aa316a8590c00a96440c8211434189bb6e7aaefc7e8c734d78ec4c6dfd79d538ae7aec005b7035b95a8382ae1352f7cd43897c68ac56860013ced14f700a105249394de02d4965d5b03c58542ddc5288353b254790c3b63befe02b06e276137f2a8e47d05ad43ce1ce2632a1e4b91d4898eb4718514dac481ae8d815f9b9e48a9168d8ec2b6b3dbf1d7eb25c3cb98c44fe64827fdf8ab0a922756bfa443277fbf7e73a849ff5a43658d72599fe98d23d098712178de340066cf33211fcd889dc43aa194a7698bfd3efce5f92af43d271acd8184ab051a4829fdc8ead559b021a416b87d3bf7d6ff0228b7c7a8221746bdd2eaadd360ffeefcd970bd70f3d62f6ff0ed5641fcbe6eecd7cd7ed9fcbd737dc7abcd8e414474f235698ac999d32e606bea5161b5fe2ffa629093df38aba5f9fb76f42bfde7d9e190306537195b51b3ba63091a5f53e83c04f0ac0e54165139dbfa0e93483d90c260d26d584d72dea2c94c605903ceac5711194f4ba771bac4fa9229868cd4e7916960602c92e39f4fa3abc2965d4f814c95bb29712aaa7770f3e3916afdf0599ea9386410ff036a60203f414acb1aad43d5ffd0fddea9f25296ae93e4880cd7a937f4fe3c61922ded3d04d3df7a4a88867859f498411ee96fe63c3b07db3df63485b7e3924115129a46784ccf8b2300f92030714373e8e2d2764314674b4c666b85d7140d62d3ddb30572ecf8bb7e4596762b4ceac523e021d4497e569dbcce3083662d023815f94578099c310090fc04fa28f4c15e489d6e2dadd3d41406b7d2860f9c04564ce8dab876bb3898d482e5864ed230d749724502069a02f5223a9a25d7734243451cbb9177742ae6e0a458c1ccc6d60d96b3014fbc32eb2dcc6bc11a0132e79256d46d59edef44a943968721b7109068bcb63fa9253f9e67cc3911fea40b5f65fdb76d712282b5e73f65a4814eedb3f3857e4c78322af6d21535bcfda4315c67f0af1633214a89fd5967f0e3e9bff193bf2d3013fd94a003279717f6df013e677bede17707ba3e8cf0e4698f932b9c5f0e5c8042e6ae53aa698bf25230cee83382df26a3b5b5859884112991f328032da7295ac872fb2a489841f19cdba5755bbfaee61a191e4746a0e609028207a32fad0d7e163591090c607a4a9d3612d4b0d4ff13b241893755f61046d8f801f71cb4e841af2d4eeed69d347d15a9e918cfad80b51011404c4aeccdff7734ea89f6c94c6bc9ed300e8b992f93f70297f4257a5ff44b0067617f6ee41f1abf3246c9fcb3bff6d5e141dbbdcbac71a08299177bdba3f4df72b2702fbd5f99d2f47e81108eb618ec018c66923369ea3f928c171710fc8ecc64ae1abb0eddf6c4e1d777b9f0f63519362784b3f7b83964816103642f35b8dc0eab599b05a59fc7c76ab9bc4ac988d9d15c41a76606c7e38f7d4bfe632a3a7e1733124fa061aaf23f64237b4029142479f1c9ad2f1d84bccec9f3d14cf95e7d291a4dc4b0224bbed976824ed8554fcd46f3666f54b003bcec096697fa4cdd37093b1a86b6608a1f4112a01c4bbc73dfd4aa8902ed8cbb14e66d3cb1f8441c0519c20d3aca5a062b9e7e379a26a69850769d1bfded8b2074de44e67a654c7f681f0403cea8adc00ab4f5efbbdf3372ec7cede6ee1016a837afe7ca003b08a7e6bff3fa5ed7cb768ec8cfc13f5fbc7eea953f78f9ac2d9c9e9c839721521c8fcd6297d4b337147b4049f9052eb6c64dbb88a5a0e26956b1e32a6772a822382819f465e7b8f14e73ad5e6d581669b354445733491f889d496674bac481f2b19874d9dff10f323ed258d73bc091c331aa912d60b27279aebf2064449987b139cef3ad3f7262958e87301845fa2f1a1b8852933c3018b1580faa6d40d9c5a7400fa70a43e03e1593ac28c9e8ee9348732370da986f65168a6496de15169ec5f332030b7e5731541be4ecfeff8e320da2311837118a31cb234cc03869fcd0038bfb9dcbbe2e44b226881926acb30f06ffd2048eca6d0ca97e80a5a4fd7d852e74fbc3d26b1e48de648183611a77518770a4c0516fd91a4f49d5cb4db4dd2159e74e4fd8c55a4b513cea55a216ea4c0eaca2d6b84b63ae3c37ed4d38db2fbf3c8361987797f71e9b97f9ac981778e89322fd69790b022662010ce691a6ea9b8e89b74ed3acea1dcaed45c4f03f6c818a9ceaa27823049be884acf9b8fca59839cbec58014aff6fdf3b303f05dd640ee7028784702e7267f6451e9e9a9b5561ee70f4fff96ab5b103056500040a63a0a842a913a76a2d4cbf87efc7e86824159cc4dd62a6964d8d7bc180aa978e8f0d8753f2cf928c931800ec747240b4be1f77d150953b0d5380b4d6563ccdfd3372e0af5e3b33b9ef63c3d6167b9dc038a94e3a30afead4bdeb616cb3349b2a0dc97e98b9220205edef554fabc372e41e0d1d2c266a8cd568f13b7cd03b24dad4d6c74d273c7b926b7351d4bec44ff2ff6eeaec6a09a932d2eb7b9f98324827efac86eb2d376aac4ec18bed72814e324056ede13b57962f71679de96c11d9fb3c3a2ebbe891c880f4d033b715efc10bc40e1f86f98a86468589a4b4255cf0b9f15ad4e2f98cc4309c571c6b2f66e886cd8f2ebb31eb1945dca966b94eca659aeb7b95c7a29ec401f33e6a03986b0e5add81821f7a804abe638feb0f3a57e5eb29149d89a88758d710faf4e0964a40bc35d576d546df39a5f68ea436c932ddd17fdafe2fd714cff2b3c04fe2d12610c2039f666a2b927a1bb9ee9633ec4363821ab0976f55889e94795d5840571cd77be02b309ac29fb8f17711d472be26c5121b4796318925f800d0604ab66cb281f61c1b4ebfbcffaf396d654b58f600d5a17e1c6b0e7a22e5da43835f4296431940e6be54c1334f0d7b269311c00ae2eb14a0715087a1e0d7d49058713dc4c69bb388f77f56e14daabe1a9b801bd967eebfcdb956a90d296ca0df772e3947da15ecfada08f1d97ea79bb5ee042be6813f43e3c3742bf4b8142f177fc702f1ce9967d10554209c868f7698052097038b09f3397897394c56e4acdb02a8915c7be02409abf7758b0181cd3fb767062feda6d628119853e55d861365b28f111489219869d13d2c5782aed04663c7daa48334091be2d147e1e73e9a43c71ac8d32a4a6215b3baa385ccc8dbd2b713a7285b4fd770b44b56b87ce5fffcca0f32cf4e254a640cccba215822b641f827895a9f336b2b484fc2e66c52b3d8f89450da69352738336089433b03c6f78f6672bc9eece55d788f664bc4ca86c25425c4581ba8c7db0dbac9b3cfb98e78486a6eb43b48df78be0f3a782b04446a3019d8d61cb2c8466610d06b56469ef1b3a10c760bd7537d748c3522c2ef89300c0f506ca791ada33bc837e50e009b23f257b790fc2da1b1a11c2e04c5abc765a4ea8763af2bce68c0e2385481d1859b0a04905f7af64232cff696b7094da287764474475e79ba9e728f11154b30399ce60dab53851a8f6fd943d8776c04f3abf24ae37121ffe56e3737093943a4232b80aefd5893ba32e48b95fd7a2b23edbd022e802a5f1ba333ecd7c0cc5c58b62ceafc4a486267592a9478823c2c5a0b7848b3b97f1628a3715f0026d56b2c1bacab177e1deb0992f2ca11c95e17ff54e918a531a42f84904eaa1281810e367c479163f6e9e6ab5891b4239ce05b5b5273bea5a446069fe582ca2ddffd01566eb93d17ee28a70404452c094baadffa56d0a9334a07e0b956ea7fd4e8899fff2b8a60df4f5b85719d7f085878379b4bac3e5669977680af4824a42b2519682bc3ad94ccf3be0a203ddc1a29896b5dbfc3b0367ef81127c7d7c94c71d070827989f1c17e88532f297340d140ced4123a17a3acfa4ff16aa8f6e85d635c88338f27edd6d3e84367c206906db985716adc86e8a807e31ad956eeb6a47f545187915d895b5efae2dd2b0d02ebdc4b229525775fe27699eee1c55dad01d2aa95c5a482237c8f85a14a97862c877c2bbf8cb68bc4ae8f93fe639a3d1d0de0241d88ae2aff63ac430c1922f2c77a56014c26098acce798617ef728db3e5ccef3d7345ecad33faca104b95072f97e37011672967de71b5a39885f3c0c75a4cc73299fd790ce5c25d6289828de0933deb4c6413074a28071cc9dde44bc2f31d0530d0c5a53e1a2fa8af995c8d1a317117891e829d1104f3cf1d4974d6e52609138d443e067270fe4c13bb8b2c5a576b7f3b3263b2022818a108aee704c189b88e488b4302ba3fbeb18465abd293f6fa7c0938fb86d7909f379763e74c705cb9fec78261e431a656797c5717326f5e83c6790f9f16146508ebf8fb9e03dfd07eaf2f84f035b5438df3a0fc926a455fa6260f3c2eee24c99c8975a1a9ab967f1b2254d15f7a8972fd3944174623f0d679d5585d19ab2a42fb454ac904821d9d2c125313e84e63918262f82469cff6b367c4732ebe36493976e9d2ace8fbeea05c0e9074ac705eb71f6d34ada7e227735b84353f6c12c554624f9db37abe12b8fc92bdf6a1c849a9e08909cb0c2d0ec53c79802667cf1658787e4888612deef3687804475ba01e23556a68ffa9876d15ad7c394edb47ec66533d6ff9dfd3fbe0789211f42f96244b4a9a4b32f5119d8e831e88f1447ddb801d439afee0b935efdccbb6fa9386ffa098c7030bea24100b18d708994e290ade9e02b53f73def76fc6c154a2c5bbeb4421b6b4354be346cf8e90b6ba52556e39da6bd60d5c54ecebbc2f741cf6f7a55358282fb9e34499b2d2c1e30b89b608ac3922876c368d2b2f4244d49d05c4b8a1eedeee8c6bb5c98ddf755f11a21db52629c1ea670422a4706e18da50782ea681408244206132dc2be61654057795168c002286a4607e9a95a6aa04006005b8a446d5e987516c7f563ffe8b6d17e65b00c8daa1ef0127b71cf996f608d5167024d7d8b764efd135b9c39acd509f92f71095e4cdfafb67db33b536d31a7d05e88a943a542623b2766b8d7f6b043be0be9c0ed31664d7f1dd1239271d43e3db107c8dd0e29283aad38705eb6a18c259e467ea2c5fe7a3e22ba252a9c734828b6dd1cdb1306187e18dcd362b2f8ba683ccb87f8ebdfbcaf36f63b5b7deb99d3a71a098564c0d0e40e48b2cd93ac434a10f91444a5cf796531cf0d3ce6917a41940c91e277af300b59bb5c379540d28104f22b6512fe3d8771b6073fdb9adbed561e464d1604263ce904a6649b40c775460a8467c3f7ccab2b1b1f697c1def0a48a709a6f0e4eac6a1f94e919cb3d02c986102981197e231c62cdbce15f4b7e3df887cfaf5b9fcc3edb32a1a6210ff9cbf86e29014318e65bccb0b306841ad0e7a059b62b6dad7d094840341994e88a67bd2470ae67d58edbf7c4caf617caea2b6a43746c049e9f6db5ef41a3a893b1c1f2f2fb2ad25345c4b7ea6792ac7cbddb361ce6d4a5a92f4d1a133b89ae71106446ef18628b37d2c754077e261202c657d4beb1e2e14e952ef98f7c6b57555003eb47b2c11b9563e5e51115c2ae706c8cba262b7075c0c1fb32c86f594f7224b946be6958d84af6fcd1cb8e5be1ebdeacb964ca8d0bddfb6d1d6ba08550fbe5c419efda227ed7b4559f9bc87c48d5af364bcee9b92cce54b20fb5b891ff40feb2b5cd5a25838aa956c3f2d0fbd1f5d884f75e359317af76d8e5e987093c01f6c6bbe9485c767eba124891d70245f2163da8a624717096e466f1e7dad6c7830fbea0efc94461b4e957f4446298370c78ba1da0d33377a7a547b76a96127ce8be593840fc98ade835bfa1cd722c7eb00ad24609ad21deb2bdb28145b77da81db4c86aa391be154a6636bf6e1939c571846d995f6323cb6605c506096055447025910387c36bd83b3e1e81d4f5d58220548ee540ed2b0453815044c826755a0afcf2d0fcece1cc2a01eec4c3dbec8e3292414d56616498b04e81a8a1acb6e32190b89260a00f088f65bd49b01f342b9fcbc561a2e77ca472a0d860b0ae0cbdab6c15175550a920b9eb97230ce4ac40b7810b5391ffce1ec7207608ca357bb5200205ac660300cf40739aec6a9fd98e9aa0ca11ff575e092bb6f2cdf4deeec9faf5cba1be09cf259a9e2d6b4c4bc3b1d223941745e4d41eb8d79ce79c43d67327677cd69df39af34085f0d90ec79bf8ef7f83558d98b7bef237afef5a9d4d1b9f04488bd8336a3964c026aaa4a17443c4f0ea2944181e51e0ff8cee63c19ae981c698483f60263d181813250cbde60caa004e9c95e39fbb7e8fdd57bc635a02446a7fdde604b41b2d1620985addc900e9ea332cc668de126536421c227b6888546c686ee3a99b307a9e72ee76f0d17049e2697f53cb232a3ecdeb8a1c90817b33e6040aaa1226005876c54b60c8d8024dafe0714c0d3338aaae24ca7d9be6f9f41ffad4e72d900e33697c6547a89bf9a3514c441301f568a41f6eaea02a9de9ee19482025d9ff117986db52c599a57b6384a779bf7446a61cea758debb2906db310f0f699d152d1625f78c9f76a7f793c09b6c45b09b59b44b9710f76c8b45ee3e0f65a5f24ab370b935746af00644665f890aa57be065a573cacb56db27193931b202aaabdc5586027ce93d656f69418fd973bd90357adb7f0a6e2e52f0b91a40f3808df33b0cecb4cb828edfd716e779e9aeacbabc5003b3775fc6448ddaa116ecf133f8a7b670567c831ba3d7b137d0c33e31db75a694fc97154c41f78e96ff586ef6144bb8ee04d5be647720e67a22c6ee7db7330558033b7a73f2be2276335d943f76f0e93b40267ab36129737e51258c2f311f012ab4318d587d79cb4cdc18b8f9b566fa08ae44fc6da5244c248b7fc45c59cec7624d1f1396fc1220d00ecb2fff390fe347889a75546c928d684883be99d89c899dc6efcbafc208d9281b774d26c7de9a125206b908b73c0243d595fdf3e9b57dcf259fe42648aa80fdb8347ceab6cab17afde429c5f7ea61cfa78b3838bc6429df73d12491075043564bc1df92716f58ba21dab3e66a0edd165ab84353265ff9973f88aef7c77e676cbe7ba16c4a97c5283b0560db363d571b1aa8e46475fff6fd85b510d8ea653ca8d8c81f04a69ea0b610d32567e219f338224462a785356e2480663bb9475a2022fcafcb00bc87d7245fcae318e296cc0b59a1c779a2074c680ae76bdf39febe3a2702e47fb400826e1b278342dbc76b4bf3f2fefbb56e9a8ac7489211ee3638f3171c05fb51b5b5331ba3285774f95d432974628fa3d04d35313c1c921f765822e5e7d2b28c529b580bbe3f31dcec7af9488107de86e05794dac2519840f4967a28172ef752644bfae0a35f29af053e735e804fa468e134aa91065f0ddaa9f5fb250af99a6dafaedcbd689898be7406bc431d7309fecd268e47021cf465f0bdea7d9231b8e9a3a3a593bb8ef00deaa0a3dd5ea2f625121cb8191bf079149b354bb0900cad06819f50f8aa6235305ec0cebaf32a8c7d94db966060f6e0b6c1380898825ef2a1a268ae032526ce9faf5c69721f8fae8995fe09fc419d1c0158a222c3fa32b052c4dacb4bff17822efca11d857147a562a6a633e0501b034e24e165cfed18f814cd84bce313a5029a578a3243e1cc0fc590615541ad50c6ea8cd57af8a3d3b44506a7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
