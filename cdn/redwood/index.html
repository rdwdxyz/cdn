<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"79acf5ae66a69a23f812efd3d5afb4dec257e99aa6f7aecb24a1be5b06d54b30b7b7d5e59a6782f1418ff89f9a1e04b5acb71a3cfad26acc622d933b919cf1ee44e02eaee80642d84177b0ccaf9b22350d5a6d7fdae008b7864c41713ae615d64521e21b60c1071ce4990c19d064a16edc3e2d84a9c9029a9d7c369b0acc62cace3e11fc5e484e20b93e657fd0885662fbda0923636e4cc49557eedd9cb98bb150229311a657c07407cd3fda539bf635467c5c7e9ea761cebef3eea98879e39bc2c8c50a84342cd9ff5f93b8fce2cfc82d515a9134c6dbc9ca396a123ebede47b0275e859b52a8d97f6c195a6f719aed4e60f302ec3a508655369543fec6417e4566ef5e98f57b03e90e9587e837633bbfa624baec267a9979088d04e6ded3c729423d5e400f084adc6315af5629c2ed4b8821421398f6039a2dcd658fac9606d6d7db47516070f2ac38990f0c74d0ea23a327b2d2588ec67829131ea2298c7e9622fc2c7d6a0f051ee3acd83dec4a21cd18292fbc16c926ac9868f9bc421821a6637346f7b347b95c76b8ca0d6fbe27781dff6418377c14dae7f540ba2b7133014ebe6784cee4cfdb4fa9dcf7d4e29bbbdc7012e1cc3436018ce03af39dfd11bf66c645b2f76d9bc0b4f71d0b2287a1daad7040fe6c4e3be3a46a86929626f9b7f6ede70e771c477f131a95db51c6ade8fe530aaf8ee34fc76368241ab335d9988b3244e68deb4f98aa46e8ee083142bce4032334ac67fb04e0a43dc73b75e3e79075291aeea04e9fefc95dc865851c1b5b50f0a8c441192b3b2f90a1cf5036a073e449ff6a327c508aab5e555c9101fc537ed3037ff985ee3373d2ef6d8138411d42c5506d54bb6e9e2f4c2dc72cdc6bc2e66aad6e268ea1b0b753207cf75060c85c656b78f5764ffa2543c645febf4349f08bd339f3a3ddef5165429b52d4309424eec8230fd430106855f0ad83b9247217701c49e46abacaaa21d98f0f33c55cc9a95e88e59e4d32d5466f8130d9a1ea7b250f2deb9f8578581cb6347d09c6792e6ad49bceb7fcb59203cec0a2e6695e7348013fb1e9b5d730464c322d9eacdc9503ee7f12351a2aa7cd8682b241bec1cf180dd68553e284a82271f48752a3e996750403d04cbdde818d58b5e3fbe419e4d85de1acd2fbb4251344dc0b46e6fd7f4686b750eadfd077969dc248769952621c35a22bf8a6c07207f092f76a536f9ca89b4d643de9f464b390e54b156cf9a9f15bfc0da92a806a58c8197ebafb02c118d252a9f00897ae62f6747557e4d8b5f7039ed617415a320f10a581f61bddbd2b804867118146c29ec13186c258e620a3140aa7cfc1a4cdd205bfa804fe5471b953e5723868551875c76d47aab5ef4db09827f5b40e47be978b6ec22b8d73dda13de7cd85b3b9641f48051ea8e2da000e5292e54a1b6b6cdd99757db61f970af383fef279f39f2e0e7a234321601a831a7c3fae540f28b17766cd00ecadebcd2ffdd451c150315cb94b5aa3e5f18edd2a70d9e3579158bf21b77a1cb23ee3828c85959f6b8a30f8e236ca107393d17b26973111f37672febeed1ce24da9c276f36118e3809cfecf64a1f06f4b413e64a8ce4bc45933ce58d2e6506c567a6f5004502e7798715d09ad073ec2bc02c8aa44f682a0ae119193028876ef9f6074ecd9cba09e445cf97516347a765c4853707a96e045ebbe97e0903d513692a1aff4a85c25a689342adf1a3c0d2f148d3160416dfc76a0c22a8efd353580ba1d6c02495e77a0ea6a65bddabd7c0a3513d164ac7270311744a7584ffebc49f4ca8048987fcf07a2fcec2fad1b58e886341177c3503befae2a1db092cb87262db69d39b7172d614cfb10e332a6c1923a6280fe53278f359b5d1f10866a1bb43666cfe773a281b30cc39d2172aa42b89dd65e2845ed460db189c508b9c315845c7317b910a066f735a4a82f30c2bb41490fafbf1d1b1159241b3802010530cbb27980483bc71a3bd0e533214e497d4d9e68c12d5a358e621bac31034d2b3132d730f48946a201948871afae456d8b80d8ce7f9d6041e27c9c6d001c17f79c7bf8c39ce628072b7891108eeb1bdf38e0bad0644ed2e8a6a12804bf23e776d9c48a17b3619736c53c1f98fce5dee2b1871ef91d826e089c8804efaa98b11af22d43255e64e5d6aef133c336b1572f06cd3dd1ebc93bf8e089b13fe5eb414e09f56a11ab8178bcdab7e3272fcfaac63be2ced364153924eb27874c9b6506f1e997ffb93eebf7ed680b845ce74d8ea54052bf31d0448875990577ccbdffd7c4c902de38b3254d95be48aef3f91514add771fce0d19ccbe917fd4965edbb4673fc5ef2e94cdd2abb6dde0eca520ef38dd79e32c8af7fe183427d3316801987ec81f1c19ad86c0014025f3f78b15cf3dd47b3e0dde700f78e952d74c97e8009b600ea6e979f2496c91477aea65728d6f9aa381245bb4ca8be022d3f4c4df3f856a8f8f406debb61220928ee37b8d55d20e704b29b570202aa57320d52d3cc588cebbf4dbbc7401a82052ca2726fce184648cf09a7247480d37850c28457f599bfb5ab9676f5806064c7f1c135966884ef6837a8fd231af130b8a8bd6746a6c20e1f1dd07b38d8d4bcc84345d1dd6e3daf222150179153cb5f22f2d0617fb460f930559e6a67c1af2f5c9b8fdfcaaca2947eb05de13e9389c5a7e3100d4c769fb099d65ad1837eca2010224388a558371a0b33cbc20b4b7edd024e52ce696c57ba0d6aac3d81fb321111b96d4b82605fffa320636e580695ad0e6843737fa877798fbae91aaca7937b3bffdc80ae2ee8bd1d412b08587c52d591ba012cc299f71a769d6359840e91ce5a285da7697cdfe728ff773aa557a36efcd94453be788c64b4da8d5e71328f1cac48285f4eca9fde3d68c459fe691b9b51dcdf3208a0168b2ee81b0472a80a48e23f2192fe2efc1fb575b2e064e46518adabb2f4e1786eb23f6e32d8f44dc945a15ec592c4236f84a00e8cdc9f285b12f05469238c93e5a54e1910194c9d155045ed11ea9bf41c3b249bd4be39c9d2c037284532543a2ae57a8f527c59197a1fb314b3f2ef649dd9c5ff8c59d1508620b7e861f79b3d1aa3edcdf06873ea88c653468cc6ed569a9691c1ea62970ff9ebf91ec850552e70b1fd096b708974f702e8d3389c4cb0781b7d817002f9348b2198ef09197647403ff93e8473bb940ee54b9662523c822e00d6e4a893f7de17277a1bd05c435424bbde59d1127c8422a6a4be63df54fe7467f08411a51d7bfd5f7f2e175dc7b3b6a15d6854b48bf5d260f7c0874973a5938d1191fc1c74f36b3635d22230e074fc285ca8df33ac0388bbf528c46fb4c145548dafa118dd1190fd6455843fa83e6168ef02ee80187afaee6ce87c4412586e8f8658eee3bf7e47c40b00d547246f3795594526596e9ef2a8c0654b3dfdb151c6a72f0cf83082ed6d976c01b2b7ff0f5b6380139e93c4f2238be6d8b83fad9c482e542f4f26dc94d27dfa354585d34e9b84fe722380bce4c45b6a9f336cf98279e34a2bdcb2c1c56176518e5017ccbca07fc621b89247f02a4340fcc71c1490877dd2d175556c09346e72678a6c27d125388f81352637ee4193947bdfa4325d161c1348949660ad236c475f6b070c1e48eeb1356dfe95cb84132c38949f832d59f5906e8b57fffd9ac0d90f02ad00c3ec1c4dfae39e97bf4f8df3b1c4eaff04ac8becc9ff31f3d0c8fa62140da3dda830cba3cfa4bfbdcafd46e193e727ff275925621e7b19d679e4b7eb6ba64277f20bd4408c8c90080eef93cf0948afca71a91fc5945dbd9c2d58f6703eef406ff3195a08ca9d54afc7ba1f0bd5dea71883fe2749359af6fd7bb218e29cff2a3b3d2ff94c2b51b65a620335361c5276b8d99ab3d9f6f4cfc2f65a28010bcd61487b909d1686cee5b766a963894bc38e136fcae9fe854280f6b1c97083805d0d79da68c410b6e22d60c70c52a5045321090cca5dcf6702b8b4d3d5f8cc38c2f24faada0132fa88207abc3888a7d6df612c629baa299454f87956ccc8456f441de68ba5c6a88344badbbef0bc2fbcfa8b462dbba3d6efb52c0e897145630862edb81d95d422918e5136798e5b5f47cf59de6b64ceb686180606a48c53ca80c9bd7f2277c83fc6771ae99792131aa2d5a4d22b12b458c55396eddc4aa63bbea3ff82c987e035b1f91bf3b112dc10ec1e18f10938411a74f82bfba92890b3df1b5f09930d619dc058755ca083ae5ec6c65231c29e85bfac8baec7ca104dbeaead6d301dfae1e2febf614e5be0f5f049d41efe0e6fea06edb007fbb91641ca9515d9e0fc2596b37569f16138a243e4dff182e25dcc91b81363d08e3ae28438551c83d9c6167ca8faa4d2114907d6aa49c2ac4e7256e102a3283467428b3c97effc2d4096585cab913bb42e9dee53628e8b6a551c98c1d3940490ac58b279faf628a509563c4c9eaca22765d089905ca9d4fd1c0e82b56344d4d693b4731b2fec70ef9a92acb0bf50792e20a377a4be31665ab70d500188ce65e2ba3a38fd83c7137436394f89d48c1a84e278fd6bf254b99f470debb59d1c05b0670962b07a086431b9561c32c3a47a4efa5ab884e359b88afd817e34d735d5c3bcac65b38150c28347a45830ad1157c5fd3eca828713f69c06b7a840e0123830c152f39315bba5f290143cc398dd22da715c8904a8167b03b4e5c88c62c95745ec5f2ba7e30ae90bb0b633db65d256863a0c74238301c1a3b7f083459ceb9b16b10f1c0cbe5deb8a2be85aca52dcdd11bf6759928985186dcc47ec7b6ad89a0a869dcac8b6c2f4cb1851d53b1efc29755cad0ba3fb3e05ab959d6b405f7805f6bf67dd290d4d0c494d618bd6e96827ce9ff7606da8a68112a24195ef9bb768a16c3421c96ff38a20da28454a7c1050b84d7cb3626e5639de1668b973105c54add8e757ab791ccad460cad542118324ef120f27d0a3e599ea3c759bae0efee3482c1974f241c85ec2e4f6be883efa5d194d980fa2a951191b2e51569beb96487225514addd0c8964efc482c2c35dc5f6146e6a3a63b85f7591f9d1fff9157e49e657f64f0fecd2bec46d191e09e90e43975640721210bdbd120abe96cb386b9294d4af8603f927d3dae482ae197e37ed5f0cb2b2dac59e8562d3d3ca8d65879c7db140cddfb6d6164668259d6acdcfd48271d845876e355f18f555b015e213c5d3c8686e3fd8aa0d105ac4bceb979f73667e2b5b1aeb220b5ba8f90a6f39423bc6f92c240de3f0bb76a259405c472d2ad2a436c323d0210b7a3dac4b5bb3a16b815dfc968be9e87d765e4faf279f82dbe8940c605a9828dfc0f4ed85700376ae6b82936f772aeaa8b9e0af417b1c013c3c9f6c50b269dddb5af938226a6df0461329e3f991185e8ecc59f810a4cf5040e4a5d368c85e584c4483b360ccada9e3b896f9ba1a30cea8bfe1fc9208aa49684c64cfe5ce751f3bd6a5bf3a318a8a702ab290e73ca45c1d820bbd67e36e6036eff44319197844613d3a1d0ec1d61a79f7e4e848412c4b7fc1cc3db53574e2b1840819985c2019a7f73dc0ecaf5943eba33d38d7bc28e1055ed414d174818b2fa130732ac6e40da9ec8fce6ab566b4c4479dcc0c3b5064ec28d5a36e532349e53457ac65d8f57515186af53a93246f4d9d182ebadef08c87ec113e85a71631f58cf4d37bf23b2e368523fcfa2fb80668686753101c362f01266a3e73e2bf43930cf34c115e64333c3ee572d1e803e2db70672f48586f9f1bb5cb356277576caffaf2e65bf28d9787f53eaadbf13aa5469ce4e9fc343dd772933526b29d5c09acd5d9742ccd5e92174f87f94d1c981f71f49fad116da13038473be66537d227e9419dc83a168b4d08352993b8ac3f83e442efc5b04beb8da7aa0aa74a31b8f1d677e32debe1eb290c1e043e9ac5c649f587c7f62c58d736779b8f37a0075a61ae06c384bafae7bc7a55e88a164e49a2c1546a5f3a125a1ef71d2bf2c7faa9489bdedc5ae0596c168394b68ecfb86a206e64e5eb36dd5a8f461a36b5250ec887c6629e0298f691208cce51efd9185d21f826882ae68cc7b01a19ec9e7d7b1ce984b9aacd3bd7a7271d153399e7bf1cb3049e534d24d8b117c87985776b8a35ffaa1d254ecf4229b1a36ab16c7bd9e33d58fcf7ce34c2ade9cdaa47364b72dcb4655d90d269c4042651f3041d319ee65cbc5114308278f5a08845ca789e50826488c77899119b9d0f8f966648f93f218500b6ffcfdf56019ddfc2956739d1c1abf9aac50ce667e213076198640d08998a72e30047150bcfc37522b59acf0b6c0f04514c205758cbeca44041acefb19d5c593bde65ae5288573f4453295bb8e92cf1a62f82ff7a4e76adba2d45a05783bb14a991d6ee7e82707ec45148feddefffeb39c69cfbd7da2d53776eae28401b04bee26d8b6939e1a89aa405e5b15c851b3f28fbb8ea5eb637bc60463fed92a7f524af5aa1e9e87118f28734e005680dd7f82180e19f2dc406f94a3282badfaeed3045f9370ffc3f1df15ec6736a2cf3e674d408c0de6f0af4e07911da9627bd7314f46627306957ab3618103497d6cb39f8c43a1a93f7ea65dd16c673520e0cbafb477680ef1c1bbadaf638f88763ffb1c7f53cbd531efd70407cc76da07bcf1411b3a973056220d0fa050e453a6029496fe897890d22fcfa09a9411aa791eecdba226ab942ac8f643a8fddb03a8d43ee31f3e64a81e362a43e17bd877c8b3ed32eb2fcb1fb34b34c32b10eb0468e5dd4466d468f4a247ba8c562405d39192b3c8b296c5b5459cb6aaa45452e5eebdc1f9e282f3dbf7ff12e8d82166c32efd0046e94fc371c0fb602bae6955e8d7b8f097ed90553b9fb47905e14af7df3a30e253f40b62cafde8f95a10a63ccaeb09f238cc2259395170b9869bc085ca02d13c7430ff14330b4fac805f5e4921022c915482bc2787cacf1e645cc1d12b7c4a1446065155bd8cc77daa88c61b653222b788591218faf97a65d9656b4c22e8692ff705cd0163cf2770993aaa499b584e25ef7b75e881ad810d9dcb196dc7611b99b423ed2e17911994f728293676c4e324f8d09bed7ba69ce5e6f353d0007aa307f0d038dc320131acafe6330f050c64365bfd1d58a689b3a66b8f5e59b8d5282135c7235756d86883b0f5a06fe96684ab67f44deb0110bfd2b9a04c3bc00cf9decab23f8acfda970edc778cebd8e9f133d3fefd0c82ddea996be2ddb500e7f21e3cae2c907abfdd311eaca153115290654f6b2ee5e74e8580cf07c1deef507c7b3d4ae344f9f7148361e4c37ae0e1ccac0c533d2c91b10f4ea4c97ec500de44d51c3a14ee591d5d0b69df27ba8974136e11bef072dc994b228e5740c2623aceaca59cd0e2d36573a464835694a68d170adc72ba67017296f7e686fe315039260301d79767b62466c952bb7fe96db4a514328654403eb508915d5f16ab869ecc023e0f9abe2b5ea8172f02a33a489a95375bae44b1aebc4d9fb6e08446463e85bb14fe66897a5444fe99e71e83508fee7cca684599486575836707397b1e198af433ab18b27ce1e9b8de4cf188b3212a267a4fa1ef86a0901cd6c3ee1e5a29bf0a02adf64bb1dcee59264d85847415d970c352d5a1628b331f391e0aea79fc94ed1cb1817fc6bdf854967791fe5ed6f720adfc9ae26318028d2de54c67d7121804461f6a7865c8e651aebb27de62235dbaff246f0e9e1cb70b108bace114146ac18f7242e3c6e035614370b98e21b77ce93e95c3619cb2cad532c5bf0a8ec8935f13653e37e62f3253f91d3e1fec9826ad092b1205d7fec6528283e802ac1e721ef9f0d55f7daa5075eab552d387f2ea424184353e7b5b6d79b15da1aca3e59ee9855a4cb5d44dec8e104f87a01fa58b4d18a95376aaca8cf3d93090ad5905d51ebedc3110e77d39f381f50c8ddd6f091be22459d420453a796c80570aa49145df81765ca8065a11c08563addf3b4fffcdee8228b0c61767f7f40c4ba069cae91de2674d683e8eaa4658dc0228b6de8efb5f221491b6c68bf39c9eab0511a63613f93f11c474e1207bd9a9d4ec5c0e3c6ae848ccc7f60c458d6116f6e7254a14d5d604917292007f5412c0a89aa63ee8eedf3b322d7d12c7c571c7f8875ecda7a55a2878430b4f7ba1dba384a6c98e8c5202758f75e7054360f21b4d0bb93080f900960d5a3ce5527d2883d6831adcf020913a1c55010d85fd0bd886748306a3380fd78b822011421c37d20a928dc3fd6cb60205b473b52136089ae1281388766e66e0b36358e6165d3769846a6d59b64248e61ab025194e5fe726ce27f748b62ed030d7a0daf10175a7648cd7b24971da6eb862709efddbb09ee6451d2c7709f73f0f48efaac750c0e95cf6ea3bd7e4ef2d64a44e31457ff823a483572ba8599f95d6f205e47101d1150ce87f6dbb4632c3d70d233941088ecce9d84ef31f24217030da66fd64fb6a6552223979ab491d76e44bf1f64880ce98b44d51d0993158a6c857171a55ee47825a5f90e4dbecf8ea2130a498eb06def3595e11688cf9245197f771092eb54ed49af9c110e16fd5c58398e8d6da751fbef6ba30429c5d09300bd3391ae83cadf3dea9071c249701e400af91ed9e13cf6f8e4e28c2bcd4c93dee614e943efe5eab418a61c099bf1ddb591235a61fec89c8525bd11e838f8f9a4bdd09ae0265ffaed55ca430ac0368adcc2c1a23bc4ea6d97f70811c4ba8fa235612c0945cd73107b8291f3a8fb1ee2abbfdb8a613aa7733db806cda58e54d9991392e6a83dd0fa3574fa31fb928826d9fd37e27784076a966dcea3553cd859039bf9a377749e2a6998e63ee5b96e8b12fb2f7c878cf7c3984a9b00ec9de20d82c19e8e0c9bf9eef415c8033208ca3afd0db9b913eae2af7271bd5aa37d5d6000a2d48b4656c6b045e8ed31f589f821660d65172d123b266bc3455e462071fcdb1692fed6baf678fb06016819376bbc03ff2fcb7193ca00be8be9a8fb7131288b95cba4ac30ba7cae270f6f56f755ed3064e4a07cdc9f9bf68f7f7f75c2c9cbcd010e2d88a122b4f2ae4800fb98584b7f32950dd8d909f2b9bffaf5e1c081b6890cddfaecd622fd3ec972bbc2e4647becfce4e175262ef4c25718791490961c00056f73fc277c8a2a405ed5b6f8f289e92370bf2220af98e233bd4c7f2e388d84c39c75532fe4b06c776dc0248515ed3ea1e981e1aebacdfe2100b199cc90c981282e9e08cd9c047dab6241b6ccdb8fea6f3d482d5c73c31653ccae6dca28879e1dc386ab222558aaa0d5938a662161eebffb4c8b7e6fe9dc36d52befe86f3d28584b2932ad7d5ef682e0f4aa47981c37880b043086d46a2e214039b5e15ea2101922533550ffae02a01a74ac51726ad85e16704c3888388d723aa85c69cc207175c573fc2b8990728f753fe0cb661c192e5f669bb3b6dfa767c4b0e3933249321f67fb832d556a64fecb75319f50eea656b23cfde7a6c88375416f6378dcd726283698b7da2c20d7d628e30680472dfd687653128f6e572b5a823aaeb4da220836c49246a9ee373f4b61d1b4ffdf6727f1bb3dad1117d33f1d07c7b8fabddd19d23c0e026a6b923f6fd112434824d0f6f761e2c7aaf4b9ff90bbdfef2618b9671a4f262d6e868471645e5788d13151d0458c715448ef1112a636f2c81b4897367878876cfc6c791e8b8ae5fc2e26a741960597701fa22d9df50096ff5d8f2183500d1fe2818b1e512975d9ef35f94d7a91833efabc36a3b44b4ebec5211f041c7b0fdd52ea599997c0c50acb177c55cbcd2614ad322442541dd4358db06cffd3b324a6cc8e71f8ef735cbf9f3540fd115d15dff5fe625f15cff7f049289e650711f075bcadb4f14b315af543a8e3d2c44cb6f58f4d4d4cb2f48b8bf1bff055f368903874ed2d870f7a1ca72b42b3f3edaf156a1c5a584290831fd8de2a60deed903470627672d453851403557d8de81a23719133e66ac1e31ead98c73612fa4fe5784cac38a9318e33d21cf23e3160bf6cca898547147a34d3e8fa3771699c7b3d32d4465013cae09635ef36bb4bfc8e73e33de52b8ccea5c515880ca60b97144e5a4ac49530dbd0a4dedf5d01e2160f3c247a328a1ea6b39494aa13d95d64766b693a907bf81808037dc195d357150e0806791cd97bf5e83ecad0ac4ee845799bdba772cc75636da930067b499dfe8158607d3869d8f30f47461aeae4c962a520b8f5c0ea624979dd5caef4e165f62015a4f3549f95bd8c4053565c701e387fab8cff018b843070ffafffae0fb5d282d35b652e6f9fd428e40cb37cba942fb4be2785d110a1f1f7272d01e220eb679ed58f2ae31742c4ac33611c67a62dfbff13be57c26c738d7731e1701812ef4093648007e7ed569a3b4989192967c5df66496ff10e25bb8c0e8a04288e784c61d385cae5c09ac7be6a1b43cf679047c8d46eca67a06d20243225840387c661f50b542e7c282f490bdab9f069eb284891609102577b03980cf90643311a8fc73819587b9209743a0a202c822fe1f2a5fba881fde424ff82b6b8f280374bfb089c499f76f67279d5d750d0473f75fde01739fd24d1b4507df8d0079fdfcea84998c5b9024fe7a84d4cc2b85bfea974acd7b8234255c7e1e5aadf7301cb294d84050de09a7524064b12e56086d4f5c6924ce76795746fa19e6e425250ae88dc61b914c4acaa5efc7d097b703a07d6b851f660456f7dbdc6dc4ec5833922c63b4f458d2fb2b85c9701128f316f487b4f6b1c1007717af530048644118f67043c05921f650ba8b1bbde257d93154de1e825f5e32d5a5b7aac43f42faaff55ca6da418beb22675d4aa101ee04667bb5eef7969d88102bfaa292c54b6f521ffa332fc6665618cc240c733299a52c9fae49ab5733fa3af984eb0c2de4a090c2dacbfa2cf201d7b9c5b71fd0b3231d03076fe7a6a1f0433f848aaa9f14bc9212b4eaa7383a90c04d34519c74f567bd5ea1ff5eaf3552d15d469a7565df21d802964eaa7f46b825165f1f7dc9f39a622fe3e87c9970605e8bd515699f90a9946c20bc232284242c739b669dec3d153f7807a2c22594f62dcf3e1442144000ef67c953aea6f51fc30d0cb9e75f5ee28f568d9732a023978a6acbd812a9e85d1ca8868a8fb1c1ca62dc8bcd5faac2bd19402050683d0ecae314811eeee1e66942d0c07ed641167484f356e47f22e1d4eae81d9b3805b3ccafd960846c642b2645e0d3e0fa9ef091bae3e2bc00b53ddd7ce9e1ef6f3ca207b676bff1cc4568fcd3911e6ad76a1ec32be735b5a93375f9783949c015256552bfd9832679118f3417d8a8144b7413e1ec2cf7c11e2f29f8de8d584fcb7645402cff54c390f84b0caef4b263f7a6d046cb3e09e2a09896bb766275f76489acdde4872e99281d4d1686b0795edcaae48992c110a6a84f698cdb4ce69623c0064d00b0e4fdaf6745f2e725af4070a75a3668008f8162703e3981083cd21d9be0f696adbc858133fbeaaf402b5750b271be43ce37ebdd5f17819f432519b098c489069e8dab4724084d1e1132e909a8d624ff20f36368244cc71844c02612c6d593345da809845ec8428db5ca0fd7a19f613adaafa91269f3de9efcd4c2cec4ddb5d0507f0a4d0820af3d631b46992a83cc570d525eaeab62d819482c78523ad9f0f2077e8151484274dd5352431f2dc0ccd2a46c474395842447499f54b7a3245763d6c4f4caeea1476a4a50262697274b8263b18ed925674403716a10b05a22a5f38571cb2103a9c2e83fd8421ce7ea36e83547513999d6e9fd826dd241760d7ee165ee81fea2f5c56c8fd0b1342d958ea51b7b01a6a0a1b1674af6b618e435a737af6a38b858c02187fcbddbe539c8e381c84258ab7cbb8e71dfff290999b377569dfaedff8f4eb7c6647e7da0ce92664480f2b84403bb663afc5b1220cef7da3136b8ba20cc1937147cbb4405781de5894580a789ee7f70b1282a0f8a3359ef923b045972d6db83250c62e9362f965e3e3a924d724c369386f93cbec1b39c5ccca2feeb31ee50a455a1398deed5c134b888249a2103d3175f841e62f2fec67a94bc442e75518aaabae07caf31cf90fa12ad422c9dcc022f73ecfd31b67342c02ea40522d5e6198620d36b6d3fa311c26d483a8aec41e5822fefe4cc66bfbe400d98e7fabe8593f971419aeff24af5c1abe094026125c1617bf11db97481d9b742aa91373e50fd0e0952528fcff92123201367e7b29347cbb95e57410e86e04e67b4e7232eb69ebb3fb74f10c21e4fffb61444fbf05f7025f4b79c0a8156eb224b528f2690881446d79dab2bbdc302ee34b169e7df51d3dcbc0a20e6db2dd1879ec1224d923a94c5e9110a6a06f02e5a24477988d60fb67266327764b42922691fe42bf768faa4b25e68611e69ada6149bf1bb0f0ae9eeb3e8ef57a48311fc0c0c2a284c84612c255b6c056ee2e7c3fa3152a4796a43d17e6e909ac3411ca03c3c8db43e5b5004b51cc5c1d19020294731a59928dee29cea88a4b4ffba7e35a0990cc37b053c57c0348fab4ec1d177d993fb525134a085ae31446d847e380db5971d80ede8155b10ad80702754f616df929b2e2980cae364537221bce91f98a8402681790032c7b458b749b35c5df42facbc279847f0ece87b9ccc23703b19675e5364378ca7f5442844f8a9d0eadc2b678b9cfcfb3615ca232c058c2bc7766afe0ba05699ab16dfd2bf9ca6d2c9d654f313c57fb764975d7eb5b1e3ff9a9fa13cf569fb3cf03659f8912525874ae0ae8540a4c12bcf30389cebc421f8995e09ba22dec2dc5ed95752c4547664784f50988b2b3de76c9d7d885af9a005ffb1f135a2c6c897117e3deaa7be634a8be499faf85e677a37f38b6dc497e45157269df0aacbe3ba8ab770b81a4b203e5d3df0f9f7f3e0b55b91b8f31200b66291bfe49f4196221c2763ccb4b265849b171b421f99c0a8be3d11b60e17655ce3bf749489274957500de02b85a5df021cf922578d9def52b83d48b78b37c5a3dae07a9d1d7861a8add38352d506675937bbbcc04b82ede944d45046ffac06c330512b5261532831f32d4f04d1e77f4a8a9dbc05620ac9bbc4386e5740b2294d6a62494a993d5a8a88599c435fa5ac858ed08a05a28657ad3f0ea85c3bde25488bf5798841b21f0b04344a0cdacf0b53dcb85e760895c2852d0415de00faae8c6831d09b71ee53d6558d589f16b981499f5de060acabe9dc947784ba6a1cbc69ce2bb5d48bb47e9347d9314721b459aa5613ab46dc8bf5ff70604cc33aa2c0437ef1afb1a96969df81cf132b6bf00fc90f80a8e3943db046a19049c21d40d99c8a6553179e2ded5048513e08f02d875ce1cdbc5a352896c6b9128166204f763f57a24899629f6406b8630ef71b3cfeabb516766df1923a83007741bfdac11632dbfb7a3f3277e0e2608d18182bab7fcef94e1a5cc1b48ff5add53eef87cd8c9b6bf8a895af04bf3827f8f496c5762ba3a63e44b74939f4c825a56a6b9fe551ef9d33ce4c336e0ece22357f007def366294b79826dba3c950ea054541e18fce4bec46216629764dbf12b1ed5b099f3866851d083d62071c57782f99cb36e02ae9dd9c9284640d3737514e5c5f4ade8a40bf80be918bb1c278756ef3f201a45aa463f42c111655807bdd84c0c6fb6b0946a3d26d3130ec45e527d2baad87c0b77b6329ea738d0126204964b8697647a22a57874bad8924a4b6a5a901ef7d0a3973a23ece4f8da8c6439ea1f9683a2e98048188e2ac591cf974f8b74bcf829994a2cefa2351f5f0e473d25244abc8cfc9e714d575d5c16ae71b6fd4cae1ed4a4ae020ed74c5bdbb0308189d746a601eed00b0606ac2eaf963f5e5ea72e0ca97885931c813f57c52df73a8a533c5cf10ee413dded02fdc4c5e945a8f5b07b276e13434906cdc872bb966bc9fc7a75a5a70f1d725ae40873065348930f6e2ab2dc8e764aac0088aec3ce7258b15d8080899567acb1c8a17c5369f3e608ca0274c9eadb1482a3255967b94abd1a26d081bed5b7e3f67d2a0351b095f9543ff9194feedb5ddb5c2f92f83193bf387564e567ae807613010d458bbf6675f92f2cbb6b249a896d2643dbe76ad3c1fa46063c9bef3332d0705daca9a8197762d3b034ff898e2f36a4f94b63752771e6893f26d2a2d55390f8a2fdaae665306005e04e1a1827f321cfa4a2e49c2827f43d6a317897151a0ab58f0f1b12c539e6523b59b22d15edb29e7230154dd8d5446d2e55521960e74b92b45409d8f6a2326fcf5cae382eebbb2f1193d49862c8994f34fb050b8e224a490e74641d3e84db24913eedaa0965e7b4395a90549defc4546779e635b6e933def1510e221b815188682a2b991057ae907772e4198509f19bf692a9087b2b47ae669314f5a2278243ea53f7353fb1d461e7b457aad7f7e79f55f1114f4a144b163130ecadcdc6cfa4c6f56751821232ded079ed82251f50bc980f961eb3e77c1c93004af40d7b908e510b290904f4b0706d836ddc093192b5983240e8ecb824861fe55ee6eb140070c014c98a7e79852349025251e1d3c47185f2424df53aaff9ffb2d4f5af141a10c634f5618dfb6b05edf5bca35110a0ae067fa4d7ff30fc3788c7f9c9a773e78272a6c12dd119caa9a387dc85935294e8f707afa9f97732507a4132dd133e31e30ed7e2c5b1dbf869a0266d778edf0945b50633a9a038a3a89ea37d82a95c7cfe1fdcb00d44fc9564f83738ed4b8c7d2840fcf153ab60f703649c3aa4955441a2dc74cf378f355559ab6ce1e93317ac9bc9199cd15a0cc20f03c02855e131a76911d7c1ffd7dc3ba1994f20f9097dac9373890519d20c7c07370c05b70f9ceb8a74351a18c1e789fb4ff5395bec28f49db247cce3272023319e24beccd2b25cdb61d9ec602353e6e8bfd3a1d030fb06041c5ce7c443ecde12d7b0c20eef68f9aaa9bd2c5c1a6e4e9b4714fe2c68f091df899c5d9d76e2b54e703d5300695bbe04feaa6a73cac42e3912cd01609eb360735f204b78a5b993e913f286800509120a94f50531ad980170f47f754d2c5f66f38b0ad22d3d4f287ac27b33416dc96883b5f1bf67848b4f64773fb6adf9b9b8c701c037df62bf7af3097fbecdb981aa0dc4190d3f09a14bfdeb1f5d55de2d2cafa2271f54ffa9d6273e0b8e1908e08b4c328a331576890b46c8dadf8f80f3a163cddaa91ddb1e86da8fd2fb941f0d0946daa5639aadc837e9761857989eaacdbe320d241b77392e2f75d2f77d470ef647b845127de992c590ac71e99d59efc1a449d7a2a65300423189e7cded4ac1fe10d6f25512eee650588ccc1bb4f8234f5f6e4daa3b6fc2871ef0f94ef89ee506fd54743a7cd2a692da320e847d8f38809a8c7e5aa88244f6c58640e57336f5ec5ea733624d599ce0943b7fb1dabd64bbcc74360c0977bb8f4c6905c1f177ee4f2ab7b02c7de9d3a3149ea94a4745b54081e45f390d03a1f2c59b41d0acc95ba1e5cc0ea768d9377e935c95820e3045adeb9ba9d015bda85ca052e777c483c200c56ec14d2602d381f1e905540b73b707862b57da7c12384b769974633d99afba40579785dfd5e4b464ac1b3fd978692fc796b94ba2bee38e1bb5025fd87ed5b19c066fa037b8e30a4f2c3aaba9a37d3ac08d3da4e05bfe3da016e42a44eccb3911a164922b9bfa97881835e428c63e0d434e3b39b70f3c3072269596136a80446b628d58adc7e0e5d3c10383f1fa3e4bf3750b9ae7d279da2b41eefe89a9d01454037ff0f9f02a4f0b2c68c40684cda9ce676e816f94b4cc8116ed1093efac347a117b2b373ae75d80c296da3be896db6b367368e48c2ec940d86c62e4fd0b5e05b25512cccadfb4f6a32d906b80476cf89ed69b02755aa336fae3cc7bd1999fb3feb44cc73557034058f0584b918c774370eb14771bf2ac71e56035a4edbde7965e74c5bdd062072d057ccb338ce9d8192dbc4dce6696d2615969ca20df024d33fadc528f4904aef92f9a01f528612761e422894329d5779bdecade473b1a74d5f6e232f926d14ff1f4b636205cf4920c6acc83585ea6bfd686c6fb78cff26f172c494faadc58e57eda330cc94c5475fdc368006496f405b23a5e3b7e87cfd51131a4d4c019dedcb2d5e975f665aacf452ac7d14ae49cf228459426623b97a2c0fa64c8579dd71df95850d6aa8449622ca827924d80c7df71b52ab814671e5cde2f2775ade9d2de60678811ca88c41f49c462a346e894fa2360ace242dd231a889e4c6f22be7445d2a0fba98fdd54d47cd57c3abf43393d1e905eeeef6d855ff71c461e8a884025b78bc87ba1f2dfcdfb8fd64e38abafc937e6a557c8729e43ac5314584da66e1a7fd92c49b8641c7331526dbae32ea8f38ac21d1bff1fb0405700a1051566f504c7c05193a3aa74d3b25587d37beb69b0ee532d2cd1b0e10d5e45b3bc7f3c8500c43b3ecf61f777dfe0fc0180811c36f42e92760250a831cbd50a3a80bc51bb4d7ffc6bfe8271f8fc020c8e394dce89271a140e57d101f8280768429331c0493023a53538d867f70dc91953f4d18a6b8b40f1b7896d1c6e8124237505a8193eab57c8a6c9612808048971bc94d6795a84d249c35024c9f384795faa54042cc8f9272a5f4f7e897add04b892c1db7ae6e86d6c21a404239d2f080064b355541f9521e709f02fa587227cc0beb8e6bba921108f7e0d685425c01c6f82f4e4d93a9661e1fdcb8564a6fdbf4b4dd25b8434b34b8d40d01fb2e1f6df07ece9f39715a0880bae10a78fcac898904eff2d0d1182651c779bf9f28cf04405ba000c3e18879618f230771e5227afde07300ac8e0ffa4add270d2297e5ed77eddf33a8354acdbd8fcb237b04da30bd9d34bae1ad828407d7abce449df3665ba260a53fb110ac350db9130926fa00e13f0fad706029f9dd78f839429be1a40dc07cdcc15b93948c4f358d61950bd6fa159df42ff061d896fac666731ee1bba2765d9ed1f80ae0e63de95f1e8262e74409390eab4dbb1c94c01ab540cd1f1113eead1d69cef32aca853bebbbe76c7be4b2f65edcc316d485c0ee1462b65aa7ab6d58697ea4f20db3fd4c377f3533142319c131331ded184e893c1079dec29e43c0371ad79328decb75a32f7312ee43241258f4bcf38cf788ac45f0c4a256d933b7132ef3c138975c30022ae44178d23cee257864c09f0530bd4d4c1e618cff1147ab620d99971eac5ce7eb90ff11de3022cdf8c0b5ad8b23f23ad142cde7e9587c1d0b8e647bd967d74e144ba9104615a52845dbc1d556c915dd8a695dae585ffe5479666cec5e764903197442a011e555c3dbfda328ab43da91a3095cd4090697c086b90f7c23553a96c4a0ffa42386180d3f42187db79d4f5f5a375e751ce1c8a64ec90590818b971dd76171e0cef75871de0dda6ccbab3f2230cf8599f24e9dbddd00b5ad4e9b508302563f42ab830cb885b7b2bad7ec760fb45c61b4922f791dd2d5f3e8c589d02a201588c193f82abd2838435d0e3b8cdcc85b63c18688632d37fdfe08cd242417402e1f9fb438a7e4d6569ed9aaafb6da23e76e96021631027c80c35cddfa5c052620137fce0211ecce02aed987e0eb94a8a2bf0280b38a4af42bfb3f431c4b7094c4bca454cf2373346e4a31ffeaffa93e26236ee729efcdc3598e76d47b579b4dfb0ac23c45c780b028fbbaf4e4ec4194294b86d1737aabf14fd03ab88488fb4e907b191b89bf266188b72ed3bd6547323a12288326c8edba675475703ea977c9138edeaf6a405e5d4ad0f513608a797635ecd78585e070a2e66c37bd513d6baa6216755146bedc86466685c36d6949099166e8bcca91c02b923a087bbdaba78c77e3f95072cc44b47f320a11384f54b041305b4123f5fe11c33444b2d75f265498d18e61f5d515fab5e857ba943707a25483c92c1a55cd7ed0d57265dc7c826420355f1fdd46dabed9befd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
