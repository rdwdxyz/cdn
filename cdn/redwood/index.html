<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"951cb38a165163b009e36c7e1edceb13d71d85926c9dd02dfbcfb0aab274659bfb054a94a473bca69f1074559f8060046cd721651b5218c05cbf3267359de0b69229ed25583fa169170b122d709a21e76934ec523327efaad9823642a0842e8d16c54a56efd6962cf8c3459d4f9b2ec953e60aabb9f50308d1c50f80c03455eff6aceabf83fbbc8c1ba696340bab4d80109a225f423a2f7f52f42f8aa346d4e64a318d493371ec05a181a43c1fb81977f2bcc03fe9ac490162d01edc75a204898ddf0fc9f8991b59ef1843ddcbc95354234292b1124b736ab5e65aaa31a70e7997ea6fd6da2986e7e53b87c79fcb3de81e621a73ee2cc339679e9d9d28d1dbacd6e53e8254e897b98a65d99f7c2fff0b44a00b0fefd96dd0ae776c2876e21c285c22b3a26822cf4c2cde6dff5df09ef215abc93fd77790d26cf466d67c282e8e2d49f1359a62c777044beb0d96d79be4042fd00ba1c4ca95d656d1dcabbac2a31a76faf6376267d3fca77cc620e0b3479c5821036bc8616bccb5870a3bf2a9680b0c08195c3b54ae480a267aaafcf176810bd16c0e513b36bef99e4ba9d61b8e08b8a41b003c67e006b6f6c68208a2e6c2e34ec5f7d2aa12509f9fbc78926737067e5b29a2d6ee2a20aca884b40f52dab26ee079e4b26502b8a3e66cb09218865e19fbc787e6bf50702b98a72b88fc9114b264156ae62c76c482e2bd9a52951522fb9eb68c0acb0dfceed934af9974a2b8c44460b0b74996ba10bc23024b758ec898469f7c3984a0f58908ce2ccea0002bb2f734349076eca239935415d3b9a90be4b6aad2b1d9b344352f1428e5898e4582cea7b3e60507b6aaee477bf394b39a5072ab0770ab58ad3d634a07739c275c710d0895ff22158b7d8e59339dde9aa4079b0b25b87951db9e0d1acf0101e94e5b02aace86e137d7f99781bab665bde27860873aa52e161a159a0b0be6bb34e743cc64eaa8f95e36e032e2ea6e881840c991e91886463a03981b1cb25a5929d7433155610cc2332f4ed12f90fcb230e3c24263fdacd55b3ab0e8877db3b8d6852a9b77b7d3ff5dd5126b9f3361b7ad7f9f9197ca3832e398be3c1c10368d0dc58bc59d61f8e7ee1b42235e07260b469cc2188e4d5787b756bc0c562d65d07b65b0d1f147334ae47127c88174c4895292400b1826df08a5c507b989b88aa7309d264cb79447c6c2e94a1764527c38e12353664dd451fef8cd1646d34697070ce668ed9bb61e477ce5fb113e3800fec462265a37ab7204d4b42718cb9c7755f965f220dbbb80ed7514a190f7b35799b1405d44929d0287fb07dc7670f327535a2566a4942aa2b34fccc013a77a3f0fdd3efac88c93acc5ae3ab47f534fb434ef338397483779b32dae84a7f348710422e12f86a5f303fd70ea5d3fc019cf62f528514e122e3fef41c6394b9f2ba5b505160171401fd2b4219d54392684c42ab1629cecd7575a33c44ac80dde2c84727d183d39c8c711efd872bd1f581fe426a3e40d41f5a8bc98d73736e6dc87dbd39077c065d1760f62f8a32350851eb226aca362ff2c8197e9655183d8279d6947063e48311a75d2043a72e66401d8618e9bd3987e390211aeb6daf7c25ebaefae358451b1dc418431dbc4701dbd9399a535ee70ec84778eaf3e102fe20547bfea16dce567c9c4ccb48415a4236dfd4d6181dc667c6f974ce76a5e590a47a894901189583a5c1845bdfcc2a2d130124ebbfdd3edd4f6783bcb6e2419f419220e121f475df5c49f9b4b344820707381185ec13a1e889ec88337e00f41e23cc20fbcf77e1f8f1fd36fb84ab082564ccc048a8a3a5bff3ab4d6c55080907766c47327676ef49f586b74baebc2f80d1d67dd5d9a773b32713f121a8f488bd4e138e395bebfbf3fe243f25218a6f8aa0331d685df91f978c3c59a140e3dab0adc462dd0735c7fdfbfb35384b84eb25904d93173d25dc09f96d26d30bd8e3b6ee8592e0c1bd236bb2c545a38c3f5a49fbe4654d134d493caac6bf5bd4185861e6919ee8471fce2027c635314d914a0a4414df78c4693138f9beaf302f5c1cfb5c4bde58baf1f5564c4d1fbb4c627e53b493865120efe13dd3de2041cc1cf1b95bd6ccc98802cd2bc13f650b49aedc02cb0e23d96f6ca96a9d00c3af2427869350f6f601dd109f3dc43ceecdec54f2c738c178bc3e7e7ff025b6716bf338fabe48906b66dfd3c73203bc47b779975eb30a1f6d2a8cca64dc8ce262d39693f186a70a4fcfd8f32075942b467ee9674ddb8f53f0e3331ac62ea7aa93e8acf10f426263a973a41a09cd96f4845535470595441fbd437605fb2074a4934ac8c9ae9a61d5b2c5334ced3b549b5c25e222a4561d8854e26104b8fe141f1f1e35e637da009bc5c61641fd8d8d05d4e027f6b15be15b123fb7c1ae7d48f5bad586fa673e6b86195f6d031e23362a5fa50dd9de3db33440b157a8751716da724f5204963c38ea7784d2836cd2abc5ddaa6bbc001b4a84c926b8ca96831fdfd17a48b1f10a9fe40dbdff2f4838c8d8c94f95dd09bf051643440db581c868af012866e42cf1530d156781fc54cfcc44e9f3af3a706e4b093caac3ca8ad00974e2ebe6180eece8d98096322ab7b1c2b99758e2619b69fb49c6b824b72e0940487e91e9386311c4acd5687fb42bee05a06883dc6e320a7118a0e002b73923547e650daaf2699fceeb3400a15d2bcd781e5dc1b496d2f49f8ef0936ec9b4825fca01a089915390bf4545ea0ff36b7f73337800d3a9ac3ab5db2f848b9c6b8bd0b5a03faf4145921d475dd96602a6ded9f79f1641c35946859079e46bd4b26c875a2a331394830f8f344de957a96df91f0d5447764cd2091b1a17da2fc1a8d6208e917c2c66472752d3ab50728dfdffab6d4c2bf7dae382ffc6425cce50f4934e53b33af1f310ce7ac0db8471213391404835760560ec299de297ac4c416b2bd24a20dab2a803ba664523c58023043954b4c0a9e55936cdd8e2fe148a239954e04afe67c15b9641d3e1acc6a2342b403bce4310a1143d8406f532dab4954badf0d99fccfcf495bd533ddfcfdeb3825701669e521058afb62e150c219f0f1e76c995196d19f9f0dc641235705e8ee905af50181b7a3b677b02ca9c1b821a197164c270a990a9ca082038519c0b51cd9e040b7a0c4026016ab855a67d201e620d15d1197e357b9abb109092ade1142d0e8932fbb124b2b20b4face411d05bd369b4bd37b854082940805e3ff295d86e62cd69fb157256b62ea1cfe4fe45ccd94aa57e1621768bd25fbb477ec1eb894a7f66d7f811265b764c10b54645cf949e13ae078998a94324b9a23a6a54fafa360a9b7bf5467e4f2a49ea315209bb3d875e995ace04384423048d352a91cf0a90088f5f053ce589f05e1fda9edd54cbaf6f79f8704dc9d90910c1020b9835e1d8bc85438dc87a6ce6f1a1e3b776f42d50da8b88457e151824d288dbb253f9b16d15d8088b792025f13d0875629e0ebccf5e4318f67f2bedaa3c1b81037784e23d46c30d5ce25ee9e15ff39ab97b6a76acdb5f4cbcd813b483a34ac23aa1d807b38835c2da7cfab66f55b5b7eec73b2db611c7ccf047a6bc6967936d6898bcc4709c860f0279d691bbfbee42482e8fac1abaf82e0dc60cb69ad1431b0b2b306dcf84cf6b3007e18e80a210e9c7d1412695a558bc404e5fedaa7cb693aa80814d93e7ef1082544dfd249a944f11ded16b353f7ce704a7979301968a4fc35dcf5bf822f2ca36239d86bca5cbc15f66940ff3d32080cc273fd192bd3a296b63b4b1036e7e0d0be5fb9a485d3ea6923eba8549a5aeccdd72590a4db56c0277a44755c3f526f0f27bf22b060fc880f581a5a21021cef080d5bd5ef0ed3e36b4fb3419f596622a5b6445a65514aa0f5c88e93c3587e9d203e0b74f408b0f176f9f13d7b0fba0ae800fcebf9b8bf4edd84cf30a5f351615c83ff865b6b6f282d2da153d4127095d799642add3118dcc72c175a92d9fa6562afaffa7ada39a0732d365d4be52e53191d647dcdb48b19d09055f1b740298402a70b1ec96e1e03d2fd175a3abba336d142bc58eb52cf86239df59c80e1cd83087a64235fd0457da367209e62af99780e2aed89c9a015a0a170b64573ecde059467a494a0832011daad3e334b719ea714f7e095fe06716409c045508b0d3ccb14e255662c77842e75afc037ba87747c83aaec8f6321894ccb714c1cde9af1928724be378623290d46a9a730c053432a739459f823a6141724b90308d3ba241edfa8facc6dab55046c873e3a6a4c7ce26480eca072ce4c4827ba6ededcbd11b54960528c84a28f3c07ee645e00d22e999ebd6805ca2d673cbcab788f74dea8560a1d39ada29309b96f8b9035307ff491fd565dc6e34eef4284ac001702348778f95c4bc29acff25b8fd24394870dab77d4bab78b5b577166f4c13180d2d3b7e47f0916494d118c1b53892a519a1ddf07dbbfbf38ab0c369083efdb63c082039ea06126dc1fc7029b70e5400037f280d1df4c7cc9792dc4f3a1976e5d2ae4b4ff4b8520bab87f9e2327b3e50b349b444005679a265a82236ab0be79f58576dcb352582ad3f58867e621ac6cd1f78f493a1164093e1900c77fea0982fa6c668cd908a7b71407ecdc6544b6f934b50bc7a0c05ad5675bc5fe2c9b06ccccfdf2563c15e21291bbb6be6a5059618c16c87c31e5ac5433d04e46ca965bb6c8e4c20a2f8c41d209ba12b8f788728773ef0a219983a320385499b3409f6724828c4abf0f82c891f9f08c08667b334146c0acf51793c0b6c050c04e394d3fef959927db769ee57c1008fe8f44219ff8e8aecbf5840ff998c86a399a54e4b24869d443c624f7653d468ea420dbc616ccb684976133c8f519b1527ab5fab59f7809d95c1721180310aa2209da1625b8420b1ca037ffa8609e4100e1c92401efa82b1f7d3f286a9c972967de9ad06fe4628ff524d6d7642d2ccda64938b5069da295d9be9352deda56de1e188e931007a061747bad6862bd4f2ffe7429c829599e276e62aca2c757ff34bf557532e77a0c1a974f5183da8818045ea95ca206f3c4ba9c4c8105911c9def97f45ed6af69d89f2c205def9ea865c536b98beaaa9425c3e36ca31468a90ba2c631d567a60f14c4c27ddebf4d502d60af12c8ac8a1e1c873266e999e1c5ca2763ec8b127127d95a811911c702fe9aa5bfe603b37608c6fc6ad61f246cc720dda9c7f68e8feed3c2b15d3facca8eeb90905ebea76c175d24898824b8fa00a9a54d8520611f7a5a46bdf36c4cf1db6ad3a370c597e0ea08a8b2c0a0aafc09ca0926936587229717d7a1c07d2e8059ee6bd481b9772508bff20134b3635639fd4af2d397116a6f36d11b98685a6c61b92c9d021c60fe665d79d91f7b5f86194eb7e6fee85e2657a4886f4a15f7d4de4f6158117c29725dd221dbcb98256ff4e710a29deb872b9bd586b9b774f62046364b22d8128438b4d6388057a33912755bf692c2227abcb70e868c977c582be6d872d4d560b7c3b4eb5b198520d94b62a7f10fa84a6e564508c419b9d28ec2b4b509504ddfce936b6084dea12c95254c0fc13e7b7051bd49c729ef4edceb90dea380e0e839bf9461ca3a3d950f589d3b9eaf9f2689145bd71a443c056603b74031a47338d8541c4db34faec72b74daeef001a309ab6710e6296f72f13a9f655befa36083fd866b0d844f05ed6426dcf5ce77b44ed366cc8aa855290f2d4ae09c185f35919229711ce355be56cda49046a3c01b1954149c09f66344ddfff8e5695cd3861c94ef671eb34ece9ca804e0f80fed40eea94a8c0facb922c5dbdbd913ce4f13633adcc6442e0bf4c6cd08c3b20d108158a53631c66731b3ceb4d9bade8cce076a07d6e01cf15ebeb46c7b3997ce308bbc3fe2562e2b643801810b994c59fbd815c36b19180c30d4f54c4888b8a31d88858b852a45b05db676bf63d867de33ee7daabb8f87258ffdf4a677326b022e8078c379356a9d323af130b4f6002bcdd86e497e3ec630724c5697e0e9f97c448cc5d65e33736d4569ced7d07fd79acbbdffc9319762092a637a583650d43f1f081944106f8fef2e61a4a34fd4c2f0b283f0614a3d6e00cc6904509fe2e1d0507edfe727b583d6a63e3bc0a82e7513b17588c37497f2bd37594fb28372fe928b973c44da744f9a1f1c650fdb6ff459e4714d474dfd7fd2918fe300e1bacdeb20fcfe37260f084224babcb75ea44651781b4f5c9015df7ae128434b4ad730268e3c98b3c15287bdbb47043c5675031ed3a7fd3fc0699aee14edc5ee16ce2101ee1e566779464a278a8cce61cbc612d1a120e6716608b1ffbaeb57f18f980fcb9fe280617ca64dc5f8fde350bb4c908f248898106d3d1c0b6b35e2bd9d5f2e1786ee6eb58b1a24385b842fabe253c580d219d60d302494575f805b4dc1e341558d4794f9dfa1079b4c61e1d6fc49e3bb546ce558921ebd0c944af7b081f6f4abd28f10e2ecda5804e744d01509a69e97f87ae3dec1d9262799dd7e13f0a8fdfa327640b0e707495b16bf418ad8ba1a90c513dcb34dfe496789fd8b1ed4c19aeb56b135650802f24334bf0fa88804c1b414409396d5e27ccaa9b39d28346d7b2ecec3fabc06cf5b7be4cb1a400a89dc34fe7ee50b0db2454881fc9a94e5e5d20ec9065a6070fa0dd746cf09ff6a40c7f10b06697a47c370dd126ba622ac901aa46bbb082f9b48e886be4aef384a8b8b7e19fee0179dca40b5592a3c54f6dcb95cecb0b80df54f7d9d0b317cdb43245b456955a0f52e8a80baf81edb5456cd36e215c3dbc701cdc0a4144fba1181342600475e211ea7ce50b5d2275c12b3ad356cced81fb1dd9846cef2a7d13c4036d05f4d29cb5dcb8353b88786bec111036322e34d579a34c1ca89c27cc49257baef8ca87681be2fdbf3bcf30753022f651cb2703c3d8869726c077c39c17c3dd9aae9b725c33e6e6ddc56f8d6605ae4cb5b8606fcccbc216d0c87a66fbe17258a056494f995eea5e39d36abb4742af8772aa721707971d8f23f5baf4e8712db5eedbbe79fc7f913bdecbe31449db4738ff17df266735859a24c3fe437224668fa6035377eb11436b71f593d0d6efac859570dec141b15ad6488e034e6f0ce92e0e8af73012adaff517ac744d5d6774be7c2a42c0a38f8ea6fe041e1b56ba1fa5e14f66a5f180033259fc6fcf163672ab85928fec12d41f8d7801f9b9b7ee02aa0b4e898ec6ab61088c790f90a76b677fd46c7a8a4805adb2204d74f0b9802a2ad9f82016d06d4a9aff997719432b0162a31af7586d924c6c7accfd3c12a44c308fdd725cceb51207ae1adff6e6b7e6e35f74a95720a0ede8b23b2723d373a47d9380cbc114672e34157694c61bf069a9150dc26acaa7ebfb259c2a437f567d30ce523fa3d0c84807a26c1a77e5c21d69a532c24351a285f2362675a52ed560765d88eeb7e99079046a22499b108d9878e3bd7649a3cdcfbfce7d083bb397b674acf027d526c5539b25e7abaf5b730583a0d86c89fe24b73a1025615bc92f9159d43df49af6b3bdf49b91864b867ef3f49a7b6d00126bc6e7f23d366e063c0674a3cb2929e5869d5a39a69d0d92e696b0202322701971317016c9eaf56dd4839053555aa9725a0f0164b53ab5fcdedd4272a78f2865e204c63c53f9f393e3aaefca8ca9207291a72e6c02459d62b0315f8d60b1747f7eeada3c6721da5ae6791798df97a54b2bb1e4bffc979a3b8cd2f92b322e385a308dd3c642c53f54704050bfcf16c198a78154ad637c42dd0d4476a7bf733de8bab290b295cb6a62fbac442e60423307ffa8154e1d2fcccebcf3595e5fee7bab7680b10cea5cb6a82f1d6b507fb3a8f68dbe5a69a697688f438c850cb4e80557b5930d91b0fc399ceb5a051f03f21396845b29ea2243b8ee5e5949f2b2de951178d5b0b82bf604b479136f232c8ca20dab278c787461dda86086193f85a34e8bb382588841f3b805c1ab18810bea524b7e5ee98269d002b9a4f1a715dce9a71765783a073f4a5f196fa10fe5f4fe61657a9dc14c682113496784d602aa2375b286e9021a89ee74baa9d86de6afea9e8080522db04bff2a4739d4eaf0e48fe29bc44ad259876988e12ce046c6fb74e3588da32a57da12d17f80d09a867af547797e0fc8df1e75fab2c3a73b544e16bfb3455b4e55c74daf88ee9bc9cc6d0330800667c4607e19255fd5d24703b86ea80f62305d65899f61a06651fb8620f7d050b2adcb11340ea45d9ebb34973129c927d149c5ee8ffdce1120a5f505d0c6a4af2b0ff96485bb4e512bc382f64fe249f36fc4d56d6406d08fed0d9f6660550d19433963501bc5e5baa0b0dc420736aa14c61dcf1f29f6f03447dad7c1758dce0e30d63d1707f5af6b0373c665995c076b1fb063b4c0589608d2d8fb9c52408a8587ec4a72391a5ed6ca70e62fdea16b5b650f43c87bc00932db8a70e90768f09c16f2b26359447ce7cc33357f8fb90d9e94d847d6edf6e87adbb06512bac2a05bbce38fdbfd395f39cea20210fe52c654fe95b666f360b4e6fb49353f19430fae29721f90594e9f172f91cd762094ff8c8c3be7ffa189cbf840a7b82e7b53416f3b5e4467b2eb683af7df36fb68da8049d9b32e1bde586f4a459e511d9bc5a0f8d83b931a347c1ad5756e6c9ba966cbe8d477915223c50bf6fd6bcdeb3a3b2cf828f15ebde611d39bad609b1613dafec44d834e13db8f48d348ef04abacfe91cedeec98cd04b3c639e591d9f5e1f535605a36c438948f073a0317bdefd1c755e4a345944ee7354c8d876b5955713709a6f3ce3797ddb1fe45f72db1466f7907948b4356f36da22229e71eb21b4d497e5f567a2e9cc9ad6b12484965092109cde065db52e38d790758aa7d81fc87581871550c048995fe7a907befcec9eb85c3a50b88400cdc38a3dc23ab8d9dd403f22a5464264bf4cc3de4d8d7f4b942092e09f4f6e6e76744f5d5c6ca5a23fe96bb04a879d6f690b8ab54cc452b01b1715918514e17ad891e36b38b2096ecaa7f4a5d133ad6a13d48d32553f8de4086ab012d3a72f487c1b8817e173add519a4a681d1322e6e81038b29c5c685af6c3ba73558f22c2b3de27e4e1411a59e0a3e7532bbffc3bf212bbfda9acb83f935ed37148b68429f741c0e9c110f4ad1952d773fddee12eb9cf91ed7476868651af4db554a59305002afc2f0268c5a9f50ed87e37382e3bdf6bb31a54dfd3713802931fa6e4bb4523ffb5ad3bccb55b2af2dff6e341ff4344827c7fcae2f4c85bbc9e88e6bd71b77ee3a9516dfbd7ea1abaf1ec6d08de5fa89125cf0b3c851de742fabb959d2197ea85552061e41a21b762d07777a3a71b442d5d7005b121187e4018de656037f3fee23b9b92c9b83bcbd3f60ae82379849adcfd56c610433d45da2892f08f3d6083c84db48a9e860ecd30225aeef5ecb31cde616396037501d8104dd6a29bd4b802dfea1271e681a11e4f839f01a38656358af82b41e27c812cf1b38b0b09e7b78a97bf0e22f7f0f84e2f719fb59c1f8a174c262e6c1493d5d8de203362d1bd975b5a384f09ff5e9928d47722c0ae1af0d72ca157886f2f4c299c06d5e819f1f89d64b52e3ce32ed7595da1617b6a0fd6519eb777e3a01a80193c70adb4cba759f43cc4f3d8f5510e72cceb70305825293712cb75319c5fbe4555f36a293009c5b569ae76adf98992445f119efb4cb357ce31dc3fd0df2cc9b3b2bbd44200d1aa2c5f92017a645bf7413596990fc63d9a958ad801e35a62ef750fa38e85fa8542365422e04e5925e94b148c825114361e446c18903be2b5cd3437f20bc9b0acaad6d5bc4518fb92846bec6073d10e9cdf09fc1f45fa5c2f8bc1e22477d4f31618b99d5a3451b82cf9c17b5b6a8154d73493d5ec88a10169688a9f1a22691692cc1e7be0e0f19ca5a842c3d90cf6ed2f0ddb28509f05c8095d261bd9b388859ecf78c9638a2d434dd165338376b09e54980c96902b98c08efa1325891a7e34ae4fb685b4cce9c72cdac48af502a753180ff50de476f1e9d27bb6af3a07c3351de71c0e89bbefcdac9518f6cd69cc0b02791f7d4fe1f28cb1d6f1dfc1286ac549e2f5168c107bef29ca6960d4ff8a3bc1c36531fa77feac5db560f55c4a26816a31c9810b5f8940769dd9d3fbc375d054813bed89ffc59b80198c6be8aa3060e75b97e4ff2529b36d4dd6cd0ece9365bd757bf07a568a6acee3d1be5372422f3bc92c5a57d38e717c7cdb5bf345230d4671dfa8c2d2d3e441b3ee8ec441d07932d363f50a9e420f2f0a69e51fc44f41bf9c38e6cf58fb7da21e939871642590011b3d354e7664d4b65a812b552bce5b4c38afce9c9f2eac9cb417fe70eed128e24a8f63a110a253eb0eb033b07390199d610c3efcfe6ce5cd86cbb3979374270a2c552e9daa99524ead42c011e0daf8f2871a8f91948c0994cdf4db9c3ed2ab30da3e8463177245efe17bf18c4b98755fae1a8c7e4e59c1a2dab396f7efda441fdf1b1e3bce0b89ad85d93c56a84cb1dcf0be06d5135bef555b8b795d96ee7358958791bd034928948ebb954444b3275f49adf3c615f35edfde00c45024e8b15a2c3c4c0f0c5ca12a6ecea9c1acf698acfeca2e832cfcaab0003999d37b9fe64174366e9748232d5f0d06ed7d240e747a92febf50ae0e3a13db0902311deaf9b7498ab8bafa7ada093cdc94ae1da1fba5de6ea79128dac4d3d7a68b27731b31566cda9d14b8f567432d2c6819f9915c1b6ccf986309a580e25a7038417b071a5d46eca2743b4014ea5dee01b6d1d1fed3c287cf444d274e6d81b951c4a49f742bb58405b781499a9acb3551dc2a46607f7a60bb8c618495453f9255bd3811224734cc265e409e4ebb272d27be19e3f03b76d8a468cbf204ecd87f02f1e34c98ccfa88af668c3f903a900068e1a0ffdc0487907733b5f928ccba2736d2888f5bc300ac6ad136ae179d7a51bc101df95f1259198ee593965dee48854e67ea329d29f0eb7597beee92e98f277f2bf830fc10f3fa92b357ab3f6cef071276b7d00c5ec15da5a3f9dba15e9236abe454fb3e5e3df3ff2ef52bb51a837106d6aeb03885b14c6a2ed95da9f714bb50eaecf3c1f3dbccb954084576c19116350490ebdffd79f3b5361add3e1ba8ca9325156daf0c6c6455737c64f97260bd5f39c4d7b30d71d32b74fbbcf8d91a090f880c9df5c98f22de71317f26d1c088d26262a460c3e6402d27c6c01bc8431ce457c6a3ba6296defc916566a8c4c1d124ff1ccf3466a25202a8d62d4a7d9c5f1fa08ed1a5e6e573a2827170eb6d129985621f7b866505164c56b733abf0a4c304d8af1d8f16c1b79824f0bb9f2afa442987f78e623dbc8ee61d004781edef5eeeeff6db86f11acf0b37df4e65d8bb75800bb3fc54926553259e9ac05f66554d6d0b2cfc84d1193cb0c6c32fba97e50626406aba8b47888a9494e0dee156004ef9932421c420a7a064db2e01830c2990e11095c14cb832a71036ed1b2cd52cc198bd9e238a5f12800cab9190b0a673d73637ee67103fc5e1c090a8f2619bc026288c1d841ad205dc66015a0340c6cd4bad34fa91807fc0e85bd33272ef253f92a004fecb2720354e731110be9db15f4417413649861ca340404312d210af0dc35a5c2ffbe2aaf6a063ae85025a8c65ffcc180a046ade3186f7abeafbc6615fd3f011d7a8e130dd39f791b7e1cfdd96d7c56cca6c925a2abd9683887fed16f338cc54fb618a13adee526392f7b79f7265b87e0079f77548b20d968e842a1ae17b979d48bd3b4f9a841f593c02222ae6d4c3b10954eda4618d62e9fd02ddc2e883273420d8446d96a158f99551d7a2ca4e9c5a1b9d1d3038279867a96544269578d34998b1628f035e4a1fd3bd560c6800a0a3a18f1f9c320d82ea02e9650c37eda1339af0f9324abab23d6ca9e692070a6568d45349269b9d8302d96c8f31bc9c501d943db8320077dbd0f895777302d58bf4f280330c3a6b9ac29fe64d025d31bddc83ae9d318885a082a816295aa717f5ea64f71a85dbf4c989a90d45156fde15041ebba500f8519bbf9cf925bced301d825357b2e114d95fff23deab70c72216f30c287e0937067ec360647d41210523d6acda78574c54b18a879a437a6c1db903c31a2af87958760cc2aa2ebb4413ec37d743783f491fd8c0a396c53e7839a77e9d89eeb7605149b9578829f3dbe712e4bffc63b3c70e26d7eb2c6b7aa60d1443e93a0537ee6c63a7c980e8b8d2bb6e84df97fd861a159aa2195dde499f2eba861a65a802eb1660d4e982fc9edcf23878bfbb274b8e1236ce130deb5ffbd3dd43c1bdc41d6637b3c1aa43b2d36744fc82a6a5c61873c8baf11bbba596bc3c5d377e104aec6e2ad60dcd78cf019f4756547f42970c7da4a1560cda116ad1d25562cb69c03af89e2eaf94e3b25beac9f3b20f7a0d6a3443ca4a1dd04ec3a93ab10906e9e2a9155361f82a9c6fdef6ed73db01b097dceb8fb42ca7c062a1cee5953a7607076a407dc7ba48ea9dc7cfef02f1e99f67c7c120c2310743f01544a53f68165a9b12e4956ff67c3b103a8c1a7494dc520d2312a41952c842be173cf1b53cf75890618f3297d001153642851133b8adfaf15b4943ed65844ef84071d468a2e2381e9b294e5c9f8b0c159980e2df8a48131a2198d30f6debcebff78338331e5a19d25b8ffd27ffdd0f1750e84caad80a703f2e0e6f845e9a6902259e878776a24ddbaafa0c8b68ab4de50403e7d24349e69aa99657a9ec0a6d42d02575cdce1e00c439c32f6b1d1ffe18fd5be64c3d0314367d41966395b7c087e8343202dd723b1fac5bd0cde215e85a0ceac6a2b2ab136ec3321e65a4b9eba2ae128a2428061097e828df6b751370cfac298c307bb3734877122a1aead4c6e6661331ab669353328a16dcc504ef0d14aafda3554a160030537ada1c64ffaa658ca06358257a82111a0223255ec63a5da811b0046eb25f485e32635ecfcacf40e685d28eb858ad6e48c282fc9474f041f6be7e775623aa421db820d1559ff90cfd97030bf092893d9fe99eeaa6b4948148b1fbbf7fc53d2e46da53d1dcda6643ac68b80731e2c3a39f881728a5983f87961ec0229b3794c79c204a982b8bc35b5f28d456f7016db339c66600a0ef1c84bf1f0a28d63642b5825cd10457fe45a742d55e75aeea7d286259645d24278cd47fa93879a9c5dd14d7e76b7f9d8e053400a6becf0f25c2a045d8ee91763f5d9c856d630afb51bb7aad7b4a493c94dd7f2c28283ebe28bcc4d07bdf70b2da0471bfa80559c4c209999bd653613f89aa2ade410fcc700a704348611fff03b9a57ea873c581c7bd821b9f0f2aa94c373a49550d38c14ebbda0cb510bf48693ede6455a9e47a1d40e4decbc0111ac7d6edaa17d8d3d8a5ff582aea682332129f4cf658bbd07447771ea09c7a50f8afa8fd95bd34d35e6d7c11f1336cb6f091894273a2eb839e0ec35c3017b7312b028e08c86f115f4c0118b047e4a17979c29f78757093879bf34187d94de618a28ddcd9d69f68f1a6d192446a281ff6da381dea118608a726857b1a10b3872d8e99d06e8ad19f8c10566a08d781d0f66bd8da755fa0d3252e70fb7cdf320343c3bec778747123f037d2a572fc48d70243377297d749c62d52a6db9602a36ac10ccaba8188cdaa8bb10b586c22322ae720e89e0b5cf4977dd67fa5094933da65f26665461017736183c7cb5e480034318e903ac9331a035697e7adee22fae8085101ce3dcf9e2db07d0d751488556ad99077ee54984df6ed6a25b7879a3959f9ef8db00b99aefed867942ef298fb59b11e17c836b62a33cd01bfde17342666407ae6f2d0ad1bfac2abbdd172aba34c2464412309173cb86730fc5cbcd853262ec272eb1feb56389dc9189f85d024030d6207bb879335247398977474f234f9c4a924c4baa11007aed28e8c2e340adc274262a86550433b954253d02296b1c5c51f8c8c9597fc1bf0b7e8ae5a1e6faae1678fd463ec6fdd97add20e669ab9e66dff12396e6b4cb56123ee64eb633811be9929073cd90a1231d7572ab77ab7680bd4571b5a576de4361d206f5ca803d0acd3775164ab6da69a558295aecbaf3fca918c1b0cb5cee1ae8b3f451de16f6e17c7250ae304ec112e127be1d9e19a57daab4019db311f3ba7fbba68ca0636d5cb05cce754b6132d989dd0fcf15a1292d8e245e4e8d71b4fb479764df626c218d8524d1802daba8e7979fec15b3c3759ae299ab2bb6a35c97f2e0a290a90d74dd5e1b9d6833e3c0cea09f5e69ee4525143e867f95a202d9f7ab67743f6a00c2e37177ac962aa16f30f9c0085629963d28523f43cf3a773f801a5921a95fd790254bf127d9e14ac857ea2624653c8baa640ba14f2c41c41f6bfb1173b846191df5d82c1f83bd7203ba8e793565118eeff97459cbfc371d82254768377b024ff8d81950c451ac4d332fe89a617f49652b74134a13b4156a822f7f951cd88233e4efc1483b4952979da509bad85520713932960d952bc37fcbb5195a76b7371745efd70193ff8c0090b3dbd7a566e1f04d47a66d4297ffa13e88d6a3bcaa2c5f1bfe31f86e022e2be584f3481b000689ab2acacdb3234f749a455a7754d57bd299606bc5de689898f5b5d1d1eae142fb9e65d88f637e5a1baf03fa5aeb53682ac2e71ee867645610e20d5d65c8c12df9b54780502fd863c80b4aa6d8419b1fac18c64e043b7a19d757cc81314b52c111dcb6e99f91c4069cf78e00c26995261abc1470ba6374bc59b5ae681b77ef89ab446f65da79b1d90dc1065b7d053c892ba201ebc66469b0eb9983cdd965979a42070f19b655364c13db6f355a4f51c2e3510c754e672c1540bac7e16b7d0ccba31b609b68c26dbdc7de39b6fc6bca04565ea8e5ca30d062cf29e1f7c1d6a394b7d94ab31fd0beddf6547c047f6e3b1fa36de274dedbc9df31a5d46767ada337cac8e3435db5875d8bce30326d61a07697d19754a790a3873be942026d8c594b7032a6e0e1794f437c24c3f238935544c2add8b3b79b6e1ac2cbe3a0c4a069a019859ae15a8ab575de60c7f76b32a3c7a824e26d5ed39d87749bdc2de4a1935ca98743b46f5d6ad91d644d46b4aed077bc7eaaafc52527ba754545221630dcfa41b87e67f14d53b75a4fae21746d4384255e8dfda542fdba101e17ca69e661ada24228fb4d1a9300291b0c0c70de9d885f7ddc56dbbadcd7a6b60ad19bbaca42d5b66ffa1e8a87d0365b4a8167d36f8fa253d27f1edd36764e361208bc603118f75df726406863fb71f66e23fbf2054413be808c9f9920611afccb05e37ad8a6ffd0ca281ebd5127afad159972a2cb6f330be423e20e94df103d015aa533e8fa89d79a84baeaa8da820e1060ec2a49dffef169e0c154ee5679c32974f1e6c54c6ca5bc002a3912f2c401506aeced4967461aaea1a9601895630724f199703a2a15be252c00f0f07fc148d9b4685f289dadb11629ec18749e92b71e15a7f3a4e93674f99a407dfab4b28fab006c2e7fbb820006a6bbc5e9d45daa7f957cbdd3ec817b00509201fe75671ecf305c27835d387714544aa8863a78af5b4c9a652180edb1bcf429f07271896b78e31eef72e32b60496c073559667248ec94f25a9b38c48ebfb2d362b4bc95e34b708f88aa8b5e4b962b78c7843839d44a1b9236a593e6f313cb98ff6cb44b9cbec21eb8caf6d91dfe01bcdaaa60677659ca38c329f41e59e749239e3b5d3dddd77caf796d4a4576eac36a5dcbb8318986695f79cc651cd75dfb33348a887d53ee819a9474bda1d08871257435c0dfb4cad226f4b97756cb88efa9953ad41336fe2e897e51549a2049bdfe331f20af8f5fe905f399ef83c3d4ee2f69baadc0bf8410c162640330335c8cde886b828326be5d1359d15c8194d581f012feb825705aa5d54cb8215c6612bdfb1f8c1e9ceb6ea5faa4789484ec425f461af2f8094f152f7d0a03f240e5ac5e9b3af4077813f09916a18d8b9870414c63d91c4c8447011326f154489bc592d0ffb5add8285a0f0c6933965a42f76ca95461343d0f81581951b93f7f38648f7d2e978258bfe70a5211f8b155c5144c147562ce91d2000cfc0c45d1a1fc2f2b5c11f29fb57c3263bb09d65eb71b8a9d025ca68202167bef708cb2e12c575560eaa2cbec066d8cbddbe80d21576982219b74edc514b4a47df67348f1525e54e845b10a0275dc21b256a79696b6544167d103f0e328625ea7ace71fa656c32d7bd6cc53ffb47d6dfad9f4cc1340f63dbfdd79702a9b941f5d6156a015b9432502a35ab9bd5c369fd1f8881d53c7ec6f843f6d819e5a84800b12d56cb7947c0d26dabd5322b71e93499713de5401777c5eb7901591d9bb1e9a96c49da3c66baaedbfb10f6ff33e22923a177d7945cdb0c6f4e409ac4a8b5b6dcd8927301fb936bb709ffe3e05e488a6254fcca462ebe8f7da80e5e708cc41ac58f686655d2bea11a2d3f4676feffe1090426ff95aa29dea63cfa6a6081ff19c5e69ecdc0ac372bd2b7a2ee5e53285403330593ef1cd6e893dcd8b27e4b3fdadcd854377cfa2e98acedf72355f12d96dacf287e12303e4dea69a3964f4a62e43d9cf7d28239fa08f1b909f97ec98b25a713152d9665a517b4dd8d3a64f87a2e54b484255e12e1b5f632cc45552791cb61d7a68fbb832a32d34daaa4ef32a16321e646706aa8ca57989c6020bf239b23ae7ca70e7b40ea6201f5a7d4e28e56fa3fb907cc188bbaf61ef5c456ba4f30967d184384d61a53be9b2118ff5590fd47bc61bf466aabdf9931f303efb1a7bd3434516aecb3dc9d1fbb72ed58f4796f1030e90dd4d0f9c2f42954d5667b461a534264d86d015df1cae64642f5f7673425ca1f22dbe8849fa71ed44069f0d70553cf3381f68c1431fd213429902bc76375c1751428ffe4e99b3cd7efdee8ecbbdeaca06e54c8a048dd5d2b71299afad1e23f793e4bb662384c3bd5a2c43e0f7f75dae9db62196758ddf1fb73ffc04befd3bb33b22004a75af987cec79439d34d026bd1aa6248b20cc4a521426291f549048d82c73dde31ed8490e9e345460a614dad8e354f11d7b5f759cfdb7aa4d3d23fe028e918773a86288457369e7781b60bf0d2da862177e59c8f573896faf8875232149f28ef2cd18b84e29a6973bbcd319c2d2c4e47d84cabf2d1bc4e28908a3e0dac33f50e67749e88c1e6b76d80aeeac8506edcc1bfbcf51cc4f841cbe47c93638f6ccf2a319c7875344de9e034af2d7bdeffc0ad808fa3aa3eb471e7f5ace636accd4e2d7693b662d4165297e977b1f27d1129a638e70809bf09b158087741807e40a897d0b646ef07e04478f936de361ff4fa77a31fcc67cc7aa3cbd29635196d20af8115534db602c01b2326cde758d8fda2736650d1e21633e9ef29e7195438535ad0d8fc5798002b1c43756a38bae266b485831e4e8a60a7e1ea03be5eea35b8436e19caa65668d1e598dcb40012b023dbeac85ba387e16cca5b22bf58e61ff5d22a2cf10f674b2c7353d9510e554c07d76456b3a5090a55557ed27518577bd83ace30092415883799990f4bc0492258d9b6af9f4dc276ad20a46ebff9ca6a3eff2423c793f17c79d05fcf69e0c93d08897acbd6aa92ba367bd32c575993d566a15f9c9b3c06a8059cd64afa0ad161114f2f2b99ff65b001b62dfadcbbbc522a07912af5e537d61261731e2cfe3df6f0b5323de7914e7388c8938cf06c0187725c28cfb97a3dfd9d5c18cec89d80ba2f6c77fd8137bce42886d20f589ee855f139c2f454994a827bfa9ea8747355dc602eb5108eb1ddc31c6fc64c6a339f6677b590682ca60c3b97828d12fdca8a5fe7a4257e0595e86168f8fa3f12cd2ee42305ae066c13c5c7d7d7a3d356562d3e372a25f87e1ca77da14b2aa0d2ec9b2b491f6b0f5af633e79a92513768d4de0ed61cf6fde7a61ef8c96","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
