<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5666b462f26274cb61c46d0ad1315bd65e63dd20e4dc9b409fb1adbf47c944d69bd7de8a3ebce6b07ccb29eaa03564dfc5f646f7a65168c5199cbc1feb0c6a85537f401ef3749398958cbf9d97c09751640a0ef43f333472058aa2fcf55063065d052f67262ad56310208f5011b853c81a92f4ea683f52831bde52d597e159f0c41074831810268c78f218a43c0209e0deae54224c6e5e442a1af65d099534da50198556156e4a783949c88baadc7002055edfd8f524fcdea47c4dfab7dad2975abdbbd358ce25bc4b7540cdc1e625b00d428bb9c09fab13f1b01246606eb50f132eac3d2d5cb8703436d2355aeb972281eb9db9f50e3540d03af84e5e18edd174eef0c92e2840e81498476a081cf2689e4b7a0e2e564a6679e1f825d46acf3ba4c80c274e4bd9913927fa43cf9bd500f3b5dcfc193cf07907c36f047e8af352ab9eea502738cf8a27f1aeb958dd495ed1164557cbea831985c7074a4b08b00f5abf7175d88e7156c80c2ad6a41bc79c3450814f108fa03f0b3e81b871364c4c22871fdbae318f650074cbca46f80d0360143703cdfe944264912adb669f778b3fd8ad1216f20babf6ac7c68d952743c52eba07c029e4be54bf155c0976e89be07018136ee1a2ffc728365300b2ef687c5660d0522922672bb997efc06d26be6c1f7750bfca46b3ebf648464b53b4b3775633fc2afd9b9cbf5ce353906b09ef1efceffd987afd7a854cbe9d3333f455bcfdbcbf4a96ca23afb474ac1a2b57bcf1353336dba8f292a623d41533a4d72527a2dd50f207fe2356e39aa6c61991bfa16665e3ff21f1d74247b13355d34e5e4bf5d0b755adc5cc50dd64aa33ec1ab6f35e917faa0f6ffa43ff63a97f362e01cae1e11e608148fd8120e0b9a9e0d394d0a6d528c72b62a2de7c6416c29d555dfb2b01da57e726d64d3ba74b75d877b14c744b1a9df7d52e54217ba3bb8f81d5cfe045e5483dad940b6394bb48a4947920bf9c43d73c6d305ef6fe6897dc5efa1f2e7af0d3b611b406f28c66bb968f9f52a4a8728715d1692ad8bb684da4248c2ae3aa094f4f4a8dcfb5c9046a6094db0fdfac2122e421b5c6aec281fbff471ff15c577582ca8f4c615ab984b77a6640602c41115abff5ee3072497bf6af087a2c060dcb9b69889f93ad7a5c7a513ca528ace6e1071b60240f9a77b0c6fa8cc8d4728cf4bce8644c89df0e1c62ec9f78c09b5709a7327278b3531032497906720e5978e5e732ab20e9cc1a528e0eb7ae0ded6b6ed0ae121b4dec63191a93b842a5bea1abdb98063ead811a80cc696dcb55206c2d1803cbd4dceda25c167d93e025b120d87f34c4b5903de029e7494871e79f6f881d6fe0fca6f34c57ba80ebce0d3fb6316b3bb3f33cedb9a74bad570ef13a709fbd294082057ff79d559a5e8f245be758abfd100e9dc59ebe2aaeebf2d94d71f7e484050e37823a4d6dc0b5da55da73b646467050cfff002088ef74dc2515084b5087db60edcf59e457085ac3b193cb37ecf869a1e496403c344a88fa28006ca4774d071c0826efae773f997977e5632d92fc4406e45ba6ccdb21aee2b14d2b4030b35c2b1fb811e00e1aa1a1bf7acfc32b01849fba06a2a221ede568d07befced03502e45808e69612de7bc0fd69769bc43f40cb2c11ac5fed15b0f635433dfa3dfad6a92937250945a91c3ac74015f5a624ac1968a839003d586f67c47ce2d6a157b19428e1357a4afee4feaa0063237e665e3446c77c15876188242d1d95442e315eef0515419a454588170ca67de66221613cfeee6633597b6f50d81311d003dbbb1e26db3397a4cf6d01395867849495bf00c8fba4c3cee9a673b85d89471c95c4bc2c429dc168c8a3863cf5c3b8e82045d78cb8e2fdf7b68d5c2bb082ca5a153c1fd52d1913335ebe0971c8b78bde984d09a38f590cb7105af9d2481a5f356529528f157575050238b2cc21b2375b4bd511198ed71732a2e13b02138f8e0d23f13598b25fc66868b5ab1feca66bd30570fd5c43d9cdd99f650290f4e7d1208587e86118a4434f456e78355dcf9901fe8bf59facd17f0078aab3438d036444afc5913b5b3d44e05b710dc2b7c64fe19d1e14aa2f47e7d78ba6d699f29869f90f56b2dd512721d2bc03d2607cd325d39a9df7c6c0000a12c1f2f8d9b6b40565a244058c6d25659e04da045c5e023fb3244a8fa002fdade79fca0f0fd9b03425b5e4ad0ade432b8397d298e2607096488b0e6c716873e38397a287f11756902865e4da91c53dbd98b6549665faaac4bc858530008e8fedc34226a69c512f73cffbe62c4f59580861cbc4bca3da6f0e87d24e2d741ab1d8a10ad89f46394ae9c290690730da1e60a7ad407d57bcddd8e38869010974bf2d8adf12a51db555aaad74fed37bccd06ea537dc008f6fad89b09d0726f9c91d95f8d551c333cf810ea164391f18cda51cc84d9f39be40dd8bd7335330e43f65ae17b1bd118d9f6e9eb89b01ec3ed9e1b75cf99b91ed71dd1bee19f5209fe90b002a1463ad75988ca936bfb475806eaca49ad1470a2cfcbfa295ed8cb1d7dc3a9b409856988d30fe4df741a6ce9e745b135f4554667cba7783e30437856c2dd8663a95b92260f756c1a70524c510a9908d08ce9da0231cf490f788a8ca6b10f2da1c9b2c29701f50794f019ed162bc681328fcbaec97c79cf78ab3be338aceee8bbceb5af38b0847602eaf1284e69706929811d8086ab675e7f965a8f921d12731b6b76a3f38756a1118598d1f991a6281d9c0828444de01eba974e50af4a02c8ad54fcd2979fb6184a1759559faee8a2afabd6bbe334c4c3daeae4f34b1c1a9ddc2e7bdd141d88b103d85c9b55e7eed40b126f0ae82b0e510e33cdab8508877894e07f4330e76e81a5903daa34ed378b6fbe05e26189305d8704af20511c0f8bad72950c52b520b30e87489b5c01d29f2a4be03816daf99b8f08dd118fc85f9feb6031d6346b4ff2e83f72800bd1cd7486a5099c0d03d292438d186abda562b3bd47fb1a514306f6d85fe7c6f39b8efeb7294cc8c4b874f4cc55e7a6b93351b6aeb7805e74bcec4757295423caabb4fb13c47bcce2740d1e4caeb8eedb0b6744d409707b70a987398c10a03329c91348518881b3795cf940ba4fd31d409730a5a15528f31927a3e4709acf845f54c5aba370dd1f70eed4e8252c35ba05afebad73cd2a9238f50f5aef80e3e1c552a900e81a91e7ec7e8176c9e21da82977470883e787b8b6b79bfcbff01c4d50deb94db7e26a6f0dee76fdd0d5882b92550aebb78a82131c63be9e3d9c84d320f58d2c9651058c0728e2007c304edbee0872ef252aa7c4c293d527daa892f00f3022f874bb03151e613ea44bf095d033a586d7afa08eb70ff60014f70b71337b01cc8d58ca1f9f33fb07e19ebe89eca23965adcea25053e816c57d23a07a5e92a1482b8b4a47d2096757f3f92960a5cbacd977f1181604d266db37915b44b7d243815ac684f55b131250e6b681c369d2e498a7d377d8a7ef1245f248009866a0996933e8b82d4ad08aa52546751a2ae651302956eec2a9f5f7825b15d41017f12b6de103c01fcafb21ce9eda2bcf5f57c5fca35dbbbbc0e09fab680a9ba19d57bb5ac29bcb4bfd1d91aab82a887c5059d010e7f36086fd24ef22a72bf290dbb5f1f9f8f2c15037f0321e2a94cd20a4bcbe0408d8da6b04149a4a165414f504662ddecddec4c4433207a90a6989dee63aba6903bae5000fd3af3a2206058e551259f5615cafe065afa5ac20cd51c2b91dc745818e10c36f73991bedd4dad7134c5de4aa5841b7dd0539f8b0add7d389b39e429ad76a8737fa0a931e51d9ac14b006099e36354c3cdfc258009cc39f2341952a5d3a46f441db2cf03756fcc50216593a13726118154a78dc98a391429bfbdc22c50b99a1c8c49f3a771f42282e66a68188051779e1a67d0c38268df063df67940e0b464e122bf05a0b68885b624ff8d88bbfe0c1dc1990482e33c2da382b81244e765de3e5ee4380b1ba2e6a942f8a09c96d405e08c5b2262d78623862773115c4a8e87e65dc1523ed445d1585a4cf5eaa94b8379d98cf5b0e9ab607aec1704915cb19fabb4f2b0b01c34f54e160d1b2aa6eca29d5ab51c8f27446d85180524a89359771aa1890bd897df906307d207d16ce0cb554ee86fade68315255c2bdf2c3b5efdfdb54d5afcf5ac4a64280ed6cacf515ed66a47a61dfe0d75637a9d81f95b328771388d3bcaaea885c8811b737311d4ca5ee7c78082adb458be9e8dcc18fcc0bee3a3fbb4fb9a16506d88091ebbb4b78fc4d4c5d94290118d136f523c7615509a4811183b11b48d85f8713282076c5ec4a40796e22da87e546162b08e2775cb7e5aa4866d2397fc35bbc52faf2040460d9188fefc607f87686f8472a474cb4df05ee6d4391ca8283655b5b25a8805f0f311e1e431f7c53d49e4f8c425157db16de31af69fb565c25237725c469f35a30d66024970f5ab2b8684a432b2a015c38302681291caf320e0cb864b581563d2100d08bba514ed99d3b5b65c1447d8e61151e41b0990e6a8c5d1865e3f90c98d893b95510a9e3b35bcf6d1da8011214c00b5ccd805f7a17912d234fb18b0e46d2a78bf6ca7a90f8f1d07c4b86e91791752c5f6245cc2e4acc2f8ce5f2551b2ca953fccc263c351cc19b16900aabb3f90cdec0da4a2168d95b87df306c790cd275971ebfb2f461449189397e28f5a69fc16e7be6d206ff16a80a12c65022843b2e8b40e57571ab4060e9b52e87999a9aafec67a38b11740c67179df2d7a9638afc6e7ff5964b58b3e471222df16af4377973984e57e9dac90442e13275b33ccfc6f75e8732900b8ce00758c77400d27c15ec16870d106804640f50415b4d5fb0ae200102bba47a5b223b661abf759ca134e3da948abfd5c41cf44548fc68a4698885542825e616009f2b908b17c05f0031ee4c62c357894edca234499dadbb432903760c49a5382420f8801043cf843a455a761c07df92fb3660ee3cef691dc6bd1207d244a40bffebd10a9baaf9313375f8f9c124ac17bd320bbaafa0b0fdff8a1878b0bd3384fd3220014c97e2c77125fd92ec8a879a81fcd8f5551a6edf8814cf225f5c6fac23aab9edcb53c98f87bfe208d4eec74a4aef100b2392fe2d6aacca4dc4cbe49878422de84b99e1bec3237f8b374c8c87d7f115e60bf09a3fb49dedb8d5a7b955d8e45700e7f82e25a3aa49a15a4a726a61ea3138905b39d7c2a4b2786f384de5d7bb024edb21c61bf750337a2783cddc35dd488aa999b7b9d47d32de2ff97cb131dcc50edeba6feafe1d5be87b1867373a350463caf669fa5cc2f9656d9aef19efdf862a59ce65ccac3dc6ae28bb71f6fb257369994a9c336e27a5fa032401eda4c0af01501f84444c7b9e8c9a4f8e3256ebe21cb4c44df98db52001b0f51516af2c4636ac00e6eb0ac3ae9dd256d177e30c146a8de606e97aa11f3e52dc79917f03c21f4d6caeab9525e9bcc0cda6ab7222935104aa52423b00ddef1f59832711fbc6c8cea5858e30112285b0689555cc7060537a966ce61564e2e2185e32cc293bc69879f43e77c54527a2eca66ef1eee1cbd94a20b2ab7b42bd62f1e492e50cb31fbdfdb75df0b660bf57fbaa066d3b6699154c628d7038dd43ee141c0fa213996b915bb585a57ae291f567124daf8868dcc3a719f3c415d1da74365db077b75c0c7c14d9a2442210304d027def0a1e52522a1cfc2a1c54a4426409bec8c583c91d63dec0b2bbc208d333da9451fefe44f56ca1f725da08c0747d7b2fdea3fc05f84e1fded901aeefacffde96a60da273c374cfa3b566683b0ef0bac99af2db8ec8e016ee133699c0d9e63206796bcafc6d46492288adcaa076e5f1c953256b91a11a1f807bf0aa3a243988da37aa5ab55fd6802f607a422cbfce44d7b87a1ea39bda67af6e8f5e6a745b7af397644f1d3b09116557a02aa74cedee298420fb6107661e20756204e489b9c156aa731c5d8773d30e267d4cf582f87554d3badb1d9f44582690078eb718bfb4a9cfa37e87f9d38b8acb8e84aa0358e0912c092c94942e860196f201165112611c4e2b6b8a0031f331282814ac78103855831213228dc4c46e06279eb5ae4a25bffa78bb7137285a7eafa34202134d7a8630c5837c28dcc0ebe37894bc1713e3e1ade3ea998e3efbcf2560c8886d85a23f13c601c1a5941c90a65100bf9366d9f20819262dcfab3825c8f422c212daec1b58400db66277d8012d9895ec736b1ef4664fa46af264e6c8e3ac6c4320e3972982fc4fa97da7bd27f265838b9ff529eb3ba308a54f8daf5b122ae274291945a24d3974a69a3f6b0ca43bfb8a8f3d0e3d5f4231815bba52a0df208181467a2c8b5b47706bcc40d333e1c44283ae510341909ae9875b902dfade017f7890920f4c652e7c0650170a3c98097c09c851503fed6b0d85dde87f566764cc51849153c96c95ccb18836aeb84b80defda3dc4edf7125b36069a847c2122c690d7d76ae7ec816b76b9c81391ae1c4c17ca4f28469edb0f20e5ba2b7a89fe031bec4ee0d246f098ffaa1c7ebaeae30f78b04f9eacb0ef03503f8ccec45ca846f9dbf03d36d045c1cdbc96d4155f07107589a5e93155b3dfe92d57f6befab5b4418079ffc2c1e94112f742e68e217cc32da76b648063b066ce781bf4ffa8b54987a71a0b4a5e158a78c33db54e0371bdc7ce3b098032b5c53abbb6ae46dd6f51ce2b90b8a5dc664ba16a16008373d2b2aa31872430ba2dc8dd62146188cb6bcfa7cdd1049c88268141246aa020e1be36e372e3a7d97f5cd789bab52ccfb91cab068414faeb0c70ce62cb12369bc97ceccf08e4672265b5ff5b7bc6f738d480a868207105e7053775a107c3e755bf4eee5fd56af8db862a37c59dc783a1e53baed19ccf05fa4a90ea196b3695bd0b6f5f10f3ed60ef91eee6957bba9b4bee65d0b6fcd2469c3820e027fb669a486b5c5ec07b03c51c70b5079aa8ab23b74a7ffc9ae6a5bf2edb323847a4fadfcf2e7183baf6275640ce610918cc97f7616910d60b391c081d33d0addfb55c1dc836c2dc5891642ca20c9ce71d6ea39816fef2baf21ae7b826fd9693b94673fb9ba0358166dcc6e75662f1782d602033d6ea295b46f512e1338971ce264edfcb9dc085d2de89ac7dc2cf3784572d28c03948f7b1db229eafbbb68693f376fefbf2562b40714596713b3a51d24c4c200ca6fc30e1f2222c42f9e790f05b1ac44de834e6abad28a9a67600513082e922b26656955804b1e1f041bd7592e94e0aeff6056b4d666d0f692efd96a247fce17e05c5f5da3551dd29272e007ea95f0ee0aaa54fe454654ce7d066429a103f00c8e7874649ea36ddb5c3442d40cd2b100dbfd0cca1de3c90533fa1db772b615055840d0d893c1ff9e17d27399c698bfc7f0851f289e217428ab986ed8de97ebeca7feba2d62bdd52c059954cc7e9a4e204aeaaeb2d8d2235b8de9a3c3b26d73c59c0fb3a477d68eb935ab0b612871fb78e0f86cc42727af7aa45170bf7a4af34a41764aed8e73aa01fa382d83a07d56d37aedaaf7f12a2e5fddf2f00b492201e345a0ba1ef75544d396b5b443e645c1d041e52098209e99ddb186a3767b33f46c87d33e7458f06fec754ba56e7ebd59fb10d4b44aae6496d36944563df87342bb88b6a124b32f8cb6cbd29d150632ec1d70b2d90a7fd9269068e79a5d3b7d7b50cde810df8815d1ae80239a1b139bc4da93550f8e31f038a8533e5e3c4b9fb55109a5ec837c2a5daa527160487056d6b3bdcc81f04905c3997250f838816bc95cd0c23edc4548a2d1534ec57ae6085fce55838229dc25862428e90466b5866935838acff8e70a2a507dca5c752f288edfb088556eac023720a1e575fb38b0af1e34f0e34f27797859429493996b8bf77208f9d18b2c0a9f4b54dc9c275cc9ecf45f317428a7176c35758f22a932324538edd4dd4f1a1193c65325984bada3caf54fead29ad1efa4466d62301162abece8b0004fa6ece9ee4001d39b6efb0be56b7339ef665e806e6999bdc19e6902a98833f2d1c32af0f57a39862f844630718c141200d35d7904175a25be5dbb50f1d618d269d23f85abf81a800c4b14f64ae6323419513ee106646efec188a3194ef0225d4ede626c8c780ca4f2ec30ffa9c52a8bd71b311bb93b7fbf596210a04b021f48f2f4669cbeb9178fd90dbdc57bcb6358c9a7a3ab961d5dd1da273a633a26eb63ac08b470da8c737fedf1b136f1a82419932fbaffec6ce59bb1f10e715c445812d31cba68d3887ea06907486c0f234a5beb26d5e15be8866e4e20277f6f7c6b166a29175f209ad0df3fc24b2ad0a978a41217033be08ccf37551a9d8db6d4505a76f2929b6f07200d8bacbdc0cd708baad7b7c27443774d6d14eb65451edfe01f754ed6fc0fa30941bd44a6ac29a121256c9e3724a49c5bc70d05c4287547d87a15e5d0a5c3c8ffe9f5083f53c6c5f6c6ab701222cbb142560d8863975ad4a38fa0e4c6936b7db7c4937c335128f2dd9c063948936de00a4c0efe454ca284a83829e9f95710ccb8501048cbe51154a2f17737e424825a435338f874ad4017ed9c8d625ec1d406e1a05a35d0e0296a50b6ec10800e409e5b2137ccd10679cd2861f91af71b297d79aadee38d8d6354b6b54c5c2e20d7a526f9b8cdbafff5e5cec2e52e7ddb027b523b7590c9eacdd787c2b3eb5b5972ce120e2513dd43f9397303d85d6db91ed222cd9874aa36be5dabafcd39fc7c8908a0559995271e0380b9e3524a30600e62cadd9b8140707b7c704db89f2b4de5bcb43efa1a9db7faf17df89179be693abe962387793de60b259f898fa7a4650f1b16e732b66122fd0210f69751cb57dd6753626e67f2b627d425e7dfb55715e3d2a053739ea25aeee1ac3b1b26fc39fa6af21e62d6850706573c4c46230eabab6e848e0c4dab33ad91ee24e21f7d7b41a5de336698ae6eb30c46f8aac4429c7661bf32109fa270c849ef15425e658fbbf7c9f32c0d54c576dacf02132937066ea11785ed0e24913540995fdd36d882d60559707f4ade73653bd274598dd4ecd123130698ae8a0dbf5d477f90b6578a1518cc3f004b499c3eed6a2bfbdb496447abdcbc442678c2011467ebf30d8e1b41e7b21f9723ecffcd4ed2915de5e85fdb3567f4976422711d0b62b3d693c4b644a72980eae715ca73dfde5f0017441abfb79a0d31f420bbb7a0fa8e4169a59394d77541ee49bd891d9e379bb5b765bea14226f90a98b1cbcbd048a8da7cc32c7c1f85214fd36d2397929045cd98a1544f7eb1a79747713bedf02a7bd087593d8caeee18aba75dbe508f089949aaa2f1fc3df0fae6367ac40d2b4b3859bc128f07022ebc695343f93d1a6ce38bbb2193cd98f7b50c100585e8724d2b13f4ce2c741e8a6f742b5394f412584cec3551b1b51ab92a12a92ae114df4579098862998d6e49530f6bea1a7aca854a5d46a6e60920ea7ba78063ffe01364f9f69c9b6e967d4b006b1e078b32163012f6cd289d03b3a652ffed28327acbffc2fe1a5b45638a7528e03dc148c2f05efd0133224734ad32895972a3d04081d64d2fa736b9ead3c65618c31053c84d89c0e0bd7ba119641c53078a9eda0ad70c33d1a9ccf19d455f375a44c298435b40533b3d43aa801509a65cbaf89ee8358f418820fac555b1eb2a2608df221a9391810bbccbbfca51dd12403e911dffbf57e0d567bb2ef103ec75e69433c0135ab9de28004f40acca23629e0de5d7dd2031f79079b1ab32d5429981308cc80a2f1a4459bdbe8ff804b940e792be70516668d3ecb7a8d3cffce38f568838ae97c6592d0418425d0b797ebc4aac858593e61e547eabcf5efd1662f8f22db7003c525a4e0f29cfd70720fc16535c3b775dc8a7913843f2a7380bf6f5f29104306a9c970fae47da6db9c01f0b4e82f0ea36a20cd868eb3838c0a9f84a8455072f4549e6a6d6c50c6c4e4be3279613b7320993161c411d9067c9813a6254f806d1d4949a7b93905f7fa668145ec3846a673501ad911836db4f12cefffb0765ea13d9196113602f8170274f4351df03977d86ea2dba5315e44aa1a2697e4ecb7d024097ebf4bc37794b602e7ceab6f7fe6951754ce7b825c627f0999b109d38759c0752630b61997652eae2bddc5337bd104d1c5c80037cff890add634967da2509b57acbd0928c3c93999dc60b454146fd95b1a9a34b4abdcbaa0db2171e597dfd5f49f4a1849b56f32fb474652150e68449e14dbf5eaabcd87e8012d57d6adeb5f00adfafad83f54df5170442164f47e50c5d5d0384ce98f73febb2bedb139a417ced03353348cbc0e105777344e60c364ad2ccbb5dd4a5bd3a87910ad7a7d79ff415bd2f1169fd1c2fbc7d20befd00ec505d9b82294c5b7e2aa62dc3f8a4915ecb19e5757e0b44823a84c82fea9ac5b15af67dc498433888a7028d7bb18ba05a2784f964a682ac0daaf4bf55afb5ab2f8d61dcdd1db29c3d499f37dcd154443a8a531e231e3a98c310deff31a51f0789562d93ffdd1bbb54b18eb684d6b418af197367cffc128f8390007973544e8f3f4159d7c4479b65f33325d87fff1bfdeadf15efd2c0cf1034b86038248a6ed499e4627c7395cbb4ccf9ffce45bf055274dcfae0720b5baa622d4d39044916feacee706710453ed74d661c4e7a46780f178a1307bd92571d62421d15383f6cac90bb07fc8bb0ff508b96415d22f98dd5d0079c9d687469aff4913a9159ac8f4fce768ee468620cbd6f1041f291eb7f049736360e90cff693494dcf498790255a4a425d0599e0df6341573b8b9662f7fe586d041517bbc1e9df6154489071e263893367725452e9fbd7086e5c70df088dc4cf3125c4a4fdada0beb17cffdab5f7b853cf2b35d0c35e13328097139b8507edc4ec12d43f24322ed4ea5ca7787cc4c711e61ab80893230ab0f248baab96d124c750745c06fa64e346d196d20f3db690c50e769406bda81e97efeb8cb71b414144622ec3866752feb094d37a1379f1959f7280f0ae0a5af754f8bb9cad3208a0f13ce997bb2549c8428ebf786f2dd07e2e465230188f58c4a3cabc625d2292c6ca957cc68a71e9d49f87a92e58b2f1043c52fd848bf6dd540336bd04bcb71fac2d3fac12f4a984622c578565dc1f96ac4f5659f4f4a17bdcc65077501b7d852537fd0b2752ee402ac91a911b6afd5e0c8cc4cb684561e154b0be61fe5e3ee2f7acfccb86b2ff4728eb702b37a06acea6bd0d2ef700e547d57430d3b0b4d5f8d829003f08c5549920152bde083f8a5e6adcf19cbd2bb9236010c7fae53d362708d046c9e11c9e64873bd29785f8ee2648ce18b87f35c7d517cf2dd5402857a6bfe95cae38653f4bd40e9775cef835c1fe92e11e09cc3443871ac626103629cbeb33eb5b6d7aca59997853be36b5e21dd86e28e21d0ece2c1787e3ace1c375aae11fdc69810482038b1bd4d69a46d25f9d6c0ef9a0ffaf12991d9c781eefd13314d1d7a923b336526e7274d4d973937c7ad77313c4e7b36448e7527c1c2b85be20ab3b08101a60622786b3f2727cd8b9fb385bc8c51c5310e8ca5e04797e440430c176c1f28f8635ce470cc1b2293d838fe41b4a7f13cb22ff1ea87e4d074d7b178513f2b8830c833ee4ec1bc44f8a3f1182982c17d37527858e4235b2f69a60ae3f3cf08a2f870063a0137f53215a763e5d2ab74bcb7070fb46da407cb0a2b586e793569437e734d5a9cc6ca5e067d7598007d4e7c68cd20fb661f30928cfa0273ab5654f0a4d119be490dbb298de5225b003a0d2d96d248674170cc4c9971c7eede3f8bca8ecd2d755c4677db2bfefc7aeb98ae9f09e7580df75cdbf804e52d9ea2fc91daef2729ca5373031a31a5e6b63aa265c2d20a8e8a20d164d8715c13505d7c040e479dc259c84797921896a651a94537f2a620d5050112f0abec3a4c780df57f2a56d111d1850001efc7871e157f43df8c848251058aad7382854f3beba35aa5bff85725973cf14670da0f5f331275638045ca531c469308f503f4eb8ac2b5c38eb72608030c520168f16b1825eb9693135e01a9a4ddd9e2df986dfbf8c42f32bf57b3144a700b39ec092dda0c33574b80af04f4ae13f16433c673b97de17afb9a21f65fb3c7dda8c08f02345fcfdfe258d1afd1edfe68977d4b77f8b425504de5c3b54bb4c0eaaba72a3df0c663d911aeffe23dd9f4f6b2c005ce27d80cd3e1efe79a8072775f2a72b8f31ee18a8456e8ffce95ca629ee5be5f25d5dc6a5bd92f9bd0afdcad0fb02566828da63cdf26405891b956020f5deb7a4f5c9a4e356c8411df8a5011216b1046f071aaf1e72c3277ad13627a8022831028afd19a25099e0d4c7c477bbdf59025b610a6aebd266e16345b81fc72aaa7854214fd5f732d101070a6427406ea41fe3a95a59a641225026b8327a17bad2712b0165f98603e25c1bb0d652d1b85fc51a89f49ce96160394f49f55269e99955d12b4d63cf29e176b7912cd0104464c3bf9284b7085dd6bd84eedaf3bd0a75c431d81d15e982c19208efed89966ccdbf27940e29e91982846e98e0d76647edd7209c58529e01bc77b1026110649ee3ce36020f5a0485bc29c219b1426cbc694dee0525208be09dd8f63008e763214a09cf2b72b4adecb2f0f2c8cc2a4a015df897d9d4b77bcc2cf39ec20ce644ae052723882a62f07f336a1ce2e85bafca426a784db2d2f104608031d08c3a4bd765f7073251444f4fadb9e149f7637eafba1928e140f93f625294ed861ead6c7a8a5ff4137a33dcefbd200593ba031b1619acb6d769d8373023510aa46703d83c967a463b80e218006d3684ac088197e4cd8958ebae1291ccd6fbb4fb4680a53d06e35b75e8ed64fcead9b49918ad58297bbda226b91d8a3460898dd2681ceb5c8297e43c82626062d2e1dc9ef60515d7ef40d27d192d3bdb4caa003603963da5e2da44f69eb5279cd0ae998499d6c544202a88ba7907946223c34bff89ea8011bcc318b2106b1fcffe5c5097da4ef426e6676f7dac05bc48901083a3b11e594ec32f0bafa68a0338c3bbe093209d0b4afcb986b621534c7a92c392cea20eebb7871b4d029aad45e4df52876dd456d237f4b377cf7a38f497f54615daae193e6f3e96b829a3cf488953e6ed7141b8f633c26c1af8f8d6f832e2881218ccc74ef86fb9949596780f07786ae9b01121bcedeebcb4655b43c211c30a38e9b66558f0bb873bf09912443d9a2d5ebabf3380b8aca8be2619f33a39022a11aa5bf26ce1ed70209673dffb1cd1ac8407e1897e10167051d608efad3154439c05b495553387210512fc86dc12d6f047354a416e01d7a116878a5b7c39eb7c4ad88391f6e41786f97f394985d247a863d3d361ec99ba16ca6abf02f8646fca2406f98661d2cf3138c09b835400ad2808716b9c46c3ceec8bf1109bdf6611f4b6bd147e88234cdb28d1fb341115c33ad682693d8b0ca3997b7015345544cec9953d048ac649913821ee8530f2dc8e9bc98e7ef370997622f35386d8a9d4dba21aa7065b031846a1f9b87bc2a3b33a10923fceb0d902f1ea69d2309626d41da771be522914affa7021d3cfc2a38356f66e181a8e91cc762de8207bdc7e138a48b963a256d298cf4471a0a380defb3dafc2b7eb90753bfd80077ea01394d6c2a398a88dfd6e6eaccec471ee7da2a346d99b174247aceb0980f8e303004701a96409d2fa24f0b9e253cff1e5c9fb95a689739dee32acec01585a7cb622f0b7b5ca7fc62b14f992de3ef4c79954e3682c8916c9215d14e6bb6ec41b3d7fd0060e02673328461d7b501daf32c5cb85f89506b1234ea64d118700eb1c5c3ede83847f5b383b4117aab7e990e0ff99d4e48cc1eed3784996ae7a6f54b47205cc359f68dab29f0a67e475d1607874b4508708c0486d2662e05b1ab368ec6740eb651f839190d9583ae421d099776a6391c125645d50214f3dcc7fe45cfc39ecdf9a392cfa355b696248598a6d200a1a10d13a70d0fe6e0c44ee59ca37b44c76bfade7eda3a4c93c7337bbfa8b9d7132f3c0775950981a12874b143f4e3bfe04b784ea0099f7914895ac22e7ab3641c7865cbae52c715be099dee66dc8c01dae87123e741e1ea5a77defbe8cd410af0612e7ccdcc362cba1a5c6a5ac19fa77b12d260cd8fcd81796814a5d78da23a01eb18b4a660135ffca9e810885f742e1183be84c1ef5266bd5f8ed7f52e4f7179911aae095bdc603a03b1fe7b2067e7904745be9d07f9735ba912da17b12be2c09dc4eacff5f2ad0ae65a29a5d0431f33874f474ea0a33414cdd0b2f610b5603c7b7bc31ec88f908e38cd9b5b9bd566e6ec092707951c4395c35a290a8123b1eca7e47081cf27cffb935487f25759d32c8750025e23bf14e4ba4b152046960163d454121eb476930458e66d88d9eefae3d894fc52dc26e125124da46abe4ba5a81eb75f1148643f37292e283b63b29d6dacd710a265637dbcbb0a4bb21cafb98bf7d1b1d97610f404e58c3debc422018018bec3dbe0ec22a904535dd570e5697010a8fe8683c6578ccf451f3fb8c31cb4bf81c03d99bcf634253269c12810cf68bfb6920730b84cf15deb534b53d83f488966fe15d9fdc8f5dcefd8a198ea147cc667c0d9b8dbc5bfc2dcf1eac1c55bd9fc03095864b7d514f1a029d828c60f9a0cae53b7fe3a509b590413c4d272e0e02a7241bb492b992b8d16d3c355bc4f3e2a549975a38074fd0523da9023bce77cf5fa1f476a719ed149b70df82a85e117ebbf4964804ee91da7000b314f3153b5de545faf1c45c3a1c32161ae1fc7f8391372248a5a6aefbc8e1b61a8731222e581cb6f4b91d85cfe235a42e81d86204256d6ac7df7a474350b7350088ca79f8b93ea3779754b95ebf093da853b7ad399b39b0b235934f65560e6bc0f5216e00b86d68db65af413dd1e0bf51b438d6dacba10b1f33af24ef9149979ba6113c982339375b2370d0b77ea6aae1689b489d0a423da4c71bc49a02099edcdda4c21ff8009f01b56ce8c674ceb4a09f5de27402ba63f42be4a7b91b83d8f4dca9886015c5800ac7c7b01516431dac37d960e3521e9ac35beb8bba10fbbf708a1d176b6bc6ddd46f426a334feb010e81aedf90ba457787e1be011394a70a32ecd5d32d842ae48f5beca3c9789149a5ced2a4a90426bbb138673de86246fd4258aaedd1df9609f1bdd644462162f6773897ab91cb92d0ad50762004f73fe6bee262f23900594354452514f88dbbad46a1363ce06729a20b045de20727a77f59be5879527177fe9ff9ca258fda6c33832f036943a15a2832fe7530df7d189559d3c864e6be20861c64bd963ec39b8b80e13e7d3397d46a70875cbab7736f154ffde6f085190aad356e8909b66c2575b5bbdb70918f512e9e35a3974acabc0809116ca88fad209d9787c5a5b46dc614fdc9ec5fe468e7cbef2bbde4de188e2001ae2d142994e8610956712143944339c15bf135205977a0ff2fb6735f5cc5646316c6709e7bba33eaeea9f029295c426627ae6db67570265c4e475ca03af85df19550dbc4694460a18c3bd18c079cf6842822819d20b5647a3e8b5578078a3d58a45ad5acb94157aafdae5e2c603dac136e40ab82d906ba0c1b77ca898620ec9cc168a082d810511f0134a822a821978015261d2e36b63c8bd99d73c771f6cc099278b2a6e8ea130fc52863af02a2e7c496461c6092fbda2e143897fda36eb4108b79db20d4dfdf6b492d1fb87dafbc811a5941423531c29e1ceb02e74a544847b8a2985b59eaa6a7b8401ca9ce8b3615594b9c50dd7a1e1edf65fcdd23c8860a8b39850fcb21b6ccad4eb6dccfa83c73c13bd89854e412a4795e9161bc8b260a88bd5bfd2f4ee706e0bd375c311c803aa2dede4e3ff8791a1ae28456abc83078581b87dbb30c597295f5e8ccf11f5e89d5ac3579d620a43403c1ea37cd083727a196a978afe9ab46cbbc5ff9e4c2d269bc6ffe833fdfa2b0ffad066ec74a2590f64387029e6dd138446760ee0775ebb700e41e5eb5577ac39afabb1044975ed8535a969f49e6663f77ed4023ad172875948de89c608b561851a0399e71104022f9dcfbd2babe434d8f29f5e012be015d94d110335bc2d93eca011ed6fd94cfc9120ad5ad901d36f84b2a09382a4e58805ae7ed6ce16c578d6f2d4240b79f4058890f05d7082e31e09386d3e03cb7465ef3ba304777bd91b0bc1ab8ac1a448ec956ef8cd85739070316b3ee913c2e91c9aa24c10bf359273a2162e866af806a74319d5ef55ae9d1b688623dd9df5ad42f7ccc703257d639339c32b4f1b6c83fbd3c1587c1baaaddc36285167285bdd2ce824f388a7c5c2d9128a9db9099c08072a02871ce80b5c34a516ae879e6a6b36cea2e43d66c7a83209cab95d89071b2425a13d5ca877d95ac0038b39aa49a9543928efbf93a7b786112a124f657360a0c8318fdd6a73319f43f061b0fbfdaca1d9031bf8c5b84eaa31b53e3a26576c1efdb3db80a9052c8b3462f0b9d0a9d341aecf78e66822cb39c7f63f24f8797e860c48223f8fbaa25693f230ed573c67d76b24b846aaac9efa9a7b7b91c2c3f1665168ed9e7795ce8407ab28d444760458eb1a96dcff7ab149b71334efdc7969f749e616ecda05327652a7cabe4f0cecf352dffe8de5ccb58bdf3d93b76d735ced698fd817e24b0073ea9e9e56594483aea2f9dda2b98a66931ad4948f1907bcd35870c3688547f093ae7c544897d81b5b1813a4769857d62fec39d3acacb9ab9acaab3c114c09b42e551701ee5965b378320e3943e75f2563bc08b71ae6c5639ccf0bf42c8c7e39f528491465854ee9325553eee4a935f990e4d106579ed5f34bb667b6c19820b8278ec38e613a87c0da2073a71dc849b30b0cca7286b85ba58d8d322973dbcd17afa7017efc46511b0652d51a77d76c5b6fedc6395c1f8b250e5c831ae37d102780492f286ad2db9aef71174ee48f76756980404f32233a5a01ae57cd20e77f28c7fca33dbe9505eee6024de68b6d59447677878a62a5e319de4ee6cc7b6a84b579cfc03cdf6cb7e36b7057e3e6bee3e9cb65fac3b6068fca545b5a7a29a2c3ed91b188ed81c63802f4b37b99c65f00f2be1c75905b5327d868df6883f39f68ce38b0a4dd4ae33eae9ed48abf5572d6653c8dfc81183b0ce5d3fabeeff3e7325d6978abdad4784c1e4538f913afa37eaf9b46c0825f1272f66fda613b6ba4b649f5286c5186223c77466606492de9ba2d424cf705206292f26c84860d2b807bdd64ffc91c7bdf25aba8bfba2af26c49c6aceb3ef8c9c27dbdd92505fe4f9997dd5c9ca8ebee5084b9e0fc8754eca294599c60e0fdf2c6dace9388f3ccb7b50bffbce9a974ebd79cbae802e1b32ebd17dce1faf943282f5bd6021b34841edc3ba9c42c346a1ee1af4b94e0ab87945977b5490201b3f8fd3dbe567571cf3265302befdabfa77c4cdda7940a9eac7331ae7cf6b9a02ae04f574b67d6e550c8a3876529684d614fbcaceb2f2ffb5aea18a3334500cc5941c748307faedc169363254ec9499522638d4599ec956a5a5bd2431d650311b779697b5fb56bb1b9373a920e708cbce2ad3fbed6425cfd3e6fb90c69eafa540c0dc78381b61744f3debce9127d22ebccfd0bf7c953671be0bf83c61c946972ae91e97a85edd04cf5846b325729d73fa12860f34dbd10ecddb79269d838c915384c5215c703a41ed72a89f880df37101b80bb8fad2ce13694a366f582a48f8d0b5e3d7fff07c138d991b6f41ef657fed0005551c68d128ea25ac415c4958af9462375b328ba7ae64cbd4f19546bc338ad772e7f4be2e732d10a854de5c91044f1c5b61fdb9093a5926e4730236f2b187e4c10cf9a17becf659809e63ef2451940b5122618c3b887301feac1d25f9a458c623f2f03efb1b9f9d4aba16321c4f5ff4a683cf3b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
