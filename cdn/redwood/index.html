<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d3837074162625d5b14ae14eeddee34154b913f1f192497f3814c002b86611156b11636b6cee62fc4886d136769835698f4e9e6ecd8be9fdc0ad92ceb84d23ef8ac067884a19e7612abf6b670c19138e25f09588be521557f330cf4230dccaf2d6a659ae2a89ae9348a1ebaa4a387075af04c38ec49740afab2f4d15752bf34cc92f2d246ec0b436f8fce7053d9a4be5b1eff3894bfde3f997adef5965c3f50103e684c7ad9127c3dde309aa7823f4852c1532fe757dadfd17f6aea161b22b3878b39d3469b16548c30e70adbe49701ce4a8671e5e401bd126d18c0b0a18981df0ae2da87d86466c0fa4a92944d69bef86ad31066cca6c0fc3dc28c1546c1fb2961bd9f3e99b42402255bbfa1dff9f49d039430ee5d2f16a5bb9ffbec12a6ab415a1567e6dc421d3d0cf2b577c873cffc6087a9cddb04d7a9bb11ac784b75d213a8012b45658668694c052bbbbd190da4bd017b5f6b4215c831a2e2d60514c4a7fd643ff8bfc22a31c4a1a83a3d4b2483e0632f8ea135690ef4152cfdc36e34682feb485284417e760511e20d80ba89da62314ae7fcc9244962f9a192ff60807fe22ed870d0e339056efa07da565d73be9be7348f0fd69614dccc8b324e883dbd6ba14cb7afad48d075a7e1486857ef5e8a6d67f97632be981bf66e7eaf13250cd42641c8553116129854ac0f1326a6957b22f10bfac312dec1f285589757ad3eda38fbe577abfe447d8f438b7aa09243a5ebb1751f7975ad3c77d78195965749cc7bd942981ea6aecf861862914b7a86255ec8aec528de79363de29a8a451117462d9b033fef537700ba38d67e0b08e0a2da698735e665743213a5fe7eb5344911dd5334111417043e51dbe818a16a3bb814f1d3a4e2e9ceaf67f16ce555028ec9fce4a080366274393b6a8f18ba7326e55751a1cd5c8ccb1de827b05b42b246d7495f75a85673dac45341f4f16d54f6290673eb9ff93310abc72931c1e2240cc9533cac74d62aeba87c21ee5b3ff4b43986e967013c818a1bd7abecc55a0e0e290a875cb428eb15a469e447cc688d2853dc350b0420170e2942c5a10d85a25e0f3e60415a4db3696ff4a4a597b5a894c15b3ee777b35e231eec0bb1f51be03881179d9682b853e155cdd3db04d6855aadfd3d420638ffdb60eb309d579264a5d4f4b7fba261a49a3302e404503420a089f41d9247ed80e55f58a771d8c0d4d85411228b6d40608c8f34dcea27e2bcf7d2becefb34d1b6350934464fa6965e5aff6e1ca5cf57e873b65482bf091f86f8a982e925d12eea2ee0419ce8b4e97155af14f91c3a0e0a54c144e31a3e3761f15b9c0f68cc02da3a0bc8647683f90c4f1a53956f5deb93d4df2e1c08fd15307c37f25ca12fe3189ac49221517449beb1655d17338ab81609f28640a1e5128932850f4242a7717099521ebe84178d303d4b8c933342b2881f81d412669562737198219756837127f209babcbacb07a695261eebe0a77ea7b3514ea7c7c1fff775f74d8ece0034da570d9f0d511a67a746164a249d945d683a6f80126c2a42871217c626619131b6d331d3ad726e7702c83d4e1155cde82519005fc01858b796ac4b6ed9265c29e006faf921c47db14d4fa5aa3da7f585a8cb4325362d91c38d57bb1d2be724f3d4be8d7b5751d6d6334c45ef106fd5dc240544193c66a4d6676151d489a5bfe0d87d7933da92eb9473ddb5bab5f8333991ea70166cdb3f81e69af8c052c8ec560a968d564ac569b3c29f39f9c82085194983c45d34d58b2719faa7342ff6e3a82a1d086ce92559c193325bfede2ba7d5bc4895fda24a485debb51d70097059bd5ad383c1e015a7ccab929914ddd8dcbcd941cea4c9d8949522eaa066009a9964828274924c2c2d7c76b21a28bccd744cda5fed3e599f8d1baa07380662fe806cfe79b00ad1ff144ed1032428a2ab56e6d15fb2baa8eee5b7fae0f9240080f71ed1566dbb105d94f79ed2bbe8334e60422c1594fbead819fb05ea8d449d3f5a82fc545fcf2a3228c85faf904a6dda176bb1e87a050e46b1dc90468ed3c9fd478a47fa2ebeab202dd9357d5fd5f7fb8ef599eb55bcd3e052cfe4c2342a5c20324ee978a713763711292179fd15d974db3ec005a8a40ba2dab74f58140f896cdfbbd954de788fdd414ad75d9a80d0df85dd339a9d9cd78f4c3cd157e8bfd9579f818d590da89334da2f6e3084e95499f7b508d9b109ecee66851c2419019b0979ac4f20a0a204a480f6a94fbcec78fbe8e773e302f7105b736710a870b36ab824296a643bd6eb5ad055381e3a51a944bd3115c5c39a9694bb387701b8ee75e41e7677780ffe14a7b5106eae1aed747db1c1352fdd0f4c9a4a22bfbe4390afe33779d8de242e2c9ed7b63c936d0e66a8e08f97a7fdc867ad8f6cadd95d111be9854ee2587864b2ab7d8794b1957c6063bf089ce35d73785e98d8e8cdaca92a20f8d65641fb9130386d8e03cb279e8cf2ace8f6e6389ad95138fa073a291b367f494579eb25f828dbcc47daf7c0ecca80c22dfbd61b6deed5e1815938872000eb6ada3ce8266abc2ff513cc6d9aacecc0908f78960ce126cb5f704fec0ec674c1fb64566a947686f823ba8b293e4ef813b3ce3c7c5f31e72aa265ad5c9a0591b6ef2b85217c365930022fe404c8404da9d917a52a85b168cbb9edcb26e8a6326768d2e22966e42d443b20f2d50619c3034c143463e59a727eabcb5ee6c77109a392ccf26de92550ac062aafe70842956b78da1e832ec907e270123dcb4ed64a32ec3fe89ddfecedb7f682181670d9b44bf4b044774769342d7d7502fb6921ddd8779223b6312319afc8035098f1dc9467464cbc0273dc177fd389763d1281db3872e42a721c54a0dd7f427f0be369241f747b98ac51020a19050fcc46820558546775a7173c44ec283a9497c632925102b549e6e61c5135487536a5a250a7e11a2668ac1df62d51b9616480eadf995a2a1de8adaf77a3150ebe31fd052c7943bc75e119c25178fef40e79dbd20131a0122e5dbca457d81ba88125026ca65a3db2a195b5bbfc3a08b40fe7f93ab43741988dbca3793dc0f2ee3d522828b42568c238fb0aca0f8463bbc79bb4fd3a8b3955c91bfd66a20fe2a5d3700a58468d3539edfe95f933cae1babe3e7e64f16b766460e98b76a83e1a8df8989e8a2c58a6a30d25705bd7bafa1c56aeb68e62b44b96c4d71cddb97f74fa3e6bd1d0269eaa3d73149ea7225dde7d9b69a62cdeda5392b3088848d38758ecdf99d73514b1944b683169a2d4f0e09f824f964f076465845b05f7cf17c1710c22fd0e3340ffb95d7162da581d4bc0a7506426fd1e0cb025620b4a04882c9e7ba65be18f129a524121f00220fa0f967f8c625db441e00fdbf06c65b82eeef8d738728fce6faf07007a7033eb37f93073fea6ffb1a7ed6dcedb0f21f57519005c4f212035ce052c182fa8c9b88bed08752a004957cac42a34efa323201a898422b4a8f307a69e2d378c62ea7e6cd77499fea7f93c6088f6205ab20555a15c79cff16c1fbe40cccc2446253499e0e8116184f2c2eb2b393b90ecec4cfefc852660314a6b88c149f9404f1c36c881842b83162799188db7db6c9ca8d72338c187131770fcf04f033cdd5341ca79d2b0b2c21c438c0d5d045d528e79eba8f20d3750c48349872f600055fa597908a088349747ab1c94c142b6ea93dd51011fdb188e0f15d693445c950cfcdfefb86a488d93bbbaa903ad146a59a60be67a616151496c1a2b302e09b60ff488ba61cb4d4fbad1a87cdda036e0da8ed901a4463d2358a3480b19f999bef7fa7c258af6e98f90e5e033e7c166c00b8709bfe57b892fe386f0093024c84fcc1b45bb43dc4cd994e6d49a7a57cd68093825008f1b634f8745a6027b267357ce42210e47944847d053222ee2ffc3a8e7ad864528ee5c9f698575b9c56d11adb791987f02d8b32d9d3ee092d6cdab8841fc09cc58a3c19b3c81f9ed31687dc43607c2a0ad336065c49b15e3d4b4ccbf5aba670e2de03c7e2a9c01ef3ed8b06cf25da373431e1edf8b88be2f6a2e43bef086e3305305bfea92599226abced17c97c2abaad7a96728d5bd4871a1645d0e33d2b4ecf6f0ba87f9e839b896acf43e139e7bbe045bad6867ce85798a6223b34d36f6584e2a635eae1e81e3adf60d0d50365eadc1344e22770c0fc4291581acb49448ba2a9c0616dbf6ae97b16d2b1ad93ea429d14ae27f70f6e2e7d079452f0664508af0a315f3d18ad60448cbfbf2d9e06e500c5d7135957fd1f83afc668744b9fa4fad2044b7b8b8ce237f364ca13608adffd344cf8d61077f2ba71230dd6385f70f2493b50329214fabf87db300ccc881b099b56d5fdb81f0697a9f45197fdbdcdc9feffff34e249d53313225746b9a1871d8050693f5c2775c31c04e467c2ae1a5842e3a55bc635d7f65af5a803bac1348a06b8e793f6394728713059a0efd56877725f6be575ee6d1a27af5e1174205e55389610741a6249c1817fd56616f27acaf0a9edf6f5d3effbad55b391c27ce0f587ef1e1fbf7a5d373fa6fccf60b34044fd6df6d2b00be7bfaea5a19e69a491b2ef9d4b130350afa846d91d194a74e4f75b4ab5a74353a4a59ffc475a22b54d439a22613116e619758e07ec092ec301027d7375d81c4c147c109e7dee4b8ff4fb7c2aed7feb46426f0758beacce78677a3a5c9fd58692ed2b9c9849f226be4b8af9395589935542e42cb12ed3920186b11abf588ffa8af5fdef00fc74ae53c2fe9e272f5359274d66ba6b73d15d6547daa9567b90bf893b63478842d4a624d141b4a271998959539f1f4b6a7ea3f9c036e01b4da6c7dfe95068256c0cfc4b54988eda878ec60153122d88232e16e0186b3e3bf4a36be931c77a8c3103e9ac18c27bb4bf30c9f7c966df5da31fccaed8071677a97207947bba5c4e5a27dd7b0d2c8e680ebaf3d94979d9be743469676189633d85a40232a7446ac1080430150bc421be843488da8c8c58ccaef45fefbedae5c719d28c5963963ce73b4436326a8e54a0f5c739ad564d5ee18e2d819b7d4170312e590dad1f8379269fcd2e22f666b32f01d9aab1094a5eae1be441f5613287ffcd319c36431865496b903f71ba79adaf9974f363d261197ed21ec656390251d715a7546fb5180a995d7361b9ef6fc4329a26b290a2cfb997338d569bd8da84e7fb3c1197b5982f6aafd8a72880cae9f97ebe4e822e60e9fa3e5ee73a3b447724b18597e35ce9196616d36d018e77d3200c6b3031e64b7a7c7e462a0f8dbaa838077106a76adb789a16bb647a7ff630492ba4fe2498dc05367997531978713921eaccb83a1cf1da478b7579bf1045440016e46b893c7a1be2c38dc60b60440f4397271ecab48c1f444397cd1d8fcfd90dfcac344b5e37801ee169c6d113fb622e049b15222fb5e04d3b7662a1818441ec5041a83c4d53d3746c5a1b410af4ab5c5a242f52d4185c738517b38dc568b18bc236f75d9143d410b3c035172384322954020abde62a1e3511058a2385fe77171face9e4cec6b134fcc5fce79980ae8959c870acb90ddbb035dfd8603500395af013c6848d3902b1d9e768f834d90d0f0475d1fe242f9c06e36312c5a9564dc418f373ed007a142003b1f3005a0f4354f7f0ea6ab53d247979195b6eb219317b4e56e95e0744eb327bc022587d79d9f84048fa5d2c65db5001ba6a2b89045a440c57397b4c35a3848e4f710e1efd2795447ad6c648fa052a2d53ecdbabdc4ba3acd6736ca3904a0c535e65b3754a84b1343a1468c788c9942d8fdc7ff5d125ed9d3f6715f54c744f8db04c3270a297bd64a839f19f508fea6f899610e49199b5d356b1d5ddec84b0870e6b4c43a1b6acbbdcaf8bd26a649d39a489db040f70c3a5cacfef77374b61818fbe4f159b750d3541ba403643d16b1533682cd55198ec608683e26e75835d3b683f8b97952c6d1f0e0049f90834a4dac1caedb079a0b628325cef10573e1b0012cee2539e12b6af5a9c7f5a7cd7a1336eac5a47d771656f253eba1b21e84dde7f7a1005e584f278956cc54311eefceb2cd95f7927a41b6bd18eca2c11108d10268e896c9b7dcf8df70ca120e1c4b3dca172fa29f1210dfd7a77a3a21fe4a43796936b1b2059d582fddddab55033043189f13dacf7a73a33f858137cebe9d97607d0f5ab3d725b10910329fa4f3f916d4d06ac596343f3cf465bdb329b6c26e016a36e0150f18b22757b49a19278b19d4234971720302403c776385717491464b66d918dc334240be408c6e331be7f9693938a98b561c26b1629f2e1ee7be941c066a700334fd77428bb5e9e7b9e0be6e9581c9c66757c8f6ccc7311871efc7ac4a002b02872d692a12b1beb19da168a6c777d0db7e8eebcb680c8cfa0df9ee3bc9c0b817c1d1b84f2dd9f65eef332e5f61bb830212f205f4429d559680b9d717402c8af3bd279113d8f955967da46d96b0bb325599ded27d4d01c1964309f4f9bc4495f0f4aaa2333a6e3603b1f982040ca8351a08475380ea4993f7672f5dd82d831c98c08d796f148469fd1e35c72395d5c890cf5fc0a8fa8921df196ba0a20abba47a13fd94e0467ec2255a5d35d39bf6d038860495bbafd836676314103546d86c78cda6167fdfa942fdc7798155fa8bf7fa0c50f35d08975ad626f6b0fd5b41495f9b10a81e653fd5056f58ddb2be9176809abce02ba17a491796b3def0a073238ddd3d1d35ebbf898a6b4f2d7daa0015cddddf6334175128606f66d904df8637eddaabd10dbcaa7e17cc7e5b58ef61573cdc6fda5cc5c97aae17658caba08116bb3f21498efd0e784f08654208d0d308e10f1a46d74a0c6356c20d73a4fa28cf56b881664e0ca1b133f6e38b303ba7897672977a4f37b85c1945b5b004aeae68ce43d4d9ae369780c78f040840a08e7bccb8275aff74d6760b8ac4a6504cbf559756028a82cecbcccd5a4d133afb57665cdcc0dd607c40c250b336586f9538a2597e5483fd1289581f18d3ec95b4358097eb82ced9df1e2b9b227b788146af71a49083626ce6c437b031c7ebd071cd15f1242312d85a08c891c62ce99f1fccf1264d6818ce41aec157cf62a12de9dd29286d082c42f73b487f26ecc59ea1e184529a7ee71b0643cb50ed144c1a328b712804da22b12dd53686955bb8dce47bf4ef20a036c069e327e77efd6b1d2be3746ae3c24dbafe0a34246444b6ef9441ef7fb58ad2b7f62cb0b4632f6b9be130eb403e203c971caf1c9419c821018ea82966e20fbf4edc4aa641854abc0c445ebb9fdbe3bef1341bd2bf2d2207cd8022f8a94859224639150ea482cdd7b73a681a29204c3c224ed1ed64890101be88ab96fc0a16ab0b24e33f3f5dfea7e1582352807fb488af24b4855548bf16fed1284161b35a7ab9b333be027ade00b27c472d6ffc002bf38cf02b776ab49092a543f8aab003a7a14346eab0f9f8174be631ed415c8ba5ab4bda5e32e71f7c63122449390b009cb9adb4b16784a639b8319e9d04e076211af1d3534daff49fcd37410006b0c76bf485a26438ac7333fba5e6d2ae460ee5df893e48e85c3f79c1155a8aeb39f0783715a13f10865c6bd001a6f8529c75904b270e3f40c6ab5f939835bf7b92fc1bae977f23dd08459825cadecaca1736e91b6fc754135f296d9337c07fe7da2bbcdb0a532e9b55807a7e6dd2698dac4a69c15d636836b5dd4cabbdfeaa336b11985f109cb5462e1706eb347a5d2e76316618d8feeed1e68331feaaee4e6ff55d4329f814fd46d5b345bf5e56466bb1a6738ece5081b46c9079a96f04789a63225b9432e216a0818239cf52f97b4f9da740365eaf8da043b6c72c5f90c6bc18ec5a072a07b45399d119b85bd9a1b7390116bd2a96ebcb97707e3c3ed2ab288daa401c2af1b46fef6a2b49d57c5841732c2178e56f76a41558d0ada54b1f5408390bb8b1f4af100ff86d0d9fe2b8f5e9a674cd317e4e3747ad338e6226469d26afe90ad03e60fd6793e1bccf2de2e2d0749574ab5fcecb88aa78fdeb365256605e9d695f564d3c00b4789df17d11504f8d78b69a18f5eea1bbdf6ba688e23452eb89c8f294f8da46cd6da6d5509f23aca6704d0e39426eff56b4ea998628cff1491308145b84c32ee1f5a07e3d9249ee122ab9961d58ce4bf128c4244e8ced6682a3916f28dde7159167a27f78ed7944a994e6feb99262d54fabc51916cf24accd424ea985d37ed05b8cc209ae3e7e551c2144d7416971865b5163ea4cbf62e2d9df141856f6dc00ddb25e921c77786bde7cd2634913515e698fc81768a668129d466d7a43b86d82862efe90b6d210d69de7bb95555a8b0f7deb9104a56172a2d67f9981ef0f73c717e259be326a6cd9d2baefc9fe272fd67558498ba0dd01fcc037131cc3e12ca927fdbfa7f609f257501c1deda85e3d5c5e7430adc3ef3a0f212b351d46b38232ed1a440d2674bfd464f8dd4553151d03d814e78866ae40182252f642426898fbd3832a39d3a56ee0a7ddba0d4106c8687bd73deb790da61efc3129fca0deafe59cdd6a959d4872a793196d26620a96c307f9824d3dae5d380a3b875cb62ff996a9874ccd1df33f5c05746cd3099b2012fa634086c8b513b5f8da9a5e4d20c6585922e5df2d6c878efcd6b4edce2cd22316e9291b05477d34f16d687d787dee351eb2073775ce1a98e781a168354951f1fd00b5cc3e351377a9a492b56586258fa1c8358ef732815e7a2037fecbc1f723b13cafc62a4eae9e89597953011af562cf16c58fdca6224ad977f2959cb685ae80e96606d8bb106423025f4cb0e4778d1613a80f5034d097ed453a8c26b2a68ad882e0ae149b924bb68151f985698749b723890e644e58c01236f4e7bbaaedea7a9700cce54daf5e546605cdf89270474cfb39378a96cc9a16c7a1bb0271ab6f8a488c716b4d8709d92464884cd1de859265d639915479c96a7528d7f8bf990058b1d7a827abbe6c69d2fc156f17229cc87db5c8e5f5fc70bae985b3c8fb04efcf46686a0809c917f5d0d6dba8da1ea1266aa9209c2b5d8153f0a4c480d34789767c79d83f4af765bbe6114355251cffb0e88c290a12089cfb6b634b4891ffb745b3704f5425763ae7b6291189d795992face1dc006e2e7761930cda0456c51234eb8a8c9861b13ec8503652e1e2265ceb2fd1d7e12845ae8250e26742056f39cb3246f000f66a90ca9c6386addf857ec37ac5e57ea6855beb8070e5261c4ee7e1d7f5ca96eb66ae32be32dfb6d361aae98ca482377be5436149b18f0157526cc13613e52d2e970a7628b4ed0b3dbc9c15e6815f49870ea76026e748cd62b186771d5a613df796c0984ecfe5aee24ac43d03fe59f9cdc1b6744f09fb05195066094f142a3f9a2dad20676240389d9abfb56ade700b31bc9d377679c075599754af505b40fe1e727a27841a9a4da1d9503165a14270e0359fdd1ad75db22139074b95e508b41c63866e8540c5f968f3df9690956535b07c07cd37a693c00898e14d4278bafca16df538f2a7cb54af3cca896f370ccd1b52397584f96d2506b15eaa3bd749b7938f8213a7ba0c4bfea5ed831acf7aa5cd9cdff82751ee9523cdf123db2cc6ce04d5fcd94b1ea7a208f52a99916c716bc28ac1786f17f9a84584e7096b4114b2505d9dd6c8dfd19fa56964499071dd4a77339b952f61c87243d20b353154c24f881b1fcb6492574b5cdf373267c36439729f09e89c2a14de2e299264719f3af482f5ce4ed2a24fa3fe7e939eef0fd21f437ccb7f959578d00ececd2f3afcf0809baef108d9dbc0738b7e0c7aeb8c70404413dc3141b12f31cf202fd2501276322b1257165662fdf6f117d0612eb664a9028ecc477db512d2c973bdd1faad3352c881899085e92b9692d927186ce5b6578af7be12f09b6a58b0aad149d8a030256ebd9cba29b9dc71815012026a1b42773913da3cc876fa11bd2138cb33ace94fa1194a37760a66f54082294a37b3de60f8d298fe7da7b28e5aa3aed058897fc83317e387b848caa202fbdc7affe10a80bc284db78a4ca35edea58f54b04ff61c591db84b3a4ae8136c429fdfed5a2fe93adac507d111aa03a95194604dfb68171ae07bdbd803d1918128ebc9504999ec66665b56a43b071ff43bf810d54632504cab6abb70c281d8f989cc2e66c8d32382b720c0a094cbbbdc3a76aea805eda6a6cede901f980c7fd1a0c1ae332c2671a34a4bcd3cf31c6962bbab2fe8b3c76fbc286201feff89d90eac29f8c5d94ec135f34b9f18dce863651364da305f65c5f88e33cc779a67289de06bde87aafb925ec3ef221246b0883d9b646fd2f449832bfc444134ba8c0e6bf5171a354a7aa94ef4cbd0573fb454f4f37d8b1cb2e9b992ccb8d0900c4c831f9ac817697b192175fa8dbac4572090d67ad2585fc447e801b3bceb34dea70b3284790de5a780c7b6a582f073fa1c976d70aabef9271d0f0fa1d0c1cd7ff3cb13a9128bcb74a89dbd46e242754c693f12486f7c081f087a3cb3a542003dc3ff5f5ca5b807255b24b9904e86d28a9625f7e0ba2e410e41585a1cefad3b030ebc82f6139fe4b63ac07f0c9264ee9a5df4e075a068c0e33c5a3b7edab57ca71c092d81ad0f987c6cf3141be07aebae736d082c11d39577f2d0f13585424421318755267058d5dcb09bff39d073620a295831def96c4bac2bcbea6dcb1728f53c6bcd8428bfd14c7662358c17041009161ec000376658b9d8296e1a6f5ca34c45f0b08e3a3b8ef7715e7d650da52650e9cc0a768f4cf33ac06cf54a9b81c0b208c721762d63720dfcdee9171c7ae3172e6ee03e8e0ce455c63bdb32f6c3b98aa71754460d25a477fe22a36e81b63edcf765ce214f1fdaa8f0e9e27a0dd8f8c736aa10ef89fea732c6c20a72cfddec1b4ed5d39229a024774c2017d99af913965b77d3318484a002fadf3151ba79ad2720c09400683e1af4d09d76f3dab6eca76710c57b62366229228bc55ffa3c8cea95e0f6ebc6a46917c23b920a6c27fbf3d7ba349e8bba187e0139b8c18bca86f4a7b7ba5877da60f4334271817c8b383fa6d89702fc1c07feb6dd97cb206c5a940eebdc158f2aebc96922e48ba929582551bab77a8b4e9c7b37676e4ad5c7ad80ee469cfe288b3ebd13aad74d778c9085c0fc26217eb40d631ffc47a2757d388296bcd1bd30c3617fa7c9fa9f6cc0102aadc501f0abc170d831b4a7c62d41293e21cfcae57d5a8dc2ef9e3afd20b00b7eb60d94a416e72093200b2a11d49c375226c405430785009dae2c933cd1c7ba6bc3d35f62c8ff74f80700620a0effdf3ea3e1a6e50d6bed86e699d61e570bcef66a2b63399e50ff018f387eeed2312716480d1e4a3ace755bb054ca488b4310c590ad59653676a29e45723a3c0182ae7a1f37156f0893293a7d95cbddae65063e866de7d4db10841da9804472e8b05aa7ac44b3fe50f3f6be4a3426d98ae65eef460ad2fa410bb0c1cf7d4cf681da5eddb2a0750986c0f55667d2cbf8d300fef5918c8a7bd2d3eefba73d35793e174081a0c344976efa4c1e4ceccb8782b9a5d407c2070abbc2f8db91c09f2a94e66b0ac7d9dca6a051a1b23e64994275adbd8c6f710b826a566792be8fea76a57b0d35a70894757ad9acb4b3d6fae6ce62e5dc6021bdf3cc0572449b512eda66c12221df3ac2f7450ce25ba820688da49d016728ea718477ce8a7f3f5ada9c7fe64302e2510eb539b2bb8770497f3e9714a55909db3532241f3f5f8c020f0bd657a583bf2081fe34b8ab5d1f2d150f15a9a224524e87943b07c4204b730ca9ddbfa07ca03448977b4d41428469e4fbb31bfbd7559806d53596fc706fc4866f63675733d9cf1f5c76ffb20830da3d07b39919709b6ce12c2379dd87a8b2d77048f7cf77f51556b14412c1241b61c2a3db793009c0e23917debee37d147001af1ae69aefc573e16606cdc618f7430f32febc01d2e1058fa49da84245c5f7909fa2b236a1ec5714c023f94c5463f8c49bc3857e66e6ccffc9c708818c7b954d8a405ce5f6b91c637c3fda149c03f31382ccefa21644a14f0b84b40a75126a9a4a39b59f2734187c1826f7d162882d72e7fa4a876bc8a3ec9026fd86facbfd8e3b5ee9f581bdf37526d36aeecef9a87f92903883a420ae4d7d595260bca342b19f82a9ecebd61dc76a5f066f7bc11ff11f7e12743fce8bd8c50494b6a97b5abf220b0375b7301c3be217977ea1fc2496658b77c6d89c5539060565d3a9c290359e0425cadee5ee1c5c6795d415c3feb3138d6db56f30c6e32fe5382dfa2fddc7a4add9017bb34ce5fcb284d85a1ff6dc36f3fd0ac6528b624c31026b225931366b93f237811341641406ad036ab93164e07bf55ca61c524d8ec0dc9a434e3156280f90c61f18685aa04a0dea14526582cb0388dd3b5579e2110b6b9db2e74ef6ad42f95b2e04002e9cac55d4fd1f88b226dadbad66d37528001f525774b2496822bf59fe0f76b55447dd7f8115a0eecbd843f5d796c6e374b407fbca48562067b5d4a4ec448422a3fc79a9261e5503c6358eec30e7573d4c17686ed6ceae0045bbeed45fec08ce6d7f66ac7a119122699de5c074b22245bd5b28d68e9e0fac3cc8868e9410d1fdd0587b481a277275511b86f36c8c8315bf09031e32d1f7d4ecdd1832aba5aaf72d958d592b6daf54754e6d6827eaf9c7a3d561f8dca40dda422fa016d40b749ec98dbdad4067be418cadd1b76ee5e06d0eeecdec10f8821a26f762d88cff373b828253ef98f34b98803c6757f19d73d3c492029856dcfeb1bd5018ed1a04f71ad03ebe584e04bc59c87868ef6fa233374cc762911832ba1142bc448dfe014ba186d691fe0d9b96c8cc8938bca4ebf8acb14aa039f50b4626fc91f3a1565e1f0be3aaecf9d87237c3d790ae8f75976fcd2110ed7801c5d596f4be6f20c850fe2ce4c99a4d059e4fb15adcd31a3e261db7068b3ed20e8ea03af44d4701d2bd99021d38b3246d4194a5447878b603ceef5efa5329c2494cc45b335c3c0161a113dbc651729770bc3d82b225c21cece7734037314f4351a1bb5fcbd11bd3e145dea8d714e6083b7d9419a6ece8339b51faf9a8b9542f1504a650cbae87a92062ca53b4816c626005e9f4b177df1f7bd011bd22c3c6242a064532ebffeb4f65947817831205c46d7abcc7ea916906a27df64380c27c91446efebc655c3c991dd5ec13a65ef1a2d55d45453338304511f0e0b54a158d8e822dae99d32a00e8e29e7f0bc85647b8cd6a87d1d45e74335b3f43befc2c57ccaaeab1d1b222b233069d033b862876a3e50494a8ff69488bf7b7dec970b48396ca8461966cae886b513ca5f435369354bb2dacc000581ea8c0b045c1f659e205bdc90f053db44623eb4bb9529bc134d7586dd084442530dfbb2077d0374e5933d30d4608a7fd9c2bf27aeb31d4ed4d86390193f907bc434d96584db2e7249f54f1254fa5218b656ce7b26e84f51520a8f578bdf97f07ef9f35519fcc6555a2dc5d711a8ea47aaa8c4ee0229dc34608bb6b3472c705abbfefa9caa2e4a80c0a61e70d1ae62a6fc3c6b09228ae8c84ed6cca2f0656c2ae855fca92c499da1488b876480daf92c75b1625edc5f7ebf4ea44f0628791691564664ec59d3233aff0af0974bb65f4c96916318a569767454cddcedd8eb8cddf5652d5e27442f9ce8cddc53d6f078cd4f993eed5679a321cfb8f72e19a54829c936d757228ef7b5c7ad867332e0ae90ee1cb5e0e228572a1fd4b0765bf53dda44d8223aabe0f047945348cf52345785e594ae8278e6b2147f39dd77cde2c2d68476646e924b46ec47e854fa85bf16ec2d4bfd1fb32f0202de4164dedae2cc8b79e01a0b01cf5a1e6471dd3da56893b433beeb8e227927de364c0ec2f1d0323be64380b4309a900fa9ef7680c7fa82f63f176ace5a24d96582aee77e9b1dfac5cc0f3b345345ed8796aa83b4a7feb8bdadc3abbaedb5b4d3879f7f0fcf21cda7d5cde947803b0072267d3ff17aacb1447e958ef842402b2d0b7158e0d4e09f433390c86065a167d48c77e72ea5b77736c5776e25c47bb9c67fa39c69e0f12b43a07667b8cf0d7bfd85d8c179ca8101cb10aa4009e2b7676728373f469521b9ec3c96f2c5eeb3a47ee535ef5def78ffdb9f2d6452db108c5c088ef6cc298590b757b5015d9133b68d73fb00fa184df41b4345c351179520eae869cb8ac0dca73e992a784e88d488de93f55853845bf5620fc7eb8ce6055b8487fb86dafa6dba1a219382a2eea24e515c76439f3713c7417c421b931d9d1c50c8e0b9cf8970762980f39151bbea2cdede1e18998e5fffa9cb1658ab99b74ba6dd50283f5a9a6bcdf3f220e8ac152e75c4bf91d8205a2fb66a165fa78fe7aa64bd24efa3c742269a73e313abd2022c0b3df9c986d0a2c1166e075b55026c3cf21cb3101eccbe9f122f55f1c47b95949dd90446d658e2e767d052398eb4e400ca15ab09d82f1ed0bd7172cb0d1f387106e55e2e637bfa7c2afd74755cb71b45c19f2bff87f48d82edaceac1554ee736d2a52dcde1da90177cc0ff3a3057b86f5f4fa90b25e8e4f0d5a653e5d133d429a72e21dd002133a4c44344572b72fde4717c091c41ca6c355a45b3c5d0cd918aaa1b3e56298b9d08b983033742f73a3ad0487cabbfa6850f61a3650a4e5c87a03f570ef885a3e84f625c36c15857b09d37b325f53b61bdfe99d452f331616ff3d7f6c6b9d140c5d6c68a86d9566d71e6fdb0e5751a30a7fe12fa417735d3b7973b712c7e7727626b0277ef1b8f85fbc20ce3b7cdc6f42204a8ecce4caf01a747233c0b1c54b6fb6653d10bce96a4acf96264a545844fc4f6d24fbbd895dfec57b3f8c31310b67ac8ecc8f9264f0dafa24be0ac40d8613a7ed015a1bedd7bc8984fd65838cf1491ad38bce1ab60034c95b4843e4178f6e4824272ea4c2f45b8be2b96814a36e2d515ccffbf966fdde2431d034f321fef21e2f753a6e848e08e4beba6efafd177de28e648c9cfe2ffa2d103feb8d472e115b6de3d33d73ce833f5b6a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
