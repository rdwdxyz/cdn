<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7d076211e4c82f20ba77ae7dd4a35a902c885235ec6ab27cc220752b14a0796a2b7c41b8e1eea7ca19f12ed726c3f4485a48c8bb1d1e94342decb823bf39590264437359ce64b0fda375eec4f3ed8574d80a4a52df5aff5cd6456303d4434e0660470a236e128dda2730c35e28f861a28c550a8cb4f16cd417b93a1bd863a21094ece1cb0c19370cb12a58a4d695847a96af72a3703d007b9f248ae1933151e6c74e965fa52bf1374c6f3cec64b08ffaa56fe564bbacd165065d0b72dba6a876e7dc8ff84e4dc90a23845338861c3934620c77e7918af9c7b8f82489a58ca3f67003175c3d422c934183dd96ad4aa2eef8a03417df903b56cc41ec6aa16791919c592ec61dd41d834000f8e7c8afe9a940bf54a7b18365b8cc39216a310d472cc53b7ee34b776f4092247838aaf8b61144bbf708e48fba9f69c9f074c750198858ef63d85e79297e75f8125540ae6bd9e3960cebe267adef0a902911f40be84b0a7e932719c12c648463fabc842e1f24a9a31bcd3fce3b9f4730dc4dfc212dbb5c7b493036fff93f559c4fab34c27771f011d73ec1d7eddfccead4dd6a260271e9bcd1e56aa7e8b282887d60603170121f1c7c300e2be46dc7205a452ef9ad51276a511b917c6ff61f0b5603e727347741ec6391ae4beb69407ef0a487d2758102580f686916a6bba9a8117bbdb8531b4247b94022a7dbaa27d7040bcdfa7f8d903c2a5e2392e31bad09d52447e2db4ff11b2361fb2d9ef696ac31b1e196f613c6d39d22265f3daec2cfe4bc1acdb8247ccda6fac63f146cbc78ca23fb7f1e8a95a568e2e573a7e65f137a5740af3afcc9b37ae8df908d2e94889355c7acf98db80ce06295c50c5424c978e4046af622477d53be8cbb4a93edfaafa4a14a0cd94cae6f7fa79257b5c2f10b1d8826a26880d7f10bbdcc89d969338adbc36fd62f7108c5881f4cef3592e5ce807884f7c75f5ffeac1d34c0ccc4a93b6edf70e6080b10244dc4e777aeef8b601814865dfca655bd166f14703a3dc917229e3fd58a2d0837197a4c36472fb773b98ff0f30ba56bcf57eb1bcbda06cfeab4efcd4ba3eeb0513bb30161ff318bd85805968b5b0a852e54d2fe8aaeb204c4bf834d7529242e13147afb27368ea287a3521347824ac47f00aeff5183e5e38275494b14d71752694287f8ed01de71bafa368c357b7e211ffe2383a1e4e10ec05ad6f5fef7800a5bec615150a997a637d4bb51d6a66dbe7b4e4c8f46ad6c86294f60699aef3e5af1101f322b321cbb06b8c841a05a02fe341f1a6affa5c83cfa62008977aeb2f21ff716078ab2ff26c46b54cb9a438aa2cbad69aca074b585d4afe60b093f4a60f4eb33a05943452c7b1039e46ee694be18dcb66b72cdd88aaf63441f9538880c31880a2913fc0965228f9bb9095739917537ed97ae80e513e9acbcef45e251d7ca0d25a3a8fe25cfe2d010e4cfebaefd3e9a643ff9c36298e86c539314583e1e205cbe4f9c15c34beab0b97759499bff4be34d6062d90c10dbbd3b127eeb5977b6d687c00f4ab29f7921143a592cc151670bec65547e093e1142d160806edd1172680edcc249b1e7db49933fe8aba14126942d3c29493862e955e9ff78961a9fd242c3b38691784752e9781ba3634a09782cfc50a9587830c327787719abcbd05ba32fe54d27d7e5484f1ddac2da1b504f14a9dc36feb8b5efa6962abd6013c3b1946aa7bbfd5c53f4af3b8549b19e705066aade9e841f5f7cf719b5bd725a604981f6b3e71a9e9b0d305745599f8e29caee7819dd25558fa49a381dbf6fab23c03e9ec46f02f3dd8c4f39702ea940fa145d894e70ceefeb0630ae4f9e73f8e446d6ed0aa034538d571a7d0a2a931fe23cd9ba770caf747492a38132a296a5488a9379329768396f0be8d49b71a096b8c3020575dfec375925b66647357ca10cea33a362f855b78d885456fa82f54d2b34bd8dd86fc5ad6bf28926e153b6d2eaf4635b2eb82c7f7a0bef94b016650caa5fd3d607c7b139668b237308022e12d45248e4db398487e765fbfc6e8263204ac4cce5452e7d9e5d0562b6884a5fb031ce807f10b4d89c27f0f42707dfcda81db94fb3f7a8fa25bc6b6ca28d89f8ee297c4d1883a55cd68fda17578b6ad5cb91f879287a8deba1550ee16a7c82167cbf6e45bca15a6d9ce9860def086177c653c98fe7e81bc65ec5a2290718f589f25e72542c28ef8b2243fa2ee0c2aa218f8bc542be79445d824307b9ff9777988c01ce456033f4a3a19b03574d223fd8e41b58ffb548065bbe8ccce4fddc51ef4718d3ab79ea2109cf49e303801d484f72544b8ded9c017423f04040149d2f75881a3ac5106ffc105bea63bb8410949071f0c3f3bfc6825a5ba5ae8f3d046393426045d7a3b750e510a5b069c44f49d9c0c2e3c8eaefb05aae83799cccc5b056d76668b2bab62709d8b721ff6531cdae094f15a5cf3b50034365fddc87c7fe912d92bd629baf2c0be86a13afc8a8b486fefa8c4efd7a62ea6ae4138422c5f2c1a800f75c55bbdec382d188be1675761a356b8e30a2e2db4508a53fc66ec53fe7abcd9069055d5da5d442ee6e5408e599ca613d317a6e0358ac50fb9e365272ba5e401ae83b7b190f1e4687a86183dadbeeea4b8ca82a2a70793787bab7ca14f3e723d372cecefc73449e6837f1fc03c5383428b4de04a4da35c2a059e2a75f96d4ade2b5bb2d9e58f6acea4b51a9869ccec345c673f4aa4bdb4a5160e09f0a714e2dae63e1ccd9be7e3d8d9965aae762a65943625dcfaa79429fb6353af6120f4fadfb9ed5f18c1dd5ce42c7a84098f5cd58e8065f9c3440df5acea36087689dbad6834c767c67f154b6d7894254327d208d98058d2a3ac334ff7ac40ad04eb70b0d9dcb112ca7856ada29b146b5783c83128f24d473d3bbabe84cad4439e0afc4f24418fa6818c6898387190937d111c44fd4e9194fe40b912ff63e6b066a8b08b9f7be5e38f76edeb7a6c7f5c9ebe926766ab92862683605a8634a477726265ec7cc964fc7a683e528e9ab7267da38a51bda85bcf62e81a0f9b21a6e65e742513de4a275ce9cad873d1b7fb803b80654869222350b506b2a477add2e5e5e9589bea597b9249db02a11813da3cc2bb6be0a66014494171d639dc090f9c89d4635bf488e7ca07cc10f48cbb8e9436f7020181129caac083f4f52a95cbf51dbbe8e7cfad5de261aa6840a00c02cbce7e2252a102a32fa9e57d398bf1c53dfb5f1fa8a3851933554e02c1291fcedc386e75b26f388707b44f9fd82b801074e3c29c544c143a6ab3ab892de2fabd4e4f8ab752a3ff460d299dc67266f7f7fdddfcefb9bc4c8cab9f2a850ca742eb74c5df8c230ff81fcf18def2298d70b1123597d753b44a0746889c0beac79d0976966862e80f9ff690648218836b4260d6337a5442b5438aa38b76c2ffb004234677837c1ac8464b14a31f96ae292fd12be06a55f1d237f0ce0e36014bbaaf61dd014871ae3d52617001b57c359d147bf85621ce263daf8de0c7632e8e5adb8bfad08102e376fca4ec218963b3b7fab237685141c0bec67e74ab36e913e5fb27d8dc8f4e4774e4bc58fdf5d247b9eb38d262584bcde40eeb32327389d4c30b550c22d97f36f833ed2bc919a5a35a618916d3f0e04da55cb6d798cc006a89d19f0febcca84948b86f47d4cea63e5f26f1d382e202349c10ed958a7d10644cd43b41ae52c72f8d158c8eb18ff1eca01da4601debdd0d8ac407c48b367a30ca0cecbb4c0e99efaa3afedd578d1321705990ba457be1a857c4d9ba5f68863f20e2124254847052c959f63219fa51ba0118be7f55165c57904954b42df215bdddeb7ac4f6ece41a8b075cd5415b034b47cc6215fda9906af875ae1c8ab88ad230965242c7d416cb4a7a2c7d78097d35587735c772678c7d3dbce9bd6cf8fb3fab4702ae88ff54fc60d88be399c011210e51d8252a1ae7f917c4b58880213325954b58f86ac37406e9457ba43cb23c2c39e842697377682f869f64c533a48c6e01985bf2828818bef24be186d4e03e193414ba650a5edd51b8874e7418080eb01d64730d187d9e4da4665d774c7105f8a520502ce36aa8545b22b755222e202e461822a7b1f0a351f805735858d2f2ef7f784a2f1a67e1c927b17a7eedacb9e4c23a28b63681fcd3d41b62a86162280c35b786aa54ee3877797633a8254cf46d8e05929c555ca8dba00b859638d0b190ecc2621b85b91d427c1375255685b381a022eb12070754d25b0c7f487e23efc5871fd7cacf67421e4ece3fbde4052d11a1aba5e8ee63af40f9dfc3b3cd2bed96a5486cbe5112d7a95951ee317d5b39127c4a6fdc631c716a5cd46a3f7686064b5374342bd9c1b41ae2ac299fc4c247d852d2e6e1858b8a620d25a0b2f9cb4b05c50e839f5842cef783233dee245d53a59cbb54a26ba8e1240f92e9893d862eec3103b25545dc83a426f34de13dc314edeb1eea9514c065d2909356399c46a7a984a39b3d4db988ef8f8d99eaacae3a9dccc8cf2637f9019aa61b22fac41ebdc3768265459acdaeb0bf9a03aed1220579ed40178b35f21816b241228b93aa1783d9d09b7881bbbf2f60c8fc94571169b08f763ed6d690d62815a05b561d7b6ff746947b09b1873409a3eef26326251b8660ddaf824aee0d4dd5565815a883f9407f7829def4972b9bc760f527f24dd70def03a8029f17b504a7fe3d2583e557770e7450b1252bff92c91e56bba9b66d44392901a65d3aa3d93844e8457371b3544e60a95ff058fa53cc1a401d5ee56299af3b34b564c1f6501c7ecfd15621d6080392762a3989700e1c4cfe9c2906de959b099a202d068309e137c4c2106ccd2e6bc92bd324a1972fd0d2b51e5b867b465d2725408b6893a667c326cf2fddea4c810a61c9f23991266500c008bbfb1f14b388c61ceb1641bf224df2024557df4b81cc4fd62e6873f35955bf63a5d8711b1a48489b373ae5f8b519d8f6040f48992e413aee148c226f8f5115c3e353d08fe443607c0c4b65082b11d29bc404f711b0fee13f2cdb93aed6bf1871e3d42371e8e88af7d3be0706a9ac3fca27a1f1796f083a3a34986cd2d37923051d2045f7c980a4a8c85157bba1ff059a6a94adc4766262061541a49437ac67a8e1c3205b577ccc1a38940b70d47b2d0289ea5661728817b609b17ef2c4d9da5f6a1defb114be683a2cf6491e20bc2fd3c08787818c1aa1a74aa7350f8c0b9b84c09e3f8217b8180310c8a5d4446f6284568427ac8e02e9a4997ad9cc074028495c8dc3850d006ab2bab173dea63905fe795651b254ef186abaeb1c95e8d537c99dbc5ab3ca4069550a3ada1871b838b45bb2bd79e8cc82056041e4f0b63b43f9976fd6540090d8dc2de1b04da0c85af75eebed2d024d1aa695923ab343944a26671b4231308f4e6da397d06b21a8dfbe44a7df981d106ca96bc26fea3476075b516192b0befbbe937af1e6bb7ce654a3526055d61ec4c5020e872dd0299483e88f7d28244432a5e5ccfcebea250837647ee58fe40dfa9a272d9d7c7460ae7206fbae02019f05687f315ce0679be44751afdb33f382a653d152c89970707c6219a26eaa366351498e81e9380f62171f09a317110e283d9d1abd5353ff3f2859d6542a6890a2779d076b5d7fc8259cbe498c42694c2de51c1f823b13e52e39037d2c9298e57fd7f6e8c84e4f55005bf8e36429de2a30836fed9f74d680c7e2f876cb9958d8b20f2ef2492935785af901393ebc26d9138b089d2b36fb0cdf605076d9e55ad064ce953057a13b6f197e82e3d806bd53ab9e833429c7167b6472e2a9d72181cdc6f90af3ec30bcd4aee56043e4f3aa5af6010a547abf844dbeed7e4f55003df4f7ac9da4276ab5984d513b6c8cf2c1c7c0d782cfbccb7083adbf7710b35eb900a719b7a5499231710e50eb40ab77bf3c3203a55215e271f4495d226c84251ab80bd40b1b8165c2f8c78033fd79905d697bc856c1720f5129c76d9ae0add022efefd82ce530931695da97839adaecd939810f6785bbf1c0a5ecc6de5979add83e8a0718fdbffe978d2a42b7568f49af30a7931a3ec7e4bc0924f672fc89632331566f04ffc2bf9c7960680a8e520673d4ace624319c03ba5c79094cea026668e1ad2db532e4216aa430edd1da01a876a4a8d6965ab3281f509281f59c8b281498fa7205400eef742ac8bcc1c4bb83d5df12b5eecb8921dfb1dd235da932f6e5cef47c85e1fcebc48f4089a70c5cbdfd9077fda51e74242ccb72e0401cfe3875e1be43bbb6efa0f03afd6887c836fc44719ebca99c17b57d7f359ac0310649b4387cc8833a58eec87fed51427dfaf6e19035a45083283b378b8ac3454642f96d884ceb8b56dfe3ab49dcde64900b319ddd76e8bafdafc0fdbc238e0e11b800358cbf35dc935aa57f990ea54369e2d66f75fc6360d8fb69a1a085be79f9b66a6a63d2ffb0cfe40dd10c94303791d2dc9a47ab7002126d1a5126a82dd1be72b8181bcc2189f941e91c3d446fd74048b0c785ead0a68207de1e3787f79da9da4a949a6f02e6876d46f137f754b83cfa4b1e651401b638a309c194b4bb235fe3c58cf464b5ac62350fddfab4f8084d67b9314482cf66176ed511e55df59913c299f6bc1f83ca8e1f752ab7583981c4bc277af64a2a2709829fedc84bb413e6d14e527d319fe5bc4b047b2729ff520dbcdc0da82dc0093fee4182006aaa77292610c80195ee80a1ffd4a2bcf6c12e6d47ed2c34079577557f4f31af574f14e8da45b2d8407417f4229bbded171be25df39327ffb38a7cbf7424edb946568e2910b6e86b6e112789d5c620d7df2bdf8cdd48ffe14b564566b2c4d16104f507ec3f890821e1e4a107ba18f8b19a88070f4faedfe3143038f1aa25df2362c24e7676c12a94cdf18d37db830b3357890db5e97191f6607db05c333ee3e86310edcdac0fc53b36cef5784d1cf954679e6d89fe95936139cae9d64ac5bd7ade80ea5ed0136314036435f46fd20362690ea13aea81c6f5d8eeb6ce10330ee5bc4eac9568a1b183b29c6dca4b8e81e8cd8113f38a2e23f4482ea5ba37dc41e630ed0e5ecf3d4b8b93f9f8718035124fd6bbc9e77200c3e4f4e6f9fb2230ed65117bba82b570b00440e271f606db462d75f87511521d5bb2a3ab324987d54468868cc3133a20773af1f9107aaf0a8c9624de50e7a59ac84f49c7f5e3f7f60080f7d53ea5451c4f49feea99170d054feb140bc67a9c18c5ca399d234881b456b863326937ad37bf4910a49d0ed12f4e64f295db30b05c97a3ffedd3f6136f9c35bfb43c4404dafddc3f78200526e6039b239b6dd4954eca53f8348ec33b07afdc7e7666294b858d696a8db6a5fcca1ae227c8322d1caf98aa24640f3676f3996218c77241d8d8b9c4c1e5f65c534b3eef5385e77de30f19e36f16e75fcba9aeb2c15440263ab3dd52cf9d4c8b95958931a0c8752caf595cdef6943ffb55bfa8ce0450f87214a84deab0d593b5a685924630376d4a6e06abd36c6913d48fadd7ede37f9cf496da3573829c80416fb9eda949d25c1811c2b023488bebac00480488e7a04fe7ccd12ab47a9abe7121ecf3d85626ea07167e8b8368c2d6134a34eb6fcc9d467b9b818688e691c7fc5fa04683cad8f1a57d49e1b2d5955f12363b03d126acbcf8eb823d20608f3f6f310768d6b90f5f577ac6c97bd747172b7ad03638a8b43ae329a171e639b6bdfa92075cb7a1e7c2b12174a67756cbe0925ecff3729ba051ddab2ff2c09120cdfaf1ff589cf9115577f69f11a53be77fd7540ec10f8d774b88c5edf0551abab8e844ba5d840af713e406ec2a852e22e2c65a0490f9b24f037b7e52ab9761bf250c4fef0cad9dfa791f52572e29bf90722465a2d540e0c7e831204e7b977dc05c0206a6a298c75ce1b4b6c53b3a780c95e61bb2960e92e0b7dfb90ac73b431e9b6341bbaed37b771c1501f5308ce2679900f08d9b82149bba6ffa34d5bfa8958ebdf714911467d7a436182e8ac7bae5ff3801c51014801ae4803872279e7ec80ab06539dd5a65fb59d459202d9afbfe10a6deac3a657a28867a1d119a5866ccc693711a85d40e39a4dfca35d5dc5367e7574a6e66777f3ba72fee61305d1d97bbed9e16103cace666182bde0a499e9fda991424978cd62d54e3c13ec6c53a53e8c8203033d5ea75b43d750bc69309b4552377f4a7f96f1b0ddc07575fc9a7ce5d4cd321ff25203d5f0cd534452c8f379cd0e5c1b9b1489258ee0b61c0b7721fb15f28c26d433b6076c7b7792bbbdd0426b65ea0993ad2e3e2da7f0159f9c741e2d9c8bcc175bdfc88b309bb922431d86f9a7d6b914f256e9613ea046c88524fad9d177af8b324be81bd02a1f0947a33c5a503b673b9712c0dbf4ee1a98287e616dc4b619735478574d8246984c3660f9fdd7b84fbbd9e54e3f9c65409a9837d139b50aaabc7468a8cdb0efc6e1d50960f6189ddfbf288f2624023e7a2d640cff47e03bb76f633c4c4f2242c138a878bc8b72e41d3cb0f386c78011d8a40104f921a3c19a7227afa754ac82e32b5791d0ba0f48a3237ce0361b412efd0ed2824bff086b7c69886188c00a3a27bce7f81224af1502be2986c4bc3425bbe57dbce4cf956502884c720135e0df1670d1dd7c1e808db4878eb318732bb75b75fe08eff9255f709cf942f668f46bcf84c29e698301876d926cbe4557ab6259fb02fc04d60ffeaf643557f008dbf322437074b270a38dd959eb2114c83aa814df22bc04affe72dad912bcea41e43441f190e9032f68f75d1e8bee20ed33279976620509e13b68f3786be44ee1859400143dbbb5fbc8bd533c0c4fd208e3ef8776e6690ef200a4f51c4f40463ea0f87b99fa9658aebe68454a8cc20e2e1f7729a03d2b6b1068daff77a5296989b867e06e4fc4f8f0af86a08ce9a146923d9af9b9c500471dc7261aa77e780ce2fc8f9af2d3076ada1396da58a3f40b7592866d896f8b38e27c3e461580dfb81a056474ed0f8c482deef58cf34815a4127c640766d5b961088b1ec539fc86c69abeec3cea8cec59e354ac150e1250a2d9b5dd17fc939171d60d1abce0c7b997b62b5b06939aa232082f25418adf77a08ce67efe5f15a67f89ac6b92109b4bdea3a4c69cd17f893554ef67394e4b40fff53e962ff823d1296d8db9a4413a92bf0908ce945b54e6f4131fc2158e3d7c4faf5df40f9c46d89ce3fb1dd11b20b10374419f6190351fe8bf03d5c714c9aeec6780c702fa2f007ae6a40100107758edaa17086f517299214cc82269067347bc733818ca5834f87766e6261f4cb340e97cdb902f5343b790d900f3a9c87fdb9dd3b4bb17ac6ad9cd117d6bdc05a2d49cb5a6beaea22608e483d21b21950e1ca37a49e69225ebab44627c2e337019f107213ed171212a0cba724c09a4f8316ea873753c5ba47c363a14174e38c2f24d4a01d854a05b811aeed2901ec743fa174a1488f0ab5b9d2b4a985374775708ae51a049967cce9d8aee700046310da8c4b61ad36d63cd76262e33ad56040b31cbed0032366ecce25fa864dafdf2cd9d57d5a1446383542af13a679f7f6a81b983060acb9ab0506268b418651f4e2483eec5b6fa11d906a9240a958609a82f8cbab0e2177ba0c975103e305f0498aa6bf5dd978cd9a57381b8ca069ea216fdca53fbc4045614f93da6f37f8505c2fe3ebe32d5d80edb57a75985dd92f3e48ae44c6d3c38fe7af34122040164f421bd40169c5e3e3eaaeae8d1b96c666836c577448219eae4fb6c6cca78f1e84423bb2ac3082d0a8c71e0447c5c3d52ccbca58bcd99f725cc4470698a89efc7042a427747a681009c1ed73cdb32f4baaa4d1b83183903c1adc07e27419d5af8fae8089a74a17c87452211e8c79ae640a39d969b915169c279623024a40b6b8cf40fdc86763742460058508cebb006747ad9ed9383e861d2bc4e0d3d97662915cea0a43fb61a386a49e730b36cbaf0a6dbc2bd2e414a481f58f5c0c9f8d963559b1c217085ffe9920797ce51bc5c80b5f0e3c5dfddd4a6cfbaad7b7f6f2e9e9ad6b5dde7b8035086bfb3d809e6388645ebc97446dc0083e59aaba6ee1fbd70f43ded6b0358f951823626e3d21252d853b3ac0012b9ecd7e8a73af2e0a58fb4f3bed1cd5e8640606218c07260674a715994592f2af2e2dfaa5d60d3128b63367225a489fcf294d8da97d5734eaa15b41ced946dafa462ef76ca92b0347d3eaaea3cf67bb2d628c779d4572377a9dc65aead837759f0ec6f52fa1b22f6aa83f42920f3136cd7396c15bb41e50be0842dc91b7bcd864876ef85d3c726ca81d37bbe5011974729ee2d661bf70c14ee019f1fdaddc38424352758daed59d507326b02f06f476a1ca3dc2b4d968828f9a953fdd14086dc2069d52eef15d37709a2aad6948c90e8e2956b2ea65a6bace3b9439ddf0db2d97c861403956f86931ad4ca5223743d14f7899595b037a84fe7aaede33ecd06e5ce773c13098ccc326f258b29cb9bbe08327a0316d7a12b651414a6a556a18b23e0b5b98056fb70a3a66bd0a717de7b98a7c3733f9ff0db3805cdf26d92846c548ef86cd876162b073176d84afe0ac0b59e5048ce41fe981ef7f91000a50938171ae70d573eb74e080e65ed8bac1cc7cb4af632cd5bef4259dc02ff0bd3c40983ea6f5818d21986fb98ec4d153e5522dd2cceb8b4900c64d4cdc2cf8f35fe1f87417d26e1c23e7f6f2264bd3ad6df3134b81129ad24ec5c2b91a7912387330269f57b2b45036d32ca43a20bbea504e33f00b6d386cf2de86bb9815d74f5282ec70d331b69c8d45f01ffef3937154d3bef1303cd28d65e181e5fa9175ba27e9aaaecc60fca5bbb1ee4e1c6dc8ec14073f05b7c1d969dac52db10a51d6d94b6dd88fb1b5cc9e90a4f44d88ee1070da60f38428c305205ac8e456b38d64b631c5638246b828812e5e122bfe3b8b68199003429b8af8f62feb0c005d570655140ce1ad8e4c5703142c23e29c0e365f395cd68ced80ed27124eb5072f11a0c5086f17f51f7fbbbee485522d5f9cae78cd7605390afea034647307814f69ccd2e1f53506f42fec00bcd77c6d9001f52c4ca682f27a44ca2d6f4eded30f0c5d37775d6551473503b6ea76b84967d222516dde072bd59d09b571342aebffc2edea74bc2b0ddc54cf04ef81c5d2d037400ed499ddf321c98fe85ff57aed2f537c1f4c061afb0e06fe83073d05b58c6280b02682af0c72e2f61986a803eecb948f9fff18f1852117153526f7248f6e78846e6eba05fb1a28d6be20da656756a802112a4080659a66dd425442d5730b4fb2e1f8ba1ea5e9848a9dbfc5994da02c4b9d213544d6c6d57f67cee7668fefcfd09b5fc2da7f02c0daf950daa4937755ddeb4e1061776f5a6c3ad5fee06e0a3a25f18f1da7aca49ac88335a30a4b1d820ee7e30638bd5cdd387a4626f6c87276b09e77783ac4936786aaabd83541c5fb477d9f9b2d35233fa1193d21b9538fc47c857ffb84fb20ea6b6b31fe628392abfa52748fdc1e736b47d18df7b5cbf7f8c99aac4a08f972a1c624da147ec743c8341a3195343458a0bf712b7083f7c91c23adf84b4f1191eb6b086e96a46a4d464b6c85a267d0c9eebabfcbd745dbafd72c7ac3cae7277bb0b176854ae4392f13054fca5cf4ea2e46626c238b924a410f5d2980f7a0e32177df079c73ff640c3d3ca988e856b3d661801543d93ba6b9e29d5523e83f28ae8fc5f99466d96afa44f7c4112ab20cebb05c9aa162d39898767c88cf0243212e6180505e57d5b426bcee5b878dcae32e571f8d5df9b9dc2675699625543a624a691553575a66b990f94ebdd22e878dfe181e3c5d627689d16a0c6a73d518508d5e577cc18e989cf8e373131f9f934f70667c52f7c2b0a3a3739570a958c4eea605c57ae54495a70869e21d012df29d5f4854844f301282e44fb9f609282d4d0ede1cf4329767ab559b273ce59e817191ae4e88aee5033d0451fd0de63ac1f18393302ff034173e1e4365835bff11f3a056670c2c97f072eeb5f1b019447e44e6cdba2b9e4e9933c55e70ecf29dbfa1200147529bd82cff73d99a64bc4de73320569820ea271879928b40b9fd0bf3308bb8324b076163b7b216c5994861c75f571a7fe3473f6e9a7b5bbd728500ef4275a4bc6e07790f66daf13376fdec8d9dba39e10f459ffe7f9b8cc4c49d35550cfa74f92d56b121c4e65c9d4dfe6e5bc41f9ea52e3c0c763f0e172457513f4f92e0781be98b7ace76f13836b2a36d32fd0df3f22cebbddeb59499230d0fe0b349a31ae511ef0f9444a38b08f1d2f8215b0b192482ce4042121c30573626720fec4a4ae32e3b749d2743bf964302cd4f7d2135d4dfe4f10cf12bc12e18093af35b14daa71f5a0ac8ac6dbc4ac155f816224b471abc1e0f64f62b3bb6ff9284b14f0bd5f44c340a83c95afd6ddd87f58d80c11a51ad3448c6d6c9b57c78da0ea0bd7480884430d76ab885a5b32bfda6a40ea353b9c5b53f5af176987b1e477e1ec433597ba46ad7b535036b3248afa33cabe4f7601ed721778cfd285eaf29157f7d2d11fb5a70072910bcf5b33b1b810297d391e59a5dda4a0a0838d2344f256fd1fbf6ad06d8c14d035c65734cb5723f7470f6d2ec9075d704a3f720668abd52b4faebb5d70e3e64a3ff0d8c71c0ffcd3b496fa1e79e8f0e1c0a35c93d720d45456ee07125fbe7bf961a10a6806bfabea2e131496232f2660390063b93062fdcf5b46541f4d6029862ef64e7d5dd1f8e506a2740a6a7c38aca4ebf716cc3961cdefba6a6c545ea96cf3e893e5d3c94199819d1043e78335d3d561c51bfca96b58f06d4126aad61e527e3045f6ae6b8b6f9c7b528665b0369ee18c4fb601388e3c4543b224ee85f3a8e8ef3971da913d19b5d1309889c6f7a716944c34653895ded0321a44cef064e11469f1fa0333bf6154b220681d09510d3ff8806d2b88bccd090f0a40cecb7e667c253079110868ad6a5bd54f4a36cff00d96bbb48ca9c3d9d72663b96e5a626c65bb17cb3d2dd2bbf93a258f55e9c0081279be583d2676eaa04a47510b51794f7061e9ef377d04704bc69a091b0296e95c336625388d43dd7b8bf9accccefe3d0c6a02b9dcc3a2e7ddfc2fb88cf2129186849990e1d4269597dc5c7f6ba67f512502ba788b84fc4b982ee8ff9c72c6e97e9ac60ccada01359d8fdb7e2c7b4a2e4eb55a2486f82c8e8b4dc4b2a39c7936bbe905dc3d85981226f91a868ae431e10175d8342ec25fe41610dda7ef9a7f598901f54721b91c9f3e95cd80a577e9313dfd095fff551b95d2623d1249c6e08702c5dac4dd951e2635ed132110e5bb9eaeec91814a2fd40b93b6cef2e6ef7b2176d66f0556b94c942ecff48538862839a783e6deb26f8457c4bd407db16f87f5f5db6bd4fc8dde141ed2dd0c454d679f897939f9f010e8ba93235c1910b302d3b0497a8f696d1594ac13d8c6e1a4415b49df7fb190d82f806b03441ad01a5269e58979911d0e6b3926f3f000fa2db57dbb65824c74a33d168eb2b166ba4fe08933c4eceb0e620ea4321f23cd0846966f9018ba4d0490c2881c9b92d0ff44167afa864145a8f552d9039d3a75a787936aabd75859ef39668c05ca952631b05310e507a22ed0e4b649c33b4852d94f38b0d70d99ff49d48e87aada9477bcfd63798de8a234f5fd605df5ca0fc05cb56f4e21ef587e8305426f6cfecd06a03f4eb299ad71d662c6e04744c650f3d48eb0e2b8e1f2b100b402893627210d25485587df480bbf2a1f9a6b05d8d30e37457ecb6363b8f1cdde01ef1a29a90ac071c3249954e4641d6b768f8f9e6d24abf327f8fafd110466abec5a2b94e5aefd6ae03ceb3c42387f04d0249212af838a7932942008adcec31d3198521c5a12b7b0a75b68a926c9bcfbb9b69729c9fdd493038bee95f7646760653411a56f6f6ee4e7416a85e47bdbebaf9fd97f4c33721366c7df1312f0f2b2438cb623b29217427f85639937cb31be22a47e083172bf4c0e968069aec30bc01c413188a6be26295ce327612a53459ca692b0fa9c91a1d508a39ec7e7f64336c484c68dc05e5c503098c00aa7dd4a196687aa6fa877fca4e342efa7e013402a8bd7d4adb2c07dfd7b88c718c47483e92b3594d4345c101a3a2744ed242b91d12e48989cc3cfaf78ffc7113e70dc14f84a0cc6e2881cc6151abf13fb36ccc96df6e9b47b130cec575c7b5d3cb021dddcdf2df769a0b15d39952914c04167d5dd4728c13d88392f0edeccd1c4656512353c4e01faea7ffea23758dff25bcffe112d8f6ffca24f385b6b3564f48e3782443fb6e45f4fd08343a4ac61595f7ccf0fa2071bf7266c100a21233dac4939f8ed37df94b3dfbd5cb603245fe71182d69334029b6cf72623446e0b0d10618e1725c3a8680c9f8026805ca4cf4383bd8d28906f7adcbb658b3a57ccb46efc3d1128ed00828a119b530a5a21c23cae48106847aa87fd7b76fc35ebb161e2cdb8c0a1885cd3cf5c283db9b08037bd5998cab231ef080f9030c4b24157e537d4be7ae591727f1893a90355d679244af7e72aee15b3e3cede58d733f66099ac0b78399e4a498567e87b8d9d0a9104548d11fe40a2ffdec094e555391be4374d87760ec85dc55e65ff02afe3602e7db1e3edbcfac4cc088e6855f2e253ace6b52284e3ef55b33fdb789801aaf6490806469865963bfd8351688acc912095f1e9a21662dc4a7a0a13bd14fa6b831cc78e3500e9a2fdabe2a407fb76ae182b998bb751e799ee57bbe50b2516b072a354884ee2afdb41b84f957d07e93686dd8de60b9e39740100fcfc757d01a9ca7c1084d4758ea2888240071eeba7f9e8aced51994ceb9da134615b51dc67f1cd29f20b11eb31a7024b9020b8e798f85483a7f02f55908060290540f61b37a49111b68601a92fdcc382192782212df998d191c46e2d2b57854f6388cce9449359f65226a87bdbe98201cd36934578e83bc98e19abe1b025f6e928ce90b91e2eca2f57241da269621bb4b8ad9072f59df733a18d853a67b8bcb049764278afb86d5a168ec74c164571c63c012f85e7afb3ebb44bb7f38010a4681b671bffbb7416c76302e0466fcd89ad93a01e8ff4a078fafa899501012b977db62a3e0e2d4aec4a2a8bae0b8c72132cf71af1bbd3b45e5e76f2e8fae8bffea98139a849e0178849b7fc53c107f277197837167d3684c21e6c5c77eaacb25c44ebfe88435d6ebf6b9a3e0aa909572ecf11d51bd5a132d40b21bdbe3b227b9485a89dbb051876e41874ba5ce52dd0f8d5ce90ca9f802bcf626bef9b1b28e4226e1aaa32dc282fafe9b19ca742ee3049d6cb1138f7c52949c9de64557dd8699a4cab69d1ff5de9eeb352e8942c3e33ff2b91925e9dc5f8ca2875d72271980206d41c80c1f8b61ea683b9db621dd0c32c4a8a233a5000c0e2e38885a5b6c01064f27091e821428d89a54129502770ca32709e1760a49ecc9279ab124a43d6d513e703fa34294067c8d503213d03ba46894c6a96c4628cad5157a86df18a12fd5cf6a06d4051fcd463e9279d6398037c325128b2a83ad6dc5d2b2ecaebf572eb727f88449de44a766b6b9e5a40eec2238a427d3970034d4926133b5391e8c3556c6f70e9247b6cfaefc5d985d658ea88ca80140234e28ca73c9b7c3a8728ff3ed3baa2d71624974ce530dc1b8cf1e928b85b6b51a475fc6edb5512858c2ff465451e885df20c3f16d2ba3e65202687401266d2f277fcf13233c82049edfe9c63c03a081884acb18094574d7662943f0e884e434998d837fbcf2e74fbd9b31b1a6578e17a16c8da7e43c257cffa1418128f19f776ab4eabd738f0fe27d6e7be94fe0b58926ebc8bf8e04a8c81350da60093380407e7dc9a38363d6149f7a0dfc386d53adff2b164e74aa939654a168f8307d88038c53110565190ee44d9beac9ed60d864f1042944e4c9b41897708317636d53c2c2ed326dd6a2cac128370fc08324c696236d2b6a730539c53697f3aee34a23819addc26a4e6e12ae8936fabd7f2f239955353604fb7c2cbcd66dbeeb529176529ef8150108b67724163be5c0d3fb51eae22fd335ab01b53fe808a5186587c90f6b3cfc885c2e297766e4e951fbecab45c5fe56e3d416608df948d473217d4d01b89e33abf92f556f0fc1b3be886128a0d13a0556852b1a3db5c42fbf45933bdb0efb2875eae111aae136a4b818b09da19b026923ccd8401bb0238f65c679f44d85159e93e0f146116d828bc8b6566a689f9e6c9bb3a66be8c615c235a7c81efc62c10a7c061032227d4474446539077e63d501b0c5e8ea1cfa79bd48b3d6fb1377534f9bb1e81210b30c1e603074c1863d72adb2080ee944bf46f589d39334583d7fdf4de1e7f78640cb84e91121d18dfa682b0c66c9e7bfb04818b554f31f8970a1742a7e55fe5add75c94064f0f812dc5e47100e4c18f26d2713a52dfb348e7e7073ecda9b1b009a423e624fe4f18f6835dedceb30bc38416a7a4ec1710a9da0f517ea5248d9d2fe097a157fea7e8a1c7ec93913a71c521381ebce27fb5ff8a3242ed5de57dca6e08b7a441054431b01923bf90100ff1fea6a86fdf6a90298f55aca5aee937a0687d86431c11bd0dcbbf90b4dd18b5a12e4b3872f63195d691d3d94e2ba72d58d3fa1a6ffe6519046fea3ef92f1c81c4a268085af20295863b00b575eb23e0cfaca70b79547f1e52704c0b4298dee295e1493c61fa16832443d258801a1d0fcbc77a677c55afdc3a04d17a680a39b5a41b89d6c93e090746f3751d25b2996bded1203645f5a47fbbabe88e0d9c5af85cf65661462ca42694fe756fbd4add2bf4cac316db60ba22675b38f2ddfc9b775502135d473012837237d33fabc9e8aa3ac8f332309f2ba2da8f59bca7dde76e7015dd40f2478f7ebc623bab1a022c7ada6be1003415caa934165f6052437a175c347a898fea819641000e7fcd6ad5da6dccf2d38a467dad1718c9a1342afe376e28a13677046cddda109843e0241f88719fe64face31dafccd5459065e23266dadafaa4775eef3a35faf5164499e700effdcd71350c5a0ab1d9b1c2475df7239277e4fbfa1ee2f954f29435f531e62372eae711b18105877358162c9f64940e9e44fa61aa379f2851f49f641e87996a96b010468972a6a3e1f376f8f8e5c290e266970d547116d77e5cb2d9ad73dd6b8a4a62f6bf0b1bf10b40103243fb96da69a25379dd8b58b17f9bfdf653d2457ec880ec483f17bae9fd42e0dd5b2c73286b24deb10aa5bf3b0fdfacfdbfdb1cfa2ca4bdfdc45359d66fa5a3af63b576d714d37485442074f9acbbf1ea5289ae5a9d13f2e31c40bdeca1c1e5d06b7009d7b786e9690fac64c9401b1f6ced64bf1d64a6424c1805a12a2abe9c049b77ebcb86c0000b3414bc694a5d792b259974df52444b2e2bb671c6e9bb0a764c03985e5d25d7b1a32aff588bbb6c3e1c1a028cea95f8b0d780726406fe589a1158ad39fb5c0ed8c0c5177713b30ed0db3c4b675a4471e6f56901ebbab8168216076b2257f9f34cefcc2be375a2523fbeae2031c1a32f9fdc8dfadc9826a3659f78b7c9f44aa1fce54eb07356cf3e631380773dfcf2b4dd53006bb46b095ab377d24f7c3736ea1f4a6865d5ac66092191420d6da259f65d45f6905f66d12d44d7460819c0c6d6a9c932aba8027dd0ac880a75d8f91acf2b528ca5ee3192f086819f39fd3e731681fbf8704990e515192c6c7d320ce9ab2dc11ba4f7db6828e73bc0755f61ec760fe3fcbcd97ffd19fc1e5364ae38e82f8a2601edab0904de4de25bffe56e68c79e622fc6385e68678b0d2826bd7e3af84490a7a28ca59e93c85ddcff7b879fd7c4318e4c9a8161fa33c51a419cd68926b496a6106e246fa685f0d9848a33b069832c86bd83f540a91b15e20e7e4c4b8a5f0294b47961072490cf177fef6392220fd764","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
