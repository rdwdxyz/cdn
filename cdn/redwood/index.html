<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3776b5e112880885f04cd1cbfb549faa74fe0bdb89a95a34dd4c8aeda92fd924703d3e16013547160d61d1d7847c332b5a3fc6b3f7c53be74af68ef903bdee0c5a5d67f26d5b1a7b014e5f22852af81378002b92e642e0925adaadf82aa159b5ed68be175698281a4121f32fbfcd3ded48815a8c27a1ea30a85c65a6b11ffe76c5888a5162cc8271f3e03ec69d4a17635e4d01bd8b3b7564090e8765686f933682cc4e8909cb4e902649afa87c59165241579fbd75a7f2def72e44fd76e05efa3c6317970314d47d5f5cbb54af37eb3d80a18b918d8fb6403a9f4b0228ddec8655d24534be07ef3ac38565cde9d613f641ab71c2d452dcb04f5db996b06a498b9f5a167f27290a64d611b3cdf6545d3b9b01ce175513e69ded2f4b60a5b1e398661a5ed231c9c14ad80cc9aefffd4b3f196bbeb8527b0ec1419551d507e352cea6fa35cf3dd7b3499ff189a88b50ab186a20f8f7418969b9e00c9eaae19bd10e56ee5a809bf721e00760194abaec7fa881c5daa571e39fe6a4a50ebf9542d322e1cd09e9a885d06161cd424646a79aab26491baa25673d32bd2bfc216cbacd6ff42ef44c2cd1dd558f03f431e115b6df45d8c81486cbcbf043e820aae5d74f215a601c6c3edbf2d1d3d4370f09079da10f231a75e7998204f048edec53749c88a252d3f3f76f170bfb9941a4ddbe4561b61f61e9e19fe756a5c16b6a41866e828b5ac00ebff2da3964a78e9c4f703373d3cabd29c7dd34963429957ea069543d66befe9f59fe1e22627f9868b557aa693c5e360ef38b39a7b7b9dc6bb548a9caf2b188244da3827fac8ba1fd2b232d6c263c14d9743f9f4d50bdefdb6d4ec136062a780fc4984d38cf1c4f0de088032ffa34bda99542b438eb5cb1ae4550738dda876d65813a43ad48ace0ff5787e22e8b80f92db045bbc69adbc0f5f583bfdc1c7317acea65648a97b699f1c22002afe816eb7c630720f4d79e61fb50cecec0e0bfea8ff1d39e2f7be80ee05cd99cdf139fe41683a2817114d087acb063668c40739582dc17972b59460bd7fbe07dde3651851f557f2150b78483b038b2d96b8aeac98a9def633821dc1928d8876e9778c0b58ab3d06d4a58d30af263aaee6f1bc03a89001c4bc2380a6656a4411c15e417484f73536fec78e1df12ae32f8f19461e9dc22241145131f2cdae1a48aa07d593febabfaec494170cd7b68315a2933d5f31727988f235eefa7b2a6aef972ce0597f0f6e55d5bba452c88c83838c2db1e91429e0313a00cc3bf503f67759b59f8f2dbd1d7882497d39aa79455e0f4f1f6d7577a3c006bee67bc8785afcc998ef9a30d42f5641726d5b1edfaf8bdb9e33c60b2f6db140be12feaf69a5f069ad187bd2046ef2463c6debf536c035f5a8d077c3bc4ad14b4990490a71a885b8a9fc35a9fb82d38983be91978687a95dac5bc6038695343cf361b7dbaf7e25aa564b4edc7d5c3b331d49b4ad1533dadf7cd4b35386d38028efbb8d633dd464ed8254157d2df28f250ed88d31884956f74687c149237a576f90f27f7a206e68976fd7962265cdb7e580d0b6db951d3948ca1f4b75cb98163015aa3905e99e836fff4beb7ae1f3a4af044438b5a7b28b372afc649558dc4fa6f24725cba263a4d310634e18502ac8681e8470d1d2078a0f692c7689028b3dd4716b2d385a265ee678c55d054c391195c50f3f31dde0ed3cd23608868147f01aa978a8147ce5866d34cddbd8e23ba81465aad60ab6d8241a305602d98ce848b8df86e5cc717f0f278721b05b7773034d76488e166ece83b4ade9c7159744f041d553804c843953b57e30102d5dd11daac1242b019cc5d661df8cd29f73dab24c9f9ac1cf609f8a271e0acdd078057fbcc79fc091a207b9fe7614371023d2c77536be7df549c1d8cd935efc485dec6605c90a9437ff1b8d07379ba9f1149a877df743f5a8a51883b9562ad97110e25b31d34121046c050d4f0b30af92de8267497f9052d58abb46296b7ed100821efa3f2f1ce1e557736f3c2f7e532f557487161aac8608135a86dee4fbe25cd7a79aa94ee959c8baf5048d6872900e0710e6b29a07d0a041c30e5172ea10aa8e94056d0d937e143b6f98d6f535e27309108300aab1ff9175abc66106e013d44f6a3caee35b31c603e8eba73e9c532d79cdf91c74f90f0f6779a414c78091f975d5b4fbdd4f2bd3b65413540e64077f1456254ea4fd5d65efe5a71178263374a78bbc7f09ed00758e9ed8e78688c4a8e32f0b40caea5046bf5bc455d2e87f3bc515ce94871a97e8ac7a2c33f9ce71a87ea77a0f8e8e511eb2324c1b6b8eb5669099ee9e225a3cb8f7cbbf83b6f87cc5f9d529010707650d85826009611de180bab91a3f63e0fbf39d654911d7e4c0c30e8d5a73022d61101893e01eb8fb9b98d2763b1995eea5ca1b7d9b6ced41060c5e34956a41e52a336f088b2bc9c35380d30420aaf64a388622fca4b41a7ef44e9c690398ee590799344debd57c3b7b3d5912cc01822981ec9f126054d55d1c981d21c2257caeb897d5e4c9fed60a6a82b85269a4271eee92720abe2e5b8678d709715886a14873700f46adf0b0c65dff9d13d924f56c94cabab6014ab8bb97ed6941b96c1f66c0c640f81cbbfd938cd9147351e3d4c1d65a84fe50ba9509dedaff881d37bf0c21911ba3445abe20a133e3f6ee0bf5f496c089b6bae0cc6d5b9b7677f5f1878f65d2ee01d35f21c32c827ddd2c67e4d4dc879969f62e50741ef398548a4844472d1b25c70deaf061ab04d9fac87c2fbcba8cf2a6841bf44d0f182af82af569206249e868ce62908f068d908fb4ad204fab6b0b8cdb1428e048d2490aebdeae9e388dc73bce0c03902279ab70cda15840fb9944b9d942b3bbc6378fbd4c290b6e74847d0e0c85faf609956b50f42506754a81d06e3f2f985474b6afb07e794fef9ebaae9ce7c271ce04903eecefe70f42bf5eff3f8db3997adf24dc86088a63db03d5490836a02108df23cfd195b773a95f1dd41d5c3568d6b68d5f1ab51f0f9bc2e4367b00fa75c8d296d2ba98810791bf2a6b34c295dc5e474abd1f3311d6a246b646d85f8eea67a70c00dc320b045d54b3e0a401c952be9a000e3db2af80cd6e02e63580e9983c1b0e5f4ef124b66360cb931dbd4694eff7c356187dbb9bf378f1088e11da86fce1482f0eff8d11e7b09b6dea5598d37db190643f7b8ff344cbd6ba657bf6404af539aef770c07ff9655bb399897689ea31cd51270a609e8c89349524fdbceb7f02ebb188f5ef407f7ff9f9f9988aed0baebf9337d508f40aaf0ff515260b28fd71a973ce163e76010f72d8cac855808af941b7d14fc848f4584168eb1bade1aea3c3606deef132ef43cb412b79dd2c5dd747a7eddb6cee1bf260fd6c488f554f123b830a7b713d2d70a7f3a4a07dcffaa529ca6cb654a8ac429ea932dd2a7b20c0c9df117cfab1861172f70adec02601cae12d7b71b60926c9f8cee80229f789e1bccdf6b23636f701cbdcd6a518e59602e43c072547829e72e6b91ecf3e863f4eca52993ed0736f7a7ee69b6bbdff7191020638cb65581b0b0246791a0f409529b5a8dcecf2069ad63dd79f877d11d48c120ae6ad17566dfdff4ce4672685b050630ea5fba89176f1a408967f322d10cdf95b07a771e9af72e5f60c7179428ee0c8f2a9b274f6f50dde86095144e49eafbddf766eddd247a8f7f881dffd29216eba3f9bcd3a2e1bdb874d5eec1887021723bf8a7551b019ced79b28afe4ed6345d2e5255b93113c37443d205171b915c440e4b5441b6c783bdc7b713bf177db49e6d5384701c048e731cb826a9103065b6a6c258fb588243570c6c63c806b7c2f92afbb3fcd754d9c7c550a2d3b86a80f8a236ffd82b80b7f041a388d37b2db7c10016ad53e95f695767c683e4ce1224b9662887e0d675fcadb85e73958b9ebf133091ff948d9ddbe543d124347d308f83bc718990c85823c350ba126e5c4b5b356947a6a5e67d819e54122c3ed20d1ec607dfd853a493f4243aad929e9e2d88944db1f5463f15a46cc6ab2bddfe4dcf3bc94073ef72756bd57ee3e555aacfeda362d6f970e0d1b58e875b66a774f686f47751b4c2b658df0f8b372880d6d1de4ccc8e5be094d3cddac3d72afd903bf961cea53d8d3f95d20f1e88be6d41a4b4ccf9d0b7021c84bb4bcd02b3ef580e5360d080206316eaafd5503415c336e0e08d2c83f0e52871c655bbbf95d661ee1f290498da7f3a108545f6b702196749cc22184103f4fd42163e7c8b99dfeca84d0245bc279931523d058ae1e2dbd53ccc59fc5fe9bc8bdf013abbab3b4b477d82b81294032619975b6760797fbaa23e9ad1a19258b1c2ca603e610f2e1c2bd19472fdf046f4d2664e7f9b33d600a551842d7d7a5dbcc2ca8538f4df145ff85f4996b53de4ce90d3f9eebe8c068806bf23a4a342365827ccd6ba0feedda00d31c396caf8720be49333bfc9c5331d735ac86b7169a3b97aa37f00cc3be936ab96e17a8878f011377421df41ef4498ada305884a163471bf8c99576e4298f66b1eb0cb27664fa963baf57c0ea9b89269419f0b5b0543d2d7c963fbd72983cf45cacf17b790f2c36328d1a163b597c990fc05be8f430652288880ea779a3d4bf9c29d666e8cc28bb067541043d75800958ede85fec63086925fa4df9dffefd30dcadd6d211ddd2c6b37b7f42503b70b28c56cd19d5771911261382dfae3b08b5dceebeda041d225e1eac09154b998d602a51ead82ab8afc45d35bcdef22873b3ad4c9981a2eb1d6c72fa3076d326a489635f45b1b9de6cb35933028fb143beb0dd9b3f3d52911110f4f8e559e334e8b3e7f85b91e24037326dc69b194c183f0493d9b61103d325943c806134fc2320ae07a80e80c5dd9f33ab9c1fb71c61cf9299c9e274d6d0ba02f417e6917fe38c16de35dda09aa43a3bb7477365f9e3148875f27d382d3998cfd7dfa0e93670aad903f621bc8291c373a836c39d88feddec9d472dd0a5549425733d76ced6526619c6117227f775e5f9fb13f959a7dd3444384079e4de2b72c997e2bde95fd28c4e11fc658049bed2dcd6de560f913590127cdaf821061269352b61860bf374ad04c2cee1da9b16e87339855dd047ca1bd0889ff76489077fa3425e4357636d8d8b7995c48ad9b279da6b04b3084364153530f7ef6b534d5e05041df67f622b192063b937802f6678c6d1f75c53f2e1578fac0254d96d19fde042764297b7fdee6302be4e6e0b9ace58625c0f121f3bfc1d4ea35dc90c32eec14155ba0abaf172f7fc33531a10cf41b3b5f47c32f08c23934f12b1fa7ac8bfb0fb07d11e3e62519868dafaff2c48ab33e9760e7f8aaa21a0f8041a796106e3932578d5e220d310665284994236e88ac88e368a504087fc75ba7ce61776ddf80decffb7136cb3e1aa050f466a3babf3a2ced2aa644eff66b8ba7be75610022869efee869d94bb06b770ac11f9f519a76358f00970ab72c57c4e53b7412397a458e46852ab724576ce6a93f0466573bb8aa75db2d140033661d6ffa5327d7724bbb6b978cd41a882ee535373bfc1512c83c84a3c89eb9df9978b15b07ee309925dbe64a9b9078fac8e3b441630dc8634ebc2225a5f42b14d6bb0e59ba4080d143b866c731e459bcbef5b889fb3cbb7e6a2bcace22272ed6133b35605bcad0b904a52c1a6448d05830e7a0179400ee03236fea85caa4f4f59cc6e8c4129dc1c32b7dfe92312d2cef4cdec9a90d77d9dd8c62f394b6ec87720ffcaab4b093d66c07c04b8433078e5ff2c6e7bb9c01abf231f98c7f62e21e6f90781664b7c62d16942f277bd6b2b100087b76683c909edeffdc720c4f81887500ab14bb01f0b48a348783acdde6ba3033a9ddf9a33783d8fd758097d2a2e854858cf33d8639e1f98da05ce5756e737ab13c11c3f4bd801a53c02c8c3d944d5cdfbed0d9e7b0e34aed50b5476d3dd0411fb99c7dc6008dfde1c59489a7d7c35e96b4b02d18d04549fee72114295750b01fc7b25b9d32befa018147ada36d0980d9ed7e7eae7d5c7e335420a0340a2a5b0364f9086d0e019436e455acf1a51f8eaaf02cb997569c8faf63aa576d92f7ace7cb942ed8344fabb168b69a5474a4535da342f03c592e61597b98a96b3153cd0e4b577c5e3f2ff9a052332f4194aeed7a18341e413117a8b7a824ff7fbeeebb645d4178f661c0ffbb27f708030983500da12a586b17bfe993a178519bde9146c5ca9b29cefd885a6511e55604165a1796b2662ea77d916f0f89c59018a74e7613f09401d311dd13344fdd1567738be9a1389735fd5b6a643dc72fea3c4d92e4108fd191c0a824b70f51ceb6328ea9c321eed4cdd1a450048636068d5a8093f738830b81d7be22d2857dafcbe72e7d18b455b441501ac63d35edd35ae18ccca7888aac05328e48e41891f4634074d4fb97d75662fe067977dde7e01aaccf0dafe1effbdb5f9363d48c3069c1961fd40f8990026f97eb14402ad5372e6f36394773ab523685894747a455face2c33797c06c572fd1f1fedd4bbcbf715a361bcce5e618f5470cf7c0786c642f9bbbe487f48f06c7e472a49ac22f0df06eee934164f11e119f1d6ded6b98e06a1b39abfed53073717901ed6264faa011480d3e902debff43f5aadc62648def44029ad6cbca07df126bc6772e7f40dc7d405320b61d907c305393e058f33a3e6aa0c1ad04f3bb6269e75c659ec58fc7bfb537489140c5e72ccd0d45191c033a59ac82b9908ab7134eacaef8eac7e7a145b6b2dcc5243b1670d145c00b80a80a947a23ab284748d5f5c508b6bc61012a9a696f0b48236db2800ed0df015feeb629897e96ce63c5410b3ff9d67fc8d0e5c18b32793c6e84a6e25ab2a34bf60586c46906e7a643a5e2dcc2c96a597ed342a544a79e4eb59797e451130c06abf6791df17ac77343fe3eafc06a1a16e0144051046cf66d3e67c682a5fc716626b5a1de91374fec88f6166f52398fe6db06d4058a348b64cdbb3f50ab755a7b61dad1eb7f9d54b7ecff3803c1a0325bffd92f7b4e8c5ca30544acfd594dc8ce73d9cb85c55ec316d1ef1e38c1ab2383b4bf5de4b96fa9697115812d473482e7091b661567ead9c4a4a174d0e59eedf2bf422a9f32b620150f8879063271a47f9955fe50579ef3fabb62860a5d009bbc2093a8e9d47be4c8031b32a223b7134e759f6609e16ed55f1753cd43338e1a731db8d7639eeac107b68e9c8fbd548930ea1c3eaf81b824a8c71af2fad8605b1a5b2e1abd0c6201c7d96e97fed67eec14a77ad14938b9470a1628bc8e2105cbf798e65e4f5a69df6399af4975697de74db1c0cdd6e84906fafff4125e9451d2275e08a79dfe6ec647f0423df044ee67615600be94095c38690ef208fac5d0359bcdb69f3624de5f6b1469a68082a3c85971dfce87bec4c2765f88fc0cc639fa7072f0482cecdb3aebdf3f89e3c0ded8c312958404667de78cb221c77bb2d7799d994567271eba4d3aba6616d92a7e7adf68c4cfe7d551384d814fd8bdce77bea60398dddb8438e5ebd4149080163ac6e6210261e96af26d8deaa86aae9e108c8e6e36e1ba7a6de76593ead8a8494329f4259530587e1507a4c745962bec104e448c31e3e0a545d332f69415aec28eed8570200a5da177937741e5c02ed6faea447e546920697d6bfa2c099d6de13318dd371debfc922bb8f4e1f07b9417d25dd661b800699d151a7e01a95020d7f6151e015ad8a1c21eacbda6820ec1e248b59adb56d061dd7f1b96fef2881450053ccc7c0b6ddba7ecaa5c49b4fe41d4064093eaca3bcb7c96893334ca533b3b46eb39f7a1abef9c33bdfd644e66322db87ca0e88ead74126d712347753139c2acfe37894786cafb6f18ad7d90cd3941e00ccde27d71e8948f9955ac488afef75c28b65debe587b0b6133e72ccc990fc1df3651de3d0a2d4c68b4ac201fd8b0032bcdff70e2bde097214e28f0a91911ad6c4eee1653b7217e3672e0b03809cdeb163d0e39de28c5e7104dacb5ccdb578553894b7f88094e968569f6faae7362f418bb2afbf106764f04c499d243abe86f806a9faf5ae8399c4f3a28afea1f6bc8dfad7af607bd63bfd7300ed58e6d6760dced311582ae1d12b903a8718926b23943354e74d8f99570b51d9ccdf494c4f29b1464b1db906121cb84f5c2b2c0e7292a098cdcd94c70a193191a06eaba40d7ce04aa1cfd745d237154df359b7a08deaebae941d778dfd837e996b7a2c920a5d866985600eeb7ef862d397a7dbdba830d7edd8758393342f0935164ac164b568fc14d8ce01747e820ebf822d372453bbf28046caf003e08d3f7771946964d969feb479e10ad19c7599c680213eab63e2e959023d363135596b898ee822dae982e8fdaa01fa5b34cc7fca16c5f94a7bd6b02c4e3e97b4f4617686adac0531f77750f3abffb3dfe6325387b6c68930dcbc7569e9462ebd90d7330a2c8fe46e4047f99b0ab461516a337be554596c2fd0bbdcf0140d4908a7e527298c44bbf14063167f81c7b79188ab906835b4dd8bff322a4efc58945cdb8357b4970867003af80482f2721b2af867e20786cf27d028045a8cdbb496dcda0f7c1f31d5b675182690fabf24950521ae930df3205346f0ff6004479d6de23172670f8b8f7797c81265376d9bb95aa2a434f152b2889f611e90c278a4c313c75af2dafeb35780d3aa885b3f973aeae1b57ca40ceea1ef6188627a2e8cf2ea8ec8d1d600d2ff504cd7ecca114977b8634ea1105477245beaa06e4be19f780bfc508093c5afed771527abfde51ca4111815a13ec0881dba4e7fb1f5eec0080a5f754a45fccee71ad0e6ed00ce7e29e37bd44c3255c4b3a9ab9bd8f594c14aa9889762b36d51800dd84ea6ad1da94cf79a6269fc65149f4d00e48e9f5b0925c57a34b794a930a774236e5721789755c25be95d58d83f4a16764aa43e57ef39571104643c1397d8694dd977ecd1f0d3d0401d76d6d2aaf63aa2fe77699dfc23cb34d8c15a9bf590b1242a4a82bbe780c0b32ca2e25c016c112227244d6e3d5acc05616f0417857a9f28e3e1879d5fe3e0e964571dc62b76aa958ffa2563cc427049d4d5e308a15cc43370c524162a8cd422312a7a769dc49e80225e9e55118c98b1b16cd2615c221522c17105eb7c473d088f74cb26f345521672fca734139a4a9a4ecd9ed27a711f8b54d19df945115c0349b98e51f250ac2ae7c489999b904e470efdf1b91fb0b157b6c171df6c7c9245105631ba4cf7be83c204e88b6fa7fe6ea000aee6f4669bacd6e5c18094f1057e35a5116c598b9827e830fd7d19b6081b044614891a914806c192d83ce170d216b7b4cb0d7c3f0b7e603e5988787754c5b7ce17f269cf4378e2c78a48ce59532063ae0aabaf449311a5cfd8a2b54bb2aa73cdd9b0e3dc9b0ca648c024fb6d4d145dd569211a30f10ca82f52bd4af1346086c779eff47b0d2a8a872c01597084254e9d836378e8f607c8106a0cb8baaa9b513ef0621cce6622093f7ed18f0a5c336eb71f4c9982c83fd24dd285a8e0fb1096b0aa8c6e7d0423879657a1ed7a5a68c827adbe27ae7e7ac0927489d9053b53ed001400b349dc097bdebd16542b260824a3710d988e79bf86480dcfc40f92601179beed996aef9899a811953b34b37f743175d5723d17999cd1d8626ff064f812987c961af26d982c878b4edecf01339f2ebb4865f4ad7918d02151b673d291241ac294c598be99882dbb84740d620f275f3789c3be5872a127ae6aef36bdd088e7958a06e58fd5671b087c351515884486a8d4bb589a24bfb6f0a3556a56578c94d561495f326e253cb58f5b18aa7ca571f635b6d3cea7d67c707229d8a06360c7c5519477bc1f067803b7d16b7f253cd66f9889f25b4325a9ac83db55a09f0540eedce37446a8fe84d8ce4b7c38dd736f8085925c2e2d19e95cd2c08fb4d8c0d478ba1b4334bcdd583ee1dd784d00d3850d3ad7d6f59fc1a0fdf808cd6390d7c8555a8f89d0eb9ae8eb85ad031a3e9113a6c6982979f680d1e1dc1f678a738aa33ef870d73ce728e4d6ce6391ac55687b06f1cf4c1bcce71aff47a39eaa9ac677a7d224b2c95004fa6827a7e58a6e56ea252ffd98a9c03b6c0bc0bf49834464d638fa0fd2a9b9af08fb907b74991306a91a109c228ef10e498f26eddcf2cf89d3b6cb0fb89b6e97fdb71479172f844c0114e398ef702aef9b6fdf496336638bfd6f24f3ef8843df998dcd4fc1c168f0ca67679a237628d6eb7332cdf1264c2f7dc6b6b85950dbc57fe289abc72879b8ddad9a5c4fef204097db490ad838f2489ee78c829ad757ede529f3309466aa3a2c052430c62af9eca44f8b17d2c2a39738ca3b0fd187f7396401f0c738ae7c490cd975211fed77e6e5bb0298e7e968bfb182fe6b0f5efecc2580ff0c08991f10402d3712cd8d9764ff1fc8f9c816ee676c972f55301d824c2048a14ea9196199fc27a2c2cf066998d89334df371c425debc4eead375bbf13ead60dadac7c67e2125066f490b229106218e32312969edf8e4b6956bfcc58fa31935c6d6241465d271a24fb5180e391a07d8849fccd3bc10ae497255463b11dba8367f8ff0e0082f2466cc0af76d0475631850c47a5d0ca1e4ad3a5167e20f67cff435e8f58c25d4d2d04073f5b3c452645da8a53420ebd31b0badf6a512186ddcd2cbd348bfdb6ef7d24b0eeeb7f0e87a338053d91799fd8719d3a34ac4cd5cafda19f13f79f519bc88fa20193a501bd4fee2e45b1a1ccc2b3e5e7515e9e621dbc9ecaf29be344647ecf026f7db64d3fd826b24ac078e53ed592d898d7f0b527dbae1298f6a55cc2aff80d858ffeff87fad3683eb902d88c992cb5856ee5193a995b04ad5eb2323a79f2623a9df664516803ded2e177e4de0717a06f49d3645c1bfef31ae3f92d1190621dbc7c220a1967ec16c28c99a708ae506feea57b91ddb8e45f34e6813a60efe5c940878b5618c1eb79d3861252493f43e503149bcea91a88724cfb752f1e510ff6499d941714c7d7fc2eb5d0f4ccf22451dfdf0260b78be1f0b2f8053ec015c8bddd1a13a0986fe3270e33044581c06f785dc01023371d7b576108456b74aa312728f297bfb05497b4305d4c799733a471a4f20f06c9e2e65794a35f98a46a51b20f3cb277a7bc3017adbb89a48721261ded8c6a32f868a0f0e671dff5e08fde08ce1e48e9c58c0743f07ad6dae21a3af2fa2a24a650a094b9d2e21b48d8ff134fd7106a9d87ea61cc1b84fb88052ad54c48fd4bf5e1a9d1ea7f7e4917ab0481baaea9b77490c42ce6291c442b32126eb6e9211520529adc689ed4736150beb0940c45640f93708f01aaf7d499bfd93094cf1ba7ad85fd1431bb76a1ae025c333b03026ee2dec692872ea89ee11b12f170f47c74bae3d661bb898c594cf5eeb59b2364c03928e68855aa7c60897939d4d99c5abb576b837bf84a473b4220e419ab97d3b74e927651d530b4ae49618f19c4be761a986a07ad40ed775b866569b1d1b0121c73676aa14f87fa30096b608efdc74a84e83b1d30c1300257e8731af4061f96c0be2de5fccdedf07df48c1312cd47d3ee7d0278e675589f5ef3a64e2f46e23666e88faeecb5efad9aea6b36986be92ac4c4a3a75735f55e2b80f3ce638a98e8a27db11b6716e382f1402046aa0ba923e5ce9c342d915ba4bb977e42b89690e1b7d877247ca913aafdffc4feb7166b49ffb608ae38a87bbe91ed09ce9ce882f2f275f726ef7919cf0292d858291695a634b68a81f6a1d8d5c22f8d4378f9a01ac0bccc2931240ea688b21ebf80c80e2d0487f8a01d1185e88892b98a2ac33f8fec6cc0be5e5f4854a6e6cdef641ea6e694eed96885ec8b3d0740346a7ac5866f164e8f8a5cfb831f90a3215608f6b06e43dee4fd7d835513e52a1dc6efc61f7085784558593298495a779f4bb3438fbbc1246c394d0f9c44a3b837f55a82f07ae1e262c9816cf6f4f75a7e954a876787a4f279455b0c6a6fa97b09a3e5ca7cb81e5a0378b6811e7173db9d2fdf0a1c40f021c2002f45f984895ab096b34c473c010a6c1525266881ac6a4c6e96b7ec3961d94885ae312da8956233b3a50d428dd6ae8dad9bb082150ad2bc76789f431e5f357905e9e340a7921635224c16b02943628795e37443aefcdccc14442aa34ece0d6670bc6c83df95c84931fca19dd7c48206fc0bcfca33bd69f2beac7118782a868069e39a7669ea01827f502f17339a9c4dda96c7726ec0ddc4d12080982f7945e77f798edea5e34a3f1896eb8c98da8fbaea05957e076fc283eb11b2a2e0ba4bd349ae2552fe119d8af9ee63b101bc706e467f1d94d16b82044f7254932d55e46cdeef654de73de309e65e32ad46fe00d7136590df72c1be0c3560a0e10aa7174fe52e1abe7031da9e7be10be04928275a4479ac00d119ca0495da4c5b8fe06bba062f8f2ef301ef7f8ab7cd9db9f414e6f29447137d56d45a301a03ef8ad18510f134cbd7a5406c57ec3955a9c2bc1e19cc0acb78de9b2b1ab074ea0ed519c5ae8e6cdf4cb2490c13a7eb7f2f03e06cb2160ac1dd4f6be57b026565c2888c322af3cdf327e7cd5def045fd247ab4cad23167605232ed6698066ddf8f8b58e609aa665c86d9c6d9ea56484742e7c487e357dbd36b5bf5c1a4d8914138806047d722a3202adc50a3ae61dcaf1fa0c1b4921de43abc4b93bcd201185e4b0d80fcd552c2f1da8f09c2060d6edb69f0d7cf40f6f21e64fb1273005ce3a353990b277832289b79b656f6a4e4856f9cb27c08f6de348959f0b7572ec6b8a4b1c36cf04e285bab6cf8aa6bc7f9db06fa91fb3d613c27f33df392e5e5d2597ee12293fd0be61ae2d87f0392685e4aa7db5fb01595133223f1e25a21cc63cd29fd96662475b91e3f6b1af92fdf92d2d8fe0e891645f684f7e7b8b093558a0369ca58e66113fcf9dcb130b2f12cc81efd71bee56624b91a76e020a505b920c90e88129f96c0d9fbcfc7b7b2dd32acc99ac6ded215b582235a61c2149b9a101334877b9f1851daf800a8c4c0b5a19871c37f6ef3775593c376308c870805fa9664e7f46f089739e4783a88a8eff117c64e4099705b853756c3cdd9431ebb46d3055ec9baa41b809236a1d1be0ca268146a58a9b04c7dfde3e710f4a3c638c6ad7ab470b70da7448e31c307d552e28cceea648fe24399f5a2aa9ac7c44c114d6a4247264c9bc36eb6138be6c5c4f0a4973bef43f051a3fb7133a9a141793a5991764c59257fe971069a32789902ec871b7af17fa52e08ad3b461cc13cfa2499de21f390a230a2efb603ae9d3b01ecd72d597f5f23fa1ded709094918a154a1c093a9f766764fd33d3c49fbc048fe977629aa5eafbb071f2a1b6ee20588a15dc1d23e0a87c6165a6b34ca61544b5595fb5e72083bd1b2de290e4d145604ba67c0e90afe0b108a625a8237ce82613c6904d6d6ecbfa84c1ee416e788321bf4d22e0537d1cb69cae455385762453161303c88f31399c2a6e5db56152b8353ac0f5c685f0dd46c9b1d46cab81191e1d753cfee53a1161fb5b8ddbd254a150114dce12a58894ebeb2687686bcebbfd49e74ae219122d77cbb7b29c3680fcc14401b0f24c7a409c1ca3dcbb96e2778aab9c989680f32a0f5be8a988d896f94a5a4179fd5e184006fe62244ecb029cd23a83b56cb62cc3855f05c303d4843c794393a84dd6bdd123d4a5bdd495127940457fb245fb0cf8b5f33ad84ee5a8d3285a19ed214bdfd2e9c6fcdb136d1e2b07cc09ce06d06d894ddb1495cd5451a60209b9e76751916365dde3f5a98a1ca3c9439a226ed191fd93f39abe14bfa9e0be818c859c2481e733d890ea9ef2dd9f757e8dfc7525e545d68877fd684983c55a4b1461f8f5a7e71542ba35ab82c922145f0daa094d484ce1f07757ec78435b9e4ac9e2868abb16fb23141ef8e3626778e900e26ad140eed11f2aed1cc9752e2824c1b9ea347054b4c15bd6b412573c21fbae8f2cf4261c9e5c6791e309919b407425630908733e7cc7923dc1be5503d6438b01ec4c1e7b887d00de6b24af0de969fbd9cd48053564d5743b81052c308377c312a13189854978dc23f50065182abb5dd8db5ea1433dbf0a3b302cef3a9c7ab405dd463dd3c98d5f492d904c68de6b016cfe88123bb079531e4b822a0a479c296cd28e85b4bebc65c6ff2fede95da21129fe97b88e95b886641607ac30eec59aadd0c26b2bdd95ea15a1bf5f97b9fa30117d790eabd3521bbff024b5994fae7673759a0f9a705af10d718754344682b898619abba070d60f5fac83b20258bfb06843418e995a62c32a37e808548f5886c1bf9bc8912bf7165c07cd5af10a6c66d57a001c3ec8b049dc7b0e5a6f95dc86b53334e9b9fd7861afbca3b7750726d2909a7ba800c95a0cd2c46cc3bf7905eba9fa393ba5c40f930a0ddc4281b3cca7e40cd2cd4ba654e393e01a684ca38efa5de129b62b46e32b6c4d36d4c1ce137b9baca749bc1f64a53923ddbb867dccdf213767cfd8520b411667dc0682f3b39b3b32c703f4fbaccb50be618711c3f696df6da70857936a6ee80e8ab31ee0601926ab3709f2133b30be14f4ee9e8eb7ab41cf8e4277e06786c13845b325349ad8c93288ce54484d89b824b90e36d5b8c116bbceb52fff5a485ad96c7d600bfae146283d1c9272c0ee1ffff7559cfcd11b33146ae54ec66426b37086d8c5c7c66654c5897e386a718306b20b3fa8629b75a3c346c26670bc1b50ae22dde8d165b3929f03cae3d5727e1e2aa8f57c04a6df29a5d77e1507185792a1acf89d3e6744fb872b5448ff73e6882a152e63bc42f3c7f03de3f88aa006ce9a2e7a9415dde84ab2ed1955885932eab850c34b9b9d900c13eb4316d61b733a03138ca0d63536b65480c73d7c77efcbd1201846e166f8bf3b5b5400de101c891bd5017c615169208369eda3c95d55a9b15c5cad29c2dca4b978880378ba2c7e97f2e97a595cc651aa1c63189957ad8f555bebce0830b56dc48b2fc45a138f9c24095730e25b30f15d4af90075edae53a796bc069abe281f080bcfe43258a3393f32876ea527556767f3583fef3814dfd7a72d425d1c819fa5e4c2017b2f3a9d584dbd58dd76eb0e6a3038c77d2e5250c0cfd64d30f725ffd326eeca195d65c7222bdf848d30c0d53e3f8b612dad89a994ce18788cd0afad3a29bb49c573ee24b0659d5148cd571221a4702a6634d7458d009e68df5fe5928988add0a51b598e18dd104c7618e37011ae1b92de2111e67a0a48d75e09e3ce810d304524defd21cf133497f07c3f46da245cfbb6452909b3576352a765e72e7d6d4240de86a1546f1597691fc21db121d897a540b60399d1f8a263c432ffb3d4d8a894ea1a7a3ed519707b84a8e88b1337fd35ec8a0be0ce081876db0ce6249a326c6c75ab555c0d13653330760761ae855ab7bf185d85b30c25d68ea6137868c06ff44bab41233cc47b9b6dba64efff59fc8e344681ec82f300c040a26b8d1ae73dc80eba02d813c85879e611fffa7c281042e3342d5f46b13e78ccf88e73a127cd1c7db757574354ffbb1d93041a4c1c51af1459a0a7b222e63f8ae685bf314d400176d2260b17de2a5b583deec23daca9ad72e0a7cf635e2c9b723970b711a72b14c38e19841755a1aa547bc4056fdd404ed184f870212f452a58ec8b27dfb2781dd8fe41d5ccc0c8dd8a38317483b6790538203c1f8b8c5d1e0bd52fac7b057477d4fa20fca237f498ccc54a19bd90b02b13d9c30d888ebad4dae31d1ac1d26cb8ffff8047f3b8c239d540c5ed8f8af08c587bca4a6dba1335fbef76186422ef56bfff2d40e784386409b4b64099893752b7e1a12dc1b84fcd84590fe7a2b0e06755981feccd4e946153879ac4584530a0258a6e7b5289775285f38bbb3de76e5d8823a01fbe86b53c88073bbd2c1a6c42bdbf1baf4f7be286957874d6982232dd7d9184d7fe5b82cabc03111d5a19e8fb5631e9bc6c2ed086f0e1c78220418638b4db5397e72dae8e16c7686dea9b20ebb5cf5cb67922a9f5ae55bdf81b50790acc567a339f46b35304ca788bbc01e714e7556fc13d0cd6beca01605d533e6db3524f03688ad807fd587d9cea28b270a7ca35160ef3e15a1c0a025dc71237e211001205549ae730e01b6d839bd8eb314eae2a6c0c51016160c8d2d28a88269b293393556ea7441b185bbcee4dc216142d2c600c64f41f2376cffc97f9767e9fb5bd3c56ec8290960740555dfb21f1a9fdb68ac3b5d9d4f0842e99c5fe9b67d7e0b9cb1e75194207fd96a40dcb8110bbdd870b27b66b3be85a14eeac7821e714ca84cd6c295ac983741b248b4bf8921b199e4d3e0aa39df8735558cfcf388627595ad6c2ad01948a273d85c04f2e9b4028f2df4923a2ff75f77253b8f691526bc9cf6a2dd14a759eec6ad11e854d7eb8e4ef37559314ab13fd280411d7e6d14f38b9b8fb14d3b18bb29fb353909e88aa1e3c3d5a515b7ce34636c7c593313a21fa94fa584709175196531088a0a407aec4436c8c360f3ffe11e00fec0cc59346aa39263cc06c499909f3469b195a144aa60d7c42f0f91e5a6c9b1305da7cfeddde5daa89874350ccbd14703622b958a06d9797848451cca47c5cb0c7ee0dea1c64e941f945dc776bbebc0d69cfcf993b0948bd3469a9d2ff0a861bbc3db60da9c65d267d0e15f37eeb47dc14b42c47200a2d8ed09360524d4beeb28cbd7a7240a0739f1f2d117deabb729fc92fd508044504e0f238fc5ed837d938c710f96ba1fb35a165a35359422d0e49e6a0db23051f77aab0d6433dd1f8cf95602e91d2a9058bb7735681932186c4a119f2e00ce55228b55f8197a719c4216570bc0d4de49f1336bd0c5530c30db921b796df68d2960e125a5369c77ffaec1fd8219299d56dcab5652c3e4da249184971437dafc5c37780101ca5b0bb86e1ccd8804d21fde8f3f7abb4488e6e41c6e2bf12fd0e424cde040a12b11480f7fea585663709e9d3ad6b070b4b99ccfcb95e2ce11ea305ccd33cea53a545f9c57d1d87c707e3b42ac69f9f74b7e3c4d63b683836753aead4032bb9191cd3ba1d3df4b97f5f43b79edd090a83acedc3c87fcb49a3d5664f0f3952cb493bd645814338b2b105067bd345011594893715ff409627d76c8e893a186352425d342b422526a09a5cb74c8361abc2eae4313b44aa16d2f8b2afb4475b290aab1b9ca0ee2af019623c96c414e3ab064d452ad92d598e4724f8c3e46fef2433ee0dc0c24b7bc8513be95a6bfcbe961209dada3564762fea89a38fec7275c4ff1a348aed9877eba3f2f68cdbc4ebfcbfb853fea09e942729d1b350f4602b3f95cfabd1559c124f88a54d5e5c50cd3d5385fa1f341649828374d817fa77d88213bc13c10a37f70b2269481bd7561258aa9bb1a11538dc656556834a27258741cb802aba6e00ba4042c3325f733117dbf0ccf985524c27d233e5b572ffe2f307a908f8b2fc73ecabaa04531ba609d691e79a9a37fb1b7f8273eb9229e12fa1c746e7c4b668ccb0235aee612a4032305ac5da43ec4e895d243cd925df6ae750e836a6f6516e5ba3bbbcfa35f69c17591e7cb23643fd74b09e380ad2c013d0115ae545a6ba492d144a684bd39484697f97c0e5d3cec78de5f5a5d3f540471237c9568492320de6c76a9f75b6bf4714a5ae63ddd2a10514d3ce2f43049b6904dcb8d1031775a2abd5e9a063519ff388528978efd50cbb36fbe87ac1006cd1316fc268fb9ad9ba695a3a0299dc028657b6066ccb19ebb241d0b5a34e865ca8b3f3ebf042d5fa76e45f9fe6534d8548304c3c529aeec78b05899dae8134908c80915fec0b286a3d17460846d1ce5b7fea1e3717fcf70238c9d2066cdc12f4973f20cc4c66e1c47df0522e20c46c478e15a3a96b48234ad68ba3a88923c0897395f9d588c48e24f4ed10aa8cc91dc9d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
