<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fb150173d423bf528cacb5ad2a9a42e3a71aff970c26735bd6906a6627fc8979f8e290c4640956d084bcb32258ac14872d20dd2c79ee5573d96912bdf26050f08ec59ff4ebbd4382a1cb5e0d0ed6ce26659f1c22d3ca88393ce7eaacde4e76ffaecfc084e87e8c07b157cd6a5f6ee5127a95a7f28c5fc20fa50aff1b478d45a320b2670bbf63740c1a36184e3d15bfb768d5933ca935c3d9473e216ece3ad78661f874a532fd5f6f1320cced56c3c9ce95dbadcc4b496a2e7462114808886c6b0559e7388a1633e25c250474df97164154a95fe5237a7414db79cc089d502d7ec04aacab5ed7d1b5845762b3e9c16d4a18fcfb2db7c1010192a671895201de9f940ba77c9f9b9788be96df4a3eb40ce8ebf956aa4e4bc6b46445b18098e63223a484a38913e877d8b45b7d30260dcbfb2ea84f4da768ca659497a16fe9636da422860ece264bbedcb18a70f623e8f5c9554b0801658890aad2ad11e1c7d97104908d3a99aba110b74573d0cee1ca0b55192cfdda1e842f253b5ce31f2c5426195458f6a680b7e1b23fbfd5f56e805288af2c3927ddc38f9214fdaf4eeae82dfa8a3c0b8b65b92eb325a0459dfc16752fa3088201ffb22e342e720d1a6cbce58ad38a475196aecfe98ee2c56550ea6ff6a50fb533c09cd94f31fc142e877358781f56bf68a6cb552389bf90ead3582ff8f9c9ce5e38fa72990f625bab6bd0df768494e3dc3d4d89b42e5ada5040d3959746cceea4cd91b586413de06abab9d15a612ac7abd88dbe0019a6d1b83d58f1556fad43497a9d8417dc788999c1b76cd8c8f43a93d7692e278aad61d9d4cb28e07e5e432a0f847997d8d5cc45751c51a8365c178b6596199993e4b6e7c0ec3f5929dca1d8bc82966a268c4354395fdabe74b238962ec30da224cbdfb12111ecde675005043aa01f29a498bc3997423d9d2a71131bb6e2e2ebd48aa8b3f9f14bb50efabff3bfeb37468737a1a249466c1d753c0ba1854674febdc6d4ab556b8124d12f66c3e355f15aa7e8f93377adfebd6afa0fc520a685e1bd701956a8da7aea3962bba172f3a957f7ab9d277abcba82586db54eb5f9d8f7c020a06b5d829361d5416cbd60f7eae00742bce5761a673856ea047f50378b1aea2ef34eb1eb58259d4b9c3800086517dfe930fd345ff37edb03921bd71e300b71f95f3357100a4e259db5dcd817d3bde9689f9e22fb03f23caeba3ca2a9045fa33a6d96ec38d0d945aa1cea93c63d20d6ba29aafc83126ff8730866bbcff0aca30202f6464bc350b632185ea456c6cf7f7acc471a2caed7e90fef9fb762b1a075bc8011e88341c419ab22a1945b7667cb218a74f2b26e67942089b78c43bd0b83a0de1563a4fe608bab34718bb386adc6def896d5a66611c2393e006f9fbab68619ef5878b5415d7ebe825c973a64254ec5f99c7e4aab1d23080981eb548a5f4ffdf67233207bace060760ebdda24c0b23dea6ec88466a4137510f2cc1824da32915b495b46676fb915c0fde9e4f121139d6b5564e1f6ac7cec297ebb6db9e54d4204599e1a37e3a21bc9b1ba380b7eb4be4d91b118cc9e4b0fa5f389af459f7559f69088a468d60766209f3e43811f5ece80bb01a54586930610751819d77ff52f7f50b0cb1a914ce82359392ad0e8f1f6d03cd43b94143fd6532bbb452971ed91dc9102fd1e6f21aca04152c04ef984f4aa7a7ad72d8ca23283264953a8cf2451aaddc0f45d715c41843920c517e549fd198e268a88e8bbb49ee3386ab0094dfe144cf5f75a1266f06622fd0f4a5e2cc7aed59fd98a7187d1b4c006b0dc7a6fc29f39cc3ed847bd9f5cc30f4b6de83b764d4abcdd724d32842aa3853b5b410ab353acf0071db56d3c07d7f4ac0b9b431428c0744a0227c7c3caac0eee717b48178cf38a6501469a247865c8a13578f5be20522dadbc3c98ee1de2dfd3de30876a26ad3273589a0812045deeaf32b55a47ed13f601900e8b80ac529f3ac44356b0c8c4e7e4f4f42d364e3cd00d7b3f5c3979cf463d84106f59b581dcd40a7bb4f4c394c192fddf8e77553ce65d4fd8e3b10b40e8ca786a3d0f8649c355ef5df9865ab38bf56ae15492c948474d627b1ad31c4cbf2af555fbad8298c53cb5e6e8eeb9043de08773660effca3a374df8a94135b845755c84b578e075032a8c03ed26d216921d6b2770b4876ea8444c153a1b01c8c727bd03e4fbc3fec33a77d49c11eb29d3d2c62531224e1a68eb91d5ea6f793f53d5d4dd11230ad9d2af2ac7918a29ee098d5ae74535c4e4d107a94fc8704e8369726cd950a1f37012ee7798cac4f798b194d1fabc7cfb67d36fcea080b40215536cec0ecccfef05b0d5c06ae6f74265127a0eeb905c2b4d2b529bc558971924ef3bacce75c9de4aa1c0faafde7424823d44e7ab6a4a2b1ed2b56028a96e4bbaffaa462dfaf3ad534d5c4061b5bf339558e02851b95f21493fb477211d0b27dfbbab36d7db18ac9c6f4a5df5a0d08754d0312f4fff1f43206e4b09a39bf096f52891133e2bf69edb4002b1d280c21961891d7c2dc1948fe0ca84bcf69b7523344f6ee9da4f68b690dcbad57340c44500944a8dfb95a014faedd1bbc2b032f78b16732d1849a5aed8adbb84f2d65213040808408e1de375912f77e097c473805a004d3e4b0a192304529eee658110ac8656169648e50e5b1e1aa75e111bd30381b1ec51f40db3c18ac0e1b1ad4e8184011ee9851c34070696eacef0e7739d42020b6acb60a075d0beb60f6a52bf9cf47988bafbeb363cb5eee048a17bdd6678c0daa386a5c2d599429a05f03403a0a90f146f77c16df7c417ce073c9c16b84c58c7bcd2956a67dd5709314a0be2999ededdd025d2d3ad7e703bd5a34f245f9f24137671850497dc8d723d7f15cdcb28472f6d82299426e2a688becf81d5372d59cbaea332ccf7e93746221cf25092a672cd9010a0af047ea0aca86f21e40a7f8276feb5b945433aff7da953d1cc5a9721f28fd75f3c5e0a64bcf8d705d4a88032a143acbe331adf888051c1279b992d3a5425193ce1190cee49bf14dd14067e25779664e91b5e1aa4cd884d8c8c02d4dc000c29db76e4ee0f28cd2233ca202ca8cd3409732f39230de8af54b3d94be84c9a76c16fe32c2b9d1a041791387f221f0fc7d615e45ec4b4bf70378aac41f06dcebe0cfda92b34fc6ea0b7dcca7dc1d11d56df1da639b9aa5b0af6a8075b123b4f6758d752266e6bc891ae99e2d9e07682a8cd56b6eb271f9be5f045d93d947780e097dbfa14ac4c3a34231bde4f16e6cd69bd754c775de4dedfd584a0ce5b015f461290d27ef0f7200a912693b72fa49bae87fe93b3cbb61c574c373e9206954bab18b23f713bd319d2d708f53fbd23b92d373eb577e779508e90196f8051642b2e02f361602c1511400a6735e1255dd504bee7ceb8ad11209c646e5e42cc84b14045b849d848ec82800eda31449ac1842cecea16ffe364e42e8247919027c5d91b81b12955d1fb8e9aedd1903ecbf311b205c99bd291bee7278dce16b58fc5bb22d9c9243d5ab72bab3e1abbcc868aeee4f02553ab5690a7992d38cec90b25ee7cfdec8e89eb683de42164f715e0ef5658485ea0e56069087a4426b2e36bb04ce8aa39345684c84a6edb5f6d9878ecd104d02f1e79c739e635157a3294aa6d1c3026a24446e987531e73e1009ab2a6d77557aed64c09b05399ab9df829259ba1403d382542ab04691cd37e71367b02ca5bb8229dcf3c078c7d2d61d9d8838d0fa3602c6c25bb531bc7eac6dcc73890d76b4d1983a328efabe4573becc8cd42ff53be2100351360af20001b63aa09e30c87facea75da3ea8bb3c96291c400229f1164800ba5c451bb2adeda38a1f7205c6bf663aaae2d7177c2bdcb49fc61ce293976256bc22307666254ace84fa048e58d4237b0fba91dbd248df8ab5aa010a349c48b6884574f8d2bce96c1f4749100ae34f383ec464d0143120c1225b1209aa88a93b35ec5c6ff953f2d509d9552cc4385c3851dc16d13b883b5ea1cd641ed13db2f9e84ae4f72dcccf1a6c8cbbbcfd0f6961105ae352d5b7076500057d55ba80b0383ae32482e5c2b7f2166afd901f615127a7fb773f21714740c285a46b660d4344e04ede56c3c79e5e6245ac49b2adcbae0c6f1d6fff3a68fd9d57c958e12d474946133356c25fbfe07c30c70b569793d53eeca5e7b766351256e76dea8eda6490d6e4b082f848ee2eddb04c23afd14d6921ee02f1b84259fbf18dbb845e3374d9d2991855c08d2eab196a529a6af69cb5954baa066c98315a2e73820e58d1f44f23a7a6cd3651ed7536df799795194bce3847a39e64463af55e80ea73b808f54954b2209883776e42bae39596a47cca940c48a429985a543357943e465277aba61ec77a364c5cdee41593fea878fa8bb0358a4178fcfc324cba0b4cbb90f1d061b72e255a8d5daf321084f8193d687994af11b4d76857f7dc2dc32743ec7046ff9aaf9cd550cee5a2a7e9f3aa46007f7d4fbe5095b7bdca070a5fcbb31f525927e2824ce6a12f065bc24109fc45d74e08adc8dd9ac5c95b0ab90cd1212cb77dfb5d1bbcd8be784748e66a48da4d4f12b71f7c7d31619f5a017efbc9c21d7012002bf1715eee491dc9da4857e036c512dd3efd6a2afa493861515896bdec34f0c87529315faa0472ad0696144971d3b76ba9f8c9685d25f1f730e48a21fc6644dc34fb466d417c7ac927d7f312a60f6b5f31b1c375aca7dbdb3b9b1cc08a3ee87e566ff2465dff83fff34a8038aff015c8f6b972d6d07dc596213217e2f69a0fe267856f9d807e4a642d0eaa2d198ecf8ab733215f3abe86df8b2ab768b558ec3c021728ab4e5c6aff6506c22b5b84f89b1a68fd984b333779ebaa3c502f45167985df5f4d3e709d0987fa2341544669f3593ca2c28206f6d02b88b3c417e46845f95fe12a7f47df4a11ecaced5b2473309b7473d20be7a32ac9cb1b866c05b62174cae8e14b8f30cf71413c575dc1535740a04466de9cd5359281010bba8c74e237f58156fd7139b91aaa95cf7e0a8fa49803479bfe49f53da95676719c156017a9a0dee36717003eacd75989e61bc92c55a9db64f61d2ce682e507259029244ad606474c55db753295b5e346f83407c898093b1c1213422255ea1cbfe98bd8bb5fdcfbc8ac8bcb6af0a432a4e193f1c9ec41fb1ce6154d4ade5d7c59317ab9343c6b24416c89777270e8171d080751977cad9bd34e0e3f5909fadaab22ec11369cf8486d1285e4ff7e9a08a8e7617838372edaa038afcc950c104163ec5e4a8e6272677e0c0a716e4d37c915ff1b2e9bd1a9c5d785d836ccd80015731f737d98b00dcfc6e3fcc281606075ef2640f18e892f65ad6a4b26c52acfe10e97454a61fd50a5f519d6bfa1b2dc148a811693f7289d8b4f05553a67f236000f1784f67a755c25cb14987f2831a9068c066c849729ca5daf2d9b467aed15fa5c83ac6a9a13020c08a9ee47cda5a36768b762fce4bb29b417d1aab85835de9cc599bdbcf4848891c9b0c294c38b80aaf7adab9c4c430ec4026e658402598fedc944eaffee573a1119f1e0c36b88e134a9b6a510062ad7dd48d209165e4184466503c52ae229bcbaf2ed7e7cd41f1be28fb0605bc2bfe8484d3b56ebb5dc850958b2382a7205d8e25c2929841d9670b1b4a1a321cd06972c610d0bf186da4fde8e35f2a058d7c0bf34ad0f4cb4b506ecf9286c30c13a797f910ee46b11308946bdd39026be74eabb65022f2b2489f88136ba03465ef8f29bc8c20c0ba89992046904ba782cb7254ee098a166f27cfcd65c9101090867509c0245821819073e08195644f41210c289beda8206e01969e33d7b84e3a8a600ef604f6ae69c15b9de703279be099cb1e82449017a03a40074e1360064d70cc96e8c607b9f81316a8dddf269c700479fc6eaf273ad62c5ef38b6bb47816c655a87dc2b7297bacb61c0e637bf2131985779b5cc8369ea41d098ab39029d0855ca09c774456232576d60db16ef8b3ce3360148145afc1b8621f1ca2d9100b10e34050e1a9821acc9a7b6f8152da5d6f5594433702e6712a5fb57cfb1fef14fabdf0dc8236371c670b6cafe085a57c275c5759fb971002441c16656b973e557cf3863c3276ead894cf9fd3bbd29d9fb75c7cc8b8837cb6577dad526744810510bb791347479d8dee0e8b50ba04254bf9c313ef9410011ac3e269d8204e93646298b65b9ce665e7a7170763f2b6ff09d4b7129dd4cdd901218c46855339f9c03e01a8c0f4d0a0e2f588b6fbc41d6fcc718c6d74578440f8f7a7bd71b3accd4c26db096d8d7fdc0abfea254ab1df3668b367fb78e85c95dbf85f9c9f124c3a16de6735eeb741625dfa6ca4c2c799a2b21fb4aae3bc24ace6e3ea8b6144847d669cad61f9bd9f38b6499cbf7be27c89c53a3ca149dad76e2c804b17fcab781778c82334c721442a15f60230011e04246780b295659e6b5ed9ee149c4beed2cc33c1307e62a72e50751a52e0182598de2df3f96902f3b1a692d33d487256e1c4c2fdf39baa34b94e0262512e419285e056b253e26dfd836e8d26319dca1ae767452747f4115d9790b59e3115cd04f0f850178283ee33e48a705513bc9b2b6c259ec1b918fb3c1a72db1a3162dd08f1d5f9b8e063d91f207cbd791e414258a0afab494145f50dc33e417a87a65cd5371d98d2d309dd9bf8b3c25cf50941ceb4f8eecbb162427f09600cc1991238ee20767252207571592c2bf13ab633b83fa719360af25d67421febb6b0e7a45988f9ba68787d809dd37fdac8f65c2a410a8dd5fe143ddd3afe7b21f0eed7626e369b368d9cced2dafbcc1c951dad415525dccfb3ed5b39d92a534243ff1d84472d0a657e6e0bb7a8e01a37a4567193b0d40c6b786f49bef850df2bcb6b5114ae0a8a9f078a8f0d49c1b316b9ce984d5319d1fd6c3f16b62a655e27c615ab7b97f24030a09f7f62117f2c54df1959e1e761c9ac2c97c0116dc2c261adc159d758382df2096dc808f7b38f5e14ad513f1699fb30dfbcd69d05ccca7f99b95ced7ea65ba29c31dfad907f577c198db7775021340f00566c873de7f3c539a0da1c5e64646e38df5f367d140b1a7bc4546906750d298bf61c9ba6b3183820e82fbcca392411367413a3d8e16d311ce8f02936fdbb27fa5a4b682ca93ca36adba31fea5c94e85d3805c52d8b515286a57b20ad8b5adc2ca46899da6164e2bf132feb98382b1563573eddac230e1a511cc475137f441919ff95f8ad04e3f44e16b17868d7c96f8b3c9efe45ac2e5e2691e6a6a92b4e75c33065a241f963a8f7a411ad0568ee1e90662d08e79cac9cb8c0893804074a671af364a7e355729285efccecaa088eacf6824c67f3afe057469d3da6fdcfb2446ead5f078bf732fdea59d620575348711a04fff79e38ab274b1027f4d6a5dac09c2c10b7ac2a485852e6bdbea55dd31df5a06cde2b2498a8b78a5939f54cb3dbc1feb21908c20a6ca5ffc503ede8e04d9a844c13bf33dc22591cc04279f32d9fc77a335c9123d0a7f158495d5f34c0c904cb64bc07a8fc8ed3107f6b87c25577127aac262fc66d674daa63690cb0b9a7d0c6973dae87e1a1981f520e1f2efc985cc8dfec933d76e6adaa8e00d9dec1ff322f801fc689c37b4e47839b91bb1d213dde17c1567d7a810b168940c86d101222ce213e8ce05ee13377d1f2051ad3a5a5d79fc5d278bfa817634c59d6cde6f1909426570702119390556433bd4f4976fca37de46ed655629832fbd44e8871d4eb689e4fe2df941c9084f136ab620ffa5e1358d91a0a5e1c6ab5abeec75ea887c07b5fa416939f75667cf79d71265ca9936a16e5622f06509a959a4f763dc746c72768afaed065060964909e71355d9dc12fd6f30cc133f178ca7d8f69b4d23df5fdff828563b297a49c7c4dfbc275439cc55b229bf101929ec14dd72f582b25a945cde134eb4367d9f0e4882a6953484d230a45cdee7d0d571ab461e997e697cc939efe7f70ff2183671d1d7b4d7626a777d8590bc527b0ca5e98a9ef14729725060ca2dddcd990f0934faf42b85ffcb4bd15f4ccb027d76b0cd54e8823f987ed8b9c06367a9ec909ca5b43e375bf5d304e1cf40e3316c9e843a0e29d2380ada38b5ee6a7f5a9016eee7fbd4c2ed1d02aa958937f5f1956cd8c401ec9f47c9554525ec038b568f379764dcfbe7d7a50ddba50b869fbb131ce1db7d9d5322e7fd13950f63b9d22f86cc42c5003156fc2e84d07277ac2575ef180db2b914e4d023ed7f1a8761abf36e128de6f275e8bd4b3198b500d7cdb158fdf2928d994c26d4d5f1176aae5d67552bd82134502dc630c7abedd7a7906aeab114118c6b22064ed0696d36c287cfdd9cf1de63448a61458f5bbdbad094caeedc20a4fd4d669322f8df5eea033111b9086d49acbea9da936e88d2592ed69b397f0b3d3aeb65487911f79b3647a19f5132f2dcc0181931948dd57ab91ee9beaa281a3ba1aeebadce4c38b723c93e5f4d651adec4dadb1dc0a5948313a17435c9b1c1464eddaa0ab415fac3cbd0a4fd11f792a7f73b499fd44f788533ff2e73783bff3e97831f35b286b3a0611f49c5890823efe61bd3790ea8e11a444f3badc6497389b40fbf400533d084079e071c6b5bc57f4f41c1b33210211d72a8b3a27854d4721764719d0cd0118278dc781f32bcce89e4f7b690dcc459e4f93f4633148cc95dc08d0773f1f25364ba245e184c9db26749a0ba026209ec830d6df16d5b515b83c5ca8b808651a098d846ccc2928eeb33897ab91258fb3ec4728f4ee6a50bedc74e13da16d7684617507f9b3321e64eb89d06511fd925f25394ca7a87eabd63d351162bc4bbde67c08567ba9a4241a0214f5de420657414323475c3dbffad1bba5043c0b969707b5f6aa7a6653f051ce0c2d435bf16ace7821446df4e3a22505b7c5242133106554756eae66356d7bb3391d01f3819847748b65978b715136c0cde2debe1d1117569dd61c60985fa25364eb9f56b306a32d3f7f00237c93d0689e7d798b94f49ed9ae18ce02889242795c614b7e67d0d4c3485c5756613d562a386738f6e8539dfc24ba7e98c196447c5db47521e4997bf490312cd15a19fd7e515869f81064541ef447f8dd8e63a757e6c2ebdcaf7a178274d73c366a7cf99be259729a1b50f907f2512842ad69fef6541d72eea598a978f9527101a06a1722ac8c4abe7acdc30e8d14759a021ef516cdc3d9555bc52ae5ed0b6f08661cf1eeb7d6d7ca6d0dc1cc6f405128865e80c930dec6febb3809de36495097aab46a623e8b7f4ea07f22222278fcebe7e5001dba76c06d4f5857f61c8c59a607bc0c19e1290a91c47723b90c9911826088ae76ca6969c9141b9a1c32e718efd284e4fd351e3e4339742159a97feefdd185fb3a304133e9c4c34c3c3496dff03d5a704afc189bcab3b3410da9d0e2285f3fcb863d8e74e00af8df122206544e01c536e074fd54c53b9757fdb769acc7f1a060ea6f9d95f62510580004232063006bf3df546be3ed27baa24e1a219e140558b0318d3e1012574d2d23256af189c8a1536c05a8bf715210281e2abdadd817ca82df31084887c756e809ce8cc2cf1ff47b55bf8bd611482118310d80360762275eb63b3346c31c454bdfa6a4eb825db45b9f88ba83a0df564d7fa4b5e4d472a00974fc0a8c1726ad6edf6734726819b94987ac5830b39d2a0c26071231f60c57c5ca7d7c6ce342291b6fd693a60aa197bea7b3b7472d3846f4c97bf09bffb7f792521f19428151f95ebbe6a1f8f70244ea7b439a932f5c88c57168cdf29fad3f97d10d3cf0b272c54c4911ab19e35dda909a46d40ff45a60f7d6e568f7eed98caa9c2ebeac52c8a606b95b40dbc45d107ef7e5b4a8b279fb0eb50e768b4b77077002f98b7ef9f5c57788e8676612fab8d63bf8c84e75b0281fedf1b9a14f5ffe1d075bd7a3a2645292a3ed2afdb868579ccab5620e90b7af36c1dd8371cd5d01b9c572687351c9949f17fdb0aa4c33321f49611f77957ee57a75129a3468d13416172b9c44c3e79a48a86510797067908463be976980643edd2d3c2557692f9b8d08188a151f0ee242e78b426444dd48b950b94445bd387282886ab5993d70e3b25986b8634029f6256a5a808e5827fd46c604f47ffe5f579214cbf870aa428aa8324000c8a0ea9774a893a141b85154979336c18e176eba797b56eed567f8d9406188e38db4267d4fcbc8da92d4a92cbb443a24079dde61d5abbd7db8a97598b6638caac630f5ac5b4a287b00035ab5afb25ea0de5b931a98531da21e4c538bfe475cccf49a17ba80d4703daa5e32bc72fa601fd77f63c31c4968a7b9d01ab767a2f9bd328b0c97f65dd874481c9ce8778b9d7e8346881905531c7d34aca7d8c016ceb1c81993216b0a08a6aab8741d4d0903ed0049bb961bad5fc531c06746a2a3f675e7c3ca0a20007f48b46f8ace131c0839fe9a6ea801048c7c5620c199ed30a2a759e3b29f6866c19ef648463c9907a1842676cd2a4438375c8492524273d23293eadf88001b9d4322c52ae0d2207afb93ceb94bffa5f608ceb546f6a81664a7cc959a619e6ce2807b0cce974ff9cd425d417207653c104f5a2c65e5693d708cf325808aa80960bca544de0e3d76470f8fbc4c1e15b944bcb5d6010563c26d14dd9b44b04bc266ef9714d280adccaa9a6eaa399030e7e400392019ba291151930904ae2d465ef9b92dab286d764dbdc475d8cd800566ff95bd7d94a696d882ad85ffb368a9cb62bacd11d041b918537649761c96d677fd3d18b137c87fb0983193108bb719f230c6f1fd42038d3116cb97400c26440790e9dc7aa05ffac0ee8f664f201e7b73893ce787afe955e8955706b9c40402a0a9d2fb8539cce55e27d52c7f604d8a760bbe29250ea22a1d2f18bce4bfd936b14dcf1d16992c6d5ab053de86b363b7e90b0af32272fb2113acbf61561d669340e08fd991b7a706ae172e7e3f5b3330e35866a1c6913ced29aad26b5c42a4829a480fd181930ea7f4bd556006a6448cd002d0e815ab3e421dfe8c955850e7ebe14d7d5af99955e0fbcd1dc0ccab7daa166e1cc1f42b9dc5d078a97a5c317f930a9ba29acc67d4d80f4bb9416870056abe3c0a3568a1c62c8d05ee9442c1cf69fa70fd5b41fb2ba03c5af6c65d414ee59a73d8763cc379f93b0cb0f10aede106bac81b890be0d5c18275546ba5d4e9b03f3e95b9cbac6c00f37822e5713a6c5739739b057c0686b6cb7a20194d2d7b0b239894c4160f5e273436ffb4e91d10409e2d72e568a027e5657638048273b911a8699becdb9a808dad98327226a72f25ae253a5680154a7ca0abb070582618d082b2fa6dd6a8e6e05c1c9c43d9ceb3326dc62dce322de8a4cee8be5ba644e1fd1871f21e8599cc7783bc4c94462d46fc46cfc812f4c8d08d5e9bc96caa24166c64d687047ca914d45c110ea004b8853d4683a69518903bc78eb9682a94346d13d2af7799190d9ed2139d7f37f8591273fc24915ba1d306e9b7173dee5e4456ea09791b832f049cb137f78cdc4213aa79feae67c88c8304f77f84eb12b89978f117149fe18058008d676b1eddac1adbf829906cc1e4695e96b25eaf0e305300739ba85eb9cf4f6685d0ba44dbfd840dd56fd141b005ddd4d4728765d97e17267cee5bed9cbb7c1b51d91a6ac3eff3154b02e7961e67c0ab8564125228f6738e15c368df27ffa2a4d30ae7c35784bb5fd645446911f4265f9cda769f8f99e6ab19048d461f8358849ab9f5e02061825b3b1b5e9ab657aad0264ec0fb292d69a9f8a7a586c44ed5edacd8e74546bde4b72a42420acf65d95a9c4429169220f168c3d7f46fe665331583d083fcac1a5c280eebaa4596cf760e421ce843d53c8599dc2925547ada2ef9dad3af0435b603022227937d0e0f89628768726dc9e3df623f991f036e2606d10f5d03241bd4ab87e766497d03fb0064615025d77bebbf6f5035da22d83f5c3512a9620072be8493eede555169675afca6dd69073e3efda157c839a44db3e8ff74b3e1afc43e427fed1e476ed8a15245186c794fc585b742516d80d0ef31c8e874ddae05e8cd9ee07397d10c100769dbf3c459d870b115919431251cb4ab75800b6ebbf4b926f833ca11d9113979c71ebeed2a54e5d2dacc4598f53706e55947bc3462dadb95b195b6a6a4c60084a2e6a62788bea1a9fa424b3f775c7b36176bfa1dac246624199ccd0c9bc59243b9ac77b163f98e2cc878a3251456cbb0874c3b368edae737164a9782c26d173dd39a6af5583c6ac0d88215127f5e1128ee224db82adc654637c4978a79f463688132b862486819900b2cc836bf54c844fb41a0c0e4463de5a7379c9beb06796332b4d5c545f85cfdc751d831cbac2be267b84ad8865019ab05bbea3493a0a1e3cc2d538a7e8b67d4cc59cb58c316f03ddfd7c43c366501e6366661a089f608da76f4f2f8cb69bfe6246f3af280438701d0f43a731e26b64d85fb6938a8c9b0a77154ab9fc400e60d3c2c971152e17cc6518d23086abae1ef19c7de1b64c31326c4c4a935180637fafdea62cdfab0c1d42471496fd9517c8ebe6b709abd968a7581d95e6638a43dbe521daea64763d3426e3a927358766ebce1e6467dd896d6a8adc4251da95bd6cf3fc133ab30de37528873e13259d1d66d49017280bfeb67823e123cd2c6ec45d81fccb996cfd82cb8624ba95540b7c193ab3d2d89ad21d95749cea392a644c3939683ecb5a60bf8de80c382331c0818759c6dc063b33405f88e55a20fffbe2fcc48197b01bfbb873d1faaa49bf8c25d1d5de5d045a90f6f5339cb4b7ae8987da589151477385bd94fd9fa7c7a3e9b6ef3bf2350ac5da3036cf8858c2e23f692101abfcca0845bdd3d54e85e42d8a470d7de3bc965781b404e912cd61b1877069a44833fea9168af0aafbb00878ea8de1d82e9d4e90c70f75e7d0871c1abc04401bb7108b68c84fc9cc593a913ea7b1c3b2d99df7db5ac2cfa56d9b0a81dbb0b7a6399b234725933475f48c961480cc184b7570afe44c0dd41d708837a1271af4d06a128ddeac8458da2b54eab73690e91790b3719bede24e07e4a804bbc678b62dc12dd97c5aa9eccbfa15107682a5536ca5f9209f0c192844f16b5bf87c45549ff722fba603e377800a52afd13bf0b67504a201e8b1e5004825f87c867e8e799398416d4f0f2bb3ea3973d8f234f7c79bb55dfe519a2dac9975b054a1ba06c44894f485ec02fd1dac50ebdc1eeb5ad1307c4930db48108e7b9a08700a0970f0c7c8f91238c78bd51d5b40700f83291665edd523c1bb1caa83a1eee8c53f84ae8bce513dd1e52822dcf75cf6304ed84e8c4db3916f9664b102bf998e08df5f26b603c4e9b5ba43ecd41d80e5d606616e4b4112a10689ff4091b1e5d9f1b6d8f9de8c8de1f706faf3c8eb5c16bd748dcd4d93f00d77032e1f1a09c54b2298963736eb5c69dc1eeb5aef7e5501e4b5edf96174733a54619f0fa694283ba43131a31523b094da6bebb0d6896c84ef26067e4b7883da3e3bf84afffe1d9f96cc35867161f87b9efb9681f9606aca493b0b639d12a2070848e0c92f9a542c53babe5e79a03f7ff27dc26d2617b5873fd0c1d069872c73c10f087b6d257111582c516f868492f3d9068621ded3a7c5fed27de1420c7ae4eae228c9fd0b2f5a25dee6b455ed7d388887c738e3ae55d5ab10bb0e5e5b95d30dc24f34ebd5305c578f5ae0db34d08b589a29f174fafbef5983978f0b8edf3f6f5d2588679f09a0b564d46083ba4e86533a824ab14bc4330ed280c23e02283971680e4558325e2b83b5eca97f1079b3018f0366d6042122f60846b1d90a35401861ca3836e0bcef79dbc2ff61735748210b8beaaab4b385ea19b75923d570b350661c6ca7c61139e874de7543cf55fb6ed41010f282105441b1f5d72ec4f552e978f74bb7ac264975bb540fe497d2bbba40cb108103aa2c6c1fdcdce260e98056f0fb9063fd8431fe97d54d93a68cc878e8ce6f1b022668013cc8737472387ec91bda2d648851e3bb196b46ea181dc25ac130219fc13187c88472f3428b6b28856ea4ed61d070a8d11869ec90b99564fe90c260ed3ce81feba56673e0a329062d361596548167d7176f303f4aa22a284b56066b9b3a5626176a6f2d2a4851ded1f52a1d4a4f76eed27b40fe00ce458a388df1b0778ef2535b3c7db1e20a16a6f87219bab230eff3590fb3b200030e4f6848e7231bdaf4247ea92ab978f2cd94ce62e135c52f6eeffb780bac0eda497ff149e46b391fcb60942691e3210d572652fa3a9e886c201e1273bd4ff9af3748f31965a830e1860b2532dc0c2cbc574cd73e8c85ccff3ef749cb7502481e1b52d59a464098fec668bf6e0ac7eac021d8e399939e046b41d03b963b4b81f89389a4af1614a91d8cb33fbb5c86049ad43dbde906194396435879a50a47d37c133af294f25e17db0ffe0297699efdddfa4a0153391d0a0675c63a34846e339a6c58ea3042e3bbaed4593dd57c3a0c02f45822fa6037edf8ade73599d3903ed39f2ba4b2ad53793fcf84cefc2544ff1723014b8e4998d36a5a765b83e707fb5d2093f43e78021222cada4d082c11df99cc40c13fdc87ae7bb759a0cac05d32a5c624f20295e4235240d9cd89ba73b6561c381ea4feaec69b7f71459bc2e4ce48aad4a5d4fcce2cd4151a9d7746a57a29bfded77766c42fd11430274a23a7788be42bf1c96a91825b3088d8d8c5510b62f872de0f45b20627e6f72f1c09ae35ec1db432a503e1d03dfe5c9716c3ba42d5fe8683c2753877fab7b2756be82b20d906103bc456fd9d86f9bfccbdbded303f428f1dc554bb15e81cd7e58945f693601ee766b84e2473f7d6feab7c04c420e24f7d8f9248cb61a4d6e392bef3710df24ffa95feb4719bf10f8eb521f7add69792e5aa1647135c251485a5cef6d1de69ac1aafce8e3df5502cf5774450a7ea08931bc15a7ac982e92a9096bb76ea6824d5b993e11031a9767ebf1216bbaf3cc9028","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
