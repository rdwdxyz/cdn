<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5b87416ec4569dd62e049c3b0f5f2e53d76138a94828566ef8b808f3946067042775c4941e89a1c76d05275cc02f9945e5c78322eaca86e9c39c9b6186b6cffc948840ff952ad91331cb7cd8c30c454fd197d45fda05bbc0f6b57d929a960dfd33b637aa584f34644990ef08e64f1204036e14edf2b0a72b697d78b41133066be8726bc4b66a90d66f3fcd4a0534c4a77abaf264fd6415d81423a839b1794216606a6408872c2faf2147f71c970e736ec8769d8586d5158a409ccedf04723484b82f39e5591d28e365dc2c13eadfd077e2653f41cd6265d129b0c254d019a71ccf254b949b82f5c8419f363a518dff1c52381061abda592fed0988df98b0e94814b25cc052f867e48cfb72153fdacfb6af3f135e7d175adc3fd0c2d5f9fe10ee16749e8091bfe0f3d5c81b5abc82360ddee226b2d5ef433d13361b5b86cd8eb595a12715bdb55791ba5c5609b27b59c2c3440d56af075086e377bab1e7a92a5d96894739330438d9f8f5737c526ad4a80f90711f48ebf46f94662bc3f2312e634fbcb2689b3e1a39e0b2c03a36ff5ab190da99f3eb2b942c272c4315b15efe7c499b33125a282e196e52117952977dd07faf87dddee75b791899ca178be8ee377340fcc8de6fc33020a664c33a616aa66f48ac2e105d73ba5be3f9d3786d176dd022383b32971edd7b5d02c66325f39422717f025beef5270feb8cecf161f3e0680d9b3fd356b9fb2e76c1d1f4ab49fab4de4e38f8944a337d80154b9f2a398027bf4125bb159754e2da4e4820777565265ed7c25997d7b7672e44ef53643942bc178efd416565e5439f776cf62d195750405b172ffef8ce9127a5d543ffdb92be5cae26f2c6104decf531d0946ea4c8e040ed9f683ffd6c35896c9163ec9d8aade8e0f2147a2829da08ae0b0022791864d0eed53b7e5f23d1a7c42df6de93df888be880d73ba717fe5009b950e5904627c311ca970e9098a4c63d440436f971a15b177a42b3021cf3609bff105242d69c8d9d9dffaa412587e955f06814ab33cdd602eab5ebac1503175e489bd1277514bf7b709bae28a403aba3fb6584879d50dacc863728cff0dff6e8dbc4f9a84e0a056abb06dfd34bf2479d4d9931ccb57199956e29aefad420d1daeffbc4fb86bb343f7ce440376ad38ddd537481ceecac189fac22fbe91e6f56ffdb45d5816bd2966b80fad0eacaa7946abde4e48e7dc3fc8fa8cd1179d0af4715b8624d2d1da2b15a66f854b30c4bf700cc114f27fd27b56381076a0785e445df41ae1204501359d02224ef6ae12923e7aba739ed682d332660068c18fa89ed0a13ea1ecb42f804d705a7b911ef6973fd7ad796f0ab9e530e5c91be11d5cb3c34f72a850120c1f492d1ee78bac4b6863d39c90cd23c4f28174ae1061f951660ae17333ccab4e646c6bbc19e64a744509b75bc741e1876673463291786b1eeb1dbdc82dc77d4d8e0052e8288958a8397e71cb7ff66c179ed58fd20c105bca0b4e4aad86fb2cd599b62a98736fda3be3a040d2e4c4a5c383e7a7c7bba59a89259cfa200fc949477e1dffc03b52ec9d04d4682fb9c4a9dbb36929fee401f86c5d29234641e56f4a6276e20a52724079a828734f6fbe01a7d2a1ca1710c093fa4efec9846ea29c55deeedaa2e3dac1e035d9f84e7cc2456590a91f0b9de719db639d6acef5f659985249fc33a9e213ad5b1c76e4aad6a4d7e217e46938286b689962458e5cdb4b640c2cf80f4f24b282c5ff12ad704bb1d2e99fde391a180e309a7787895f33471c1d2129ab992a31bfa62ecaad89c8467cf5695b352a5ec70f38095255473738bc620750d82321488fe32540d1c7ca30f85f535c4ccb0af576010615496bfe9bea50abea780d38bfe5811c7f936623962f85dca869693330693f3122ce7f663f9519c3651f8fb194121cc3828f45e6b49a8e28f4ea7e67060bb9bb6c502d091e96356a9bc4e121d3d32dc08d3c481ea96d971745b15ad6b54f0ec36bf116d01d8e049f01905270ef8cf7acb4e8420226289639f6d50403b62206ea22378f614437af938e517fb56c5e87f5bb8cb98951c916a624d9e10123a9f58575561aa8e1c69babeda4c5286a56720d38124a676b2b2e994890b13bc3486d933a165789407cef22b3009313d4cdee41f0c682e7b856b6b9401d2fd5c7180139d276b42555a1095847e31a851eb854b8252637580d458d30bba052a40fbb732a34f9e4adc43b41132dfce01a5fcb7e6cc6d2898a177deb1d1e6939f07cac9d0ffa84070fa09095686cd88af8091c17830140e2bfd19f6144eb38a96150a86f69ef2db5317f98eb06254fd3a2e9d37083ac21df6546d2d1e1f7896398ac43ad20ce442764f5d7cbdf3d25ebcb93844affe3bbccfe2e77de737ed16c98d59f1dde764816499625c67c213d1688b6246231f20b4c3d9eb33b66ef1e2521384f9dd1ecfd4f519164b89d6aac3e4f98cb5ce7808445d4c4a47721244418066a131637181a7084365121282ca88836c58992ecf890e2a2c9cd4f98db85dd81d6cdb2d6774236d98969fe27a2e9c5b47d970c13bcb4e17ba3bf2e5408e1bf57566427d48eadfaa9e1c67d61788fdbbacf57205c420a715b3addd695b3ee63996f1e9ce2861753630e7165a5a845a49743c09f32792b3ca4dde5b3f6f980602be1dfefdb93cb60070ab69a5a5462cb8a38d845b182e4dc524b5e4a2d6ac19f120d5dfdc6eba6d54917c1170e5a1207f4d5412433282bb49c73e13f250fa4a97c6439f61de40401f881b4dd002f66a78ff2c25727655f5ba39c29f3542df6c9561acdbcd36ee045966c418144afd9633c164c7ee337703d5bddd0d6d71e934330e74ebab1b9170c4bf806657d1f85edeacbc1df2d55824a150a841af05030c04fd7d99ff06ed6d4de382ea58db80ab86e5ded2a7c698e5741d40415c52232f18eb5d2cdb0f177bf5bc962f06dd10025e88cb6d88e046165e88aa5b6821b8535ff7ecdf71e327ac45d838c27a065c34ebba2f20953071f27fd39fc0af66f86bde0acfb8720f4e2f50fe5a8bb678c818e818f5135405fc59ef243c23d5054bd8a59f650d11363a3f32ede4c1ce5457855a0c6220caafddf131e0a5e1f4ee162b0e2fd1ae4383baf30951d99b40530d2f291063bc20c0bcabaf2251ff4cdea71b90a5a0a65cef64677348f0ad33d28bab744dbae75eb52fbc6a48131f0c78d0584638d6ce4da0349bdd9acd902fe1d61be1b9377f7138d53f5453d072726471420384cc70869eb3e5605412e397216d15890c203a4d0b64810ba7181e0d55793badd8adb9b3f2d8774205ed75f4a001fbd79eacf7921f4070eb529b88a1dee8a1459918de0e1ad9199c339558e298e311b7fcb68ea017ebc2b0941031d4731aae07117f4c3d3914b278fe24e897dfdb7a233b673dea33628bedaaddc326111539c799459378324a625f679de3234224ae25f6462391805664cf2a0fc1f86a6dab73196aca318f545e29e51371f1e8fdae8f3bdfd6ffd6df24e68350a0a6524f96d77eda227a3d20efef4352547ae83c64f52a41889b8d99a3a4307ac191a7c63fe1a46c0bc6795118407021b3946085f6e4ecf6076821fc7874612d9bb956a296762d61382d95f9f23fa71e4bf9ec2686f248a4a482f340935d02ae5ba63da275fa29112c57d64583dfa0d761edfa3ef6c23d3e76f69b44614bd5a627c8c345d723c94c6060e804dc671e0fd0e76648e449ffdcef703cb8d01304d244046a8c07ecd926db56fdd04d007d0381b97dbd3908b6a1172c255e871d83b86e9c86fd4109666b8188c7767ba212308703461c0b5197a4457a1ef85d80643d4c9aaf798ad96b4c565e36e9ce640753c54f49feb9e6cfce8995445fb1b794a3f1f65d018118a1b972c30a5c0dcbafcdcc9b11a84f56fa2ead966fbecf980f5b97a2f572b5fab049bbf5980d05837e1463c00cff5d63db9eae609c76ddf8a6cd4b5643e000744764e291be24eaa19af60ea4d29db52f048beb7552960139dcc52c8b00588d12d8f00423b2e1880269bac00ed1fa041ba9d87d08243b5285480d9514916ddd81ad9ebeb247888693ff622df2c73b5088fddb33d5333cdcc609a3e1d33bf1feb5e7d7a1be7d0b81e2cd981e2717d577b3aa5fdd3aea65895792ec2572405e661182cfcf3099d1b2bfc73d9b9e86911b69941bda2753396f9d67bf9210cc6c7836b91814ee0031f336053f4716d0171d12aabb3b51ab251227a9de0c1d1f72ad3199499708b507ae5f4d653b2a3e439957ffef110e3a9c74d2dca51ab9b3d31c9a9b4adeeb54f7383092b2579b67d52fb0aade9652524d5a7c56beb6440292526a5ceafe081bbb60d8299d271ba911d64f96666b7d5b8d92205391e86755f96d3d31eefdc20f4df2e7e5662af7cee01143a0e3e6033d102aa68eb0ffbd39118889536c309cfa718268cd7fd4f174fb685b39772b95dcc750c3a297709c79f69574aa051aa97bbbd13a992fa125d109e45b174631a369e23c927c80857bb77857cc4a806c55eb029ba76bd93835a2d48e52880d18f425b8fe14617a1aa00b44b331cd174d8cbf7d8cbe49f22a028ebd3e04ab3406cda5e07e93a23b0a5f1715571f521471821fd26f57eec1f7aa3647d4a7cf67ad95929698bbe22e9e7e32b6c9b0d5186268eb1929571a391c2397f682d14c7e68c72fdabd8030e0e668f4e65021bb03cd1a8af5a8d45ed5fa650343b52e17b7fe9a90d3ed71139cef2adb6e72191666ffa13ace8f92d2d9fb2b4127a025bea49c9ad612315f234482bf4bec1d72f532a47e617cbadaeafe9f9214ccf846a5d7b80a259b9f6cccde90f582b693ce17299b34a8bc96ff981a31c7a698cb09b64375f01b983df410c41a273762f86beebce0b2881d84044d32e892e83eb13f6adada64f018b346f4147e1b995b9b72a3332cdbc932acfebd6f363700ad397d06ac0158f84e501448b292adb5a4e494105d441da173400b91e8b7361895f37e245d4aae2824e3f20b40cc2415669ed41c8a17b11aa54708676a02ee3fdebcf1dd902adbb9cb3e2f212ef59081fd34858f1d99f7eab96ccc37f32992b19471cd2c26ffc15a86c33df9823632f2da4a213b5ed37bb4f1cba64d920bf0a3010b47f4340a1aadc2d9426eb3541194ede2368bc76a792272a4cf21bbdf959c7e3ccf31f6cd7e74ecbfe91979f5a1813510a4d627948747f88a5a4965295aa2151e2cc7542e89c5d9db825cdf22d86cc3aed8ebab2eddf9618fa15f0ede4013e52c19792b7042d814d94819bc79c47276a6a0f9d7655241c03165b33d8a21cdd56b1c77a08d8b7a31d8f78a5d01a25bae6682e264dbb5672e1ad4aba35d3c2767f1040cc86d89bcd89d4343320d58dedae4805a1f090dcb95f9daf48370be64dd85e2ac41a9a5db6bca7911ab79fea69b0e275ae871899f6d3fd7ec12a41251bc95d9e52dcc41bfdc1fe609eabca7ab62b66f7cd28a76d60c2e2e226f612b288168ece35ad311bf50f37f44ede38a3b0a8f08d3efe80c86a67a2404f3ee070057a22b10405a7e57629ef81128bc8b2ab7c5aac8446ed3d694a19a15578522352f0b7632e081fde0fb69e61d7d93d99e7f9040ca87195c6f44aebc1be78f236810bd2535a720883b6daaae37cfb37a35d4fbe40dccd0d5ee7581f2c9ef7da0f0a8c24e2e901fb38f98c1c6c88939eebec1c984a4979da922498c78afe141d7f114460299f10e7e6f58da50da8836e7ed393f69b9a50394189b613243cce360d99ef85c92ca0db0fdc7a87be380b0bc6b45f54357ac0963dc3f7dd4935c8be68678375664c637a11d73aed27f338fca3915e5782ae0ff7ad0192c59480ac26cf04b9866c3b4571db5cce64542fedb9e6ff2822aed439c6912b850334e79559638e349e81a13bfff98357a1920abfe54f7e0c29ee5effd335003ff15c14261c058afb38c4f2a0a335f8d64800211989acbf7ed4ef0045ad648401114ed82d00bcaf0a5398943c597aad30b85f4ba0dba33dfed2322db8972e464f580b30b6021351a21f07ff315bc5869e10ce4ae6c22f7fa42e5503d0f4ce3bfe0ecb8575d9771fbdfeeae73bc00a3f840cb87a768e95f982559dcbc35663b0dc38708cf5ead1bc242fa9f0587d0635b807ab191bd1251bbe5a0efab91bf3648cd52d2ff2f5695b4695fa755e9a047c416ccf61df08fc5953dad1579db0f749660978cefeca29b1598843b4e64bc024913d93a1152104af1b921ed0227960fbb073e3e8b82a76753661a7c885545a404ca39d835d9d3b30cf06a69a98237a7d97be6db60b226c68fd23217508ed28a2905aaf879d6cb8a05ba7bc7ffb134c695d10f8575a0dc7def06b4f92d217d060a89f37571f77ec78c494f6d533bf590738828b76bba6cf5d0ea011892da419e31e7949f66b74c1e43cbfd76739e963cfecb6a4b2576770aa839122983fcb1f166ce822ad5855f0531c089b274a8d7417ff15dae4b1741d9f151a6d386d937439853218bef74b261578e9f4ccc7ac870dae6d4d3185e750b262a01de23bc475db32ab113be9f4ac39e5143543a2c01d1e97db5e513478aa1842d2d18835895cb336a76f94f0e9708e713a7ce2cd198a109ad73bf9c6f42c1ebe441a7233aa3e549b34b84b8089aadbf2c016261e071bde15ce4b3f5784f4780efd364a6a7026bd25aff3ae508d4a0a71c1309a450c0346a46277d9a89959197914eba675a148e9239413fff6620d36d58d4d0882125225ade544de88a36471bb66e70875f66745e2127fd27375d61331a9b5dadd8784c8ac74c309b46f35de6ac7d000bda39e005303566edceb94bfe86a71d9546d484fa0c050bc8cd578e66c52a9e047908fb785be7ac54adc78767e13864df3dcad620a197fbfa0269d9a90c3ae0dcea02897cc161dc8556629c6d3aab44863b1658700f6e265dfdf2c6e01325ea6e4937b0912d1f9518c550eb02e0978222f68815cfbd05b4cc958b0a1f0935de5fc74c24fdfb399186017d2e09d3d572013d7a5b160cd648eeac8b0bd5e7c34d4ce538c878816ee172b280f8e680c12e6fb4f5ba7754e83d76b894a579b70c06cb129571def6af95efd4028c65cff74f4c7533594fb662b3f43c25637a7b0dd9862999dea55acb658ff650f95e84b1e0c23e52c71a1a54b446e7978cec23538d6aa9627a132e20d6acc3e825946cbf84b4ee696e7e4eea48eec6ef117650a42fa441c0a935061febc2ed1191dc6e093a7f19bfef4def825e9bebe106607073e2947af868313b830123074ef454cd46475649e2cac38ca8970bbc06000a473577b02738ecfccea79fe5933645e0f5df65bf888df05d82420aeb37d1f9db44c3b99af20dbbab78d2b78cad80042a89ed24dc7f1446ae13f05c38e210d567eb34024d3abc197faeb5138f6b2fbd0dee1c6a6318b74f689cf3ecc3ac92477662de1466242ba05d0ed22df2c754c56a2465c3565b0ec49e78c06b97b349b73ded223e608f890caf8117917a12bc16d9e1dea2a1be1b4f282a8a69a9c6b9262bffd8969d078eda3d90b3a0669824407d2faf4b308e396c0135f6c008d4d6f78e01767ddb1b6ee0a956753719ff55b6daca391ecd94d601e5de2656d73e8e79da6bceab66d6179cbaaaac83493eb1fec7c91b4554428b181791ea12666aa09d4fdd89f31269640e8cdb25c42c42e958af36f2fd68dc25911c8150a371fbcc7f70e636b75d51dd1155da70f0f4c56ecf211638a534e31030061b78bad4f5bd31d354745b7024bec662dd40acaca7dda90a28e8074e165ad2eec4f614a0d19991407ff93b4e7f6c71f5d40ffeffadd6441e3285a95fc959d662991717fda8135302275f13b53f040436f26e075cd6371296b040217bff81a6e6abe69cbd53dbec4eeb3468d94dd2ed19461e6bc06d86cc48e2aeb2743d587a8ab4d753dd30035481ce7bb0cd07c80f9eb23da9c17d1bc2e192f3cce152a5b5e635b62e4ad8d14b797ef7099d13e635be148503ce205852659ef79b96584465e6dfcb177882249c11fa84c6c5e1ccaf95efc1df22acd702fd0ec91cddad1a041825d028b8b16cd7cff00df503a9b5ef3775c6688613458d9ebf788f016f932986e72349fb5f7f7051536163e511522300f3f2d5eb724aaf37575038b78b641d675d85b5edb87a4cae86d5ae9b5d1f6166ce228acba61c223cdf3a8f3ea06d1112fa5eaf9f06f2ca77309b32f55e547f36e47395b50f02936e2bc4c5b079972dcff8cebec543fed4f0b21c374f7802491de155b8f0c7ed3c9d60ca503a7041071ab34d69d838157f9b141b9befc0970c45026c8d8abcd155f6ee65fe83732b0ccb4c275f9b50935216f11133d62f4d6ae2a667dcf0d05245b3bd7000411b8d1db36aef6039ed1b5342b39762ad4d34b1f5581523fd83f3788c3afa92396480f87307223488733726365f873d4f281c4b0b7fc64f30138900c6e2e72ec2206d661dfd16dd23de46f7149930abd2fc3e731ff51800b23e80b274b16fe12ee105de0dd5620324ec98ce2fecb530cf49261eef092052d6a7e1c9e9993dde13df9f0c1ce94843b4ed5f50d3b749c5ce7ef4a97e44343b6a670cacc11b817d224c6a4db36f6bf71963344e1036fd02d47c941a6f37dc10abca758b4d112fe339e63740196ebb4abc09b53c4eab91fd6cabc6a857ce1ab6a85da607afba59d7539fd57c957c8ce1438b790312041ffe3275d73818ba0d9a2b5decc3cfd34efb87ed8efa8fbb3d191f1786c6339f9b12a168a2b5c24d38a447c0159dca2496118aeb8732a3662d644d18b10f8f0156d3283d3d93500e35edaf4648708f3a10456854f070c136a9fc33f01a0969763574129569288d04060cfee87a01fbf027806199539bf9e9722cd808a6c37b2e8c51c82353a61ac288594ded790790c87cfd6f39268f56453c6d5f2f40e7cabef21200bdfd8713e7d3eafe8cb9f1ba16475730a62b5f84692977706a6324b5659d093bb5f9eb3a37099bcef9b9411b446206ffd2e5ca2d2b3bbfa0ece9f3521b92f3891325b73cb98cde88996ed5663697a9bf3f04771a83c340ad9e905522bd5cc8dad19e7a8b45952a9546d49b6fb14b031502c665a07abc23b130edc4325a40503858b6de621144ac42f0af0ba7632d7b5d4a3a53460443214afd3ba215baae04d7f963dd460f5c0112f23f1feaffe0a3db3bd17d416990a22e8aa492eddc57a94b58633e1142c1b4400b88f273f99a35c3cb9748aec343f2f235f321a5c7966116c832158133529a34c794283475ebe82ddde9b921cd18bcb62e945416612aa53d373fa3daf90b8f0a0d9394a4a619fef52a416a2662716caba64e2febb1d88172d6517f414ceeb99b73671f133fb7d659454d0dc1e70a18c764accaf1be53016badc966bace9add117d4a02d88ed7ee442454c51a51f5f683c9aee4f77451b15cb90d66ebbe7c292a2557aba5641285331767c544baeab9fe80b846788ac56b8879ea1de80b74e2247a681cf7f89d5924797efa6531d9233860a82b3d582d85918bec448161b2183a3b62f1e844cac85a0159176424dbdadd36892071b5c2b52a41099bae7e1d1ec26bdcefada8ebc1d8605dc827bad26332453310ddb33215f837eebcd1e122d4d0ee8b44977d8bdeeabc6b85f707734d8ce21f7e7649fa5838310297b5a0d78b631bffb45ab299c7c67c1e6a87d2d7b9519cbaf3f5b8889f3dc09976b491c72ce07f31ef3a022dc674cfd21eb578a7c141641c8073072c3b9e175ddc49e3203907dd95b4b795574fe6f63dcf6c62285226a46df15f25dcebd1b4af0c8dafc82d15988bf6b2c7e0928e4d95b86043ffcb506d132e4bed5600e8b81de669a1a8b9891069c39eac2c7f5c1ed74fb07ee4d09ac60cbd705d34dd7013b8618377de142e17155c8947c9206e8b5da1964c274e14516c3bb0ffa733903b8fb1d167ff5d708d1f34d1682941fbe407f385c029b5d124e697a58c94398b732f7d8ace381a40398cd5951808cdfb87163eeacd878bc468e49cfa6c895b8dbf5a79690c065f034a713b405cdbeb503616cd2091d254af3576b85ad3941ef01ed4d7549a8ed6ade73bdea24670a62c284b54ec76daeebe45a816c995eabda4eb7bf507a0f89a9fb49be63a1557c26294275a32c19be26c9962faf35ef22879e8f66f60c0f797eed43b0af40f03805577723b29b5ae14bc00fd6cbb03c45cf4a7d26956e5a52491c19fd7f93253337ce20937946f660ace8eb848c10b550bb14a5934294784818094d1e87b9948c97ff0b78479a7469e9d01d13342416cef7979601a88cdbead47d70a6c6ac1d3a9e566df2d2fc60a0727922c6dbf64ba332981e121481dc8b22bfcf684904196ff8081873d6eaa27fb80ff79056f4054921e4f762f0fed4563acd9bc1cac66fc81de3e0eb5d8c819c9a9f33f6e28006bf63d20f1c51c9b5309b1ed699ea85b088b3567f043ab7b229e435a20101fb46bf5e8d0e3691cfb9afe3599b75bf94a6356bfc7ce0bb255229196d35435d961c69e25303f575f54cb931d1186b7af40b1930f4a048814abd78929020d1119eae2b2810d5d25fe351fb4fb62ea547397db8c40ab0081f1671645788503cbfc0eabd00b31bc842666c5e1b965857c19d793588d4b1888e27b4b5fa865b056ab20862d23640b3dcff0c13cfc501fe1e6ab19de7ac4dfbe3d073c6de1b521569c8aeebed9bd468c5a0d6b914a8bce1d354d065b58d2c5e32cd133c5676f394959a26fd5cc461cbd03a9b656e729d3636af2c2f477dd47a48c503cdc320bad54a606bc3ebff20cb067de5a20ff3bb77c059be5e1debe63a7e276a28ee1d36c8f9b1908b6b4556b3ea6980cf573ab869f208dd59a9b81f5804caa4580fb79f9dbd6db5c7f7a21f4cc2de3e44ed19095788fed5d1415391412f1eb31a54d04dab61ed73325170d951b7b7cf3744bc8cc9688a9ab687833506a145b147a8a7a4ebbbaa56ee3282f33ad720de0238ef87359d782e9e37cd721cf4a8f4b6b73ee17fdc3405a7b0d5c48a14f679c16d49cf3190b050320efca21db4522e1d277b70945ae10d48092eac5338002ac340f5f872fa617c9f5fb9da59ceb0736872ee41f78561c14d1f4991c32c2dd805272989a3a26e2054e22d76813b94226c3214dc0f12de4ce1835af7d8bf95ed018a65ad2bd07c641c5a56a36e97b26855dc3bf4f1bd153c52de138c079a21e2384497d92ac76a900abab2912c61b41c67d72aabeaca89c355ff6a3859bdc896e461ac9af08a5cb10971adfc450339013f9a2685e58cca7904903123502780166238b54e8688df1f9188d34750035322df7e7fd971c7e804ea4e7332b8ccce21c6465fcc35812a0f59c94b49cdfe598396c32b361c614135e9a46996ab4314514c8dd5054c66a35b336c2509cfd2c4596fa19540fff7f42a996f5d08919619e7ad145f92f2c53417e2e4d75cc2f33f3d4ca58c14d294ea1faf910428035f7a9d78030d93ac88cf9afd2b66d7851c55cdd865decfd2601135e9db96a5d9596554f15d5bbd4fe05fb48c4e61f54e905586f52865f259a6f1dd585c112f527ace1efc6eb3db430ba1515a3e5222acc65698aabcefe65929b3556b78c7b556598a18021bcf55cc2196ad96aabc94888b021e0e6b7138c7a748d52af84d13192ff13df2892183a4e7d641731fbef0fe0a989a5cc1620637a1976b2a2d68cc125bd5f9053a18969c32818c06ce4e04af5d6a3d9117abcb4c5b13b3476ad252a5958971b9e39d5ee7248db548fddd1f548f32b7888fde8154d58c549fe674ab228acd0eaebaa173dffedcf8dcc46a7ba7ed9083e2c4e6710948fb005662b59927dfe54cd6167c92ab6e5d3fbfcf1d4baa173a6ba44e4d550aa5e43fe72c0a48c1d2e325f664ac27916c6d77485e9cb5a3c4e2fc2f636fbad4ab475473faca896197ee785c5b78678b8a360a9b2b1e8ccd81d16c4df2d8d3090f22c4b2f7577a63cc1cace4dc866004b31830a981f0830233687b8992fe9edfd88a48347a93ab1667227520d244fe3734efe197ffed7b0d563f9e8603faebbf33db0410f078e3ab3b438d93cfb7e1822dc42a349de80dde4ab04e9dffd6bf6b296242e3cdb6bed084474f8bebe39c74870c906e73cac7a4a4fd995f1198e3ce021748ecbd4fa9325692e80d352f78cfb74d29369e6ed90933e9c361360c41f3dcadcc07b6dc494b28b3c5d58f0d72c37292c772d58891c598ec206d73387748903775a5b1455cc74d3a387a36031c72c6f3ddd47c7a70ade8df79174dda8e14a26d4d57514c78bd9b7909bbfd4e81fc732107091132caa38eadf8979c168cc24a915762002fb0c57a37ceabc395c23b148a060946dbbf30437ad04b4a6d7fec1092b30b02e4fed11b2046a30ca1e901d3c54e0deffbbe4f372f62bcbc86ed4b95d91b7d078b75eb126b34434825cde5f52134468033039169c386f3dfa19965d94bcc68201ca8a54bf3ccfca86fec0d7b844c4d8277376a7ec74953aaf45129339c1e4ed365d150fd1785acb30bd581bbe54e207ff2a7603a9f0de257a1b3ae7e2843c2e52df773e0ebb77430923695fbf5351d2f3389649bb8587c27f263c7f8405a367662dd783dbd7be1d47325415d5f8874139d0fc8aeb961b626ba49715300c81f39d3c19ca33d7b8a1a271b480c3f774fe67329397b94d151c7cc7c2e64bee7eac59f68beeb2d7e62f80e39be7d1c40ed24b91376081461866e448a6161c95de6ff3ca14b194b200069ee651207891daeb74e65ad3f46ede840fd5b00cff690253dfafee6132e001d45e7428c31433f411785e228e5f658e557d45d37e93040b208814d007f4e35fc94ff10e471306ff717f5b7d5e2cd711b5036ffa9c71a81aa497d092dfe764c34af60738a849739e4a70a606deb0f8fda74f8089facc1993e978eca332a0f072846c461dace37791b098e2c74501c8d8ccbc68e0fe6fbf18b54b67a22f4b87a20dd8aeb56c700326f2a328bb2738281d4899e612c2cbb7aa891a62e2cca9c34ddecda4b0064642dd81d558bf76ba28dec2dd83fa2ea70d4764f89c0f6065da52ada3eec4b74b627eff3f9c0963fd44e50330f2dc74ba2ced3bd37a1e417321c8af5e8777c3d2e15fdec23874b4cf87233c7412bf5708a6bb444afda29d2f160a775e5e8e78bb0816f39b7a90a242b40cdf4790e7f55ef6f8efcbe08a35ad8e2df525c7f8a2b68c79c7c1b1b932d0b14015e141b329bb4a49f078c3b101c726ecbabbb158cb3f30375c8fdee8ad176287c82ce7a18db80cf161fcd795d45b60e5767b71875d96eb46423e395577cb76c8e69c081102b4761108cadea75eeb27badbb9136b686e8f0a08b9d634f0b6078522b27be6eafcb3bd9b95eafbde94c00741b914611ba905558ab9c0eb85acf3c29d1a7e83560e0b92d6d6e9349f6db894ff596f3cfb130615a73159d0ed84a6df6659ae1babc3de7ec2436c402626100c75739888f560b4ab7d41cb5569cb6403cc49ed2872b3f9a2b5c2c4f32c47e9a2d9c88184082cdbd991d61f822357514c377b05ce8a255848594f3fb87262149d452d33e2b53a5e5c49c694cb2384a19c35ce8fb5cebfeb765800cce5b7358f9f9fa24cc6b2707d8a08c530ec62539fad34723a534b38d040e1c4e6686de4f0a70eeaf747292f21c7cda96974e37199166a2006e19a38d2bf1559e64025bf629c26aa9ce339babdf3b7d19eb8c97103826e4d5ce502ef2e8bcb5177c74ccc7bfd327604a247d7c7cf3ca3cab1530dc179a57118482ed8fdad22cbe2a6e64bf1e659c0f4491d670666798110781140d521d655ae32cc2bdc6c51d8e965d6f9ebb2aefefe4aefe90b23d73c3e77f5af51e31d54d40e1f51f53c1d3b8bd3ecd1f876ac67bcd5804ce84a4a8fc38738b93f2d33aca1bcb32608f1d8e8207359daa04ef21530d893f7a3df2994b1a047be46df357df882298aa04a5a0e70b1471721cee32fd9c6670b0bee687a83035105e4a96295ca7efbbb2d64d2cb1a923a6306cddc7d4af1d82d19b51f71e420041cf644d00c7f925decae913ab2e743c5c8d4bd52917ecbf4a9c479f4684ed9b32529b02bf4a1a4c1283a127f68baf28d4371778dab7ded2924d535726ec1f26db497d328476876a4c01f1109eaba11bcea18c93a7c8002746f4be13db9df6d3b731ec282c21d69f8990787c354407a08aab484e73c6a385b46bb7ee76530b7930cb4a36fbe271829dbd96b8085c8c76819cf59e788e9c95ea53aff2b0af3ae12c11b3e9a402d2bcc2438ded41b7b15701aef5f07b506f60f660fe63209f8abb7aff0eaa8506d155af6b16c8db74a908446da093a501d79502f096a69a60f872ba0063cb7e75635addc833ee714c6af36067a821506e2b7cf63b30c3217a7663eaa62248a296235d5f9630911b0f52319c994b69eb6b388d7a3fbc5d8ff23ba37460daf6c4b1838d45dd3b134ec3e72428847a777162e53b9eedc29bab6072c12da15b92cafd104bcc6c8d8b84646030cff42ce95ed808c4f836db9853c6321138f73f34be2bc1ce9307079b7a3bf6a41c352933832e71b140ed48a1c9cf0e07c0af6291f5b1d24b67fb559605deb2b633fb5a7308876260bc4799e685a67c5caf56af21dc167fa64324dbb744490eabb578812cda181af0b3e7b1da435caf3d0501f3d2fd91c55616b6942520bf3a9c701779015fcab0b38d86c11762ee15f30d40c6fe0f8e09b9fd2a7ff98c62024ff35595d221eebb70ee3637798d5d8deb8acc8b7361d7e211d65fbf0b0480b6aa6a7a56b9e53ebb6d6f134ba2113941fc748cdeac37ca518da25061c43b7b42843577200d4355cd43328d4a78e63b9dcfe65e46c76090fb9a315ecc7ae1a57dd579a9e068c2d2f2692d98df4333a1e0860b650a343f02b7768ca885a9b68467a76106cb1285a6fc1e9265f81dbcfd3f97ce983269454bb8204faea105c1bc528aa832a787c066ab3d0d6513c68a211f3cf807bb7f03ea71869bd06c1b473089a9af38eae4fad82445931556b7592e3e2cdae81ec0f215462342d1bd5c3fbb8e5980740271b452de8c1b1534514ee348cf77efdacf9b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
