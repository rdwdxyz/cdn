<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"53219f3552b16b5cb80a9eadaa4bf960f08792f074bdaa0390fb33febea292b9be897210d67e3e314a1e9f30d7ed09b7102856477c30213e9c8ac28bf47558269e47b5f6a06228b8a4cea7a0e73af2b48d7b6a1ebdfb42af487346ed89ce2eb4c165d22a1f8dbc18b1ff0fa3541bdebd1d91e7dee39b7abf04859e7c96bfbb8e110ebfcd17f945711c2028fed34fc264057e5ecd45a6e5fe522659e7eab1d5ecc2f0e75ccf782e55875eda1172cf6d814d59e599ea7bd355f91ed3b5aafc1295a2a2f43996de5aed098779890ebf3281f510747205625030662d3b432baa9be2b8d8e769b12dbe6a57f9dd59982a88ada418a37cb5b1ad131fde3fb62cd13c24dff3b3c2bf7905bd0267018ceaef401a95d788161f0fad3891616f933bc580b6c534508b58fdeeb7acee8868f020677f086fa4c198fbdab1dec97cca4158d0078b5b4e2c8b79b4b2741dc5f92fe09807d22958cc10c33735ba027d764132b5b6497ea89222ea4baa90478f255bba794799c4bc9c911de8a16d50272ac92af571d01c63e3143767e8b29f1f2fbaa64182b85eff47db91afbb17d11c35696022b1c2fd03c31c6bf3eb65d2eb4afabc3684996998d2d0949e19ec5024f03d92b9f827c04566a82b9c465759551234b126e24081e3ff7f930a809cb67dd77235fd0121f9db7562056ff91e34f754fef85ec76cbe83f2abc0124dc29f7978cef69296f1abe86f2eb6938298fbb95929225a2fdb7acc01ba8b7ace18a4153d1cb7121b58f44bcd51cd2b8683b7b134f65261b5705755eabdd08d5011a4925881efd1a585113f9bacdd7737f5f6eb5feba07ce7f36e1660a9dbcf9067b3580e108357e6e3ff8491d12cd37b758005712253c22c738113fbe2e89029885289c7455dcaf830b0f8f58cf5bb6859639038f0470a3122e69e24f8e63016a814da5aa8d67e06d9fee7241f00d28da76c2ed6af26e8a0cae076de7b79c36ad567f43b66e1a8fe9e4cb4e0bee2434f76f0afe0b6d7953df694d19581dbea5e6baf35d17589d1797d4111fe16cb2297b86451ed6d7b03615994b0421cdcb67d85e0ae34e64acc134b33447c9b6465ee62499a656c04789867927d44d8048e996eb327cfb3eeb4bff5680147510bbc8d8191c404bf196b4aa06e9f16a8687e25da9429c8a32763640bb720e1a1f78dab9b34f129623c23412fab3ed04853ab651067766b3260641a6c5e6b42975d8bbf5a3eb992efb1b591bee7f178693042a7564869bf6bc2d9d9e1a7f87e13d5e5e5ce2e5100c5ae6129fc4617a6be253d2025f3244a772c8060af54a6353aff0849de2c8fa361e9e85d1682fb9a5edd174759a44d088aa619bd286268be37dcfe6c08c73db20e7fca85d7f9322b9e2b233b855c355c78a2b5f60f8403764cb66aa79b5273a1f1031457945ad302a8a985f7c794f527e900392fae08f15a77208dfb8505b2e852303972c2dd102aff52d95ab48f3796678f1dae1d2add8e65534be20409a20200689d7ffbc5a903a6eb74d160732ef09d09c41d44f46aca688c3ada57556619c8dd078cb5e65056b15b9e06b09b5ff82d88d50a318b514b698c9ba9b21c4281031999fa834e67b68c8b7f604b34f224914c33cc5882be345e504c0b184c3d94b2340640d5e0b0017674b76be030442d0f7c812c5a52c6ca18b661ab754b3507bfd0e63a805d06bb266127459e8f9e0b750daf1881c728bd733d2fcb230ad153303353dd5227e0af395949668690cb6231c3da399ab28cf19c9e19bc8ed803da0a3bf6450caa915585c96e58663558e8c37b49922ef851a70ed53b9d604045a57774fa298e4696add2c3b5278104933b3a0b22a5f5d73d0bcd946cd1e44b25f5274d12c4a033b8cd107e8d609a613c8e09668503eb668e394bf04ffc0e43425663d4f15637d100a6a0ab9e69106920b2a6a66d3ff64ab7970a44ecb694f70a4f3e502b911af193dd4d1f734bce1c3343f8c371e2c07c0d644455502dd1de5b5a09e961c1a57b777d26a96a87b0b6b061c2648f30d00f055cf3d879834ccc59f3ab32e26f9f8a8b568d79582c027b5f3e589c281d55d10be08f9266e3e1c0f96df127a50d3b87de6c71d226ec1aea1a7d3f7a12c6df5f52841808721024f7cfd8ff07c50b8626125233365419664977d05d2cbc001cbeb7665dd01a4733109e137db12f78d8c8e84b3abf608c322d561d49896a7ea6888e9554f48a13f5cd8dc8fd343b7af7f2e7ac8868000290c74629504237705786d0d50001655d5697a84e7f98fc03603f9fb9fcfbdff01e6afca659dd93bd2d6784a5632f60281a1657ae835d2e1afaa5000f8033359649f001ede56c9d27d44cd8504749295cb3276a34f6c0b91b872ff1144900ab46a17922925f759d850d8566b06ef0cd6baba2d199f80c6a06753d4a6b00e8927f0891822789343247ca82e14014c9907008bf8373e09b2dc2d02de1b7a4f85668c2be44f95da0ccaaea064d4e933bcdb680a6414007a5d865819fffe724328d6450bf5330417065be7ec03d88eda2279bf3d29254bb5552876ccda5a1b433a1968f3c824422ea16fb04588dcf8ebd4f24822596753f7746f8c0a29b19bb421598e817b8ace7717e0d2b9d8b2ed3bf8d0d5dec0bce8a6a87208ff3de0460c0b4f81de057cc1942ce80c9a418a5bf671213456bcf78d37051afad107cca205962199cb8d2b72bfb6128c60d1bbb3e61ac90fd747e8bebb1ed41263aa50657a00b01f7d123607dbb0ca8e42c420584f55b7de099ecbcb90d5efd3213c01f2f8d08409f45f75b777ad71f2cc40b5c8986c68d736056dab896b09b9626f5840f13f3792130ca2d8eb66fdf833ac5315ccfa713b3b39d6a45e5179a72a2b3c6b0ba083aec09d9e352aad8c38d1c9a9e4514d2a54e1a4045debe41f3be0787c8ff913d6d8d5de9fb05f1186986fcf5faadb9e37dcc73d5697f07fd6c1e79b32bf50255545895b1942c628fe7ca80e1338dd452a91205b4ec62cb7a0d0e10f6a9ba1d3a0f7fdbc785cc88a4fb216cdae094b7ab6be000aca14d2a35ce34a368efb700a9540232c2166e75d6d8311087a0c615ac503287e17954ba0da09082ad45d3e6a91da3ad0760c84f25c5a5a25f117f197ba6e6620c5b656ee725b8fb67e2bc32d5be44dd700ae2c255e37bd9cdfcd024b9346f0745cf74ebd2b1d15d47449cdbdd6781a82bf6d154c2bc854f58639ca20d095a1030e5991ee735e6c062ad6dab14639c0d5bc969e9b8e456ba5b44eb974646959967fbd4d8cae3c3fa4dee93a943a5c17de86801d5a8ed70495fc1670ffc03e5ccbd2a0e5aef25a230aa566da886d4409bb8816a672572094165daa29526d4422d0299321bedf89cf93ba59f429f9ed8dd6a5fb6f1cb6b836f0a479012fe334ef7e3d1e8260009db274f7e2e41ef5472105c6ea6d632703e926bfae5df907ac170047f8d6ba6b7251d9864ad78882d0ba96f8f5b1e6c2894b8261e7564b17c3e74595c9ed500033c72ac68297a948fcc906b64e0ce1e6a318eb558bac8e0a2964c7b2c31b8a08b0da773175d98c716f86f3237411a8fa6280e0c9b3590144105d3d7602c7874a6cec363516e71d1d8705ecd250f40a849fadde0637e3641ce098089ef0d35d57943344e423afbd3d742fbee0d07c5cd16e2fc1e2a982bf417f94f2fc4a0e1cdba91b3c7d05e1a34e0602b79032a51f2469dd67b61eea882d216c621c6307432445ce7e9cced68bfe8ecbaa053381e35dbe3eb52acab4cabd3bdb49cf71e12f3a9228202a6bbb51566de498420785d618b863292df113f6ecf94657c16a5e4e6641d4b38d5bbaf0870bd45d57d2f94699756ce44636c64be014b462835cb57e5d3332867abc0ef95d1012bf892e5fb9db80cc48aefd521203af0d8bda018abbf9c40738335622222fed334e4c700543132db3319f4c1db5372a9f3ff7eaa17066c00965c5c3aa8f3b4392c4ed9d5d05c3f139970bb2dcbc9611c3bb5c66a40facedb2a2a5b47bf086896be467898a4904fbfebcb0ba71698dc6fe540cfdd7452bb52058e59d1b78af7f438d5264d855f8f8e3191e15eded79f76a662fd40a16b4845dc9243ea8c845ef34d98301a1b95b6b2a68a3305caa4d9e40c867f86fc072190f21bf7fa6b9cd40d26d5f2b171b23ef01db0c1baa15493f3282a1ba8e04005e58f2adab7eee28b63e0d32693937118e18c863c7899dab4b18335aff3ddf6bb099fee01b1aa1061f72ce008b2654815727ac7b87d167b05fb509c4823e8b4133abbf924b02904629fc5cfd744d51746f37977eb178019ae644bad96a3274b5ca2b23db0fb970131bb30677fc099f27c80cde9fac5133a4a31c7fe4744511ae8ba136e55c9f28bc6b01acfe6c0cc3dc9e00337268c82350ed20b788063c6a195887f41b33ac253903f3e8d137fb99f4a9dc8f3a912210f9e7560e749c50465c576f5014162435b6819046eeec5c6056c067eee053370946b4b14ad53c23b28dca2230f476310c7bd8639f3b184e7a62ebec990cfb4d85ae75933c4e2492f5c195c3622cc4496cd8349e545bd6a26ddb3fd6cf72e629a1e65fe4e7619486c7e62280af47e543364448c2c0c8877cdcb9e7fedaa86b6aef3f4864f266d9112af924c31ea6cb1821cd30a5722dd814bb8b751cb87effdd38d71b191057c7ed9c7cc062b7b8497d0fed832b3350c5078968fa21d018de93bd6d695130268b0f2607167bf36c56fbf20e4a732804e8b4c955a841245a179b0d59b9899c8cc9c68e49b0fa10f52bb951d1ab4c0d4f470b02a62b14a1bcb53bc2665b8c4da4c4a9a368bb35e89eba610f24b2bee7a4d6fa67ce09d24187ac228a200145eb143162d152b33c7369e802aca1673822425f91090decbf7ae7c47944772c084e6a49d4bd61ca0b126d5862b5f7db18fde71ba81248d6eb2b3c613bd1c73a682fed11d725db7b3902babb6b9629160380394c8501a2ce6727b9275e294bd382d1022b3f95595b21e329b4deb9d279c6c2ea8daab18122c955dc745a2a9a6caf8d49c0bc7c1e031766477f7f801ffd5c4193e79822c1d22f6bb87719b9e534d753bb7a67743e10c4f175c5e613437fa24c0251eee9e334e1cc900c0f5b14e2777e3240ae981e6f4d07cb12b50886dad2dc385d8720f489670111d8aba6727ea08a63ee1800877fe09538aceba00c3f124217359394e4d59320e3e5ddb7001adeee89da87db067734d463c800417519e949cb746c81e77ac3e27ef5a9df4874a4d5522e88d2137f7bc049b610ac6c3d8ea45b3a50f299f9cb331bc3a43918e5c8bf94101a8269c58530d7600996174d3bbfbedc8fd020022406868c0087d28ed0e118df16e08fa22524420584ca2c199fc9b2ee12a370e8e6b937e0b248f1014e1b9e847cd79d58d030f24e01710fe4eb274ae2e137188a61860037c2ddbdb02d16a4dd9c42163d4b76da74df834a5ab70c21f901e78b9784c9b000f1cda05133146c043d38a91712039f3f87e17dfe681f60b0ca4314f3d803d2024a3314462de53ac931090467ed747e4a03646f55c4e709b4b4b882db70268415347a64488d87b92254c30e63ec7de5f034166781bc6d03237a8269f766a90f2d8e7976db8a5909803048df9debc9b5c9c2b7e1bb1298f22fff28d6ed2fabcf0b36d5b75f79c295498d12423c1527e9268deeab20f5737d270b531c7091546317d5840413612125b97282bf0a4b9c6c257770b217b49dd13160a534acbca85970e5165c2d53043dd83b7ee139f2f83c2f0ea768df73dbde6e04ac9fe2bc15c089b4b3c74ee8da80903254a41bec67daf10bb1131ce9c41ba5b9abbad6242b0da895e32bb55a287cb730ff0d60d6c191ff775ac7c54cac88c49d610844fc0d9346d779a7eadf6cd9d4c35e399680d48d1b987e8ac515cf9d525b2bf58b84c2c0bcc96fc7fdc0d932c263cc4a3766916dff1d45db3dfae30234ba901d0a93205e4f0fba695c2923509da05edc5a7e25ede80153fb703d66f93c7379733c2653525fcf3eb45aaa7d47a7a796d7fc5df3bd16d530a65163e21d9d625668e058509dfd1bf5b9cbc5b186fc5ecde9d836950e8e464605c943bc260ff0ce0a036de1e2ba8fa0d849cfbb440984a827b00345d5053e5d9dfe32b9d17498158d984cb97f76964cdb83703cdfbd0862f0a9c6ffca57e3c06c6e583c5918ee234077b864401bde78eb2955b26d5af570cccb4881d34fca0e28956f0670d958a4d2fb451f195cf2918be380c992979768a2c779ab0c938c5d241ee8b6181649f541b9381e5ca84c094d697e79a32f00953c6fe2a78d18316a6c7683d161ddc7c6ffc3eb7d8a5cdff4993cd60d5b611d4879e8a81c1e7dc32d31969888e2c5f6b964c1dd4d668e85da6b8db24b093a96f1969fdc87e3d4bb2162b295416cb33a6553ee91de903df07931ea779067c857ea07cbb1128d4e8743f764d63b795bf921da4efd519736650aba6f0c062d0fb4b014d6c8581cd8b43e59e06c9c45140f5b275566427f6e6bf2f6a73cae71ca695ee7b70e306ab6dc3d8812d113d00ea194f678068358fd768c3108ab21263dbcfa88c520a48e9f91cc16b9d5e7d7b58dce1b10421907a9351c01fb4bf8ecb2332aa0647410b198fd18becb83945d8c02884c1db0d0021d462f5b1e155c6069276ace88e63c20fb11e463b26ab8a5de30f8076ce6ddfbf0686e62ce67ca46baa883348b558c92f3949c571be7871f1a77c3221ae3b19846ba5453ff5c02cedc2cf315c90a84ae5f98e52be823461f301111d30cbe1f99a2d28c84d9c1e388e1e4dbc5d389a4123933f2dff2c1d5b1f4f7063e786f48bc26fc935f86f5bc534f13e11308511e6a64f7c5358dd1241614cd4d11ad58d3debf535e245637fd1f69ee49f9ae9645fb06fee81d7a42436a609d343ddf028f3db1a39a13878a9dad03a57545c4ecbe2bff5aadbb124f089005875b059aeaea70b7485159baec769348dcb3a88894a96efd6bebe101a70d417c4cd073b445145b2ce5e49bb803e5d4b02bd1d9ddb7adcaeb32c2f9836f87b6385886b4097f0b46ad3219e4d06254ffe8738dfee03c101d875c9ceb0e303bcdf4555a41ee3616d4f1a539abee3632f1d4e227bc5685e5cd1c9724d77ffcda3dc5825076e3c87d484fe885551b28058a13f7e44f06679085be24127aad5dcb64c9adc2ad0f7f4c98b9ce25059b260d387cbe570215b3fc3d05839e8918e29089b671dd20956fe5d815c0158e351981dc3198dfef340edc95876db4bca9fc8dd28be0953bd083fe739610a3c7a11c8d672f1f6da13c47a9eee068805eb11dbd029db160c2de632067333131a7d5c155d6ef858039dd75f68bc6abc6fd0ce22933861bd32b66fe5027b08be9725bbd76ea371cdd1340ba2b02808c049ffe8b75a117c917101ddcbb379893f6977fa7c69ae05045987caaec5f923f97e3a4eb4d9bcc7f886d903d8c97529fb43ac33ae3ec60782b9ad7e24135a8cc3caa32548d8c3cafeb6bc45d283f3367201017fea1ae0b38a3f3ddc1b4c63330efaff2399e4f4ef35ccd3eb7cbfdf20e321b6756101d271ad641f92e9f393e36a0c905c0f682b5daeb3bd6cce5eaa7a44835deacf0b137d1d8240b5dd89bde67ee017572a784eb7d9ad9769d271663c3213cae41ed36962e237231523ca63cfc0f5fa92bb39e02cb7af25e209d96a7250d188267dd343dffded8646c8bfe648b42deccf6409fbef38ad76495240d045076ec385b455d7517bc10c8baabf1db9b9c9b793aaf1897c945d59661873c3b4b38e5d58798a55a751c2bf94ff746240f3381d72710375b5f5e1bae2b4ddb0f86bb07bc7282c6791f6a7bfa5e996121b2fec41aa1370af1e8469baf337b72e0d08658ae5ba27467f194f31f168625db48823f66bf60688c43ebc0cfcd4215e53ceb96fcdd49c3f4f2a8985228fd4018e80bb950e6f1c45f347fdec98f06060d1460948d208ea1a09758dfb00070cbbf1f2c9989dd71693fc055655b1b56941f8d44a07e51dbd6d7156ef1b09a02d9b31d5be00587773a6c9daabbf710d90e12b4aea6621fdf1d883142abe4b140ef4d736533f99b5a9c6c5341c5fa62bd08b555bfa0e017104e4a6263b8c7e79dbf038f9fc9cbed7ad34c07b9b14630be9d97a2dd344cf513b3c00a0499dc05b0713671ef4d8ef97c777845e65bd89850d9d3bcaf9f2fe8b845311fe77755776e805eceb0738879b05f7a39e5e422a3b2c0560be86628b28878c9e0da0814e4292310d8dd7a61635888a4eb74c04bf06fec4dae1de10ee0bdffd677eed9e370c369294d053b117ea2f8caea5418f6dd06b961fe9f05fc612b806f38ba5a865e3bc319ab0eccb60a3f287a81adbf48b767e9a0b181ccaa72c28706055f3018a24f5b329aa4e1e1bf7dfd44238df08f9f8fa28f5fc79a927efdaab3b5b3d292551c10838c5ca16a5eaa52199135f13756ea7111e33e83a6aa28147c6d9a1222fa8df30c1df2518d3464beca61e6016745bea59c41af09a2c7738ecfd5a287553abfe7296a9e9922c84070409857c6f692e0b0bbe236aa92473088bef830ab7bfbb6525ae65138d5108ae309c0170e53ad55ba37ab923b687fa902b78c0529947e7b6934382f1ac7ed9251cb8145b188c5fdf2db8824071d58e9744ac44c4ce84ed01c9143f8698a9dcc9ce7a4665ab43281929672430be6ea854cf56e2d6f0a25254a0297fd4632cd9f683b2fb524c8410770dbcae62703aa6586ee24768f5018b0a15d0f73595f3d70e72f62819b5c187aa304ab13586f69235568e398ac85e8c0c007b5f867ad14a2ab84df55c4e2dff2c79bc05457c57f1efd3bad928191b3d07d38981a30072bb73f3a6f5070afd461cf1e2012c65d34aab002ce94bc764e78573f40ea8c29f34d94ae0cc9a4397e42a3684c9d24fd76bb75aea084029ca9029da1cf6e17db4e1f16d0404cd4993e94309203fd9f2731dce09e64cf4347dbcb58925a7bb0df3d58ebe999a33e22bfded103aa1170455990300990a14946443ad7fdbb95f4f63ac2233d5f0f19e75acebf2b6a7be90f58f7ff5040c8c011679a330a3e1205bf91cbc39efeb63e53425476ab60df7cadbb0073c61813d42502c05ffd9a2d305438eaa3053bd41c864d589fa6c7d03935ad69ca4435483351c878cd6098fb828c12a7a529bd15174a2f2a522c7340225af7caa13971f81210819942d226b72d46050072290996256d40250578ffc5165019b5f07662b8f3c3473e92b6642b54db1a94a146711abee7c0762ad84a48b04409a0098e82c89231207f0303bcf8bc5b5a4cb1892571b6b84da64ef8f9e254b8f3220395dc0293b66feea9a5ad6313045a8ca436539323b78a8dbfa11664f3ab807b3728928198f6a45296af6283f7317273ac0a70f117a777d2887690359f4bbf0230b2c3bed7209abbeff37e0697ce58fa2fd49568076d3c5ef336f4f02b90b3006ff3c5f0514c431b90108e5325eb1a478665d6699a585e828670dc12fe016af0cabfa511abf6a0ea81596836332508b8f0c57bc8f5e27d7b147940ab36b2aa79a521cd15c0aff2a288125960ed186264f7333a19759ed189af7da17712108d9d6e8d03b601b9e4061fda5ff5a8cbf07f870a3b0a5e1a2e6ef0d2199df4035eaa04b41815bf6b7c981e558668c6410aa68281fe96b3500d1e3bd760148d394b5bb57dded430241b95d7596af5cb5ae16b937636e58f5e752c6ba00f6f9fcd930841e822e0fe7d768ce36a22be31dbadc9491c9251291b6379975a33395e2ce89daa7f52633840fac7b835c428c1b202f005f4dc430c9e4d7eebebaeb7be6c6a13cb24e9764baf09ba7fb3882e2c4eaeca54989ed593ec017bb470ea98b366ce9ee1484a06c4174bee50c0a9010a6801247840406a22eb884a22a1a4f16b9d1105a1488bb1b74b25d5ad5acb5368bcc46ff39c6e2edc7fe7aec3559480f115932bd2e5333f150170bb1f95b1e02e8ce7c6ea295b97f83d22e18553e4418afac7ed95a64dbf1b4799ef391d4be855ed60ec3ce516eeb8a94d84f158a803c0655a4a52e6755c3cb6225e99c40cd43b672010318c0211e678dbef7f93d97d39e9c8c052515537119dfc2ecd80053ea9a8ce00eda571041aed18a8bcd419bf8b17dcaa9b2b245f3d68075ea2748fc37cf62d430695d38e49780f8607d3b1b7b12a0040cf4e0b8969bedc9bf0632778f14f5df61506065e76ab97ef3e713039521866b3cf49c07df8fd0e868d1cf3ff42a7626114450c244ac53216af06814405fb2a4b88264d3258ddb060572097c783e05abbc261205cb9deefc52885e897ca81de58b3040b222d70eabec30c360025ddc246d564a35658ba5fc38bfe3e59c85b43a018e144de6d143983ef41b2ef1a89b659e18b707a9e6d2e758250f9b0fe0b06cb6638ec3a483526edafcbc46bbde89ae3c02ee9ab4566355f475e8b20652a030a8cd3b3d1c6faf6a119bbf990ead4559548714e4dd4f471b2edae6a1726bd38664d4e378bc120e408d372a7f5556a33b782cd65d17f2e04f51093321b9b203af561f63ae168bf6fd3ae2390e58ded87a347285f195b3bd304d8433bb4f4d0a3c5f4229bdc6da2b021e47a5bc162122263c527991165ea8c0a91e301d80c82651600d9568ca349a9a3efd74f3622db25d2ac2bf01557b34efcae13bc65ee760eb1d8ca0f78ed1c269ccb29326d59500642e8e5247bbdf94e79da406f7e6f4084d8743a5c80fbf50db5cd10f8830ca70bb40f895619ec46083367e3e274532bd5835eb7abe5c918d1e7ab6f21dc8104024ba00897e7359780ddefcbc76697f62f75494a8d40da04254c7ce14f89561684819b0a4f41f9b42df3c00cfd4d6d3160362fcfa46e978e9789a34eb07ab35e233170ca7745891035718f44515e92f753057b8b95d2d1d9db5547e46f26e93b82c77aaa7469c44b6cb91db7ef462b3df46df31f873c408ebe76d1be1c1dd81bd7e3c223f6bdc24a20369e50302980a0c7159f7e86dfa70fb5324d6621a8e076da3fa507076c32dbcae4a3ddf0f0f3e451f5b4492703e4ac3040fad8a9c001f2795481520cd2c4ce616f7b760f02fc5212ae3fe9a1c454973e1795f2dc754f278f780f24c2f8e98fe0e7b54ef11f40b024883850f5221d87dacf240b6b64702dba6cd090d7273190172dae0b9b929defbeb39f899a03af9fcc4d6ce757912a0d68cb012d899e0fb606306076764be0a39abd860f995e9d4ba5ada295cb83bd88926abea6977a131786a716a50257eccef121cca78fcc3db9f6d01501a492c6e1af489f516c8c0cf8176c6dc02d17e9487ce6b7070dcf994e3ac7fc8ee8c2326880be216a52c18309099b89faec5c4b2d4e63e8dc565ee955b37e4187e2c3cbd1f5d8f3f019b1e33dd3275ff0c5a3f669efe8e82f8271cc27dd6a003f99b6cfcce8514c82cb6c1f13ecc06dade712a7eeeb9103560cad87d1f62d6626bc0e4669cbe428373eb2b53c3b7141bc9286ffa33622f9b67bc0d2e1191cf3f807880ce2281a335ba15d9cc3360accd0dfa8fd612bf07079c56b494eeb083e54b8c1205fa5d0b3ac6d33384c2679ecbc98adf7c49fbe1847383dfa02056c846ecc0d72f201bad0c17ae253a98634991e7c7b922465d3d3e379911eace99f80c51b4edbe4df0608c121303809e4198aab423942447dfdd70d46d250c0fce3a7b1ca4ec2f611710879ad25223e1fa94d87165822e94bbdaecb526d94a7f870065aaa29778aa80cd73fdc0736e977701f1063ee9f5781a79f47e3dfb608b16afe31b0e728d0685b12debf8d83037840c3124bc37a753d16dde69f7c77adb93cba2e463722dfd1b050a14b679f525b8568e13cc9512dc4aca9d79143e0dc9abc0f235dddee083b7d32bac7ecde5c87086a1c5a896c9e4d494502cf683d2e5bc1142ccb7417bb73878971330127c03d60c1685489d893ef0766041672bc10c5522e08324b110c47da4aeca2330d4feb293980a8f4568fdcbc6e1f3304e656c5458d8a9865e7956d9c320c105be86ec0fa7e9c876d956da836f9bf2e979f3fa547ffb986227d7d25391ffd28d834c1d9090336f81b10179681cad8698f63fd18732bcecc130211be303ae1fd67f4f8b263811253d753f9aec98768711dc14e27393ff7e7ffbc28d1bed585f61298a87305cf0b5f5b62880b8ad3e8411258e76ac9e22dc38bbd6acc9dded3497165fc64d11f4704798898673ecc8b097a20aee3cd2755d6ff5a7a9e3972266c4b40cb63650ef30559d6d1d38b13a6518cc39f832e39ee1b3c5535f40be393eea0fdfec1a1c21997f1feeed37a21f19faaeae3a29e8f30e916c626168f6d37f4083a5d35d3fd86f60729a017c17c9dddb8c3b8391b77299d5fb7f90b3fdef3fcf98ed8bec7f4dbe50b88d9619d485216407434641622e5c899c7b03b152f1f29198a15f8fa7a4ca066585eaa29398d311f02449966291f4ec3a2d319d35e359c1790ee045da4bb6d807a8d1702f6ccec37af9cceb9a35f460c623b9b1cfece40956235e9989f915e072cdcfd026ada4a039676227faef909a1838f22561cf469de816dc37ce825f11dc71b1f5b1db2a0d87441714eae0e70b9bd71021a614134dee8cd170ee3dc703f29e1a1050d7e1a31a56094c2ea728f7638c8c8c5f55a9ade0ff4fbd0052f6b7ef4a3884343177ca0c0826025cce49458e31d2ec2201aa75d089beabb2cee75056ed1be07803da0a34e55769d06ce6ddceb762fe035168b38825756e52be443e0db12bd182d3fc27ab75f819f69037feb311cbb3300a4e45acfc2f0d9e11b00b0ffd5b3902e9444546eafefb1e340ad977077a0f3f2cf2ff5b4d7d5a7ca4db3edc811cb85de4efd90ffb0dd736b3d9cc51f499c96179e7dd439baaa01e594c650cdbecacab297b1c2ee696d4790c58e18c347b4af436a2bea88ff86743b7c8643900738860dbaff352755a324456b47fe762cf2ea7c384163929529ce073800cad483652bcba311d7641f3a26acd0ef9b2075244591f4ace45476ebf09de5a16a7733846ab20156f15af883711adb3c99204357711df769e40596098ba6debb88b53da7fea6b044a06686a95890ee0ecef615c0a2dd42adc49571c566e809cd7a9b511e9504a60b7393c330225cdba8d941874610b07a99a1194ddb00cb18ce7c2507cfdf3b8407cdbdd5c1046238d8b752dceb306dd086f10a3ad89fad7e0a63279ceb553478844cfb400a387e3ce1e89cb413b86d0d0e5f509de32bb8e00e8b310d1beaf806d1add79a009aa2060989f9ba00daea34570ef1845321a30af2a45498a2458d61d0e41380382c2a8fc87f2916035e1087d90a654174f32951b83afb7ec6f0950ad5b3833e6ce9a6162f81978a0cef93a9c6af0880ff26967e6af3585d78b2690904c24ed1ed65c6b940b0e823e51998fdeab74557b9cdfe0d819be1d85909b52aae12bd24c564f54736d416051f6cbfdb5453dc969848eb724c7014925d3fe70806dcc58c6a3a71b168b64c830fd78db7a14ce893e4a47484512d968404771c7a1ece871ddc10f4e869cfd9b4e8c591788f0b7338ddf14c0149d07b438e2e3f08f8078ccfc3f84b9434c4833e05aac23de15a0c6298adfe4bef05eb184a5a3344f025c581700bb4c708238d83598d1270acec4a796108e23866a09f7c0b1d4c62c3a7132f79b0d25b4c9bbca208f19abddaeefc6076d1beb8159045da0c60be3e879760915f6f28ce68e7c392789e6df7a84572f46f5c71a36d3f1dab6f6ed5e93ad7d28132495c6d7fcd18f112a0d68025ef66c3b54ddeee09475caef652a03ef865abbf19f76871348b26c655ded7b52eabffecde3f26f896cb69cf349d4cb889acf3732715bfaa998e358fd3773f51515e93d1f94ebcde6610fbf496c318f8ceea20be58b22b632a8ef4ae4ec968aac9db9ee42888679d5520615dd172560e522e79c91b8ea56a7a1dce7c6040b8cafb81670efa4ec82f0261f172ab8650958b29790f0542adafd48b443313f38f4b1aa27b7d257b76de506eab2642556fca9b6da6bb840fb1ab77e3b20cc0ec098edba95df74803d7d1d6a8c786c33863c1852cabf408de0b6249133991376e76f1de7dffb01006f0f7bdf6f8e78935ccb0218398eea5ccc9fa0aafc8882247edd4c5e477c36dfe3520e30a8fedcc467f52439e8983ad058bf4a6f835cb7fdc3942c460f8d08d280fc9aacb9d66a9fd304143c813c169be6585d7353a21fb9231b5ea791f26505d2104a85ff396563f69a632b3005c339af237725dc9eebf3b04ec6199ba9105fb4fa6e720fccf2cc2aa502c6d730b2d3f39f08348d9de9b9223ed804be96ca91cd1686e76a0a37a04be1b6780113dd5a04ae1200299ce957e65f33fe91292b98251bd68e5700311f0a85998df1ac449d0b401ea26bae29390c03e693dd69caf310c18020a3e97fd1bc668bc1bc66a16e3dd3fea147bcc748014fba5cb72210c199fd150ebcef99add695f75b34fd4cef3f498f0a00d31165879fc110cc80c77325f01daa0869392414cba2be3bf978f218878bf83fef86d8ed309ca3d54fa9d1db1e595852936ca2437561d7085771fa7e006e7d4d5c9edeb54a5f34e3e3563fa28a4ffc395bb6e145d7d5246b43ca583328d44d8e383579c5ae5ae59e8a2c455e5db6ad18b1fe195d5cdcf41d0f00eb7c17e770dffb1a8e00b81259651e9e46244ee6b82b60ef1dcdd34c01904e7208114629cf228e7d465a2b7339d286405d78bf8dd8c854514d813a84b7f1ebd6b38e7bd538493096ca381fd696717e2a4378756f5060729cde400d9b4ca9f8491a7414105bf6506e1af4aa748fe1b633c0bc01aad5f8ae190435f1bc356ca1b7cc9273be8fada3c8f357d8a407cbb3bb8e98c156686b2cb48ca6c99dc6bac29185c1fca155490713e0b49a5aa59cb1637bf346b23785121f2723ea80e176c1435d071239b13be9d1903567d133d1959717eeec578eeaa5edeb424b1c3a9e9f5013a45b75d13c1b9cb79e119a8a70514bd8361bb211ed23f95f193021b96e1e2d98fcaa3bc54568bb30118094e62c924bd720189e6cf51309e6156e5b1217fc605a2ac1ce1016807c95eb98ea4a665b7f859b460de6da04854c4d18b0d56eecf3758bec2476ef5143b9f562932c875395d01d2a2dca21a0280bd80ae622307b31477d8498c0a40af384284fc8055e96ebe20ef7474cf9ab7c0649f82829e51c34919b4c4cc7cb91d4f174fe8c977362d96f7ad30ee4f72da53c99fa17fd45aefa0d6465ad59dbe929ac88d401bd51662222efb8855d0c2fddf485d99f9a1e6be04a21b366f6647de9026e045634955cdd227ddefd88979177de6fd190833460cb00f33daebc34c8086643143b1c5600264b221992e376e57f27013a070a0375c47529f487e507a7cd855b9454199cb9392d237588b71838dff28223d7d7459f48de325fef80e375a87270245cc4f420570513d77922315c6ca2c672825a1e2305108c34ebd20d237b1560bef87308b17cbc0eef9cee0fa54db66caf1272c3bdafb88eec080aca491744093909541cb440076ce8e9a2608959d374de56d4316111f42713dc6fae75cecb904f3c911f0538cb285c13d6b2ef33b392c64e762a5e5edb3563409eba4edcca4a053a83ed11b2789a59a6f2e493ef85bf4b818961c3cdc478acfd0cb49284c0b997105d611769b0a6d5b284555b5dd747f321cfbd35523388b98c26b01c30dd8ef0b65ffdb9a7763c74f2bd2b851a91341ca9272c9ff1c8228140950015de8dfe6ad9ffb97e7aadf9e541c0824c83a466f09b4dbd08ad2f3c61de8dcd2724ac162be2d4737f34c75d678210a4665888b913ffe38fb77153e9c5929bd1c55b21f0a4224d30e99b279c15ae62d5379e1e980f789f8dee766bcd15454c9862e972f7698845a5b90d1fc7af9e519a2f1391c3e62ddcc9c71d8d6284012d1bea1dac8d9a948dd75b7de20f3b53e4b4951e78d84b7dc04fe9e2014a6b068bd02a47ee3b392f6a37f758ecd9197d9d0682cc51acd8e411ec2a7f270a89bd797ee1907b5166e18adf545c7248664b19eee6984cdbf9997e43cc2727adfdd8cc82559ec109d82e9a50883a340b9119bf857363d118d837a1250a94eb6397b66b8f1a4f510d8bb4dea54477a84c48f13c07a9a034b99b34145122535c420adcc1b149ccea741e55b3b9da484d1f3faf8d56d3a832e6c7bc5edbf078766dc9dfab0259479b84069d5e894e7b9c5814af201700d40eba8425e1dcaf999dcdaa2ba3e1b0cfa4bac146546f4271dbbe7aa8bb57ff1e6d8cb577598b3f370f26bae8849d4071093703d681f8a0a567514e2be53db902f0d716789594e118265407dd1af7eb72d822fc8d6cd3a216a13247572216e6d0d669aa30804375def89f4a4896bc90dcb0c1e5e06ed4b19262711c6114c9f1e7997fd91c41591a655a85e7cb0663ee56fb614e17d31b97c99ce82722ba28e0b07301e1a2e1ae8aae69fb7f609c9127046df02d3ecb4770dbb456317d33ef24ad9f2bdaa2b2347b24d433eed65dbde786d255313d05ffdf87c08dd7fff4aa2ccc86c52bfbee699410b87d06ec922305fefb96145f365cde39dbecca01ff5f6b646a1dba4b643b494c9b04650f08eaaeeaf1dba27e891c7ce484535bb7dd433edd814d493214df792c94d8df8e472a0cf1719ca1dbc8f20c0e1078eef15ba9197701a726e26cd703d80a20e25c35468d86f860c313adcd29893ad1b97081b4b0146c84dddb7e978382fe90d5b8d4870e9b22febf745d6ea4a9592f67c21f672944eed669aa813cf8012c17f2407d4177679ca041af8bea55dd2b891f420c6c13117db92a29e4e7c7937f7dbbae29b29adc748f65c1405f0fc691a6dcecb67882f30d1c096d2de071ee5dee0f9472f00478b4d1ae097291c2fa019dff58c1c339ea06922ae43e9dd0c0dc0947d65b9819fb5581479d142205d16d5b8f43171da1604be3237b24fcd294a8fcc6cb42237bb5a055852547a966212274c10d86ba173dfe498ad6157dae7aa92dbc880cd68115fd1b6c77e7bbc8d1a1bd88802371e6adadb09b332c432973eb002ff800d2f3ff543396375719bcf9507c72e50ad41d6881dd0dac05bdddc2c657c74e0d6583e3cdd7b02af676a80165f9cc868e41dbe9afdcb08c2e8223d9dbb7779a16b6db8162ae9e7ab31095034e82f090af16640fb6075c78b45c0f3f946442595fd88803d23d7f4279e9899eed3ef94e60f5e862ba2281ac7eb7a77e3f2c13cc2273d8a864474ddd4d045d8aff23cf14a6f35134dae0334aedb1197b19313f8b318a52298a66e2d25d01a2ea575804363653c2e2d223bd9a75acfa0c39681f70607c869609c3c31d8c0dd2a5ff940dcc1a4d02184a8c3cdec9b39dbde4f7561919df2caff43745ac420cebc567bee115197b5b1e044d54e76a65171a2296c169bc8fb593cfdba8ee0d12c81b562e03fef31072684f5f59324f5b645ac9615a7cd59bf5c204b66f282848e78c28c43c963330b22f6e784bae5e44c9fd9c548679b028e379d0fb167f3f8bc475fe6fb72894abcb692d61599810a254ad93a732887dac886dc53556fe317732fcd326f152a8d9ff2ce92fd91bc2d0716eafa21519596ab5dd80f351775dcf8333bb834ac98f86208d26566a31e210540553c056ce4f72ad64874fd9776661bd617521cfc8002333d9da555d4013f18360182821c39022e042a86b0783ca292cb5d956415ac2be061e2a147062718b3c4f22a80afab6c5a7d570b66fc30e2348b131b28486567106164e2690f6bfd997f16a2a155d83855a5a6defa5533806807e924a2f63aae60f8b2ecd52d9d36f0306a26ea2046ba6a2146ec8b2bbeddd3348387e19ec76dc0cc445af54f7611c37827dc2e636b95d4ac3daa36c55c415098e76da836883d28958b87f3f9a7f0946145e3885fece2c15d66acd5e15e7bc2015dcf74ec4ff2011cc2991911b2fd5c5d04bef8932d48e0c551b04cde06ccdc7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
