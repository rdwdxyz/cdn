<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b2604e308fedcc28fadb6fd114f206a0b5e442b230cae1efa435145ef0cba392e1be0b1433deee356c1684219be947ccf9c49826db77ae988371c955ba1f7da1fb47ee482646b507eb36648b0814ffc16a411839db92406e81b3a201a721666da2e2ec6618a4bb3549b4f695fa8f3346ae19132da52158dd107a0b89ba9fcd2da004635330705f8f8b6c2dab8500394cfc2a75628d84dfb44dc2b8ad21628b7364ba47a2ab36b2e25a6a044d9508b050bac2095e32df9a720b41ccb17e81016807a6a61254543bd50d73eebbef712ed360ebefaccc17a33a8228564d88578e6de02fcaa775033ada45988cb02a582e8913cbc69e61f5ae479d0d27caa070f9b0189b3541a8e16ff2ea9b503af8ffecb35e11c7b8775906329763e74261c05d7b53fde13eaf0bddf42a5973acf36f40db8665b8716d38705fe00739e4c6bff986b1c14adcc0266c42a2f1426542b1f3c4887efca2050f2dc40f6537a2b10d867199b57c00065770a60580a9515561ca4d6ee62487f66364544b5895e8665911a8bbcc3e6ea126a02e02986e7c5800a958a571addf03a1a570f67912e4b683f5107f1f3dde8b9fb694bb9538278fbbcca3a01029e99ffbbd5bb34de4ce59ac54fd3aff5cbddd2553608d06f8268fc3e2fc4b6b228e157e1745cb8df205ee930717865dadfbdcca01dbf10658367149d26feb13a3776458a7ec4957dbaca2fef765d25f9746a35fab2dd009e4bf5cc0a7dc9890e21a10eee46baf587b138ba795c5a6ed254707a4ff10badc6100cbd9f9dcdbc9bc6091bfbe1185d9aa5077cdaca0beda8d1e988c37fd13c5a8db87343b18cc8cb092a25795cf87df2a1c5b798c9695ac8a9a673d8b512e751b06401ed66a069fde6cf87a09cb5b440a25b6454512f94d7bb58849f56a988f42d60084929a4797d127905586bb7b6164efe784e90d947a91af036efeab6036d14bee035925a78bb85914e0fdc18c23bf0c84f960ecdba913a1fb8ead40e9647fb28caec12035ac2e1b7f1c179214b016aeabdb4d7d32ddc3c5a8295eaf770b79964fbc6da2b0ef325301ef8ada72cc56ad2daf000f1c0972c5eac4303ee2d9bbd98f6dda2bb9c42d868c7e3dda1252ebb141de8553878d42d250458c1c4b0cbd09cb66c8a144ba46c6a89768e98fa75b5f4797197f988e1bbd1907a0372684becec531ceb49042899a46604ba0d45a25873d4256844110ef33ce8b3686bc48dc32658b7f0724e647825e10ce8fce8405c812dd2d61d7831da40b36cf7f6164104996591cb061a911d800d36e69416b638ad88e6fa5d3334c5298c05c8dc60985db822e2da8b66885e91881d0b84d02d3913098f779fe00a7b45c8538f006ad793f3194e70a15cff4ff659a56e698971772cb3cc3d085ae648d46dc602468d46d240d87db27cf98c5eb9cf076e3cd815bad0ab959b99bfd7d81481ba0e56da9bad8aa22267046b1278a8220a69a03ea5ac488cde584706ecd48714f3831606a7da47866ce81eeca033a9ae6a2b52e398ef36b0de92497171bf79217071d32c67cc01c9b802b1a4d61ef88526a509b21f141bb279e7fb9c06cf6a00c834410a670e9a338e9a629dc9b6bd32dd8efb6ba36e636af55721e6728295f165500715b470a537d9adce5e316e545e9f5e6eef14fe1184214d3e7f7f4b17cbcc3a788c13bae395ffb9035ff4079f8d9c861c27e09dd950ac1d8b64ca0b78ff444266b91ea24c59cd73db7b4b2123c0aca14a082bccd5de28f9bc60dd159cb50cb30f9168e137ea9838493c4987c8461f33bd1dbde34b3879e8c59125ce7dc62c0df93ac843586d9ba741f86f733a5142bceabd844f3d6f95495a9de41c1ade79d5d1b0037d8b06806922a70b1474abb2a61c0097b8f976d559dddc09a612a5e54ac1e8b7fafcf7e2ecbb004af64f772d7b9cc3dcd02d5111658d9f2232a68929988ef5b001ef386ed46b16ed6afd70786f3db369c533715e2c34d8ccba7cf20e581fd687bd374ae4984d39076a4b7efca4d2f162c1f46b65c7c800cbd00d7c12f1a678f9917d5352c334d5188a6a17d62d36b95377a4d4644678a0dd61be6dfbd3141dce9c16ad3a8198109713637bf257b41fb47cf159133e13bd6e4ca6e3ee6bcb1ed2e1919eabea022fbdc1972dc47d03fed6670beb3c1b1feb7bc99d44eeeb3b0be8e08c416a92ab96bc72fc50906bc210e902344fa5e5b0938c61c99aa3a9f19b406129344f9faeb56c1625eb2386a790bf1ab56a78ae333ccdcbe2c107d48304115a1959f15146017b351fe0be49cf7042b2016769bc51a0feed17e38c3d45eb22cdbb539c33a5d4b0bf50482b80750b48425357d68af153139e12d28444735e7121b8f20334bb4d893a9322a73468770914cc79c4377205aa85dd9e37ab5fd645573526f973e3e1358322ed7f43ccbceccb8d0ddc4ec1e8ed1ca93a9f6300d9d0f6ef9437640d780f08485ee1bfb08636d2bf97be1b24b2affb7e6bbd1cd1caaf47dc8416811b50f6bc1d9822e69248590da02ed3f4799ed14711a125748538412cb118695b7c6b8bf1b5227cab235aee1276f677ff1c1f7cdf8c2133b80f87a1f557a48f28f96248e66d398187fec60c47e36e8e110e114772f5ef207636908a8079aa4397f3c8994adf0b853a84f5e26c268d0cacda08a3fdf6d27bd3e4b38c5a2cfbf6a44805988b0ff074ff1c1a02b98537292f26302c920de8addb7fae8d2358d8b7c220f55bebd810652292464e7a97bb42f1c769421176885ba75d6c6ac8ad544efd1c6c2aadb251b78db9d85bd8526a540e04a6d5a4a3b930cf4bc32e239d29cee01f6dcbc33e358d89baa70db9da28b325123aeb107bb8bcfe651f653035df39af3a3b0de1d3a022a89dcff548638f2dea5f114b3dccfb2b4b385b2fb59dce2a0c716bfce18b71ac47d31ce4a31c031d8c8c6281ecaf5655e3c5ad07f9348e6a4e754b88ddbd06e7c8925aae276a87fb796a0c03a8f5135f22a0fcec1537f2ef176b83d94f4fa9ce6631d8277ccafab9a59ef65a1a314b6a8980b925c930e3ed3d6236df64f8252b0d3dff75bcdad08385422ce3d3e34104a0bf5c8f819e1627c15456e58005cabf397ca80ad6a8a5195e882cc9c7ce8a6869a884c406459a0c109a83b5939b4cce62026ae802a35709296080afe1e69d196bcfa56bc1a1944eefd80fffb23c21b9c71e0e83a7ab0c1e20c807a70c27bfc782f203f962e1be14a24be9c0a2471228f4b9f9b560b14f6e5f2ef19c5da79feb72322e70150275df43b83f6883bc1ff49f767790fb9882c52f73c963fdf8267208add2a9c69787f8116c52d985dbdf0315e04007f132f961697b1d9648b122b77ae6865146ea86b156fda57ad38acff17fc93c25ec71462146c850c31dd6851d8bd5ba2986d387cfe0f1bcbb5331c6865d58bddd636d75430ba93838513db93d0d7299297aef61dff69fa2af24b58aa7369727b17481cb0739d3a0517a266002772f5368042138c157fefb908236cae5bf3cc74f5991ea7a6187b12e9ea42433e88309fb904771f20fe5730c5f90c6909d7052790ef99bc5b3e7f198c9a7484a3b27f2c95ef00866e5dba27e9c2eb9a0637ec80b8754034be867cffe0a69e5a6759b0e654d9d255f7b3fa424296bf5491045125f91a945520b0759ef4144694d9f3356483a3e3354e9c6727180e11e5cfe1be4137de88867f4cd3b3e707d3e9a3f09a3646df4c2d4ff612ac33380375a7e9a6371e070d87dffac983835a40de79e1b4a1a84a83de47c6f2623261f6e561995ea49f9b565b68ac87a6f396ce165c1977d7b445ca8aba6defe00a636f88a0df6e93bc432d324566f8a6f942ad36afadd4002eaae13b0e25dd8ba778a8b641a3a2acfcd1ef73a7ec4b727c3ff348621507a2d981c37bd213c5ef4a6dc574de507729f44be3fdb8d8d157fcaf7f2b865612af64f1a9039706a022e5c56724013a35b4175bfcc37aaa1725785bc5b985e045c64446c7839c223dab1ff0f711cdbb42b3497bfeda0dd4899dff20dcdb5eb805d9ffda80fb7cd5869cfd19f01e5a0d3e2a70ba04bf35ef88674ce48e6d70d6161816ac16b71866048aa53581368e64450ae6c9773a725c5563123f0a60acd3c59b5f170f7245d50b666eabcc3641548ec231ca821bd6e44b1b84ceeca05a2263f5726027c4e484416c0892ff0a97fb677c0370ada327475a062854e4c8beca524a0c5417a7f4708d08e86d9928565f6699b4a3c0c15059987372b40d0b34f1c972e9df9f93d1969ff9617418c2bf62c70c844d3061c6d39d0941a7f792b4ef4a1468205eb3d7a78a12e6eb3875e8c4ac92bbb3e3c62d0e6ff0ede1ce576ee21810b76241746a3d9e1d628f80891ced286e32aa09fb844af9a23cad6a164cddeb6db21aa3e7c8df3b199bc00c26b60620c705b3e929913edfae3a6cdc8a4b64fb3f4578c076cdf121956122edf5f37a60a738da02e5f6b367557473bf7f38918fbe7fd46ae298fb77fe56ede281f424745dbd0f5197ea1809da1059abf86d321cc679bb71938d93910ac60745db6d8ed5e5d77bea0600601b00bd85ba4ccdecbcace0c69f36055e4bf996e977065f2a2f523620947ef0a85d0fad0b7e9b8b29e3fa2d19092948ab621ba422db3c03aa63a46d43a7888319ef50e5ff3360899fcd08c539d887cdfc8937abd92a8bf3872c59541ed677e877a544e6cec7ff16a02addd89eccbe6c13c9a8d6b77a85d296e69168848c6bc552d62b6a61a3ac32d36cc398cff3f1eb499d080e2431c9c766f1a94a68c5f121bff4b69d1da29ec560914814d2b1be9527cd5774c8de4f370de823520b35a76628a4bdc83386d89a94a664cac54c1fa2f64bf793a1de00015ab48f58069c0825049969d41b6dd9a6991e9aedfcd6bf679d514fb27ef2b2a2e5054110a47372839ee3b7a3cc60a5298ee5b89f5959dfda865361b69869ef8ea15a18557da78cd6a7e08ed49a2e8311e7742a524fa8e3e92393f3447bc6829e81c36de1b1be787cb1d56f94bf352391b9d4d7b8991b1c3247eeeb264ef9592950deaa887649cd071cd220433032e4eedea8b8e94b3b6eece5da951a5281739bf98106f1a411e9535674392dee08a510390f37406ee82e382fd0723bffaa91a073dc98c79aef39029a7be4138d04c418295188557eb6102f30e62d15e5e04016ea4ee331a7101ab8650aa6e8b7864999ff112cfbad624b6444ec1879c6aec4531008bec2fa2c877d15ac5c88e8c0eb54045acdad61b9f58ee9caaabc628235d458283d059f40239dafef1a8eb0231e5440f5c1a209229f5433f1bcdc826235d2e23004ac1844126edb376afc17bcfa19b6da8b6386142781d912afa7af7fad9d289c0488ee9927a299aa828aa86aeec4836eaca5bb902132451f696c9fdd7b58f7a339c43ac8e8e8d9a0851a1413832902c0380564b08f8edf39566bcb53c9b6fa5636cba57b37ef1ba22a0de6c827b5ec2b704647a7065c4360d81b22e7716dd91b0bd97c827cc733aa38670b86a8390b324162c77e2732ea3c02a2bd7c8752698a30fb52c1521bc2474ed0e621927100d1d0b934f7fd19921aa57369268b041f0e702fcdfbd54c13c64ea640d86b5ced80e0f6e82a9d3c6cdd5f73ab410ddcf0f3aa5a2cbd3d7f078a157eeb0b288153421b2350e05998f6ea32f95ef1cf3977aa95004e863875f6fc7ec6d69637048f8a04223d278664c75bc955a7d41a25d89ec8810cc889d9cc6e3fb51904120f82dedf270ee15ff57661078d65b5e6f0fe0ab80e0519843786a6804d450de6cd882abe48309b5f7905e1b7f6ff0f742e0811b03f429ea4e3510971010d72aed9685693df6ddfe56843e80346e7d635f19a5bf6d73c9d9bc794d74eb9db8845ba10bb29674d25ca8918bb8fca5d77062e47365a2b964cf7364b354caf2d3712f7d0e238f52a0dd6b7fe4add0117e001579b25b0a1f3fd3395cfea30c176d531a00ea9b6689dfc940944528cf4cbc03583418f9aa1fa8b363e06070e716632baa5386f33d1046a8cbd46bfaf644e65f7f20996da25b42f08cc38a63e4deaac2ad4819f0f226cbcc78905dc12b3fbb625b1b111d0e29e7fdd97f4c484d0e62d260dc5c52b9b1e68d44ff3f295585193f7e7234b9ed5e2d06480ecbdfeeed3804ea13d915bcf182d5584eb200b5f83cff123194c0c0c323845f4ecf308678586e258e2710c4a421357469e7b43c952790bbaab167e82106b67656fe11d5499f3baa9c0228dfe709d53b1701ed7e15692256d7c29e7b7e7a352d4cd1d5aee03175721f1487fac970a4bfbb2822ee990fc5b206868aafa6d9cc78e8e65f7d9c06e123b9c9a47230c7d73bd88172cdcfc1f1ceb2f0dd3ec479912ee438e3303e9ac2dc50bdb39834fdb96bff9f46c9c0136bda826c957b4e97470cd49a7738a597a10c624dd15333ca780b5aa7bf1c99e3c032793f9883fb5be790c65f1fbbc7c9d1d4a15c59a45dc406e024cbb3a310ea1bf8b41a818bb978365cf341e28d86a149e3e4cb5b8b40e828640b4e4f2001a427d85a96de44458f9ad60dea30af947dd2b1e346c21565fd44db4b5f0458a64aa9393191bf10c20a044442912843d677a603ec2dbc1b15ddf2d0c525b0d9d63a2c134bfc8a2830f94057c2c37d0c6a48e9900e5dce6f313315593a371e84b8b780a3a97ce28a112e81d3d519d4dfddb70e7e97940236bf13a2fbe30f9490488be46104f388f81abb47be58d0e3b6039a0314deba565f0c522d621f0bc0f3eba29b6d822afabaef2e0b443415304d1561ebe0d2cadd1317f56d22d0db9b5f5e77024845685bb0f9a66c9e016892497eeb5ef9b767d4313abb993b202f8a883345a85bd8b49046b6b24a86d385e3bd7cf2af3f7692e2bcddcde276dc80d7c68f8acf6e895d98dbaa30268b43287be2cf75db369457025cb782a47f8d69dcb19f35d0511e6ed8e839dd4bc780a2592c8e24c33d55dfeaeb064d7719ab0b1ee45da112631e1ffe6952a7267a24720b58a75b63156342254b7df9879a6812e5c33fb5e3b4d890595e7017c4162b3fa84cc8a4711f16550ce46ffe37bcbfc182db9d49464e8072761790857d6c19dee80c615577a4cf736d6a26f64867e92eb636fd326e667e7af8effea622c6995c6cbb0249d4b2a61de683fc956dd6fc9558bf4234b5685afc5e69e4afaaf08b169fc0c8d38f8fc70d65683e9ce74c4af23ebb650bdd1173dc2745be809d32b5b165993e057d93ae99ad713f77a637dfcf78dbcd91c30076cf5bf2f13cb38da9aa245cf3a87537c2b03c41e2c66c52669f99875033879724eb0d680a88ba41d911291bc7a80503e7fdd4afe5695e38a0e660928b60d2778c66e2b916e2c8cefc564ad19dec9f9850ad0bd43cdeb68dab99b462e5e89ddbe9d3e6ac47bece851b6d9ecca0a7a37f189a945cfc48c60f54dc15b8b2d23b94a0ad067078a1f4ae8b030d8894a17e2060a0924da37f1b685cf70840e1df6963f18cddd9cd994c9395332f63c5212be4ff0b25631d9376707e9415c874a22f80a07b6e8eef7571356c1923bf87765b8fe4fbda73e9eb944d31c377b527708d4d6fa565508df256675f4db265ad9d2b3374d753d44cf3788cd6dae51844ea08a3a1761cef49b4d8172d74b6a920c05e59665ce0cd87c36645a209b5a8077a6007e5b7b9dc02d3b22b5811eb77337671c7041db01f61809e3012ea2b59f4e8146a25d9dd76beacf206b3453fa88a924eeda33804820b0719c888607f0fa2ec63b8e60be4ae7e77842b0c8ef8119459360d78f26260491061c769a1b4c67b2dc7ef47075133f5bc235f60a4541258c42765e86dd77996defa0c43bca2e506935b338719ea5f55dfe0b631e53750954f2eb8f69c9e0aa6e8760080ab65616a9621237894ac6a8cf0fccd8019c964b69d000189c08bbecb7649516ceed53343e67b91ae1f44b6396697b8cbe85404c92cdd2a059c3d783d85c95b57ac6eaaca5c8c3a19e15d72580e179e2223b2ab446e56c4a84e4c8503646edd16f513a146097a441ab5613a4e07b73da6ee5bc9c0459160cda6759d987490c4ec8f0a37ba3eb00bcdf1062088f21964aa365c1b49c76f054566ffb5ab6de09517ae110e5d45551d03dd86d1c77f3697aca2b0de4545b471d08832a264d693da3fce9c3b5f69d1629b181b08ce20552cb156e13b07e58ac1b25fe61ae9383a6261ce941f4dd9f0ab09883a8ada5753af4c33f1d14c374e9dfba933de89c746c01417ee32252e3b79f6f8753bb603a3c6a507cf56afc8ce56e1da00a53235d4135acabf63688aca605c49b26162f6678d2f6272dee6572d1e2bcab2f674698015064bc632831098cff51fa58f7974c7193a731204997aad98263ca3a51d6ae74ee8ac9df7ca4582fe3a7c206f13875b6721bf93d6685e483c3fed5fc7e4e3de712bfeaa6bff09dd1b672e2376a04574825847948b941b9ac7a0ecc700e4454f98ca1d2cf13641d3a9a44e18b95296a80bd426c1bfab2e9f8260c96c64990f3c4facb806227d3e8293dad355f5321dd0df4014d9ff30126c0ebf70d43c4c12485d423126d0cf8effc79150851706966cfdb21ec0ce8e3354aa5e296b704741e9ea671eb5106b8da0d8c178c3883e20da89b911ede20c93d060595ee188f4fe1e7d7cab7188dbadf5b435340e6e16ace5be2106b6da1a0b7d3c183e05fa80fe596347cdaf2fb6040820f3dad1c170ff9c19e16621c9f1efed8a05408f37a652e8e77bbcaa010507bc8499dbf1c11d320d0b8085780072cee24f1717670b6180ae03a9585ae6f8d575fb595c4c118a717be10f559a7fa7b5c0e023b66fd2d4678d5d7225826a154d990b0972f731a3ed38e908de6160fd31af03368562d207804bb0ce04b66fd31360bc727b60a4471c687d1a66de156943887e9d29af3c0a6ad37f797ce9e4ed16d2b2255a8b47ef5ac02726cd5110465372072b27b2c1d562f679ff576c9387dfa269b0925dca6dc8ae156b2dcab174c6e81f3fc1faa8695e88e4c4b1459cf7b585f011df66e210eedeae443e378abcf31da3981ba3777388c5d3095d3fe69c5fe424c24e44105b44d42beaeffb9b54bbacaebe26e333b8dd82e209cac66f53568f0524dbf3e5ba62f0ab3ba8b3e66a2a865fe74ce88990eba5ca01269c2463cc7c7b22dba6138ec61bc1e124712273062586d070f2c176bd4cac4b107737fc6877fdf258d03420b574183e99167f94058b2e54a8779bf238298849a87ed7c08453721b37d04e323f2579872cbaf9bd24a78b31ea70e180fb08acd3240cf3de4ad6aad05e8332f6b6fb4d8bb0b2f5561551e6e22f7655866c0dd1c5e71a21955a2b9e6928b2e9d54874d429fafd5e61cce505c13f2046992be239ee84e6553e41bc2cc4d4625e4d825ae17d6cb15350d773a91baf8e64abe9bedc4db8deccaf16aa27d7634c52ef0fe9a6c7ebe2803a36859d9d09dbc8725b2b7dc3a19167598af9f7be6410572bf59c3f1e2518922cd10d1ddc71c0ace18cc02879570dff3a8684b187273bb408f046eec46b4b02bcad1ab9b6ff5f3654c097033164575bd306497f78fbb1e4acd1b60a1affa7b263141157f5119e9ab590cf034c43d99b9699a127d7502233aba857f422b916cac8f95b6c06dfa14f69bd9797a7f23472eb18a0acff59e10a33984d333529f8a94ca3dc262d54ec8de6261a2d0e2b3342e016688055e1254a3ead131b61e576c5d376555769b58c407caf6e549af6daeef6883d1daa88905cde5db32d3a27bc6f97c0bd3206919486ae088bfb4e0ec69701a181d300f446cfa8b6977f59ec2c0b36ef3902216fce7ed3217cb1c7ecfc5a996df7afd292e2d868d9b48bace1298b5ec2598f6e782c76e7dd1642b4998951748d0a04e2fddb994df257cd839f02a94808749ac54a665d3e1e8fe1af5fc43575051f8706168fdcfc63a29cfac989aef21761fcd3d53cb1fe34dc66cabd705a84276e746a81f1e17ab276bcbd3527a607f71f72686e6e6b35feaa22c111f50b661d09abfd7ed65d0f03b9cf453962d7213e83ff60033b4a2b05d24872db0cad608e8740b453046c9c90465065b95acde8b8a4b149f039adc8ef4d28a6f3251e86d47c2c63ba7182d462d8126d4d861667df00c071560363d8bc7cfc22275fdd597d081c03d86dc98a3c4cd1de6fbe48fdd1d6c286f9768f011265367b37a508d6120d6e142e558221297f3e788bf72f34a34b162400b953b7b2933ff6acd837eb46f9e40a6d54d670c061815a5ab75ea05045aec08a81231141eb4388ab82c6d014d64503908e2f9284eb9484c05ce7784694245920337ffc47db860373827455ebb40a2bf7512dfdd42a408996f929bed664646b262b32d15875b8dd2f9f11718a2dfcb511f30a673f4d3a62479d962d0e8d89fd994ce848ed0cc73636bcafe14bbb07b786f6211aecf6f532c37660c18d46276873b86fcc2b80b3fbcdc1999fc3c97b482cf1c595227539687f90c6ee234f01e1ca633409baf687bda469c26abd4b5786f41eff4bc1e578eefdb74b459536dc060d259e163527953856e6daec7fc30a9a4173d5996b582007ebf1de90de73fd5db952a1aa0e8ee015de40979e86d65d4a450f36da8a16c0d081e8525c94971d73b6aa000107bffa8f1794d955d6c7a9ffe732e04f8a8b1e9026f2d5c66858436a0039a9a0e03e238b5ded4dacc6dabfca1d6538f2365ff4f4743c76ece8ec107090c427dd9e1e1e8f3abad2f69d0753680d465a8490d71d800ea3d6e2c9932f10792d668cd939700ab41ff8da83500cf3a3776e528df4c9c3ce30d716e696891a842f4415d98501eedf63813e55e7e256fa50817a927e7d464cc175c8f25beda48b8849cccaa8f7f2d62923867473fa7101563e45c421ca2cdfbc79e239de98910058bbd6f2b587a52f87b21fef41bafba97106d91bf30c7414dd502b5aa72b67262b59c1310ab30bd24d08813e47733f7fef00ab159125221e197a189ac955aa12a0f393b60dab1a5a3cb6ebff347a51987c06f6623739c76e22220accec3a77ca2a717a00313316f7080baccaf3427382bbc1d59da3ea3931e021e6cda415bd5ba6453d3c4e0d9372e0d5b495c18e90c0e7dbeae3244ee6b4262e0bf3ca6b74ec11669a9a18db95e638d1ab86b611d770469519177a72010c11766e9040c3abac89101fe637deca8c7c13d4b7915b244025c0248b6230a79e8bf90cd329aa4bd10e5463c86cbc0f3302c133b819f3435ed7eb7e66760966037f99bef6156c2a957afbbffa4ab77d649b4a30899c09c27500b5c03c57412fbd9038768fdb0f0fbc66784be550bd24a79acea8ab549365295ce6e72836882b16cd476b93db4dad4f3a9605f1e9ba323499fe66c072ff0e23a827c4dd50fe8d80cbcd3b045f7a0a806e5d1444bc58d7459f98f104fbf5c9a7d2fd60421b1ffb827e1ae9e30105f6617824edfdd3569eb5d09e23875813b4c122cb06a3aae1861a1f6104e4c4beae8e6511d73b542e03e39c6fb8562ca4a0e3d7bd15e7f54b5b800de891d82447c44167f3e32029ddd26f1ed7b0919ca9e80a6531938770032c3e3f548cb17f30f31373ed46ac5bca26395811d418c98241e12a43c156545480743257dc717b0ec161aa916a91a6404b17783da11bf4de0615e03d801427635fb343c0b478c1d9e8e676b6a8b53e22ef13223b3a338aee1a0b579e058d8ad3db81d2e09e938e2f8d64ab0835a1d08faed615b04a12d27ec54f4150e74a4de9de75589d33d9df520d068f184136e33fe5c544707117f13d13bdf0d3977a89e9a7f3b32b55a589436ae60e42b1f6a12242eae17f21061168cef4883ec3a08b606eeb2231fda31806afe5f13b4e961379336973afb377efc6044443a4c9260d0cff649486ff47b7cb6570c8b20754b3b765dac7393efad5175aee94a5209af81ec319a0da1ec85c1cb0852731726637065ef1efc3340cee7372382bd2a68d31ccac9c12aacd431f037b3abf479a4b37d4c5109c821535c8bb9737df4b5eea232d79b0e68d039b4efb4f873a8dd6309b7ed1808104f6a066f6bd9da6b389d76e01820700e727a95e144c585145e3150388f80840621c9a609cc41c10289937c7b3331c00e5550e7559ceddc45624871a96ef6b73660903ff479df17759a89c2c4c5753846b552474a7621cfb3a6e572f573b82e2a6f58fa77bc6f598bc25bbdee571172afe7e4ede7be295feaefeb737f8303c6f3a301d58e5473603517741c1a70b67ae29ba3a4c36e1760d9ba280114eaa50817d327ac577694bfad688c298a8dd1ab3ae143db9a36b1b418d2dcbb2072e02c390e8dd93ee8c69a844ddd4704d21d9427541d14f9e17b7145387dd8a26fcdb8b499c42ccc36b13a6fc42634d7726de4bf81c43bed4cd6524b28182cc27f69a288e6517d213ba8920e8e030d3f7033124499b7c97ec95c0cbffb7adfc99843dc6a827c3f3bb7be41597055bf70efa08e537ec8db68a24f51cdbfd89422cc120ca4cbe397cd44bd9d1f20d82ba870e60fd6c15f9b93c389468bc854a33b2124af1c68727882d5dd65bd1318d9a77eb75f4a6cba3132458962c336a1c448299371baed278f66081feaf2766e910e361ea011ec468377dc3f4945992cc56c302fd94b4371cb087ffec6a1062fc570df93e7297745f43afb4774841f2157c8de52201203817cc789234e9f41c9a67c133f19963cd075e3bbc7b0443e013bfcdb0e6efe5431a0d5ac544eb764b17456c3e378dbdfea7561d502ece73ff79de4db4ec378706e168aad4d2c0c9e87f843f1c106dbb6428b4801e7116532d44f578098ea4207c76e330212eb9e509319a84643e8f0e3f54d456db302332adb5987cdaa008dbc27e4909d80ed75fba63ce79171a3f8c5d8361d51680784402cc07d2a1349853b167e3874317c282c126b2fb7768dbd7cf3a4db4bcf0f8fa29a0db151fabb6e914471b0c2ee3862f8570f2a25b3410f84f8b0a5984ab29e0f88aefa9d663a372e9bff8cbd935290c87f5a356d6ff3843f78a5ae4c57c83b53cdcf5be6377712b3c6d7665fb234353852d447e7d82c6e4187a81d43666b7905eaecdb7fdc3db971f62b22f2d018f2ec525c87bbf902a342600447030e17b812e8e3a9c7ae78268f8455bf145898dd12d9e3e9361c3ec0ac5060f18a1ceb8a05b9c98e035b085c73705fa47a291164315bf6435cea70fc6669e1126330c8c45c9d8a51a05bcbaa136f50b846186ffb05aa61fcf009441d6a06cf12e90662ac3a868e37c86161dab9f3f73be9bd0e001b25f7b09d8b9d15b3ac48aafdeb88dca77afd136d45d2519e8b41281254a0260ed8793377abe66f06eb2a34443949485a4cca62b75faf38d8195e8a24024bf5f4965b3575b5586dbf1aeac920fd900ca96837a57d5b2bf3290c49bda57b088ac73300e12b575574fa76e5f47845e4566f11b07863a2aa3d6d49a4559cc00cf5a47bfe1f139bfacaf87e61ad839f7de2323823cf37cfebb833acc238fb7b3305f5f42ae9cd576c25a77301f6be96c60ddf835ab37aed184a1b2ec6cd245bf720fba5ff836fb0bf1218ca7d58c8878414e20032cd3f2a505c1c8c37eafa5857d7fcbb13b4119c469ff544322e3f0d4159d0f9dbf834efa0548f99230c33db89699d407f9e48bb31d0ff777573d85da6f82711dd58225532497fe202c6eaec145c1d5efcb17bb7b022ab2568bded9b5baab4850d7877a708dc59dc6d620d8900a7d327d54788decc87e13cda09809bc8a36174c94e9a462b08603168fd3f9ba12c0fb13558e15c7b2896428669f36912456351893e4e349e705479b6d8a95aaac34cf160da6f7106f1bf538a22f4dada115a7bd49020b854a730cc207640fb3a388ab2d828b72e86a6154e5d8724f45cfd10cb2ffa75470efc3b76a38664ad856ebf810def02b5106c2e7a60d8a884a437dfd841798efe6461ca906628e2397444c1180f64215ab9aba5d8adf0ed5c54a1ed89609c4ac6bda9393d34bb73c71f03782e9e884aa3f72f6d891540112635cdc729e4ca0e58cf777f233867fd5f32b5aba411a10b16ba278c483e18776ea3908d9dfcef08634ff086a1d11f923e040faeaedfe90d3cfb34a68a914c7151104b91ece5ae2c7ffa72789b2f027388982ea308b3fcb7efc89ad801f2b8ffed229996d6a50bc61d95e261bde63b5eaebefde865d5c253fc9471b4bcb9a334b7f0fd6f8666b22744f91d30f7019f64f350118c7dedc047593e691c0ec57eed864f7c9e82fd1c59979b58180bdd92247f601831ee22cb8377501d2c27099a922050f11d350c44407381c5ff79ce94cb9fe2c65f1797410bc04d40ccc6b7e9c69d66e5873e227d0c2d4770ca13c6e602d1e68b955a34368a970c5680f26b10bb16c30861bd8907d444167eefa4b067cbe02909ca58f4c8c32b9c342a317271237d0b7689de9bf814c2d9d090c388545dc414c338ec25c1a5a4c67d8f585a555d1a3f84f9130d4f52b3f657ed615a66484dfa25ef1fbdc83a713691b7be001a721c90a4629d5c3b43e25f8bdcfe3db105d3fc5ebbbba349e94cfb4808cc7ddb7348e4786e672e92ed043156e1ae07e247e188c049b2ad400e365620f96848b028b189ef2da9a5b32c8fd51451f98bc5fe4f976edd6957303514e967121ed982059e5ccbbb3335fe5a1fade9c34abddfaead04e4375856b9b389abeaa4b6fd3059eaf8b10663879eb173678f76139d4b56bafa6dc5dd7c051801217c98630319d3936a37b7b6065a6f10490de008305ea5d96dea31a67fd9445fbcb052e560a4490256e3fcb17d4a854a3279edde8ae145e03165dd79cd585b121e0bda5554d514e2ffdae2fd27778fd097324228cc25f69927280dde40df5693a9cc8a7fecdf1836c46cdcb34e8612e48a493fd1a8dea2b26f54bba94d2d7e14cb25e5c9c4e624d42df949caf593a824e248e4c3d57965684f1508427fdbed5cda38659b318b139881c7b824f90a1b842e7cae3e2c76d9e2ec6f8f7675aa334e67fdbb3ce896fe3483938a7a100075932222dd3ea15b1fa2b293bf9126c5f5ac127d504bf6914719b276c8b3b882023b9b4bd60de77b1d8ef46ed3be466bdd558daa53ac6c84fd0c0cd66b56ef7fed821d02c7c2429e9a72ccae9cef6adb82f28247a677457918855cb038bf0ed461edd33bee45a97a8453135b212506410b3456f05155c9793bcc0e375ee2063b2d7410f74933a316f36f82566fac13af66dfa250de6db383a1efae190f835317ff0a69f27cf6a434ed945aa3be6065b08a3e26dd80d5730dbad8509a4d0bd3ee0f2bae6a16bff5702f47001b971c736ff5aa602814850416b9323eaf8ffcfb76136067e29711228cad0b5142c9fc233cd7a7c45fce899c6a943997bb5640d4dee43e181315bf41a6bf4dd5248ab714044118b20f713cf1b34ef7e21efec7d5c7c733042f9386416a15197ebb8b1e35fe9a883c922b0c3d53c9b3403578662b5c8d284f2697badfde1986b2f9e8f36c9adf19bb51c4f094144d0eb83c277d031c57e111485d7c28b36f3ec78c1de4d393c14dce09513717688092783222aef83f0fe0bbcc8912c5f8085ecc0c258f9aed2e31652829bff842a4efbff27d7e101c0605e88f667f09ebdda1d3ea179526e3b4cf50cee4f3131940ccfce63f6ab6fbf23c8ecb3fbe0e17484c5c8c2a5334a0668af2b98470b3cac2f23178eebb77d0ea7ac8f4ed616f6e2e2e76464bbea24cf1440f981d673218238388e328c76324820ada74524d092caf1c533b1358711d387f494e306af5df5311f9e6ed4e554a1ae4a567bac51c2341785725c783c038dd68fdb4d1033b6ecda439a8d9d5a3359dc028b3d719f0ba6a7d9992cd4cd00613a896e902a5d13eb73e8f476331dd77ac4ad1ef7e3d0a3fa7f80730c18c818d07d31eeee113262f3be5a9f33a532d8bf79b5b02813697299722a1419a3c3ffda9ff573efd188d1473557d39c289ae76e2cd801f9d9586e9ad056d12378361281beb5af89a73c4a94276c5750f2624ba779384acb9f2fced8cc0a856e3d8540587592ff668ed466591df5bbf6f378eb84ee7f1942ef4b76cd85ab5c7690bdcda4bcef3768ea151086e32918dc946dc57ce8aed6595344109fa349310add0d16cd82c1f7593c0c6cb85845a3799050800be5d93761c3974fc0dbdf24dd0566591f159a93822fb27053f23ad1ab6a7d46af215439b276499a9faa801dba04828776238f7032b21078d249e1321dd5f21abb1b332371561c4490ec894f99b05cdf3b4821824073bf7cebdefd05aeec2c8dfd8d16bf17d68d4b56221d134db01f97ff0c4aaaadf5ec3c43794fa8bacdd68b42a867e63e3868c0ce87726687a9c4f7855f21297c9d2647c4e98c5abfd15f497c9b595603bb7cfe372c4fe228d5be188ccd93d7fc05670064267e8b2ac61b1ee13edd969d9b83c6fb7ec2d780a9db6c66818f77117587e3a2b8c51e6e8758f73d605cf167e6501d2d5d2256839ef487423a833ad52ad9ef04d7505764dad342a3f41357d2f984d99dd6757eb70bf7e2d55ca606381ecf435a772327334864f27bf6c2523b007eee0b0e81768c7233bc39c978802f4e53cdb2823aaf41480ad1817872bd9952a6940942ac1f95f6a935e0b4009f8d8dda2ff1647f1e0e8d887742d499d696a67e4c23a3449fbae8a61d863b31986c462fcb7e8bd5425f3734263fb070bf6d959d66304d29b834e746d1a78f336a8dd652e7ae2808ad20e18a8418cbcbdd32599924b412dbf176c854b7e21547c3d7b65af9057e2ea8234eb95d0d3838bf00e71e3defc30b39b6166c13b9d57bd6896035747e47781828572595482070ffe5eba12a50ef6da42eb6edd004e6468c5aa7cb0012659065784f556c8ff7f1d60c639343863ffb6c221ded5a0fb1af7ecc90665623f621cadb6e45f378f83e46c15254888672bc104286c0da16a167150f668f53ea64ba2d67b8d5c63b2f78cfcc5481b4da708bb77dd3800c6a4bbe6582b26067e9ed624c5750e724ef5ea04583e4c2ffbea952a04c3dd9bb9cb46a076d807279ba935444762c56116350b22801fa4e2afcbca9e8d325edb184db08a948d106c2394d61a780b17aab17cac9c12c758c2c83473a99cc6e39249d0995b4e2a08f9a13371493c6388ab036aaae634f219754abfaf42ee85d33836813ad1408e13223683c96d767878f35da50c925d4af8cdbd0177663c35dce3d6b5453a7fb9709d5b21f029010c1723216776daf9ca0affe3a7ed0913616789db212335eee7cea68ffe9339b09dd5a7316c6d5fbdb5042e876c8c1e6216f1ecb1602c2de65290978c422c92b45d1439607cfb73eadbf9326677a2341fff048ffcd4adfec8d2f423d5f4b0c9d26e861ae1c4e5a36d6ac7a33ad93415af2d86408726116c520047cb99379bd8c2c6abce4397b15e6015687a7d1675b351c2959a063ea4c34be0ec2827886f75d054bd7addced3656ddadfaa1c9575cb348ef95f88eae1b0e3f58722a167b5b953485b6164239413e66d5e8be2fafdc867656415b16fa6c4e17a099dd0a3d1dc8b68dade11efbb470eac0376cd33c8714346212d1991920a455fa96cc74fec325a6b78782261e12273d5290503a02d52cd4fe61e9920a1acf763ecb5e8285e9b48039250c2b599a4acaf458f0912e52497b61b6dcd5eea4c8f63631903a3dbf56450c368513723afe4c9753cc7309091aff306daf137fcc32ba5e792a0982ef065ad2b91247c2e1819fcbf7da7e9ebcdffb776c652f480373d21ef1575ee6649fab4c7aeb566617ad5dd5a0df2a5d9dca0fcdb0f6426eebb3cd902e34b0054448da86d7fdf873df973f64dd919e393ebf096bc0c75442bd867d31d1020657478751bf230b16b6be7f1fbf7135b4f434b7233aad215c960b567b7370b30b92f5c658e792ee5d985c41a0e916951b49abfc58be4b6cf2f019aa38a65d174cde7566db568f989be567cf7924ead85568305e1c34e1269069","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
