<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b004cc0166b6d0d13039d5e5b8ad3043bd82611654051aeaa3edf5f4772de2f25ba8c55ce172a42d0b2281c3d5cf14821b3550333500ea810f1c1af8e02207c38024176b2826263fa3c1be77dc18d41268bb6adfff2654cac742645c748285d7281e552383d42befc09f30ce098a69eeae061e2469fc8ef22f66c6e2a4d53225fe9b3cbaf7340dabbee2e24802657546cbd39ca09c3dc639f27f167165ef0200a6a05f924a991c92492feabb169e92257aef308a12ce3e8acde41fea6f6e3d37070d8bf0e32a5e3517d07b18731c5d8e4bef700f13c1d9b748c4b45f91f7f3e1fe6dd139ac3f26b9f9e534a08e8c3b7558416ff8c707e1f6b4d97c6af8dfc35897aa327a242e6d57270faba834df5b8cefc7dfb881186993f4d47a2fef9fb611478d24bbd430e7720cad62b4f44888e56bc75344ba17a99d4434c81f16e019893c6db2da8440f9ddc0d992d1a1fd91afa47af558551af1e89d6c7984dca6c3017cd4d064382a9386389921dc43946f73e9f74518fe5f3934f3d89ccca405a478f1453ff200b3713e18091886b3a10914724dd7bf7fe20cf73a2cc7b187b5f2d0903c8419b29680122369508bd13e4d974b7fc6e155b6141421add52ec9a293b818d49c3db6607ad8f985a6db4b1f02c1ade7e541df60e89d7285d7a98a3ec50c31602ca56a5e3389ae777eeebc2d1358eacf06786853984a98049acef02c5fa74f13725b3cd118086b29d939cc85ea09e6a3a5cc8b5a12dbc67999388df1dc9dde5c060a059426c23b0e3fddc1639789d331d2279150ce287851921bc4d130c8b33b78c2003e67ed590b64dbc64f0c57f84b5157e20ed654ec03a34632513fba8d7f723beb6895518c0558a63c644b25db3ebdcf5d2502b6dd44952a55fe51259d846bc7d3c747ccadbbad18defa15ea674ebaa8511c110c9f7041077f7f77b7fb65e0f32f4f303733d6cd01d6d4538dd5a30aa6d122364ca01a17135d923ffe728cd295e407095467c77237427b294a10fa9ce9c50282163cb6ad28664904bec8a80cfbca050b9e37270c101db1af62cf9bb8458f224c92c3388f573a26a258f06840f1e2d4c51d1e21edf7bcd4580a264f8509bcfab6d200eb1895b71be1c6b0502db7466f7f403da469eb725afe4b7c3ebc7631074b57181b975e16ebd1ecb661a57e61abcb9545aed338a2fb2cd2c56cc1f4b4ce85592652e1aea3881fddd834acee77231aa4159f88d79b3fe84c09765f71fc2a83b35d97525059736526f688fa65273a1b6081f2ec55a59dc0d7702796d2b1592af51be3718ff39b7d329009f9bf986be154146591dac57cb0f6788a8d4cfbd23bf6ae0c13d03846b33470c83a449d3d0b39bbe31e51b9bf25803df0da835a94b9aea7a54b9666005d9dcd78f278deda41c7be80e82516200cca7a1a00fd993f92ab47f64392f9749464deb041ab8a59a199b14452e035f422f5ee848d29a385a47c4e64591b36abf40e5fd4949f50b356a1d08a1d4f32fe0c6460a167bae656abd944751bf29f0067da115e9e82ca7381b42f90ff6dd7621db855a0b384370d6b614bc001bbb5d9b0d860f171fe348c4e500ce7cdf73893a5fe19b1fabfa6e1db2b1543d9b8267e9fd9ecda8cca1e4f703e55d190923836ec7d1e108c3c7bf3660e9d07b92313f5bbd12604fd60aa241dd8a483103a41f263762050a444d5075ae8fc5c3f4f47fa71ce4ebb8f5b0ff50b78115f777556bbf5a7b5339e723f4e062a693ab7877b7f0a8e1b8d4aa1d46e744f76d4e99a619099b0dd9e241d26fd42664b7b9ae5800212d67235fd9db100fd79241c003a15195599ced6c6e12534a751c257865908f518b632124450cac1cf757b5fb9120a0dd35857ca3fa16c7a860d330642fe7c4c76f2c116ce0349ee614478d9df41996ad93488c7f0f5762de3773dffcb29efcb4776a6e3610a0f2a8ba4d66236f5568fee3528f9d0ed7b9accdb63b5a9197bc44c8636388a10bb1bb25f38a3bc46c6f797dee16d94bb0d1d18694ba68c347747e36eb36a2ccdbea673b724de94cb07391abe0214e0def4e9f51b4e1050e2d09bce1b8d222aac31edde226790e0effed7d6985532b11972f7434186593a302195704aa15bef997f68dd69ad0fa030f7e7e5b242977b23400ab7a1392a00eb1e33c9c8012c0e097e10f23bb9299058a4ac9bbf005e79a198e43bb29c36358799532cfff26233fd8da2a82343d03d1c13e4e3fdabda4f966c6cbaeac06c1ea33efd034da1b9456313a2cbaf7ca7e843da8e921b39b6facf883405f701d19cf3413382abe4abdda1c8da330c26b9a040d6922908b5479b59c8708d93560745b596c35cc7809dc4b565a65bf0c36f6a46ea39b989d437d48b2011ff3a37d03690c305556ac6db02610b9979e449aea3716f90cd63037ef8594811e035de22a3e371d43c8cbd5f8a00c72e82567c4292dc5cff329cff9779160854bfbbace9498801010b1260ec4b5d3b707833f3de25f74721ef3131aa963ddd65bbd4f55cc0e49ca2b906eb8922c3eef7c91316c1740f2d35a31ccb6c40143f7c70ea0a62395074a41165b73495e03cd60fa5569f363c2f901c95912e12a89b64221c6b4c66ff52127841fb9f8e952d83d40346fd77ed1c2dd0c9433d2ad0db5d6a55c657abadd8c302959317c2c266eb567f775a033d53f5779ba007fd1d2c574e701da9cb6499889349055628ef57c4e612e5333ac264b1a04fc023bd69943cb39ad7fd104a05ab3fab7ad1a9e0a31bb8f5eef67f5792ed780471b3e5ee18ac221e45ce4cd0f4c4969cc7b2d4097083d3044941d31463f4b7a676302f993adc99e22faaa60402409f90458ef596a7c7a603b33018fd5620f56c77ec16940deb66ff2d897d2107b965a1f1bd851fb2e7e13f55b6225acc1b4c3c62e585abab69abd110bc0225c1740c05dbd2944b8538415fcce49d0bd8fcdb88f0f451de71cea9ba8c9e8aedf8966378d253b2205f3fa71497c68c73986c94de5200a4e68e8b5951fe8b447e478365b849d487070133119e028cd9570d90f14793880d708939d5c08d6ef83ef03e13a5356ab44a8ad6223e0963f740a2afb25dcd20986bb767f9b05c5006843c1092c1e3e051c965c08acfce281bba9bbd5c9bea3054fcbaf6eb784b8f19001d86416152b124c82e28076be7e2de23fc9809de6a8d4b1b3d4a9138b6a1c0af7a287de19ce71276d549b56827892302b19b7709e0de761e0d6257f51ca2f4b4115c79f2c96640bd0669552ed85654f3c935525a544c0d6959488bc6ef62e6494c51f20d79ff7ab0a8e7345a60213556cd63863c64d2c1ed66d713d8270c9db9e33880d54952fb97358c01068ff95a78b6165f2535409fd27c8706c666886a8dab3db806bca010ea3400b52b356013634f62327f6f8f5f368e47cd01c9d5c7e401bdd50e0ec0f99aef5e377fa6ec9d21d3ae2c4d930212488dc936ab78fb626d79a1c9153aa6c5227d7b0cc0e0002ae422c92ddf15d5db6e918da77a32244bf55709c80af1b3b38c37d51f6424629a99e648a64ba977af019853038bca66ffb6b6d2894de9e5643aa0ad573c4ca9921591339512a6b6a8d8e8a3708ee0c302fb282ced81d8a9cab1712c648ca3856127ed17fc5ed49bbd530cb78629df459d8284134e0a8832e354c5d3f29c82e45e67fc61c3a219fd1a02e78339cdbc9220e3d2a8ee02bfcb8cd55f5ac4692751fdb1c21996dd3eeafadd5ed8f8d1101cb99946e8fa915288ea5c8d679c443be76f0763c583b288ac249c3906f320b5a82cbf52d469cff57ca106c4e01b425360e043b25edf76431fdb32c1649a2a5710642b8ec122c3b74601b2560ba45e1e3544bc95a80a94f623bbb0b8ace22d63cf1ec63e333d35949f0c5681cdf272e332f97b8892c521f2631ed27711900dd1b8c9672ed8f62bba7a630f28c31169cd641df5314e4ccd28556612c5b07cc7d508afcc8ab47a906930718f70dd647e8d1afde7bb28d7d9f43e0cd20861371ef2c6b299a1b2d926319c960d811757dce74696680aa63b2a9b89455f084c98ea4d82309660745d01939676e4e02cf5e67eea83947d12f3fd45a965dcb96b2bca27c15773f04186b8d38c4d2f1ac3eefa2364f959bb166c1b19ebcb37ad4b55770f07e4f84a95f1f9894451dc7948722e44264900b1e6ae06d6443d831c2210634be1ed8620b3e280afd059fa91d8dfb5c3dd2bc576db9b959b5102a60fddb0c32b155ba24ac0f552aa00f80d94ca2495049ce47cf2c9f62f316c845c64402e0258b9a9e24273085e95a514d3fcc41d72f697a89bcb5f028ee470270fe0f1f85c835982e97b08f231759f981028671ba8f8db2dec255a8624f7a5e4a2b6c50d171f1aa840ccf56b143517f2c03edb675dfa5124a3ff1b090a16c797ba72de2af9295ca78d07dd930c686480199ebee3b2168f3e19594c6b6cfe64ad65a76ff320e68aff8ca1f4e66bb7c1103e46bee364f2196f8e319481cd3e92380654d011332abd8cb639e18fc0e170b44d6102990a10ceb42f477126e62c87cd626a88ccc10da7bdaebbfb52557c1c81fa305d6f5809f3e245ce24e694441423318173a640d00ec42258bb4bc787f380fe7f52e2881d968b039633826ad067eb38fe451e8fdf0cca7a824382e0418d1b30a4bbda62628ad93770251bf79e053267ebbd1fb63aa869919ba4b398df29bb53f810041f6430e68637bbd6508ed3a97167fa42804e1465f5f9fe7d9bf8aa98b1a837cf353fcf5315edce44490dfd3aba045b7f23b633b5e731227f03ecc79d6536b660ad99017ec2c009aeb928cfad3f70bad4d2bfb41e0649443752bde927edc439ab6adfe1fdfa009c923d1fded2ec6d0713a18fde7e5645de10b81bef6bf2887c467033839854f935212ff3dc4fe93ec45318784463ad3c0f46a0792b539571fdc6a9f369c80e9b64a8fe9ef0a51a4fc54132aeef17df891f83fa7d2c4b04b9d3e3f875837b649f554ff52711c47aac06a462d00f8cc30b2662509b249cafee30c0b540c15bae8724ab27a1084451c50c1a0b43cdf7f4b0d3581b41022dc9ece7d1a0f2e956f84bfd3c8af42907371ed002144981ff1a807af490798f8b6e569bc5bea8d9c49f233411187534f9c17c3a3170926fa627c1a325eb8b0fd5ebd047ee3fecc0bdb8050f6b002d248452ec768f6f50795e7f59dcd2bc96512ce24f61463be07face4d9deb1ebf1e89f7ff7089da7465347e391fd7002fe6274fa21803ba6daad9ea2eb2d2c60f6db12e3465d82fb20881ae05ce4d4c59cc14b7e110fd2ec9a8230d447957c365c986f2318913a5ff54835304733537cf52c6b9737d675c484c9a66d2bac30dd33a8d1138238bc2f1e663036da906b79b6dda09602ac649a7b37af07900d5c4d227190af3234c59573f18f824d63538a5fb0217455f66a317d98712c0d453b0c7f65bb6f235a52a990ec386b50615827c9539657846a830e90da6ca5b35a9b821b8b2f9fa62a3561b4334452f2e328da35988faea7fbb2250852b21071602377dd30e5206cb006bf432445d7d36bb392ae5f5960cb4ba377668151ae4ed3982ffb013af6d4f9f8358b7a228108f5042ea576e8da35c89d4cd2748ccfe5dfa5256f3957e653cc849ebd81618bf99c0611ba1587e580e353d8e2ae88f02eaf4d09ab997eef348c73fd9386e0b937dc97dc049f24826a8bd23e3f8d6107f74f2add3c23a11d11bd80fc79ce805890f99d76269d9dc2a13de169cb4aace6c832c9573e968099d2849e92f620a29aeeec942595652687e1e94d305af819d799ff646d798ee18d0686e567be767e26800a8aba30ab046e7685f8d08205e64f9f93f370826bba3f905ab37ae0aec947dbc67a500a54b07947aecd358e3bdc8397d6ea5e95ac3641599f684467aed0c45222068a7b2b39eda1a5e967a547220133c56639c737b70fb880b53185ab3e8b5b0f8ae9727f72472d80dd78503cf780d43e8709a1ecbec11fb3136a7f40b57be41ae0d354924759d2cfcafbf5c14e6781eca9e99ca2aff1ab48326a530a1116d6c91eba1eb3deb667c095dc2a1b83681109e31a9c5e453aaa0345390e817aca93355e14831982df99a6c827d0141a0b04b2f8690f6173222c1f3e2af0fff0f9be5369c3d55fb4d0df57c3a08cdcc23a4772fdb846b3822150fa8f20dda68b2a9fd769eddd5af35d2a830cff47e45c61e3f804c0f8a14a21aac4a68f3f3e2d94b8723e7f32f7f4a3d04b990da44b7ec244f5732d46b465c45025808a0a2453909f553316e35b95661be74ab8192888df109ce4f449998b6bc3f55570f6014a5e984cc1c707709cdbd99b012b3b0c2c51e53f8163dddc6a768388372f4b99ddf9f47822866908c68ba723e30fc099db240cd0d08c913417ec9b65c577335dcee3e839ffe55aecf69d2c6595cfc6d8271af5557edd8b0334e2163d4745432b0830c48652d5cf3a764c118af3b8eefa0724ff0b79345ea4dd7c8c1897b5bdd29821ca4d6cff577d9f7877fd77de456eb0e8366543b097e42afcb5c94b03b2cd4ffe090ad3c1521687d3ede36c54273ad81ab189d844a02c8512a3b13c14e5c8e5cc69c1bf21352a96c1c08c06fc94d73110d6f697139a1087c3cf97f32821fa6cb1b201cb436a0aee62ba3183ca8ec56a69f8dce3a43daeb3965598ad31e9b54747e0cc582c87f34a16033348fab5ed8ecd63d9f696e9aef32f1691fb6224a4bfee39508f7e73f9366cce57818af41d055115bd426213f136d21cc975729016d0b321fd436ca8eb869149936552de95a4a61312cd27080594bbb61497cdeea324e261dac6a679ad77321a7a862ad9f6d617378d61483ae5660abc7c9b599ac75a36a54e7fc9dfec6248c983d835c289e9288373656eb27d2d55f90b9ce71437471b29fe9cd1bdff3c1cc1f831ef73e7e8cc73fe5c9f8de72c8a5ea21b4d2211a3d437ea19504070befc34b19c23d1b763ec99fc6d0c51b6afeace3e947caf9b605751da310ff23391dbfcb537a7cd2ba6dbd1065539ff88d35a754771be3c6a0099d8f0c251b1b054210731d4e79d8f37bca409258024af89dd720ffa7269146b0ca52a9254dcfeb14d7801e6530aba55758ecfa52f8368511ea95299df6ab6baa524045369377eb006929ce4879b29128d45e89eab5a272a32f3b16a4afc960ba1e165db352a517cd68ea1c1b689f7dfda1c2b4ce0cc94079ba78bf0803b7c534967f89d8b454e4ba236de4365b1d517fb4a3f4db7789d40250ae205d15ccbaf0ffd376e7d481800bf77474403d90fe47647c1f0e9cf357f5920f647fc9fa12b0f5ad47ca38aa85715fca2975bbc5e3fc32d414b8f4c76b89db926b56ffec5ea565cd54ec15cbaa1116c85feed2533cd0f751b86c5c47d9489aeaa015185069885890ee1a0fafd487d35f5ff8fcd8707d07dd4429a0720cd7f2e99ab7bec1d2d6309f18e63a81cdfd62670ef49baa8f5937ade808b0f17915a901e097c847cd04d90e09958e7d5174037931cfa6a184f1263b8f67918a63bc59fe7ae51c8df93f98cc6008748a145c4e5dbbf5c3ba5365e7561b24dd199e26fd744365dcf66240f7f62540f965ff0d9a17a54ca507e0af24a463ada3ff3138a0a7dbd119d43598e4449a6a4afe60354da6484b21fe8affee132fa1f61becd3be7f3a78523dd7b7a20df237db7fc8bc7e570833d020fe83c9a11282fc55a68d32438048f6bae1133485c1b34c424bafb1521059c0941bdedec47c93568899b0b2f3950203459ffb6de60bd443e5b2f6017f7c08130030c99463f006c6aa0a0eb03d05b9bd82aa819896644a568c428e697bdb75f18987dca6fd8450dd59ec14b5c1f688e7f76bc8f69308b0cbf05a7cf58f4da5eb7ee94b6fd1a20b1cb54196269663d2059a44d27e7aaee510ed98b30cae738038782e4ea21ff8927b53d7010a2c827c7eefea9697a6d190c693fbe995b8b107f63c63dbd89384c2eab57bf35b15d3234c65f76a285b4fcb03a17fe6fad4d89658895fe5fffce507fbc72db8ff66eca25630bea158a86e37cad8a210c9a7a38c616c60c2b2c709ad12b426e7529d70049a5e2781f8df11087d6429366361f6c26c55a3eea2d0228df727a1eb74013eea5de94a3ee30af1bdb28d30c633acbdf224880a51c2546e2a4651b5cc7bb097512bf4b333350bd6d1ff53871524b8b7fa31e1bf1bcda5a8485b5abda0dba3128c5ca03e4d71307f16e0e7abb1897d16b11f9380746944483b822ffce5d2fee43bdff8087b182313c23e397652be99993a17dad3194c43d3aa55ec0752179128eaafdb0212d79e4e3e2fc5cf4f2adedd55a099cca0f23fcc78bf55aa6abcdca36bc5914dc2dd238c8f3554357572a32e01b21c392196c5b85187b336d1a9d7240c69fade8f1451e4117c81082af5c88a5a795c9ab50ad730f7a92d2a6ce19e541f245502d264658ace9a19bd369a5b08d8fa2c290a346bcca148fe7deefdbcbbaecf03939d4d230ddcce25816d233ef508b9bfbaca8d14b6af4980bae1aded7672ae406b5b6cb1483f3e582e3db636c70b3030fef43b7c7d06fc262a10b8b8b28fbf7687c97d129de7d76e700e505fc6bcd47f58ee403c90a554948651abbcbac9d3e23bd7392eed64f2c43fe172254da311db2c15501a4e4d851e953446de496d263b17e5f8db983dbb9a15939976914c216fae33397875c6d6a9fa229ecda6d813643079663e98c5fc80b5af96c486492b5e85a3301dfc8811eef7cb9322afda51f7c073db6e04c8d7ba0bfe8d472ce1b9e1a0b026fa778bb845b04b2df3a32769ed8358136b522f2fbbdfe86b858a8eb34bad8652cbb995adb81b418fcffdbdaae92c1bad814df3810bc618444e890f76c4668a29b953c2cd3d80f1a45434a7e5a3a207d3cc2bd29775ad8111b744bb5e4265d630741276389d0441594561363f75893139989302974c3fd46693355ce83fff4b7db1602ebee597fa774ff134cbaefa2f4009e46a627aee1c884d4c1abdeaa65dd28701fa6fcedeae0dc995232b63f5758588b90247d2369cbea1dc9ada60c165da692f8dc9b9dcb6a0974f0886d7b4376c90a3c86fcc9e821e4b03e52e1da450bd2e7711cef8230ffe1b0abb563a1c94d50bc65d5d6757740ae5b5550bc4f924a3f2e57d0ac1a70395f7529d9e0fc792da5b30dd0b04b3a47059e38f07ab034021bfca19bfeaa43fb247a0b774f87e2d2fef06ac476e18ae38b35810d9db1a2426a8fa4dcacf8b5e98f9d2e646823b0223219fafa6fb51bf2a6f4ffea07f1ae9f240a094be2ff9985e1fe289141566e47c891abbb37d72f26d00d0c34b23389260a1fe4724900a79be749b1939e2c7b7725d6f77008a51a725d3e033425abd43c30e3f428944e7ad3ce5bfdaee41d726f7e42937dfa9467855e6904846d1d1e53347fd38aaf9145b26817d7034802669ace689fa99dd2b872c9de31744e6b4811db890a8e55996494b93d1cb7242f98248e7eeb3dd5f2b83ecdedb460586d63b2de68889c6c8285345cffbb9c2175fae84f71309ea8e558a6fbc9d370f9b82cf458a2206d1aa6f3462e2e5482a4dd7b2261d004a17c9166bff57d23de9d8de6962a20f138039c5d2242eef22daa05f62db2f16990e5360ad202ae5c3ca481b474c9eba81f573b9dfa78802431f8c649529b9a3513795f6b184d387ca5112811e66d78eed2e27eb1aef00485c8b06e683c64808d367b3c3a82d44cbce82aaf5a6364725659ba4fe03ac52676689121c6f4e65fbb4508579f0d9a7ae3cbd39375620970a0363105692237459cebeb74719477649367ae3d5b4038e54fd9d62a08a150eba28a912d678d396a6c2fc3133679dbcb115e0f18c97551382757d2549356fba96e06efe8bf9374a053b347ee148c340e04ccef4bd0d4232d581d6801ce9810b5bc52526970c38d78997fb6a695bfa085121ee332c2fd63946b1bb148cc483ddde4d1f547da683ffc10ab890d75d35545ff40c437fc24969ef183bbcbdad038769b91188ea14e91e9115c456ea20d4fa3ed708a0dfc3d6431413d8d27243f09bee265bb0bac2d25d713b9f18f2e2d6976052f77be6cf9232fba223b00b330e343bed56cbc9e4fabc37a5389c99ba82f84442993796f56e7c435c96df6cd590e61be38c62fe9229e80b144d6c8b41d7f81dda77bcff948ba609f503b2cb3de81633b6c9c251e6bd1abf436614830a7426329d1f2e8788d4bf67a6d458d84d22fda8e6390b594f722187c35d20fd1d73c490b5fceaf7b99e27a372ca8020f846924ebadfac29e16bc8b52e76f8f950f3086f5a2eb673b9c4bbef2c7c2697779073543f4783b7f16e7a1f7a1df69937e23a1a4d4281113d286555c1b17379dc094ecd91987f99196e1a147ae935517a2e9f8bac7d701e538c8390639ae59a05b7c7df10bc03a965018269a248624fa138616ad68615b6eb75bda2e6245571d8c4021225744eee2a8e2280261d15a5129c72a0f36724f5ce77c86a0f3d4448aa1646b824c4959fa6cf381a834630cf3dce6ef066e66dfe311430366d5ba6099800787ebe6dcad09a8559153b4fcc7a45003661518ce32141f36878815dc3e3d3a246d926bf4915c5dd751246bf26a594872a1f43c072d9b12a4aa879fd08eb6ce4f67628d8fb59b557f91232ae73d1ff499d631a99f73e5f28239d2a7327b680de0d4d3aad9f20686e4f247cc513229f2fba5574a0dbc575f1cd621ac4159e2bbbc35edd5fbd1c8481f8d806d7a80c18d7820217e25da24702d3df1885f978ba3ca9fff86fffbf2d31b8ef768afa627d38ae130a096918db1e1e69e8c06e02d2df72a8a21f732016ebd1711cc47126ef8c17a3bde8d7847a63c9b843b7bab9decd4c78f07e70482fae16479c5a87281f82487168dc7b8fa0f4d75b7a14025ab824ee81c7db7a9a7b9e8396cea8b079ce1058afa250c3711ab14e35a75103a37f7caacb8525cee36c1f4707178f4d420b6626314797ff3ca21f00fd4deb29cae3880ed6e4860dabd012d13f3b1b5ffd3d7795ac940860f2e49f96efca15be4b1d1e430b4aef08011e4268d3e3233c09e74042d70a37b94ed4e9a6f08b84d169655086dadd8a9109e0c465b8b7f9ef3d5fe541678733c54c25b2c60b2a5268965eef329ade0208b5848d29bb1f32d016f345fe0dd2add2927d19976d58e72cf601acef95ac7807ce0a4b3dfb69a04d79195550120f7b3db734ad3208b6ed3343c9cd4211aa8f2a171197e5cfda00383265b1f811c87ec9c03bad7b730d409e0fce45bb0df4032859cf03404704e2a5b4f609496def36bc51496073e4edd9334fb1d3a6d759c5f12c385429554fcc13e413969bb8c61c2082fc26dbd4d8eb1fc34a24f2dcd6adf6939c617af400fc922eb20a4049ad5efb9e3ef8d239562cb83018552bd5bcca18875aa2a8729e94fc8db632930805a7af750dfccdc992e4ffa81bc1890dc3df98187c2dfff7865f1c42fbef01ca5b96d4a7a688c8025c2701d7fb7b6b796a847fdd376da147880d49fed382e63fcef9e82239ba6fd525bd1759d2fcbb40fe9d5b704d7b66014ee3309a1a883cbc4b04f319c109e430cc1db67fafa741ffaa4aa14629f58af9f26ff0eb4986862e4bf95de0fc8de7f3afb7a920ac5384068020ed952a0b35e1a7aa53b6850edf3e50200818a817d8e17f4032144adf5e0653009416361157a790c02b33ebdfa9dc9d2c6d3ada830926289f2eec591783f13c5771030141c731a4df2c3656376262aaa55326e2c0dde69e78a1b5fda3fc2eee47c20da21a826e556f526ae0eda223e5ceba6c1324782ee09ac5b1aebc8697356064601862e78ffd21263487767fb7abaab641264622714f8fdc47f7e066d38b83b98636021399b8ed444158b279b193263fa8474028d69f80b33441cbac4f9396a1a6b663c167583bd2f1f802ccd637f4fab803ca072d4d44cc0f397cb5d77af2e1423fb577f77de7155578eceb20b1bf9329b79aa64abf2eb6b2ee257d6debb5b449f90ff280bf23e09f4aff597db9d45cc753b6cb12ba837492c3e7f316c8b05fa1e043bad7900994fb1f750c8ed81ccb3922354f2910b1ab8cd82d6d949d7392cc9b6bb3e7277b87c7b6347a5f2369dffd8af046419c53f567c6f0d0711739ce6c51dc0eb077ceda5978d124396839f95e38e853276dce0f7c6379a561b9860c12cb5b60d64d1e741f0adc238ac1202521cd72a0d0f5250f472fe918aa48450f923b3d442d6bee08d187680f42bfe094209e5f98862fa92aa920435cf4a25d71c77b714b687d8a4403b251dca42ae828832a181cf9a55cac22e6efec0dc02ed42143b412a493d90cb4a47e966872c5206316197a2935c2c706027796e03524a371c40e351d33dbacc3eaeb03cfe7a0ae378267daea4cc7564f149b7beddc6c4b3bd6b4ae1f58f35cb0067f80ffe60c8da6a773f4ecb44a8e235f6fbe6e8f95a839e75e70fda95c1443ebc6556404abce2510b2cc7d8c6fccc15aa229d6b33d928246a1834d8060fe97a92b5e72707d3276e0f00d9962a7061e8949e2050c6620518fb569f764d592e9e78bccdf3ac18535b6dd4e1e6689e51d0f454c4115405d9155353de8d08df8e869a0e246f64b8f6271654fabe1e91475dc86304f506ac60758eca058654a88c5c98eb5348cd1bd912dbce3fd007a21f2db2ad006f52ac86ce6e02f96e9f345a02507ea3d5f9bb31340b275da42180b6dae2dc570d16a72e97e5efbe7f4c6884e1b2fb09a37177f8548d1ffa7d84c3b106f255d92b49b1066381af638e1aea8a8e4567d2f4be28163123f47cb99517f2458226b9c50ed8a0656551aba240257a0b1496cb58740bea4d80a0ca2356178347ef72fdb53ed82a4e057b572ce8f9ba6c4bbe0f453b3e03aca36431c54d4d82245ccb28f49744d89d7517054c84ed142e92d0554886a87f0a15c4567df5cef9ca4c13c67e36da1c7ddf2eca06dcca1c64061f2be6b4bc9077361f8d59304d6ac2eb58a0e564978c40e5ecdb4b1ec4babef32fc8a66e8b262c69f213dfe44414382d2a245fd691b889497b338ec438456a5eae5aa0017502cf7a3d83dcf378b33fcd16d958a34c20eb853d2dd7e4eb80a6b11c9f0ac84d1ef4ca46e8dbb2af1f965bf80d984c380fe4e0ba06adbf33e13fe49ede9e6e7e7b7466b43fc796cac06dabcb6aec1190cd4d7da83ad77fc6ed88a66f7f6fbbc9601217a9991083a1ea7532ea71aabb76fa9d5ce61dd4d5cf608bdc9bf6687de0a08dd09af89211a6b07ae0eae27b44a186c100c97ca7e8e36ffef0fc9ca64c75fae72ca43c5a4cfdc17b62e28b84f8dc5bbd10a788a1a136b827acdf15b5195c312af2ccbe98790beee78c5b131335393984397c8f0204e33f68cf9155f6a40c27a419a3d9628bce239adcd6860c0c6246e2ac50570bdc36e33bb8489c503f953101f7dfff7cff233d700b84f0589b7c4004e103f540bec63f5ec03625dff375cd6dd5a7e63f16ac83a6554956ab4fa1abc9e04eb4fe523e0a5ca7889e3360591179af0adad221ff73717b9e5497a9e0b393005ba89ab6732f98a5609cb402ace08dec4cfe50db130c3c60525fd0f04be9ecfbdd99e88cb94b282b1ae1b60fb00c38abd41c7f9c95cab7e03e0d834c73ea86f03118b207cf089a2b0898d17d2f3bbe9014e13ba3cdf30b3f09a221c604580744be6d26b8b874599489c314729e4cb387a8ce6181f0e352410b80172e2b404f5a714fc7a749d630a6628afe76e07d38d7c30218b2e4f2c09aad1fd8b6c8aa3e5e824ee66c41f183fb8f8e64a2d9f2afd0a0052eeb1c8476f3fbc03118a59abc1eeb0bb2b380da342ddf27172c8f861928c27c74f448d70bbcf8ba5da5b03a64f06399d70465ff98fa2c82ce7c470153d541694a84890503bdd666aa7ee2ce11310d5c07310704b9b63b48a70ca6dbad4af9739d5b15173d9bfa9073f4ab63a23f647cf9087444f3e0f2b1fabf9145c80997ea5622fed5d41cef32a4b90ffa25134471b394d7da6434d80896ed2b485cd563c75cf8c3e7047ca4adbe72665083e1f1e9253ff6ac934cc036ff8ca723652ec5354b76ae7dc348297ef11394cf86dc777c5fa20adf005cb04ab65b097b4fd9820f493d50d8c42215f5f855a6532fbeabbbab07d0f6c23129aab8ce0f900d4b37b88f4e2a5795cd59372da7ff27afa3c60bf3f3dd75c4ee2621939922ac55ba9abd3663454c651f93856a088e9f6f084eaa6ddc49fbe08d773856b18890a5da8b7b28137fece5496da4db77adcb1339245d2c4ab345cd42d50293a11162daeb5e0858997526feee2426dc2668cd650aa3b11664052dec51cd8e5ac0033f69b7399e11586ea1fd758057b7803054283cd285e27b236476798d3f7aa07328cf080200c3763cfca4873a7953c8fe0e8ea942c872c40d364add5abecde5b6fcd5b7935dd3ed3461901a9bedb40bd448c028493d33a676495226258c38eefc25a56d30af6d7f6e2a84affd816e4d1e75a4acac07ade6bee8b7f3c899e504553444c46219b0cf61d8fd991b70ca3104b99d57d1b187dcc78c9218d5daacdd3228c3ffc537ab1ae724ce246f1c76f1ef676e8eb48e4154dbdd48ac03f29308a506e4d3e63cb2478aa8ca0412703745660f11a5946e180d2b0e32f08bd1683712f45bc1887af52ba36b14121c6992e6a43a3d07bc8ff18a05a2102037450a3dcc2f3a7ef0d153bafef92744f66d8bb9da86fdf9f0203967300fcf1619f2aca7fb358bf23da6cb471096d917bc32fccc464128d6d60b07189d697b1161d689b216ae46c7fbc83dffddb538dc4860a0e020e8dee3436267a4a38e59d5a04adea96bdf705ca5069c51b412aa330c56f2bc30325f4da537f2e865952c48fdad875b162b94ed67d793c0345e6f38a8766863e18be37e120d3a65ee3704886a36d039b22eb16da316ac500efd4f2cd1ce7c3414734525c84cb607e925e2d7b416b3ad573fa33c961f3a1c71a7869718bf533dc5e9860ace92b49038930e4616955bd9bbcb8723b0030cf59afba29c37ca0735d6e7892cd49f39842d9f8afe8a6ac518c8347e0d86a78cf8886e3ba4eaa837c51e20dea16ca6f184f78d00cdf7ef0e0ac69ef235660d98367cdec1d451ae8e636be018a8a87b805e1dabcb62766e44bf9db5fb694aa5ee3e265ee4f0cd4e6ed13761f525c98a4d2568fa509d66959cc5256f576ced3531bbdebf071a3d23b208d5efe9691aead45f03877d15c011e6d2456b25172e5b738ff8ad479c3a5304b01bd72ad06af8cc16befcfbefcfff959b7e017709e831cea9d73ed6c770c6e1b95797a9c2f9c2c8863b59d3abd4cce1398dd532fdb098d4b8a1e87aa4c57a1a0ee13269bb568e96d8252c3277a920716095dd3310a3a569541928f77fa997b5ccfe5df1ece5f7c1517c4b986603e69450b3e3de4ae2b79e612e23e50b55a731d72a2293263b98235c456b4790396b142ffffc424158b069679c9f18f2f018dda6cb147e56c0c0d4f05be565804baf550deca60964ea6cd99ec9033f1a4b6e2724b1ccadd4a2d9ce6c185f6e07aa7e0575bc73660b387772ae8ce2cb40dd3c31249e254334ac5a75e8aeb915195a60adf317d7d6bbbbcf35a6458f612f8496381ae1e59fb0abf976178e170a490324a38eb38b8bbd089ac7c319be11f27a475efee19e41121843f74f1f5806879defc12b83046190ab2f1bcaadb4b3463a95f2e90398a534cad8c318c855224c73f99eb9e0c88bdad28c27ff3e36583a97ed3b5f87b608fb1337da8899b5d02dd4aea05b614567212ea6032d4a3f85875004d4061bc5afd7107bf94b8c8cbfc7143d6aa5685558f8707d675be8ace86af856bcb0316af2be05b3df6efaaccc13a024918be02de5531e08e64ea25d4fd05ad146f5879e14d548c29de47de50ac9ac1796ebb7933391a0d535708bb8bb8e44e175c40e8ed0d9971d4db512556c4f335bfebefb2d288173fbe26f69b09abdf797af3ed9575e8ee9a8703b29a5434dc4bf716d20ff76c59567a96d9b1f860610a44f6dca5ebe962b9ef9a4f048e09ecb31438a2994234fc30a51b99f0140842b4811008fa7be83de4a1b706567abf980e49bc6443e2cc58b66d12ee247e132fde53ab523687a8a322abc4fd8853886673276f93f8685d12aa0f9ba4494fdf05bb81d1650c9e42da823a039beb16a1ee7bdbe9d3307366871ae47f61fd3fab944ecee4af3915003d66bfa0759d553720ade83efb39c1741229ec40d5930496f0632fdf861fa27977a76c73dc6f0cb894ad2fd2843ce8a737d9c8674b3d1cea3b84be154faf756dee024ae9b30f7a85c8d932ef029db727771029e195f2a4619110bec2e3352f1c3e3d301051cf46fba72fbd8a7a8a6c1a10d48d1318daa24d2045c9e3b3c3a2050983558d1083ae7821cd25e09086b8033b1013608a73d9379e9fe2e7dca95dc95af02059c1ff509b673247b64b3cf3c8e08d5eaf128a30e7f1a7fe4a04ed46248dc07cb7e977c103a38b73cc0615abf4517c879c25f5ed92ca06ae50c6cd78b138632aa202ecbfe1afa157145b94e9a92b5a89c3ef4ca38daf1ba37669bebcbd082ef333f55c9691d335ad141f9c7f7745e0adca84b2c1826e37b2169853d3736ea6a158c5546af6b4c4e951a7daf4d8a574ac0054d2a6d9a5c7f07ebf8e5f5e3f9ef1306e302bd2ec0f86fed45156ce82912236ab2040861ceff0122f73b782690d342ea068469bcb30ab14789afdf6fb39cc38b5f20a6a4df00209e1f26e48550242d32d8de7a8083a0327c10fcccd528c2f0a4f9decc5f5c8dfdb0f176d0105224d83d88685640551aab91b726ed5d3c86e7a86141dce1e6752e6aa6086bfd6846eb54d6f6a567108133a027a0dfcded435ec7a7c0581f3a583e19802f7ba98f96a2d4831df200d44f4ece7303cd0de16246ce422f27dd7bc49145afc490cc3ca613a08a6da40749ad31efd458a69ed10a9e094adedacd66089714d8e81cecda767c5fbe3c329d81e2149f068fd9a1b6f21316e299ff23388aca9c1742251713dad5cbaece8da7b9703db1f793affc40d7dc9723c76bc03e81322538e728f3888f9fde9342c437612232126ebfa81bb18974ec561021688c7c38a29dc9bb8a9420ab63a5ae3d102fa03aa02f43b15a3954c4674195a19ac39c7ac4e27fb4e252371d108ab01893d3340888c6a7be4281646cad60c243b472799efc43d4163ea3c3b3db180ebc2b31e3780806cb45a8dd91fe29bb781e51a8a40c43356edc8daeeb7e7550eda4c9e4b23e6214613b0d9165f48473638587f7d30611dd7b7dd917297b64a7f5500d8621f1d04632435b9da62d67f6387c2259ce5582ed2210628b1c47d9439871d2e42605dd05125ed700b080d65b24040238c29603b9f8952d8e8a23ccd127e07368fe1116dfe5cf370f4dbe63d18b36ba492e853cda30c19fbe615852f41e33c1cebf5b90f2d4e36c58ea5720f32dc9b0619aaada5f508a840cf694670f43ad5283627eaa0793a28cc0e673253f814d045830eb783cfa11b330c2649a401f05d0867a7848725ea6538333dabffc2cbcee8e9fab92c43d9c8522a6e917df85238a055808a097a13ce54ef900b9ad5d9e84e6b6f1d38a0efcdd13244c2aca677f8cf471fc5f4c2032deedc8eb23a963e23a3a2d8ec9c5dcad113cfd0458110f9488699a17e788a16afa1bd3979d89ddc0ff7a186d7508c392366f30efe155d08279f964710c353aede62ce239db803c1f54c0619e5945df835c2c093d4d9712a49a7fb1d147850b7082403346e6c35b9b37bcebb3d8584b4a3257822f2a3f5dbe0a31f0e9c0b4cd9b1f52984a3ce7d53a8ecb07f854ef2c74c57ff3cb099cee89937f65097cd96a4668a50db7769c25cca2b0904e6b031c44ed4e709a39e8d8f29506b0c1442072594cdd967dbf8098b41a2a841ab99adcc5db639adb685be2e4ad11010c8a8937d10176761ffd3b1489d94c9e3f6539a01ca111bbf1c7c831391acca0e6c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
