<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5d7477a721021672c5d43d6edc13905f7bf7897303900d07c57408422b72e96bebe7a35c85bff065063f2045647b821d28219dd47549b1ab37dcf63cfa9dedc498d519f27ae8193423ce87927d7bb25d6f8b5579fdefebf7c9dbef1aab03df1be0612a07e696f03cd1c23eb2ada89f8aab216e108625df3d203079e7294be4e5d1e50e1f510ceb1c713a247abbd2027d197243557f0246608948f52e46b6f5a006321b25a9feb763d9d582c8dca1361c88c55732a7b34aea747857dc844e6caed8efb17770994a4349dfc49632e352e3990471d9032cb91df2a1ac5b861f50e1b06f411d0903d731333dbfd1b0b4630f00b8d1cc9ec56a39c7f1f423b3409263f9ca5c16d0993180052f27bed902953d347ee9b98fa29816fd5d9e9aba023a567d379e4b384b81d6b52f632c5eb745678e535fe6ac019fc78f7d4b14bca89b935f52876df3375a0df3635fb5b2a91a389e8a9f68334d9aedfe8bd910a7927196912ab8158d5637b2f673aeb68766dea6f8043126516254d02a3d680e7d21e7b8e190187b6307215c3607875e0d756c899136305beb3b4aa2ed7faf7b5d91c565d517b8d9fa1a0af7d2189449eeb441d3b9d1f9c66089cdca3ea55854c266f8b71220c75cea435f5d08de7bb446f37705c8a35656609a0f598012f7f6a487405f435a73c3f81bbbf719bd153d0dddaa25a51d640e9bb78bc920f2857db30b583251c55361a9f64b786b7ee282f16eb4f77996a3d9eb0f110d30de20fe0a40fe81255408dc7dd49e61ef8de2ba174198b3770d71230b5f2aa2d0cdfb685e5b8a0d58e294eb5541789d44b9efb6a14b9645e946a008fc7e3dcd524906e4eb70c70fe65d0a54e5a7e41bc8a7a1d5e7135ce5fbc039d2117cd18c4c61adb72f4477d5d3685f1eb3d7871f9cf144d99e3fc9f857efe909ef568d8e7b01bf5693faf193a21917f38419440a2962cef0e023152865fee2a33f57de3776deef9826c78295bfb92de1b6fde371e73d06a0f8de755ab95fa118c50d7dc0154ac5101c3524fb6c1b6e5917fc9697cfe74265bc16b97c22e16c56e7875f21af9e7435595f50ac41e601a2ea34a6a8bdce8c1e7b8c10b01d928962f9e7ee49588224243a9c07cb95568a9a366dbeb3d7588c44a149aee8a4b2e6a7a0a6e8dee0784de18e422532a20aeec66a15db8d97a94c35264cc4a884cc54ee4c06ad46a64cfce5fccf4a0292ed320f2fe14580066f299c9a7409272a9ea46dbfb8710d07752c922e14afd31ad5eada3bfde464cdb45f6fdc9406969bdd6d77e32db60f069ed3debbb5563c834613377d43fab30a34587080f9e290e24d8b4139309c87f518d73c8ff73a1896027f1bfe0028ecf0cc76407edf52a8b3067d18beae4addf18664085346da3660a14e7c80ee66a97e3023b4d140445cc0ec63845fba524633ae13bb3021c4529d68886ca36fbb114754d6c464cb210dc80a428d57f7a5e6ea625a7ff1884f7b9b05b4edff4d07c15ddda98c39a08d2a35b8fb03606adbef6e3ec6dbc121cddefe25d609073822844e893e8b7e590a531c3447df6699a562adeed97606c15cab8ddc1699ae794a93ffacae4461cc116dee3c27266bcd2e03a885e6eb379325ea976aaa045e18f7448b94acd2d7294f3a2b0a3a8ca5a5f079378253d3c3eed72d8f718b071330150dd9712a0df32222d326aef62a1261bb86af64a516f5ff11b465dd1536032d29e68121e9b74056ec310fa1c03bf139c5c75329b4a279ef171a2dddeca730f1639927ce799d71686efa5c7fd594a5e3ddc44606795c5bc27cf2ef5a093ec779912f0237a545f416c19a3bfd865d539a433ed6bf0db2ad9839db1e1f87f4b573a154e0231f2d4aef39177e4da5b0949bb119063d70d4ff2ecbbbc96870084f75f801ffe0d8632c33edcfe02b46f8cf52b8d6146e5a94c6f37f922e1832b4333f9d65d5adad68e1513dfc05a39fa8172bc06adbc89d3ae59d4188f96f02fb1594f94cef3d1370896751a9bb195ef9010d5c41b834fd9dda3295cead97e14cdccc13ccbe34e8bf0afe6e58c6e4ce699b2dc0d374a34d49f672032a25bbe6c83e0a5ea94d21fc0379eb4dbe78e982e3fa89cad7d31a2e5c334c4b3c064453f8151195beeeaa8cc918391e9e772d071f5841e076dc24c14f511c2bc1b822fc684f4fe8976629c1adaf12450198e2b265cf94e9aa15a4f1bc6126136af5cc9a9836bd9537cce46818c79420ff4e2910e5c845ae0e11e26c1d2ca965ea9df2ff45fae4d81aaba18a57dd71a3b8f7a1ee1de5692b32916c6d8f70977c0a8e7db6a131151f409124dc1000623fbf096d18d55c7af0978d33a3cb905103ac39f09081118930a18328d08dbcda04251ef3bc7042369750d482800af9ae90d997a25d81f77619606aacd3a57625f9c21e9932404944a3c4220d68e2955f6e68d99cf1489f125c19eb726bfb2987e1f3887b70278f91c64b406ba08cd8c9b44f515ae090c7c623586146b10d0856a2998351be20da5bec25079129173ecdd20e6bd5f189579bdc99fbcde4abef2eaa3b829f43e359598963780534a36448d408d59806ee2a64a36a9ce2dd192e46c7967b0b888aa865743c5ef974dbd8adcd2df62e17773e434919c49b5dba646abfca598a3c5490ad720ce72e4e5187cc3fe61ec8cb68266949bbfd1c1339e2486fc6e693b962efb34f7ce2ba8a7dc6bdb46255a465e17b4efd1686eed3adfb9f326097841e8e41f4af2487e92023f7ef208654be1d45e576a42c996e88e3ee873bb7c7268c8a952c6f8f381e06e55fdcc649f18053b12fd70762ecc1e0f7707e4b7006d9ec39ee5feccbf18330e138f62c962c7c85111f77f6d5103ccd67f2f3b03245bbc81dde7186beea2f9a542fcdc6bab132791a7dcf88c05fe2de5828d7b6be0f83e109019b2d6f423fa8c2ddf3c90fd399336546051ab14fdfad5ce52529d9c1309b31557c4720f4b79c9e15b60366093a24ddb596d5bb1fbefeb080fdf87b4f250c1a017ffe1214c0165e29c5bfc33bdd074ed171058f525656d1ba22a63cd5c151baccacda365106f49291c308e95144a9d52e0d17034c93bf065263e662524ec023b790b34a20c5099cdcaa69bbda0d5df9413b72198a805e20b0877d1b2f62b8dc43ef14405011a88874a93d1ca91a9e89ec01c602bfa4ef53f22149f45884bf4ea96514f3bdb77e8568b56608bdf63b8497babdd2bea85d542ab2943acfd92d0d20bdcad5c21312ec14c9f7b7fa33b9817956b4c2604296bb6068d27aa3799a356cfb20047deaef2e8e0bbbd7f71f508ffd8464793c8ac8fea71d6941980c5b0170d9b0f7a676fe2148291650a0dba0ebe6decdd6e6a9adea4034f794288328abaad456c538e644f3c2ab61dc7840432927e9fd6a9f175ca0a38f2dac72796b4e1349c415f9a0bae0327b71b66492c735b06673506ffaf30041335084fdf5824f9f7b013528738dfedc29021167c86f5ba615a542e7a333a9d448fbba86969b1d6e6eebfaffd228e65fb8ceb747c0bcb5ff148fbdabdc2c75500db15005a68a5c2ff03e0ca313c26c12a8ebfdd5c0faa4ea6981ee11ebb40a0a94848ec4fabe52d81be334a186d1084ef5824ee94f2060f60bd4b4d93a12852fac92623b9ae9fe0a61c4714c51b1129acc084f67ff9edb10eb50b5a6e182ac81ccb9717fb745e3c0763f49254aa63e1f0b76bf60ee34b9898a980f649c74ae9bbfd115259bb76fa244709b326aff0cf56aad285aae7a69c6f55c8c1928f82adb0c0a41ed9cafd1ced2c2d8c987c01a671166c1f28e42c326c2f2918edc73e1db7226cc73248de9ac0b1316c07183b3454e5e518f24e9b2893770fb76f91d6cd9179cc6fce7185139376a7f69c7835059be0900a1f6dd193f880579cdb0b6b518c0fcb9e3aceb61b6d8f8f744c5c789e4c7584b66cec0e35b4bc9a8265f9c2ac702f92e098e00d09e94e06f5e93f9e687b4b8ccc6ec31deac77e8a7f876603022585c81e8d6f7a89ed04671987be3f3503c24e91976a1f7e04dc7cee6751f6017b1097bd31851dd40071acbc06f9a92ef121c0c75446493217307658cc21ef9081e081438c6f4f3d6e9fa0e1a1d5a4da486ebd78834873773d891a94d35ab18d669dcc3edc12f2dd8c1fb04b6714eacf76340e672621c5b4b8b7aa6a51b973000c3eb7317bcc2c86f27af42e8214ec005efe9aefddd4b2a40c305ccde5b75e198f729e2efa35f810e2c5bb6671e66273a165a6a96f10cf60e36309e4cd4f3859860c4dd8bc9f80ec7e47b7deb7b43721a6dfe2e3e6b95f1bf21928b0c07a8404ab95fb2fb61e8c3d9a7ed97c4a08a8550248f20754eb1c238de9a8d5a7986c7676818d5c3c0c4b2260c01718cdb340cc5f207f4ac75fcfdb8378f07307a522ea8925d96ec4fbad8aaf8642c33b0d5754b000ef42706555150e7772bf0a78a20eb9f0e8a1370e874646506617acb0db0394b2494ef4e934fb264170d854314dfd652ab7a6d9916f4e6439a4db1fdbda085424e4c503e3da8d61fe81d34ebd0948ee276a6af8f14ee6a66b775aee91179053ebd307ac425ac23282d079aa8a69585fa1b4c53dc4780396209ffa7d26771aa4f89f4fde239ba8b6e95ca636b443341feb09e53af69398a9a432d61dbf4d5521e7b8f4b8671c9c5373af4463787317364420fa324963afa2287f206324bf6334e1afcd6677a6f6eac4048ffac0895a3d1eca15572bcbb5c336611d2a9985c16cb367de08b636cd8d5920206e08874e55dc2b3d75e1d0395c3646ee247dbdc7e1958cf5859c4dcd1efec67479f85ee2c5c63a4ced5bf2cc349db8b123cd3ad5fbd35e4cb2ec528312ca51aff29a3f5fe6156345feea5a643acd936eb8a7fffa0ead470ee9a07cd417168b55f00e0f80c6c9c11913f060aaf1bd489f7538ac9c3c8bef9ada420bb6b67477ba5491404fb60cf7721910fcdb80c0091c9ac392acfb012b8c9d6d637216bce9a9c8277f60186117095926994bc103629f4b880e9f12c5b38b8fd6e6263a4813e33ea446263ded7e69e013799149dac933530b30b0e4daace294d942728638b15ab53aacd11a5d1a0a8f46d4cdab3965a7afb3d73f7542bfaa1aef53c9c31fe4fce65359076bf3f675b6fce7b976b7ca08c04eb39f5b36659c4c491c32cc5e6fcb4758c1ccfe3766c674427f988799b67a568f536c5d060634227c991a43191c8c29e68ed0a08e8d99c35c811c24d61aeeb5778fe8bd7ba093b280429caf11dd47a218381428e0372037c01361bd213126f8d0272ddc6069663a8d8519ab72451d902165244569599f1873a564de9bd5f4a31e13b01c9ac7696fbedd4e845734b5674e218b5d8dbdffcd76f9f0d1bde05f893f213813c29118942a3649f61da15eb49c6e96834cf76af6aae9049c7f51c3391fe9c5c1f76d71e04f4b3faeeb7f339da7ca9b360095c0278d174ec44fc1b906b706a658960d3e2d9ec0eb23a10809e3332f00385e73a481317aa0372d4aebe1e280f753f522f798d736fdca5537fa64c62a6672e4cf15e2df4387219ee2c010c343cd95705b038b0dd137d72d42babeba8de04da4952f965aac1ae4fdc84d5d3fd7dd22d918d5ab6ed1d2fa572844a33ab6c9b0ad6f679bb8202b2c5c39dde11e668ab9e87d6275efa83a66064631262d1fcfcd4bd2185d456aee7b6c32129039ad210d9857367baa6704c59f05eedb42db78ec5d8a316feebf6a397da9335f3763dbcb9e5be4fe56c1fb6d766710ee03c09949000143850b563c133f3f5e0130c1717b7bd293df831f80100d6235663e3792f70599242c78bd0dbf4c919c26337334d564ef2a31dc06856851879556196d51b1a5f9378c87fbf3477cf9687fde298149c63cc22be93079c17db2cbc9aca1797d9b6364f9646da4acd9f5bf787d0a3754f7c2fa63bbc4c1ed5df38de1181dc926cbf287b93642e61bccb200e2370c33a5dde80346d6b62058ea8634ebb6555aba3250af15183cf6ad317f2306f303e19808cd2d8f73d25a70f3e043eecf2b6804796c0ef277bb2a44b65066b6fc369332a6e9b54be7afe8093085082fe31eca46004cb62ab7e4efedaeca519dd84e4eb30f54526ce2adb9e16bc681552e3f03d84f359b24e4d162a53f5aa23231dad98a8293614d02cac212e8e8db83df0141a60328b6b93e7b0d1fadcca1b02ca779260c86cab10f36c64f180fcdc86795210e6ac379a8cafea282ac4ab98672343598f3a6324f5c65d8da3b81d259bf678c453df987c81c3231770932acac0155fe37ee8541f304fb249c3182fa02681c5b3b9562a397319936502b6474ef1b7a70719c07355b88d4833480fdc0b05c6695ce814cfa73a6cf3e7a319a53dceb97c5c47088ca89323beb68f20f07d755f9c9160723d5e510ac6691d898694cfef0cbfff60b12c924778dc0ee3b0fb8cc541d938a7e2da72b4a01dae5e89242c4b4952b8d66846a6d8981e0876161d11c5f1bd58b322c8f1ede83442387dcb9598b48889ed8d39fb091e6597e3f462e07dfdd464b7dd785840e30e7a612f102aade03931ecd734572ca50055fe32ffd698be74762f24703747a986209c34ad4074b40c7d9afc8d466b5c64a3f87c82901b6d7d1b3301ffc994db4e31fca51eff9636e64035be242be5e7caf53c1a42ddec192cbd69c1b9ced826ccba93df4a15fecca84482dfd169f863ce983b8142bda245fe98bce81c10c96417fd62048d52f4b1c35083360ccb76dc1e506922b0706445d405ec8f73a8e5bba6b2184df812787812deb172ffc40506922c35f99591edaad6198aab3deff2a5065659fd300ef42e5c4408450d482d88fa635b1e761d7a5f9c67e445160a76926d289c93518d95a8c904142d54c038269b28026b9d3b2ea867f973ce448477464dcf5b9c824d10d17aaae6dae74ef9f097a3ece3ac305000442f09c2d859b4e3e60ae00384ede21217f2b8146af8e9057142796d57c27323fafab10fdc736723531f01e32a2f1bb2a2f9ff60a39e95cb5cbc7a9c24be405db5d53b9d0f9e74d898f0885ca2185622b7969257ecf01bb192a009079c88224b0eac59ebedde1b777b08424cf800a7e5008c86f353fa786ac1574ae1e797ee9ca3d02df12a9e4037cc7b37ad9c3a03625b07b5711f7b997c855d9534c2422865f5c550b6a74969bdb4beb68b0b0c1baa70fb2ae02003462988efa7b44a29f2adff3d0e095c086ee615777858f00c8a2b9beff4ad48d383e9e5fc447f665b498bdd315f6ca291b0551049f09ce13872f0d68ee414e2b77682c3eb882a42120d9eb25d6282d7e77bb4f3232f0dd797979df0efb3dab7368da2000922869479875653ddd4a8a5da61a94c3587f92ede57b0b4fb25e999a0653319203171574babfbd4fe23fe519baafd9e1ec3a063f6874589328b7cb5c7694131a5d59e3ff20d1f7618e9c778662275d58943ad651f363e747f2d937a84d97526b55bf7700d26ff74a83ffa929d9e4ba225904c62c25d5529b8862d483a2fd480fea2ab68fe32b7a7ea2b504936b6a2640de201cbd8fb9dd66a8ce6ada6e0d0387f3318b4f2434520521e613464fc5e3f6a5b8ef4ad15f445f741891230f688f5cf9d63c52cc4fb3adc103502931b31a1500b16782b69c232e01ec2acf109fc9c3aa958821571b456f19bafa0f67c07ed757edfc2b94509c6190893d2a44e31d2b43087da56856337028b87eb10cb61d38791e990d175076037480c9ccec0e46f8c7ddb5a18211fcf8666da4402b6e314aa89ff59b18abfc78115a083bd769e59d45513368ffcb302246e1d34cd92cb7830aeec2ed3f936e12c227b9c595b484186b0b5991ccf91240cea0651ef12a680e74ec2a491bf7427fe6e725a76d32198f03d0bb241385003e4cfffa810c2fcf7a88cda02b56c6cfa9695f24aa146a27812ccb05c0ce8fdb41c900903ffb9783829b5d366b84e4e4e7d64127783dd966391b5e7a4c1fcbfc0ed69d2174866d0010833d6e6ea8c41a3be739019b9e57c98aa81758c59cba196e98e9a26ece2a15e080f6a2016e677ad068634fc11c28f45687a28f294e9bd6c775b6d6de56502827718f49da6b9485d48db94b89447b21e77de4ddd0de5b5e79639b0b1e93683b9d49262b46a95429f9b1247ee18e4db7bd25a393d165b44b33f4ede1bb89fcb08e5599cba867e765289a5c93ce20d5d8e4283ca942f7369065c073e48d120af819573a91d2171e886977f5a443d32966e6f62c57e6ceab3c452f43847f53e706c9d6b799ce7cf95f71fe973166fadb3898b7f818223a61a3822d0c2a1f97ba22dff90ba5fde01a2443f5d4e6744b15acefd4b344cf86770e0187f67785bd98f04d67f3074ccfe45e3895468289e18571730c7d5714f2503c1b7b584f4ea4d2d208c33352f63787bf24a74e844e35aa814c329b16e18db0b8e828533e0d1400bedcc94bacfe02f015bdb15a2e5819f6999dd6fc72a6c013a0f31dd5b3681e754c39727e2e8b462ed74787fe1069c3b05a39958e96a898caee30a2b0afbb85a5bda211b44045363f38aae24a58fef3da9b4955c081b992ce0df819f090449e810fdc5ce10de765d3064d7f5aa666e9b74a0d15351c276ab17c49c47b0c9efd3ab0b6ab74ad9dde6dfc5fce48dabf695c15d549ddf9195d7defcdcf41c74bb4fd29beaef2632ca490a29d425e52c5df38e3fe507113f1dd888096c34337a9c5648f685b3b8ab21766a5c46374c5046309a1b2b7e29f75ba221bdbf01aab06cb4a8eaa9b7162679f601cf86e81bb51016de2f294a78ab088eb7f681ac7c322120b9578c85f1467dc66a8cd9f3c776dcef78a9533e055c9d37360ac3b63df0d2489c7a98e750ac22b0fd54f13da6261a17cb1ac50504f02f679f2172c5058d19000e2135d530665a9c920206ddd7960aee8a8d85f6968c50a4113f1a5d10057ce3751dd0aea65f9ae24a5fa08853ae957900a1db163162e05c8d3f347d68e2da44bc5c9219c91bed7e1c431f25a64c0f67f5134bceb37bceea09a1e322404ec1382ad421125d583ce294209d33c2be59297bc505a47d78439104ee9aa323b8f6d9af5c892036ce388575a3ce8110fa65e7fd95ba295e9f4fac460728d29cadc4af920f4143ea8df2a119ac1c0e3aa845f00de080a24ed3ac40d81eb3da88e3cf9efef493f857f5579c611caa10d1b374efbbc106c7c1b82ad2bd32d5c454ef4ca9ee0a82c0d08ad3593937dfbb0daecd41e72e0e3d8a7964d7aaf4c0842a467da3523d10ff859114b19a0cce34200739fa1dff13771a38c283f59578c12cc84cfb2d105d68ce299471947a31d5abd028c8cea85d9fe39ae034c01fdfac82c5564d680ebcb3f16b287721769e9afd7ba97db857550da6a920ef4fd150ea654db40b02692e10e82f00199efb5c9265a554555cc7ba0a3ae158066c3c98ecf80f589ee81fbca50faaed25bc75dbd83eee47d3bd835c04f319a11ff023988c6e3ca19c45f0d249eb87ad6b83b7d81942d86e211594009bd8e8d9a28e632beef77071ebba755f98559f9a2fc7122eeef5444fca5943451504b70e7af7792c9c0a0bb2b85f66dc857087296f82ae1d67f4681859757e62878ea37651ca3fa82484a56fb51d8d2baff76e80d8033e9b7bed0cac9f6b16046ac2893e3d2a6b113444765b62d1993468b906466fc1df995b08ffefd553a1ea3786ed3bada594c5907832e810ec66b6195cd06b742fd07cf2c2e7dfb011bbff0597f341f026bbbc2387026a1c0192e68608c2d08aad9eaec6e6855eb0027ebdb3ae9670a40fd2434800d37a28e495b7707db2f1a0f1508599a7a0192ce481ea14feadad202ceab3cc89630c5ba05aef6ded9d1350b2938d23c6abdfb0afc1c9fd94b016c33f653ccb7c38d273bccf60627cd9fa776f9efe88bc9696c97c81c524a9d24b95476c37e0ba64814e38980bf004e33498676303db0c249b338f64fa55f0f2474e121a9e01445ab8cff660ad7bdb26375646b79da00f3d41acf9ef37fbb707597be740666ffef829500c9e2eb2a1df09b40f4e6367c68f5a32a60b1b7ffaf0bd24ec05d6887e303177b9dc14d6cdd2e7ce02a9e674a8c71240f88af83b5e9b55e4db53dfc311b7ea8fe36cc244ba6627adc91287c894c86fa065b6ae1542b11c6fa7e25d102eb5e9c5e618d35ae60d0861d0329aecb1f85897a5a8253fdae495a4f6ad4cd73a0d56d0e447bb22a56acdcfadd39c3e5168860ccb3e78a85e9d2f6c0df7c89f7f8d75494bb31476e769e0c2651ccb6a34558aec52736c18c11f9c0bd99ee02dc5e927c54127674790ca5763f56e6b8be929996de861655ac69c5db80c380f7dfd4303070d80dc7790d31d100130a075de64804d5fc1bf56f141bd5771e3dc2065c8287a304e93d12d7776dce14e6ed545d267d54396e166c319eebe2463ab4db437b33847f4543f70ded97f70c2a979b959203bf9fd87f1dae9f8bdf72929331816f44d53f4a9c1cbda3be1131c7c3f1fa4171bebefe51ed610fef37bcf14b569b18fcf026a44ed1b7f4a04d0d2f9a2c30037d4a8ef303572b4d7ae3525f9b56d7fc95b1b2dbff95764e7a35b85197308c75cdb5b2dd2e31e883c0f5873143bd61a8ea1026120dcf7269741e3af41ae14ec260dc5002ba1db3fdf744c49565aaae59f062e214f56995b1213b2f77dc1694cf1d4240ae554520ad16014ed5dda4ccf1cd6474d45c3b12b5e63fa3ce302a609e6ae845c2e514f0b3d8b22437341faa6fcd9e5e7c137199512da902713c06eeddfbb55422866027aa796077ec2ec7e505227dfe30813858441aa993e622a0a82e602106a95e96b6c7104a01370b3aa7c71ea3312b27bba50cad88d2ec0494dd6febf9983ac8b078f5f5e5cd85227304e16e94eef1e95c1e5485007da7e11778a5f6db151190348e9d80d34d60bf5e0cffee7282daf252610f3e6efe9a9509bdbb62adad955ee4c3c156c86dbcb4f2ad94252479175716e78a87663a2cbf08df440d6d089e75d3f46d3829933fc38acdcbf0875461f0ab5d3727efb801965730114788e7fb5ebe046b164932948137fb192d4ffb5bdf5b8af706158ca2412c33d66a03629055331aa1a97d6d87775ac60c39963e2573ae7b92c3d84cb3833b37018aa04764a047be72b3c958bd583ef57fa401eb0f1f57370201d0a9ca333f8a4b47b6bad4246894ce4e0d2e659df8226e4d5392339d9c61f1d5b88478f2f706f919864e0e051f316f5e8feae1244ee1b9161820ec7294036f60b6f4a97fc187ad7f45dfcd321c1641ca447af91886222899a0b24d396eab03d40fee919b84baa7d05a97f8160a572c1d0c91ba5978912ce7126d2db7910ae6d18580483604063397d887f147907fd43cc370d174d469c7c73970ee3877d0d3efbb31895908785917aaf32fb304eb4fda69b3d58f813fcae4799c9b2740e5bec2a9f57b5360fc235ebfc2e4da009a83cd04c79d5a5ddc328fd91490cd23779556e8d75eea94febee94a81ce0b6693465060984975feec87da4f9bfa5694fcfcdc932b5ddd92d65987a6d6124162fee04e785a61eccf43b01533a056bbab605a08aaa881eed7a23e0cb3c43193bdb89ecde0beb576e925d01e1aa5f15dd18d8e4fedae8b8d6f6d248a6711238674271813945438f41a8043475888b8a9ccc706093b3415d8b4da7916ea7d354877c58c2e8a3cc59b897207f3363c21fd3113295f1de745123824aeb897c0baed83162b52964c031506e6bc74796242e35a526d3ea64ec58036f1fe969abe00fe9181876b32c9ca3dd331f5338521df1a78e4d5537361787433e2bb9f52f25a3996e0d192cb73789b43cddd333960d15dffbb433e973392b04d967498cb8b3ad4b1d27c708e30f6711557923c716e33c55cc442988d5b286d89ae8fca4ee2ee4585a7539c29f24860035d494aa712d5cd4371117844af64e43471184af4647baf324d302caea0541e26a78c94baa791f982a127b4ac25e47440d5b013383975bbffc39d0cf46a3253b491c9e8af2213cf22b7c74703f437990ff65255003ce6538e4c5077b3a850d952f5955d70370358c333e1a2dc42fab3e063f7a3efb8e2cd626cdc01f190896af09bd042059a4489ff89fc4d7c75d84c7255042c5f03bccd94d9a627866a3a3d43563493638700e10d809b677057be1e41d7999969cc2314bb15833c8d6ae1cd9b375bb7b1d973ea71cdd14bcd2d82d36858132f6c6c301346ea956dc2c3604223a8f91bf5b3c17fee0b6837ab380ec40237ffde98ba87ea43cf1aaffc7f202b3b425583f9a4df499c263fb1c6da24b65f65448e3a668724d2c941aecd86a4785c3a199795283a75bfe2f6d0cb74c13f3e81de71e1d10d2d9ee75ea29d88bd688217856454d6d086cb6828417cd51959c24073033279761eed10e76bb51e0979e16ce6e621e15c4cdc2a3c112d0d13f3935d5647af6111eddd765c61ea7e5df87c5cbeb391b0c9793831ac887ca998138722deef7a441afab6eeb74fb88211bca036fd17aa0c36e759c68107e98fdd11ec7eb8b20ca46349610cec91e6b0b35935148f1abd9f3218f683cbbe93164df0110924b94adfdb34d85c0fa06e7daa29db64aca8cedc1a0dafd065531044ae4f20f9fa8ed04e7cf21d1384847482c18613826eb4a32b3fea478da74615cd310a7c993736f9bec6570c463522838cb35860435ce9753dab7dcd693f2a14c387d89e1acdfda5da78744968cd4eb3d12a9565f3654768ea63349cb957cec9a9fc6208b749aa83dbaa6fa44935e5d63797c0a76c572bd4f62f0c82ecfa4c297dc694cceabd70483404f861d885ddbcfd60c304161ec27970cd14a4f1c29983facbb772142f7bbbe6d7e390da3e38edccdf506ee737e8bbf527d99997ea31096cf1cd0f169d908f96adfbf2e494269f779ccd7f4222b17c0ddf5bb0a46c35c81098eb9c034732e8c9b04fa40ca1faa160e37dad6e6ab1893d6422bfabd91cc1a78ee84efaa56238b2e11006aa59c756a41e09769d2621e36e5d0b3b78327b97e6b9a5fd23ccf9108ae729925cc5c1633aa0753b9d9b81c44fcdd28725bb7e36211ed08c06489d181642eb54b0fe7ffd7465fff2f4aa20d0e4744172010ec01e7ebb1b6fc7683e90eecc1997888798eaf253a428f5026ee574c8fa75e48f7ba69bf9423804d71e1c4b0706d7234ee8caf94c6fe829862147b39cc92869dda221b7a6366f28e4388a6a51c2d7b6334113a81e4a512cb106e6cb6e4d8a514112aae238a69cdd6a40794b5749d0326d7977d15d3d304492846a7f01382840d93f8c9df006059dc35047d15c5be15f51631da89e08c59934e250dfbb4d98a10c9161bf9639897a9a8c8e40ac4b7078a3f4b542b86897ff1a630650acced77be4b6b0a31dfe68e072f09bb4629db5b0de041613a946a97bbb244fa1504754c2d7e1aac6bee55bb184c03a4992be036f01768ac025d840284a59e5b9c709a8763bcd476ff6b26c1bed3dfe405817f12f1eb27ed557246ed69b4a57544a7515ac36798d090528ff52d6aaf57b0c2cabf42802856902a50e77fedb1a41c1310195a4685a7cfdb2bbba611c321b5bed0fda325149dc88cf6aadb438818969a128d043971296b4b4a063bed702ea3a0d59c54c8f644b4658d267e6772e73cebb47e99318d65eac14c293cae4ff9ef3956bf5a55ae3d134900c2f79e531143b3912576e56b8bd9a12545a00a481141b38fd45b5d53c0c13ee95195bb7c395be7e3c9c135cea488f9e0f5202d17b8393b4cc5377c3dfd29304138070b470122d04e7785c86bc59d345a3229ea739da293ecd954d9ef677e87d898dc8dac49166466a4eced5a283c0be8cb33a9b1b170d295b2423699018359eae19a0a9589fd220a5eeefa0372be1bd4164ac29fbaebcc504784f55debfcba57499e1d10fc3416a784e2a645df656fc758cd824775528f9114ec4b698eeffb22193368a5d572a7fbd8b56f23521920ca2f68fe858e98315c08c1547de632b04deacda842e41caa744d310ae26ea886de8ddd4f40ac95f3b42182fd1d5d18c50ce2a9729261aa27acf5dbb778a7a3ebc583a65eea6b520435a5c56c2acba65bf45d79388aa5914d9b255d52ef8b01ad318aa483fba0863ded4f3f9df3e337cfca4045a4f1aa406b86c6f1ba5432ce0bc900db66aedfeea97d5f06aa781f9b279f7aaa7b05696dc8cc1a3967ed459535cd47cc96875b52a5b84fb4296acfe57d2ae191a0fb181049059278d7e96f68dcf7b7af163072d5e849baa7810dce9c7f3a2666d44c011a672e202f1ffff8dd4def099ebabbce28b82b4736f4aca9b3b96fa292b213c33ce8f96c2f63ec2a0ee86889296827a9d31615154e4715d95f59726803e6abd458df675a4665120095211cfda85f722324e7ca09b171380c561236ccdd55e8ed8b29c16eeb2092c001e96e7ad12cfaae7ae3487fdb89d4ef4ccab0f51e80574989eef60ddc0c6cbd878af4c354efd09f52828c7b96314457ffea10bc7836ab99fe37b2e1bed70070e440bb557143f159c9472098435e9dfae37fbb818bab9ae952af2750ed2bcdc1b69b92312683e64b0b4b160926b727b8e2d97a5068230f601ff5fe3f4d9f7d67a8e3a23a8b554d69e68b76d55f3743aa48ce50daeb0c39ade83ef4d51fc84e14a5134d2432e987b7f827101077bc06f45dc6f9b87f294dccbe7798768dbdb56ceb07e663ae506b5d0ef1766aee8c0c261ed4f94cdad814043f636c1c4f6162be3909d33cd8f415c194534c29b574c358273a71f34e534cac01a10ae519a90c3269b2911f35ce98568c24674a496337f5cfd0e02f011f2f1b5e16803e589f55d41a0012004944be8a750ab0a4b6c82897f201c2c616ea06aca353c1567d183c281a3db75d5548782fc7acb251ea8d1ee0d5ab06c88fb574c3a2fa3ae06466bda3373391d8e408148846e314fa045edb03d2ded2a59d70522c2a9620412c1b82174cd6155599581098bb9821039485f24e042b5b29647e0ad42fb48e88ac892702ff17f343fa1b91160f618fbb01cde6599e43f926f8022fa0d15a7600e1eedd1d1b7e0970f70b0f55b9a33a72676cda74592c83ae90617757e855c4fa8e13984c004d3bfa188b0801a7488208ac7f7995261c2759c6628cfdb01f072684ae028f18996f36c74e61282c15ecc665d545aaaa25db268fd06ffc46be93113fff72dff4ff7a9940d11d683dc52f743279e2820f3360948a759701d2eff173534c6dbcce6f5c9d8dedfe4b1a543d3a1ca9e7bdf700b1d4463eb9728edd2bf5090c468eba08571273008cb3339a07471e92e9fae3c75accd9e260cf43ccc9ce02964a99059410817db4d63808667c30ca0ca2dccf7f810ad7a55bb2420c01ff0984a4e5eb7e80a98ea97a1d652a63980fe2da0df7e500e76d350b60d8466962e52e009a722d2f61dd2636f5ad11bb4359d3781c9a9208df997916ee2a233d2383b0d03b38191b29a31be578d699b86544c55724d8aa6e1f3bb40602ac3c90093b22d6a71db780ce0d93ca4982f214c7104557617bbb3212b5ceed8e2d7082f55b7cb5f3c9482c3d06490bf687ec117e033e78d857c2e0b198342e3c7ac9e7da27c3da7263761c0919614896604625558c95a74c4e506592456b6335570252f61252fe8be118261c2bf085c56e5b5f45d890846fe4c59df0ed56576ae7ecc55161f42627a27d9b5cd0611ebd955192cf7a04fe5dc59936cdf7f46b5fe6009bb76da9d52737f5bcc20cbf32076cb42ebecc398361a18e4dbc232c017ef1f124ea9e16e8b060f570fdbbdddc210fe44ca798133f7f690718bd3f0926dcfecc3ca7ebca1a9269141fc658d299f63f90b3c89f36e64e24bc650c79b0ec8c994592cb70b6575b28e6537cb6524f557619bbe999e0078491cfec3b2f2dfa89289feec54f88e61ee0dd2a3a403641649fa12cc242ac20433e1f331f1ca84bf3d5837a4e4b4bfc2f67dc4facc2a90f17739ab4fc31b76d47c464e57c8f166de3ad9680f0ab1781316bf926cca74088de1ccceabeff98d2eeddb88fe01218e7919e20f63497f019ff4b2b903506fbac542dbc5ae6e164e1cf382af811f8ff954b18530da597e8d83bf33cc3bab0bd013fa2b9af01dbfa1c916170b9eec92f407aeeaae85a4bcb8cdc2f420a9df8b39f37c9667194a9b2ddc7958724fb5ce4d0632a1b50ed0f99ca2d35a3975d814edf7fdf331af063b2d2f87998b2390f28cf06cca37e678eb90c06ad7197a51d77296d5ac56f355a6f9e2c81ffbf971f77b707b78525f643c3203b81b3a46089ba4bb975262ca3de71ae9a26c7ee01b7fe4ac456fd591d854cd82a24426c759fcf543ad22c82a515333c57093be7c76c17eee39db9499652c6e01ff224c01ca8246fffdb16b913935c02c8f056b4b2a4879a09988097c8920adcf9411d1c4854f349a24377a0e63c649a824507de473d33ef4e4e689d498fea79886075574d75c715350ae204444f3f3a3a53593e3edc37eeeffb5f2597c18427b09a004b3a75ff32870f74f6ae0291c3368bedaffd3eb249acf1b8701dd05edf2d0889f3ac90c0983be2e8414fdc3423f020d4b58b61c0af5b83ec2bd137c11e71e66144a4e37aa257253bbe1f503f58d8615936a085a3032675a9852244b4f767c398bd7a4cedc7d83f071be99581c3fd1f5539b0bfbdd3a7a7a7306ce74833ae98681d0e9665e6004f13de1015842331c94673a07c8644adb78f77a90b7407769fea3dbd4f13f82c497c78cf257284c744e2daa7d96b6d5e7853b99a60c16ac98623752f69b66f66a70b9456fe24939c73aa672fc2be5b6c034054af23a9163c32dc88f66f687b8b30f460d000d685964c8f4d1285d980d6f355a2b0d36dae3bdfe1dc1f4f9cbb65ad25f2a7e160ba2be4de190986955ca60bae49f9f77fa0af083306e53305d8759e254e415cc5a69f687d398884a9ca97ffd0216fd4c9f450198b268fc5ee88d68636c72b02c5f28e8bc190849b564487cedac06b4fc260828f47ec1ab09a1c94b7e9da1d7ba339db3bd02e788f7313cc887ffe2a687eae316659d7dc7e75a75a71c190df950412b1fbc86d57b122e0d75a3884d3f3c7503658eabb5c32c89b460f541975bc79fe99b55fd53f7e09c0d5d0267e1dfc1678b584c8a6690bb2be08b225fe192c4597177a22aa082afa709c86da1022384eca331cb3262eae15cc55b7bcbe806342e8e815eb4fe369ff64c5dc71621ee2c218b4e300f1297dec23af6f5ac1d43609cbe62466cce5b6a06406d01370b63079302199182f07f432c33445e918daf3ae523a9df019c22a390e9dc91ca4c081201536b3e488fc6cc86fa8d3a5999a68bbf1e03158621d7d3f78d2f8de9022382f3d635aee477087d69423973fa34e46659c24843dd76facfab6e7f49bf340a95adca23bf758a3e71faef4155e9871c483af81073b6499200a202b722d416b0c1f5a6098733aa23deb77d5cbd00b9325cc18451751a528d03b9d3d734797e35320b61d614af86acaacf12b199939c114c935b236c0929dc9181589b4d206ee577896f6c724e7b7afc35fadb48a2281947dee24ee19854bcbfd7483a8d6b75e309c090a01b36b160bfdbe94f06f6d667c406c15010c235d95b7543dec99523e7090c1eca4f6d376624b438ff4dba1c296b40cbbb57d829aee16626d66a28f1a066e2744c176a78ad642a20670c3571cbbf55da91b534f5f354fba5331f53ae86114b85854c68cb6d9f942b70745c183af1c8446e3954c2631ac0e3afb7bf72fd9892b2856c6b46644edc7df8d6944781ac52b16067626b6afb4d0793411792454b4665520931a85952dc60495cc23185aa302d9007c1b6e5799206c829ea371f264d1fe2f52602ee65fa9cdcd3a5d305c751eacf8274315d2c6013a64a837f3057854d3ce8fc159909366cb7f821480138f1481d004a1cd8b695df864aeb4e117165df36d24db456f9b336a8cbed4fe42b097570c3333c37b17a0c2977bf18b6dec5ab5686569db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
