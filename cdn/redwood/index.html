<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b795fbd528cb251e0ef873a2781b48da4eeebf6107ec64ed53c3ebb219038872d8fc51fba9801762e5c2ae1a13598bdea1e8962d824cae5c0c3d6161ef6411bdae513f766e3ae516398c06720df0516225b0b7540ad7745e26f0fae01e0b11bb8eb608b9009ad4d44cf10b231bc4d0f3267ea1842bb8a5bebca93d443b4026b75960643bc7b32bdc9df81fb64db68444aca193d781243e7194ff3ec27702fe0bb003664af0d77666a80b1add09ce1278091581f6cfaef183b8f2b5ede6bdfc273b96197a36a642dafa1b016eb690062dc3cdef6da1ca8568e7d93eb554b0aba37d19503c1b78f649af7ade540a1398df4c611eed00a2f1d707e65cd0c713a14d02c2fa1fa9ee093dad58eb91a944fb2c9fe638450708253a94c3aae6ff7d0b7a60670f94ecdcc880a4b935ba35c83a4e070e31756c29c7e5eeacce11ea172dc35f56f875e6345712fb704ea4457bff0e37c234b1af80261eb8594e2f9a677ae5aa22f209b438167c822faba71a3fe3d70d4b33ad5b57fc8c13f26bd7b86459e14a49056c42c85aac7f66a9166e9984c93687fe71689a6441d5a5485040d3599b5b8b40db2ede12dcbc0d7b5828aa27759e34060647a048517b835036d570cab79c84d0f63559441d4bbf3ebe245e8599733117c180163da5d96d1f3de49b8a8a47cc300876d603823325e1e76996deae509443f3142d53f42cd67716d04059968c17ae9fd77a2ed26c0a01cc07103904665a7e2fd472014cc093b17674d10baa5891e7108e8f3febdbeaa85f07c4897bfa0dc4d5c1bdea72e830e383f7937d71d5424c2edcae0531941dd601f6c7a96592493d3cc220473322d8f25a4c42613331ae872c26ebcc24c958f01a65ff911127e4569720f163318e3833c14cfbfe904f3c38d35dc4f4144b48c22dd54c02457e32547ba2a334bd6b6f244ea6be7223d364836cf4e545c4f569238467b4ceaefe7e151866c29fa60ec524631faaa5b6a90f82073087130a68cd436b023c3f6504dc323fe4b73e3c5d5da5cf649e257ed0dae2959565118f5d0244c605caa6e35ab2e572644f46ac6a6c4172ae443452f09fbd97f7a78116196d9d9df9276773350df789e0871c412e7b9b653df628d615e91b616cc92c56d4d21b5cf925a1b68e4cfd28de24de5f6ce7cfc4f5ddc9750bbad114e67a427525832194796b134c9f868e68725adc748bb41d46adf239614ac7376a0e460f4b8243a6c9367bd80b5b0cdb77cd3f6ca5526016143fa9db0205311bad900d911fce1ba3bd1c515ce3f9fec12b1ff1e87e9e29178a088424927d84729d8435754f0fdf59ce51e8ea39f251e48032160cd6c922723cc4e1567ed2c97eab4311ff295df845ad292a89bd329bea98f1dcabf3523d8df63bbc480d228fd5e800cf46731aff4aa88a751b84b5169783c0c8868b4b4b9d0108e2c0d57f20bb6b6e7f73830a86f4c6b04eec043590d3d1e15a40f3cc2b3054e90409a5c35f3ea57b1b92d85eeb160b735e3f2453b1f464b0e0f3386ff5371b188bd6d3146b5021eab7ed89bedb890ce0b9250dd2653413363ccf7742a493c40165cb08293b4fc4fcdfd6b6aa19020f2eb76a1a359c23e2852189ec05864e6c452370806c43e932d8d7066cbc4ad852590c49ad03a0253c3b0a307d9292faedad41599d21f73077e11083c018c24963104293b997678edf310c3e1f0e79874798c7af6bd974ebf142c2ecef929575030d859d1734131663023e15639b7ca66ae5dba3c707b8dad0a356052f140fd85c47c5e1f457361bee77a20f0badd69b8e3bbb938d4a8abe53dbef2f68a76974fd510ce94764bb988c39214dec33003a3b55470cfd47bddb9d8478d94c01f14f476b19637167debeb9ba67836696460cd4848bf4e1e130dd8843377d3cdbe1554068d5e8495358968d6a3bc05bf49244a9eb09da2869b57355932a608c81a872653cce6904994b44a7756212721e5e486b0d4bc154a11e809743e54d51ffb201bade0044bba5a86e7e458554b0a11f1bdc04c28e60b71982bc887b0baa60ba3ff887b67e05c47697b8bce4748ccf7f3461d79700894eddb283bd9ac04711cfc9ad62abc7f564d542b981a1901900aa6f23bcfc4491b0998ba6f9c38fa42e34bc1b741ca249259cd590b083fd8e5df255a16b42221ab1800dfc1a6e5219d594d050cd0126bf670c67568709781f4b79439748fca954cf60acd5356db378797670bdf08217919b749722bc3cce65a118b682c91764babe0ab4c3dd5c49937b22928fa95796198d2ba3f26ccefd1e73624aa74f5303e07c7ef19c0b6a6d49651191e4219d7e6bb78c62e687e2a6daea10e8bafdd7d8a57dc3d32614ad11a2f5807a465f59fe9f4e00f0051c26267536854988232957bcbbedde10861367e0cd79e716834a01b1584103f83a00c111236402e987cea01333f9382980f4d76f9ffaa1560f3c44a5f961c2427479d620334d98c79273368bef9513807616793831baa5657e8dc991ef84812b15572f7167f0c911bf79b3d597c4d8d73dad0fe8b6c216dc5a7a0299c3b446c13ebff39e44eb8c2995f0943f15fd808aac22bbf37740f07591a6e8a2f5ac786e6f98a891db10a847ce046c5c6efe77a60aad9d6ef9b8c05dff972fa196854fb24b5a599b13940cb3ed8c98adedafbd283b3768d7d9cd4129eadfb81c7ca0c7c020a557f8aaa37bbdbdf2d4122a4972a5ddd174058933c091974d8290ada1f2713aa1b20b9d87fc00187692203f78050276ca92ad22400f3a9074cd54cec75dcc6e7565b2fa9173dc2e260c8929101d5a1f314d395e1ca70d6accf54275e6ec36ea7bc6e104573365a0567d658ccab773a60b843262f4308cb21a351e153edfe00ba8406359c16d2da99cb912483f356fc21fbbb7b285bd7c77640fe8bfbe461b8817d63cf12eb1de9e5128658f084d186173e305e0304a4d667f8b2a825fc3e11f02ac79210e6d75bf96e76858a35a1d773b4d9705122ec3f74c72b785c2fdda5e6f3c83b0f1748c123c82b52bc1179f77df57ffb65d0eaa7cc3433b2cbf5094ff0372044351f772c335d4bd5709ce58688978116accd5e0b0fc832b138046e4dba613b8889bb88c2960fee478a4f897873ae070a7c05ae8467843b8e28f9518b1910ae8eb83c6dcb89b3bf9e0d5fc67d4a3b418c44682bd47e200e577a7e43b73afc64911aa6d7bda22fceb67ffde0d98249ea7622e786e609acb7713949231acc935893121c1da1f988c3a4d882a77e8117b32826c186da4962e0e3bc5cdfd2e31a7c28b052a8222ed26adc50736e66b5ba62c28c0fb1b18ebb49bb0c15296b1fdcafb519e9f85e26329182bbb94badb0ab8fdef81698b0beae41ed7863a1f9758d602d0180e58fa1f35548ec7a0d51db9624002161fd1d1a03b7320bb1fe3961e92615173c2ed402922e775384dbf35eec2b27c899d472b753f3e5e17af298c7cc74c481eb167c88d2747793fa75fd082efd701cceb80708b4db0450f0d3ce2113c522b33b2f5b5f7cc79406f7fd6c91a06266635a7b34aa37c3619aaf28a7abff6f017cd416d811d81134684ee2e3539e54d8033afbfade89ec8dc3ed68ff0a14ecdcc1521dd9b3d88c5c3c8030ca2a31fed229be70e3e4380df8576261893f0547cf5d6b63c91419209f54a8a79203448b7a33b98630bb61982e15e156fbefe7d90be88e6bb4087a82b9e3995511971e633df86980b6b714791b7c64b1a0cad4de644829af80a51f82c6f9c25ba10fae7fae2dacef93919aa32ed262d0429e5a61a6cd4e5eea8a3cd46206042ba9593a22ebc6bbf65f553cc286fc9f002939e21c3b94361e765c387e4e1fc310077d9ccca55541ae94d0007b8186d126a7a3d329dd572ebbc4f4d24bbe1add2c246158dc0037844c720907e84ee71d431b3c0288a36bf6b2634a1b84fe3a9eed1ea1b0092cbe4e10e2a744f08884e55c302bf350bf2224a8c33e192b1ade4b1fa0f9fb71c603e7dec80e9870a2da78534b2672af9a89c36f729fee10241788467aa2b5b31e0b111c4c2d6c4fe8ab962072c9b541675ccfcbd3110709fb4ede8b40cce63e01ce4589793cbbce3222d789d83d8d25f5c97dda25da1d1ca941088090fec16d371891b68643d09b3e31d18d2974eae55d4dadc4525d900214e57cccfdb8260bcf30adfc3ba72fbadb17dda5ef9ba3d0de42af35dc7dabcc3edbbb96e20ed8107487b9b49804c49fcd468a5629205afc6b1ef3da99f66e59de27be789c79b43b0958c6b6af0060d80883a725f3681a51e5a0fd2e4679a102a1c8fd4bf8e125ba5c6299eefba2a67cb47da498fa87628edbf55769fcb708afa122e0accbb8fa0a39ec97a28cf86c60f990745c642d5ad0a48104e68b0ce3c53f1ef7b715749fd4f21642904df3b0ee35c5d73aadd09ac90fe0076b556b29cee7c9359b8368e5fff29cd312421e79d85bd97ba86c6ff2c3ff74d8cf71793686eaab18fb8fb86a585279e247f3993b138c7df1fdbaf53640eb12e5da6bac1f9eb160ec342e9713357dc17da591ae7db5ec2a9d9e26e691e1c4de40caca6eb65cd049d8f95dbabbe51507ab7fef95ce0cefc438c9f2b2e0cda46c0bae2a6f8cbeeadb4893b188823a0d84756be8bb8f06835a016bb15f7955079f816c48691d891206d9ccf56cce941e09a4904ba87432426083cf789fa6f9849be4a7864df20f6fe28bcf2c48659ef09809341ed15f14c3114245ddce5d57caf1fd51b1bf7d5d8bfd10b1edfd0f028ca0a9d97a7193d98bb1b4268560acff8e7eefb807c6391c793fef02b49c4c1e3b8b928451a7e84396d40387134280a847bf8e9444ab2f0c204874cd797c6edbcfd91d3645216ac42e6e91f6baa1d535c3fa435156a64ab49ab09dbc762cdb71cc4c5144a08de7f751b45f7364e3f01e9f515c8cd3edb4a73ef6df441025999aad233d5797cd7fbd5fa1aaf5b3806dbbe0c3d14b65830f8dce58deb8cdd0fb0fae4bcebaecb2f0d76c2bcec6b965e87efda8b1ddc9819b4e7dd21017cd8e522c73280aac81046b19f4c9d97df9abcb9377a7073b12ef7add5f593fcfd09dbb20cd184f4c958f94532817f7166a59b1c992c276bf7f9bf71930c77214edfd43989eeafd85bcac2c900e8aa230f6c2e7fcc8bd00d8c18e47b32e897abe7323a3eb645a3fb8fd657e3dc8e6fef1bba099f299e6186e1ef8a418d00558c9d676c8c882794d2391a099e7ef5bb3bd43de091787a2a1972430c93061c63d8db654b96d77bcb5ed69e114e09242a56a2c7079e73f7eb2d123a6a8a7e6d232bc6030c4f8932319e248e09740571bcf43e919107cf43afe79c5310119f2581c33dbd7aae7b1ca74a5575462487e22c4e3c91e12881204b9eaed9aaa0e52008fc0bc3e27a1b07567840303887f2506feae426536a618351befefbe63a864c8c2434a551a92495b790c43fe426b3919f57c87f18dc4d8eb40c36db09d3048bb52c78fc6006d50243a4364a9a11600d4dd0918cccde3826af4f4cbc5f81b4c3d292c86fd022a3bc508af2563ee4340850dfef4cf575095c5f1de459010996870c861e8b48fdc98c9374f3cc2a202c5275f34f0762125bfc405473596591e2f200fa0b476030502c6b8440c594bdf2cce82b4161f6c84d155546900044da273440ed6214e916e23ef9a4c62975546a1c8f79cf419d25185b0b7c6832b4deb7166e6cd259c439ffa86103159f315a9590e40ee45e5faffa9f05f9bec5955694c2da33761824056d8a4fe715ea652673dd7d9784edb3be6235d463fade357e74164b8d762c914f022da7b3367b4733f4a2049443e252a4310dc33f1f68e1bbdba1258087ea1cfffeb4ad4509cf406cef4780fd109397d0a646040778ed9e5b6bac2b505ae158240da373c1aa865b3b8bea904ca51e302ddbd4986f2af3c4024f70d288f3d9794f1c9d9aa9971a3bb18b6b36c29da13e162eef6886a87aea3f198365ac5b13e4a0b757b0cd24909b38832ef54135d2c0db1c82864d1f959ab6f0ca708bb8149df127cb2e6f20421b0021350e76caea7a5652e4d10316a6dcec9663c603382e59376ba26003f5e78c26ee3018d152f62ddaf57a4eecb0091f9b878d5e0409d9a1c2594de2407252738613dc071870273e5676a4f4d214f1b732cbe0b38a5e2f044af607d3d75772f1d71eea90f3439a4534e47de8f1074fa79f6059662c8aed051eae00e8fa1253394434efbd804dee39a8826a2f70b072d2f31a35d8c0b8528faf19cc597924ebef6c6304957fed801ffe9f1553be616ca2550f340d9d1512105605784e24cb09a9706a02fef1ee618a94c02f7a65e3a5fb20d44e247f8a381cf82576c62dbc572bea0f7293b3f4b32fbb227b7162453d22d767d19d97673bed461a80e0592bc48795ed5ba1e0cf00cecc8e612dc97e0fb046a66de76e84b915681e4dc759dce10048510034f7ce6ff99dbac893ab731ed5ff2bd119dd3eae0240992e7c0c45f9c26b62a7ce1acb5d1c3bb8cd2a2005c6feb0619b736a51320c45fabfd7e7726e4250a5925af992346b00288f6d69bdb60d687b4548377491a7f23a5044c7a6f74066d7f96d295c847db5a84392ca9d0642909bb28c952891240309043b2cb24126e93925f243c1b64145f69ce2cc0fd2353977c1b5a7bd4c1109a9d8a2f97abaa3003a9d7602daf74489acb951de8bd46a4190ae1a976612d8299fe0046bf49841068948dceed431dd549385cf93383bddcac0605fc25ca7e8edb14e1d54bcfeb1cee7cdf22b1ec40f45b53783a2834bfe7a6644f50a1458abd84e4d2a1b131cca985eaa534460ccdb52ec9794fe72d47459d0bf366787c01f55b5a2e6f9a2eb5249c4f27e4c00db9084fa49c94f03cef7a865ddc0e3e2d8c421791432d482b4178822cf9d601344b3654becb41a4a74133a6eee22b9baddc35086aadd2f3b93ef4b9c32620386c0dcec43edd83b59cce309139c95015045c1c22e62eb3060b44590d2c770de6552a0aa2bf0da1a14948bdb5836955f3b4244ad4b4d00519f3e1d43b9f709701f61083869b077a57ebce1b7b7282551dc1b7199f6df3f1ccfa05fe2a69c3eac18e77e3d15d769f435a0dbbf02c4442606656f8b3a7bee8f50e80b631481f7e0a93bca29e194c50814c905e9040eb366d217d08a3060863c809a6ed244054767f2028563845a8ddec2845278d2a9f226bfa96c56ffb7925d8dd8c3e6dd6d7cdded63b756ef774bceede322dbca1a4c618c5f57e67fc3aed4ee001d10b3bd8cca6caa986f6c21a60389cebb74ac8bba690b127c0b12e9f828b50e072cff41710727a649ef8ae3d9431de72cd6e77b3278010a25a7446a6519b733879c8cd30c1128645192926a87c5cdcdd425f91547dddcb9ca7bcf3c20a9e58128eeafdb8a6fafb43bb6df5502e45a7f366e924087aa060457ba604f4472ef73326a4b0262831b40fb0c2cff9e53ad8916d466729c9a90725a8dcf7ef6ef1961d955dd317b419226af0f2edcde180ce2850d758f59c16c98074e20705895b487cd9f40192c17fb28b56bd319b66e3c0c4c54d9e59c979ddc9c106978ca0fe665ba4af4cdfc7fe6986c85714290e21e473f30484be62eea915b4179526d2d38d83ee11538225673714d657642ef4225bbcdf8a2fe34e3dd73a36eb2b9f2e1e29283ba4b3724d8fdcc503dc6daf81470a7552271f8c850655387d0740ff1e9b630880c64c5b46d0db6e7d3ed2a3011773f8503b5e693d5687b105af8a29d4fcbd5cb9a8af0f3ae14f51b81c50769f4bad04783726a279048e3ef4ea1f8beb3720fe782723d543f4834d81f543c2b5fb7e5ff872d3fda607521a21b952fff64b644b151de1197d79463c3ee8c8bc404d02b5790d2eafc1be9cd18f721b957ff819bc36766614c26c8343719455cd5cda03f068b788513657bdddedda70a07ef9d51f9d4e03754e3c0ff66308fe184fe6d07a5a93e20eb9cb1e4a19e636b09efadb08bd270011a318bb7049738cdcd0a5b89a2c07434be1bbb1d426d380e50360a4e2aa2dc97247298a44ce91666b0bc13399b471b638a8372aafd493c24bf62f5d3e2379421dd3cd1a871859543b1743e06605d10e04f2347545d37b9720180adf16371c76050dfb164e76d28a95eef7d5463a8b0506245d292b00bc764a2e3b72f13e99587e4ad3b73ba73aebde274ced01f3fdea10e1c602d812e8b7c0c9ee44f309663ec0d6fa8fecf23d5122915fba270c579af715ad61d47bf0dfb691f0081b3bc7b27692e29a9a176f9dfd8070009f09de63a85c1f2cbfcab8bb7138844e31f9e20275b85c3e2ec87d05a39f9df713501cdd77a7f5255ea57859b925c75bfee9b774e2bfb825905442f4e28c9a0c601cb08df636a5c3a2f57999c17cdb3340ed1e23c28903ba8e0a61de2ac0d4a5dd8db2b9fb6a50ba11e9ab54a805d7e98641da255a40cc21521fb20254ced5cff4e2cc53025fd3d49de43fc3b235ccff1db01c05750bd00ea55256e1fc57e3812b801b65eed10202fa44d453921096e5567b0a7c53d83dedaca847c8aeabcc212df0813b9762789f21666689c221b0514688f5d6b3066491cf2f1cf0fc5e6add0685ed0bb2d6ea84f6e22f6b47904892bb55e4ab0e428c9b471b929007f41e5601d8a7d52a0b0af8cd9ac71165fda9d457529e31ba2a4c5c6fc79aa000dea923df1f649505caf5ac02b94b634024637c2c122623f382e008d9e0fbafeb253f7694266c31ece2b646fdd85fd2d731870e8743c86c3182e24e72eeffb8e07dc11dfc7c8a078d20cc37e4e48cfa21e89a1e2b79b642549895551fea237d363a5f9d592ef6d91039eeddeceb7e8b505cfc2347ed6ad1175059eb2475a145557d9d8db667cd8b03addc079f8aa7842784c3d029e8b62764503aef2af704bfcc0b645700d41f126c5d396871c8ca80aba3ca1a5397f0e62fb265c88a038629a3bd9aac7bbdcb7ecbaa2bce9e2de5a18612033df8d084d39857bc45471cb742db5dd50d001f4b733ef2a36ea9df6f3bfc23c4c5ebf118814cea7bcfb35f0ec966d8a61e8f311f17b4af4901e9947949442de6b4625635bcd7bfa79dcc693026e820fc2cc630372fb39622f55ff5d104e87e2249e4588e10624eaa10ea35d71bd86e63c35f6d411bae1630abc5bb237699c5ec088d015e0bc3a7f409a7f52ca23a1636d5ffe552f1b48bd55f54aad57f755a2a8683c812d7bf8e776b48d7a0e89378e52b3e7550775b80aee1ee0f6315e136a7e48420d8e6248012cd8adde7a57a1b231a29cf36cf13725a329cedd64c014b7e23b93c5596f8059b8a93ad2cc73d2fbcec3d2156f524b236b23b9ea20595f65bc8301824744ef255e53e387ff1dc65bd0373b0efd6354cab13a502705e0eaf16e64939631aaf7694c6856d330315b1fb23ba0d12bd0202cdb43ce84fed9cfcebac0cb4d30a20ce300d08906ee75c7328c3c201beb1e92f1ba2f29ecbdcbc64b013fba78ba71213f9cd1ac578a7ad452334ccd94b9cfc51d2b53e5a089ac13ac34b459f8b1238759e43918927327e8554d059b2aa9a5f8fac2f412bb50c0e402370a20fb25d12371b1f373913942ef050f19e28daf4af20e4400cf1fc3261ba8dbb549523054ecddf5aabfbddf45b928cdf0a8e2a35b4d697dbfe519dce995e12167c6724c21714215c37e624d872a9a09b79f0ffcb86211e94231d64506d38778c611972a76de620a53047d436183c7fa37fd07f81865df35e4434ffbaaaf145fb5a8c20f84521b571f67eb12e60e0cce259afba060451ffe5cf439fb6d8437a27fc8a5313b170ec79cffdc2a61fbb2e35057a2b7304b831d391f9e4fec94a3f85b5e292cd3eef1ea287b9fbdb51c5bb2a30b365265acd1c3d00550e5b0447534a53da95e52ed61bb33e775815ebd3a981a548f4ed791bf77bca3723c6592d75a5a2bb31c99427c15809abd9ee780687b7d6960e86b6598cbaa960d3c4d01b71eb90297b7076c3c90b319545f578455f500f6da993d845d4d7a5cc228d22c7051c52d8184a349a5580be8078de08982d8a1d26f4ab55312a36c50983b5c2f6eeece23c2684942d235fefb85cb52c074f01e43a0686deac825d884233f6688f2360ef4cce75597b91c44b348de70b9d278f719dddcc714c54ac54d52e72db582695f989ccc12e7fc358eb94dc89ffc5aaf17deb13a442ce758c4a1149adcea61405198ce13796ad5fd4ea20ab9f9e8c920f310704793c3e2dd5264b6a6d61be1c26c6d8a5e596f0935d61475fbeafb60a55a287ceb75087faa44250961b9785c91418d9f2ecba88504002d0bfab2ffe41f0f1580bbbd5e1ee87c8054e0c9632ea03023d9568016a28e08f5ab9e6310ea9da2c77cc511e41b246e88233c38e4ae059d3b8476dd3ca9e3ebeac13a8b4037da03840cd21678112d2e0617cf25bd3f86f49e1b5bb70d819d0b025306c5d1f5fb280a0387753059bf4d37e0b40a7ddaec0b024cbe0a31df6cc12a4fc440818af7e755479c3b1051044dbca6af46a7d8ae7e8543a93bed232c9f0f338afca676b3ebfc082436aaa71d45e7f98974e7154dd65c15c20f7389e9c4b8b4c9a3006479aa1fd44352a161e4b99b402666195aba688d7f243018e52fb13a7c3563f00d33dbc2916389dda44ef44ae6b4046f5b4619e7511faac21e8c4466f1c2afd7c9d9b79c012f2d50770c28fdda31f03956eb9580b9efa51bc840ffe6bbb60c3456b7796568170f0d69f576c6b0e778284fbac4d259ad79292e7c2122c343cf03cab573ef9fade09c746d9193dd840d9e3534e2101ed7993194f5808938bf7b30879c6ff8db36338f56b85120895ce4584a4fbb1f696f129ba22e37a902e1ea9da2c97c0ce193623cf07fc8e17b526743f4a412e2961b03bfd73dd032320f9b27bce37ef40909844d56c039f8dafe3cee0c16fa23204ec96ffc9b8359d52340e9d7cd1465079592562df5ccbaa0cc504f47dd868b75fcf236e775099f09c47f58b243a5e243c488e54756fa08dce12a263961217f896e0460e6c157c97485ce4fc84bf1814d5a52d7f26e0cd67f7832fc902b315948c53795e82014131dec4d3b1913f101cd63ec98e61d9fa07826ae84443bf3e9f31cd4f7eaed70252dcec63dbfff06791fc965a86514aae80a3b3479d86fd5eba2ae9f509fcc8e6d4937b53a2b61208b5b727462a6ebffc093454b8c9f15543544af222b59a7c0b111f5607bb250d8347e6aed5040ccb57eb50adbe341d448d488c6723dea10ed7013f5c8373f115f6f608dadfd3b469cf88a6690df9d4ecb06d62f37fa843beb88dd05f883f18fdaa87feaa82e7714bf18b28e6c45d8bb00228b4e16cbbf3814fd8531d4db1c8370dae2de920fdfd1c5c95297ba9ab7fbe93dde32a69f4e07a84e34db2937672c89553a4ee54a4e86be4ab85a7ee70e98670fcd598701e7b2a94a6b682e040534f6529c65e186ea2b7d6becdc0ad7f908a459e15439d7d9951baa54c61c9b78ab5c3b096de2b4a259bc09a298ff063e9b8f7adb73d81f6ccdc5d15aa2845916c5d6346b8338168ac50fb323625e641682e90f7deb4b9913d1d374f6dc75997369b88e6c459f91f4d55c86bf81b532156870ed28d69af9227119587d4415f0011ffc9b4d5e79a1de8132ef9095f95398a5a283d66db04161b5932b6d30d1d651f8900cc0c8d4dfb1f846f350fce6d67730587a30916a415cd8a02713094ea7a22cfeb76d34bd93ff26fc899897d6a463f23e480db1e4eb161756451068cc5d34205204c6db0e6bb288c6c6060346914c0ce08fb33c52bd520e965b50cb303d4fc52f25fca55e8fe9fa0750040cdbadca6a132dbf8f7b51c7117983498e1d5c50d5a6c1b04f1902ba4409528621da3a7e9cbab74802e282d6762b047b2b6c95001c796c589255b13e148c059abe0563caffef2ed5a6c9d6034dce2b985f92a917a3c7b366d4dff008393b77eb4172043c34fb865de9bd0cb26c6a0e096c01f8a07cd513816bb7793a0a6c58df49500562ff04b58b690d0862d9d95ce7a0a08552065de710c2fab788e8b5b60bfb41eb76838132f4fee35848169f65115fb869492c21b9f9412553ad9ad6c50d10783a8af3e9db4cc9b453301be5d48d536240fb768347049dfb95f2e04767a17c88715571992fdecfbc1bd218f40d508d7024ada8d3d90cee6850abd9c95d204bd015cc993bcb9a16111526f507ecdd926059898fdf3cf76b9781c1e2dad9b97b6cb13217454ebeeae53e806984a373055ad0800012e186be9b78b22eeb6769276cd51c864dc9c00c5525c8a18b2c62a1f0233f5b398b72f0a63fc12fd6a0c6b8c2fa070089a87baadd0c669e96bf48093fa9bee29dfbfce65e7c330f2830ece07d7af1b5599e50fd99a4f4537baec6281e27fafdbe26c10235c60be0f5914ab3e56a70acde995db28322115f6e10db2f128f8845a1abe397fed36fa1c510e309ab4152e638a9e3b25ea49af291ab05fbef16127185d4a4831c94a4601a654959a9efc9b965d53e60c084f6a942cc5b2ebc0933b0333ac9771da7c22c3392557e2969fd00fbfaa3b471cbcd99f78db72626e5b0d25ed355ea46fe5e55718ee373bd9e4a25133c9c37bc20f20c4d0c4accd2ed40cfa019a89a3929de684b34409646157bc606c3d85b6f4aec7671030af73f441d0dfaf11c8672120515c52f19f1ca20b2c26b71a1a62841f0f537bf2d053b90eb55bf7e13562befad3eda14f5e4c3241e9aff5b1015d3de4ac58a79864b0c5f20b1670601e3ffe9f5fce2435f72fde4e22d2603ec1bc37571c4db55106fb92f6b0cca25e30a0f5f81bcb92efa6e97210a4ad19dc548d40d2b1b860a2492efad086cf55d86ddbf4bf4f66dcd02cbee97a42e96b25433662a11010e920c254544c7cf6764039dbeeaac10d20e5591da9ecbb6b2a8a0a35cb00d25fe121d559534b4a2d92d5d54d24b16f1359577a1beb2202b8e3114073d5b7460ba9c27a111f89c0ba448d25df538b00b105e907abe52aba9d60fab12f77b51a28d877d6f7b4bbcaf10292008ebc029b9c03b2ce5d1a0ead98a38ca7a8c273d08c97e3c5dfc8e1fb6cd7bb498d988ce7092d7b81e08d95c42f8ce8733ded1c7d11fdced880afd7f035883a1727a8e83008f01c3ad4ca261058ca344f8d93c805d8d81eeb60266eb72dbfee11181494543400ca6c980a8b06bdb50774ee19ba944076066d03f5d83e1e65388864f1c1a5dfa3f5baf85d37502c250546ecf3f83c65bcdf4b269ffdf87d5444f6260a7574bdf6fc4c028d44c5b4a42dd07d9339e22befa7fdaa06c4b3212619a741693b06d84bebde361ef23d0d8b3991454f0be68c28478af87afafc08c0bed8cedcd2e63453379d5ea945c87ae034d197f40ee46df42443d9cc5fa84bf07a87af4da1661ce4a681b79567e82b85669e8bb23f923d777eb9baefa46c8dae5d73b550fe78abe615a13f85ea744ec022c42264465556b150ac36c8cd12ec9a85382b620d4df6fc13d4b28c3eb8700c8a1d0e17a4fa21b9a153f9c4f4b9f82bbf6ea3bdd64867544223583336599b2572146943a12657c83607d3a3df57cd85c4afd0f6b5f39f99eb9415a33057f3fb7e6a4d84eb580fd93cf0b25d0db4c3ce3bf9cc0c6e6070c2f754b803d1b6800700db08898945d924671c1813efbaa85c4da2169cca9f09bdc3ec5abdeb8e93fafa0d7c0c604e05164d08b922e1fe4216dd49667223486e1030e69748505ebde7e3c7751585898441210719f865bf91cc748fff5fffc79df9720977a0e53100642ae8c15472c333269ffeae4f71004365d8f0a137d1fb189409c34d5b43efd0296056c52485f61dcc0104a6a236d9dece5dd4d9efc9caed40c64ae00749b5ae1a025158cbab65640ad01087e872d9d150c124a6ab9d1009cf4580b08a7e0b569932fb8953ae718ebb1a8e4e16f66fc14ee252c62487d87bdec18926d63b591764f60f6e780263f98c82933bb40d3e941de7352621f67336b68a0a241737f982922072653b9c1fff4b204a521aba0888c2877dad3561cf18fb3dd2f00cebd1ad74c3dc4f29950fd7ad3a3027fff98721b30bef526c7b9fa971f64b9bd53ae707cd96619368396d209d81e5daa7a9cadfb69e25b2dcfa62c2833d03b7735bc422efddbb9bb669ec35d4e02eb65ebff374d79b5a38d2b455d15daa1e7e356ebf2f6bfb7454226eb3b0144191e30b9e01e8625bc196aaf92e89a3a826b3dc91bd1d38901595ffae321b8d3df3e6ba8770b61449f8825a8f7379e0482f0cd75db2be5f7cc94a34f881f98ff66cef12002c31fcbba563867ef909c28f4a411484e903fa48c50589c5b8550b7b11f2839a70cc21468b9efef6b0753f51c859bf5448943ca8c32e800e153399d3bb89ce96b6d22006bc16db69929a057df6c3dcb81e298bc571a7f21c9a06e55e96457f36664c83170ce45c751e060039d5c03c690996691d9ba73933386ec31c1b91ff0ed8c30efa9a37fdecd58ab92892b0218035a709e2f32a0f8aead547c3608c93150295f960f5dd1b2cb74849f86997f24930aff733e52f325136d7b7b50cfd42a900523e1790e84e0aa9f7234a029bda7bf3ecc5716b1ba3aba13f8e004d5c82da2301ed4b2fc7e1889fa65d8b30598c33dbe1a9bbdfd050d88886385bd115bd6034a6f38866ce4bd4872563ef080d70ba9d9bc5a0a04543e1741372f9c6070d271d520cd072cf403b078f76022f2aa1d7f7e7ea032e1830e33e151c7ee38d9c1e7dcbe5153ae0c66b5db00f24397d2f03fba220090248dec98b29306f286d03fd23a8c16068d485e8c95ec635a265e03d4589c16b4658b825bcfabd96ad204195e02b41f316074c18bafb1e846a194f3d6a2ca26f5b5a228314e9b0e80c4feaa0866ca960f849426d5ade0cc50fe347c149d79135ced9c3e19bd3d4284f1298e5ff4f38e2d9066dac2fdfb0d66460b291020780c67eed1f51d2c8e57c6b66e9849b10ed1f201376eb820ddf7512ae43ae304a61d70943cd727b6e8860fc693e69897867a060742c39a95619914ee617ff4c829423a16edc827fd5e49c83e146fe65e1d3a7dd31f23627dfd02951372f65dc79c17203","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
