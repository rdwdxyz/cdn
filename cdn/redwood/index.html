<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"322236dfab1dea6fae9951536137221769eb4f8cc1962b8630ab06610dded7d710ea5f023e2c5d6ba9486ccfc4e9ec6b4660fbde195ca21441767486cb61b3a88b6acc577363d63eef2ab6d385b3a4c51b6c929b0b9bf72b292489eaf7ede2da71947c0925026bbfe1289d9f0894dddbfa482a9d41c62206226c0f3c35f04b485088038b8fecf07d25706b8a70e78822bfe2215cd158a1ed8ee7ebb473145074cfc186426e017401a384df9995e11f7695c8ac0b54a477a8c1ff057ddc643c59512ba01df9321b5ffef4adaf2d2388837a7a1dec7ec08a9c2f66512390e5b1f35698b111b639b3c2b29b7d0d5c850503be7cf85861817ae89ae88da677b4fb15061c25a4d09ff2807383dc8256c634e798e5c761fa7fd36bd7e070bea1bb371cc93ab57645dfa4a192503f6a6a406cfdfb8178dfe83449f6c9d2000fb8490bff3fce5b27d93bdf23c0093f29e6378cd82be5f695efef9b427ac74ae7d802f6c42d04180dc938e8f4c7d0407e26367717552410d594ffb2f037820360b322c8660a28edc2929e4c35c2573a9b4e531eebca7d735213db26d64cbf2b61c066181d4aa921245680d4a227d3909771dd0a17cdd93a968d93906ece07a09f86ce3d2d80ed7a05b74000ac998550318277bc9fdf946da8b18589cdf200124784bba627df2034a8573c61c983174dad6174f37b638c384ddab8106f641f717ce88320da7e5d8e95d8a4019c7b555ff83227ef2fb87cf86be7047c764fc3016cc821319fb52387b58ee20409e2b3a5e95aa78e5b0b74f9316e7d1ab1e6fa8b0f9dd792db3209cdb352942dce4864d349e262bf8ede47c0e78d4184872cd1d9dc38c0ba9b0ad9d574fe3335e7c732155417de87927ac206b601279f7376a34f42a394472c40f94a6de57d7335723087fd0477f5aa892015670098dadd81f719617424decba1457076b1575e748fe1a573cb5a09ff8afa7fc3cb360b2e678e237f4bd39e6f8912ed0f92a07b77aa361e71290d9f1d71162bb4a7e0f3ec787d29cc37596997ca669397a4e38aa64c38dd70af8aef9fabebfb420ca8b62be13bb897ffc73bc31a30b3da8767159114b356cf14b1432e4f30984ed20380db569d416871a1517c6cbd1eb0c10b26916c2fb9e5c93fd34398b4006e0693fafe1c16738f326a0a71b5c147f1e2ab201646e9b021af500d67aac07472588a8cbeca04180096acc59a21940bf6973c1a0c533703a3771eaafc0ba68458f2f55f69a4419930638118b2332c6f18dc5a84d46a58f4b28afc9978ee69f5c8e01e62bc82593b56c9dc8fd945553c2125af772c72b2dbc25f9271fc04afb18b6241c2737a4e389c25350a96576231a119146bbbef6548b8aefa48bc7c7ffb59f1848d8957f1a204c5005b5b6c86d659ab76a684633253988662f1cb1ac2e327b60543163d2f69ea37ea75a7e28fafd8a95b4481fdf75f9744335cf093602aec18c026473bae306fcc4bec580d9f6982d435c00f172e5ee75f4e91c09e23254e61d8ef4296d11745ead59b4ea1dc96f3f026ed8c710338147312b33bfd97d03f9d07ea77446665872b014f724aa1f43aa8f1959c9309995391bdc202cf91ee8b92e7815aee2cd649d7354d8a3767d1d3660f8c6bd73d0b298d7b44b24c16f93fef5ab6b104f66ed1b4076101c5fce0d40fbe0427539cea51248522ac60e9d9da3835a6b54c3e56af6c5a7bc7f14dbbab1b307fdc54cdb214faed2b0f2fd9b900416704ec357710776a5a84931285b436b2c16feb076972f68808c9a98fd8d04469bddc1ea3f039ee54c64f9603328de037cfa830697b75b2e84641119bccd46a79c84df9cb3dccfe12e38b80d7d58b64e3a9727a376ec0fe35243a3bc855f2729da8304f8fe3222ebe9b490b467525e5c0862bdeb07d22ebd38785ff9ceeb7aec18f7583ed7a680ba7b919224d0be153029b14ce7b76158652679280c435e4b67538d73ebd58c9ef35ed34258dbc12ad6b6f456888eac4978f14f27f79d688565a602eeea0de7ad797d37e6b3ff24918e176d1c87e8543870afdc4510eb70e21928f53525908f14fb8bfc142da769e12f28b98ccf8906a7c281f87be095e36f4303459fb21f51f8da7e58dab86d70964a4632bc22115220d2ace2ca567ac2deca7cffc48f454b98fc133ad45ceabca68a6b0f972ced8c1b6b62d5ffa656cf28fe29ae11e1bc5405b32f58b45dc06938be98b21d4607b4e963088a1f9ac82ad1b537d97e7a11a1f91cc6da3280535dcf2b0483dd6d2b4424ff53879166d52f154e494c521682ecb848ff3d8e777fbcf7feb2715c39470a916e9f15a29703cb4526486290e45708d6b6132475f8bbde42e8e05e9869a31cd97e363c3527dbe81dfde73f90ae21f484d4067a090e83917b57c05efa789829e5bd0e0f3a70301b0a69ab9b1357ad56515b07f714357582994ac7da8e1f0761bef69f04783460f81295cc87f7a79a23701e0eb40890c80984442c2a6d8cef7912b653922dd50a79c19e829c1f52eae995eb76de6af41c4cce608e4dacd4817fffbe0a00884e3870b4f149737cd14df68f6e6ab6142185f68f09b2b0cb7eeeaaf5d48d50ce5899dbd717c05697890ee17be192c5e3881046236ab330f7070076d071dc1867042e00a7acbae1a7be8e431c55d173fd5702078cef23fa4692e6ea451a127b738c8f9a657503d890c01b8051bc8e0f073e1d7f294738ed92435e3d28d5afed8daf6502cab469495dabb98ab39d1871cd1ee880ac0bdc2eb434e935c612f7bd1d7b4cfa2f099d779178d8525d9125350dedaab350ceee27a36707d7ab48fb9be44de77a63e8eb31be527eb560bf94fb9e5cec33ffa2f7daccc9a8ac564c2e82173e21b82c59f794e90b8132a2388b62f03904a956949aacb529d9968e09b71ff5d16968d1f29de9edbfc9264902608fdcdc1474a11b38b4b0688b048b4cf444a6b9e00c9232406bdd6b47cf46f3bf92ed58092262901b17d61a00fe49ab83c0391fc17b3b4b77542c64ed425bf316cb0fb326739b9d526de26955c9a7de2df2e23760131782a1ef27aafa0fdc0c02eb54a293d99d3efa3956953c52498ded9ea0d39b7446a09dbd2f56fbb864333630558b77e1e76bec91fbeef1a3a34a521dcf6bfaa49ba54189e6f1f7f2e0367c23a29c82600f0f7fbd6d983397f86330a15de80e262999ec48ec181342bf2308f7c1e1d093d81d5c9bc05875009a0822b1434c03a3956851f9d6656c1badba5b3f88115a533b4e223c0d84893f94c6ba37abac21b4a5089516e68ca93d746ac5ba3c544fa7b9e5ef3f7ae278c98b97d5c8e3e91edf2594a67f6eb59ee9eb97545769e041c803685cdcb97eb2adc88c471f6b52d8b7c9e182264b157c91693a2e3c0ea3958cdf876c77a99b431fed6a54c28220522dea3845c41492bb601a3a1772c325c32f47b139592de5c832965370b12b121497d4af0f4b8a19a0c3d5ca8315e70b850204242d1a3c338b2e4ec9095533d275bf6719dd1f025ebbc3966d1d6b1e40925caf517eaa507152f3b1ed248c86d34b4aa06b3c56c4a533ed9b9cc7d90eafc0eb22de99d37d9d3b18532acb8674b65d6bed54541cbf715bfbae994bba6058ca76840fa56b5d4352331db911c4b534132bd1df965d81c6700cf93af1f6533779183c7678617c7a952bfe9dedebdf7494ddf41af3fe56ffb9c31457e541a2e7ca5f48b50f636a5c77f3ae3d8552f1ca97db54e55cd4a334d2be79d888cd5e6283f08de4e09ea50814dbeab992891077212ac8d0a845e88f47cbc04ddb965c275e8a774b92acdfff9202f9b317586bb8889493c725edaaf042c5c6c435a5c3b02e95d60a31bc3a83bdeca8150f5b126dbc15f151d7c0d79c08fba25839d9c1f863b42dbd4b7f8c3dd16aa37d5d61a85cb8478a3c1e5ec66c5689e66c817814e54600aaf969592f18b755066e333027d6b794b36a9db8492bd5dbe1c8c3da9f19070f25451e9f2a4aeb2b249d5d5ac51c111f456674bc0a9730f43b291f94f9a2d651929e3796bb2d25d14f955f8fa88569364bfcf57b66a6164f8c104472d33d8c810af00044e79f748aaff5addcfbc9263efc3372fa2ac3fa6f5bd4442c33e4230f8f17400f05226436b0b1cc4f49dfd34e574e53a19e0fdb94bcc9a615c0a3a8be5f3777debc1358ed5edd0c03bbf03d9e4d7f4126434ed26aef5b44093988b3f4849918c57dc0ae26187893957aca42681cb6ae3af63d79ecc3327ff455f7d708bcf34e27ee3b4038fbc1609971b2ffa4a36f588fed4283003e71eefa0337f73c2eaa5ad36ead5b87d710b54c5e63425d174db4bcc66dd3188341413ac65435dad3648c761b5022e5dde1ffcdf12a2bbb15ac8137e5f454d92765bc68a8e4aa8542e35e276ad16c42b6fb359188c2484a22ecbc3e0874a87a3e14433ca645cd94c0ee7ad375a42358728eeed66830852196a783064c0526a2ebacde4a16acb52d7b1ed468e3aefd0014f83dec30a9c7c529d6f42eeba004a6736c7d7461d7a8c9839975533a3f6bb0c343c0a29e0e7aeeaf98aba80c5ed030e83d822ede92d1b903da1291ef3b4ab0a8bc9f4fed2bebbabf95c5f6d342cb09c46a65f9ddc5e1b748ccd5fd36f621b1d513bd476bc83d0e4ae1045048639d9e63cd33911f2d160c5acdd0bad504e90e5c5964a5d49954466d1c244895fbecc8e94a1eb40b2ba719420e99b78c21a77c10e44d4d2c97d790d02b4e213d9fb2726b0052792fa26398488941637675b172e0c9c9bcd901e563cd0adc95dd5d7dd45b944fdac3360c324045fd6906a42142b0adad5bc1e1b786644d83b6bd5f64d84aa33b231e88044db6c734bd9e877e290e6dd259d85d52b1668e28ea683aeaacfe91b125cbe8a26979b641d404f92074fe782286eddab943f92fe83884721ce54b6ef992f47983bcf6539db37d6e655a3011e25eba499b30b3eeb2829708c20c28f51622afa3c71e96fc090a52df39d520e4e8f98de41b13b720a0f627ff774208d034f65fbf2d12b7141e0517cd305f03c87b05e27144ea38b7ccb3710cffe4bbedf549b4b9eeccc5cb9bc1be18a73df1bd188ead17e1994cbfd4c154d0c327ef42c28e41a234922b8ee42c7f1a0c1cb1c3802f8e1e565dd43dcb3d4f5ebf3b84b8ad796df01af51557d8a43e760b5ab1def77ceb757c82467c252f89553432a973ac6ad8399dc47f5640876070e24950cc651b5c6b3dfdf2850c18ce34ef432121e6370ff6f41ae92207a5284ded6590cc7c17a98e109b59db37becc42536af2a7f6ad7ce8f3bbff9a58fb3a88e52f808890aa12f8f4eed77d297389568098b77aff51e2e23bc9211b832c5d5bcf63277956c43ec2e17ec778fbc3307eb4c09c9e995ad42ae2cd2de0b9a0f99def9e8a607f59808636fba8e6bedd5eb2f6de2d0f13847af85181d6c986bfe3eec749e305e5ad060debf86bb3189938f70b946a6525488244a6448189a24c991659fa92d054c4d57ea4088981399e25e7924166c633cd75c0312a72cc781ac976168134f7514ccaa6a08be5486a0233391e7daa108791f47f0e38cb655a02b59554f526cfaa834a55a32fe06c6a063f61d84b9fa787b65237e9d6c41e94d7e429012405489dbc5e7c48b840d256c141aff39f1edba98c49b4954bb0c90e60f87aefb491972d24d3ca3e29dada1872f4c1c9236806885006b5acbd7ec1f3be249e57036a8ce3e8dac4cae94f84d24c00a3462f2d18f15f1b9e5a3e8abbc579157b30b476fdd47bae58190482488578844b5db659797f35d61cc87942ffe0de93b6bd38cfe06d32324fc9acd5b2935662b4ae5dc03251807ecd00463a69731b60b6c1db91fe802a4b1cd836cd6d5e2ab79cffb9c71968528c8528a356d4dd05fc03f23492add1356d6fefb686480b4f245a958d7c75f0904fa5c583b0d41200769fa18e5d143a938a183d8a5a4ba93661fe54c8eca40f611725f1bb5d8272e50bb00626aae4cf5d2f207149b44a0f4e5cdb7fa96398409572b4f7a1289163f8f6a7d13509eaff87a223df424003b5734776fac0f70217b957ef18e4a8f02af7399c425abe411e750b2f9a832efb4187e00a6121fac64e4dd5005dfdda38040ffbd1a004c4317fde6c368fa494887a3cba9c0ffdf2997ad8f57b033ffd8eb4e8b4cba2215ff5cea14257cb74db0f13ddab31ad3b7773911dfffbcd71dc09c25de1e102925b06c10f4fc5b968939914b2c6bb3f50501c8dd84fa8c4cdc16dcb64c26b610c26d8ead32b91723a1740a40943e55387ba5e9bdd9619720c72a37eae5bcaf6b310a018386f9b82e58b274df561625fa2a3c36b23df8f860a4e97b27fc75c144b674a712dbeb455b337c81ac82e2782e3478df7e86ae7e788a86d3eef519d77840bcc3de0f4660fa2fe15840048884b8a2718df37ae86629f09b79fceb108124a6228c022e50ef2ff2982e288ccbc9dce5b0a9c570030b033de04fe1b9b5103dec417d497b8ec754431126c6dbc886d12eb39fdaac38ecc7b31eb7fda314064204e7d8c74511c8a216bb1d381f4a19e0606afbbf05080f98bb75d69fb8d5db161e04934d4d97f713343063b0f6665862097724b20c66d4a5ebc770b3f9695a227ccd0ce369c4af7488c9664eb08d9263d4c3b0f751d30bc7c73e9cc4a1c3f69b16b21b2f116f2638458461d9e3a6a462d83b7e389a0570deb58ce9429ac30ab80a1ff920d3b71786409afe4e582de06ff1044832ff764fa9eba9efa384fa0c5cfb26da7ca27eaff39f7e54dd899be0f7af8f689d18077785fd7528a68e219b10ce3dcdbbfd02256eca022b98d4cd2e5393f0c7f8047bdebe077d298e35ea5735f0223ab7dee7c43099fd449e3c9961e312043f4f17ba5a13d90201c4b55419c75f85e9e43662b6db461ffe71b90c398a88e5428bf7e78d5221e3c305dd664dfc3f8549aac4752771386ea09f1b9b7f5eecf7f4ecea517d9baee6002fc7ef4d8074cdc9ff635e5f2995b7425668508f1af5558cedac758cc2278b384f8db9eb418795ab93b6703a756833ee48bea5711cfe3200f1f61ca1c1c00b5ec901f1c2c1f2b9e22c3c35fd0b49bf003b4c9884a7d398f59ea01df85c7b6e43dc8aed5705fbb97b231068ea26993c1c0ba9bb128b1fca1cf2f24a12c4e9d9458647e3863f518be74505b218ec8f0af8140ccaffa4ffb3dc897d980c412d1af3ad5ec5f0917680c4da71c69db4182e02a2ffd3a5f0b6e7a0a1bb5877d0b5111928904bb11a76c4e44748d633274918b4dfcf4643a47b85b6c99044dccf2731c2c081f993f83e8320175d7f14c5cb97bf499a306aeeec4e681baa6138db2c92aeaca86d7557d6e44a3502273386d48c75dbd6ed498ce6e4b471ae86d3e8633b557782e2edae03560c9d74eb17e28efa45138e010aba1f92001416155d82fbbd6ed9e8c1303dc425a9ae6f01edf91d6a899a203ac6e3122ac3fb71223c981334b7e1c7f792a7c7d09708e0d92a88b6ec29f57ca7b786fc46e5ac1406ec73da1012cfa8e6ef3e549872df0374d627eaf9eb1f52d98b76ef556ac73fa6f59ab541b7df4ec331f754539c784c59a1f351aeb5457ad188cc02cfb9cd8165c6f7bd677b863a71f8730d563fafca50ebfefeb9c454844a2b9e2d4caa30c5b0608ab4a8e75f87680942eef5cb0c916fe89e4484c7cde124cffdcc9be118401d276d08690e2df2ba30dcd4e0ede397a5ed8799a59311aa5ea60a2f46b3fc5564ba575f9d5eddf7857e978522d9db5b3e7c13f807c6a73bb4cedc85502e3bae152c890497a303f81cc43c126eba0f495c0c2b219fe9f65af12f1f2a520532c8aa1f96d2872d81a86ce7fc8fc6ff134ad64803f5c12705d59045680509cb9cc150634cb33e21efc840411a4f5c6b2737d7b42af919220717ffb0829386cfb9e7b887ddf6b7813e3c1b377bb4f2450450688ef98a0f7ca2657ac2675861622be674380cbf39f5f57552514fce1b573258f8ef2b01f0c7156f2c92b414b97be2af93faf41500427c4c85b12046b4bce757d2144551f69380cac6cd81025530d9b70df2bd395c5f06269867e132f1fd36588394ec7ba7a40c5f7e449c569e97ef421244bce2c533b745928571dc139494b049cf9e1b3743f59e525be482e8d087e6f86122d7e1164f0443b8c790f5b1895a04e4376b86288ee05805fb3c89dcc21f8f8b3ddbf62070fa4cb2c1022a65e6d857587a47f60f2f7a9ad686bc99f8e020fa145fbb3165b3e4dd07eec0b03e0e8b240f54dc115bceecb2bd863b4a7934b49553ae54db7ee5df314e616cca48fb37f3d763bf31cb4b4907cf7a0bd3909e6054e7ad34ae33de4cabe3be82f17f33b5c11d9fe1a924c00d7e0b41d6fc10f89f085fa4607db897a7b7c9e897a21e4f5d336a779f05ff8674d63fa589e1ae9cd2b6a0ddd454a772c67f2e694a685b63fbd6841d1eda0a09ad24ba4cd78e99afdcbf66f16e2869bff21e31acdcd29fe6e8d1e275f57f564d81eaef49f4550a58fc78c06722e3fe8251153a5346924d079e349474775e12f21e2e21f13bfce0f68e6e4d871335c20e7482aea6935bdac2e6e031f0af5d08c942fd37a35a9b5c8295e58e621c03d94b29f08480c94d25b1966d9811c47415bdbd2f0a6bdb755010380051406f5f5cef46ce695e3a4fdeac586e77d44af29445b55e27042120ec064ba15fb56f4a8879844f52bf016a28515cb5507465cddef3cc2e3c9da751dd3a9977fcb106a915b669c58cd03eff3047f40794f866a92939e562e580ec1936d204dafbcdfd00e29f65ae378ffa534c6775cf1f92b9fbd60fd4076e99ff46804ee1c5029065740090aa654237fb1207cad8face3ebe8da508d1b6138832584cfaacd0a6e71abab8e847f4cc387c090d7616918eb57c2a826946e563a33b4a5d78efffcbf4938125ba1e512dbee0ab17cfa6323457a1bac7f14fdd57f909e0866ec76c01eb501e544bf94e7251a13c7d6daf6b7dee647aad1904a76a96b75c64db712fffefdac1f014c25449ce9e356506a50dfd823f603b78a9b019ca690be065eb84ce1060caccc50bb60ab77b72d2e54f91577bf16ef70ac9de76fde5e55558f6b8b3ee51718882798fbc91e20c7756b3b20517e4e9f82b4aff723d3c524ae901930fe271304af13d505700de23489bb4bf41a9813f215124b75a3a3c8b2f742537253356623941869f4e2dc711e19650d825c6cdf7bbad45bb6500df9e61d43c45a72b33941d29a3beb15263611c994c022a2c1c0ced498c0289a542fa7c63324212ed90c4daf53732af7bff1e65b987b63e5db387268640d68039319bbdd6aadf1ad3be3a6bb362541dccc26dfe72700b8666d1177776beaebcbdf5a387120f53032d4eb7afda89ddf49e02b0844c87b773cfa67bfb631d8407610786524308ef11ecfbfd08f9aa2296c2f2321688e485edecf318c63996f243df576d53272f9eca7f3d8f47d9d94f62f68f62bba4fbfe76db3b4379b0207409c7697bd644cc5e9e7c4f7a49e8395cc5885997c884d4e231f886d4194df0470d3fe89664688e933728a983df41f6e5120e6ead09e08989be7e22d2e921702ee050c865d159405d017426c36799b94f564a9060ece42adde7668b34e59e2dee71438e2f0088eaae71184e875a7097116df3d2e296ac243317cf95f03c848af2134620ca8a98a80270e334e810f382041da74a16d8755db6784cc0b770155f1a86b9d518cf79ca9166eac8daf232a367c49d9b9d79498b10840d03aa57cccd2a72d99fafe9e50cd86afac06908464b27224ded713db1e4b1b16853a443307eac975cd512442d7d292441672d29cbe0ff27d427e7e11720c6d6dcb7090a05fbbd202a54344f5aa3888b184d8e4ee02d03330ba6624d12e839c2ecf20ad7fe25b4dd58abc8abdb459a769f544399ff33ad0c80c8bd9ca7607dae9c3d9d6b77404b4642fe7b5acbe06034b1a5fc67b57b0a20389c9c050aa07e3cf600e4ec908bf7af10c57012c3c8d8a662b9d6505f2abaff99a61590dc3f6bc5e9744b8d2ac02a52e350472484a98524e7a31a55f5e2e998b2cc96de3f6005d727bc3e31189b063ef3d6124f5a5808642339d8e85a0555b550ac5a4495f8ac2334fc4963138d795d7a2d3a1e46a3bb1b757dd610025e0fc8af1adfb7fd5fbc30f2c1497a5b6ce74e702a2091e81fc72f3aeb73b7b66aa397e63731a496d4cb7ffd284352f03d8c7a2988d1d3bd3c649eec58d8c97c6e331b20f9d7a731805db1db59ea120b7770f9a81a490f0847d5a2930fd83b1cfb5076003062134413696545cc10ed3c580eab1bdae83cfb45a8d3d22868dc30ed02ec453982f5ce46b447f8eb47acadbb75608ea2849e53796809c23269bd2ff40595e4140a001a39f868d0766da75e83e40c866f173fed71e5a3a99409295ae8ec6d4ea5d0c01bce9d3a7b225d38433cb42c19d0994ff904aee9ca4f861d4b1f7d4dd8a554f8d1ddec58c2650fb1fda5f2a226bda835e077841e8945c4f231ab4b0ab89cbffd6d44c7001e7ed98efd275f6dc360a76adc073dad8df6709d4aa402d9cd191717e25236d4d36064575e73c3277462f924e01868fe550bfa0d5d5001a46c7d878d14862e92d87dd415a51ba6d5234665fe808f3bd58f1c7084be8222463c0a61324a291c26e5e9ea80cbe716d2de7d897db8e4cde700194b343dc9bb1a2cc7c1622b97f300155e615620b01960ab27d2bc6b21f4ca64b3e1697906a00319f4fe8f63cddeaee64c576e69994d222163ff12fb487fd3b534789d3d9623c54b211de0bd7338571c411c05398183964fdd84f97c6a439f9a80b3ae683fcedea8ce72b8a0a72d88951fa90a4fb2917c8e0bc8e79c6b2dab66e2acf7dbead0618e8d1673c4ca8fe13781ff1c201777c4e2d80edbda44f88493bd38ced25ac84930742aff08ccd925112c695a5d25a269826e561ee9e455035e2b30b94c2c881c935abf0d5790023036fea8df1d9bf251f7453955faacb245d4ce7cb577d64eabca5ad33ede9d2e3661114acdd4e6e767f1122811e0b54fb0ab92e908feca1293b07c708fad48f22e8e17faecb8b2d80ef7680b245551defdb3775084a237e9109c7e20e64c11a58d1ff6483d893dbe8c7cef1c7e15d9f180f110b75a50a0fac7c425051d32869cff67a2980a46df34eb1e5d019d8a8ba62665290973ccd5809322c333d028454bc5bf8d46ba727848ff40b359cc10fed072037b55cf4457da10307611c6406c3092d97b33dd64c315c2bad5df372f71de1750ce448494b2bf3f73a24ca9f94f89555c28ce05292bad2fc01960d25b633f53e719be3cb46fe14e9956b5621403d6a3147480e5f31f17db7f766a511bc6f410f928cb593d160fb0a2d846ff1832a407e2655c092b55d2e59bf3cb7008bb0fc47896dadd7c4bdfabc3175f46a94a9d63e4bf2f5355ce6011b4c88a226815673c5d9fc8ecc4c485244091f1267ef004ac91c1c560c65ff18ee37d3f9300ccf452a44797dff4a129509bd40b714ea3b3d2c3e8a786ff6784fb22fb0905ecdc2847c5bfd6f5f19e53112f45fadfebfdad0a82474242b3d49dc9f831aa0c9669cfddb781a8e33dc7147eccfa86eca16f39c8d4e732b75941b2b1b46213f001800357cbd7f72a422a0b1eb310c421a00d11fe58c93ec110c04cb0c76236eb9ef44468d51f8c95a9e1b97216f089081645acd49d299ac3d8abd764da230e0082ad9ee1c542769b916d8b2f39851436a7b2c79b5d9e0b4289ba3b8bd9695101f2d95561efaa1f0690fde4c3c01e49413b107838f4370d5c93fb15be4e54691e74c7f157ed47440bade1ad24b8119277799bd6b459cc717786b423702dd88d8d3056860a387a4022775e25e8ffb9f16b4a08c1b5e435e05c729b16f6e2da580ec20f6d69dbb6f65d272d419c299388e8a5dbf02f00cb41335486b4cec3a1235b6f17d5471480df2d6bccf5fcd51464c31e78f0719fdedc7de2a28f652f4904b1f09acb2c8b80f638df2c5e0c0b59311afffc878fa0a38216ca86c5c8bcb10081c0de3f87d0cbf7da7671361d79762216a482fc415890364621b1dfc15a6395bdc59d60596faad2ace680d7bcadce964a4a78e9e82ea78c91319ade1b48018d03995a19acfff6f4e77862021cea0d39f38f887e65e8c6d1cdf4c9688d2cb18de5b71206e3fc942667a3d510de163c66db0e49bd51cf4f371f75037302fa2d0bc09c5f1eb70d3a47eab4b9099922b47d22a763aae432bba63aea871ae92819f3902c70a689a57a6f70525a4929baf126afaaabece008dde6a8332f9d1da71152da78340b024d38f8eb14e0c97b8bff0b2dc89442163177a98bbd3f90e46027c73d5ffdfbeebde5f0d984cdee0d5a863c22c85e1719df70c585eee796131faaf9d272db060e8e4705a59b0536ad8201199a5fd7db10489673d06f448967e512f692d6a0ed9f473de817d254d79ce65daa615742b136b10a77923f8871af9eb886ae3b0b5d8a6b5de79885c01324f77da770ec0232600b1158362a76a90c8185dfaa7a2c18e312b31b9703ba4276fa63bcbf0c0fad95440b732e058ca2fc6d85648011b73e96cfe0c08e80b71acc1f84b9accee3817a5c3b2c55f63a4013f1cccb7f8e7c1e4657c8c5c2aa04b28d8258f1c10b6ca79c3f2d914224924a42898301773159ec7961220883196867960acd184f7e953013e7bb19caf696924c6c882ff2449ffaafab502797d5b6243d9dfd7edf3745820511917b572a27b5a5ac1ad439a61dd3f263760f379687902594cc8ec8cda90354ff77080e78fddad835b849fdb2a9df96b9566bb0e4f1e19140f93f11337c2fd9aafe5d9847720f306fcb4275f276dfd55b7b95d0bd684c93d2a545654e0989d9da772762e2ad46981cf75d731e01cbadacfebc88ae3db5c1fe48464a85b25e32741b641935d177065579d88fbcacbd11dbb9bf17f3d49a89f4092b2a9b8fae23df011ee8c5a576b76cb488a0c9e85460a5e77b26a659e073e222d26d924f174cdf158e687def8ca443386ddf238bd22a3dd3c4880d00dcaecc7dd441cacaff878250b1d0ab1aae675121365c28c8c7cd6f62f26c7b0ac0057c3bad81a522fa1430163881ad4e4d01a80a4e4427643c04e45620ec769882f19caf8d4db5abc0e0e4d2a5f42d2ac2a4e4082c0bb4be16439d7bebcb53059730142666479a9fcbfca23747a8f8657c13a7ff8d13dc0fd9ad146ccdf02dc10b9257e50f807ffad87622c64285fa9f23683476386e0c0fd39ab069fdac26afb7b8063d22e696670ed148a2c6826fdbab06e93e3c5cbf4b40a9cc61954bd0f656ebbd070aa5542ed0b3a3c3398a4f5738b6f46a2b1525ebbbfc75289d98786c143225ad510f2e79d6d63a0cd125ed58d4abc17972e30d1ffbdc9a5ed3d2c51ee4741dff8cc0c7602fe6e83116d036b20423063c74b6d08209a3c90cb49f33ea12dde714749d129cb400e770a0fc7c8a1e0173f2591b33bf24062751efe4b54a6cdb2e237a699cc2d1e33cb7112ee73437f621c64e7c1b76f9fd57224a9b1d5c653ceca46a4dd2b7eeb089b52574a8fe573662b4d5eeed879ffa520aaf6fcbdb702f6efadc772298b951265763080c418bed11228c795c84af8c2c9a7dcb3d427620a8b5667f70119429292f55161419c0502c2eaab82d2860ef0d885524f9154dbe7b78a2878296de6baa636a179ec2570caa664a2da923b051d95f97971488408e19316ac6f5d747fe52cfa7144901150a04a3519fc607c642814f1fa2dfab147b9e82ed91fed483599d9174904aaf90b42edb4f4f39b163dd330bb5fa3a6622313d85e67bb3b4e9eed7f20c40c0a60d6cd3b0e5cb416e37ec41821ba9e7d8081d1d323be69c206b363f9daf9e1127e43149a23a1dea77a7a738d72639cc28a48abf12a216e88519ce3351133a7c074d3fc332c1c5a5f00f7fb1f37be3651b44de060ed7fc09efd34c1acaf05ff098702d45942dd90caf65bb6c983d08c6d6d9f0ca7e2e375449792a5ca6dd8320d268014c1ed244fd13ea0a09338492defe5e48bbc7cc4b711950430f326cf00488cf1523b9590654621c0aad5bed73865357ebbd6ec26da3ea0e48350e6f156111906f1e4a537b9780c92490f8cd0d2429c6a980d5c2015c723f111e4de6839e7dc37af6316bf8ea273375ff34c4d2e7a856d8be7a7cacd5fd05a3d503ab7dcf41c6aab918e30408b15f9b535dc9b7e769a413248006aa3e8da8790b2e1a9514c051aabf5deb30413aadbee85d713d56fc36295ea783582285657f48d637f173e1f78d673d2db59ec2516f8d668d7a352bba9d733df2532ec4c55d77060411ab253c97c56ab9106b5af2fe2d12fcca74edfdd5ad01fe0c898ec1e2482ef510840fe5ce16008e9149694f0973f99b50a60f64985cd2ffcacd9992d509ff7dc823b2451cbdb1bff1da2e5c21b2820f910bff231cdf2080cc987cf493920122724bc0c342e781050acaab9a9c7edd945898a96a0f89db6da6b4f4e9659ee96231398bb4d0b2d785f52841a65e97a296182e6e4301c98204076ee2f0f991ec84e52231c5481e68cf09d2dcd36e3bcfb62b22334e7d5dfb02105d93117e5af8483cb876d787232404ae1d7a2741b3930d5818e87fdae5c0321181706d4159ef4126ce5fd695a49939d570d3746693cd5baba600a2646c98472153ebe8343d87d04248e66ade179908c8cd6cdcdcad4a0524b05bd579a4b7fa811ba1c63a1938d790e8b4d77b6b0daf6e247f68971e03d6556927b644107f38deaafa53a55950700e56950f9d7ea371aeaaf44262d0cfbc8f4cf50419439f87822f9140c4ce49e7b0636e11ad83fcffad60036d6fcc1ba9f64044f9db0682a090a0528afe2e814a416812c9e4ff8ae656188d04a579ae4a6af1bbe59caf6adc22cb32b6c5014327b2861458ac7b4c2d3e4b8fb71de18ae9ecc86011cea99690a4ac9ebfa2f9c9aceb4715b68659907fc25b34e0a9a3a7f96ae172177dbd519e39c5e52140b2f93ef4043ee20190da245414f3f895c143d5d2fdb22a36bf8119e94951f580b93625f983e7023c8b330047d9fe56da90970d476f0cc2899ef1603d5ee32683ed7428ec920e57dd8116674d62f0485d8b0f4e6637b41fc63e2ea8c0d0c25f8e3e10ef124c91d7689945ce3982dc5315f9abbc3629c5be3bc7b0f6a9fd48abe2e4ef3edeb3c6790f001d0b269d5ce974f82e069a2e70bcdbb78265bcadea16b48ff50d6b4c7918399e949e14519576cec1fa8c4138430e654886df8ebd32a7709c984be3d69ad8020509c57e4ab47d6aeea3f109ef328357f47f483f4cabcc08819eda53ce217ac5035764ed5b744fe0e02cd36f75b4cb75968b03e217a4fa69d76c1fe3487accf0ff700d9ae2156647dc91c66217edfc4975f4e425986f0867fc47fbf84b2ee1c5fbaac9754ba8591f3fdfb139aef56f2d54adf435ca03d81918ccd022be969240be06ebef6413eb5ef8f98fc71fbd084164fcc2a5fa98aecb8ddeb9245d74be4c77c971e0d34253fef59dec75403bdd521e4227e6103f50686089ad745b78a5fd2cf559fbd81d24696bfe5f18bfb12ba64d1a594d8e67827e6629b8267bd628e9d424aca2e616b0613789b0d1db26c261b1a4befc0a6bbc6a30ee20d82f0a03d33502748908d772fc9c5b414cbaf922db8eccb9b1a683e65ac0de8e49e968b0b835bb94e58927c17087c684eae7dd167e05280f0d027c5f4c8ee16735f8c540925f12caebb13dc9dc42ff05774df4bd8865d0b15a437d639bb2f6918cd5f4be842aa79800759691e81efbb21beefd8f530ca4a27518f12085ed427cfbfa392a2c65ee41aa6d55a84db39d73ab9492770ab27c4cb561ae481ea31e6beddeef360980cdf882021a1e1fba7c683f112537ab44ec0161d2854274618e08b9dd7e85a3dde5279bd4ab66df8aec423b6bfdff25f635d98be0e2320fe10deb97632f3dbedbf5865d3a70da9c2273485f3aa842eddabcbc613dacd8ed6d7507b2e32dfd2d0cc891045a8726cbb69ab9551bfcc9a561816c474d415d0d88598227029aab9668dbb08920008f049b9e47a3d9f94fdd224933a061d3a42d64ca685c5081b71501679d98ba94da2968201e4e9bf3c16b9fce1c65490441f73e8c12fabb886f4687fa72e07e01d4321920b789c381916c16a36315f966e18f2cef489673276f3916969633d69b66362da120876fdb03454dc7b6b64a984386eaad3fbc33b8f0c2b929938c1f5377f66c076f4617eaed44c6e6b5e4f53cca8c8b1211b384d41d26f8249fe7cfcdd8cbb6ad49f1d0e487de82a0a3f39863d82226cc2435c5dc8b2bb167a66aeddd00ddb379ef436eb3c00aa9a15f084a98cbefa99ed9d815b1c64dc23c51941092da6639ded746b2577f5d2f8263383f7268944afd4969bda3037a751cd50c595b5f629bc0d4404ad6cd9df073dece1ce76af9aeb6a3f07bc2ae59643f3002797634c0343f3d9e906bfaec8091acef80ccaadfabb48cb89ecf854134ae76604948751900434535c98bfe41b61a3cfb6564cba09dfc20a2bb0f4cbfde4860615a396e4660db9bb962d6ce91a4cacf17300cd6f5c65377b1cbf07cda00a6b5b69aeadbd86071e810511d7ed03458460093b1a7b42f176b780506c3b1b59b155e519e765dc76bbf378a1d2c2f157392de24b03d8a05899ca518eb92dd73ee9d60bdf04f26cbc590164a994c4f93543f1537d2bd5d026d666460c1bedb8b306a45ce6d215bd54c1388685bf21f4b454e60f5c32b9d06ee9cd84142ad232faf279dfecb5f03fb728271ea520b47f33c5f5a41fa4b241f84925b3692b6c0cf0788fcedbf12651d72d1d74183b85c2cf67c7ef6253898b052cc8c8570ccb12efbda6c7f0c1eef9f4d29171349ad28b185611fba96dc855617a8c10087719227c5367cfb0ba9293f22d4153ba5dca6343e1aa6c190771ba059e8f184ee34f8a4e6927c3595b20b73c216fb4046142063b92839d353e2a0884edf47cb3d9c141fd32e7dd8a76c9d0844019e59c078bda4c4c85a779bfeadda79bcadaf49c70c9ecee075f6cfa9e06e1620770fd908a5d778d3f76659ea20b1a349c1f77e19fc8c9f7cdab720c025a1c4fb69c4a120730d94fbf09cfa50fb4220d337e947fde7c7ad2df53d8263ae414c887d64aa83fdc0acc2e8f3f61993c20ea8dc2aa07b3bd8bd2ee03d29cbefb8fe4c4d8c2a1354a0a6510ee15afa62d59c7122c27b2251624b5fff5e2d02bddfad877044c9b6c4d807e446f7f9cb7ddf84c568fd4ea38f5c113cd6514e3e88bffee059c996053170e0fb840fafd1f27b6fa23ba82ddca097dafaa1a1ff01825969db66d143b62940a4992613ff486eb01664d8d0af833310779f91b89c2568b36940abaca20a6adb6735de60496a47a97f859f357e2aeece936397ce0cf4dd26cf9e43ec3e171f4e90e18e2b285a0eef1f2b89b7d5e0e8e487b57d8a48ef58b33d658ce778abb31e6c52b9c97767330677052a4eb75d5ad1c0551af57af2d2392b6d807ea450bd8b3aaefa0ad36d689c98b0b73a96b53647045e4a52163ba08ff84ae76c139cbe5a7bf2387c2302226bc018eb2b2b2ae6d06ddbeee9618bfc5607f220021a50115f37929d283628e5e7e48ef4b4372b74bce6b308b6f32fe7c105959f437c0833cc6dbbcfc66f9c9c314a1fe0bce5de622ebe787c086046439f858ac26fe84a771319c3662c2663c83db7a40818a1bb24b3894a9c6978e8ecabc0b097e09ed7563dec7184aa3ebf8ae79b1084001e4fc8dfe937b94933e437571ae4fb2a883ece54e6c365a044f9438fbffdad1c931ab17c45e09c8ba8050919b9d2384410c0e6b046abcd3072066ce0e887b4a9f4cc6b5cd4d65846c6ef51f5653581f6e8c6712f9a2ae3b7ef7fed5044ec7928614b04682715d2da2c6f2f5d9803a45c4fe1110b36a5daa49e72ddc26f9a4c3c2efc9f073990621b6169fd45780ffe7d3ec08236fbb2c8a87915e70ecf557c1bbcfeaacb82efbd18986b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
