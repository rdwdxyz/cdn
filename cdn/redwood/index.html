<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c7cba008954c4c89c4aada94215238e920478077fe68fcbd388def72e1d6ef2849a5c392d40fcec3b6502268769138d4bb90d1c9408b7a223260ab69cbcef5601ba8cc6a6e4b5024a59aa471d0fdaa049173b0dea2249a42de711734ac20c00b9754b2acd6b39408ffec27dbb1ab70c309f03ae7897da9fddf6b253e4a08ee9994f64e5e953bd7109322a2908427e9c4e301286bc8aa04e9cad8d2e0684d3a93be7044613e5feeaf6febde15761c17540880f17168c35ce8e9ee772c3cdf858864a716fac49178a210efd65aed3de77c00924e60f85a2c95c0bcfecb6cf96c6e58572fe41ae6266dbd8e1bc9fadbbe855b52669010102bb45b3609764218d4b26f9af430f6e63e1e5df21a7aece7cbe05dc28fedd7340b39fc448f9f23633ea9933426977b43b32a7265f2952056b054c5d84c3cd262241cbca2ae4db4ee7a50d18ad8bc9bd2a5b3028e44d866a18c8696b7f414ea2f2eea0e8b26a2c224f9c92366b0b6c1d5f45cef89254765b1653f64742fca044cb181cf7e68e476538bcf608b0e83cf143533145c4b9718acf2c72e8288eb38459ddd788fa7330ba2cc71d4d6a1f5245800d3db5ec2afa6a7df23898362d00adf27283bc1c25961caa7a647ed5ca321906fdb6d903c114ff44ef9effa237c16edeece2979f14d96e8ffed829cc83218842349188e5014574c319e5d3be67ce9a22165f2bb7781ab3e1d3a5d3786010a839b369985daf6ad2e44cd2ecf62c989a63e1dd4a799f2ce774a83f28c24c3262e7130744c09658803ae42d43e6dbf1286f52c2f87505bc423da3dfb44c01c5f15ca68e05ecaa584f40ac8719590637d35e18fe5eab0533fd29a48939fba058a3a2120a02f5db96d3786a46af35680a43ff6e5cc06fcb27f6051f7877fbf1dc360913a1dbd95b55f4d9bb6d1345357f11c42c0821374a555780fbd8dddb4d067007e5db9541d77ad09258caffa99bccbd50078616e691f94f221a0a31aa6856177ed3a9d8e9158e6d416ddd556238788f9dcfdd4f47a6de4d32dd762e8a2c09b2319f888e35d8c63ec344287fd74fa1ea6491058fc0c25a51b97c5fc27edd5d944858318230154964dca89a777417e701c2fa2db65e5b3e5794b8f0985febb23f1188eb1195837d42e081dd78da153cbc76189344e84598f456b5d4dc5d211ebde411c5408bc1674e320faabee360b7f21f5aecf5db42dc95f999b1cfb954a95d5e5e620ea0a8c18241942b8f058e4e5cca0d34793ad1b30231066d2714c371199f5a398aae61d8dc444ea4ce63cf432dcc2733009b380ce90438ec9f413fe5b352bcd571e3af2eab5e9126ca7ec5f897680cc90c00e80d94f9355e71708db11141dea57b8cdb8ae60a7c42263fc1a3969d2a01f7fae0719748ffea19214eeae6aa06b092d8455b98c6e422a4319527df6c213574aa634c3374ab9193aa381a48b2cb0853ad9d52da2633f18ec5bcb17077092643ca493d94dc7b8800313c5ade633afbb75c631a00c44884636a2116feeae25bf2d35370478600e1c6a3c6cc4bdc45f42143ce1a5c07bc33d5cffad16fb2c02c12187fdc4a81e2ffca5fc0fa13bc73fef2e5247017113d2f03d7e1ee102bcb659135cb5d93ebd0c53b372c7a488e2a66e8b1dd222b56f5d32d933a5c1d825acfef49aec8b4b87ffb07737fd0ef112925b38b680c7d68b22542163127c143d6a339ab642f9cb454cba517bfb3e4d10a60d1632b77f3c811844f40589b8adc1c5a2c59026d6a9a7e4c9375ebb9a36a806de5c8a48bf6c05049b83cfc11d3f2a1ea11a7dd1c1b6c19f870aee371b765ad777354edb08eaf2c073e32b1cd7a25be681ff8e3214b0941c0bc1ccf5126eb859034833c7ee21726493edf3ecbcbef99597a61549956f5bd0ab8c1bb6ec45e98476cd0ce39c9f27e66632eeffcbe56ee46f307ce22cca5e7d73888660b1bfa245bd3ad31a4d8798903ef11acd5853621759ab14c8c24a4af6cf10f672c6ce04e7f96668b9dc855140e0be903b53f4edd10c0ae349587fe659b05bb0d513c8be6ea98e27fdd499a34b0c08b5762b20a5358c787fdd396b5f9928966af671032c7042f842c251ae32848eba1ea3425c557d74574c37cb183c802f75be33aea2aedf6858b2e10165f924f0a23d007a9c72bc279c1579bb907e091dd15fad649caf29ba23d4a97121866b41b1cea41efac4f2554854a6c95a98d88c0a5795fc190d8bfa9f5e9a3a4dd37345c7ad641dcf6a8fbea6ef131bcd0871768a47e1022e7eb90f8b0337de32042fba68d9d9c98b409b9156bec26416a537f5f783f8f19ddee17ce047272716a7690178e631e882021be5c31f6804055f839db989842c6b319a8f4d366cf92d8d83ae6be5c91aeeca5ce4d3f55eddf66e36c3a69694d3b841f665d57c2d74834a880378127a644f3a410b0d605b05d7001c12c56b7a1e5151f7846bf0c7c6b66e08061163d6b0e97aa68ea32cb87630daeb8f390c306084d0285fb94d4bae265e27c5a14393d7e87ee89e6463725322f3df3550f029159a041ccd255168cd78904305b253c7a136ffbc11654a91b51601c71718c93eafd03b9c74f8696b26d614dff9d44cf63b1ecc1c9e50cd597a2d998cd7e6d43f92250246521fba2173885d4ab3b1f332cd42bca061cabaf76e1bb04cbf34c525f356b1b9a798329e735dbe5ecc5dbd5dabcf45f8b83f236129d2c5ef0618ba6fa7ee0daae5eca47a2284bde492b26e7b59306bae028fcb07e9685fc4336c9c0f333dab730c355521d6e2253f2843ee2ad2a30cd09a427f9987a482959cb3d4a3b6fa340684df20fc839b6a3cc8006b79e598633d73ff8542c4051f7b43a04b4969d997e3208be2f77c2fb556aacb8f5a25879f34ea73818b00d552467b042a95191bcf0b613ce65666725679085442154fd23ba3cbfb706f7750b502f7424a27a345dddd93923d7602425815da4a240c3f653b6836db5d50018785c71564fbf73c01503058b9e480b12e014aeb487d71eca8a937b108004437a2658910feaa58b189b9a44b142ee3230965fb1553633b71ae1f49f1d2624020dfac8c0a516c8a0d6c5235f3c6ba543e92c9c5809040d8c86eff4419a3ca7dcc7494a0b2a8de3cd90ee705dee7d78ac22480aa5c10f0460d885d41187139b8dfca9432b3468ae4291715344b2a21bf0b223ac15d17ffa722f63e3447ddf76c77cc4a24beb37f0356d93a364e7228ea77d811adaddd48ad19866059b5429fc171dbf58dfeb32ba2436e7e8ca15f374a332d3d35d98cf0601aed599223b41a2420bf51afae7a70b9c8df030dfc85d1d69e596f4abc0f1d1a8b4652a6d653890231a484d67bd7766337cd2b980ee234886bcb8a0e7cb88ab44b10754f3330e6fa203e69fd3bbc14ac3b2e48ccea9f3f6c7272908764326ccd5647063dc6c8487acca184d6b4f891577e6f00c61716e84ee8df754aa9c0ee6e243db6b79626b5bba3f33b9934c150bc422423d537123ae2093fe2c21b59db15d251e2184180e21b9a729625e5f9171692892b5f3e6cd06232a0216b221dcf104f75399ecf8fc583bb422a62a0282beeb7dfae7b6026915ebfc10d68cbcdba581b2340ed5b59b5cf4ffa6c48dc0abcd3acecbfcbfbe9ab383ce80bc42d304a79394b374304bf53cbaf1b61b4aa4a7a1130e61c159bece73ba5885f20bfbc66e303a57410b994dcd2efd03ca28d52db4fea1e5c4ea1f46818a87730811cc4ba4bdd8fc10b373c81f7352c099343d0158a3601c1cb8f97f6f975c7af6f58779834e386b52a38c29fb0975feb3354f87a960945c762f7896013db998ece0d338070aba052dfb86ce56dc9ae6741c36709717b095c030e4fd88addfbf4c36e0dbe7461f8c07aa4e78c9648bb786e900120685a7552cd30926b7bbca975cb49693ce76ef877560162ecd7b0d9af5645ccb8943b1cb345ae8dcde3d10676518350c1106d8f04df929c7cee82c620d33b0a4ec9925beebdf9602ca8d9d810478d41b0cfd091cee40d32659c4f894c585ae9bd51ea2dedb9e9779d48d56d2390bd7c2987f44e939d1ce3086f7773da4815bf8fc1d33d080fc619e957d08754435b5020cb42e09c8327745f5ca4a54526eb8a034005ab0882778fa60816c5fda2118c0f60a0b17aad9fac070b4ff4bde507b2a1b448af6ca3d85891ae9e5e1a8086c1a4c4027362b65807ad70867e878766c6ca7d0b577887bd771968fcf9c975321cdd8d0b225a1c592bba547c8ab2f9c23ff6fa5b279c5b164521ded32992ac3e96d367300eee1212806a2d9aa5caf6ba8b67c754c3be06348d2ff6b51af004b06ad97d7571f8daca02068e73bfa00f561011c26f18093be138e0b50e18ddb869a8d3aa81ca04693b2f748a54ab4281a50060f7a0b2922c7c55f2c8a897ac157854340302e6360df3b8fe639d5fbf7102095aa934a89ea0263501b5f46efb65e0a3b9a4b6157ef11bf6644a66536fa7cf72159d3dc6a93ca6586c4f8c36fbc38268df313956922d94ba1d8f3f199f408a9daa47cced500db194e771dab23d1132e5f812b317415e5798c625e22297d49147f69c4ac8d326b3ba2e1f8a90dff7f315fd3a9357e2faea09574526aeff2ba7757269bed938c9fea5560706b7d2193974ef8b39c05b68b97231e2393b6b77383bdc90a4155b67a1fc18b43025271bd64036f930d67a58cc5cbf14082e8bf15839f2d6bbc9e137d807b9fa6b2dd0e7a5f4163eec3b8186a821e8a39c84e90136b699fd9a5cd52f84e55148528f886dfb7269fe0fa2b020721b4713c891acec1948fecb897bd182b622debbbefb7d90a05869baa2aae3e2deb97664e88767315dc993ddf2f1ccb5f775c26f9aa6836d392de671d48c19c408c49afcee44493160132725a16e081f4f0ae5e9cd1600cede34dd77e8499e06370aae3fa234c3761be814a69e8c8894d2d2e46eaf3a720fc383a69a2482700f2a9537b419607c7c1fa161e95adabada32b861492cb914e08cc7b49f40103cb399daabc9be4e5b6d8c8f6a21ce01c89b181978f8f036b83615b4922557773004f745e7bc6be1dd0c0d458ef8f48bd58ae7906705a7fa7a00d69bae5434f2369075fb0fb01d7f5ef46d8de0955ae8f3d157a1b1c546d80ebb5bfbd544d0ba802d7224250f3d71e7ebe06deeccb34dce7cb55a4c0f9cb3052ceca730c920bdf3d2517746fbbcad67b45458ad50eb23aa86e9d0a3be8e1ec675f6cb3021e00e57b7b0c044a1f55e37c88cdaeade6f707341f0beb005a57260857ecdeaaf0776731caf9c444d9247287537683efe571c6ae62b9c1d1da916c7a78c34b28608c0cbf85eb794553271ebea2f1e3733da2858e291d853025892d735aa3b440c2368d5f8c0ecc818a8f712da850eb54224f73b10d0b64db26887a49c8cebb324f470791738cee2f8143852a2ccfdb4d0e03a5dd82f4dac15bc0e31d583e9472bf5db521285a20bdd366ceef4051f0c4a5fbd3c170a02c95a2d34eafd2cc3073542f1a6e61dfbbb3e83c9f5f9dd3e97fe53771b253e3988cd025bb5581673719df8cf96f1d2fa3845428087762eb5ab35fbadd6aeec57f894a8e5d38f485666634acc90895d4d72034c30075e17470c6a2a04db17f6c9c29c67dc43d0f9ae171e67880d5cb524d8327c3dff4cb8b8815cfe4eb90617179504ca76cde1a951abda73a248016a93d2611713006d868a7cf012b8f4a384dab5dde8da7a64824b73fa5017e651864cd64cef19f439925b745a5a0a19bad303815a864271eb82fc51d7b1a3e6da539759ffc1c5d85d08b983035c1375d777792ed4e4f73369beea9b3608f2c6f41ced2f60e66ca6e8606848f28bd92ea61d3983fb63f612211102af83fa473210873eeb356b28323b04290e8f6d51e639fe614c66438dc31fa8adf3592b5a5cfa2c3198b9063e0522dc3ebc9869b7e530bd8d53dc3cd13ea1941c99c97c751ecf6dd679bd834315e752c1d79e1be71911a064721c9a13144950e3f349576deb97549e9f0ab81753875adcec290792f100ad5f9bf75b1dcde4d1cf195b38f06ef83820685172b190b664e18b1035dcd42dba969fedf113fe3962f29e393a3759ae86a2e848d7f9dcec29f706b5fa84b69e45791a942e8f34ce9cfc02302b2b37a90dcd7d6c93c19f9cfcec7b22dc7253bee3b3a30d9fd51fb980d42471a0adda4b1ac4c4136386ed1835e1367e906f691f885df9df98db158125f127eef59f0d53cc8891424cac7fec9538a209f12f9f626068c132ba5a1f42052aa9eccf29167f91f1311b3e76921e26a30f481bf30ef6cfc49734750f13166891523235737b6e8e6e86fd6fda9098a95660180dae8e9c9c579c62c49678543217077032f673ae697b8ca7794803ba171d13c4e8e1749a4ebceb249c33deab30604fc3be4f1a2d5e68759b4acd9a3ee0152904a16e728ec9bdafe46f708a397d28b33598c4c899765743edcf3574868298357e3525cb5ed11e67cb25f91e1fdb2c75cf8601eff678cde8f93473d8957dd675adb7aa0cb2507516c26a3803d9c3acf50f95e4e28dc194f7a1139bae106c9854934db17c7008b5805cf53ecdf87365973a2266e840606023f8277bb18d9bd8bbd4667e337bc936d7034826b459b8261728c7fc07887e4c7cc74da3bd35f06c05104712bc5bc80f96982626e58ef61b1e5419aa26371e0bfb7a2f066b9b811678e5a5a4ed5c355384c1051b9d68449ced2ef0b99ae8d2f67ce6501e24ceaa4a8bf2d68baba4a031ca9cbacd6254492c54685694f531752a8dc2e49f68dc8773f7d2d68901e71a5bcfce0fc9174c127c0a587640614fd039a4061597a9d8c7eb95823d84c44e66df44eee99fbbc88b89bf89b910fa738c8061cd060a8d0dddd651dcb9ca316f86ea4570335dd2ce90abc6f665148055d240da87b18ec91de96f35e600920ec4d135fedbaeae1d8c5f4bfe4791fed0c1e831e8752e24c0f6b819a03c9a73153e233f8c55e807546b65e6d46c3d5886928176386300c5258e4a6fd6d85ff9e83b39965b325143fcffa813160fd589807a26e35b6c988b159003487567e05b3f8fff60352a8b7c6763c6c14c289e8a242aa290b5571e68b62e1cfdd9c7abb8d515c618284f51997f940fa140fc65e176d6089cbd56438bc96324b7910d03e1129578e745582764bbc1c787a0026c063e04f2afb3d563061efa0063494fdfefc0bb4d60f8864018a1eb9bc31b5c9dc8cbdf20c7c62e74a8bb03e7ee1f3f75615530da3022bb2811c7b7d01765a95b4a82ae58253b7aafab759b16d5ebd3b01ad648d724010d95b6411aac769e2b2618c82a6a9368ec4f3e7ed7f6ecafca7a03c3481fab8c15f4d1c355d09fa8becac41e51b9fcf667fdd36548ab963352ad57e65c9ff45c5c0e31b6fcea08c565650301798dfc6dc725170210d7c8374750cb788dd43002eb6c27007902ca3a52bb8b85c060ebe6ff37a75a5a1ff9a47d338ffb521e75c9e93cf3ea059bb5e04f6e6afd21441eca5fde2694d107bc92bd2a925cd668ac5062ef34e4448fc5cc87d0f7b6f7cb7ff0403400114479e085f8fd4773d9574e5b159ec5a89fc139d70bf7bdf88fc2571c6f974bd15ec33c0e9bc0f37b0bf343ae7698adc63717ded4bc2e5878d7a5cfb4d9d5c2adf00374a8ba08fccb96556331cbf96fd6e9e8b84fdc7f376c7807a44f99b7797bcd4c0b0b7a93a2aeee508c0d37d807c5fa289d045db18647185bc081ebd38d0dce0abe9211447536c748e94f2b46d7458de6412b07a7fe88dda3e111b3156e0dc95103b36850789725c9992f1117f9ce6f9f59a67a3e4b4ebc85ae9c7d3c1f536833d1eace05ab99c76acc05c9ea6f55efc5a20b1b4791657d7beb60699b48784ceee97c9dee0c8b7b8c18c58855c3f0b0b90e36e19e5bdc1fe2666cbdf7971c142f64e7f1654df4d6cfd4751bdf459dc3bfdb465e8207e39d48552e61ec0f991b8ce6d856a5b09632e9ae955ecd7711d0f4bbf82f91347882eab6407365994f9f895421a01f56292c9cc439aee715c0715397fd2463b5bc3a1b2fb144ee1f5b9df44e07d02f9a1c4a8f768509630c1755fd608020cd98e111156621178261c667b9061a5eb18aa87f2da2c8e933e509e2afbc511ab56dde986602fefe9f0c146faf49d8befaed3cbb1bf90c6cfdfc0822fccf3c2add98a4145989af2852ee355b43db8b2df40d64ae063a87d1f08a42d2ba5d623c0fca42e9dc6b2ff76ce8a0f80caa88a9e0ede2e346753f8da3868c085e6d837e176ce459fcef69ac5183062895f88012d057d2ad90b0a093ed03967ce5f505463e3b41db493a97e05e42913a89f760ff7808ac2a31afa3cc8a1a658af9453653f930c697b080a447eacd790be6df50415c414273da00631ad12ee1125e415f673760e23b854004f73a65078a70afe516005d1f5055e0f98aabc39f3370fff85605b649b5cd8146b86ba1341381f094c75463c4acf92a08ccfdc9fce51aa5d9f12ff2022cc2ef3ae675d83a4aaad7e174d00cb753ccdf0e07da1efb909ef5b4c7d319e66342c2e58a816f507690bfbb9c6b8b9df9b4d993a12e1c943652d104d8f7ac04e6071b793a396a7c7bcf8e62584271062acf249decd359ba1902717985a3a986587aaf9bc88a5c80f15be82664d623a831c0891b8b8455886740b8809320b6924298b54b39c99ad08bdcdbef4fdfdbb8215da45cd71c5ca2a9f570474b800674295b7838c664803f18a2f74c9a90e61d1f58cb89eab50a5ec5251e21547767a710dc52fd0d5bad7a53e003f5adad59bf9fb48c2be92ef2a4d07d20b61df0d001367bdc34b8ba536780cddf7c75d73ed7fec065d7371be24f455a8d1914bc46eb800b854659c3ea6d044e8bccfd886fbf50558e7ebd17677de7d57652ff4b1d2498fe5ca8a1eb81a663daf8ca7b1770fe2556a16fb303799626454d358c058ac48884f72684dd68ab0dfd13866f10c9e095aff4a10e3fb6ae7a603737985337a40ba425ef10d7ab325bfae410ccfa83be6175fc1d86eee8f5158c69310bf7008082931390064b0443ff3884500cf977b1af88eccb522eaff5caf26266e7db48608fdfe827fabe46a04d41ba06034642c0b5079673497873797a6bd0c0203fb59ea4b1d15ad071ca44e661cd486a85a66c3714a870973423123b50302b568f44f2e663a977619c22a50d9579fc7402b5585c4ce50aa12be8d7614f2ce40a4095876ce8ff3912e518cdd6367cd6dd292d5f2324c759a6adcca1cbbd6c547073f25faea2d6eabfb7719c816d10abcc0ecd0e34732e7660d944e032a2373a631b869eea004ef5c219c2d067179c8a0a24c7d38af6ad5b1709b448fd0d3d768f37d08e9ad4e54085b41ce6e2652edf2a8598271ade770868572db0ee9b13e75a9f01410297be09cb56ac1d6c4c8262c6207a24a09fb12d477109e55737acad02d9f4dd2e1cc7a1ed557a68a59e9bf1a612d7703da50ab552907fc62c6a3c8e35f162a435db39f3728bb2ba5216508f8a5e365cfb0ef0496fef56b9277e66dec16dac4c543a4e7ab1146a8ac2a5618604a6d219498150d1a180930df4496f0b0f5475094805d6961baabc6a7e97bdb2862e9df0ba72ceedb69179a18a026929164b246d2df94748edf052a88d033c82259a1b6df856bef8dc9ab8aa118b12239807c912bbed59aff30539dd1d2d24800394d10382168e69b08a16921bdb4073495626cbbcfc7fa57506d790030bfafe70229fdbfc82f2e1a5e8120b68f1e31ea046eab82ab79b647195cf9b167a3e4ea4e5c6fc2b1701cd230a125a0287722f66be1e229ef4cbfa9074072008bc13e8fc7cf8ee522b4f2b3257e74ca2020c37ba049fedf22135013d621d193056bf5f43ad713d8027a266d7ad4c375f14b0d371c17d954b2c640270a13738a611069292f216733de51cbdb790e5f22a093cb5eb48468f13c3ae545a9d02887e164a96857e130a2f20d0e67e478776b0d0b2dcb424d95c6cdad39d48ae794b6d9d660e45505df460e15169b3101ca9857ae454eff686665c1f2f85823dc952a741560af1788be7d2b90a1b5ddffb0a98ab1be4e01881cc507960fb78cd017bf83c77cb8ba853273e6433139e2f4d33db2563e1361f686c514094c6276c04d6a6496cde7cceb4a47b7efc66bf109f3f4b5203d9b33f75121e1c0b05d13244891e040192e607dd8b78cc425212cecf7f3b96bbe530b6d2dc3f8853bc37e69223ff7c6a668750b41f7ad7d35582baa3c610bc8ba5b71030910c435c12c4b2195c2a0cc58fc858ab8730944401eb40534569cd084cc1eeb8dcc64296d20e350027449a10b4e306566ede04a00979db5ad2f1ad0acc6a04002610918fc92cac375823eacd611991826caf65d3275fdf8f7c8df0ac9e0edf44b0cfe1ccfaa71c41a8db31df2827b4ee16e26d1b65343dd862fbc0ce107c80c34da5dace56b033ee24d3a0dabf05d90ce81afecc1ca5146cc48bb8b328629232166daddf7321852f72f9950d099dc18a904fdf2fc4bcd573f1fd5d3fe057caa29990ba10fa522365d7e95e3d0000c43087c2877e0def1772a68d62020863902f8914eccc0607f683b92cf6713ebcdf0d695978b3a72168cc318c8e3cb891e167139235fa38b73c970c2a1d535e6e3a9292e217e37d0c6eb5657da03209a96aab88e7d5e0573029d3259403c61d54484b4621906312b8f1383a2a3e218466b973ebb8e3a52064720f8fd4ea2608b88d06a6fc4d1ebf7ea1eec9dfc58f0936f9fa4018182d4aef7dd5489b5bf835ce1f558c1839a55dbceaae86e0ba966cfecd5776e6d99694da49bcb869056b948e317f06a513ee82df8a05ed7aeab237bbb2628a9788bd59c2bb954ca9a0fa56b3dce3e320b092dcbbe583cf0fa0280459c77477ae24448e5072360a76f8f5fc6dc89eb8daacf6b13fc1378c01b6d29436141e4de6d2c6f1877eb2062c44830f095d99d593fa1a85346e313983c7ee40fb010233e416627bbd660d6e895453a7ffb10f86ca35521ad5e7129cc35da476bbb4e35a6af396914d71393e0ff273ff456af4b2ada512a0e6076b5560d9db1ac80841bc94343ce94149ec335e915cd148dace67871149bc31114d651589798137488287dedd0c06f5f72aa28b6281af645d413c206cebef6e413902e0806103915f770a3a4b7574dc444748db4b4947cc05091988065d5293f69be5583b8c1969448e6f51e82c7cec0f3a1903d70e780ec6eddc776e8223d0c3e6e4617540ef661bf763d1b965bbbc4fa46a48dfc89ca20eabeb0ea364ae60bfd2a47a5a484de225db65817c5a2a092c2ec67bab3fa014c75c0298b1448714d6bb5328ebea0d4e551460499e252984c0fba47d3494428850c206e1b3b0634badf1fec66d36eec4c595db91b11dc79aba389ff74a9280f0533e0b861aa32f658ae34bf7d5fd6fb7a4e1424a1df30a24d78262043e1f03c183bd776a6de00b0d217447a56fdb25d09c03f4cf348ea46e40104d9c2e58b56ba4afc38c6afafc35612e33706e4c675002b04e21d2994715e8665fefb6538d2d50ffaa2c032146d12ea8253d8f16b48f5995cae6294021dbc8965c574e69d509b56342790f5927dd5cbc36db6aaabb330ebe170cf4d40476bfdb5bd215ed7ffdc1cb0cd0fbfeb20ad4581f7456a81e21c9e8d80218e063e59fcb8289e838f4c2610c887241e5af54386ae28c5b89f366df132b8f31460d208933700f9ac854f0643a24900d5319df3550f3decf1d84abaed0a4bb07692106e4882727f8a808c82e73ac27694834144b81c9876d74cda762aa154b40cd8d43304761d4f679bfc16babcea4f5bf948cfcf652a1bab9488c363c4e62d5a26007836fb80e30f14203920ec12a35732f6cbd1f4782bb9863a50b6a47637ae831dddb86ff3211bac47151d49bbbf35f61e729987eb10f49159304eb604be21af80f35c8a60601a7816b9b51ca8ed423cb15906e3e0552aa20f969f940f278d643a6de1426623855bbd891718ac2c0b814da14426bab6bf78d6446572332184b16b77e96a81dbd70352c9295f98db8a3f2c6f672ca2784b12bd353819242b389ba048590da9040e02885e61206af0c6894775942605b5e7f62408adb85ffb4c8257d9dff56cc904e8e692ea3593cb906960f55375bffd0d85b8cd95a6f39651c159ef6af3cc8cd9db2579a1466e9d9c58258def80911b2c5e18e2995c70bd70aeca1b2e24cc2b49d1eaa6f8f8860027f8e527c592e379c82a7cac67ec3c45db0def325d86c7f67bc52f006aee44f88ff09a2dd82c2378d027befa8bd908298aacb72afa3aac73f210cb1916be584a643f1b0ce757d7f9a01bbcc95bd78d47c2d3b661d1ca7d77e7b48dd05ec4b5e7b0c1710c6e27245e80c266da33160ed74d7aa2b4cf400aa6d788387a6f330a6b81bfbdfe4401cad0d85724a7787e862ebda36f54fc1fc9610816b94082b9009c1b4a56b074d10b7d670b76f2257cbbcc632db5e143e12e59f0c2dbaf6132247680be045bd8417e321fc14e9e3e1569791ab100c3a339c90ac695c5d96b29a1b43f0bbd91b50e04eaebcf3212e6e2ed1bfc79e6a4b2e02cfb88d53edde2879838710343f5d33306193260b3a5bf72f73ccdfb5e3c83ec224ee94cb92c4544b27773a2b8ae091b8bf9014c9cefa71f3e03abffae36e187517a5f45612da7705325c6aeffe98321b7b9126c365f96c4b59431729204565bffa0a00c30c11fedca500e669139b749819d3ed914105c003c6c84683522ec4c2332897afaed3a2fec77f8c1fc2d404316fd2219b2abb58cd0cbeace3b2807d7a6b681399271974cd003c146e7b515e3f4bf4083b432a5d72c64b5d0ed24b624d9235d8a30ddf9a92075a3c21f6b47abe45ed08b2d939ac2f7349733a3fa83b829a42047ba6ea539819ff122d0d365c25a1f283e28f8fe0dbf5cf842952f4eb4b87f36ba9c2d140b9387d03be79ee01cf059b05e5987857b631dc39756af9a3da321f84befba9d43370211cb2f5af310e63aec48816a806dd8a05083a691a69d160ecde4459b00d5f960e008a97a8632f1b5a81729d5a9db921d205d6cfe68e22fb476ac993a4888883b3337cefb1f111e1a4191bbaf288d69d09ad95ca0f8cae63db0cd7e17eb9b81054ebe72fead307fa345ede2712f1e5691a18d4a2c9f5f910ae2952bc9dba008872b154964f7f096fa3bcd0fa9fcc7512882b904a46c4920c6692bb2477073b79fd638ca5a249e2e56ec227a142b6bb4bd82774b0cbce34b98a9fec8d45aff600559c6be6ba761dbf8072bee75eca0b91e918519ee6ba1356d098e0f64b7a84c501401a07ada579afad18ec359bc682543fd5edd6f373701d7b09c3dc3c900ec9c9dc0cebfe18a4ea960b5c79838fe4557a158ff986a8760e2cd79d58c5db6c09e0949ee8b61e9be4545af3105b70adda796321f4756d0a211b79caa6f6a7350b48be6b011bbb3e37d41efa5d57af0eedd74c53c5f5ca7857facb606e6a5326d023aa88e24520d0ae1efc82015f5a75381bd9f94b425e926fcab4d4aa1f8c0303a8c33ff328d30571e84bd3e9b92c3cb2d7a77573c2a09658211f3f34d0dd25fbc05fe9d51e824f56f322b0c702477ddb4666f4ad08039908c79b71f2a466e607bac62a8d96b27b3bbfc1bcd0d373589c44abe471c3ce7292079a00953c508f3619ecd8e959c4f2069c1555024c0fe3b78deb39cf26762de7bb774ef7337da483d41431133a065a604fc094e9b6171357bec1396437c267fd5ed75b9b666c49dfb65d3027505ac14e5befb1e7e88fc4ed242933c821195f679d7afc25addf5ab38a2ebf8194e5c23108094a7a3487bab98155d324bbf9d6767623608595a3b166d8f5529feee533398cc1ec83cf158715c17d8a704c96e62c6823cd20e5709e6eaa818b64908ffef771ca2e8e59c813b820719b83bf68fc58974e5c1a35d9d0a18bfa6b41ae3fe2e8bb33ccdb0e84f726d3c8f8335292028efeca9fdd66875b95019ab30592260967ad289b49ba65d8cbce5d9e672d4dfe47489892c6491b377446cf71cf488bdd5a538cf278f5e921af7726489cfdcc87d464874a1f6b58cd66f8ffce3d0e12227a2a90e5cab0c7e72a983737d3db7f8095dc9aec0a330d5eee895b5aec45d4fcc949da358a73e36d437d72708258c05a217e79c81375bfd75da4b93d6108848c5b8ccdf534dfbce3c124561da81a5895cdc12566a78fa75350e51a3d8c67cae70942f8c93c9f51d8b9cd8668a8d780f1c6427c453bf7fc03dbda77c370f23ddfc741296775996897bff5835feb8b4beed4c862473ba30d10f300717e3d3a513aedd2a3263f2dd54c9df7e31ee82253c42ed14bcd31c222889188f7c4620ddfd5509386b4a219466381324c7f3656acd6b9c7520f93a2edca6745b303b37bf6e5d0b0f000f8df798bda4d4b08ac385c8f7f93a66058f89767286f135798f43c2df0c14fbff627bfa70f717b3538d7f7e954903bb46c5bc75f39c5938db3be6c61ad452f89ffc8b2a3df9be81c4a85e31749b657bfb835859b55a28ac48a728f38bd5845bb7a4fab9ce50a4e24d30258ff37a3a94a679900c49db70d39d525049d611acb534f35f77f1cf3cae06b727cde309e7e8fb531f4909fc480bed7e1c316a760c4be8b32cebdbdf57c971e900c58f483b87ae1eedacda7934945f5b5332680588bfda5c4083183f6b1bb532d133b6482226d9631d03e1610f8d1162ba268dfb482e0218c40a071e23e8a9afd9416c39bd182a7e47b38fa46ad31eef5d606e1db25a12a838f979b8ddbb4d394ebb7aaa09a4061e3cf93998be68b123a57bbc7b568bd080555118a21c60c649ccb8e1f160583e356d8de782a31dd24852c2d14b3856df6fef7e0315f67a8317f49c74371d98fdd52d3600d1ca5de16a6c07aaa0844c7bbbd299f622230f6efc764ddf1cf58054304d4fd2d345b1db8cb872b43d461657badf1d3bb95048bc5a01215bf5bd9d72e535e597f4cd6355dfee3533f1b8fb54b997299b0e4049f1ca4eee8ae16bd81547d93a31eeb91eed5572abf5321f0ccd73ea41d1072b897520ba64057539398efe585353c4f43206e21a98f60b34c7eeaaa1ed4b69caf95fd7cdc36e6a4db2284ac0c96b2242e482eea9f2105b6c149499b634c1da7d1259c87894cab8175bf82eca0235becb198b347ba47a6bf9254b28f649a7879845a5ae1539ec40114531f6b0b0943ad1a530657e9ee559a2108ffcf6ffe9b1c72ac54e0eaef4a6e84d31168fb464d8341749195f4ab8cd97463e0333a736dd01f542b54891cee28d17893991ab0a2be0d44eb231769131d2137dab37590cc3bfce92f80ec99cc2c7e9a1995d963aff4f69dff4c2ee8397112cbe49f18a9232c14bc92f65cc2061a1839fb680b0256f81e509f41b826b104cce8edb10e3fa26a8f518186fe923e0aeff9ec9c5599d24ca100b00579cf5ce43867d938fa9796bf5558fd88e0580409d041ab18f959e4c14a179ce7de40b6edf56e600e7a7a5f8b8487a1d866b25cd2f8cc032f4457e339efb58c85c910696c06fc3044b82d4c86a73d3a2ca163c1dbac142391b435e89cfeca0db6349cfc18a981c86dae5b85a68f1affadbed8c24d4329ebb59868a4f06342e33d2acfa17e8aad9de8db251b369d203cedf83445366dfd795c3e6ae0eb93f74c7e03d1c8797ffd21fb6991af7c45d2b45c96512e0cb4523aceb07076fc68ec22359769b8c8bc87cb46e0a8752f45269aa13ed1e3a505e8d8e3c05a4fb1902d4c43dd0e12acf5b6e6a56b3ebd239c5c43a6958d29266dcd704499224bd1390b845bb8d43eb599d212b581031d89d39889246e0f3ad80632a76a2849121cd4492538c3ddb713e740e54d8876555df0b3c531fc24ec51720c86fc7576847d6efa116e54bc51fb7513ef57299a13c614ad0317344d0241698e9b0b97c3e6ae2bf522a976ebc44518e673730d35d8f84ae83eb6689dc44fdd52b91736011992036d9a942a1be5d0a6aa7a759a80e34a3f23fb1059d77dacbf2df1cc22de1e8d2a7677c606cabf0cab04f4e28f2ced1ad1d55addf4f532182a2b0e486c0641841498778afa09b8e2f10af5e43af64184724253d57e20de67bb483ec68dc7720d5539ec275845ac48371dd1b691f4e0759d09ce3299760e8986c903e70832161c978f8aea90497c3152b1ac5ae65d93258e39b3f897ed323bda304df3582362bfb220dec5044bd6b898d775d4926de52ceeca17f1ecf67cc41dc65aeb619b1eee6686e5e5a6ddbdd21e710d6b077ca9a3628c911e6ba039f5ff610d1a07e340e3a2281cfc055378871ab9abb766df5f6c2ab542bb9ca98443bf512c78f7c03601e217e32a5e0c779f83865e0cd4bda6a4e58c11ab0a01f9f5b278a633f6be46f54ef3ac0c90ce707b2438a2ab0719b2d102dda6da11316239b70e8d06c7cff80dd54865bb15f3fdb7b8cdb2d91af6929f4a1abdfffb55e827739005790fe16fb2fb26aab1d5620901c63eba7e3e85b74ab38c777c497e84299aa21c95f45e0ebf26279972fd477a01e8ea110a14235cded472a75545ecf8dba6da8bfb67c60e09690495b3db4818594dc1e7b7ae294b563f16b2d81b152287bf8eefab633089f0f6cf37140c8acf304c164629b672742f4b2fb3b01c3f6b9c706601d2798320aa8310b00f33b3ff3d833953d559bf38d4f5248bd07b2fad06c7f5443dc45866fd6036f8f96166252eded9d8168563a8b008d90854726eeff78f6d1ec57d5d26acf466898cc08535e70bcf042319b65f27ff167fdb2bf933ae7b78c032490ff056bc5213098dcf03ece4c5aba5d99f586059a85c315fc74385e937972f769b6f0c94902df2395f4d7ab60a332f799b7c5063c98eec0797751b95cc22087ee8f49d40ac8e12b182031169dc852576a36f2b6bdc663033adb8fc3d3b77ba5b0708b7a0e4f93dade7eb84441750deefa4d8ac2d4c297793ab3c352808c33f976ee56d431eeb548c16bbb37740090ffcef0c5fc0baa5f5895a42bbfbb6dbdf3bcef962f909743773ad5deb8dfb24d99828dcd76b4fd022c268797c0804f44d5edf596ef59671a6f7059f3ce3e653c19e94e834184e052ddf476918c91c6cd4359da55d75a59cb6df7154b9b00e2c0f233db803fd2d3b82ecac04db2f0d96ee46cd1f86ba8f06b017dfc0fa35ad3394baf34843b8f3cb4a851ed46c0e014cc40e7d9b91e8aeb3ed614e1ceb4046cf8cdbafb381a9a9f462f795087e38a8ec008929305bbb38e62890ee58fc60526d4678dd6ead18b8f4bb873c32192ffa481007aec02d2f386a1d1e184a552be77490e519a03b44a36af41ef90903e54352ef6ad1eadfbf6ce81b0d1575e24a6833d5f77829c68273ec59bd598a2280a8d426beb0d1eb4f4626520f81dab925c7d097eba29eb604573502a429f7c3dda9ed15c0eb5e3cffd7856c5af02e2843a152908070da0f6063e5ad2f6f0e9ba32cf1c108d0a7bdf13627c23bf5028016f89a5bd151807d38902e86b5812ef508e9b20f16d9b31add43727a8cc05505391d08bba111feaf7395fc527939acd9d2e60e0e567495650d80ae3b273cb1495abb680a5938d270690093277d17a3ddbfb548867a766bcfcff3f93e6871a1724a936b2cf55eaca0c861b962cecb1f2435d251bec9d7687b0f01d9488d49631498d2d314e6846ae94705ab314292a6f39984e71432ca6ec2ee536ab3b4adcfb874d8d58356098cb28a212e1be629774f95178332118e792fd04e4d25654d3018f7a2307605d0fab0e6f58b567e12ab92f6ffb1981c875807a20180513662ce69a054dbf8dc98a47975ad9fd06d09385e4ba988493914e5a60b8c688b9954743673428354b4cdc2b304cf1a234d10cc5f3a809579db1b090ae0a23a0477b939f8aebe0db66bf8e3cb8f2e38361d2a004f8a349d8b73726fb7162a48cf009287c13b34a64c97d84f33f35f28b54abac9f08acbbcfb0d55cc1cdbf7495590fc6a82a817682c764f0274a8ed1b5c2cf7eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
