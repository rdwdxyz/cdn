<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83de897e5e3522d5bae4c0290a4abeae4837f538973ac76a14628a73e0e8af9b9264bdb62931a6625aaa035dd3c5b7e165c34c04893c0ed042b6a56f5f5305426a7fa449d85eca44266479f20c6c1ef7e5a3f6078cfd2fcc1899bdc05233ba97596a1fadc70e1cb670218541fc3b00dfddea6494a743757e94daa868098e6da11e85d765585d2f1dcdbe6a9b75b333165b4d7b45dca9acfac3bd42656163aafa1f4266bc99af4ef4edce0be6547e8a5b0c3854f4cc996a8416ede37b41ee58e9a39ac9f04f10bd091651b2b31a9f08656a9e32112675f98ab11e1832ac0c9da907400136c810ee0494ad41f2e127fd357aa2c9dfbf3459c679254a72003454d430d2703204dfa92b610e7f71ee395c6f739d8764bc28881eb90fdc84829b6fa3b21275431922864478edc46208680f9584cbd3e47f680af6286b85d6ac56f879cbab30d049ae128ae180be0ef198141c8428a6d9214341d230d104cf52a9e28833276a817f25c97ee6af5c9f2983cf4094505bc4c2a138dcfb74bacd25d932d45e4d39b685f9908cb8dfacad27f0dbe20df2a20cb287f110176a68c93bf0d8196b60023e5dad422d0a824b787993c0a962e65eb291793accfe7d7d55bad2c8569d2604e27503680e487ecb3a942202e7d8182225883118cd9156d55dbe80e28321c2cfc611c400110a5d07d1bfb50f4575336582876accefe9df749a669215cb1051b680dbe41ff52a55fb59ad2da9a38044fa6181662cb97f1cc1a9bdef5121a2e68798aa3a54f11b70cb45d869275ad915a23141a30174082df8189c930f288e19d6f7e2fbb9cab0b5779db85d65a53c27cd4da5ef7f0a964d8c73198bab5300335e75bd4d607676aff63ca309319e8a6c3241389ae1c147da4fe984a874cf2b3192225a1c69c25880982b511b5b11c5d9643bd1d0d9eeee0f68d37996016f5d10c8419678979a13b9f09562354f44d90a7bb7b1bc0b4f9d040769d0d67c6b601fff49351d91b95628987b845c7dbeb9418fecc5c44fddb222400ab36d92fd8001ec20736e01a299d86b6e0eed2dfd6c018116be85a2d999a730d108c8a728864d29486fbe5d3b2116f4d6d55ad8abd4d3a9cfb239e467b2f9272ff33b2e06558e94dd1b5acba089e98c07950d6c5a4ae49bbaaad969b55009eec48661aa3ed60423caeccccfb25003993f7c0726508510bbcf09cdb30494634c896dc9333df1bc0b731c30c126a15e7dc01f5ad153783765f3036d1133f28a1bf392c25ee0141d448b86958f8580b3009e970a74369719a55a760301b6a07d6ca2ece9b329dcb992c1bd0cf86796d39ff0a115f3e0da0a1f098851cb448516fde611df50586aabde10680066b4cf280d6360e1a044c572b60ec595599cb2330e7b7cafe4abee21864197c13cdbfa5790ecbc14f50e1ee5ce25d9e716c56201aa8728ebf5d42751427343364bda67ef886bf9a092b5a2bd7998384f435ffa1b20991d7a708a1a9846688a3f44e5e22aadfc5232a65a099e95d2202c7addbcf1f7073655ba0a76b761afa64df558162396d1d4862ed930ff8d8013adb2ca806f21e6dab45e7a9ccaeb8e7ffebe4f683254a9b7f38bf43b6745ee1cd9455e2632a6c714b203beeea8d5025e68624a55e89d61a75bb7547d0cff4fa744d5e05f9a20593a13e8653422529486044cc86b10f4aa1aead5c2a60ca65cccfa6f919901ac361f78bd70934a87efc12cd02a67756057b7a9412d8b7855a6350a90b9045bb1a12d9b43714b9a9f97e752baa876264d11cd6abdf9fd73de7c50ad30e001f1b3d29faa508fb5950a0fe1f867b1606e17a2ab34a07776ff84ae713090e22883350cba1561714bc07b67a730ea8b93331ff9e5236b957ad08af8dd3dfda0b4ecf9883e61e2dc3d11f74ff876deafd70a0edc39b0d4c0c393526056675a05aeddb5f1bb7c2aca5224e943504141240887e33e50394081b2f50bce86f3ebb75ae0c0fbabcbf31fa8c69da816e8f3215a14bb10fc5cd6385ccbd507e381527f347f676ac1e16223fc120232ba50898af72b5c6add5501be3e83feec369cd8456a54f4a48bf5a376af5654be78fa7acaa4e0b5bca2fd11701babcf099fb74afd582121f16960e918649781766c543fff576b26af7335a9e1137af1d18169d72d1dbb8f146a38f3194702f65d31062734a611361730d21bdce793c06824532964a855a7c9dfaf6fe9a8a34afe21a232b61c6d6bb4d14f3c2e7d9c566d0b6a152ffb671ee09c78457576ec92b8557161726fbed09ea447be5c3d231990abfa8ab57aa865d6633d273f5500a733645a78c31b62b9e95b500b1c3f7ff39852782df7f6bf70b98d58e7fecd0b9c137c962be89dfe6f0a3515154b0173b4a5cfb683bd9d8652a897632f93e0809c9062cc76facb80806447990c453ee7689a9b580657276ffa68532cdff8e97e7c49e364f3149135016ba062159dd6a29ae6a55062da361cb180271fe31ea49f425adaa866a1e651529c11a81a807948dc9fd9f1dba9b7e8f489b37a6ec49ccf16be3d4bd2b91439c50d1f51c0de0999a1d72dcafea3245b84ca22c74fd0c858eb582201e09e6922a6293e7253e9ec9aa7a97bc4e69b8a0b24ab2209714a632df9be3ea74a39bba262940f7310c1f85690ca9d46de408fc1ee16db5f8a7408ddf064346a81f52e6331f4f7c47d36a5a75b5bbe63b676afc3ce7289719e69231b6bedc148a7ed79d5e0a9ed0511e079b757f51d65cfc0bd5bdecb8c3d9c4f443a3122f452fe5a0bdd0f454e55529ab4b278a0c776b7eca30527ce8c665d134accfc5ea35d7383880e8ffb27f1e55be24a6491690ffcc8f3913245340cdd7048e1354a4795ce0f7a4eddb8b726dac56d40401f23b45a6ffc7be47c3aa0e2fbf620d9c6e55fde1a2ac03c06bab3339a3aa183d37e4baf6886b3a57d48e71e6222cf322f4ece5656e9758391f4d935299dca792e9d1eb6ffeb5777fecad9f9971b618edd6062505e22204670727c38721615f6b0fdfc6dc41cee1870cd308a4685a1f16e218d6caef1f23c9a933811677fba2e767c27d2f0c74911b4f83600e47043080918d8d6e03d6587ee57cd34c54477826190b86d3195b41b904b5ff1d7c0f0ad256c7f795dba92b319c238f5b5e677e0fb189ba324977cd027468e09bfdca95705d1e8d981d44bb507eb9ad8b5a8a32f87385dfc8660b7aa1b0e76d9f06b871c0d9b76c1f73df6e41f6cb13ae5891f6fc96bf56a45cae4b9bdd347a1f92d92ae15b5f4485fff0041d9fb3d2cac0b3bd4f23036a110d4094856920a4493da32595a8b887206edaefa53093a0d6a9fce132538e93afad895b1bf0d61f7424e1e839cbb9fcd48466436ed6280d34dbcb02269f3bb695489813ad3e1fe8e9b5dbda0a88007af13dfa15496dc918270823b3f61491b2da236a2fd900da7578d1b3d29570601ea366f9d249b875ccc88358f775b8ffb6f8067247ce048f4403ea617f360636193b23001e4a20de295c3cb105209bf380e4b00d7e088bc9ffa2c5444ccf480b5c59ceeb6a5e0d6eebf283ddcc3f1c6d1acd9905f46f12dda72a5e8b9868b52656aed015fcd57556b2178652bdd7b9647adacfd747d03c0abc125b4483224d49e77077ed068ae6b217fc4eb03c70170d9538c77a8dc2bae23a6415d756d5d8e360d96109b26da5aa015daa817191219949fd781df4a31f35e9a15b4dade76f954dc2ceafb3e4552493500728e6c988feba2071ef8e9e5dc7382c52ef02c18301a00f8ac190634c7eb28aac83b71cd01b4f9f43f68990c0d871b5853b958269731e90ca8de825198b9851279efc66e25cff887967e4be2bbd7dfcc5ddbcc1c4e4a2f8b652ebd2fe8c51ec5d7ab50635524fdd09edb6929ad82f008f564b11a5e49936ccf31c1ebbc2208bfb4e590383c1ebd06c9912cfef1c050d42fa07c3fc103b1c3d3f923c439d7fb2133d56fad0acd066ac68d7eaba7ec1c5e3f1e3f709093e5a9e0e87850a5e39ca65346ab0063803da9b7f37b7e7e35f94e7d8520e4651debc866bfd0c2b6c25c9ba53cbfbdad1726d3b9ca25ad88242fe9f2a252a577eeac1959602034e0258591a0c98f6d1eba2ba4959930faec32e2e471db8e9abe0a4a6cfad801d5f0dbab3c60d696162c072c6fdfb881fe8ccf9dbdae4612634e06875334ca60bbe7e59f38385c8bd2c1f1b11142b5c132ff57a184e3aff0a9add9b6e34ca8194a97641ad17247ca6b636b5e7fabb851d1273610238c402b9a6b647b2ca47f67c9a8f29a7ab8674d09144b6d457b14c9eff793d61202035b49192a8b9330e36659775250586c3817016e1d30e9bdb5511a5ac99be368f44a97ed36aa3cef35bad44484e1e1e26dd0c5a9cdc883768eabdb1c970f0fa6b752be4a136408b5f7b7f55b369d5f0624e7d5b64ef728a5731d1561090bdc05a12a7c18e88eb8442a5663a38d28307ce726fdb007f77b41ec9fe539919e52cce1172110dadbb3d881adcef346cef35de18e27a131ae3fb7a5cb138bb1b243caeaa675cd112bf9d32a32e0ef2abade71b233caa09928d49239a69b013b635918619e842a4dce89a64b332eda4eb5134ad9ecf1afa33dda4fd60899b965240e5287bc85400fc3fa3bc80319d83566dd9a1e77431f4a9bd43147cea5e8dd0806f7cb59729b6cca4bd05db221d767599692eaaf186f530c3894e4c6c1ed6f0731c247e31f6246d2f48264dfd8e8af8bb56d89bc55c269bd3e0fcee2b0c80923bed220370d6502f6d43802a240b589640327dda17b664c9328478a201fc3c98063936445ad27ee9549b82471a021acf2b0aa76c5e8d053d8caa7c97f83756c9b343539d8f1da136a0693aabb9e67e97eae8b9b14144e81de47aa7665bfd51c7b5781a0f65ed1db4f45d241f2764709d66123933a4b53c269e45e2244009a2a862817faef3d56b4286bfdb3a3b181df3850b8ea69811ea9509a6ad5c4d2b5a86643d71f8889a490a94e5502082f0f430befd1cb508f52738fafaef227da3069468aa1beca657ad3747cbb6677be562ebe652c5c9a4b62abc21e13a0884d115c6280bd71dac05409310db521d4b957bf5a0b426bd55ff24ab9e051c2870c61aa2663fe5ed4df974c9f1d9b4387d72266b5f33de5670908300ce45232df45f9f7f7cdd1ee3e3a8808ac4f7b4de2cfe39d96283f3233b9ad6542e4fd46b47e36960ea8cd676a80b0e638a485a63b013966efc0bf40c9b818d9efa88067df52d05ddd4cfd2673256353a49224c9cf7d011b86229541a4d54fd4952e040afef3be213e1c69cd2de0780e76c7ca4a184ecf9818179c92df01e05189f1d95f6ceaa3c669a9e0d8eb2067751ba820069070eef29f52f5ac72c66112073b0911aae337bbdf6798b1c7b4c0d8bd583bbcb1be6ec99d5c9ec023e9ef255c2ea19bbb150d96f1ef3ae6b41a4a947742d8eaf49d394193ba5374d6d7e684ea4af197ecddebb64eb8b23ebfd825a46433e8dacb89213a5bdb334295e20b66998dd3211454ae98a234c6c732e9818166e9d5afacd95708e76293a7b9f30fffa75c51f5f0cc4febde6eb37b88709ee3ef0f246febec4d884da702f1cbd51023af261c38d02eaa89841f6f0d5063ebe53553820fc923953d4e7ffbb30f8f054263b3fb3e8f6dc142f049dde5570f65bb08d851c178f76d7b08b995cfc6051fe6fca65b5e474b5bcfa8ec0dcfa5e9550a17809736e5ed0f9f68d3623e074ab70c68eff5da35f080a32d184af6abf1679b6b8765cf616a74f81f52b7bb672307aba9a0a2a072e6472abc7b5f9a7e5b27eea2cfeb3f7a047bfde7285a8e8bea78887eaa0e1540a17296ff1f2adb04fe41c178031b97874063ccade7d05495b08f2d7d63b5dc12cc454e3c1f3393eecae70bbe3f2a72730e5439259c8fa363750a23673a99ee6206216b8777471d6644589aeec28df2acde1775fc7692bb42080df29c62690dc345c480889e04a2c7b7a8ce14c74ad7eea0c92ca55a61f8ca965909b79e0dfa5f3cdba274b13caf2c6383735b51ea385977368718513147cbe1616e8ece25750b9456bc9861b2e4344a2dc1f5befca8966f058e31c4e59300c0c3c5c4e9f69d4b8e94dbdd82c7a31aff4ed3dbf3dbe0ff45a27c7dea29ed69f20af1490e26719ecb1f86e330f7be81f13e8c77e23d988029b78461d932fbda99c369d78838533f21f3f395df8fe69081f6c105a069c930db2cf0d4c3bcf45ba143d6dc0e7ee07c32be75a3a4f5168cc86a6de6223cfbbfb8dc860f04fb33a63cc52d61fe89c550cb04ca543b227b4db1771f535d9de04b6f30eeae85b7390da88f8db97c78952cdf0959aab540d927357aa2322d7cb7c64e0bb3dfd91f0989eef42eece1475e5cd08c0c98cc929e55b35ccc7308a0534be870ae80b0638abf05028e1314f99cd74248122385df88f0df09c7817034f4bc6aa1437da2ea783de10a5808917d1b190195a1ded4e65cbd77d5c9c37ec3935c42ea3161dc4f52885fae7bdfae2946464ccb8693d37db49080f3491985326dbc396f1467b4c654f9ab56e2dd6da5e8e758bc7a6d187e0c620206cb5c56faa9b260cd4e7b478be89b9e28134cdcf6b47eb390bd4e11adad48f13b46b7d3982ce77931b7379ac6db56f8b124a5a7b0a59342dfeb77576d60c45293d11bb8e9e2714a3f5ba89cd20b44974f8aa66ea71faa33a1f5f2236a574e2e8d2cb8a857e28ff20a7100c21caf4906b36c1e2c8921f55ed13805f589f67058e933bcfe4300e109c141fa3cda1000b8200cf2de06cabe524a782ac1d1d937871fc8eb9e5a7c22aaee72fd8082127d60e51e8b35978dfa667bb63394b3e3950e8982831f0431ad43ec372d4d5bb7d800a2c4b099a63e6f55b1c11f41646b0d34e8b00022e3e677d7d572d5916abbee95a54087410bcafa4cd687bfa643e6c7bf05d94413d59b997828adbd5c0d09c939726e9698439c7bfde39a787f72fad300219df859db3c5f3f8429ae76a69a40e06773545d9c52f6edefb3a737e5d4e94d7c1233ed9fd143078c2337787cafda22fd86c089f11ad42bffeb5531fe8b447c1162b9dad892eb44a3221bb73e48424c3e5fbb4fbe3c10ae1525dc2b03c6f529a5877828faf722a21ffaca4b55d275cdcbea5343dc80f47c00c936e959ef3813cd1d0d3164a3de98fa5c14ea65f0e4e422f99086cdaa552653e44cf79db7d19e1a2e3e1fa4ff9e17f5c1464060bd1baeb63028d52dfdc6a32121e661a630fefa0b8c8c26d6b486fb8239d37542cf0977923061e6e2c0ca8ce016a75ecce1eeb6ad1219a3ebccaa31b083aa93677973d75ca13a8223b7fc727323790d5d6632234cc0c5fdb06e5ed734c0fa4ae193110fe5669598a83c3d99aa31c591f673cef43e5fe6f3d52d447bf3a3283cab98c9f823102d879009c56f0f50a2b5bbf703b21742b38a100d4cb3dfa632a97372e9e04e4da74c2a46de18bedc5e673d6739a04472f35dcc1dbce77a165608e5adebee54aa5ae1ad2afaf9121aa43a73639ac5716c316ef605e564ae92f61e57bfa0ca174971443468a172aa413177f974291ce26fa918486d47badf0fb436ac799bbfda1adad6cc9971af4eb4ea0a151fdfab57be13cbe99bd10b4bbd0960e872472b1b0db43deeb30571c7f5b1cd989f60f04fcd6ae86c67bbef2f8980bd9d97213c3d52d9edf17f1608918c18ecfd4ca4ca13da714ca652cf4e2a85e325913e02584e92198f34bc115dbb31108e6009f2cd591ba7776b4bc39333cfc055cf734c0c52ff2f6ce9601831b59bdfa832c8ee8f2c2b1ec180f08a611da194e2511da04516af5bf87344e00daf014688121b6f42dd984f8ebcc23b4e8f747261c14e826508b9a9271ee20dae2bc1a027f82b9d8bb9e0dc20a71ca844c5296a97e8c234496cf076486db5868e214e372d947c638fe20344e42f06aa60e7d888f94f82ff983012f44452aec90f68077a58f05740e84cbfcc60b3c1c71b385486a0f01a84e52f6ea09e5e56576fbd00039f447905eb9497618f061489532db47a83f454038ea9718a33baddb0a5732a00b03edcebec22ffd47ba790905ca2dec3c83073cd8fda0b34f430ff6d15845d0f097a6152a467d8a4a58e384c47a1705be6d9364d34713ac670d0de134acca7f0ea10970141353b052302b4c67f4ded2599c7a1a3e4eedb4fe3a9230cfb94521005de7952545089414a5cf2d971a140cf71193f8815b9b006d323add63c833f4e39e8396ef5ce90208af026215ccecd815197fb27e8f69247854f224abcd4f12d0797da1519887bc978f94a200fa31854efeb93e0a2e2db625f089acfa0aaf6dd2aabb7f33d3fcf381bbf85348951b5691fe49b0b0b049db8ac3a2d37efcff8935d1b67e931b93a9c7b51f937a79f75c9663d7e4dc8eb8095315295e3f45598cf749d3c8b0f883231e52faa64d7f0ce6cacf649c4bbc87bd4c903fb13fe624ee2a618509afe6dc4d23f05c6c4aa037dfa6acbb22bfccb40e270a18e4d1868a6848e171850b15969ea6c9e0e012e0304782c079dde7cbddb3bd82186e52ac76bd0966b1e2f0bbe6fd8939699d3d5ff0ea2bbf7d17f53a9081a004249a1ff52a35992546520ab1b8f47d8a7ce1122e32fed922d4dc82d49975f49f81d24576144477e88b6b185b7f368101eacfdcbe9c1fc683defa4fdca3c327902ecb08cdb8534b3afafde62279c0120c87003f998844e25699ffef82c025252a67f62acb8f4fd5be982f2c985bf771280eb9ac2737603c71519380860a123cbc7b7fb6df62398cca68cb39eb1f5ad04382d63eae2f8d1254eea3184d73d8a2ae94252da159173223667bb2879ff853185eea9a9fa8353bae4d03f1c9115459db6fe4b064f658f0e42cf8e36911cdbe16f33efa1412177739e2172a3977e8a43cf4b841b2930b03369f4eafdfac38fba148cb65d1f1170048cfba5929e4e00570aabf0a3792ae5b6fe96812cc64b8c8cabaddba7f57fc4bed5e64aa6b49aa0c49e6a2394a6ffb9787f3e38b0c2d50d752215e50d7f87ef3c332cb83dbc2f867434b0e6f557bb2f4f7c3e90aea47b2573675583760f4d2c94b00dadb44501d1a5711d221500a019be33e01450510f0ab7a309c6756ed25a59b1585e9a8dbdb5504e1a536e562bf19d917950a28ec3a7749fe3163508a44a9437845243f8cc2b1f93372fd598dfac5fb7b47285ee1dc63413cff9b26790fbe5d757059baa67f483f03425d4e8e7f9ba7a1386cb1a5c9c229415399ff9e154661ebd3b760c17996e2eaa99593d7bba1a6d6cb18d4acd66020bb60ef24c631fe0e7a43c29a44b95dffbade9862fd1d1c0cc69b2a023e56d7a1ee25dc5d33bac7318e3daef4c5f3793cb7adf7af29f864730621dd9a995ad8e3e94b6925fee92b615cde7fb119646269067d943cdb4266f1ce62d923bbbaad9d4bac0a18cf39ff34985fbed4594d94899d70052d84a43dfb2251c7f7e29f4db579c613f6d157116fd9e89b7b41ed150d2a51232ca6042c2be49e97ea4f7b6dfc667feaf835aba1b00fc9f9c81f36197869fd662f89dfc6daff3ce5226cffe5ef659c43ad477377c60227ad1ba257044e247f2971a85dbb7d8d831e6684e094ebfdf97783871fd8afe8f9c5ac4bcc715ad257e5e65d11147c682f6bda1a6336693f8df1d4b880e6b543bb4b93088ccc514ecc981b5892a85c26eefe9e4fcc40d85b2ff6605f4a03a8faf2ec66642224752c8905a7dc0c3084f13708aae1d08aa2fe9dba75d5b2504e6b06217bc4b28a546fce0be2f82e7ceef512208d841895fc62a05c03da0e3794262f39efb789f572541eaae0d0895e522d2c4d6061d556f20e5e2b4d1a02912cf4cd24866eafcc0fdb15bc8be4f81ac524207435c1cafdb2d65e7fb5cfa53ebb6e9b62bf81f3e75def323ef6de6e392c0ab8de2284a7f67975e35ea8dad5beb50584d31ae2a166fafad13ab2b2e93811ea3f43a30c3ca91175bee0e5b34474de8194c589426372e3c3bfbb1243aca5999f8887b71cf1a3282aa199ba2b0109f9569c7eede128efc0d07f015ba42fb1810a13b8c534c96ff5d30d27618059c8934bd8865fd95eefdaeac073c2b5d3ed1b766ed3d7a6555e5a8bb655dc4fc71690be914a1552b02a24c1c670341d7ff6f2b1c37326a08ec77cf89f57aff4c1639b748ebe51afc0878e62e13e89e8388bf4edf163939872ca8a77ffa806b0762e8ee8c28e54b4576e777911e47104839835489000da806c4509f29b677af856f0b8deccceb5e92e5590ebb11c86889c3b85f25a6f5009425361bf5107739c6e0dfaeb2524d27ada781e5b68e1e07706625d742a26d2b9264c6d7e211bcc3415d4da85ab53f5df7ef747a56aa19251b3759877529b39333a66b5b3e732f8c2041d9ebfd37609d7abb8a6127ca900b6033f79d00f0c386a304093dec2822fdcd8711ab7246dc0f77a1421b135df5db35fc66cd06bed0c9f2ee99ace913477c0f855dcd40a57886b1ebb0cf790fd221f5f9f90f1097d054176e29a54776696740a323fab8dc03f6864a9e5a24f40efd9bb889cf97012d071cf68b18391cc5bec9a0377198dd85d49af96f7b9b9c4f2ac3057551e61854043dca934f4200b622bd5db9b4f7ffb881eae9191343b06958c3dfed3ae4d2f8ebc376582deb5e6e10dde96b87986375fb44a1073b9cbfcb26f12f00a49a83fa900cc2c0570f710c99a6b62980967e997ae96172a4a7407aff4ae1f99faeb95cf0e392127b7f259345fba5fb516fdf675e2da61ffc31953d11061e203ff609ac2a24eb7ef0f3e54a911683bfd177fdf99cb5db096160af94a5439f4a0c6327367291f4c278fe53078f0b9816d417b47d83e9833e38a058b8f52fd401d60a932dd37a06535d5a4c90ad322072fb4a2c18b2d0c59b76f92e0e6bacad31bccf2ddf0a48e38ec4595d7a11a6da84674fd5f2e9c5ef1bb66f3da8e04d1aaf5fda83a6bd8e7c2db20647799846135c1a2d00edee9c264ccd1402e92ffae7827b4784b86bb538ad593ca11bb79cdbd9d7a36f47ec68368ef5549ab179d402b472ed705fb3a2b21e0811d94685b1ee7dafda5e7184815fba88a44df8a1bce35d30ce78724663ba622fe01a8816b09cf99b44c0eccfc4f027d675888cbb167e87dd274296cec470d68416662dc03c44c1d6fe0343a90f9c2e912617d1545ff4252baab9f0b8aa616ed980b745ae75d39f21d23c3c14f80dc3e092455d95442a89fec3666d16bda354e1e373c36c44d55e98c6fc020aa78e962a7fd0606d756b35a689894fdab691cd4e5ead24934ad70abaaf6256e06cc486ffe95a93101aa9ebf33ac9f199b52a54bf564e59e3a5b9a6a553fdd9711669e646ed6c1b00398cab10a0532234769994b39c0fcb2c5996241f5e66e5c2197184d394a381636608aa58f134ec98bc2b67fb53d72fb0fcf5d503ee4ddf51fcf0c03d7f6f0ccda13caf40a3c7188404e5c24dbdcaf905cf2b3d42e0c2d987a316d845e445ff55b761519925b6e1f6b21064c144f1ff4f4b450d90ccfbae46e41488d84b6a0d9aed92620eb2191b58d67d7c21fd2ec6a4def8cfbd1431732e9b68f04530f373723ea8051180988bca55d447cea8748aa091e14f6392e4e0d445643adb706143268cfb56a3e7fa9a4d53ef72c93390cc27e4c05bc5e8e2f91a42c2631f4413414c81991a0b10015a1bdb7a6fc9dfd01ae2077c6792c478b5155e917d4ecce8958835cdf638bfa601e5c2221a275c5660346756c7632af4d3fd1062b0dd65c4c4009efcb4785ea4d052284aa1bc21284f62c7e630e7cba40f57d20149a1bf264b6bfc5038a6690b489f341ed95ac302e952b20ad7b09f599d13e22f7dcd4d0cf2d672c92efb038d01f899a3faf14240b975dfb9e2b72520aab647afa0b65d382d43b00735cc70571df1d25d070dfc20746936cd9402963f724fee03e66ea17d0c05431df9c39913a3646d932124c81ce176d6c464d49d697d47eac137b93ca3b328d9e2c5d2fed22c5513276a92ff5e40311d8cf22ce8b10b66a2096c0b39443dbae950d0115c1d3419994288ba11d1b458df0908b64f4c54270e790b4317179e95c24b2e017bb484edb070862b146a42de848ae71ac1800e01c4982aa3c0f7e00d846d15abb7fb655533d31380f4ddbe20682c452ab314f93596308c8120083ee8949e7cd89e9a3212c58a7ddf2a8ccdd9fb00a47239825d1b400f3795dc2472a398d796d4dc94259282beca1fc3f999a9d2ccfe7c18214ee44449e43d84396a9a95b2df29979b5b508c100c058775cca67146b1836739a06205b8add85b6252ed6337cda089cb78a162eec837d5459fcc1ab5bc8cb55602dc3a28f3ec7bf6f0cb18afd84b518fa0370e8e5458899e2c51a52aaa72c19f75885e7fd529b84ab694df5f6ec7e066e1f2c5673e3eefc3bb7a1cc94c9b8527c37fa0ab8a707d50fae24e9d9a1f4c28478c1aba47ae531ff07846efc302956147a7d1bd3d62dc2f89cc2e2de5faae594f582a39798d2f5d2847003e4d3d6886218a1bc1c2178adf982dfbda2da67f0ff2a89d8a4cb5ee9772cf410f0eb5613f0b9fc6bc52f400cfe6cb87e42db3302e2cb88dce82fdbac5dc974fec55c4bc60158fc44b8a9226c9850517dfa5829c13d58a95457ed7327294521368f3256390ec6593dcc2bb28bd6a44e4ff39eea3499d2f4f3ddf01786c9254f295ddcf741ecf84b87a2fe6f6d83bb15dba349bd54204670c597108cb1f201d67a0cd85d96a04c5f782d96a2a78c20e3cae27b00ed6782395fd7b5352469d80836580c99136777b7f8ff045358fd6f49b3616aa3b4523011b72c85eaca89a3a1c4e2d9dd8f590bc49bd01a64fa564a7314363d601f41e56be60efc576b88c4f8b9fb68ad7d9f8d05e8c067f449bb70437f5563ec24c8bd43fa5064d364c9f6fc701d82d35504362f2fcf6b28e2fbbce070da6de1614da6c592c79c4af4073d6b9852dc1386134786a1305b3efa6454f456d42cfdb8abbb3150006388e5191c4d32f4d119f1c2f1d37a441aac77feac40d3883318213f0ddd00a89bcc8dfb844326b9031536e6271ffa30b169b188c5fcb3a4aedad2233bc4cfec86bbc3720b27b794bd7e4753d9ce90d42876a23cfd7fa4a22c2571a1cde3c720b00c03c08e0a993d66e2cfb77849c954927d260a16dada75a813e6876b8801dde919c7fef9e5439f14fd12fbb367a4673e0a64490de877987c49a091c4b8511b564dd45a2ddc26ac0ce94d8d23e20dff9c8529e6ad20c8fc8819c95a4d0c1a08122fdf6ce3ee4df5fe79518654596d6a3e15c859ae5f4df6b7911c40bc12068349442a1d4c5ec78d36188c32032b74da26859effb93a32d62ca240caa4b783ef73b4017521e5da4b778533080170d80ef29143023abd422517bb57f88ad003157dddf1472917bb84544b132b5d1d7b448599b62c42b3f77f293d1c29631da4020e42b7eb2d39c9d04105703e033ec04ebf07876aa04a37f4a2a35e725178c8ab419a04a79a7f5867de37496091c4d26f7a42f46172af9d464c37ae51fa810453cfa1f5444a68b0866a397fa843f013f083db2ebaca966d8dabb63265fb962be0a92a7ed2c004a23afda0448c22ffb0a9c8c732b770f025ec2a822ad021b72bae5ed88a010dadc5b0ad67e4f4b897e2b502a7a5a69eab396c8d36cb1b19fa48a5e5179d4d876b28cffe8c478f5faa8592cc57f080db269a47f5530684c3a99c5c6361b8d38b1b6c2c2ed969706a951d3655fadd0f06f6e1d1977796fb5e0e12b43ce71fd3dca61aa415ef671f82c48a05aaa8be4d046dd1b45f920ef63a67c519015ecc6b2a79aaa088429d142d4504110e416ce9295e139d1315b394d231c749c87c9e95ffe3a211f40736db70d9b7754decdf855d7bc6eaf5a95c65ed0847b586304b74f752af25c8258e0df142813c6f42e156c53182580e8c78d73cc055f811f7557ae94fe4e528dcfe4f58e83a94e0b9a19a85c72aae63b6cd6c4c285f42fdd796a70183a9fa7ca2cffc8c4721d52df37744a1f457b1cb82ba1632742b9a9c30a42fcaee805cf3e44b6ed4e24d14dc4da25197c3890d3529f49ca7c627f274edbc594297c5449f6d3d5d84a5bad3ad78f28fd2bd8eda68426243d604846d7883063e1278d5c99b1f1112948d7598c02d13678bc62ad0bc86ae8effe44d008c74482a169cafd6598a6761da75ecd540851420dbd4e64a3cd5dfa413228b5e93b402c72fbfd26b01b7688b8a820fcbba9c92d025b846793d488f31d73ad5601b2b2a2c5011cfcd6756dea02f15fa4ffca3f291942e779d90ddaff7bf86547cd5efbde85a19e1b7dfbcf7a472e0f4cd3731d8e28437165d1ddf0815283700baaf85859c0109d480c0583b0967a1adb40fd0cfeb1c41b0ab4f9a1e0f709675207d8c9fd00053db19f5fbb39fb2779a3db2cfbe71f9b5a7493ee612c281e772c93a9e63ad5b1c2107deeb9c55f3177ef519df0fef188fdbeaffc3a1ca51bbc16f332de7e4cb3a058d7b27e0fcd29cec90bf62a0cd920eb4b83556e32ac69b2a1b55412256cfd58583fa2993faf649300ac6f72dc63489f45e62d15b81e8d2732d58341726db71e6d6d4136ba1c5e5279d4c42d31df48f51f0c63e89f1658da0d51f9448a1b7df5e971b42e05431d3ccb5a02c838ceb84c3516ac438c25b7420a3e4526838c6199b810910e8f945756dd937be3b512b3957fa7b8fb5b456dfe6676dcaf93bc472a98b149bbfb127fd6883395109f65f868227864874fc2df00daabdc14031ef01cdc100a1f39d624d40991e03098eb059201c95ed7d7e5c29efaf7b53ae3492f26384f8af7bf9e6da0ff2c6d4d679e6290e87e9f1659d1ec91e1519043e5e812c165e5e11b5b9c7eaf7099844892867a65320f824abfde2ee87f5175f640fa74de7a355dd561959448f0d2e5c24e88f94f81f47b8e9c6bc6a41cb59a718b0d79a388d45b70836fa51137d123d10fb162a4eb74f24da8964bd491ba277bea085b778e73c6e0bb4683ed83d122a18ed1fd4f220f557f9f791989e985ff62e59486da4072cf41e2ee813cc7b15f0d971575dbb145419e01e2aaac2c27b1fcd120efc1b08ac68f294e4eb991351d5cdacdeed5276972c8c468a9530837f5a6cf4b652240a9884e8d7d3bbfdc2cff79cffb4be731341c9316bd12e02e886cd5766bb47efb444528185890161c01ec9866cf832fb9ab2fd0b4b85893cba0655f37cc3f875b59196281ca6926ed8df2182bee9e0b7a98291fad6f32a0e463bbe19e1cdfde6d7a43b95f59dd414b99d2e812c8d9300a01d0a93d8a9a67dd6bc33ee6b806f7f486e6ba01d68a9f36ce92ac3ff76885e24701fc0b7187a3b6e82592a52166e6fff9832ce3d3f39f7646c9a3e200d6c3f44ae62eed1b645e8d4025debc7078d8ad1a2c65454cbaf439118186e003c9a96bac0233bedee7b60780b00907789052efa3abb20d3b08aafb179ba9521062d8f0672c3f16215e47c8b25961f4c7057d2affdd2f01b8b20673bf928c5ced625c12c0b147c5114c5aa3dfddc849eb6d5fbc6c33474085b3ef97feeb859e85f9a1ef92c420ea11aa67803b45a133fc342c7c019e0706adad80ed28afc4fe0249fdbd979b05e2c48037c042b5f8694e82ea9fe0ee3d9e00c5f8488170d98f45bd404e1a57a0c6e2326b2dbe1e115270822b2bd375dece2ff1b9991845f069862fb957f7ac64a0c0990439b9ba830e6357833e71a9488268b60dd40aa43e8bafa0d5a70b1eb8d40f7eb04ca984dd7d33c98bfbff3202c1db5af61a0c5cfe1ac42880b4b7e8bdf22d0a73d2eb11dd4c2672e6c948e69ccb4f0c50670ea3f65f76087e3f1f96dba3092b3b1f498803ac899e14d33cbf285caf56bbed276bfb349c25e48beec48a4e34d3aaedff1bf601b2a37867fbbfed205eb38c9d9a5e643d4875bc5315fe521039074a5c41a585e6f33c1e9621f99a56e0830bdc08f844965650adec46ff476445de5baf955600c047b7071bd586f8e254e60601958b9a2bc0dc0c885c0b15190d9a7e3a4de74fac4c7674593750893f88030103489103449f0105bd5a1b1c5b0c6d84d77fedd5029aee932a7ae6dfe6c0ea1fa7be73192b7e3b2dd93a534946298d0fd1cf1b57070b1aed938d785b5df489c41fd4953de2e02eb9da0890ad30bf65f43bda67d13fafd5d8a7ad2b6e9aded1939010a9937c4c6bdafc07d3a62b136dfcb39c895df3b6e96729dd0ddbc6459a89244e8be5871b24b7c34de82025e87ffacc510a94dca0e593e736338b7f23019c5927d3c050d8f140bd0a6ef92b5ec2e3a494b3c2af75796847050ec6270343a65d85f7e417d766cf68e8b41a554d60cd1ac25bb89d6fe4f5709bc648360753e4ac05ea2a65d69b9e3fd632104fa8ca32edd2f1214b9d6fcc10e7b105969f92d5924f3522d05c9fa7168d8927e82b6df669683d339284761c47403240a6481f5d0c72db4a0f28d36743d908782908e71af7fbd557414a322289bb75b3537e56f84efc6e4cd4a20724595a3fa5d73173545c69c9c38de643012add7a4234e961e692caa3d90709ebee783f6b02e745042d3df8dffa993bfbbccdd7470bfa492b7d31c7255c4b88f7113c69a11966e7ddb90c11f09ff088ecbedb53d38e897d6a81f0fe6a6798e0ee22469ac56824cd752c777e9fe5241c3ccf4ead3b48b7f3bc26f9b69c5e999aec60ef456245a89196cdac4512741c836ad253812cb7bf0de7f095cfc6a09fbffe875a099e8c73feaa55e861ab53c993314bd899135a70a44454998a978856200fecf6a8c455481172e817b4ea1d351ec55de95ee9a134b0a40cf2f0d20c3081c004078b58a382799f90b865915b84b8bd4a8ef09241d09b139aedfa6b95b492699735454f3e1b03df9cb9b4816b287a0e6a4935c7e8c65b8eb4efaea9b38cbac02afa70924b62a398302dcc179514cedbf349284df4148b49725a8f998174d95d98823a1be36df1e5eb69fc85bc4e902496bab996194e79932300298ddb6a63fd4316b8e56263ad5ce7037b4d5b05f00659bc59f9ff4339600077902d7f9c827d898d9b24d3f83d0498865e9b17a4de7e34384085ecd461f7f24c2e9cf082c1e451869b5bee341b9a09e9b324068f252446831b6343542315d3e9fe51dd26e4a737a58721d73946684aa85d3ce7fb469b6c8c3eaecfe4abd3dd6c23a932b445dd452d3988cb146031457631fc79bde23a154215d884b56437133afc2ad16156109b243b0b9abb7805fd3fc08a6885eddfa3487a18d50d70887158bbd1fd545121d718a047515e774a605e74a142fc487071396f07c93aec031244c2a7b7acba7c53410fd651382763528ceeca599fc9dfb262dba8447ac226cc56a02fc0405ff01c9d330340c9f1b9e00cc0bfe2b9199e1195512a145198156dcdeda5daecd937fc12d9166f449be14737ae4c02d2f076af31a7f108e5b866908ea084c945e23362b40fd642fde48064851e2f5bfccc510ea22248e72b9b506bf7641f7837af582bc2abd07faa28287886c68073c6b832b8509471be76af5ea80de16b1b69ddff08234d4b3a810fa6f9bada285bb5710f7be41ad9a16537c6dc10a5cf61d4dfa0b5023e8c9100552f57c8aea3ca8cf43b04c16652191f27133ee9d0f332c0549352a9866683b2818a52395ff58836ccc25532a51392a7eefbb610d1618548130e1bfa071b033df7c84a0c0b22282275ea89f4e77d641acecbf5620f3df1cb34ac8a8566792b288d0ac98e133105250f3cc3d34a66aae35905d59cec69e6f463d417e84f491dd5c5e52fbd2c4edcde5f8c649d5a183f3cdcbef34070d83958510ba3077a994dfbe20f78894f7cfb7b0469e03fbf6dc3550ba1360265fb1c6c49ac41896d2ab557e5e09c39d463a72eb1e1b84af61073f7fe330f54e950570852c5a859465ff38160e70fba4c4e34492aeb3d4d3fd3d26bb13c80ebd106794e035c4de2b3aeda5fc121867675111d9a1cf265b86884793760a6ad2bab32d254e33990588b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
