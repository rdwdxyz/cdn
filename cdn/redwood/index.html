<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"05b53e7c42f8c3320141390ec32869996e095b1a7444b1ecccf2104353f271826065c8bcbb3cc90c1e23574d23a71407b73b9218f66d8e9145939919e93e2cdf7074354990f47acd26f9c59ca3d9e58bee6cf0cc47d7d677cee1104359fca935d28814c18fbf0f65dffcc15f24b318f8c46885e3e5421c72516047b9c90a1a560b899a56f0b08f7e9728204805e542e6f103e2795c168187327afea3d363d516b8c7d167b0091c93e1786ef8a3c180367bbad9c6486e7f40ab5b821004980cdbcd370751ecd77e6205aed16eecf2bcfb9184d93ec5d8a3db75ea0a1035cd72d604a2fdd99de2382abe4d620a5b2ad59af28ff1b79eb814613453e86f76545f1138d4193aff1059733a8b0726269edc37b4c49b8af61104f50069f1e13ccf02b1990022acdcc4710387d27fdc05542ff4480e98947c939e009abf714251738577a06926709e2ed88c2510ceef0c835b72c1be7a6ecf6f78b6c1787832d6abc422876160194f35f823dd59a23ed2dd1164da4e85c3a0ea4d98ffc5831a13910478157c5732540dca8fd4f3de7da17232d2bdd39aa5a3c5888e1bd623c2a1f37b494a943cb065c74edf7800fa22f600cfe3eaa571a70851f46ac981719b36a4786cd657bbe575681b730507f0f048906d980383d803ae8a0b6932457bbad972dfeeff5e10ab69d57847dd119a518f803b58b5e4ce0f13099297d0f7bc0b54b929a7188a0f1f00948ce29debe77513870f84f96ed17081bd691a41ea4874179c48fa614837c2379edac31b03b2384aa0571b5fc1d0aec5ffc3466cb58ba030575c01c1356fb79473b0f8f71355f5aa8913d1f8cb1ba719f0f6897e948dc32fb2229668111702916903a0325ad9a2783041e5108269b6b6867b9fa5932d86abd6361ee489c5928751afdcf70890877d047d569949756fe23bc264e73bb3ef42a6163ff6c17c8489e46d6fb2927fc4b94a314211706af37effdd3b2b39078f79878b6cc13b30d06b2e2807a169869ed5d9f4d4e05c15a5f55705a05e685d9aeedb26f523689cadcab779c403886430f9095a1f12fee603544db576a1cead9d829273289bfd8822338662e433fffa32ecba3a55589b3d13a985c2d849125cc080bfaeefa12c6ae50ebac54e021caa6f6abb82b76ab74e12313d2d7e0b4982cc2d16daebf5924b21cc896564014208b8aeacfcef64ab4d1843718e4ee64c359e6fad6cc2a5e1d89a6a2ab8a37129744d2684cf752174e2ef77fbb78751116cbd995302e2c77ba42a9ddb0c91058c6400218509fd46cbdc71ddf19f265978dc70d910ee9459311150e8b5626cb1144d8016a2bf4cb7e642767b9661e8cc97d2f26722eab22479f75749a4180ba4e63497250401f5d6d02af69057be234807fbeaf2bc0712017f351bad7d69909232f41cf3a51688ab8c0db9d3fb3dc41d35dbe15bd8df7dcaecd3534eecdad972354d22b1d503b266192d12e019d93136275049bf31245c1ab456238a513e52dc5c35647845b59b23168f86594d131787b8dc8ccdaa1da0cfca6146e4ac2d7a6dbd427c0a983b497bc4065c4c9920dde15690e2c7a635647e96608616fced9be497f98c2929569bc2a04d0dcae047121f54fccd16b9710b00563e95679f92019b280b0fd6333af60041f21f99e96a1516979f4cb579bf95062dd44def85c268a137b4792f7ac96a22beef349bd6d39a86bce5b8bf07833536c9c7edf0322a20d1e1934cb76c1bd5fbb8b6d373042e447e63ff54b6145b9a436be7b5fd09140ae0473fd33927834c4ced597b74399ac05dfbc250b84a126957223578a13688678be81915263cb14fefbd9c5d0405a9e0b100d5f7991af3fede6321da123a3cb89c4e0bc7a1f58fe315081aee22e87c0328c41b4e25bd09422099228ba5b1c5398298a280f18486b6936711f784600e679be61f5a1888c37447169a5b20a323bc941fe9c1192479b3a82fd581d160a28aa0ed027ff7745ef21683f33d7506811a3663690f7f03128cc7292ca7ea68c82c9f851852636e890dda8f88b55bbb8b5be606ac7bb93272fbe6aabf535a375093936cb49fd6904967c14bf18f9e10c988fb622974450c3681098a6064986b1b3a4a4feed177ef9cbcf30d16afeb6d82e9fe716f14447f8c4ef7bdb4dee49d42fcf45129e63302595fb722cc6e2aed9a0480825b74d15b9218c6e2607f210f616aa7aacd26fac985828b6ef52cbb0fa87eff50c5fba16620b36c2e838edbe83c884bacc2af91daf82d2181966edf92e01e21e2dd2c1fb6e2861932a7c6fef8376737d8a7ff39523f8d1094d0bdf9ec2f274821ae1ba6141f227a3c22186bfc79a36d630c6935a7e2885c2a10fefc27698a1f1da131202ae1ac3920bf12a397272c13ff22a305d4ecc0a46480d491cca338dc64bb8bcb8032d6ff8e626d6aaf76d4df058aa7e990342af12ead2cb4a1e52557253465928d5f8bf4bce0bb5fc4601d18b1ae2b2418f2e61487ecf3b1c134649fb091823a5e978d51fc5c414c72b1062c3e5ab4c88b1cf92c2c5b7439c340c84809bda3b5ace88a254368281ee74b94c800540a37ac5218d13aebefe707f1d4949c2b61ece905c6f36657428cf719d488999ba3011188f77fbeadf5a5c5d028f25f21f172d23f9240d457e91caafdea16b095dd789b7eb26ea1998624756ce84a0b12bd16248ada1ad50d104dce5530fbe7c6d85592a85ebd94dfb132008e67c68349d18b036fbd918f5637d0facfcf360b2a648b407883af145fc10026081e12168f82a9c9e738c7076afc6e006ed262d4e3588d3012b6b6fe0627c44cb21bbccb36215a206829d00f2ada420afdd20306b24f2d9ed457cbf14e1eb04ec6a44afbb0ac8df99a4dccb7e5c52684aa74ca1bd4fee1b17dd0e21217433b71a8a3b2dcd157b6bb5645eea338a68a6c7d8aca95cf782de8271212bcd9a90b6b46ea73b7cbd80886785d901e4880677addbdc79d2d258db5e0b342fdf130c0a5bedb1343392c86182a6eb648f61ae9ba08d5beb97f681dc6a6fb4fdea5ea01e7a357f79e4a71328533461debbff11238de601900376369995fa7eae98058457a978363823b1d6dd35ee8c25916d6d89399731513e9bfed69b34e583a6c27cf55bc4ad98478b639b56fb536f6a69a54888d680a322f666fe645b3acbdc9f3ee9e038dd40578a3c13b0994bc26e6b65b1da79026a16a692270cfad0e581a04ed9a4c8deaabf97a789e2808696d2c928e8a4016b43777ca588fd180b6c090ac80358a2c40e7b3f3a5edd4865a7dc11a92f75ddd13cdf9881abc14114475d8247666e1f02aa64c38b73971793f1175e609c1dd143fb9f3cb4434459cfdb19e47cd59cfe23a3a2fc133f1b48ff0ca797079b9b735e2ab950a5464b7f8ac3698ece6f6e79ceeba57f28e580b960dc93a1a7f50dde2c5689e3174d9c31eb095e831082273bc69cdcb9cf2321415f6a018aa08219c5b1bafdf7774ab3596478d24a990de3d5a4af58ee4b29de56c72e1a39041e5b2e4d41dd53b4eef6ad0d3ba081c7c397363c063800d4f26e28810f60d36e035591bd828a73301c7f916e2a8253ef0df6d7050aab7d3e9f7a9a4944e418b96b43c67581a49a8bd0294a398c3644e683e10bf870976ffa570ff3cc44645d7598d7c97882b38bdf3a24f454f58d461b16305ce5f2797a9c4ffd59f79cb2c70a2aa5f96b88eee354a1a3312d0efd916c55eb24d71dd4428364077dcd240c292aeba6a591be34764ea478a6be73c600b3d8c5f2732d001e67a29dad3506468fe2d4f86b976b23996e4692079cdedb2a53a8e85922ace631c1b0fc539934604be9d94ab5070b8b6d8700a43ff8bb1198b23032ce94a193873d5f614dcf60f81f32035a46146b15f13931f6c890c7f299f7244e1762fb2db389981c32f9339ad803d5dead99893391144b47e83d4d7c28fcbc3ea4116d45d21f23dc28189968f83740e04cc4c13ab483fed8e9d607e1f2b24395ac77197397edc871d0521e905fd55599b33c2c4ac07f0aaa3b5b451decf6ca9da7201c7008050d8f5c9241d49d31ff18eaaa7b1dbf725989efdbac8546d89d2ae7ea8de28b5e85f3dbaa467952f851ebea74bd0abc5cedcae55659e82272eafeaaecf59cbd79c17434687ed62b9a80510276f00fbafcf82c3f75003b8a74786272ebd15e09433bedf5ce17a4ccdae494afedafb7191653471ef97abda6aa8c4adf662c789943573cb3416a584509d206f1aebef9caf471ebd95eb701799b2e4353530737bfc414bbf4f07949c64b5df0d9fcee7578ea387c778209ae70031fcfbb4fbde25ed6e6dc5ca623a923b1ff69d312680695c6ce39155dc4e75f6146c4ad75a92c894c84b0f8d1035129a31acc7a934759b5639b49a71dd47b22f9ebb99d219b0216a42739cddc1b81c117f54ef810c1215e9badafc487368f3504c11286fd059e51dee770a03f75a7d6481bf2dd2c0c7032dd7dd2139b4ed1c1220694b79ce743bc2caab1760ea03b0faa2a8ab64943c05b0d65cd97ddf42b685bba697598c5b8ab7b2f5a54cd78a94f7b4ed849480caa2998683d6b9dbd6a892b736635ede6d9374a600c164bf41fa8db113f1b7db7f4157fecb4c54589e6908308d5ad39117f2e1a008d3eb435b81ccc6351a0bb9e4316ae43952ec78f608b7593ef62706fd5562f3c90bf05a2145d89cd685ef563295cf60c41eb2ec3524102272ce92b2e2527274177015d4b48853022a527c96d39bc31c1bab5593914a58bf2e85e61f70b844d13ce581db8b43ac3f397073ad3f8f2e0aeb55c27a6cb68aeadb371027c0af460e3e498ef3ce755fa0be391bed5e70feb20ced27d2bee50af5739ef0855684cbf63267b375d8eb1d410b986a88dcce6082052fa5b1de5d4e5de76b65ee7dbb489f853a3c82c720df6010f0fa19c7822b84a8a9a63f832d7d0de73a85c060a84b0d0154fe7ab86ad248370e27e21974f397a8ab88ce68e999fe1046c588e65f46bd64583a6f4c46d0c26e38cbe0680645306a01a554df7ad845510c63d1d9e7646a6bc44c9b09742e9bb3d8d037f01953bf48c7250345bd3150000305cd60424ac4528a5cbced84617711fd1f71ad92d3003d62c59abd68842de1c74b06197c4c4cce59348efa4511337c8ed00b30138a2ca875343fae1f05a6a8f7f8e8505bc03374f6ada90d38349eb42b49080eac7e58fcacec2df08d7c930fc673f5d2470fae6761ca9a0ff4e60f045084ee55e94059f60d7b50522217dfcae2e4afdd80f24cdd7000ba8e9d53573526d9b11aade3baff17e49baa9b2f41a1bb03f0ff32cc73a9446759c7aca040a2a2fb68ebe09a330917230efa049627e073d51a2e4a503ee3c012206fc01cf6adc6df6ca551b5e596d2794018b26abd07d8ea2888e7dc416c8b9f8351418ec4b8f5ff4161b8a02c4f607457fd7daf6a2c34119e70769894803269f1d7ceb558170d9962b464fd156e08aab686e279a20bff3d709c4fef9e0e302d1026503d1e5868dd3e113d4c6e2f454ab9bc7d1cf24f57998f842821717e607e6701b356a6ea9ba3a178a7d65a28e38370521f61bfb68511d4c0b95ca6340e9cafbece17a766e26913819f2fce993ead0297a2cdfcfb7c36a1c5f40845297889ed8d0908791db66d3a6c13c7fab1fceeac654e6492b425ca656eb98b5784ef84d264ccde197ea955a962323ff80823959119b5155c9be2cbb57cecca2ec4b1a473efc724a8b2c14ef0407469987e5fd8f1b6cd1db9bde30d1dae24c8b8e9f4fb32118135a90a2f49abbe15877cb2c7260e47591da45d98a4483fba700d2530f7f4160e6da506b73b6a44ced0a9bce6ec1c22c73c367035dd40f19675b338677f57f48da41f894486e92c6fbc544b71a6e4f47464a3b82219e5e8edaa56f4cc4dcb8a4e1a21bf0fa9db9a0df156fd4091781f61c994a9a15668e0b02d258e4ce773d4b3ef8cc5a0715be3aefcff7beb90fc2c57fa2d8ff82b800da5c5f36c5e69ed7e766c8b368ab04bfe32a4d22a8fa684f714e00190aab843b4bb1d31d1bcef2dc5430d819571eacc4b10cd0b0aed7c1b62ef0720cf97fec707bedc247801e9111c064c9f08513e034fc20febff84e8c23b417b64e1cd8bb8dc347e9d015060480dac0d645f9dbaf46232033a22852d678a3319c48e4f0e69a71fa108bd7e99e08b0638f2880e3a458ac1ae3e4f690fb8688aefbc58d39305e8b2c9e2bdea9112ca0135552030095b34712697158d0fb5c38456b2b25348169694188437919e0b48b73b4665cc7cd20ee3a496e193901bf1594a3e2f5e8340140c31f7150988556a62e0ee4ed4ca2e1bfed0f75c187a6fcad6514e479cdd3eb19f41711fc53b4631afdd5305e2c6f0bed1a89ca8e7842b4f38680c58594a2293744112158a6710dca4b8bfb4ef13803315b70c9f3e0bb553b001ed4de6b0c5939e3ec48d44514dd553cd7c8c2e99796bb01be7ac628f74f40679ab670b57d000109867bfe52ca171efdd4361cd817f63b055375c8be0eb9b4f958f5aa932f848bf52fafd1e4d7a297bc9be19c17a782b151699464e25d2e75113ca866f72d3e341ee5b81ae7bc026afe7db57bc3c3c56f5d60b21aea44db0186848bb3b1ed693b87003b20cd1117f87c2a0e89834d6d7f2e13c8044081b987fd5f7ce1c477dc137ad93f26ae8ee100bdb8a328e4879cb83fbaa5c159f247ca8036fca5260aae17f3207333b3e1c5f61ea556b0824b7607318bca09614bbc06e0bd60746be1a4b69f0c92d8fa8b7f864348a1716533ee495da82480a42679f7ea1db69386f6eda4178f0fb10266f0946fc880d7940f88b5e29ad24176e39850b23c2962e2dc8b4ff42231ff4698f7c782deb60e33787dc181029e3c4182b3a0a6d67e2f6b709a5f47e7679357e96f41038b95c7e04635660b52f5ae9a6e93a39b4c52815ed6cc295f26b014567749d74922da4bcd3c04d2393814172b8b2eb4d1d99f08f625d012f9a22b9a4613468444e013779d07e1999a92a8b3a0dae1b736c2769f784a236ea406e0221c6b9470deeb911bbb2a484b0ee0f13897b71cdfed08cb5dec0d546504b691447d345590634d621935aa39fbb42001a666734d532612ecf72474cd2b7c62dd78002dfb0a17003338f4ee237e70cbe898d17133ceac5600948b26aecbd0358ced1d0c1e8ca619e036113c615fd2c0ee75355c5b8f1fbaeafe219635b7fe0b98986855e858ba72e13dc2bd76143290dd7bfa28f24a20cc4befc0e067b634ab78684b0eb3c5f705f40368dc09c4a322fadfa86d7bb94e67d492cb3f7859cd6f1b7db5271fa29c0137bf59fb513c0fb8d3c131e42b113a56f3e21ee81bb1d2202ae57819a019d39030bae8769e803c21c6afb4eaee2c9b3ebf73f35ca974cfcf9324de2ea6ada6841dfaf5fda1dd2da6a4eeb6b918957e1e9f1547e6439271591ccec0603e2e079a7b127f2155313d8943cd89b00ab97b77341e3e316cf0d6647569a4d60f22f900b350c1fa643ec5dc929675c0e74046f51b06bac0e3043a4138b681cec24a9c5e9ccc5442567c84ef3cf42c9733538c86e2de767ec7923d9e1bb2c907b96f814b1801d63cce023f6fc98625cd7b7721be92b39152d13eae736da1fb57b49a155c10a4d7efc23dcf8472b360822975d74810953424fb69fb83132088729160e91db7ffed6d96aeefc97b5856cab8969509390a63073c91e256ccab8386a260692f15b2b7e7c6c48d3cc161b738c844fc285f125dc17661198dc78acc8e32af2b2c08de793acba2f6e7728c9004ae4f835d03bfb09ae27a0a79b92ff9f6757b9a4ce013ff0bb3513bb8238be72217c6e6c60e032d783babe74ade9b71fd458f237b97878cfffcb3ed28695f51b4ea591f0f116a21d2105ba320e6266a06758eb0ce72e6ecf899b8d92ef0f7965040de999b3e5dc2569b49f70cd253e2b060ca4d60eedc5f004c31d19fb8d58d6ae89475df4907713ecfee5a22b9df78d16895381e583eb7e900cb6ef463ca3282dcc05a73e6fceb257ea7b7e7ab4c0fb94f4e09ca738f806f5573478b5ab7e5a7f853597d88865b85f3bf6c60f8fdaa0ed0095d2aee862ff4c905e007a3f35375dd86290661ad704cde18a621ecb1e0f17d59f275940a452ff36c32e008e42cb91c1ecb93034af3f3b86d5447d0599f46223f896753b0d97f32d72fa84a314a2f3ca0885e4519aef0128b33ee41b12c99fb0f6db4b9462720222a27064823ff66dc7f1986c28a162d5adf80d9579fc4d5b0199f0839bdada28c0dac7d92369f80b13ed8c643680822daae150569f5e261d9d70b72389681df485e92da292131afabb01992936751b306aed13d965ca7471c0e7ad675085565b807ebad41563441ff2d725872552b3d21755386937fca3bf7b28a9bf03b8b7d99ac0d0a851714684f8cd63fddffa560a4d1304b7cdef81c5e71fd9681113c2825fe5e006044ba90289ac7c082c9bdf76a17a842e10268e3e329c7b3f521dfb4318747bc772d157a8525425f4736d3bc94e748da691dc9dd1d4e064ca4968c05f625d1e7936e99d8b3c7d55089c9338f386422ff64a4373ea2120d23300e1bef1fe73fa996cba763acd24aaba0ffeec51f9b13b2dd6182185b71e4f66a1d191c01d0012129fa28ba976c56ccfb96c5a24f76a344418f14f0875b26abeca9af2f3f6a0a112f586b680822cb79d3a3a73a9ea6d8ff6a47e488c92e682a4a311543b02e1c7224c7f2a323ccb360a69c92f03e6e0b04df17b787e31000e29441bf32c97bf51cf6c7539800dcf19bc73c5d92d3c4ff75c2bc5eb1b25db7a4604b52b0d4c15f2b1a617cf22565d80bd7cff817966df617461aaf88676da87c789ac8680d5dfb043ad41a3347145360c84ce963d0aa44a83928f6ba7d286fd73a0d0f8a282e5716346ee592258577377400a13bb1590591ce88887940aafd91b7f7232bf8ba50473cc96860fb7dc458a2d9d8bcac470d4981495aa888b3aac658d1c0cb9dc34837c6e68fd100cd580226c2d08a68f797ff46e6c198e884e1698b2b1724785ca8dc5f8ad7625aec8da8d6aba07acc815dddb8609930ba354f867300b4edd9cd9653895f31c9f32527b251cc59d2000631ffa3920237c0efa633038eed5094222b5ebc15171e917c3d95acaaeef85d54ce145d0175d2ca3d0e1e245fe50982c6ab1aa30ddff3e255e46f7c14e7ec9bb439e1d894ae94229814881f0f6925f00ced7fa3fe0bdf5669a9c297c2dbc39fc4b25fc0cb333a1d3a854b09c43e6287af0061ce564c694bc8d5329720fe8170ed5b3883daa6232fcb5e025960c7f69c63d69cb535e3a2c3d3b5c5669dc8d4f13e07cc4c6d60494ebbbc16e4bea96fc08f361e80cd8fcf473c289f222db12a46d30f17c45e9415e7de45a9a35369db5a52f66eed7d40697a21fc2aeac4218a7600cec11290ae3bfe960319162faabc939b572f148104de0548b829a77f66aafa8d31632f5f05ce9c97185663acf3b9604dbfc9b431fabefe16c2f3bcf642818061fd0ce493748cc1607ad2e3ed1cd73645f165c7f8b0329d9e1d3327121c070869f52f7d6795c097374845704a048c3d959cdc054e4d7690012df8d254e1b139b5f6c49d38fa55af13ad4db6309d03e006b58e32019a606136a0b7724f2d69c0493bb0255f5ef8c6c8482466dbd2990e650a2b9f475ae2e8fffe0904be32f74e3e676b908179ade596253f3c50a5348becd767a1e206f69c991d69b13f8ce4cc8c2cd2e8ff94c2daec979c499586e49ec8d0c3082decc322e1270643c9c136aedf27b2201e254111525f099864f771097e1b3d5973c351a6bc2640efc9400482479a367d5c95c2ec077a04df8d40d74349beb19bec27526d2f0eb534c53a97c936870efed21d2385bc9e8aea53379ebbd93feb5f1ea56bdf6b9be480abf4ee35b00d0ab13468a54244595e901a7bcd6185a9cdbbc0269e3b750f2d713d1988daed361eb7f8e98de76e9c69bcb625553e445635c4dce27d54cb433ec7422a9ecbaca7bef4a35dd4f7b70bc7dbc842919dec89ec67a1106d7ac809f2573d300cd6b8737dbe121fec41ec4ce6d1063559b5a08f07b92249fe0b49098049090eea663c44e0f9d891a2b9e30981898c1ed19ff2eae66d875f8fd9c540aee75422dd5cb8046789696b268f8c646b8c55b05f3553a2256c34ec10294e0801f68b8f46b3c271af99661a19dba638187d77c4d63153de25f8d0361d219e4c114dc8d57afaaba90358f085f12d8a04a3da715c7986bf13bc1b1d5e233aecc739df3410db9e7763292300dd941ec3ef62c92d41b0dafad820777fcb42ce800ef8963e23a3e1cf905f90bbf97444f0c31906fbe98207c85dbb24169f8abfa933d1293c34928daa922ad005310ddd1b5b47385ad6d48e51d1a5408f90db02b6665eb2092773c9f8d6d2658fa5b55ce694b70426de0a9f3b681bb2f31435c95f1b7e62a3607b7c45834cc18ca7fa7efe31427d3e9d3f17c60ed1e0868c0361216b5a35282e74d8f968797ac5e6092be34215a5a2151e84d266c458d8e19d934cba91ba2ce5f5c066d0c35b4c10f208dccf483b25fd8d42b1de24388794641de443967a1a1595907a555004fb436e26186d522501923f6537bc5a2aeb5add44f0a2c459a5bb836edcb09f717159acb53bbae57db0052927b8078cb361e2bda50d11ef73d73692cb12602e0b72799b42fcfeb83c7ac408f2c3980b52ddf119f880f2068a4a5fbeafbff304bcd27c2712e63f8863c5a4c2c3833f6ebf0999f475996d150ebb450f4e7665dd9a4b8f04d587a884bda9eafe38d2bd98a02e68e15cd69a76eaba6c5777cd86d61173495456985e0a6dca69e1018312f572a3f630d9ebbde96b8b5db51894af817bc8de1aeb3b9cf27604df85863a9ac56e1c1a940b6ac8f4b223e08531c673f49e47bea8de169c84f188b329c1e519caf87dc0868575d4ee47b475f820b1f399de99659c52637c2caa56a3e8e8b0c433f7bf01bd439cac0360fe6365166ea303961ff3811340a24c6a994b03c47bf164f8cce4180e5e3e12363327b93926468d4e23405ee22f34ba9628cedf4e580b3d7f81d2eab147cacc6e3cc8102b2fab5a1926befe3bba4484f70e99e6b3d1994f00214e5b7196a550e842022f931beb1bc2cd87a8e4408a786941b28064e8808b5273f48dc735da4522cff11bff4f0c605a2104d94b7e6d12aefe846ea5e87ca0e7874290e156ccf187e9eb3999392db9599132d24b8fb12ff78fd0ee4761c106d309798ab77cf3298531d7d79d073bc680e77db96df916c4d50c047f880b3958970e821344026e14c59e9dac3cd4a169962b29438b7d5d398e0b27a094b2f4fec852cc7fc9af9ec219b39f77404d386b6cab103ebcab4a9b5f7390ec2d269001011d98943ddaac90464a3ad5fb4289f6602a5b787d28196de3e9cc44da2ef96ada0af5f199563c4a94a12e55744390d0de1654c4e7039861641bd5ab2386ff8b8f4d6521d5d8e14e63dd67b99a59a948449d2e172aec7302a6f08df6e48b64de1ec2b5a6e629f9bd8c15007484371aaba3dd50a7d0882382f2068450bf6abfb08e282efb96204755b5ea1c5dca97dbff11fd1ce4075d5c9836970eb70a7fcb22245d1a53f8a55964fda2fef370e22809f265d6d84296b9cf1c061016aafeea571b5e4cc428ee710d6a77fce56a3acadbdd6e7d08a3d7f95763fcd2a64f4616bd8e1728cefe1a7e9b9660315db5a0843b7678424443d0b8843d6568418b1547895a8428fc319c05485c263983d729cad283f421d01499db34fecdb1fe69b26dd44c5f36f1d60994209fb880e0caf9322a4e99de17e1c602e803e3a3a67fb739054dd880e8d54b44caa3c8bc4ad63dc4d883217260b9b2ae7521ca5719e3fd93564531a6a822988cb215b142a01a6843eeeeaa26ecc9aea9483cf6f4e0edcbce15af9b7b61be38516ed25ff4d10e81dc194f0b00d8afcc63983e52b1b7efb788d66132611acf9a82354ce17ca5708d5dadf678569af9ffe88cb640735813954f9d996b534361c9acef54ba3cb3be997d9b5802ec2b4d219a40e2a488261db39e844ece8ae0f7a807e573b7d9350960cfde576dba7449fb009c0a381861cd590ec176ec1f69299f1723f3789649b386e0eaa7c9b8537dc917725efab45d0155adbef9982b563d517b691f90350c70739e86cee43493bb5a0ac6326acea786d16281a7cdf60efb7d70eb2ca8e5343c79f7869417c4c32b184ed4825d54f2a784042776513290984a7a0c62c06f58cefcb887c0409d2a7173f4b3bdaaa9388540a0140a926e17aa12b19919181cd439a5f84ce86098656211d3d90689bab30d3e8362650f07b2be4581dba3c2a1639cb22e86c536f32197bf6942b2202afb84754973ab1396f0e065f0b5f9be43d7e9caf77f6c47c71b43606689e0d9b241e701990e385c515fb95265f74013b3ec6fc466834485a486ca57eb99498510d247f22ed84c56255761e613b278d11750cbe2da5a5f924af7758540ee6cd464765f3758288364e2f597c60940cde700ca8549bc53ae4e5b3ea5203cdbc323d04fd516a23f5a30ca95c25870611443c7a70f22f7b3b782cbb592c91bf511cecab784c531fe6ab019d11f4138a006c6b8b51086d068c5f84ad2293b82751e2f88b2b77425fd74db5c5e360b5175993bf8d0462c7409bd43c58b9c45623b5f5645c5c2ec775e8e11d4205c5efa3798685590d914079be00eca510dbce1b1495c18f57c01055bb9edda9063ffa59b99c968da0176c1de85e91a1d84889361e52712c9b19e9c6be9b67b1731e6aefce52d2941c53fefeb3a602c9d86a0fe8448ee0d92d35d4d5ce5a66e94365c7ff45be38cf1737d8aee08bbeada06b87f2a9f5984ce4d6c95a28c59c927f709bbdfca1df202c1089e796d90bcadad1a3a5f07d4ef82660ae479ea9da8d61f96d6cb4a5c1d7f213f4696a24ab279526815e3e7f6bb55dc667c0d798903aa2cafd90abb11e520b3979321a637ad7f38ebf6503329737227acc40492c36e4aab2f0872c9ba91a58836d028f4d36e1cdabab920ed3c6d7d999a58e0688ccbbb217e1973d541aed9bb9fe2e9ea17344b2196e869a5d82da4ec093f5b6bbb23804d4506c7bc43b213d810ea91cfde51216f49cd4747dfe44ba7116170f0e9a65a30db387169b3b4518eda77bc1a10f30501a03a5c6cdd030800c8caf0a18818694daff8710b88f22d3a10faddcd3c5274e0c67cec90f3d4e1d46fec8a55ceeaca1b620511952b16cdfd2604812b4cf4121e143e58a3dd23182c3abd518e11d01b2c0d281aced4e169af13530c94492e11ae74a69404c8e6a2f843b53ad3a5332db1b7e77bbe2969e813eb9452378dece392adcd21bf1d4fdedbfe7b9e8721549e42d1a386dc4fe8dfb95b11617e69c95a6ad96889580b8d88b2176623fc50fd8d067761163ab186d4c9c56b4cbc7bb65da73abbf8ce1b8682196334c8b1fe6102244b088efd65b2b40f48a682c26097dce6a52cdf89d39f93dca4a39dc6bdf5cddfb5dbaca74dbca0b9049cb6e65a87b13d3171aba2cdae4af90bbbc11951f82079a2c582efabd0e394f98b65d6b7cff7454fdd1d8c14f2b342d2c4537cb834044f492b3f60a419cd73fe2ade68769097b32e7bd5f2f9e7e51d8f7a53edd38c542b4237a56c66b348bdf143e09c8cff9adc23ffbe33c4231cc699885e2b8f39d8de6dec9570eba9681c7d4e21b880e13849cfe27f6c9190feecab81a8a65ab816b981ce27c3e09a5083cb9d08555557f6b36d7b9b43a192bf44ab50e2051a072a7fdf9c8a501c280e49e8c7980df425625a4c869cc89cdc549cef07bee34438b95e743a6d43367af8c500e559e9dfbea82de9f7ae1b7213a868317467cdcd00800dde2861a28e9e092c829176442eb314d90c175b26f953385a1b02acfbfcb36f9f600d252df3b0558775a37032396fff411e1fa880c14f2bb417d4b6939bca77e497782ce3743a7a2627fb45097660231d72adf2b9bf72f0c6851c9e6b71fccd364e05fb8061e8d9fed561960b2a7cb4d97d517b032e7495249a86768f7486be544e137210ae71a09b3b678934abb2c5c257a11d87c65e86c394a9ebec9723a76f421c9ac8397f05704d785f9d2b926a97a326b6067ea7b4e08bcd04f0656614920631b2231b5d29161d8c17cce8736dff70758ea39c053275a212733f30c3751032c721b3f3a077d222044554ffa213140f8a36fe2d4064308842ba07eb25b4520d0ec84da9f86a21d853df8e841979f6e8479a7b22820acf79b255ad68ae5532b2542fb7b43beef0424565f12d2d57170643f5e631fa97c04ff3ecf23966dd78af197aa0b4ce00bcbdb96d76989d9509c7021673f21bc1bde8f95eee6dbc9beaa20544135e940cd1ceab4d98506fd0f104ba5a515fd1e8f6b107333fdbc5a87d4d6f8bd4786bf0760817c3db01686348c08126ddab2f6026f00204789c1767a00de9cef3a15b7ba7ceb1773f2942100ae12edcf4bb004b6b6319b9e914401246ba2b758e3d1499808edd577a970787c28949185b61ea1e365969725d2d5dec1e3488ba84b359b5116303e25e2a29baf0ca32359c10782c6f12f1ddab817c992b0707c656db43a4aee348028871351e51b604608f220db8603dc9271b3472a6fc3dd14268f33a0e9f05755f102336443d20d7c755afb6c345694d6af97b3c300423faab2ee3c975194a7767ce453d9a8d6042c18c1659febe53f6637e27cd96b7cc900608990c768fb799fee0e9fd39959d2f539aca482f4b8ccbec069d8d584b5372eebac9a57267f27d5c4ce73d52ebdac07c53fa3a8d359615ffa0ff3a029f38e3d3bf07c054cf71cf89fb292e365b4aa6a655b466efce3fe21a1596d0f5b604ab20b59b61f28661ba52320b32bf5a206cc58fe245ed0e820ab742e7133ae6f5114c996f8d597fcec1e641a15069ca1fd60fddd428c40fac1a6f9eafb2cc87fb5f16039bf1e745007f46b79295696701b21ab43afede22668abe04aaae49f3b85844a2e8b949dd865233e56df206fcd78a816317f87c86ba195748aed535d32b68aafa9c63e4571b3dc476580c887d182ec06ef51fe1fe592ddbb19d56bd4a8409fe8c40006d32d765efef57da438a9ab9261078bddd0b40515994be937afd99f91a63003ee06536d644dad73ac0430dbbb173a57b9d1e7ea706456a4642ea37cf73d4c00dd3f7b8d9927d6cd682b5663c75af1c27e03a14d347e2c1a230c3d013a274fe170ab6179c2e2f4316e7d528be7d8661b5262d084a51ab6a23c2ebdaa705562ad06237223a14e85ede21148af253ffdda32f77d3647c8aa37f1089d809f1a99041322f87b710726171256b983c8223fd2e46d5acff21c71dcb5dfdd442c8b5d97e4edb84ff5a33a3025af355f867959b0c3ce1cc1ea32c7a86c86923d52edbac0999df0e2f643cc4b111f613fa8dff03f86e576ba7dde361be56970ea046a2878b16188ed8bfe0fdff66fb89e88eaeff85cfe88689cf98094dee25fb84a653d8977d1ed1acd0d1a6a84298852694254863f53a2fde47ee3752109464133fe1bc6bb4ef8d388a943695870739f38dc2157000e364f995d9d640f801121d388f0eb9fe0d4fc80ab7e50f002cb20603318f9c96a0a2e154a76e067c653e6d535ab5ed09984707c5bce090f951c16310dd077c8e82ed0c0779d2cce6f04ff15197785f6b7db51856fafd8f3537245b84bcb3f0d2014bf1e598327427b74adf5a85f5c37fcc74c50e35a06177a81d142a92cca6b7513bc70ab901d8ae358f2ef60385e39d54ac8673c53e614e782ea5dff62701ae620bc8db54cd36b4f68b13254d2f805412830b167751e5638db1fb2b81ce5f193f2b0485cbcc698e30828f567e5341ed5542368d135dbb898e25fc383e1531c6d26936e19220d19f4fb84d2f321933c8f2b80f3c13c6ab1daf99372ce43c43dd271d6edc3cf08a36094fb7eb216a1b8dcfeb8a607944f71b33ac7bf3d355a7e0835070cc9e61aebe114b2f46510958198dd22ae0fd7f60350d457901b703a954ab1fce3b392ed92e188e45481976952782d7a251a5a460ba39dc68737550013e17e305efc42dd0e7f14f1fdde23acdaaa0d1409eb58be79e92374b85c15c082704829060b2d7dc2098db553b0607968e30160625f14f3d3d10a43f3028f17fad5e28334c2cae7063493c27ad93675a61cd44e5d601a3d9e7e8509d3d6b75e4ac2765200c7a28ce639b520692b9fbad7d5c5fad22c63cfd78a16a43125912c21e68c05210f45e28dd99a9927d5fa6d352993440605c4da9d7349d80484a44fb844ff7291c94ae423416827d19029c808a3faca432340b8123c6a1866320e5c7b550c4155573b9678f961c396a8cde4375b8b8fd6616f73c62dc59265ed34de1f089fa8470f315cf574bcec4e6c6f644656d62b4042365e9570ae582eee613dd3c708fdef20a0f83d462df579283062afe1ca31211f44a32734ac87e20c80e73c118967f3410aa34ce59d80f04dcdcad8f43eed8dbb5f7da5fb8c4e5f5325797e50ce24637c4a3ff5fc219632d83f1f1b5df7a64229dfbb7dd2a6189cbab46f2f22cb83e214e6266dc3ce9921dfc73d466f4612908977b97d82488da2c108a0d5080dbeb795b16df0e8c923fa79fb4a54a7e47cfe30a9b855b1c15efd17e70c890184fdb5c272679bc391b8968a2205da7d2b9a22aa5a6bbeeab789ffaccba0f04cd5486148edd9ec240c02c316c7a5dffc164c1ac9e5d2f262f2780ff24a419ae1954d2ff4e53877394ea1791d11f4aa129f3213b4c364ce93b32fd0803a775c4dc60b35dcfe01feb2f28657c200aceb5d4da2f657f7900911b9bef523c11ed74916a4abe0678e0842a16a4ebd2a7eba7a700ba09b72606a7ba5e001e2f7018c9af526b40203f8dd6c31db6d0ff96b310abaf67c2ff34112de7a231cbc0098598bfe378bf7c8f2163508adb9c56b414cf910172ad57404dbb96d6e8cb8f301b3c5bc3b07f2708b344128b613e55ded3271c185f059a8413e7ac251908f95c92aeb1b4e377f28dc23dcd51b880ad166ad972204ba4a1b13bfc11ca15dd20dff1e43f6b89408b019dd2ac156b16f5b0df6f0992463f09a03932064545de770ca4dc9018214e09bfa1ca878b7609e3ea4a68453eb1322f25ffcbcbb3109ec8421f0f34d0035999e8ca553a7d72aec3dcdb09e006d474b59c571488b926a5e3c5ba3252d47fcb56e71d6d5f61b8f45b07bc029e9f3539d6cf025785c0efefd9c44c44de22fa8ea11a6309322463c3f4d875c0e8c58cac38ea2d7d3f9bf25899f51f10aed85e7b2dd1ac52a1dd643a2971f5885c3f314a307f0420d5ad8f7bbd12d54d69befd116fd52f71292f9063162d401d30c8bd8128c9967b560a18a5d1fd1e494c7009ae39e9d391df599803848ca9eb9fd22fc6b8407c1cc55171fe719fb011ea53d4fc04e534c6fa03fdf5e8d93fc34c3b8141fd8a8e3e33cbe91db0ef9f98e204f2cb280a1e10b0564fbca18eae5f449480906863f0fa1cff05548a85f228fd1ffc16d256391b14a9fda3aa382bf14edf5e88f33d12c6d937c60ea630afa0a17a18a96f1ed12d2032a9b4d82005713fd69553d1ebf2ef40156b3fe5b58e6218fa41fe55a8443916985a050058dfd668626f66cfbf6a89d1634622e9237034b68beb40a2e241b51e0985b51a79cff62d28950fc10c0fd41d70fd4160dd1b637b6c34b037c8efa59f90539fdd24c0c4b21ea7992c707d7667f867fefdf73623768572646ae6bda799fa6232f237dbeaec31155a033f59aca97887662663bc96b3e8c9e99daba91f84d80db34e09af9526f9ca84c38da4bd35d4028c6f7d5532ac02e90a6a274b11aab2334b4699f8dc0af33537dd28e466017cb61cdedb0d229601ae42fd6a85273eff407b4bcb991b8dcb99d6bcbe5c7610c2a1cd477bc26a932ae699cb9ee42d9e32414c722262001a09bf75f4243cd0d8b914fd28a7ddc1a91fb2754922802","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
