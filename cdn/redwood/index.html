<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a203a3b8756a7d1aeb540d322e24440e74e447ab1a16573116007bb9be10391e61ba944b5dfdc5fc39e30c0e18a20df0e4381aa2efce9fc87badf5a0b5f5421e3c9bf9eb2835de964316a4f368d230f79006e5526bf97e4ec013264173efdebe1efec2c724b91963b57f46b8e92a4990d2bf87176b735d499660c57e00374fb27297ebc763208bf20ed459d1ea604a9fbd460de385548823f0b819a7967366a51c2c062f7ac5fb5643920c121f8a0b1eab515f451629a5ae7fe72204c8c8ed11b042910302c852ecd68b305e2a15b406f4e8c2cecdc1f5d260cfe62f30d9818ce11fcbc7dca8ed6d16d20d83d8cf525f8158fba241322c70eb8c4006275cf612617f44f4d87b0d2ba878c2bde00258f04f33986558a6d82fb36fa1a32b66c577d25b39a669bae633b99f035364bd623d12008e86d56cc6a7098d4c9e8c98257af7e392221daccbc784711e3bb93cc49c14546d70a5a8d4cc16df44bfb98903527a1ce70aa8fc673fd22d2d0b1c3db160df432e0eb73694e2933b2827ca54965d93fce79dcb3486ac6baeba54c039cc801d16124df7933ff4122fe310a037d05282d8c14b9a72f00d6b1a33619357d6e01dd65edaa9b6ff63b6d0d41da2bda421f11d1a6471502a62cf8ec36960564238bbc247541fc5a76ddcabbedfd5308bc4a3037f66c11ab6fb5478f53933c80ed3d934c9644afb56afd1567a3449c42bd4e2a2753cba680f093f725efcd8d6ca28aa34002af5d435591782858d22f46f9ad7f84e00bc45eeb377c7a8fbe6f64aabdb000c4452cbe8b1d2aec28db4b9e94461ae3876b51f663d2408097a6cc5d6dde11c06f5945259e4044479a3912a11dd317153d14efd3c57841196d889cc0058dbc0f36e31e23d3d3b484a2e54ae2f2f965ac9a8f16635931290199daf8c772997a856f687128c9661c3b26681c95358a121f8d8813b1f12bf721b4c5af1d51d532cb03757138cf7baba5bd1e1b93fb1ac2bff542d19f4477c187497f5600809a224ab9804a856771b090795caa5a87d14df9304a05b2ee95c71eebd2e18f764ee370a42eb1b0ad185fde573648e538fb77405ee88cc10eece4ef017b6ba04cdfa0a3fde97b21c5841bcd20dcd47bf2c7744b3fe1643d782a5e60b62e7ce947f58358efa560b3bc8ddfc907ab949be5436e4677d088f910bda71002b386e61137f408d58ded955b90b9dfc1c8ef19127110f7fbfdcbcf826dec6a232cfd919b3738edae4420b735aeb5f701f08429efb81550992cee21e7f2cd82b60f927bb18384f3d58f7999303443711c61c28b79ea159cf7dff65107d52109cbb3866907be065d1783f6ef0f4be426a50eadfc5c0369aa0d7b41fe0829419e545bd8d5583353175cce885d1f1d84b978f86df75e9be2f0c398a4718156d078d3340d708dea33fa6e5d613f95bbdfe93ac071230ecc94cf66ce61b9810691b5262209584d6adb92c5252c3415fa2f3002b791dc146bbb75f49c821392b840ac040e037e14f7cd49473749709232f910e19b922b7fd17ba807ad631b8b4080d955541e6de3d586bb21cd4f03249a761d0306f6f1d82d373472e9e12f7e2bc2bc580d2efaf33385d6388b54e09bc8fc8f9ce1b475b32261e281c45731a6ce27091ea343414ff2fa8e972637a787c2f239daed34e84a20b6a740aeefbad360c61b4043c5fe36b5b30985c724ffd828a34e1d5972c6a7c1ca9f22ea59c2c691a3d4a8dd478dfd95996790106c231b606ecdb4bff14158dd48a2430634893a29ba50731be845fd0fd332c8e621454bc46afa523eb3bd751313249796eb5d02ee54e7c2d1c0b6fe5ed6d36a04e498d03ffb67ad8b9a6119f28a21369afea18bee303deb089a48ee278ec1731ab351390925e37f33c1bc218f59b269b81aa95dc00c177992bbabe92156cf32963fa46314bf15b3407d128f31fc710bda5b130863922f317698ec1c19e2f5127669750b511e5585bee7f485ff4089e071b0028a901f658d882cb9f1829d0a3b77b133d5f6a027ccd5eb2e4756d5f3470b28723b425b548e27f680a496fa8775f831568ed67a0f0a885f5670d77b78f7292ebcdd74adcafb7d232cb482317789394130d4dfb8c6f5d38df9a91bebeae21d080ebf1c01388bd4f6f7add3426d19a15293527ea3bfc60cebb672ee0b31d327b3fea67282490f4835fdd8b98c2f34a7433237cf83ae3b3c3dc5cc3b9e7a3910cdd659f05af60785294acd1e828a690192e420a466ad2bd4e205957c95fcdd350b701acf3390eeddb99745fed72629258eecd43a8c7016cdfc9c9f42688e6fa5706dac993b39cb47aee15b45f0668974c26139796ac29117c9198ef30a74b5b26e97c246bacbdb97a44715daad276dcfbcd9160cbd6bba3f2d36db0a1e8d7995357b93e0db28c5e2d23e5b857d0e7b085990cde27deee8efa4ae7111914a01da57f6fd2f3333d2ea4cd3f40c6dab94dc0182c4b129c65542ab1e239c289bcd531b9974f67655f9d7f4fb3e38f26e4608fc37ea2d2e3cf96a39206a853fc5651a82d797b24b444058cecfe2c6e2406dd57e1e0a51d54bd973ddc9c18b9fa7a6adcf194f7d5424107bce141f59ec35611dee2ced0ae1e9e8a5c947334fd52b592eac85a4dd2df43e629b20f1047cd0e6eec7631eb56202a974a8e04d1eb40745fe0620789611519ac5981f6f60a6a8c5d718072653c2a9ddecda27a6bc1a638a3f0e7158edcc03245bc0c915f6fe37f907847cade3bb21e1975b79044e803b98ea0738a423fa8c206e3c38c0bcb7d3c014acb158ff70bbb1170574a99c7435d57c6ef1ed4db02ab7567657b3835c26e75de932c8a9ceb46682b964c8baedcfea3dab061ed1a593eb55ef836b2381c05c5093fee0facaf6e7f92fd3921be6539dc9164e2f9fc4b5649f78c9e3ef47ce66e738a87823e7f52bf65023bb926f0b2064d27b8900b4f7e20aac99451ee889d851e0562f8cb4072bb2411cb626e04de28420412ce62da489f5bf255160317c45385eda77a9ce60a3729143876d197e2577e2bb5985a0ca83a7f1016d11b56478f0eeb877bea651a3cb5162ae9ac8a5b21b444287dd5b8069858515543d831460aeef55469aa93394fcb39d2887f7ecb6c0defc02fbb109b091857285e66ab8bd1a2beb3fe660f60bf5bc726fe5f3fd4ba5b2c32dd672567cece1500a74f2566cf93361888d8adf50f53e8195a9a13aa8f2129d12b213d99530a8fb4d5bd5f54a967e98129aa8fbc1e5f4a17b27e80d1aa430c6e6189499800dfd6526401c0b4104d5f6f9359426f47b47c71715839091f63278d2fca4c0104363fc0c6877cbb90a106226757e4d93e43da7bd685c2a511aad394ba3c069d0dd3bb7a589cb59c81f3021f5deb578af623863a0e5f458b97ba02f29107c94ced34e2936a4a3e5c26bb85288bb8a974db2ce69896354d9dece6d844b43f093d27ca281ba29447b055d0c21d063df6d434d0263223c31ed3e5da17fcdfc2243439c4c089527e90b6ba4ae80f6dbd2ea8d73c45e8dd404df48fb6ee8b7a5bfb558fe7efd2cf1feb145e5fba884afd7cd4cd31665f5adc58ced90697ac856b08355c35d0cb4dd64e7cbe532b4e17d3c530b67c4d64b3638deb200781b16d74f1bc8824441d53d28a1db4730aa741d8b67440c6f3cb89f9c1c1e0f9ecbe58d80bd0bf92aeb77d1112c19aaf4208149c091c044363d56ed38826209e47dcb5d6b4d4d3fd1c6058744261164123158c5d0b5e96f0615161073bdbd7f75689b1d283ad5527d68e5e7b55f33c0e95f7d673be76b06b2b2226bfc8bab3550f3368662ec3a7fa16dec14e4c28962aeb9ee3c7c00aac23fb4304a3005370220ea32850668bc1cf73f9cdd519034ad0893f7839fe06981ac895a225bfd1a76ceec5347c9f40729bd9ecf2280a078963f00a1a45bd9d41bce691a579ef81acde6cfe0586b96d812e90e926430399917da934b9fec2db2fb9311cb79ce358bd3b6aa3025edf4beca637971b1402e4ed0755e79c325cdd759871b83e14b4c8dbcaee025de8672732074e82f30dacd1e7309e3211141e261fd776f977292c7b9435c6462b6bbc95e414160188a5e9c4ff9a778d069b1c4f0d83065b76075d0500f356a510846e6cf569ab6cbdceb5b1d5be150659bb702d8600b8a4955431af4e20188445b3b6c45f8694aad5d6f72e4a62049578acd7b18ebdc67cf1ccef546a83477eea6aee083f30be935da194f8b293db3aaef0967b5bc7c5ca22a7db8d32d2312d46b756464ab15b6b8741dfbee82199dd6125799a12ff48cac49c1e5dcda56a15bd4999157bb7035a3cd62a51b1797e9119a3c62c61f9c5412d9a4ca6ffff4dfaad8e0d065dfe30d2ba53df8a925e2670e1538470aed83c08e4963f840a9bc82b419fb99084f77561aa00132ebb57a4fd2094a928ec5de173e251cc56e5e64fd5a649d86baf396067a0425baf6de8687c28a8a501034a54dd8f5816e1f5c41236273eeee0c093a02fab1c83f98dc89c00083e601f47f06ea8f9e48b453eb0499c4e8285b2a581adc037619ba26d30b355ef999eedeb82f892029633cc4cd580c69831e5bf7995b5ede768b870a82388b72545ddf2a11afa87dce58f7a5ac0c12c48571eb2e72e76efa653f811b308a05ef48f488251d230765121e9337c89f1104aa7c7ee0ff704a97519a27a26410c8997dae50204ade25cfeded6983025cef0a7dd9c3689973b2a87ff5b2867003026779d3946ad0e1fd1cbef9224c2f2505a10b2376a7853699be24c15482ea5b45b3435e43ef0e0e42786a839833ef228847e5d938e60bd7a744398c391241b6579a45a782c7257b235e6bf5762fbf8132d6e8e0706e57c42c4c0663b7c62529fa9f33cf92f4b36515101b84d5b4d2e00ef50427c553103dab719f41e1b52786d207b1413446292ef44d767e63dcf67593f94b11114ddfee4cfc086664d86e7865436e1eb6c83c1c3c202ba341d15fa892f65a1532fa588588346481c2d9f1460df76a828e37b32dd7db8854c76f10619e3eb34767e2e99e09e20911b7595f0a4c02c3319df04650f747112f7b8a62430865f5edc1cb0ccf546067b09d089448c18c5b3a985ba3ea97f10e618c5dcd6d99dc2768d8c88fe63978a33092920dfec3a59320dbca519358ea964ff6f7aceab79d99fbfa486fb676e119582ca1322f80c5d42466e05bcced8dd36731fa7cfdfb9d2b21b628349183c44e65b7ee9d3cd2ef48f1f8b7da2497fce7d14100278e992cd6e3f43e3eb67247e25c4817102113cafab8496c6b54a62a5cb4947aab1f3ef207e1eb372d8249d1639ce133066ff79d6e02f7a11b6d0f1463ec973335bfb76425baf526cdc1b6bc6213611038ac12351d7a0ec299e327e5b79da73486a27132de0562766f85627cf5b228ec2678555f49a955cbe22ccf91e97cab20c1df5937a841895dd3f03d1add7da3e563b33cb77f7eae6ccdb4b708748beb418ecafe0f8c969a0a15a3dbf63b388584226090b79866616ab9a35ca935d52255aadcb3457aebafa50e68331b12767189d2c01e971d3bef40db034b8bfc4622956c9014249702889d1a5d185474798d5c121c03954ca6d8ae53b0c6bf796870751a2ff8ff5b68d9414c0dd6626b50ec86f7b4e694920099383a7afba4e9e1f2f9c63e69deb7dfebb4b0846b087c07ddbcddbe56c137ba782182f73924989710575bc7dfbcc7c30707490654728254795803c41e5878564c47eab8f5faccd34b6e85ebf4ad15d7adf2586651a689aba689021d70d7e0a4c74164549d8673b90b001599fe3c0e5e0c3725af06bb0a566e4896b93ab00d0754fa8ec2a28a971a9a9338acecc934801366ec7cf6d18f000664f1a787a1be6785479b29ff364366e3d945f24b64db531e10d95a2b1a7290224ed7da60ea4bd10d588066e80b401748586550fe60c0230189c7ead0958ad05935a587fbe7c87379179edc9d149a5283ef046086bcff716a3b81df32a9c52ed19d684b5884243cea03a0dd03a60d96f22cf1014305d90d33021bdf4e75519f301d5c69f543d98c6e7bfb374096dce3c990c3e5614eaf4f8b5b097f68f5cb8285c8e17ee468d6376531c7e538f8ca37edf3ac2a350f92c53e77132345230021729b86e1535fe29700e67c55816acc2fcc982e00908e520646e615ee52ba11b7ef098911428d346942178ad341d9f2ebab71b739b305e79bb99df6a62211e3632359d334930340b3f71d7119d2fd12416ffe22cf7f58201fb6e660f991c2c5f1deca3a96fcc9d48908706e1f2e299ca2044aebf393d519879e6deb0b70eeb7b905f4acc4f703d6c4467ad8cabc98495cb6540c1fd0bc4a5c33d3dd5dc07f4318bd33a5145b2db7c12330b091323ac0ede1567cde7062c811511ad208376a21ea067ced365bdfc73f4edbf4fca80c714ed5ae8eb580234f7605b34029a3d70f8b58fe5f8a654b9303b20ce1bc5e9ad3a6d9181b0be4c94c9d219f66e886a60e16910d5e5de4a7e3fab4292d345348efd7d3e8472c064d39ae235812e743c70dfec5c0010693710466de87f1d7057f6da5b6563ace3c0a318cd9549faedbdfc4c802e54ce371495047ee917c8d5aefbb606507804025f380d59d15d6780c1f77c7972bd8f9ca3cfe02a224092e41982b6fc0b0f05b7047950d1a261ec84a9c9256197ec325f38395e2cd01b60537d1ac9cde574cc37f99f35a22d3a36c15536a3de6275e8a3a49ed9a968b02d1de3532c99b920aa6db1f58b8739cc9973a173abc0525df66f12d270a8b9438cd1a527e4ac53c37b5633d3b072def200eb33c58d6f8de5796de70b3e1189b4c9a7a6e59a3254bb94d17ac5b64404292e2b6dd7a4a9cd7a034da2375ee2b15d1f4ce3b8c6f96e29060b3d80fbe5b655e645e251c3d029e2385c03f911cf67d86535bc0ce9706e1ac805766225b3d91e5ec1a54b4240601d2e67b790904f517cf1af436187f5154b6b8ca1a6f048a1dd79191d21bedc674311cfa7f7d38caa6369b1ee6501d0e93a7849d5e6bf51f6702b2e2c9604f21bb8ca1b4a6c08ceb906a3d6a0a153b99906cdadd96f8d0041e9db0441b8092cbf3fa1d756fed13823f3a4addf4179b5eaefa0ee435a35dfc16f8e3db98cba9066f39e405de7b30eb6779ec77d4c2cc21067d618085805581327a32125f1a8bb575872721b65a9abc410fc6c851b126867fdca274834b8375067c35992b03247d36fd044c1743d4d3f17753c9b6bb6e5c3d4647d0fba6663c74e1fcbdfe780ebeffff98d4e94c33b4838b1a4d610084a063eb94bf3e42d87c61280ac6e660ee0a3eac5031293fac560e341184e351b8a776f300180f3f97b9b52361767e31996e57a3ff1f3c161ccf480dcc9428d86873c83d61646c1fe2d93c4a881ff4156b70aa9891235619daedb8a635584c52c83bbe15c6a14b358a794dc2fbe71d7934393e8cdc3aefd5c9c201462a82966f4a9f904012ff2cfb0727f17f358448d622001a35dee950317c72245caee3df43cc1b66d09c314a7283b6a1cb3e9a650975e7f8a9f38f2c7a12d02f2084f86e14e501ab6c09e4dff47939aa6cd456e133f2fd285bc5e3487fd2b98c2680a327a88d688afbd1848246ab3ed0ca51ce4cf0ac396496e5d2303508e6aca7bee50f276d56f60f3c708e9a70af2993eab4e60291b14935a260640d53eb814eb286eb750980310da9a4e54a8fff2b4443415a1621b9e5272cbde79b4d6f7e12a36570b43a0c78988c100b0e2b59547a4ecafe26b10d9d384d52dce181aeda2c1fc6d32b30bfa3c6f0dfb9564bcc86a51187246ddc0ceb834c19ab75bd050bd0fdafd5c35d163ea8b481d0d7fe739bd5e6d5a521682e4c4aba26c1616ccc6f11125c3ad95df1e9c856b6aed9207203590f202b6d91f344c620b0f69cb058d8afb8da90ff7280b1e0f88c6a07fc55e38c4e4a3989f73d714d125537729eb2efb774fbfbfdb188727b699e85aaacce7169cb5bccdc442aca8788e35bd2c48a9f611c28e2faf49515db25564eb45362b216e3bed0b243bad121ec9a170e1821cf0f52d5ba9319a187751207668c681054772a5e09723298bac66c076aa53b7d3f933e2a83485674f00ca8554d2d22abe556e1e451bf76ccb49a9f63a4fd873f66da693baba57c8005862e7163702c0d626deab6c1c7b3489a1d87cc1c46d57056870d492a65c1aa0a18943dc9cf4e44dd0661ce42fab91697c93c6938ad7ba56c689a72d3716a9409cc44dc36d43aff37fb3055fd9a8b2472268894c421a784e5e675405cd142750e6160d98168c31ac4f08b50d16f7052e0a17fed3673ebb0edcb754d4ac13117b3ed9803577e005cb55df22a00fae455c2ff9b2d5fb31f5b228a2c2c9b91a05f8be71a672f24d370bc77f29cd9f035bb6c36db306586e26b76f7e50aa9991104250f27022b54065938ff31234d733e10d89a49d7b27b971b5d708c9abe9af96d840a68fd26eea77c18d1f2ed80a4b45fdc4d4344c3fe865e56f01eef1d4d6b4ccb3818e165782ad2948a74dedd28047290c60d7145ec03cb4ba3b6b5ecc5464cab80c964abb2cbb100e7baa2bc796de1e74ba55e48d57fedf8e0576d15ffcf1924e3a50dcdedd4292ce46ad0c9bc0072d1cfa5e747c97767c4a091589b63cbd1dfd5ced5f56509f1b9a93a964a2f4f0dabc683f236b931debebf592bfe3e559a3a017b1b3f94ad18182cd824d9a4f6ebf5de63ab455ae8b9e875e568ea212092b8f2293e763c293d8f630ebbd63ebf84058f207004486239c34f8ae2b8a23258a7f98ae6b69223b1d5d431e8e71120bd773e8dd43348bd80fbe479c25b71802230f56430b71bc10c4e14b0f7b413f45f2f6fb8bca703e7a22ba8a33c78fc17481f6cdbc30188fd8669114a2d29fe82b3cc058e4fb0989ec81d16a5af674f0edaccc687ef3ea5e70fa250430171d030e15a7a5a1dae871318a3276aa6cd76b3e2fa4b19046f6abbff944b81bc8c2216fc4e2daa06f1dfd3ad33199d52cd76c63963997f3682059d0154327c1dab2009a06b569ff48f1d81e72facae1d5767551e50cfae6cf1e8f16e00b0d5396168177e40026cd6e102ac11fdd14ee25eb8c5cd99f2d1addbe9629910217ee0cedc7651127b5845cbbd61cdfa12d5abafeb8af7bf8da7f5278d4a958518880ba764e49efc06a38fff12bc7fe139ff9f6fe2ce16f492b6537ccfcdd0fe6f7a345fa421a2c877bad05361c9a230383e4dba02788ac2d6e6c4f8b4c7e6dff453d1a8cb671b99f63e75a1793397d200731d8b792f17789ab0e9b37c8b0c81e512d9de5666eee490823c69af9b5c25169c592e73548e64fb5a5f92dd4b63d7309d69639862ed33db6c699f6a5d5f0bbdb533d159a0133d67a7b9dbe1f11c6f50d98f87aa22b853421e44406bbbe8af1ed539b13eb0547b38bd87f28e6bc89ffc7b5554d5d113753b2c873cda29e6e2e62a389f25f9c3c549aab03d43eb9097726cf39c331b1200c06b6ecce3fa879e095ef230b0c9a05db131661692684ce4e5b558df33685ba851e150a977575d148ee229606882f5dc2ae909aa6b892f6c7a5456160b3f685aa8455f31af4e7dae0aa18250c18d4286527f98b0d444ff35482172b227131f8d5aaeb2a2cd1d005c6852c8e9946347f7888437332aff43a25e97d2e93e4229e651b836a1156c90e18486ab666ac77fc17a441f7a398602c9a54b38b3c60ed316c39ddcd04f045635302495f0282ea518ada4ed17215ad8523e86258159759ecc70c7b1a415e814428f611862df02d41ec6567cbd2277a54b47171038e22b52bf21a0082656c4ea44669b623146d1e8f18317687047deadb2adf13e4e19de9db6ca5e7746af11c4720f56f39bd393fce15d13bead2c3b32875a95e9ab5bf3b4e116167c49cb7778b5554cefd7dc0cb20578ddb35ba4e5d875d5fb7c8b0331be3fc3790771f3fbbe3a312b0f5d5d2ff3e0deb2e7c3f3a462e93a543de5dfe0cfe945d7ef22ebab6099bb380d45dbb3558e4399ede667d6367a99e8b5a6d4efc44e5f60f0b8e348e73a1694220877045334f6e55badc9e57137505150633525bba1deaa02e616c8faa4104b1bf36770b5250d4d303c71d450e92829806d523b5502285f8cb09d2483c86fb331032890666084939b7b79ef7a91c3c76376b65e9f50446657b3689ef93bf49f68cc642742c0bab86cf36d07dc3dccf3cf8837d6086f4989de58158471fab598bd21e32902a8d1b4bab20d6a8ac683b6601302c5de4803f7b8878522a968f91e2bbb10b1549b0e990885d3f7547868b92384e38df9f8c4b2405c0aea1e5a3c455ab83b50f1fa672a7ec36dd9dfd0b01bdb8f6eff629ce10e4eb93167e753f2968f4c46efa7dbeaf47f3de076b57d26b18d945b59f2ae95b52d8ccca159738fb2d65cc89c183225eeb0ba51c04041e0d0e0d95361f2564fccc5f8a39623cf8259c6fb079099789998a753c9b00dca8847dec9a579eeb3e1d24dc2f7eca7f74101daa6c2044c5fa7cd8bc56e2a5d004b60dc4d143b5ff4237e7e00cb7998a3ec883430bec728a8626df9d0cce32e6eef23124a57632c1a5302a2c7192963a392b64950d81a6713f1fa0aa7e81e5e2e46dec7e3a901335f374f89faa85acb82914b945a23bacb457064ac7debf1a7b87d9e654789506b91c07ef8f7590acccf66bfffa5ca94257416a8968ab991c0d05e2c57ec3fb0c5b001d6f63f3b76dc68a795540182f42214f1b436667a13c5d5635c039cba407409a28738d07975d6f4808f35d87606460f03b8d1650e8712204529762999dde60bde26ba7fb265819da93b280b06ec8af7e82de7801b417ab40800a099e80992bf2ecad27e1c2d1ca1bc77c403066cca05885c1dae9763dd088a78c21b5fd9d1b63865f4c28e87c1b1a2bb27223cf032582048e55a8a7e106ba3618c304883c01107b5ddbb1c892e77d3d0e1c96b6599ed859f02dbb6aa05314e006a97a35d5832eca28427a69ff1176c7eb09b33f26400b50bcab1fdca430b257a450d90dd967cefe9836fffb63f5a047ca1c195e1be6bac116107f16815b293f2f3dbe067142f9aed69e7a2fd356e901d74d607a9b58ea1d71f7f42f6983a844a9cadf444114b17e9e42e8e000acb7e1c7e1e0c6107967d4264bf8ded17314790b3a3ea7d5f4824602a3b93a70504622c36614195a66a0862e23b5221d70bfb4a33cf31438459a40a1ebfecffaba799cbee88e158fb9160f1906ff00d056d8042955b3e25f43ef869e4d4ee84c49d4824e4e760d85cfb50ba289919fe0ef0006af5368e5487b32f4e205e846c6480bda8b7ae9dfd94641d89960d9eb6779679f0b3a816b44b94f6c52dea3f639eaa2077d0593be77c38a2644658dc9e939bbed6867005a3b6d0fa8a40cf2361596e1c6fb294ec5143918e70c399a61a87bd77347ab1605920923d79414662c6b2afd71e1594a3279f28446a287a66258d8921f1bc829fb204855ac09808be4bf9b6aafac5474887ce214223553339c4cbd14b796b7ba3b8fad2f479fc1d0268a7039fa2b0793534d8ed3ec6d74bc97ad873dc1ebeb9b0fd42a3820c30fad4733d465e80f18d6f654a206275cba9375063e66dbf4a7f0293858f78e6c2ed5d2ab03550abbe725cc6c28fb326433b80724626a5579dd6eac894e36ab854d4ebab62a9e1b8dfc955736cd7ca7c8ce540c7b2a86f6a6f5195908b02368c356ab8dc5ad6ab16eb23dc6f95d4c4578a53c738068e4ee4f6b31dcd891c856fc666d4392f70430650c83e3486098b541335c7daed374f8b7919ed2d2910791afa72633bb568ec52b49b762a7115d323b4db0cbb0650cbaab08d40b2ef479bb6164e05f2d9e7d9b341523d2dfe23b7f785da22c0a3967c1320968931ad15be374b8e284fc653221f7a631298736f66f470182e4fcafc733bbea0402f9cf2cbdf9fdc4e168fdd20ec0c2e6556ecee81d56412adfdfa3e5b76d77cbf09ca5c1faccb8a8b7d2b56f8240cb2cb9996a9501fde1984f92fb2f5a557ac1a734fe5462aed97dfe91bc42599492696156f9f98466b194f4c7979262dde57af1b2b6cd6956babdf47acc154dd017fccab0fe87882352419a6447858bc841e5c7de40c7ddccfb0738fec2c3946919496d0f0e853ac53a9519a3f14909cff0c82f144d32f083957f5e27744ab80c7b82f1237b2a49eaa920d5172798182abc0420adbdcace9fca3ece8df3c9e965b6cde14b3611fb1828d1416a10b1f6e78ae06c2818f1ef7ca8899ad834aa22f5f1d929e3739660ab0f6e64ed30ade367769de231006ac70b625626520bfa4576b4d0bcf0739f753f8e1527ee84c981b7cff291ad43f1df00806cf7b722107d8040737059f95d42e6d2d33aa9cdef36e399253eff8db4beef1f82f8aa1ee8d0b304b2e9a01be1896bb1c79a3ddcd01e556a675a6c1933afa4dcba9ba39d24502e59cd3d84bc933be3361dc50accb81f729bb9fec69d8c68358b17b11de09f685a823d82acc569560ed3836f80f392a499150803c0ae59810cedc14b921fcee5feab8c483f99d1a24775dbbe7beaf15a98430df4190a5b389c7322d9d08b89d801f81f3d26eb3f22859b317052f4e461fa6e923d65a75fc9ec80a71623754bd12fe91e1ce0dd8052b475a25999fed12dab94fdcc90772a4c0a85db27fefd4a7ac4294b9d8f1f81eca1c8dea203f2323a24b6c4bd7e87a413c945a31db6f8a509b66ab7049a50be83663d08f0e94c27fbebcb03a0f2a7efa9b270669befece54336aa43a1632dc96a93ff150c1132c94de84669744d6e6881f2419984160748a563a0a868eb108f1064ca21b81eff9b2100d9b120742f332bd91348c05bf602e654a784b24613f9e48fb40a72ca93bc24f098c2195069d019a723478dd407e6766ec73d7c866ce9f6e3e20236a4959af113ed4a5a7436fefde3d928aa07ee669201e776a8ab60cbce3a3bd825c3b6952958abba030f2c0c72bbba375b51dca2eb601864b6e0731b86bf4758881b7cd0b33be76547896117d3ff9c359f34593b821e8a46e73c01e067ac9fb69c23f36a76c78d6052510e2ce5e6e6d995be755404897060c6d3a7004b70a264be8693b5d207d5a6fb08a01bdb2c95706189d2f169309482f3f61cdff374d64329ca207458c6ceac78e906823e1a6b936a281ffd5a8b2a6ad88c4ae580bc7c5bfbd2f000c740a908ebad32e4c4e66ab81f5adc57d036db19242d639ffd8455eccb9132a1a09e589de0026d8b442ca98681feed6b672f6e7d92710496e735b69486f46aab3d2f4e87cbc00845165c7b9565ef74bc3529d36f072d51865774c97e9b322f0ca56a5a3785ff5a7b70351ff4aff58640332fb03e551af77c640d3a084abc1c55d0c37ed0c3c932fefc8cd4e73ae3d360069caf9be99ba0c8e0aa5c7d29ea67a23689bc185fbf927251675e8d18cca284685237c70a9d9f87442200a5fc894f7e2f5d0e730ceee0ca575635369a4d036e46379d1eef764eb135f8c901cf1126f51baf4311f8c33833e736ffb3212ed8b86c3946fc6a5337601fc53dd92b7bcfe31fa337df1d6e53047cae359e80ffa3a9c6e73ad752241b3dcdb59fa63bb1327b0b94cd93cabf7c0595027090981b198b0183421e088f3d21dc639f1a36c10d2e52a619aa83f00bc40c7d4ee25f9c8e6aa6f8cef60a50486c4d33afb7f0a5412a7ac74683ee8aee5f1cfcc850f5baea5b039805d8522bdcab13ce3db41b34acbade646490e0518306e61dbd162e2fcee8428977bedf9ce15bc156745fefb5aa8ad4e3b047f6a9adbfe1ff6d6bf91c38879c222c1a7fe0eaf22720d109e4278064aa1a9c15d0c279f1341e280efa51b3f1ff2322d8e14634f9a2945612b97450e844be36218f524a6b1dfcecfadd25645f9add6119c7ad10805e5988abcee2da48e2e1ea044f9b7ab4b8a525611471269cbba7c5854d904ca8bf62926a6f5bbc5d73f63b2551901c5e23ebe525ca3c7f05dd8bf4006c2743464649cbca8ec9065509bd63fde4af7d7515a794dd030dc12cf78c22a9d6c8675f133476fe99688e2ec0c4671d71a9c81f81d41e82daa917fe7b49b1a82a2a9a17def6427369624ef1e522d47dde4fd99e9dbde859a56cbe04e66471e9545082587e1eaf296457ce3e8b14a7834d9a5d09abd482dedd3bfc2c900194b649d10ac841014d59f9bdf3de5a28a515f524050e255a4ecf3b55d67984d38219f20e86c1eadc8c9090b027ac4d3766f6523603cb1793719df7b8f7f1059537c3a76ec41420b57b35d6213ecd756ff017bed12565dc559a35956fd9c3f202d8b944350d690a4301ba14284735d0126388a378ababcae3205d63ae4e76bf3bd4506d9f11167c6756d4edcbe259a7120480e0c53f8d2ade5871fe72243341e87043d4c9323669e61271f57188b6398d97d497bf87147930d01d06b942e28f66d40fb86331d468ee96a2cb4de5ce3b7d5867b6c6ffacf44feb5d4c47be9fc0e70f655b16498e9c2370809ffa5d62f927e414236719b38e7f06911c85d7da13651b99846003346c87cd629015389c9d2dc9a4f81008b46cb6ef0e7addae96cd6e0f6f05d7835ad45cef1b66011e96838c17093b7cf2661fcff11598e41a1d5e0771b9a6bc28df5649a5231c82bd29f0fdbbc94f787a6f7f36b57b7e8ff9978376507edb260e03453a9c94387094db5588f47346abdc93f9b0cc0db6b6cd345e0c44bb4ed6726272ba44b203f68469526ccc70d7656d2ecf3c3cc3869bb3c357fb9caa53a31a455b580ccd68d0222e4fb60c0c9b1712c9cda7ef780eadef27d62f42730383024c60d1ba20e049f19504c1ee2ee01b858dadaa42569ff4e81c4947ff7f5d9c5db737a176f25cebb41a55609e53f165bda9f7aae1f49f811a7e540ae6b21e16b1e500fca4886be45646cf77978f705b0ccb4b860f4dbaadd27c744e5708f4eed841aaeb8e4dd9e494f62c629d47c4ad209d34bb7ffc0fb72d03adc1aa539b031c7be685fd4d0e839f7a86e010ed63f5714206bb6f1f9eb26ecb24ec96ee0a8711f7b1e18bbbf411c1a106b7270940ef6916b072615a37cc2bb9864b4e5358000504724645d5f2ec19889e870ef9c7d593ea9e6056f0ef3be6d375309060d867acc2606b9950f91d2fd357d3df385637446e2216bb2cc60f399ad4648493342dabe154dc098ebb3d824a4edf806d27fb902858ac00caf6093680b92ad277131fdab899d1288332fca3f731bb9f0570153029e5ba47714d3a3331003fd4e3ad7d944517c0cce157ccecfbf9e3b9c7505699058ed8d7a70abcf5d6fe2b8bc39d508bf0ff1b1de9f54846aeca5651b88d098744673fab1b2a273137f0bf59e3ba6edc14392fe98e5ca467ea60b2e4b65370c96c5bfbddfa0aef5391e2f9c752f43861eaed7942cdd35fb2f65ec44a11ffa08d782930af670763905b5a12716020d8deff732e548c80fae31dc1e689d617531f46f0a75af66bcf8c6b377b09882ccfefe520e6f7923b9abf005a0817b024b8c548e9ba8f52188bcf6adfacac86a34e71079407ab0c953ae892f6deae1bc85fcca34044de2b83705dce66e5a76b0fa843bb682bb6b993ad5b3086f61df0c1b4d735d0d3daadf66bf5ab973cb87f44f1627ab30a00d95a238eb5699ab8fb281aa92c026fb2dcf68470d6ff5b20329545da0d3b32b025326182c9a1b622b785998dbabeb18d0861b62612c38f6318476f670155f83a62b378630aa18f89bb108ffd6e45f513d56c74e7c9d59bada1dd538bbf64168c5b77b4c314db811881873ce0409c41616a786a47ca2d7a3eaeaf25e264d9ea38bbe6d514865912d4d718cefeb7915fcf7c85e8949e39967e734ccae9b62362b947870b92e51bf06bf51463373a25ff71ba88cbbea1f3786692e1198c17fe7dcb6878dbdb4a8a330bf3a25068391875628ffdc484c142e0b599b70abb3a338e136f42202000eb79e70ea6e1e4ed0ff5b197a15209a7bff713d82de58fbcdb747a4dc31fd43c8dd0948ec06714708fd2c49631436815972b1f3b833e190540507dd3ba591a73d0ce29e32a02a20f64fb137627817822647c0f8014500d2e067c2699badda4abf9112d83f3d75f2d40e2f2c44be6a1f04bef493ae21555b06f0a0f8d66bda8791ff394d48de74b8eec73ed14af331e8d0dba5ada25cb667a2a6cb3b0cf5ecf6967b797d7ac74a29337f9775aee88119726c10f7d8e5e0e4de92534c2903fe5c03ab38481def534d5c273c1f5919a8f60945dc9768200029624b933e091590150deaa550509ff504b6efa462cd93b55ef21692851fe3edb11c142841376e41d61db25f565281d4db208f25124eaf82faf6af9504d555842742a14eef6a78258ea1bc68f97634b75323827405c07be1ea8bb69b9aaa8dd1126fbe2d7e3e2e2d9d21c0bae9d25d8dcf34865be24a031bd6e2a6b32c29addd3ccf512dbd1fc05436af6e432f4abaabca0b0225a7945cadf772141deacb26d0c0b997a4884e6408e1521646af92840e1f9477655aa2922e43f72cf552f4e0cbbd4626d0797da04440038caa5d62d70fc247f4fea7b160f8dee1ab5c8b9d55dcbf201b56f352cb43065f9821ec23cc4715e7bdeb640409be74416a6fa4fed7999c916f01af70d873c43913840e959298c5bae5c09ccc8745beed52cc84a8bfe8daec405985b67686dbc7f5220913642f127cc07d217b16c90464ce1dabfa3447d8b19ad82e26c6428970a3e6341c064d2d777ecfed368faf94d62b8f31c7bcaab601cc2f025cb28d3199425d06c804579e4f2a5024b0eab9d28e679b2ac4d25b619b46d6dbfe05901abeab5e7abebb0266d23538a841c63829489f9efebe4aab1197b55a9daa26048328e40ba6ecbecffddf3eb4c75fd046231a39f4506f1203e650dc613d0475bda422244b605a95f9bfa2cae6f31d4d41ff5466fd7875e0425372833bdf9143985e1cb6573ca8cc713fd53812043c145c39f7e3d9f71159e8e7850ed31436ad824df4e67583bb08c5c34458c3697aab1deec436d6e1377fcd0e1081bf5018954a4c8ac8e210c1b61bf6410f02f61085d8de449caeb0e365c7928c4b75dd1e758fcd7935d606e1d59944235bbf109bb09e90b043d8aa008d52ffec76f6912fd4d171246b438a5a73eff7f9c5c4566170e53cd18447d1e2590fb5cbeafe01454ce7e706a1c631cfaa1bdd3ec919a00ba7326bfcfc3f04f4fe8a8e6e64d81ccc3f57ac699ac62e8d58bb730540bc298e93c33c891d6d4819ed3ba95cdf7ba2be48c78745ba61e33c049c32960ea9852cf65b6de404e01affc430b254ed03b40bac4481c84a6a626f26a8aeb7b28faba498a82e84ee32e245e8a21829ff98d2041514fc025d9467a31454b9f404a6af6d373938b8d77a46c356561e577bea3c65293f6ff5fe1e70277f97d0cec6827240080531ce0f94e15abfff06420a6adf70ae857f0f9db9d29cf3d90f35f2afe5ccc348d89f1ec41289b7e211cd01391893e0187b294910acc02425c283b96ca9ac73ace2ff6aa50b83df8453c132ffb7f6b52d65cdacd384ed0cde70efaaa2a13ba05d6401bf83f655df2d9df3f5368d54118e12301c18a82ef8009aacda67020b231b461af1377c0e899a7ea59ab145bab1e796822851478aca5bc6336b77d6d635a28fb633739f695441e7aedd170701645b0b75a98ce15c31c3344a1f896fd44bbd9e026da8f343e351918c45e905ea267fab93c4d28ebb163a7797449e084e4f61bfb14e0bf6d314a4e818a499efd9f7256bcb6e7353614c5574926acd30368851afc4a38c8c6ecde6289bdab0e2a35434b78bfd4f7705c285e8820d006c64d5d4eb8fe0bf52918d42ef271f9fb8dcdfc1863a558628408f8a3fc48576a61ff48d7c51b930c5c0ba75bca48f5ae010616ea98c56641183f5dc02862238ec47cb5191105673547415b36f870e86b8336d3c14eb03e9845bfb9691654336bbdb74e84c5c5015cf0635098a7ac4069c35cadeee37664e78398443a12e52131dfae1f10ca58d57f16","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
