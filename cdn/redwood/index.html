<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"952d328bd039f288e8ad0937455e64148ceb6e362894cd109da96974e46c676c22edfad34b6baacdda3de6e0ef4ff19a8047000f7688b22ad158c8b632036324d470a11595470bab1987b28f2f837b1373f740483e645938a923d5f1cfe2bce63626ffd51d693f617a39a73da4208f8b7c56de96b3aa7da9f126f664bb37fb88e2492f555d2bf6f26cfa99d298772cb8b6dd4cf1a52874a8c46b05b50536e5916eb48bfa77953c1753edb654ae247388b633b4fbac91f9128de767c34940b408ed082ee1de17707346784291da232bb812e25238607d6b4a351f716f5af1e45d1e4b96243b9200fc7a0e0670aee066c95c08939bb49d15bba1b149cbeaa48d0cd1d4908f1a9f1fa28bfcdd992f66c61f33ffbf35a78b85282561fd073f76d552c677eb54b384949846b00bc8f10d79335338ffa5d6adece3bda1944971ef11802538b418c74fa8bff2847409ff2151ee04a237a965937f82cfa94b51cab1bfd56c0a08d78e12224d582fd604ec979e4aff10c599f41c42040baa4b91d322c92880b11919d0810bafcee246af496d71ab58bd4c4ccd6357a0c81694771537148df802e97bb5a7dafd18a5da7f18b70fc08578c375b427c0e91f035465ff975e3202d8cd382e5971552a9c80e443341d60be900eb95a6e424c74d0fd82d63b849309d8a40317fae442f24d048e0f0588eb31cc02beef4613a9cefe8d2d55217e616f72457b2d5ab7a7e47c83fe3c8c0a762f38c6e66825163325351120141eee3562c08e9c5ff4bdb904bf45d861b7dab34a16b4faa51fe79d422352150d68176462f7b1763024e3be9a0a731598d0e55f049e742e14103f479fd7ca015eafd37c62992ddf7740a0c9ebc8ea73da85d728427e3a9e7c46c23a1b7eaf875403af29ebcc3d901393b28c4fac9dbd7ef3b8a2275700001874426d79329a0d9e81941fb93495eea94efc7764137c784b6b288c50f7e38a7b0b502f9090ce5d59c18f18932bab94c3c2218a27019ef9da92ca3d202d28a3cf9df0e97c203d7c7968db640644135338cccb14ee9828f88a9e3b1fe6c7c829030574e334a4e50a3c5ba8ffd831ba014f3e452bd0699a8ebb2de5b3982632d35db1d58a2a4607b936f3e9d074567bb67f5425e7dd08cab913155523d86044743c7c2002a80a27718e76933c74ea55cea819e097aa29f5561a122c34dadda5b0523e583a4c086cc8d8454a8ca2eac3649207dd0e6ac921751fa8833bfec4c8fba24722121859e7423dcc8ce86b134c2b565e99c842bcfe19f5acd68bebff6257a2fd66333296f89d5b2f90c63dedaff1fb0697bbbd6755c4b62da607f3895643058a899669d26b7a5c3411de47bb548bffe88ff7d0d09a0de7a64e04acd586336debe745eb9a36f1b2abd67c52eb682c6ca00ef61576001a384f1668452e3f210ec484b4a2a1ebf9633ae6543de169ac8b2c6b595d6a8f630e7294f31ca98fdba3e4a7e093e8d63d98d8c18529ff36b3d9ee24df951c0890f5484a3aeb4fc687d30df86dc3062ca21083f7b2358807f027ae4254b1297ce7f95168acc872b92f18518bff584b94cad3fa0f29d96f5d757ed31a09dd791bae8f0bfa78d5fb78c240a11a52779bd1f47d3b131e0a90d1218e66d7c3cb1211a3f9dd93e030adb08c57d4bf636296ff3bdebc07ff13fae75bade82d0d6b2b1e0b67d4b1023bc8e89c2fa72f8ac3f53dcb679600b664813b2f94a44b5dbd2b42b966f8f2ed3fe5cc5e32d1a00b08f858dd84e4a8d5eae5f236fd277cbfde171538d17d5ed741e0aa655719ff971bb444008606ebcaa19af7d205f5bf55cfeab8e5cdab67224633ffeed976eca110e8833c3101fad36b5325c427cc0318268e29ab6f46f4589522e0eb949058aa7ff9db02159899f27d6b0a4e2368ec75f6a7cdeeb2933a2311457293e829f5c4fcf0b922bbf82ae47c44783b340e715ac6f117cc1dc9b2351e5fd9176a50d62b3aba095f8f56492d52b69f941a55862fef58462af7b1630e290e930e6ed2a94a14ab472f5b44504eba7feea865f4e628ad33aac78150c6f389325e266f6ab149f9c703df624d155af8117d3be8af78e53fb65f74b22c95d95b73565711c5f596d48a6a906e1bd4db88dfc27f3ff93c050337f6a6925bdcdc8f9d1746a7adacc8a48f689c7cb3a5364aac9cd500a1591de91ce5a965ddd12debefdc131fd38ff93a56a4bf09b8b1dde46af4cc91d71a2bf395c58c9e9c10c23edb7dc691111080c583029136de285f5f293d4080fd0a3707548fc9252a251dd2ebab3239f93a9f32eec691a3cf55575fab23104e350c9eaae565a21f1be2fde73fefb58d5150b50d2c1c9869872a18d3d51554350eabe97582d27cbc45bb021ac408b9c51a676df702282733b54db91f378c57189a25728cef208e676d766e36233d680650f4b7f04940193164d33c1c73ae42d918b072fb41571cfb5698c725000c1b5fab4d27581082528ac314f516c1a8b39ed5634468b6718faf884c6adff62a76a238ea3ec45e58daf46378d8331bc961f7089bb95189959ff8b971573742d05cb64bd29ae6ab67742dce400068f76b2004f6871d90aed8c647090647e8e00f6ef957b3cbe6f5c59bf19d416fe63e11094a9d8a2600a6279dedeccdd7e9afedee4f1fa7f04bf850d0432569c18519ec7f1f9cea47f3f30d5e3ce9e65e79bc9ea9db10ebf479897cc53b123d172280f025c122c13b49df4ecdc24af35c420b2fb860712c382f64b8dda69d0e837e8864dc3f8c0ff87f01c3c5e1a7051ce3884c32515c11f68d197bbacff8d5053804ac60fd0198e5538ce4b7b99e221876d57565624bdb021e596664a226726fe72df1c60211de75cf6351fa2a2b05180118a21c0c42ab3c19d39d658b228de6ba1a4c014df9e2c0232eac1ea5da5a3c7679201a1a5b176083825bec0b7f122df97d6108cee8d656a2a978008cc6c33104d8815bd758a7d01ebd8852d3b54d8e9784733a7adecf1d5fb3d4018a2cb23e45606c1bb22e0cab2b3f4aacd04a30f50bdfd182bfedd02e2175f5fe9784cb3071861cea1820064110d241c1979dd7f4da5939295f0c021dbd0f5f49feaa7a361e750769a81d95cbf8e773433ee1e65de853c3eade0b6e84adf1640327dab30c9d48aca0752e16f79d958c2b6aa2441410842bbfebbf141c35e89cf93b061b651f9ec342525c28000be5d370060e667e7076948399f71320d5e09a84ab41c91805a20e90d651ef973afe6080372b91626c1f07dbe41caf56102c72ac63d4877a49c33688dcbbcd7336f7e5ccad5cb2febb1070c09f9d489c41a0f5c04f5afa5f3a1e3682d0876a69833efc142bbc470df6462dcbb0a50ed6036971cf60752bf5d56f9a22a942e2fd1d8fb8d4e636a08ac1fabcdacecd96441206fa5977e9a661ff2a28676c7ca535dfc174163b8b6dc0c3fa7833e9482042a1e3bb1afb3bec7a484bd206879e166a4fd8eba664d76c49abf01a090e5453e65dbc68622191cd1566a35010c24b5fd3e6cf2abc7a9a55324f0d841e5b5348256789f3f6d7b820766a25021ff6068edee05d7aef6f8c37abb842d34b9760818dda26ff5a80dd56cce531a5fe09c00626b8c8af5af913813a32c4b4e3e844aa94692536419819a2eba372d91a71ac98d62230878f0dcc8b6fe63304506e7163f90867647c1559ffff39a340800d9c0435bfe4722ef36bf18e50da5c8a610b1d3de8aebe4bd55b88e6406d4b8206d65ca194844633735967b9ab43f9fd6390e1f3187064d716b62120b8117d0fd320a4e43f71babdd8c22987002e246a2a813d3f7f778b851252b680496995ceb67bd025cf542e7a3dde2406d673153916e2646bd8871ddadcc18affa759b70ffbc3255f7e1e712dcda2924feb53e9edd0112e81d5c38a4ec9fba78cbac0512a30009d800019afed94601c09b70e1fa17dacdc1aa427fa3d4c5b476fbb1c4fe7f57ed00d6ba51524f5409e95e958429063fa04035a52e4e543dcf5dec38fd7329c44ba6f5a5e839731d06c476b506db9d5451fc66d3c1b0bf80b4d46f6ee71160082b829ea19be9e5c0171882158383b202f8ecfc4c0d69a78614591f42b4af27ef94e7ded38c9d44db6e0257ff7445c5433f9e91ef31b4791cc4f8b94d5766e1a2c241fd81c851345956b591296608c1a8367bd4795f7b78d78bab26fbedabdf4362e512a1c42efdf65273d189b72e0c093f8c999c4f785b906c98a7d68dc0779f6eb597e8daf661b92413627d25f52880e07298ff201e5e5e9c74f546add67fa0120564637afb764dcba3bd39ef8c9696930e6945466cd52e3ea9e43743f91b935f8305a3eecc9dfb5e4b5e9ffb49ff59d2dc688e1f8f1bcdd49e20605bbc2fc0567018cd331c0b83a86328c7ce64c44f5871517000e703ab65704b8815e26edf886cbe10cee3bcfb243c2b7657d38d56fd552a2eeb1809fe59205fabecf91f577acd9213175292fd5ac97c3e8dab58c979478a57e5ed35b05546c93cecbd23600286e7b74077804a40d4bcb4b389e0732b49029f7bddf3f2dd03f125b3ebed956d39fe6112461fe46a1ba32f0e541cfd7728f121adf6df5a3a7f86e335b81ed78f74a1827dcf40aeb5e83f4261fb1265694c33efe2977a023c46f72d41e029f367d75d62ec5050e9f3cd46e7bdfc7bee053a363b072b29efd2124c7ecea86cfd92f357d95d5263eb47e7e5afc62dc99a7431d97ff72d756f778c3ec2210053ae3843c8d3ac6c273cd85434406105d9363eef2ffab8c6ecedad945933b28ca2ab654ce7051d5932a5f43cc17129b3b5e1fef3ff3e6a544d8fba5ca96f3ba5f1602380b89ae0fb34c02fb5da48c1a64a3546ba0107098091360e6cbe9f3359f832353703eeed32e2500b16dab8368eb44e9a8db4661cfa0e0d6439d16696d9302aa6970132d41d236b907ef4470253f56a1fe39ff99fd8badfe99d2c06c54a8141b07392a0034a7fd733b2a2dd16a7c573f1551f08916d27e02664ff3f33c09b8707cb54520353ef56d68a6c848d160578cb3acb525e5e166c1f2c4a372d48a01dcce1f69ad3669cdf90becbad017402672225a8be9de2839e60b5919869c5994deebebb522ee9d4421bd5eeca4e57bd602faf78e7b56cc29fae63e4b396d74b23fd4d9948daac0e833237ac7938d32e23657ecb78d7b1cb79277f7a5a900d2bd3eb4e9fb16ff47801a90f75cc0ade7f9cb8011e316526335e7697643f95389346544e186122d919b5821426bf6c8aeca19e7982be2d74933c1e73458cbe6cbb0f925a7c5a169608708dc9f99369c3902a8880a52603471ef4efdf28eae1a74998d9ff32ba09978808301bf2b50345b0afb241db28247d22871768684248cca7478a782cac9d07c8339bcc995c2860b4084ff9d46646e0430ebc7fb9cc7019935c26b39856a24bfa0b28537bf084cf8a669aeebcedfb2d97f3b138af9fae90a8fe61c1422e36f706037d0c63202a596f43e7d037283105923ae03605726cfcf3ae8dde6d7aa71407e9737680a26962bc4f461859142a83020991c4ee80faa286f44197b120c1054ef65374664bd27ffa9c1159a67eded8059acb7fdf95b4a1c8df3aacbf70be00f7134b473efaa2ef525797ae87acdc75968f67aa13997b008c5c34b96e551585c50f948050a8caa572474b626c91149561565fda3d8baee1c9676b5dd5916fec3e3811c91789fbf30a85c79c661bb469f68e9c0f4aaf92682572029013e11c682e3e5c670cd1c4e2e7ff4bc7fffa1a95e287791e0c9d491193b4094dd92de8b31b104651de556de9540dc47d23f8f4bd53612d06763240ffae20929a153c7643bba1ef77802c42f8a01cc643e2086cc28765e2c8a3136dfd60a0aa05c64ac73bb9825cffc2831a2a9a3f75be2e12df3400fef167b380af83f3ae65836aaf295d46bae4ceec90c148b56a14d45619a37360cc6647ef9d83a814bc79f5ad6f139d4e53d12b379d26cc8ac7183443e63a81d68decd9ff4442cc482e37923b7e0085a18302fd03072a2fc309b909d069fbb5bcb8d6e50e7df148f63de280e7991975bff650dab72b35e9dcd5fe11899ea59fb8d905780a3fc0b9e7759efe6299110be548d738729241d44db8fe327dec647628cc6594bc49fb93600322ebef6f33bff1e39b61e3107644e599799e369241ed38b327f30758266137f70975b66e9a982263d8e0e392474de04f882a466eddb58c2e32b577debbbaa54f3c9db679de05882504afbaff29edda8634aab10ca0ddae3f401ee5fe027b21b53d9e103cda7b37b6c6b37b321dc358bba97b0f0c906b2604f80ff4639727b5c9ec6176c836e86e4dfa891de944a62130fafc54ae6d7aecdda59f48c2b3f80168879a02439ff884ad5230063a66ffb4648d559d2da0288aaabc7e09325d4133c61367b806867482440a9e9b2da5d87b09a1139550c8ffe7fafdb7c6fe86a5d9a49295551832e191eeed2496bbd14f1fff4ec922c99f412ad444028cbd137a38300a0c511eb96428577db0ebf3249fa1e7532c87e4de6a9a93d0359d54a4d9884cadf6fa1c72f3eeee0991ac67180378f663e2d0604c47b0b12b0dd6655221069f300ef365a5f76a2535c4b34ad81b063894f6024afeafb1482cc83fb3754200e461a6f4e8843bc9be5de81dd33d80f475aa258ba67f3f0fdc2fe4808173b201cb87e12b6a1174ea2c7bba1edc588627bd7359dbacc4760f3fb4a09fe5bbcd5e92bd9e6136a7b2d1eb92733d3cd72fa2b0ac9d992af8a0c0ddb8c0f36e5727165182fa6788e4a3157e0510b84a9c58dedad3f7c36847b3f17444e27684c8143a9974c60c871042182c2108d60ad2b7450e350ba9f6934e5a8cc039ea8608604cafff2fe4e031c313d609c2ea03943515c6e2dd107d086fdf8561e99df5d7ac7e550fc8b1a9e76e5ee86b7bbc3441574ab5b384cd47d3a8cac74cb43069f02ad8beee4ffdbd383d7049f8ef4e00d8a2d09b9ea6a23215408f68bddfb67a3c40ab88eee81f1d12ce940fafa6bfefc55e53509beb01303cbad62408797c2aa19247a966f18841e2b7862425fb1a2c3ca22bdbc24d1b851f0229959a01cf0b62588c2b93d4932acd13ebcf1cee4784a605872bc4c060c332e66760e1c7035dfc70c00e3c0b630394cbaa1416b12598656937888944638523d7707a9d5ebf21bbda6ca256ad3e865e9bdd1b8c064f2a646a6df79c9954430b7b7dd073beeee2c7fdfd7d051a1b69253c8a75117413a0b1bd9c9b0d4f5de28be67d1ddbc91af38526869168f8a8229a93542e4c45c82020d2d6fe71a6ea41482ade2d2892037eb43811b89d31aa5c3bac3b999cac7b1c9e6e2e5456c92f79e5b3324ab5e32476c31fa776ffe96de1148e2a3d0e10dc2d9caf4746f8e5cf683b8f4cb64b51969f779f10cecaafdd8949963ff1ca01a2df642a7d75909cae8e3294d61376877c32610141ada513440ab8b775337511fd1ae215ad48173c9a68adc9ee078bdceedbc7acf2c67adc764f56853b44f57c75773b8f5ecab9c228aada39fdf083932eb1ed484972cb0a3b7be59a94d89e04d1b803efcc63f9422e11bc974196fe8eed62084cb6a29c6f9ed1578c4e38e828f7b9927038281d51e1209e6e06c4930f055cec5d48bdb83d49910f61d0494f3be95e14e6adc43451aee0046fedb7a561c855cfc4e2bbc498b98dacb1474f0add07d3d88a58a3f03a4fc2c91605e842f547bbf678bdcafef03f4a5f0c9c6baf1843bb7635f1faa8bb44ff8082aa324118859d139c36869e128e97091acfa7a3eab933423219e43bfef28feacb79d8a928253902e2c33adbd307afc03bb0debe54a1f1b8394cf7f46cbb01e813e9ce0bab15b4ec8cfd529a4cc985702000ae439ef608fad79601ba2de78470d97e17e4bb57039a6ddf1f777e34ef8dccd4358b4e66767d72f84ddb2b24c83a11df619f836a8761a442676f418d4636640837291f8a42dd4d881b31763287bfb7421dc4db5039fabdd0fe3749c64b7998340af0089a0d7bffd2059cb53a36d3c25b2021f233de97c390cf73c25c9d241b041e96d5c04934a60aa47b9a96ce7e348dd1bc7fb682b47b43b07e6b510d9ecc068f0f27813af2140dbb72fc548b01a9756bfe32937640d62f96ec4937d4a30d622e71f977ed60c33b127a2706e88e66c69a53b0c6b6518e16d61157852260f7551a708f2f2af47151286a090cfed0a159542eed9230a5941e6d49ff86bdf6b73675cba99b297092c85b9c542bb0478b3bbee47eeb029854ada587c5ec7fc9fa5cae69f0af559ee576ba00c9ef9eddd507b633b43cc92fdc537aea17793796cfa081e9498b5b1150ac9437d9c1f3578ff58eaa18d29f7f02a2a875f91921315a65b9eb1d82aad8f9603dffebcad326f87d18046fa18e4eea3ffc184e6d72287fd4c11c9be056e8de425f4ad497b77ef448d70a8dc63117c0a22abb729072c137186707d5f95e86089e45298b1fe37b0789eeef2023a5e0e9fe23a37040b29ed14006b25bbb1a94ded29abff558891072640c45f77eaf08743e0c38e63b062aba27bdb6bdd62ce5617cb5d27194acff566f96610e7a25e9f34bf119fba77d235d88f546bf4666b44f6a5183705b4c032ed58477dca3d7bca03c72447f69a51f59bda434270db2600e5a58f10d7052f651dc1652d537ebf10e89f91a208ced926ee3c552b810c7e4f1eafe6e80ad964165e0cca27819f8452cb0f637cb4fc0d34f35f190a0c45000afde654a21d8d69e48fa84eb48da7bb1f5d16700c4e6e092bf73071b1c3b649efa6f6fcfa5567dd0723ef9868fb1aaf8d076b9178c931f49353d7d1f3d901b3bad82b9d0842b25c26802fc5cdf9788bf9550114b41e0d2ae82fa7a67cd696c3d60a74e80e313315e945e232e93e5ef9b9a177c95e1e9349a23a7883a4cf19e5b3f8d6924b4f7d73dbde4773015b5382da33095c67a1303723ff5a7dac8dc995349f216f89e03d455061c0e5629263e997b4bce87283cbc172882afda1bbae17bec06646d8e7da0354b4839a3c56e6d3107ceef15238838961f4227eabe99bceeb0fafa09b4feda3f74d6495ad3f81a1a92db1b79b2e003596bd5b5b3ee1714dad1a4499dcc76100ccb9a91974ca0dcce263965b128f1e8d8534493cc26fd36dc97d7b7adcc350747723e1444a39a88b60f7310239d607ae9a10fa63b12b8b3af110e62917b056642407dddfdb2c1ce2ad68b80732a4553d372dcb82d517be3c5b1046cedd6c3eb1fa3531433dea856dfb7dd94e11e5751258de3cde50226d0743245e5be558a16fc0a54275e7dc5ed8fd560fb88ce2cde3de4f0777fda0048329334ecf6b6a1e6de0429368d76e33d94aba49b4b35a08fc477ce5e12bab2d37ce14e4a1316175e949dc3f48ebf7a2a9575f22df2e87fe9d5a9ec9afc620311c4bf610d7497d07b6a8bc6b83cc585c3f54b8c6935544c2c5b23a4c1ca71a07d998c95fb3b81c9f9b3d1c392e3c4cfa245964d4fba36b50d7a6111c19dcfc27c1c90a7f9caacb23420780d39b9c302b897b6541fcd1a90b084fb6380e610e1a4be87967d42ff3e28d7de9a29170108107fb5ea801d1a7dfffe7ee69422c2b48ff79ffe617c38a2ea23c611450a374f9ef38646c4b4157e6b53354f01eb69fe64d345585d361008e88513a3c0db7a15d9c4d03fa28f5fc5aa89f69e0a5b2676e8ec4fe272dbfcf422fdee67f427f806285ace9235a5f667080f178da3977e8756d94406a626bbbd0f1964ae244edd325e87aa232f72a0370ecd82c79fd313ab2157a40eb666720bd71b248b7747c045e7c9e3e7d3edb3a15a38989008d9d858e7956ca79fc50e67a99190847272123331c2d8ab10f616805e0e55a35e77c1ea1e58d254120603cf200b8f97dfcf8488ba950cd52ebc51b93132ddcdaff9ea646fe89df6c4fb5971383255b5e00debd71f146c7daa9161eb63ed03d11d864708357d1af27280ece94e864422231c811e7098d6f4b09e1d7a3eec6eb2f91a166c0f3258781fb69fca9be7dfdddde1b9f5769b1134d4118d1fd809b144f3fbb3ba4f2100042dcaa7862c5c4dc561bb3b5f81379772f20b80f25a60228f0bcba4cf608b138796b29dc901e521d1d37c3d6a190260fb01b038ef5515409d4ed1aaef64ea7c16f2cdcedfaf597e04ec703e1428a8ef85eeb77b116dfcf67c608ca7919f415c0165794d05e988e82c7045e80edd4510bbdb3ac312e9f3e70083aa30104f78ae1d291ae2cbd8b176ef33ecdb712035f94443c585282e475d1b69f55dd6db264ddf8c09bfcb554701bba279dc7c7449de273d48dec6ee642c9ba9b64bd09482fe491f948fcc41518bc3f1e5983c2d81c8d8cb704c8c9ee9d4650dcc883e8119bf5684f2efe98529df37019810f7d5d6f48d3574421a6b34559754895cf0c7705a737b8a41394eefcb9ec0ae8cbc9725d081483fd21b00ee791b077fc8ba7d86241ea6d7b0febc062cbbb2688ce30a579e52f0812d6049fe40b0ec26bde1ee41b2e65d22d52691f74c5a5c67918437ea42b7e90a15cbd8134d9f1c5a8073b61657e5fe8a77a420565045dc1d6731b559e040ba5eb22e07bd4d55ee2ae4dd301030569df890fd1a33bd7d5d232431404217bd3008eacda7ecc25a5e4ed6742af400f122283455e0aea6926d137ce2b163746730566f3f98f8b76c2fc5fa28ad825c248a1eeb2c8685085ef49f4de4cee22c2c9d0c537246b0d3c48bcf5717ecc9ffbd01a55b6b6fa99f183deed041fed823a16c7ee5f811af60a52d654f92c736ebc1dfc240f94dafe6014e8f173019c62d31cdb1c0c881227d5c952ee8f27ca5981cda23e19433fde809633b864abc554014e60994c777998020276c8128294433db0a50becfc3422168c454c4b24413f8fa956109bd57254f92e2dd4c791d3d29297059f8fd756bb1590684e675ac53ef0c3398e0e8f5fb578abc5bb8b0cf30e290856a21d2804cd3ea4f81f64367e57a84bacbd798dd070c21df4ed4fcac777f2559caa3444b773898df05bdd21dea571bc2531ca35f3687c140e0b718b01e6c1137c25d362d4bce97e121174a48114f84f550d093266aec6292a9938a0d0300d4959c5d200f889242431a072ee179a16ddb7f4164d6c935d900f832b0ba22ed987db1b8a3fdcf63530369a0358f400ad4cd8578360256cc4576ad4d029eeb70d01cca7ef9f12867303794d24a21ad4e105e814227f02ff7f48a6f940ab56f5c38aaa1640cff1efc5042ac47d1749618c7771b94cbea3349e04c1bd7656951fa7f96efaefe30a856671729bc6e79c2a49da91db7d8294bcb60cc120626882089b0c263497be1782fe26ce330e54dd52d50d7e1778f44d989c9a5f0ffd029db8b8765f6cfc44737a2b15b48e2126df6fd670352d4c0f98504cc31a677961e850a2c4d81acfcd71eacc6608522825f371b8ad260e7e01f2aab0d77712aa2834d623d82bfa2f67baa3eecf25228141335934bdbd717e93f82cd71597daddfde1095a785f7203adc93e0d927426ac8cee2a110635ee3946e2bf56e2b30acf70624f025075356688f8563b7dd6bee7c506a9f6acae6b9337b60480d176b697998c510e6e920705d71d686a3ee7371dfc557a704dc8f8bd48f9414481a382fc9cf39f90ca2be6d40f45d65db6a8bfbdb344f52fce725a58c31109b973c7d94e4e729e02edb9d2c0d11b2344e8a1b7236bf94328f3f1d1b5190538705ce0e3444a576be1bc68302dcad6a8f9f355d87cc4c6954f49e6bac9e88dbcde1749b39ea5231257869b91054baa54722b74862a00ca08fb15f82e1a96e489863c95e35653900830e00fa4e0b1ffdf8b5b1d912d654b8f78919ed63b639c9afd6014d223f586b49437c803f05ce6a74856b88ae65254940b53497a47ef6f56d40d3a347cfc83ffa10120faff99cd23526b454f4f61947a06decd60aa114781772820d0399f9f53963f2d3e97caf30eaaa4dc20a7866cee00fa864add2355cc6d13a066af628d108f84903e1118e4e20b0527f0634aae7bbe6f76e84ac4050974398abb74161c12a3af2ade9945a253eb5a6710ab1fc5c152bf92d94e3b8946a9bbc7c6da933cdb68609721caf24db7f208f437520c3224ba4e59ba835a4f97ab4205001b23956888f646c12901f972d219a40eade2f7b7e31bb461acdb3dd5e3c743e7ae02ecf734be95d18bd0801936b05ad87e136339483ebfcff2b764f98d404999bea0429874b3cf3e325b36847c0afd56e2c46e54b998e1e2787a869fdabbba3a0b6ec5dd3e661a1a8b03ca31f9cb27ab2f02fbf7ea05514d6fc6076518987b7a1f83f15898b0df33bcc6b1d3c095648e859431170ef561ea4f576cb54c4889c92f34e4142f81c0de528db7b2d4c1fcaa5b802af424d063320f4baacfb5c6c596859bd3429c1bc8542139e4a34e78798ceb38d9ea02f8a2bdd856739ad47cf870baf573ab513263c7c4360fad23d9933cbe37f49471b1a5190da03149f36f7d8175ad243d1d77c4dd7443e2cc84019d1fa6975bbb024fdf1889b06b2d706ef7f8bbe84cbea7cad35cd3d5a22e03283942b73bcdd7ac791cec8ca442fdab70fd0d645117ba06490377f34d90792ebd26a53342510a1ec311d6027271275c149d7c36f24bbd1fdf45281009b94f80c663a7094578ac43ff922be479f797186105dd5159dd2cef9d727a0b3f9996eb4e85480c0493bb5e65b732f5e0d1c658e7659475cd5b7407e05c34e0b3ac243dc218fa2574045559e8f01d8f46fbf2d9bc8b5b325f74671dc5060ee9b3406ad0a503b2d90b574302e0bbc5137ba4845c87a1bded3907c481a6fe7678c1a941ab7401014577c2c3e69ce0f0c82357f645cc33f67018a45873308dd8b47341c26502a84fa39ee890603178bd34fba8f3b85f0fe96937e3fb77998f79172c5f16a86b5bdbf935ca41e7995cb4e4ec70cf9ddb1ec8fa54151081a848c9930cf4a0b6941807489a66e1014814b95f669abecbbbd0dd826e2d763290beccf172bc9ef4a6de7cb1b61d510a452c5c3c6ce734cf64b05e344dcc894b92d57280d9a41fa8dd0ea618c695110e27074ea32afec6e349b055f93477dfc6300a7d347d618d1f50dbdeded9ebc7b69fe46468615fcc47efec674015bd416d3fab51379db7cc61b380e7876b1f674f11313a9d63c90d7e69325fa6b39265fce52c27899dee75aa5e27c5fc1f16528e81d5a48047346dcecf3dcb926f78433041140e0fccf7a0cbfa8c2c0e1ff4de93229ddf37b10a7721f6bfc7b849916e6ab1f9a899cb5a4edd2b3c3de56549a7d5af02a8dd2f4330588e2b5b048c04b3fc5a0594e632334395e018101f4df0368353107f3275b8e1c70cdcd215601d3c7ccca60c03672085791acc9625d2097c1b27aee6faae4aa50fb0c9df43d68e1efda9c2877c805e9e0ad746d82e23bba8e8b6227a7ac96d72b90c753868ee4ba5379b852897fadffacd0149093a77a137e2a43bb72d06e0503e55d459bc423ac46b6d0f150a49af60ce23cab7d4f1d23373840f90de6104b71fdeaa3087311d982e207dff25d9f5e22132446222a60411fc85eae93bf004b6b4d618a22ccda4fb408a1927d58988dbef16f3da65ab44ce5e6bdb6d68ccd2c789b7f622a79503c88c405ad5c868c2e0af48171cbe2e03e20690e4bf9bc447151e60be81af0ff9b2f5cf8396989bbddfb633712cb41970140e3d4335200a2ff94a6ab1e5281e418971d283039d76f734409c5a1641bda00d14c21cdf36f01004fced805b0c134eda14044be5ece2f6a5f5d777a79613216b4d0eeacc7e1dc043030f89a9c64b02b87cc178ca289ba6262a3f8597cb24fa51c5c18e7d70de71d6ad7fed2190dd6db3fcced02f3e18c32381d89135efde64f9e81abe60f0a7ca5aad2154cbc400d5b89803cc271dfe46ce571f477680fd66caaffcd21cd08899f94910e7c6e620c143b4457c9477846414c27a5e60a5b6b55454f71271948984891c730dadc0d582cdf7b3b0c6ed77b6aa77f0338f23afd10072236e2588b0d82cbe54b2aa979e88dda293e5a102b922cc22337cf3a0eb537008f3270e7178a7d70178b77b120e0b706378a74a63148688c187102c34b203d96b38f193df7aa92c9afc13d021fc612237a2b79c0061e99f2a25f5fa312a6c904da6394771886ad2280f324a719d581ac75594309f85ef58f7264ff3fd00690e16f5f58ab4fc322ba03fa6d97993f0ae65c773b55767df81cf6b6b143a9392a39e6dce9a22c637c5f0216f26628874fa5083e7618f813fd2de10cb28218c08c2234a4e88c7569f48cf8290d4b2352391df02e85b95606662814f786119b1348b9a91b3b931f872d224e9bf8597d9068e34adac848634f1d5fbe520dddcf88529d429bf2136d6c7cf0b42bd43bd39fb2918e954ec0a2974b79cea2ba69223618c2c8c6aeb82096b246e5e5ece6f5aa6ca811b22e789eb331150333158851b9933d05b13ca4360798ccbb3e64121bb1f6e3e9b83ee1ad645fa58098c4b94d5850f42df4d7e114434c66aa40ebe23c61f8646304a62e490156b146e5dc7dc601c050c5e02e0cfe511d4fa232ee24eb03f365908c5386ab3f97e4becc21ab798fa9e8014c71c3237e9524c0ec17af5b31c039b4db28d65587a00d791d6ca3d9c654cbb949708b3bd75eb7a2cb6d07175ff9152f3c1f3e46e9743375b1825fef57c83bf419e97a3b064a186b1f9171dd46b0020e0e4a729f9fa1aa11338ec33fe419c2f5c99ecf4a6b12d3ba9215693859919be7c6d01dab1869dec1cfc02e9b4d428b817014c2ca9aec5ffb9f4f89f4c6f6e4498bcc53ca9e22ce0f8242e3e3ec10c13c8fcc935e3d6ee8be1b31b293ccda84404531661db13d064fd0d2c9c0f287bf31d2578b763637e9341ee086057677f4c63f53400b87f9b5cd05093f4ebb8ef534e39ac0eb9ad232a0e950e1b9368d340cfefc2cfdcfd15a3f9b512f4e33f59ad9579948fc7ef7ad6357c62e8e3acc11facf9187d7886467e880f0bac61fe9e0281c03f57aadeaaa87ad7f94b0aa316f42293d8d6c2ece043f2733e869d72aa0d36ddb547b416bfb351cb0e39097d37fe050986b8f346e31f8073e02b60cff2369d755dc81e9a81a361a548b90f36c45fb3b6c4eb5ba15cd650efb71804ada4bba351ddd1f0f18605b3c82e8ce7ca81bf64d825c49304b06a8bba37f146eb95afb4338228633a4c8161db8564791962f77359ac5425e461b62cca0665706e9203430e2e2f796c040374e0ec56d304dd95aeb2d4a6c28454b803bb9618e34aa6edc96323bb67321b4bd8a51f353a3b692fd7facac45fc4458aaadd8e060e1c7dc3d0aaed0ef3cb129f4a9f45928c5345938f103eacc17985e64e0577bd3046afe065d87d940c4123a02be76c9848204bfa4d0e393c75abecbd7b78ce2b61800637ca6ab817246ba15df9be6cf2553d2ebe002218b69211b0fdab5aea48c767784eff2dd5ae8463ddcf92e2b04ced9090b2cdb9b0877cb7974c99e4dffe63de71cd969f3fdc0596d5f7766884f4cfe92cedafa7b1fc4b122b379a75fa619b632ad6ef495d367d02e3a8544acc483a87a2be46f23fa22e9d2fc4afc38eaed647553e2374b8b0314e583605f78c6832a128156e9701bac61aa80a69bdfdfd3a1830729496ee85693f3722674cb6c245f001811aaa2d0e0dbcc476dd540e23f7bf8426fb188af76b7848e6b0438ca2cb484d550fc9a016bc3cf1bdb18a30e548d61328deae25b625af7ca920397bc5a3eddf236ea805bdac1325024d7a1f8bc9a05e7c7ec7651671733718b67be7605877564240e2e32940d790fe247ea04e316ca38c17dd085d9a3be992a339df38ae3a8a127c48aa415541ca5d8804e12c07b9d6faa08b031cd2b90f78e5e4a3690fa0d1334b1d6965ffa61d948082a92b0d10cad624e4312361225b7b6fdd2b3cf298fdbfd747a2504976a3d188760c1873d95d9c7a5c5bc5fbc45a3e26d8587c43cf1842e14919f8c179a8b57ca895691fd54886df722b01390d4811b3324d9376c067e9da5415ae6d1c13ec163169f68b424d18c37d7590408f8aa389b2ec0b99302ca46d5b50d9a9f1f22824cc3831bdb7341b40968f9f1d98d479131d0d52a7fc615ab9a9890b2735723bd50457dc05d9992d9de89a4a9439c470559d25f40b47776c2a24498545d628299e9f92201e321fd312579d2382ab88e1cd69fe5f972814bfd92eb6253ea38af2124a75c5cd042cbf15f5cb5ec5cb4c29f869d97110bdd6927b08784d573f09f1f7226667b83fd8f7df972b8581a62066bd1564e7dd93c40d4a7c7968ceb8d9c31fbfed61e19ad9821c9b7b30a4fdeeb67efb8bde7e92b5d4e389ea1912f882d57b0ee7acca62ee0eb86c8c0919d104470aade4092e93b66bd9564408831fb1400fba9ac01c8dfaa892d74827ba53209cc7e9aa609829a85c8e119e85119144e51849b884f9e901691b3cf41762be8e44f1474a1259495018a36f01e199d18640d08a09a82038e4d71c0bf5ea73685319f6ef593940d8352a331e33bab1bb2ae8b5a0650ea0a6c155f82a990e541e75378e8ab9b7bede8603e6f89110d0667ac8e0db3ee7c53c7690d9d83d741dd2a2eee6f9b03817268e59505162acfe92a177f66aa59ffd1610dba98e222d1a2910a3ad1163dbbb051af626d28269180be18c3b381f28e44ce41dcf24013d0db896a3f5a162a5848ccc9522b3f294fe14a5916b50524f69def9da82ad6371d342f25a1c4f0b5478f5280fedfd9564a2513c72b9d45d341e3f3d76c38902c78050211ed8a9948dd7978f9efe1ee070af7d2850b1fe19959a70569b054152e117381443e16311e57d6833747088f7c70207a9b464d9f72662d3ae47a6876c9b4837e8bb9c44881fcf841e7f9166cc18429eb8d43147286c6cb779c399a0621ecb991e41e28683369f3c85494acfaee69821d239c152f9bd189be688fceab481a9388460ef5556a6fc2dcc9375d4ae30a7f5518d3b55731ff1f95972f1ebcb8fe07c4b2239d2cfaf5363ad56bcc8bf059c9e8538cf30a35e25f75fc23f48d5e7de2ae23de0159a4c530a491ce254d8507192156a8ffa7df14fd80be432b416638393f11d7173d88536de6943769b0aa16b8ce52194061448e6fc0c906897b44f5cabaf08ee3c5ebc8a7492a2ff916705a1b13f96353d1aaff300c7d232f6643559a03a19f63af4e0a64bbcad33d39341d12b4b1967f0a003701a73c134c5a242c6856f7918e50f3e6d6b3d1e78becbed6b17e6418029afb77a82b7b1e32a13010b37ea631a42a4f19aab0889b905164aaa73ce88f3e823b8e8fe178787faa38e34cecf4dfcaf9b5a71f330efa17bf67983423cabfa2686e184648b556e263fe99bbe76c5195958e52a05b9657e905dab5eba45de83b1abf54ba46532414d619b0bfcb4e5cf52292dce736b5fadfe849c1e46f8c7d304152de78883b3e2a1d0b96afa33451fe9d76e1597688f220f85ae357b6074970aa31f0e51bf0cc9ef964595a49d591244030571cbbdecd736eb2c5d5e4a663d6fa19d5ac057b69f29308316d25b3df72576aed6ab98e05573fd2b8e143d7a63b6c5e97708ee616522a04c4efa8a472d4781660a2084006d247bd366126de0044b80bd9e85440f70d07fa9b7a1c23cf8d8bb06d5a8d0e90b43c8f089ee1b1f8b5dd10a7b70a88d20cc7cd1b47cfb2a445adfe9eea99c6bdac1f3115893ec778c61626dcd3799dc2fbfade0c517200dcf20b0648a9b737f150e012274829d04c8465810ca1fd7502920c00e59e9fce1fa8800898a479421fcf010d6d2d2a22436b46d1419db3d11fccc31261d9ddb934a3737f9ba90ef4bae261d6cd06b19f8405702b6c245932166f387ee379aa73ce558ae03b44c44b5f9925eb8beffee6a1bfdf702245f5848985b8ec8b848d04553b0a6e108918e0e1ca30fca85b4b5531dbe690ad4187c7f17ddc851f112e14a0b80649cc1155ef23c442066783ef0ec379c79618a46833406864e7f6927ef15f6c9ede8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
