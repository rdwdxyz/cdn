<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf7c3c0c08dcb3c190c171b9b981f5272277af46527e3d726ad7e7a61019d3ab196a7db7a24748d16dee9d9bb62fbd798aa26571a1f4ba127810ce004a0b280e4fbd1141965d0c66fcc321ac151312afe3015c4468e1863d1c5c0569dc13a31d89ddddb08c8adbc039ab66c86ad076e6993cd8d74e932572e5e72218a09389a403068778753921ded2ddc9e8b99cafc4ffb8e95eb07d48274b1c4cb2d7c4a317b4916684acde38a004ee4517b8a07551ef720e3aa8b59464060e59327d224ad3c63bd9b90b7f47c205890e31c03cbddf82b82e402ba91b6e434c03c3cc776fee38a7c4ec23ac079218d987d9318e8ea4006e408e3a46ea2a3ea691e846ad964608f0c7669d2779a37e33178059eec6d2120a90b53b29e1a443f2149df6b9330d60fe3d8bb830c555d555c603bb23eaead598a63dcab0f1825b05c0b7b80fe2a0bdc3de1d3f79860d0c1395865a6498854c61b7f7066e692feebd9cb69dc85dfd68bbc839906eed3df4e399dee1d6fe1550d85016b0c0277a6c93545dc6a7dbbaff80bb714551a31976dc51557803c8c1e13532ef1e1d435fcc4c245cf2bea50fb1094f92fe82e09e1b5d00fb92e28ca27e415e252a662a45d59a791762b381e169b440976139a2f9a8638a8063a0e82c7a9a9db49d95fdba8a21cb8775507972cf144f579c9b4791f34f9dc290131d95857cad91675d345011134c4edac0eb287dc94f7e55764d6636c4c9bca8d641bbe61fb1e3423af235530b8f9f0f159afcc66082916600714d8f4325b9bd78b29cd5a9d19b0f2470cc17a861edc186258ba193ee969037d35d72bb28a8794fe723bdf072dcc4e5ae691342543833c5c31299b1cd049ce8c81e4f8779c8e43331aa043b468428514a6cbe1a9a0aa8fdf2f6604237b44ac23c5191de308147fb4d9b73b0ee452c1ef7ee3cc90b6e1ac9fc91205b1cf8cdffb1539bb970b3eaf4cf84b82a93d9673eb5620b41aebc9560ffad855b83d0c7523dca9f9d476c43d2503ecc54d854dfd596f69a93b27529d9dd082ddd8b8f6e04d161d5ea7e4e780c3f395dc277ccd9b5828ce3d2528b84e04140f5dc59d5d741830eba52f994b279371c76855bcc7a05399a8327e3a8b9d0fb1bfd20382e44d7c78aab5276967363fc6c2d24e61506a07c0938196c4e9f466ac2b4d11d7a3be6908bf50f81cd9444df8d297bab7c063f279e5f9a4e79e582aaf35a874d2fe4f4c7111e3f36dbd1d6a38c29c2b391b60e8620d7eb4d545ee4ec69084c099d78e943a242945d94aa08c104c96422d450f5405dfd5e4a6f46e76fdff8f2969439984a1db0517e7c9a4adc45c5e06634a99dc0dbd1231723af960653e808a422c21b564963f19f17eadd5e45368601ff5666614fc8eaa3897be47b260c2f99270000f82ad5bd3b119c14a32a446b30eaedac97d3205e2b4b1f8d1bc3567f9fcd3e6e78b94e5da8cc3b63c9264be4422f1c740e8e7ec1e554bb609f1828464c7f203af710649ebe12362cd583697e59a7958dfbb12399d860b7cc3798b2191c4647d39049942b60aee3450e00ca0ced5463b3701cd243e12061c095e0966751ea524e73a724957428ace80daadaf52db86790b5d8e9271e2b148ecc451ff35c7e86399e4349a0844e6b1fc672d0d034bf0711b23783fd378c3a237dd094c8a1eaa7756dde1b2c56dab4b5a117bd2b6e6bdb8e7e5ba9e4d8305c4210a6003386579ef197695343aa730965fd1cdba1eafee8b2a81dc044188803a5efffe2bad2eb05afa98ef6b50dc2d14ea44faee9480831c9efad259a8c97553139fcdb1214ff246936803fce103e9d3d90d85b0c3fadf340626bca0fb7aac93d20af95597c8404e81808d64b749ab26c4bf8f9571936bd0d218827ed3bf3592b28c872afd0db62256b7b3766453b222c9045bf4aa54291b306dc0e578f2ce6fc77cdf080f9e06f7cb19f7ea7b1d56252b60ba8702e12d2230e815505a2352ca7d051fe630a2ab1f81e410c810a2e5145529c8477a7d55b73d70b59d92b4c8eb81ec3110933466a910d2e2ba19c2f82bdec39569371fca7fb12c916971cd25f9198ec11e60a9a3c566ddc7081f891e5b388158f52c82cd8a9218c12432c40d80dde78bd0d8d16bc5a9ddeb4dc983cf3878cdfad16f700c16fd05c186dea03362496cf21380cbad46622e5d77c6226317a52c7e9d5addfb3949572cf876b000c7791e99cb0085779e21a8b76e7e41e9cf8eba053e0b3c39ed392d135bffff26ea9fe499dd7154bd7ea4579c0a1c692a8dff9fc976d811af1b5d2ed757edaf246e65b1b9bb4cd2ede3a5b3665b14a8de4eb8b6e8bcb676462f35f47a0ae9de79940798c0efc5f26d21364201e80b9f8e1b0cf92e5af2d7a0667ea872394eab402342ff78ee4c7aa766fc3d81d54daab4d4be206af8800504d28973597381004dd9f3a0a0d238e5a4818112637fb2a46f3548374c064887674e696adef5bbc670bc98e15b2082c09cdcb0ebf64c2a7e035f0653caf95bb62e835f7af767f7709557c1e874ad6769f82e94177478ac51eaebe88b27ca9d3fde3192578737432e8e31fcacac3e0dcb79493151f3d44dc3fa2c68b157c28363815ab30b11ffedd54a5763829c727a6ef0cdeabecd4457c72a7c25faf06bcaefd3650f219e21213d89924cd794793c97ac44da44d715e8f9b5fe68e7cdb089f09760874e243b648d041e827d5ec640d06e8a163c24675facebc930f5543458749a4492eebaa79dbad6b075c27a20a79cab5b50b504c5196064056f899963f4bd9990678f68489df3135c07570fe64e6ecdf8818ba6fa7d316c9384e75603ee216446f6617261ae95b4a766092b7e7c74fbf9c373fb474e823a25a45fa4139516028b64a434a9d7f213ed89c3bcd6489fa2bee8b3b5be351492fa66e20c5457c8270704e0c1ba6120c8bd9ded38dc1f6a3000c16bd631471d4f320bef8ce98f08c9cb55ef3008d636891e21683951ebe460b7f71a373a60dfee2ad7b1d6ec5016b910adad764ba1c0a2ec391ad9f72a125c3089f8dcc0c091c555859f7dfb394be829f4e178df6c7ea56afecf97733cafb1957eb7493a2653cd9e74e4a8dc8ca309cb1e43a0746433dfdff4598c2bb4954cf2086bb7b0a8bf29b1d51812b05cd42d1dd57fc98dece10133d20860b97f788f74ffa3e1f4ebbd32278aea18bcbd06ac1be9c042a7ab794464839d180a9c6846cc63fb774bab989fbc72bf9978ce7d1fa1fc281b4cdc9ec14f47ab30a86d9b3c79c79eca93690eba2174b1f89f18e49cfaba8dfd3871da8e7aff72627d01cf700d4150f97311569a459f4a8222dfcd4dbed1aa8a745278d26f9629a20bc71051979348281e9bc191563da906bdc631a571e00d28d2cd752956bfa460b17cc43ec4298fcaa57176419618c92345c7c5d3e9cb4e52ab0106015828e140b15d56cc7b0352f407344853ad0e9085d1561101046ac3dca6ba0206b17a26c0d08d454a169b098eeb3620c73463d3ec3038d9bc735483318e5c07e169a7505193b025c70d854c3d9235f6c04c03d7c83f45b296cc74d3880cbf12444b0833a7208af2e1701a9ea5e8dc33411267a8a79e085220ac435b233cec29d5c73f394057fb9e54cda24c723cd1efc61ba283d83ce708fafc60c2e2f9817921cb43c7b39696adaa49aafaf48e8d055170c12afbfccc73e949e9ff0d0968330f7def6ffa490244a0ee49e8b73bedf78d968849719ac1bd322db1ed4a595b4cb95d1db8f48853133b1ab42d180bdb5d3be78c2df3bb3aab93a6affcdc7148c32f5678f6f91656b135d2fc40ba7acb228f75a9803e2aa4047d9863257089d716177a5c23215d8f3b9be9d10d5ae64c9fe41a5f65a13588c1c576810d58ceaada4a9481c8579488bc3d6db0c04c09748bbee17388c5e226d09a91ae7b93bd6db8c95a4cfe48af799f60a13c1db5dcfb4601bf4d5b41d6cb48c8e2b5c3661f43c60793dcf33c3bf9209126fc25e61f59349bb4097f7dbfcb153a42c52f6660556820eb03a78f630d6fdf922bc3992b3dd49476e82901d794e45e0f57e96cf9cd6894fa5aa1381ff401a26c76267e362a7c05c93a372bdbec41d14c1ce9086324536afedbf6dbedd4fd149fc56fe651d077113ad0ac7a86ecf76d71b0a4fb6ea429d3333d66b8d6d18fa86bfa1646c25748674191aca786daf0f6b01783b228cc3b045fd9a8c95751a4f2f400d1f63d76495ba0ee491b3af8cb03e6e7e19051d53c275220351c2e940cad185c98b062ab2ad2a72db77a6e42e0ced4caeedb070f05b6100f5ef830e9a540fb29565bf9e8b5b55fe3cbeba6f1525d34a230603199fe0b77ab39c48840ae0948e5556185539b9962016460657a17fce86989fafb0992999ab56062284f1f0bf3388ba2528cbbe22dbffe53ee5e4e5b995d3a3490343d16070f820f85fc252af150e5a69b0e37a8f5d7c5eb8c42783311c935e9f0034c12957a82deb4e1eca4ebb39af72bd47a729f87f93cb6267e4155e033460a0d15331bfb725f9475ab2326f8095474eb13d7bd8355fb4ea1f4f040ade3d95c5516ecdc6ba5c8b922f3292933ecca6496f8c07a49eba212dd315dbb92c626e61101ff297be96e551c28a975f73b0dcfa434ae17ced1c7efda42d7159a9559e4187c535af60d7ad8d5660248869b37d465b1c35fff2145acf8299e780ca52c67e2f53db60b4179ccf7180d96ba1acfce532eb100843e2aadcbf83742a3463f7e1316a5377f48338e3764ad017ed13b0aba949cba8ff5a865da1cf254c585abecc202a661e8617e0bd25634b44f0c985363c629d327385a87a079d2d955b0006baed58dfac599814fa9b59365654ce52a6c7675f6bdfd2862d4ad8c52652e56917d15e7c97e7fb31966a5cccea5b6ca6276378c62088440ae5d8d7cb651e33f74ea136c697a29d095e75bbbd101120da904a7a92d408aaad0c6333bc46ff4b202af1a3b8510e4ec5d072c1bb70da50a74744a24a28a34d82bef4334a7343d34cf141dc0c589db09cedafcbc47836b6244fa9280bf415d2d741d24adc98bf87804231ab192af9f83e8e646da1a49ed0b4439dfb5405773dae9b0e13656b1bfefca585a385b88232806f3a22e19e14110a6aed4d1581b15d7aa6b27bc9dd5560c0aef1063535542b7e01051be1df4de7667f8ab490af342b37464f1c06674c2d7c6629d2da877b9e55f9a3cb5accfba9f9e4a31f9f4da36609c566d7268726e43c60ce4a8a340269e34e081abcdfd699eb3115bbc1b6be7bf140d7c8de8689eef2646799d42ab4b08b63f00846b56706750b5b7d91271f77ad39f52e00e944f72a0b67354808235c95fcd6925d8da332b13c1485173273ed30b2223eecefeab27b60fdd5438cbad64a80d792fe8e0a1e0ad1019857811a03a9d1a3b91245e7ed5a6d9fc0141bdcf01d6fb6526d2d4d173a9aec195b314a22399a1a7f0b7e8e56ddfb1f837e3ecf0924e64bb0ad90f7ddfcf9e2bebb5638605f2fc72b72f5d3e428cd650311d40b02be3aa24932154143fa3fc900759c905a32ee3c5966870deb48339276721e87aa2ad15f19966b49e9ebf8ef38cb14770d885e66965d6505f4e5ad65bff762ba0ce6b2bbcb1ec1b7da3748243875b7ba7d49082d7adc4c18a3ac2310055d0ef574207aa39361e313f73bea177928a4c6b4e16b563b1be6665243797a431f2ad1aea7d879ff63eddb10591d9d54ad68166ded13e5982603fa3c5ad8ddb0099076f6697d09b6cfb49e44c856c9f6132e8de69637d983c08ed7374a6c0eedc7c0f087364e2ac165e5025c5dd2fbc6781522c5af363330c8bd36f650b1da71773ab51ac8f1224bf1893e4bec6a6fa5354ec6fafcd02f62b6a6f31c4b4d41ddbcea35841a69d836bed8ffe5a278957b800f2aa109b1d32710e57e2778cc166b472e81ac70f03419e632ce963e869c437c94a913846cc4bcf33f65f121cc71cf81543437918fc7f6ca91873da959f051b6893be9580ed2b0c23861108c234eabf706767ad384323d389e2e9ca1f663900e34e0cc3eeaefda44494e2f078cfc81933c84c103b1a74b3466313ca3bce4476640ac96d5c0de7e4ef2251b719fefe5534ab086206dec688e615dc1a37afc94fcb40fa4734218eeaa862eedc4df173412e977c00c3284440c90f0a7427b2945283da0639f1aada8c17786d3fa2a6cd32da51b04a8a336d1c758947c1b429c9fc1e1ba28a40dc0211391d71b7e66d004e5efb4c8eb7d7024a533c0975724c24c9063596e3e89f62ca20afd768485a746b6a1a17694f7e819d3ecc31d14aa6dea9d023f69a05ced14d72c15da31c7b3886f3323a211de78c18f9407a158241baf1cdc70260b0b9b72b35eed19cf1377acc30e93abbff27f8cc2b4376c9db53707e54a77f17c1d708b44d0bee9bd1cd83e2622303ca3d3b71ee0a362f4c08027bdaad557990e8bee450656bde1e357b99c5f54c9f6248658d06c708f983f44df60c5e243cb44b6568ca02bb8e18fe1a883a0f10caf154bf4957e82c422c1ea82baa1057759ceaee9b2ca4104198586d571fbf82d8e2ff5e2f2dbfbbc42b5855aaa5244d30ec86b85edc98381ff2bba8f672415e7b5cc9b43a25409bc3ff6346d8fa73cffb3fda39bb690adfd2060711cdd2290e35760392e8c145a3166c1437030a1783b231fd6496f247c86e09d47959b911e4a15636d2ff7bb3d88f213812b38afa0cd39a69fd0d80ea52b4168773029437e69d47434aef0a2b0257298079411e1aa7260c816273becc36ac4c866df6588d922cc853eafb9d4ce8946ce453dbe1359f2e1c2b343aa27a489fe4d03498c2f25a2ad05f55bed4b1e4d2d5b8dff4db89b02bc237bc8d46cca929a9e5770b7f6e18f42d893243b0a0d265210bff9246c96b028087d56c79ce059dc7fca0e55f68790309434e45b9326b2108f957db604cc709b87f05495b80f88a01c45dc8b854ecd4c46a0ccfb205cd9ff7946af0030bb7513f39b3e79a17da6b5806be7730671524530c341f11f750f12582a6efceb41e5f4cf12fc6877151a656874a14a3448e62d9848d595a4b3d7ee3831405b68efbe65b4d4753106c69cd1915ce7f79faf370b9319e2503b7cb8ac8f295689d8c084d41758138d1fcb18ae3c17adc094ddf2c5679f34169da291cd1254c79c0185bb525c46591eec96e51a40fc8deb5f88fc2fd7acfb1552ba9a683b425699c9c1d31cb0f32f59e62f2622c1a06ce8804d7cef2f98591a6bb371bbc09bbc264bac341d3ab34c92ca3d3bbb8f85c3af804554389e12b6b781c8c158bad4ce6982dc269f0fa35560e16f2b088cfd636fcd71b945682919c53a26223a4c19a16d44577178e29f80511ccdb0fc56b93ba546ed2403af4b4102e9f665e3205867c799e89ecc290f18868871872315930483d499ec16bc2daebf0cbde9b704475b9986e069838a571b002ff0f902f1fa1eb67df15297ac02c62803c1d81225a795d7fd1fdb7e9de0841c7eaa6a77f96c1ee2f64f6513427eea7f7fdffef04f4ef4104aa8ae40a3f937b33150fb4b51468fd9f16e4c2bd9d74f31d23e84c81bd43ddbb61ca35edd949098eda8d3803d05e60b896413ad83478c65f7510d467533fa893d33b8df9db21d62d4ba04976734eaccb736ddfa3eabe62edee2c2830af532377c6d6bdb3aee2afaad4363a2ad1941969a78817c58f7693d872519603e949ef5bafee3582cfc9dc0e645eb145ece298ad1e5fd20a982da2fdfd2c58ce3dae011d4e33321b467f842452ec9bfbc115c51557f74cbcba9ead11f58073755e57bbc44f4a6ab0757c4ccbcd21d7175696957c29e2635421908a9247deea3a8a65ab611a2214e1e389a35adcc37234b205ad691cd6bc6d86be2a3877ff161e8c6e610d18d93df2f387c77cb537e99e5bae65867f66a8f699604ee582c2fd69fc567a93eae3390d703f3776e393304f588407ab044b9fc2d7d509b966611f4fefb8f88e86ca751783246447b77a161d0517e438ec2a35832be28020ff98788a682812f2b202bfcd2ecfaaf51df2c1e8bbfbfd9bd4cf9f62ed4dd94d539e8faeb03b7c400bffce722164b8a6b20d9fae76287a44d0b379415f11914b714e0746ed6bcc72788cd7998fb910f4976a27cb6ef2be423bf81c6e5ff539fbf66c893b051de139a298f4e2d16f227daa2eab81b878031e68caf6d051af1ae1e224a301b022ad51e7e714c759743aa4c0aa3498f8d1fa18c5c80bda0154d67c293f66ec3d81f9aea7155dcf9545e978ebd0d4c74618ef1ce3bba7b9a637267f09ce54c14aed3290e7fddc08f8e33e767b1033655e569fd0152212bf78a900cea0cd10e6f9501438309aa4abd02fbc9ecb527a2b541f5a477b033feaa58e16d9b583ce3e6e78439f9c565e104af0064813c78cf36b2e3806caac6b7666f13b99cfa842f02b02da980e33ef60ebe9ea599037e439f301ddbd089ba7eaffd9d402d218449df5e711d3f6757170babe9644dc13a958db9731735ad49ba4f15fe4ddd036465f0c8d431c54260a7bc6e98559cfe443ce69f2e110e183fa81fddab8e2332de7a6639ad83f3724d9d3b4845a50563958a2fe6b8bb90ba4cfb0a6392a728a94462ab3428ef550e075786b39f683ae08e3737271121046e62390852f11cc3ce534ba71314d402f34c878ec2c869ca7cdcd1addaa01f853ed8d6e8cea46621850d20c0c9b1f58d1f7a321d5734c67ca3c952c3b37e494cb9d28d18fa74565900baea9d77021ea57f4c2c8fb1251fe177ea1cbf117e0043f1246f0be6c0fd94e8417d60dd1eb25acf51d2af7494c1cbfe2eeb8b62e0cb6b839248b400c691a070d5a2efefed225c24c07118e43725482375d4a5a50719a848bdd12cd525f4b49f8a10f4bb9c68cd95f45a6249061444f1c0d61c13e314782f7b29a005e642e8a925e2056702c5aa2bb2c28ac6ea5bde2fcfe627a00cdbbb22778c07599ee0ab7d518dd6e84337b67da06b00421b0a888460939fe6bd60b6006e35eb3a103d64a410a6440a6454e42bd8f807a21aabea756c364d815c80768738815c3b0deeeb8baec5f9b2e843f3131dc7f014be5d1f8935678d387328e20fca753e7393f5a388bcd99e1b712da550bcf786e1a0504b4757e2501aad22f6b6560381ca31a0f7a457d1db70129f8b2509feccfdb5289db83df6c44afc07fd8c88345280691493e1dad682473db087c09b73c9c0a037860c70f5c43fbac20b81e9a156a69f1e4d319f295f02b87eac46abc23f82ccc7e2dc99ea689692ef2d094326d3387328fc4d36f22503db8bd479263e771a4cd3529bb75ed4a46f3980520cbd5f72c9ccb5a1ad33a5d8fbac3affa229569c6732c76fe83c59eefbab9e21dbb30308863ffe17548f6611f57ed7be2c545e6ae1def2ac24cdbb48d2ffb28a5a05e7a9684c2aa68dad24adb05799b6efb302b2ce315e6ec7f6a1dfe7c68e9f01e8b9a74d4db26683eee86681e7b72f3889f6e2061d087b56982b4b31e99fa473e788bf17f506d93e46402debfd5143c83c7ee81d0f2214a3977c6dbd567b0c4f532330524fbbea623dc8e646a12ae63bb2f5fc34c92ee1dbf879218a96fe7fd3c7007f6556fd7508f9bbffb1ee7fff19edca8e32da573a8bcb374bb364308af5bd23f7623f7935154644eba7d2878334691dd9713275299ab9f7474934d7377c5850b263fda03679da819d0d2f8d69bc6b650993729f30334299d793a43a53a973fdaf1720f5c0a2cec236cc36073f3630f1b3ef39e1078c021f49bed0f3716280f311c8764772f348ab0d0967a0b44430415dd0f26fca5c411ab41120b46297dbb254363b33cc2522560aeec2a87e5e4eae1ddc3d3d0e475e1c33a69d671e21fb82b61b053e6a429ce2d66830e480f14d328e9592103fa9818c845e07bd1570fbb86b3d6e83e3119b796f16f66b9fbc886e23a86712dacdc2d110926369d25a6ddf4ffb336e5020308f6a14a90688c1f545aeef247546c1a008ce539afb7e2830d619353dbd4eb1e5f746918ca01ff9204e3de1f5eda06481e9908fb173af036344106a1298d6e0bf790f5a6c0a924a6ea04b17657a59f79b16bdcf4d10612d21d0ca829ca6153da59dfdca32bd96cab05838e8557dab78dafd4190f2cbf96603757124866ac72fb833de3caf962181dfa9ee980cb349295cda3244facb59f0619b4a815db5f8bc9b6e99c38d3702327671badbd2b948884586faa42a768d07d17827d2f4f1d6504ef7d65d938a595a5c38d43e01bb09b95358063be113f8d972ac6748a211da9fe9b17c7f5fab455976589aec551d44f932051e3093f20c6bf8aea5796744497e1df1567d2ea41aae3d644257a2bc59934428164f2c6ff66211ed5b6f8346477def7a30b059a91bd16417869d7289f4df1b275d2122d89235233036c6be8d301cff3eaca595f0ab8fb1a160a4ce917781a7f362836076b1d86ea5f7bfb596e92867af6e14b3db696fbae20b81cc7eaab81a0e7468f3048c31aa05837be79fce874b2f0cb85122cf4e5c24719f7557f6d9481577f0f18ed328f01b6a1c59ff7ce47fd3aeb5ae98cf9b0e295880a45e16145b251e7f87351a03e1a0e05d754459002e4f7b5233b044d4012988547aba3fc41e31ac318802243000a3ce577bcafaa54dd91338d5ec34a53de5f2b270bbc30a3d4f338af26eeda9d5d2dfbd1773198ea057459ef3789cccb22ff8f4435843b82229d22035cdd8196b35a5b716797fb95c8cca9ab8944898e69ae38553cadda796ee436b383db5042d49c6dacfad108db7ae13424354526a5864bb7fd0b45c44cf8e671ea7017a3fe2eabb39ec04e601f1ab73cf7fb975b77a0340bfa7a54b619c6db030d3916458290bd430e0dbd8b8ebf2a7a19945f49e593c1665ca5341be4bc7d9a58e535c72b46d5502dd9e9f9afad6edcb5a34f4caa8aab62e4025299e138e05ef7612a4e96f178da6d5e54d1c7b7c168338cc092419ed63c4a5b54a83dc05df705fd470113573dbffbbc038155b3c0774b85edfc59cecae28ace0b65be35bfb41063d8714b2c02cf848a201640cdcab250b67b6582d4fbbf708ea60abe9941732d3e9a86f1d95472293f699bbb28ade736db2d1353e26e893fa909c5ed1f3360ba7d53d6f4c26dc7a709196d1ae6027a82639ed2c04b9d2010e50c98851b37ca83e9db78ccb06626ec2d19ed5673679b2a9455dff9f88aef8f567873261d669d7bdd0e0245c33183ec404e7ed3ddfb06dec307d73b0f011ff5140898f1fc9f0e5f01347b854047ec2c3e90b4bbb3d80dfe4e6fa031bf4c68e58445da7e10746bb2b86666c95d0a8dcee79eedd04b31710a75ba95a4edc472104a6aa699350c7e080f38f1ed35e3cb68bf4e6b6d0a61af3ebffdb0833d885afe5423aa0c29f245931678feb219c2632bc88a384b57e10b6610258f935e063ac04bc9916e719a2e7d51531794c9a3eccee3d159af950d19209728588f7fd5b1d7294ed42e2c38e7ba8cc51c3e7b6993cc9d26a85e41764983581740ab74f422d0bbe7dbcdd6242b03af77b4de70752643f10ef4bd259d4b9095802bcc612285fb1e843893bbaca50e1d87d263d4e1196e700759ec60c51fe1cb1304e9429f939adcfca2ed66cf66a90cc6172dd4c73a1cd318423dc57eff0fef27f4d89f4d01fcb4d480235defedeb425e93cca88a846b2a3c1aa3bce6dabfdb3f4d981da6e93ed3483aefe78991ee92538f847a24024ad584d0d7f251892c4b0fe5b35615db7dd81c76af77415d9a442c233b02b879609f5fb2483f9c615eb1b657b606c0b27f561934824ac533311cc8a2f6de1b969a6ec9d9af9a99b444aa9bac60baef9da076682f65162ad25389877726b07c6f0cfb2025334b0d3015f648b5b2066cab3e74d4243f812a4454df8a7965a5c42fcefb4e9315ecc878ef58ab6b995f240925b2eb838fd887fb0db38d2322bf9f4dbb87284aa52af211c588de7c078897ed4df17fe7aa475f651b2703dff34bf32b7a65ae24339c1a65a879d6b07caa701fc652ddf19fd8a093460fec63ce88de40a2ab6bef70c898cbe91a23fba07eaa5c49a4f1044ac06320a8f4ab0406a4ee97e56eb0cca57eb79425e2dd37008a2dd193ccaab09fbd878b065fe9901bb086125cca2b3bf624d82abb224fc3682bff73e690ac6c42656c31f1e28610bba02774569bc45e2f940bcafc669fad967c763456630025b9c0ebcb978798b1cb00ab0e5e70653f28c99ab9fa4ba4f356a82a2c65393ccdc02d5c2199880c024446dffc3d5cd7406e01532b6ae69d7013190bd7fd94afd704e9ccb5ee7907e851822add9fef2b2d74fa845d1c8ab7d55adcc82a31277541dcf9f6c0a97299566ea028c93978a45996e3be089b202395892d8ce03466bec4dddea226eb798a4f55873e9e072b884538e053d928d81a86be75f9e1cdbda9a41f2c5e5f00c43ebe9e45d99db83ce83b857dbe1e3ae6c37e6283a7d765e17032f4227760441dad06902e5e1e254448e535593c891ee5cce4663e8544128f108dcdc9dd5488c5f106f419371baf156a98fa3471ec0c3c724c50d047b53d959fa2bbc6bad2676495d1032a163f3d219c1abc96a26a165ed2d27317544131ada43393b56954c644d57b72cfe015b20ed1f8e5c16665a8908096fc3e24198a0a039a037009a944d07b17944658e4dc7cc9e74ae2e1609dae85b02cee9d7b8f35b310f31760521c1e3c9b46f7d3359b75925432e93b93fd2023471e079239e4e8b04aeac468a6270c1d2b1a99300eaa8c7917cf41a384cd91eb8d42f82c6366e504933dd59097e259ae9f0f242847a36e0898dfcbb33106b4d1fd3a5ab248c82f934056b003d052585793be95fe0ad6653a3e0468531c089f0ac01204bc9052c22d2dfdd2153e2b523976873266a7381566ebd61a683bc5df3173ecd6c303a5f977621d301b0659fc8ba088a536dedd18287bb54403540e95a6e33e9cb7ef8cfff252cb40c4b76e686ec613499a3cee7b1d4f6763673e4bd207683e597bdbc8c1d8b67b444af7b6f711fb83ac58c35dd64bc5b1232c6677126de06a333c3204c1b59d8c2f963c75e668421641a75fbd0176745a427f1eb4ad80d418ca0a08457f348ec943a7a8ed69de2c3b88c46bd0fcd6b3d856d33c94e06a4cbd7e09da280105b4746686fb7ced6da33b8e9f6038010492e58274e7f391020841cad7c8c5a9a558585fc80f47e689c8f2cbc985317f688056542d6e7bff889404797afea8219ce817612d88c4f66fcd7d97ef22253d2cdfb0ed6f9c09b00d4226e9f1714abab4f0cd81073f4867ad3c6915abb474561651ede8c260df472a495c6790bc22c198bd64f0612361477a5e4d2ebd52a1311b207274174d53f9c2352fb98f704dbc7e89b15a4bdbb93928c566047832669cf74566d295538191af92e3af9c3d971cbc94f88e9cfefdc628d423a1bb07faf8ff8dcdbf27bf49da3fe6b6bc8c630bf533fb48acb49eca16b7b87137f49828d892e3d5d06e7027e4eb3da0e35640ac70271b6d3454987a3dc1379db201aef1c137d42d40a74584af62b2c1062ba63f583ebd18f222a93275b723d93cc511e6d658de4173554f5761051a567c56964fde2181a96adb3bdcccd48344508b377830b96fcb55eb945a57413f118a5650e1d52f40285ea90ec7dc023b2fb3b62fc80d5b5592b7dbeb2d885084abc3c6af392ec00433dd65e445262f593cbc0eb55eb2cd19be410ecf668984f8e44341769908c66e28bbb62bc2036e21a7ad359daff44f3fccadcc28aeaf615e478dbc103e84e311d5c9bd479aff2b3f3b80a0d2f52d4739d45a2458cdb94ff493d9748faaedd8d44bddd4524d905302e40ba4ec6d770693766217add06254ed8c134295abc5f8e587242c314b4cd0a95c7117944600115aa1dcd582a799626547d9c41241f297c2b40bc5d717673e8ad410814d5ad28825b0c222394e14e8082390b2761bfea9b8cb9c91115cc6f9741438e72459da0d50b7f69b0aac85107d22e268f84d5ef7ade6e945838ff53acb43eb038c45b9ff37df0b5db49eab98d92ac2dbab2370a41d51965fb1b3ef7828a9233b81f70b4822a6927f749a942e1dbbc700dd0a4bb1bd347d279263b4c61a92228b9dde4309a0cff0b83169939637aa0684a132da24915c710d8d7737697a3d1766ccf0de18e7b588cab811edd7f205bb4f937f51f53367338b386014e6df9179a3113d433651adacb99e53dfd55f6e422628075bd4749adf74ce557451d662513f92348b20b1f0bdfff7b4dafd6b91906d7cb3cacc6afba4f3a210028cc180bec9f36cc831d7dfdb16b3d312d4480e71825567d1abd654c4f4634c474c47ebf2334db2c9f0f222a0a9bdbd86d4768c7a1847f4e8b3f1288a3037b5210ae45e3c599ad7f8254b6068276e43457b8f217e6b9823a24c578ab5ed5daedef18bbd8806bb58c35cda5e8274155ed6f18707e4d3ab2be9f565ece06f7b24e15aefe1471cfe8f7a90b64b4f5c4a499cd118651ea12db1ef16cd69efc69f0aceb8f60ca9b2676fd48c816826f8fba990e638c36276bbb958afdc508eeee1ec10dcf8cc903b83c0333f6594c9840b915301bdd520de4a4046b0011c9e304f2fc00631e4d3af9eec1dbf528d7a28b7374f761597db1f6a8f81106f6a01ba92230f2caf87a6eeda3595deacfd4a77c1589f60c06506eb5f58f0abe9e0d81acc7d399af93833c766a71b3a601ee0f2a9a42bd1ca4303b19a78956cd74a70b3aa795e88094a8b2914527758330293b886cabee1dace05db9fc71517a8e2627a93b10659d0c402b366d0cfa13b889e9e40ea8093dca6990c2bbfab630ecd444c7ce4706aaa70640e4ec74ecff6d156e08b9912a94d1ac31ef1e7e0654d79bca0674aa095bdbeb855c6988daf135370c78f8ca88ad5a2c4b847c446e570fffa4a7f3942fb08922d5554de05d1f5e1f13761613f9fda3ae61dbabb8b6eab49ebc6675644dad5beb7b8ac88ed815d0ef2e1ab4eccd095bf90458e092088f4f130e02ff7eb43c04fbaa1503e744060f2ddfec2fed711bc85c9ecff893d0ac361b098a1b3a0a87d146a4a88afc2a291a83301d4a998564195b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
