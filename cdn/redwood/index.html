<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a5c54cee8133dbebe8c4099b6c8c760f40c1f300917f0b41a5f2e77fee7b5f4c0534788061d3591dad03b416ed05af305ed48b7cfa8dced4bc75b769f680f93fccc0105a191c0951170749ee55040535934b3fd4308b16f1a076caf1cbf5a2eb24a4eb77ba02fa346c9ccc3e30ea2bd6b5db1d325a44d65c374e80bdbe0e5a93cde9fd70be9f958b4a8db39f7b4992d9ddfc33184657828cd138b51c4f6e717412fe4f075f52165b132f4845e3dfd69af148fbff03cc2f6cf079b0e2757e92052bf7c71bcb47c6c0a9394733096c42e12a1569147a092eb7b42961d6b56e17d5dc5ed9ce5fb9b1f1fd68e73183a82b3b2e3756b018bb8768db1b20ad005d588d463d5f26ca365793e9951c2c7bb459d7ce13c9f3efff3da2784df995707f43837d0ce9cd9712402a3a550e0e9788d9a3f91602eb34bd93c1c05d3c641968b6c90b12cb5008eb6852980b62daadaca11bf86455185201394afa39bf205d68e816adf087dcff909204419e857c33fda67b999700419893a0bac764f82d081e5184340cfd8a13e737097e800dc05ac94a53bbb1ab124799f0210af4c3cd93d705fdf710c6450142fe9c185fa2a1f545d0f225b1f73dd609e78c64e384772980757198b03fa5a80c92aa63b7e03296c4dfac6ae36873c5b97c16f57e03bb6d2b35d9af6788418e34a45dd2d20a0a2421e2ba0af889d501f3746b9b2e32a865d5f3d2044426d55934bd972e57e774fa72ea2bb5c7d09cf65fed8f240a6e3a78b6615f1c7c6f918f89a9da4a130eb7a570bd5af3a5c10f554e43018fa92b89efac16a64f328dbddd3e87ee8830bc2fef36e9e9ff6c0cd3cf8c5e7a8a184fc8eb6ea026a834dfa156f390a7c2766faeb51084d9d44c98bbdadc56afc5778fd3ee977876a7448306acb14114e1cc5dfd22e9bbe7da52771d5ddf98fc15cbdbd68d8e57832841d7dce25222bba4858586bf03e8bcdfca358d738143b7f0b0e06652afecc17faff3630f90da2dcb42fe24a49f6e71753f287dd3d55757ea1abeada34939ee9890b1782160ba592af98292c91f532f1ecff8a059c640fd31bf23e6733a76f2545fcf29e77975c19e13380d6e0dea7aa582edba13e9e3b9213d6053622cf9a215ad07846b597d20876e9c4ea03bbd1831c21a9d2c3dd6c79d32035e31d01d245ff23f9e5853658749308b1a08f973e879c77a0b0ca7c1599e3bf5d199c603bde2a122656d9c2696ee8ea5b107127d8c7b7a40f75a8f713a2e4e5f28593007dc3c0df357733fe196d5662642a12b93636818479251c7f7784a018ed2446ba1b297173fe2f33bc447f7219ac7c5fcaa6291874769d9ed28e0dd2f2afc17b566ae9f1d27803e659d822bc708da5c7b59be962e877eac22c8dad356d720a99c5cc35bd96464b326ef96454bb3b457c22e426acff03c511c50cdae996b0cf53fc971c3cf3ed56b0f69761e92c97c77ce09f2f8947b2bda63c2be3a648be9d20386d9c32d18312bb20b4404f7e81cc802dee3b9681c603cb99b20783c02c7e6d76151bc08fc1d20a0db69554e62d10f9e073d9cf77c4f5fd0c109edaad42130933dcc98fecb50557dcd9361224c5d6639a87e95f90a57b83f04f7b4fe2d39a978f7462837a385cb83d0468952936819db19284a18b97226cb0f12a5a3ec43ff580d7e90dece5171281e4f5a3d15b444793743b6225a9d6f368abf5c8a348e3ff5318f72b302ed403ef9fb4b8a303738dbdc63f133b89d3febb0c6463a0e82eb831511eddc4480b19bffe89804c4007bdf15e9845dc7fdbe7ef550cd00ca908e918372751bed385d4c6f0828cc5a1cbad4b4c9733b2c2056be8aa74711cc4d83ae96fa861a1553cfe683c63b2e25b457a45914b94b977c12859fca53f4716fead8ab06be3541330e1eeb8a7b2bf90667d130d83738c696d8b3fabcd2824de69fa0dedc5c10fac386bac16e8b29b5fef165cd301e9233c55e8ca523bce1dc4be1aa37293f40d1786263a7beb53fdd2607759c2ba16e890daf69ff8ee5b2240c6dd58e49f7b06746c7bc305886aaa4ab0129cad99ca7733bde962a394ddfcd5825f32cb5ba24242240e128b23e67796abc468f9dd5531ae609fad7275696ac9d3cabc6a4488eb883ebd32969610cfbcbab4d5098d3a8c178a967dc853f034962745f313c711708114e7dfecfdc64bb6755620af303a49f30a998a8c63e877762481fae05a30a6d7cb3f01fcccf811b8cda9068caf9cbaf4a343f9df82d95df7fbbf74ed60ce88f1ae19776e2504597cf1c0d773588459a97c204540e3c495b8ea3f3708191ef36d555c62498e4ba09804fc4bb076520bcd023132fcf156b4c102d4edc839cd93940e051d90288b80b89f13124af4b5e30b1424f419e2868cc6d0c8db2d78268d4326f56e2665cea0c314a041d86c821c7c117f332d62cb12d1c07ed61604ebc6b0370473c8f823d7a759df4e4ee3d23408dfb4c7d887950260f91a11407b52d826b398a0b92e0c9d518c649a0fe23fd50da5d494abb7083d0ce5a1ca5f1c3078b974c9a80926f2adbef1131081be0910010b0d5fc295e8fb7e5015b1e0a665e1fe09217c60dc5f62c94003f165a8348e0436cf7f17dcbb783d100699693829d44b394708f00281b39fd6606d1c254a7cdbf9cbc788dd1d662f7d29d9fcd1837a2743baa6103817b2d21c4f87c07f83471921c11c22835cd0261073244956e874fa79fe21a31a116ad432d8e7ddaa7013bd57d8dd5a85945db242f56307e3a9aa5abc7b98d2a188542b8e9c5f0b93187666013de9848ed0e453116aa0bb39c1c945ad2c104c2b533e791eed0e6efa77b3f7d02673151f6dda3318b32a418da72dec6d1cc4430743fd9e14e7580fd46e88153a1af371e86801d35f87038f95e72b71c1021fa875bc90ef3e51d4e03b5ebc2731dde73274dd2a4db7342b9130cca339d00677254447d358f9a6e8b5e98d250c3095dd0fbe27960604c1829381d18fea616c6e10c2fb128ee6506d4acec47b62db15494c59d62b6b5ba9fc8ab4dd7800bd5669d5383314ef34adce960fccd5bf992d60ccea316c45755c84d27c1bb0a8fc84af9a73df740b4b2a616c00c40874a3b9ec3d70d9e4aee17889b3124f1e0c45d003023b17c58405e1fa08d4d757702c63897c29198653c564ba432051c7333de25520e4247c5fe152b01770687a34a8876096a0532f8db906419ecce8cc949d7320d7be464066fa3ce76512cedad43cd17fb475addb4b88345be026361193d2ad0ac1d735dc537a5b54f5e04061162383043d61094927deea5666b8d073278f59246fb1f8deee62fc9c8d38de1fe98b4f5820a7ed2d4b8517cbf839bcb8c52ea1ac0bb71314ab0b063f19f35c4afe128aaf7a52f567620a79706e9c5ccc84257df2f66317c3deb0472aa843a87c46a0a602bbebb6064551f819d9c704bb9277f7b3bbb5556f8abd32b036a902b4c6c3b0f5aaf88329bf54e40989703500bd08df47879899b2f57a0c2e73a153585ff94cebb9941e731b6427a1a17911112b751a6fba1a3d799de35c73b29b5382602d496d6f639fa330ca22f5422cc274152462c90434c3e3aa49b329daf1565be4046566c6f308f63f05fef66b3e4471fb19d2f1266bf18621245db7a32b6015e12db715c8d8ee96abf005fa751282880486586d28bf9071263b3bac1f7b909ad56df02ce1843e42984b301b0f2d26b783c6bd55d09ceee8e802777aff622ec0571f98313299e2d80d01d8005ed0f8643dbd2ff793b855f189a3a8c9b61b83573613eca800a428ca523978b774415968c6d391a0e95013a31df1b26376e435cfb1566b1ccb6d64ba8ad0c772b2ab4aeb2ecd691d914755a76c282e3213c586bb89765165234a3d81d622ccd9e1f3d4bd8e43294519049f395f75f30b85707f2d6a2673725a388ee234f52f6095229fb1d3ac247306c96496d39a500f4ecb9f4e99d0674309d013da6057f8a565ab93d1c5ca8a3e49bf212977c512ad502d4ec97f6cb5943333c998ca67eea6b374e8dde3147666cc223dcf0bb37ba6c084b37d0ca3f2911e1b40aadad759ba285f8fd210eadd5def872481f58e9a73b9faf52bd7ec30a154fcf6a5ad9a5e33c15cfb61e2afc60cbd51143fa5006b58e2fbd9204ee7df39800b524386a37c93efbe906d1969e87f6648e8420247f952447cf0e7f8230d7d5403311b4c48ec06e5f58617191f269b8ce6b0cc999eb4b68bd1420fde2e2adcd1bf88d3adcc3c7c06bfc8a1a959db84581e782330a79da33e0fd0c92295e4bfaff0aca051906de9ace79abb3e2ea408d32d72b88f736f079bedf7e635db5b075e80eb26db63cfdf478c431bfd05ebb4958f660e6f2a7f99665abb95a7a8c6cbd21762e134253df285b4da64bda7d7a9ea1b13ef9d72a3da808f21cf02e04d6755d13c94f9db2d1256c472fddbd1d87aa10445921307552266ef3f527d38815b71b67718bb796ba2df18536c002522724671367a69a8c9a1e3519334ddd095bb7ca981366cb230a4c71acf7c80b3f83bb6c345c94bf20152088d51fbcad0f54d10568efa19ac895890b8f0999f480c8c87f8fbd8d96c8fe8531ce1343bf567b6717dc9200113fe3a408a57babaa5557fae5ad28fece87abd539ee6e57f4d10faaebee2dc4efb86344df157d26c3724381edd68016a5ca47b3ae08dad5d3de166b214bf28cde9f1213ee899a3e3fc14288eb56fa76a5003653f3a629eaa59ef84942e985c6a5579ebf45a21be1c25cd9ad01485fef84029c04b8c2ff9e6e7b654e32c8fef356042e49db98089d0e17f7a2ddb5b96274411565a039680893ab889a4edb9df634085339c020a8a30755c6bde478f0284e86415c370fbeaa37d7413f12c9042e9fbde768803396d0e03c9579da3f415b9821328e0cdbe8ee23a6a31118f4ae90d389ee79c45d27d9451113f7edd2421fae1b2c52c5425d93328eb52bb663e4f48697da6b4fdd640592b85cb91cb82cacf88411131c324624ad2781b3a89444de952caa07127da1b1a96ec9b67a384447075fb337484dea2cf0bffa9f450d8aa2837c8fd269f6ef243f671f4e32cef6ef2e0fa40d1031fdc6c3ffda795e42420a1ed51b2d6b897882011058dad4f36767d975db4db57d79fdf4a9db784aa0e868c9ad898d642dfe1e10ca0e46fb0b15d1cbef3d126f49a3c9afefeed971b63ad6842e0e4024154af320ac48a1c0b323988aeeb253435ae25eba60aa65059bfbe6d789da525e18daa96005fb8672c644edd86c4d708f3924f7685dd7a4a6b0f1e2e5b6feff7d7914a5cd58210e44cef90e203fc96659bf98484bd351ae44bb08e794ca95526fa37da3f7678f0f7cf1528cbbf6d902f99b8bc65d78c07e48d60caa63f71302787112fdf363ca5d055dd92a0b6dd4a694b7da72e3b1d1b15e38c1b71a083d244dfb8628f82acce25c281c414b48f1d2028fcf41c7b3e1ecff135d339433ecca51612e35e3c91bdb16b3f868334a66f718e5c4f9c4ff2edfe6139023f7d1eb44c62d5b1f1e065d3cd54920565dd5b41033b644fa4fd05d2d9dd8816ab9780c58963abf0ac3df8d0d2657109dc0cd9107f6592ce0393a26552e3ea87b86580cdc51aa5378744c96b5499ed982a3be70512c4b4350ce9d06d8c35462f22b1092e4d44e3743bd75d77a438b085a24a8efd8d61afd66abd1ce4b4acdd356e56a62460c992278a45e4c1d55790c1910cb59616fc92c462253885a7d95b1a34b0df12d4ed14c3379173ffc8816b4b7aad067d307f543dfea5f2aac07b066c00eb03bf4bab42ae3617311542a331a9c0d5695329080246f0d9ab85c7cfc0ce9ecaf3917a2865bd5227fb7060048c7ef6a7b9a2f5282709c69702ddc4a50c9e60316e1894976111b7e1568b1d6915fee26ed4b14e4a37ed50e86c956b8afa7c8fe973f71c25b609aa995321b9f1b102a16b510160541c650fdf58965d7202fb25e315d89d4867ce8677ca23db7d86f074450c4d4f853abba7f58228483f319ef40ff39ecf555a4aea3e73ba0a0d67d70446f43241433059335fd716f0672a5c2aa9dabc04f882468ad9de782f1726ea2ac85d05189cf04d86b59d2d124559158dd69a0f0cfff2e6a7ae082e32e427df0b6a113f2dd9b381ac9d96ff404641bec77944ed955690d357c415e9b6adb41d0757831554ae6e7b5d3651a67c85787598144a74915bc92774bc120062a6174bb957ba793cac72648a5d475fb80507ba9ad734d9d8053d665846afae34aa29263d59677a40a4989c4c0138a15291fa34b991e94e8a4a588fcf3de74b9c77f4b1bbd3fc22f12d497310d41061334f4c7d1189bef2352bf91744304cda968facb090e3c8fdcfe71bcbf7781663d0644f370565f45b112925a7d92ea905b8de3ff9a6d14f697250f77141e0a6e600703e388f9add9a77222ea6d9efde51aa70f5879ca9a492ace16dc80b3d12b42666192a36f99181709f598d3ab2d6f19e9af7b79f21f6bf961f3d61cdcb0a8e97d8d3fba5a896074e9d9c18d451bbfa6f60503cca6b060d97ee204c318ed1f654073bc22d18de2e6fa572cbae8fcd777b1bf85e0f119bdd112131e4d441e1a24a368f0576234387d21901111e0330d7189489872319a54c3280f8c9e24ce3d5468e3fef7c3cbe2310dd8f2c705dbd872d1c0d65ebd53cb555d39378d9a2a7565a42b346567fb4bbeed4f8efd09b47b5a2e52080b336273bec8ea2536fc8fdbd350f401303d03979d27b321a5ef7363ac1ddb009ba32a6c7c27e38260ea307bfa1061a09b5c1c4a86e9df5be66a9df8cdf783f718259777f953789d15b091c50f49b02ad1d867fa0ec93f41bf01882e470845fa9352b0f0b6a830effc297c355b84a9fe249ef18a68c4cddbf4acda11e5f64d6e3d09e72f78aa00a6459aae0d251c68cea4f2a30cedfcb592162e0f757bd4d78454564fe90ccf5323bb401004844573b81a9acdfee7929bc1d6abef929da147cbcb61b03c479641748e677271d963bf06151ab5a3a4446a90c1ae23ac06fc666ac3c822d5862947b0a576360142af3b3face365550996a9a9c3cb46d53382debc8f6c46a84040af338df90b258f5a894527ef5261abcad9c097f82742619ae30e54b2197c1ab9291455079bd33e49cd3a28a9c9685df6f55b5d6a034515481ad45039051351a49a4d3d4dba5fc4878560b27b0eeb74a08a730d1edc53de7b426f099ab971e042fa0137f6b0967f2ef81ba0056f818393eb464f45259d46ca46c57c995d8432958c094b36664cb97524e611837fd0fc3631a1ad1a0f48e0b289cfca83089bbaad1e8e7c2898a34dbee9e4dfe18c2ca7aa6d915ec91cdd12bd1cb3d89431cf8071ab4799cd945d5e75ada286de619ba8d1d4c0c5820c0f13e2713dc30887ccd77af9fa0830ec23a196c92408ba000d632745bd37772dc7113d45b611fd7155dded8c61d31c5a619cd023bb0d2417c33b93606944b6dea99c5d09c8a6ee3ee4b2f508602c3224371fa16402a5463b478ae17b72dd5824fe1e881f3a7604013794ec2cb410ab53a2f4c5f2b591e444c688dc23ce93241e222d1bdf55bec89f8b39c70676cd1302be569800178a8f1d56492628399c6e6553ee39bc404e68c2b00da2f5c8677cc85e5809903177254e42d923a5f4599676643750db86e1c6874460a4d6d5a5cdae90e0cd0a1d4249a2a6ff8fd0e8df57e7a9eda55ba2b91a1b083f2a17566e74df7c8e8f5f0b28504d58ae5c3a7d4d26fae9d1f11a6ed49cfa96563488b840813255bef0ffe2eb8a13c8168dfde6714916835fddce31ed4e26ae45c98ea2feaa378900638def0f9010d064ab592c9bce6b46750fa8627f91f77f463e6b78f3ef7e0049300a9d61cd4fbf2e0a09625d5de3d57538cc915d5ed9e92d6b466a5da523678a597f16db0bae8c9143e29fc8699a2354c5dc4db5ba35000f83b07290b507fcd3c0e4121d2be74e2452560b44aca6aebd4c67e9c2efffe4870e26d7df76bdd73205086babd7d576002199c95d5689cde8fe3c034f63cf101db7cb4995867b4e3b1133704822eb2dbde5efdc7465748f1c4a137987617a4f1e187c4961cb8004266aefa13b20cf2b2a259c3aa39bf3e1c34577b4ae718220cd0d6e307ed0aa34052c448ef04ca98cee10689cf9167a731054e195ecdb6db06331dd561fd70319c7ff5b882da7901c756baa31cd32e368e1b95ea497a48770744c4cb24eab1c5a4dc258153da07d3e29d25f9660b3a5ea4e64914bcecaf7ed5893726c4efb12d77f5a90384d88bba639f6fa04d22e85e45204d91002f98494d91b572f7867cefa7fb174fbcc30f5f96815f852f11d6f01d9a300e81056178340c8ad754a27ed79cdf6ba094bfa9c5274e046c007e32608a983505942cba31a93cadd44d1e02d1a762ba48fd30202e95ea3902d36e02fd7452aa0ca3e7054f20137a146bc421bc1de990755fc494df5d54f0aad7a441b3afc4a0d972c30691040562d650a085f6f796ee49631b581d652ddb80f8c58eedf67dcb6671969fc32f22178bd5bf6b5c329b7e0188d03201c8afbbe280f192196836d73b4901a6ea75112bc99fd95da53245a3841eed5e5759342f71fd34885681c899b471b0ce41f5b35b6c9c5a3b107fce021b748400b6361661e0fd78c68cab12758016a5f6a9f5f788934ed872660937dd3aca68b8cfc3f422d678e3cfd0a4ce3ac42290b7809c599f78df36f5d0f94dab26b96c880d3d916f151e788ae5e3d5a53b5c55c5ed57656bf522cfd015f2408b9ea1bcf1ef5ac26e90a7f594d06bc5a942001dc7cfa13e062f030a97a68be4602af14550e8446328c32682406c589bb1f85e91c59b6bccea78e9174e78b33e0cba534dcb70ed8bf87624c146533b8f6a757c8409e0e1f8858e80ec88ea9b16bbc3aa02a25d5f3483dfdf82fa92e9498d7638881d5c3f0da16a65d9c8f292b4947a8ebca51ce7bab1ff624222406156fe322f389aba587507af082a1b5107a93c3feffbcfbb7cb16612f7e7b1fc4aaf04ca99894e2cd74841189324169e53ee8408d05b6b9c7a7bd2109bd6bebf92f9a89502f4555796b9597f8adb4c164e3748a714d9cb8c13cd4339272c4f3de4f88c30085d88545147095cb8c6f417ed508dab4d4177cdd601db19d6b2f161e8c2e61a4f7a6f7e0a3cd5f3c60e1257e84665181ed71525afb2c8b12ab2a54c1c18a8109a21cb36204e7b879247d9d592050b887d9195591518b312c9eff58b40ef36b5ddf3069b63e77f30183edea60f7d69ae6aeddc3d9c8948758a3cb18eb986319d2cab72180526a305880c29bc32e5b6234e067361af48695290fcdd4dcf465331e7b3238761f9297acf8c926d0bda00c41c946473f10ccb37e05a19b3e9c6a1b2824078a48f35d87d70a411a47ceae84ca398bd629e369f2fd3a155b8a06c16a135b4bfd43c7843d6a6e9bd55e0e9b83e11a325e1aa7bab8b6611fd96a9d5f3942ec2b59560196943cabba545a509c584a8bbad26347e619c7f890ebfc2cd3b3937a9a1d1cfbf1453032797737ad64908f94691ab6059277208f8348e65b15fe0305258cabda7c6e3ae0193cac30fa6affc97c2726b5fa432fd4fde64b881676d4b5430abefd64cae99ddca65137fdd31ffece746216f6c4a79a2fde7d26119d3664b3d13c8b5e16139b8fdf727657d283568211856dc0bd61fcf44e49285e2d19c18681a0b08e989836a5c403d08ee05fa0fe55a335e4627927864f5cc53baff4ecf62605389fda8bf0776de7e27c710539d796747e6e66d4eac219f7dca70491ea55d1624d43d0ad98f4ba95d57724f06583e8169c868268e40077299b1b303979eb94cc6c41b25512853bee650d1c9c4f3488e161782acb3f66ea104e2bf07da3f1db7423027554e003da6a971e6e4072811f993df2024733a100d5d6e849a843f29bb9f9b0a0395f54e901ff6129187773b2e7f4c42a14c519fe1a84337ceb464e5ab8d317d94dc6c662e6a4575f35ab78d9f5679e73caf32b985bdf1e5029ceb44da49cdcab99ed80e4966400616ea47e32d096631b2c23cc964f184f40f2208e0dab256d9eee0763712feca6ee52a4c15d410c03937f96896384064d0cd79548685c008b1f07d3289789c499b9b405f7eb96ec80f2d86bda2aa38385dbce8d80031eeb71b8648025bbeaeaf3e06ef7f71db692cf98c263b201c943f0c6e563d6cc133ac3d3fc87c689589597c918acaaa90e15f1400ff4479cd23362802f4997649ebec878959b5ef30980419eeec730e185d44b7582ed3d66e11269a1e351fd47a03f1ed8609c3c3e6753ff45d5f27c12ddd2cc3f365e32c7e7288ca3a0c542d56b63d1047c9c8ff4f092eb1398b50ccbc515900b4f14704ca5995c19f4fb4ab29ecc69f3258da33716ed68f70b67a085f43ce2d3813ab9462a1e92c741c87df5133ae194306642a6f473596f32670f1e263fe7b5d839eac55b2e1e07d87265b9340705d4f0d5e8749276360cc1c1853b92a63abbe29368e8b431daa4b58a65159d0cf48210f8daa09804e4b4b36d76450442c45f6ac2b8cba5892be5f317081ee5e3a4f4ec8fb5a05468ec0940d2a2bfe27038ca7ec02832b3d3e556d98ead9b9fad1c13737243dbc6e91eaeea10bece71d22c7d9ae7e92e6ec9a3571b7e14d5138e615b66cb8dcc29afb0aca9247b4992935bde9e03f2209fcc7ec3a5f4ca2f9bbeffdf32286a1078fad8b10b7818d1781be0f5b51107834979c0608dd5f1920b362e0d7377950dbbf943641d071a3f5d12858bf2bf3977daa9ba1038c5c0e6f7ad5f18c554143daaf1dfa21130b8d0056e52913152a0107bcbcaa7958698dc397fff4432d9f033da21d222f0c1768c80c8e4eecbcb106aeb3ad84fdcaa8d228a0eef5a1538d3cf53003139b79379c5bfd5248426a9198cd622f872ddc326ea998325450724f3fb0645d76e5d10f1a2d313c3c6f9eaf821846ba603799dc553a2b4291b8fbe8ef5bade7ce3e601dbba83e428ab24811d8dde869844f1bf22846fac38c298e52176aa9af264bde80c0a63b9adb92b4c1c5bdbf26a20b5d6528ea7447043328e532ebb542c4b7bd3d186ae1ec64250d31a2780b8f6209c7ae890c75360702404a3851396f0949a9b5bc8caae80508009e65ebdabca4aeccd75c1b1b63868a4f4f5a30ee1129d3181bcc00fd4917a81d3a4609b56b7272676fed6ebc802c07bc8d9999d2e32dde666117719fd2fa6a8e38ea306d053d93ff83b6347a3133256d21438b458098762806eafab7e39ea57021f59bcc9c46efd95fe992dfa7bdacf479fb371785890e1f906b093719f6b91622beafc85c6256dcbf04564868c13ca6c928e2fc19b9e8f2a3655811745cb757507fecbbcdb2b6f85506bd6f881c9926434507a886ab845dcfd8a2fe5fd0a4a3cbdc67a52b242ac9044a0e43a44ca2489d6d97bf45345da99b52fa4d50eec0f9bec82ef88e503ebe09c5b13cef129d7eaaad6bfea33ae3e44ce2a0761f8f2e4615a9262f3aaaba55762e1bc0403be6fcfa0d3ea32bc385d954365b64d59133f98c0536d58b1a6b67ce53394abfbe20d5d247a15fd89e76f7e5fc523dc5944cec83b3350cb116858d4a245602d1f540bc7a288859070785ae38517becee21da7e50d2a27c0dbfef4dfd5ef70288162fd04e12e13b6d0665402566cdffe9c186f3ea4f6317c69b3ca4c916e4362a66e66511938a546e5a3398741dd45bce8f49c05c7df07185e2dac3ecc86401ce0f6dd39a0b7c7be7747a0bc100dd4f0bf5c4b64c28f44d3c0b195b4947c8c0484574d1d17c9369b11468bb13d0c552512dc8b349a65cde5e9e952c389c9d91763f5ae730c69872bb2671ceb0b6094c4511ef2b43164866099dfcc989cd0b3cbeefc4cac74d9aa61fc3855fb23c9c34737c5b56ef06c3e19a00553df8179de31a52f8ca787a6e12bd324cd02d4a4b7bf6802197ff79e3949cbc559ab23aaded90cf18dd73841bc5b4a2cac19a79b549d9446dffada51d9243a10e69e91a93fc327eabc8271ae75cf6e619abaf8cb016f2627330ee721c5ae633070932a8b38a737bb2cf2c6ce88a8668f657446fbe54e5ccb8fab327b5c6449d0c8a915fbee3b2895bc27a01b70fc12c0ccaa719eae423f38d0052c07a6fe42163d98bd18a6b8f7f8150d98fc668c818635d21dbabdc7eec2a8cd0e1ead30a463083fe3afc898cd6c82c8cdd929197d322f4f738a7ed24b4f09009552ac96eccd4238e4d620bcf6e8a09cf73e115c7fe4af1c47f24be5b4e3cde55efb7e3d10afbf44155051120b1da6194695ddbae32c8af79abfb73a261ff2111ec2172a4f486c366d15c5fbc76ae1721f2fa08a56292cf33f9d54251082610c350618ebef8421f770750c4eb3e567157362550048d2c0698064cfed71f1999a5ce18ed0f08922e2c1ac7c1cb0a22ed891858e71521bb66fece972bf4b6ad6d016b623660d0cfcbeb2227c111d0caf9313e4e3631787cd04b2caadd06b25462acece556f3138d2abd02ce14c0c2732e9e47a1c28ef909c7c0a8d463ed93a6280b4756cbf085428d1d3bda30e9a0e0c30c52fffdd6462ce5b7582514dc8e0d24727c52e95fe882a9ef66465d861dcec3c209ca62f50c1e4f82ddb100d932da4ef84322b3e079da58a199080a0f8c4c1dc8312a91ca7d54193e4bb040e724f223d2bb8270b8dd3330ddfabe3aa5b78cfc848a836daee889fda93e978a404bd8ecfe3c1e6b81de84ab9e7a2a61c22c9ab018beaa6557d74c8f2c926d17a50d75b1153ea836e2362c42bc3dca300c24542889befd97645a39fe91e4f96d2eab8bd692ef1b12b9f46996ac5c27d1cf6d996733cb6573105b7fd3472869cf370fcd7aa11832a72f2cb9b6dc7ee22ae5d6dbd1731fdd756bc94af9d168f970c0c457f381531c56b9509f4c1fbf530d9557b48404dbf252b89c5f5a771eb72feafc77d0c3e095035795ae57f88b69b4a798f30b05dcf42358b93d26c687f515f6eba314ca558d3f5279280d78c231e11fee6c678bbfc710fe77c27d13e705ebc560aca3bd9bba5a20fc26ea818da0c3d5c4f97052dcd5f08847066feaba25c54a862d84c6df896a7457260155783410f7d7c61b8bd7d8dea2853fecc612c166a6f0c61a64bc86cbb7b2c4e0818f370c998c458721981aa576beeb52214ad320dabfe0df7e917ac3f05e6f060016228aab6434d866da81873957cb60accfee1d778e680b22bac5e8de9fd0137f7691f37459cbb655d74227eb2c39f206a9f50e19e6d0df726eb31cc40041b3ba539744837f750d7bcedcac4ed8be2040ded532968ef71b0feab2f1f74a21f8f5e987dcae6a8ea4b5ed1a926373e38b6582cda0d28d21d087e4565b24f37016cfccaa4161ac22d3e5e49e6b776db19126ba8bb380a8c4f13d89c7ba4dfd1988b92cbf566b738834e6705bd3a81e04999ea4427ca53ab975b596fee0b870aaaed6e91f954e62572fecfe4d08a95a896e3d96139c01601fe3d87899eca9295124de6eb435e7f4ce7021dfabd06bc2660919de58eb3316c7f47728cee453f73d7f2a99a6c708d41d6e70de151fcb192681bf2d0178d1abf6f48106efdd030ef450c3bf16632fd815a7ba37cfbff0166e148082ecad3d51d78191d3e62d0b0cff17777691cff3561ef069bdf323eb81f9db8b09b15faffda857430849e0aaf3f341bc98abb5576acc144e369bde2d9c02fa1765a9b59ad6ea4fea8242f2840cb80ddfff6aefcb5a563c260336afed1df1d2367a05f3153d23e1b11532c7b035e1fe3e30d04b9913c24b6516639edb4d8bc6ce3ece5e3ab2d44b0dae07123546027bc5e7dfda22c9b05e16fa23a1fb014ae08f1da209f3055ac61b791a369ebc23fe9212c780ac97ff5f8bac1c72168a24540ecb35894da1c3a7ecb44145927e92d332943d03b6263cbc3b3b266fec76e6afd15addc668c0b38e303653c7a8a5481ae50dfe80729ce718cddca6c36a5f0958418fefc5c786d8d3437adbdb7097ca86a6a7624c3c5e3e2add4df4e7125c8a47d579ec4f6bd4adebc0e7188eb2553a4a3b16f58729cd0e19491bb49eac66e2435e98748648deedf50356fece8fdb75c255b39b506541e72b595b97e6b25e9f42a833205b34bc664b8060d344066c0c22f02416fc29810718a9b2b017bd4079b673a0b926f3b5ca1677901df58209718e7c236b902ef7bc6fe9187de6300fcbbc02018e69a73fcdc2de9027cf9858c3304f7ffd75f2428c9d7351a8c1e605a0d71a8310c68eb61dd3a3e8ddf380611c62055ba60bf77b95a91269a3c7d815effdccf7f65c57660b8147361e205816ed531ac94af4b0c994a6bfeb4b7756bfebb56c790a057154a229bc18d3a5e5a9386be1494e6507e35ab69971bb33021e07fe427509b7443c7f2c306e8ef32914ff062c81b77998a168b45b0515ca32447c059f5e081199adb588f69b947ea459c69fd17905b12dc451c7df578fe315c45a74df34568905a36e8eb2cdb8024e96bf22a0af46339332ecf5371f4ebf2f64e406ff1262996712a5f2cdb232232139acf66e335934ea10fd6ebedc98dc8db3ac82deb44e865b5b5149cd7dbd7f85deed1fba13402bde4473a246f0682fee312944dab4cbce172d6d00d2cc4f0ced8f18bdfb8904fa9dbe69458430c42e390a14c52542c246fdce04e104178d9e80fc42231114da05627fb0aca51b2035f9f1817b30f90dd2ee0eff750ee3c949eaa3ddcd32f2c88638adc15e0fe0c801a2ebe74f25281c51dfe27936e7fd0294debed3506269b7d5d5410cb0fd03dfd78ebf18f9ffb9edd14d5b52b1e7901499963a30ed2fab646dacd8955afa9c2a1572a81191e3657b97895a231c4eb0eba6dd54648ae0a5e7a0d9ea3f5956e2d859d9c979889fbf1aaa5f041a31e5d9c62a9b811b6ae76aed2e87cfb4db79f35aaf31cef09b37f6fb22268200935e4966c7cbc946cbc0d7e0e4cfddf1a58cdca8cbca98be26e3a14f81c949580f0e11519320d6c8795e4f76734a31e9078ccb878379e07331fe168cde873771b41a83b46f14459291c7d72ac0d40fae9d92083b9be5f8381704f7618b21ea9014b6d9eaa590c329f45e46f52318a5a3f896339b79730d540d14ffa38026b9345cde596bc09e5b908a181e77a37e21c7778a9c83f844d0ba2981b4c67bb9de80deabc58de01cc0a16c2b0c9e5ae231caa6c3e96537e1ac41d2b2555350a7471b796d7a6493ed8c7dc32da0283828f37932e278ecd4c464944845dc35f371ab01214704608d743b5810c179bf88a9df2e43497bf047a2b044957e85d909bf7841ac96a3262ae8149b02f43e9faf6c08c94a416db69eb0474f4f5fa24b77c96cd30389025655019d8603fcb2cfeb632c5d041f18ce745b9cd2ae859afeeced2f7b8ecc84ff33f8845d1c440e1c419e5db58ac57d49ee04198d5007e8c1573fb9f0d948c3e67ef27a6ea177e88215aca15ee8c8a71cdf02b5b61dd254680e510edd2e278f1bbc037d0ab3a5f07d4916abde2d07d2aab49dcf0e1a957ae003f1de870b7626e36bcb9a92bd0915a4a1554b490f6b36eaac7371792c8fb82c6b931e7a054fe8488b67e9f62ac3b927f9ca0adcadb89d98d0c42eea5ff2bf0f984536462bdc040baa933e3db69bd5dcbd0c2d9330522a68d0ae8fc882a5482fbbf6ac63f6787e3f551582c837f3f3e0918c9006424a35cd68058b6c8a292f16e4ade8f2b554629c616a15e05b6cb94849e9e44f296c7c323b6f34e3cf6bf56aceebeb485f6c5162c77dbf4114daf2e1e4c1316bb4a450b898c78c563d1147b326eeeb9d053015776d8a4d7013f371c61ab0f9a7b094eec7adb31e73d9dd635ab30749156bb5dcde781f1984df081e198f63923aeadd2cb42c0e4e27853f7bbdb74acde4ae43a0f6aadd569d797cd877c67fd853777ea46ec35dcef1758a6baacc794a7d4638c26259dc57c29e1796cea76052bf673feefd255f0f3b1b05cb847ded9095707bb1f00204cdb8a20fd87b0f29a29e3b66250c9ad1cdb39c99eb1e4ffa6d24a21b39cf5f9e416080a018b624e123a6b6d183681b7cbe2729f64782be4d067ab260ce015fcd29fa2d550649c0bd79e20039ce3093fc2c0f44fa62d2786d130b6d5dc0b2004e325b63fd59d232d65aada4a6c650ae21f0e2680237668f9b51a5d2128813d24c3056517bb99dcfce5fa0183decabde51204a9f80b43ea788a0e1709aeee70ba1299661ad4c98dc4bb7e829680c3f5c4df9f874905ebe1fe8b1db135cd16d4288b21797da7b53fede9f614bfea6cd2324d65e54e3fa2ba4cafd5ef62ee5da10f23315e78858a8aa4604231ba3a1c228769e1b8af1089ab76df08c3a79960e48bd16d64aefb1d270af530aa31229e6b6016d62bb1eb1d1ae0035998811773c214752e411741ccd530b40646b59be86386abc1a89b98b90937a0c6af639ca9108820cf2e1f9f251f684ca5f2eee8bbfaf140447b13cc201c921c1960df6765331ae697e93e8188ec50262cac617a98d56ac4dcb5ce90efe1b4e7150477cc82062c45250c8ffbbb388a4e49018e3f129d32227ddc3d77d0026734f804aa89d271508337ce1207f5ad737b9096411359ce7c14a1318f471391b5b68595de007fbc97a927753ee9e1ded2c7b6d6e7bf159b8cfc37d23452caa6b0ec8d6a850550375a802cf9ed1ab09b4ee850f584e3ee948a313396f9c1df952432f7004adcba682706e1ac3febe39e646b148355103f565ebe36a7d588d50574a1cf56ea27c095e8cb9e0ccd88e0a9e0a44c5ce522442eb07ce1fd98b03706be469cbf2773c90e71bafb120605fd39322473a77c81902a8572c9ea668be0520e7126e3d17b3a6d09657a5ec88efd0a745769716e394b4be0d1d39e7626e8e50e41642e8ebbfb21c9b38c75493790333e6f895d53f265966bade5a00f837e757344830ff4bfa0bae72339d0dee36b3aa97d455475c4d8c37d7b42107b2783777da382f0c1f223534cd3df8c7e4a3d102323a3468e1a3528314efc0e8af34dfb25ece76511917d6b46143fc34aae7145d4ef659923362534ed93ef1abe8d47281f347ec7959059179dc2aa0d0b5f4db440e3dec5ad0e52f37c0f4dcaa37a26a3416c9abe8b7b329754475a34782f8c1f63c806d2e2b9dee8b134594a507f519411611244fd805ffedf3b9904dc6d7ea2d1cd44fcd8388168285dac49bd95f203439e07b7b9d4ca06c4bc7bc37043bf9c12b787b8a0e1bcbcb60e57d1d98ae04733397a0be24497f37e7501ef53dd65f4c394bac905e51f70ad5af828c4cb0e8aad9412091256d0ab7134669c1df526a392585331b36c4210d938af5f77b40a42d841b0d04ef137a588c8f9d609411e7b635777a396824e96eb21133174eee3947c1b9d29eba01c0d76e16f81dec422ecce2bd8e39bb2396c4464e249bfb033f46867223bbef53615ea33ac68828b4289c626cd4f4eed138b41871dbd0fef269864a79b929798260fa531ef3e43df9180802ce09815ea6968ffc70e564016a37b1dc14b8cc1ca8c66700b19c5b16d1ae4f8fb9e245d9428834c8058af6c429233273f0ae172307809b3a52a83bf20e6665c60faa6a8e69e01667abb650cf6e9a00bcd481ff740463a3a77ef01e619fab0e100711311567b678562bf8c9331412bb16bcada7a9e35f845bed1c475d8cc1b69a25cb7f7aeea86399d698ea905642b61aa703fa3f344d34c02e1f7f765f1364eac82923018267fd32ab067d05d2f9d634f5ec03673cb0188092729ac5404c1674ff96a50abee19f85484e3e1d067cfd03cfcac4721052666035bfa9e88dbc8f6ecea3b74f238f19a163ae264bcf1a62ea90fe8ebb49d1561a33ada30e6dd8e3fa648fac6f0546d5e7558dd08330a9b588de0263916e94f8b5d8eb8af682a77e83960c0e34ed5002146ec21515b6e02b3871e79a4e980fdf8b056237bbc3635beadb32133f8425c99b9e3e49849a678bba147023f854deed7ffec059a6e012f949f2080eecf964af981a398bcb223cfbb8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
