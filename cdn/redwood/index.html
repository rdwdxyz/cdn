<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d4ec05651ec80631684a3e4d67e67c8ee252e94a900e67963806c0adf5462189274089d6f82f8b1bb8c05f031c9bf1f60abb36f00a17de4b38e0ab8ef4163d0cd93a57828bf2626e4050fead3af04b6639c53cf7760bf2f8f1dbdf5d992fd09630dc1b02b61ee6c01f6f3c29a6a71848bb088f523ffa24a7b52d5fccdb7e26123dffa90078cfecc288b422f6fe3a32b4813cc3eaa6947872a383466e528c0b108ef8d5b02b98b377bd914368cc7a5331682ba20e925d9477eb77d1a4db62c7f3dd7a2ef0321fb7a2bc806f67f12dad31dcdf1d25bb92c6dac9139824992eee969cbac6d41003307e17120c1311761b54ec38143d77cd42a82985c5eae1b8473f112b010c88aa341c5435f54551720f6fa051ea40dd6d98d9d02fa612e5e95bf0be386c697085f5dcecca13de17f71af7bd3585ab881afa5952fa94c1a2f862f8614e62b5f84a3da85d9e2aeb005406db50942e66500d8ae8d7d27177b07c60c7c0c1b7adb063db034e59dbd650fb50e09736aa5404a6604fefe3d0ab90203b5bcbf416cac1ffa3fb20ad900e8a7a8fdcd153f8d6d5c70f6c514907292e656ef983a13fdaec9106fca1986646642e820af277105c7ec7da3734d195f1cdf3f312ddc2dc67537fd7ad63de1c298d6c13fb315c29c0e00d803970e6fc3247b71028d4d95b021adeda1d02fb1f21e811db8b65b253305bd4eb4819ce0edbacd13504771fb02299b0bac30a4779b1bada97215f04dbab80183cab86ec73cd2cf5a44aeffeb2cffd1f4588b10016b454b44f10fae0d1b9dfcbd614f062d24163573870afe56c02c939a7aae1e5fa6a7d76d6fb9046a959cbe4759b8b4296089759cb971974197724c115ed05e4faf3f106f95b720c576cd5e3eaa3eda917c31f504ba54522d47ad644eb997947bf341e6e7161675491c35bfefe7e9de9de00e68a36629327ba7d028aa261ac08e7120f1dd12e46f066f6db394b75d90e343129cc899764903568bda656d9407d01a5c1d748788000be901013f35248928b5137eb73e29017379e697c3306af83723401e42b9546a061bb7ec90d337c52eaac35fb3ad2a0e007de1a74e9e4dde4d190958623c691a45cc34590b51474243999540650d7506241c80d345316ec23cc57349dc3ca1470b0a453aed7d469c8a631d39c49aeb39cda5cd94d96a13bd9e53dee5bb4390205b527a509a8513ba5fd50cc04836057d8b2e2262daa77dfefa87c6cefe3745b65d856a946a5864308080eb6d38409d895ce312f070070f3f6d52619d14e3b54ec865751da9aadd4403e7dc4d2a0ca4b642afd709475477b6d7ad438cef5e6fd7fbc3b05cc06810635e2ec1cd50b2cf5efece967064f6019df373fe343847e696fcd5aa924b06c85bd4e89401cbcf0ae544b04b60a64f762ace1992569c27cc774ff6f0c403ade81b2205a3de80493a19624889560a5b6a0b0f809d1bf601b3a99f3107cd991554d48f39e2040e02cae1d043c685b5c1350aa3faa52b2721a7598c01b27f93c9f07a62b75b86816e6cd76a662573d1283076174f0c7b2f7a5f85cdacdd00c124df76acf49f4d5d3f8e2c49f0c8bb80cb3da595d67527d60bb5444dff50ac0e568f11d0161a400839d4e7bdddd9183617b739de7cd74087341c7f946eb3d90db34221b3243c25da90874a9fc8e239e04ec1065688e7cb2aceb3959abaf76bf09e7c40f4da0c0cd0f2baa6e56ee0ba9050eb65d770d3c3bca77ffb7d6d5267f939d58b387ff9b28ea007a4bc27ff935ba4ab97183f0a2c67bead04cbb05a41ebb1e5f06de3851ddd664fb6a8eb76bacbfafdd26aca1317be696d771bcbe18cdfd8492b10423cc57eb0097ba2c1a6a49cbd081ceb02c278c51d706abf9d98aa0ecb9da4bb318ec69ca97970e9b0b037879695ebf1a97c74eecdca2f435ca8835f2ad71291ec68b59cf87d790f9d089f3a162d165502bc66cfccf0a7468bb30b1a021596aec1f3c69977989287340717af33f75aa32654a9bcee6264288bcdf49fa75b946a308d92b20f760213c160c049458d215a50aa4c5167277eea464df37c39300c57a1b0ada4147d53956a17fcff8d9e45e84dc1d6c4c2bc2e051cd275329b7f7a34b87fe212b032fac7703451fc079702228499882d043bbe882ed60fdc90f7c1945b95f90975ddadce0506e21705bda1da9da6442918b44230232b8a6efa5b4f29ddf7f4e46ef9d85bae524c71b99a642809129b5c685970b7fe0d985771044e90d302482367aa7799807dda8ad6aa8868196a9ed3839de5c46cf3c4374a12ca08a5b4d96fe9cff7b7ea1022d844992b31ff765db981801d9e7ea1ab807ea5116533acc9f5b590bbfb6535fcb3fecedd9532437564bd53273d5c138b0f2583f33175fe9012a84974986ccb151f01f2e186ae5863dcc1e2fc88e8f4636247ab513d94f6a90a3b15e00239e8254c1b521d136c3bde2dd9655c95350b71802044d0ae08d0a0d2c968e74a2b289bc4ffbdf62dd52914898d34cf1920a90e3856651f9a08c93bbe49c56a9219189ab3015bb0221de16be0079b37820a4b91a83a3df2293acf8e44f055edfd8209588075bfad3d4dc03c3dea712bfdb993542f0ad83cc465580586ee882672543f2fc85579cc9324018856e7b88872bc8470a5685edbf3a7bf464a12decfdde1164db73741336d6334adbac3a70d191fb5d58e626558976cd75c99884edbb828cf6c2910df7019bb3f7da1baa5a429d7d087f3296d2bfccb3777f99606dbc1ae9fb00825a3eb2787c45da33c23f3aa94e83582ab9b3c78f03e1b4b8d2e380129e4d2feef3a45a4fa877b235ff8815533f8820678c736899f7ba9fdde0baa754c5ac9ff6bcf6b0be5ca4587ebba3a55125e88a79b8bb5451410a8a63fa57ab7a341ed0af8b740d7b9997eb79ba95254d8c3e737be5f9e89f9593dc1baec7eeaae8c1f5cc56b3415fdc3674ac8c58f5d4afd25750666989c02378f0e14b87a45b83e82378836d53020c5a1e87a5664e99e12179cd1dea3debf11a298e7d6918e87ad6a377af81c1de7042d2f65af6fe505dc342feaf084eb3b8e5a5b4b824dd60674929a6def997cba702f49587b6a98ff36cb60bd562286bb6c23abcca9ba8322381bebae8ca26007e84c77a715b0eecef1c6a43bbf7bbc7b1efa816fbc445cac66911adb956c660d9e8b752eb2430e35f248e84534875876cf8f49a66e14caf91fbb01c1cb7dbe75927a6f8f4b5e14f3ac5fc5fd635c9db7db9891ce8ab629d616724b37a9df187338ef626f1697fce199b48dfa01069e4e762fc85a898d4d3b137d33feb7daab195c1c87a62de4e41bacb6e4abc270aca8dde98d79cbec69c32d3f9cb8f917775aa89bdc4942de1e496745bfa59e2c922cb8756db3a3b78cb98997e0580b188868a9737f263051de83c77d1f79d274d0c9e61c8222eff6a441c68ae24c90519efa4bf8cb3c82e4b1eaa29f6a1a9cf6ff77f50074af5def3c44f041a6571c4efcfca632d2460bb652ada378c5beb9d92504f3f523171c9749b9252e02a3036b31be9db2ed839fc4ce7f19844df63f96496ff447711278b5880a414bc9fdaa0050b9dc2750b5bc236b17a4e2a95db5a7bdc674434b6325734bb204821494d86d9f667671f6d3a96c67f4ef6e3211578ad511193ec78361d876aeeb48628a5d5232cf6ed6a1eb84f16e7a5dcb643dd8c250fe60b2b4937121922158c454ca62adcbb139239a8cc10410f324df8f06a49883eecb12b560ca13008fea6b7bfa0b1299b0035fe23125fb7a4da755fbeaffcbd5008b51f097dcd11af1336062d2c290b35bc6a025fe6f3c8ee2d946b761e7e2b310330a93c45d1fbc973d859fd76133babe97f55f7ec17dadd5283ca6c5b1067ce80f6ebe3880fc91f38a3d41d7e8b3ce5597ed734cdcf5842764c29d2ad9306c69e0bd345c9132b3ae80f4b8bd02ecf68e81df395ae814682a587669ccaecdfa326c8f3448313113d3b6ed2b2fa5e8b32291de5b462532d6060458afc0abd7e2159f8f44124f5090d261111c61a973e6eaa619eeb92453a33640a14552b786dc79d01bb2610d876aee2e398669fd7596f5f9a3c65cafba359cc4d888003c626c44c5a2f0e72033b2abd8e6f8209f47d6e3411a10ec46c654501dfc2a49d5b6911723c7287fabd7cf259d10f80780bae6b69ade3fd09bc0ec7fa1604e9e3cd5e6bccb0bc33e07218a572ef6ed03764e7ff69b1c3a571b7bf54ccb725c48ec9ca7bc49e6b8f0bd2609f24a3f57712a6d383dbf98bb4c49b9bc894b925b2aef70d3a11d3255b2d33661dc921be149f46b2eee83d1556e52c2f86ae6891389c9f8f16b5d89f948195b797af3a39ff73d46a16f2cf821993db12bbdb5d7a00c2a7071171725bd9fb59b72612a012a8e7ae52f47cb47e73fc829f37c5e5f901044815cf3561a0e6f6c7d6ca4c29cf10bd5aaefdb09d09833a9336bc611a91bca9e021ff7af44e4f404909aaf44c9b82a144297314eafcd28c9bcae8bce47ef04252786c9bc8e93b406d4605956a003e78f5102c627eca89deb8558fd31de6f4e3ac15e13aedf41a4e3bce6519d5ef947b40c5675ddf35ef9ddb21fa6efadd12e521cb476bdaddd2e4fdda4c193e6f07a7dcced9171ed5ca60810d9d8c99a8017ca38f0234147a91f550bfb974d43e571a369ce3d859e6842fb4e5522aa0719fa56df933d44a1534e4c6f065231e68f1ad5452aa96c3c3d0fc34fb686157670480f06c53f94d271b70b669baf241569ef9db93243ef8e0cbfafa163c25e89dae641cd25cb1d33a46a7bad872ef9a866c795cbd9a3ed21f6b5a85cacf7b7ff26e3060a553ac0eb74a92cdeb765f2297806956cb0ce1d2a931c21039d03a79e0c5051270fe99925006bc1b115b817798641c1ff0c3087f3e67608cc35bda95a377071842b5db1503910c24e7843dd07cf5692e9ac0a2ed0f601114a9fda87dda0e3dcb813e41fabb950ae703d9027693efb0be2fdc46726428d35907ec8d90516a3d638dbeb103a6a1dfdac4e418bc1074977e3f47839387c881debac3bdaa845d6445760766b22ce25dc51cc96eef998a92fdac60fa7d3d9a4bceb0640ff8eb756f540514e28289ae7f268d227442e2a65d9a2c4863711791c968ee18708da6ed0f94269c375d064d5481b4772db4e31b56f9b976c90428be9c19c533a2f94190c1ec08c5f27a94c4839b9daf0ede6f64af6c5167d32c4971c09374f64e94f50af1bc0ee5f466a0488af62b199103807b65ad1aa3b895f86ed31ee79a6709a39b432b305d643142388fbad9187099cfbde6f929b8117571147838f6ab387568b427305f0aa8f173fd63c836f4b81c79a8b0ad7991a52a9bb8c884b50184733183222d8d6ec5842a9e85b7b30d9dbc68d18ce0c3411d2461b8c5f636be6fadca5ad01deb7f192451d1bcc6731d211e7a3b322af62ca4451f25130ad83d28be41306779db1e1f3294c03ae7a0ca7cdf838897ff6c00bdc83893c9846bb1eede277c7358a0740ba32c59db5723c8b24c11d3c8594c97b88743983a41123ec548db64c74a079e2b502390acf7ddbaddd8d0bd70236928c9cecc8eab97e02a36204f03410f4ee7f592abec1b6f219167557981b711946ccaa6ee46a830d7537613d6d825867a4132c1aeaeecf48721b25eb7271bb78fea4c033ea821a66bd8729f6492592c66c81fba30a12e02c2b2edf2c73960ba720f990c285ca1ff4da0e1ddc9ec38776deafb1dbfc2baf5b94b5a3a0b3a97e307b72fbe3dbcbdc03c1208291614fdd4a004e029b0c38a9b0fbb0b8e0efb454e6c2ec01c6e85d17522900e3c8712ca56a712965ff3ca3108457321fc76a4b6cf79016edbd5b296aabdd0fc93819454635cb4ede5fd7c90cefbd581a70a7c023e8fbd8ae2432d18f3955df80f56fffbbd464808414231a3c777d33546addf1942819414d36eb89aed5e287eb36fcfa89a9c49d03acd60092fcca19e986e9ad88b4d4bc7390531e26d59ded1b82c0b57df165d65b9d6aab12002550679fe1ce1908a9f07e5f65b42724255c8a1923936ae56765342c595dfc51e2914a3983138b4573722164ef82def3473664cc8f567baf9e4693bc9cf7ab81a68cde50acb77d624d51155a61e8b5cc1dc51ad155ccfa3e3f76516ab4ee7edbcac665f3f37f17f3ffdd2535ae81f5977ef47b46e8045440f32909bac6a1ba7a4b21e2fa71ff0c825ecda096efd51c2942af92581737ebfa28fb907404fb1a0c22026309292f5ed9eb60495b3e263434135ab5562a0a8256f929033d66a996c1dac957f7e9990aa352d4ed6ef12dc1b166a5c0729dd3ddac6057255c4da4ddd53974f0f68203101eef4fe682eca2e41ee0c5ea58782d6f82a10fab8ee38c2b1395a7a90d8a9f5980b9f4ab7a8c0b643268571dcbb7b6633e0cde780babd1cfd944a7262974431e3c584af8b93b44d25d4d61f7393fd822bd93922fc7093ac35979d9a6c99de1d4732318a06ce346da444fc5749b6f5cf9e2cae93627e9d570b12b59e10c807324d2103bc6f5f7e2046692c4f22986027e55655bb0b04d284ea7518a85e93117f0641600286650e326dc817a546a72f0f4ff014973ade994ecedf53271e4c4746c65f5596f4106d228596769b956c2f82c35c6af983052d95886a18573956f9ea7949064bfe58977acbfa8409f19c121a955be0fc150ac4e8df3e38df6de3f00def420d9d1f6b4414158679a8bd5cfc9afd3a24b1dccab42011eddf33e7b56dede5bb6ab89c78f8492087eb47bee0f0a8238514098602b440ac446b0049a7f6dc534bc22f522e8735ffcf80cff03effa4f0bd01e88c50bcb11ab09117ba2a6975abb259bc1dbce5e8735b10d3cb9cde4257c076f9de290441a9899c8b9a161c971a682c21772006bdc150ede794ba7a073f8d4e2fedce2a400f81efa31a90a112ce8cee8318ce5cc950244b96deef9e290cada29fe904a3e4ed091e940af9d40dd241d8eac1f2d28067bab94129e9aafa8395b3cf47e4bb07cc94873fd8b596a6b252c56d1a5e77afc9c8e5b4c53ebef0be27e31316195f988fdb5d86c87b0462b5e65650d38a25d29ab11b21e224faa68e99b3dc5ec279756246657644048d417867f640e400b5ae699596d625d1a6bd04372622a050ae107b0a3ab18d5c4728ee9f340959350962c3114cc4aa94e079bc80e66be8a99bbc3d54745b5c6ce666cb8b61eac582c7989559e5a3a6f45638017868c227eb9bc81b0659006081a6b6d0fa730b977f9dcd5481b20f0cfb211ca22949a076dfe15e841a3bad82f399b15e23caf1c128c09f6246925d0f80011fb1b07f6e4923f314aabcc36c97c703caefe70f39f2fd72556a5c2bb7f4a18e80d08d1b3c2a40c6a54dc801238f803510a212e92a65af6f7329b8d7ff8de44cd49bd497c3bee77b1cc667ea7a5514fdbda1721373fda2f7503b795cc8cea6ac456e125e6991c52f35aad7368bbf0b9ca7931e990dfed6beb4d05ce20f79b939e9590c2c61b567a30c3b62db341b823d1dd9d82d398e3f32ad8e70bda8bdbf650df730dd15c58ac6829cf2f3affe254ac2b8254f7e21ae4d8dc358edd9defb60435b81351fae1ac280df72dcf03938943e706f16dfb1bd3ba4e7c01f0682c1aab594ce87b8d038f09d3ea7e74a36092f232404c0edd50b8984ff307c3be42f3403260d2579fdce7c48ebe72c0b7ecc28210f5ce536b96bad91d5e46d9b6a5ef58ca4325eafdef9863559e4a549bde4ee5bd40e62109e1595371feac0cebacc9bff1fba850f3a1a577dd78b975e1c7e80dc6563045d8572bb7c94742298bab88f78550ea5aa7d8f3093604735800f18dd1481b6fcb70883fea2fead0c150f3c46ddafef34d840b0f05179d777f7098b492847161c909e1883d6d614e0f2ab9869f12a3f242e39bce0f2a9d420a32438259063564ba8b8ad93f4253995267c2eb20878f62f0dc439fc985a1aad6a708c24a1adfaa30392be2cafa4a15602cbc099909270eda40500d63f2ed8ed782f46120436c4301b6d67e3557962e62e361e4abf836c2680b740514fa335a38383af3884326caf1f4c2788b275de878d1af78b76f6cf3c364f6c6858167f67436e7801bb1a236cecf61ee0f4aa9bca18fb7685c92cc0127da635702573808f94cea691e8ba56ac787399474c5ef3d331464c03ceaa6b56a493b505d1a45b0aaf3e712c6a7fefd6631bf84495d17903848fdd284ff7c2a026166f30036219aaf8e60cd2cc4b3a63c57f41b2ab94ad683f41e6a1cf8746489a91c57310a6c8c1c659e3c48f9de1fa74b43bf3c7ef694f6bda16c2e0c7494a25cffd7d284ba4a02ec5e1fc4ebab64b02dee9c5c7a2d648de0b5cfa4f7b3f369166e31556336ad68213852b0c90d1fa369db40747cfd0487d44708622e4f9547b795cc065afc018be2936a7f72a09b31fcc521fca727f10724c8afff9f9df2958d1c2048e54f7e1b451868567515326d8defe1b110eade3e514de4df03b97e33f59bddef7c49ab993fad9005c68598cc4e7c7f0e227c415e48c5da14a73745e94ac58544d230b63d4597286401caf74d09c497b4f7f3565015d258246ffeef70147cf91f9da4b77327cc26a787beb0bd2b8cdb1c24f5533b2c7e230696782df8e5fdbb53109a8b5a6dbfa415784e8a703207f5711589ea2bdd8a2994dbaff8bf18c53af5ebe543f48fe94d9d347e670426c92a71a2216ae8808e05664ce1f26a97ee55e0e6583fa092ac35ee64cb84cb5b56946c5c19e39f61f14f9e1ae56a61f2b94793c2ca43d28af414115581b98fae13d9ae175978bc4b24ffe9fe843475ab17ef23cc4d7893c2ab5896bb716cbb0dcdf8c898e4bde4eda9e96796899639f22b01ee4e1db96862b743e1deeae95d8e8fe219190c2ce8f8e09fa44fd41af71da9643834a20fa3b9878e4f1f7d06371d380f27065e350ced3bb1fb51c2ee40d8a9d45ac6ffe6cadb1c3de8cf17be77c8bd9336b32ef45b0c2467e1419a3d0d7d2fef5de71050e69d0e9f1e9b82d465a549dd25bf83aa9b0d0d61196ba1cc5a9ae8a28586e78f7ef997cf8e3a18c4010220e4b42fc42bbad925eea4fe31dbe73620b5d98f2f5c359499377b4f3dd35a2e66d4db78eacfbbd686ec6600f4735d11a64ae46a5675b282e506d3e827f3c8233f7de0c0d02905f9cdfc6d0e446d339692a3f2a8818a8e6342e884254604b61e71009d3d663eca9ffffd234da912b51429ff5de5bac4028188d35e233f7ba7bcdffb2d02d963a58a1da8e7712b0d9650e3821eef9bc5c0183979c9a7fd0dcdfe6aa5f132d8792a5e256cc1e55165982e61109699fa1064f24d8b33fcf52b014e18c4d1c45c3df69f0f1ed0b11ef519707491accd2284e0ba484c173966f8c9e3e15364cddd2f2beab90b70b1461f3a830d2cbfa77f55f7b6b789d93e611cec321f7b408ae4835192f9d4d6fba4405e4036777682f5f6c368d273967599f88bf2d2b6b217210bd18c616256df7f59a25297dd1cab929b1d59ed00a2c79afcb385a810a6b9c093a66ff7fc4362959dc3457c1b490b45579127e5de24bc3ddc05dc302abdc32e48bf21aa935aa0639bef66306c420264d4cf8bf6bf44c7249f63dac6bd0b7ebc68678eb9c8a6ed0816f254fd9561a040b00d8f0a7f3f760b05c66b0ecdbbcf3eb2c0301f83110e6d0f65621d4b21803f2e19dd6a77dd6865559682007461879e78ffa5956821d2da82c522ab7df1df5444a725ee1f8c4ae3fd1ee3618f53886b0db458eda54a9be984c44dc3549edb345cab55bdf229f85f19752a468edaa51c686fd333bd6cee65f703b650b91372a87260d48c9115ec0776e40f7e50217bfa84cc4e85d1ea75e6085a35299cf049b253d8e6f417daa92a743d76630f8c50374145e7337896379b1fed8202fc7e5c41a680714eabcc65f5dc6c6fbf7152c9a5567fc08e403fce270edb429645a1db8a149c4898337a0590b905cdc380922e3fbc387071736608fdb21aaa9ba9ab84938189f47a3720f48dcc76578d111df59f50a43d595a956ff1ec68513d6de85722173049a64da1049e3764c0bee7da5ae3dcf26bd1c6334e0f747e11e9514986406a5d1a5f52ca475543ec8615bb6a470d30fde2d52cf5ad2d09146693d57ff3f3b6886c116ceb1d214cc07bee9503071f9ac7738d6a890d8bb41e4140d98865571d907b6a1b8f58cac16a3ae28c23bfe9db67ea89dc49428a4c46441614d8b936bc1c1f6abba06d6239da18f00d66290abc06d80ef4ba91d1521cc5954408fdda0d62b4d1c6cfcc9d431687e1b1c65512c13c4d27b3d4ae98de9df59c9ba80d5e2a75b2a3bbcad29bd9e8237d3c9b52dc4d99f0a9ab63d7e60503d743989b8aca994320cd2bc33be2791985a29f4b17f9dbef9c9116c5d9085104d939a4ab67723036fc3289661c2dc181d1e9b2b2be498b299b29b931897eee356b8aae148f3f30ae52f66a0da6fae10cf9304524a0189bf01da1d1c80e30f74e8b15956c30863f1417d0a3e94b7d315450fc504c55ae34b77867774053fcf465f117cad46e4bffe810cb391bed5a5beedabace64b75002c3f43590f84230bf0c3e41ec19b31ecdf2e48de3e9f0dd29f21886a5402a98128059eaaa1ecc2a23246377afe4bbc721039d8480adf254d44c47d912a1151e0ec241b868b1a75f180d0b151e6ed719e18b081c8128fba7e2ab60cb43d2579791bd1114a3899790e5ea01ffbf3f1224510b7a6495cd0462def511cf8587cd1ec188ff4bd32d71fcc3f9241de2b862183ac10340b594d753c5412d007ba07c668bfb4850fb6049b906251232a546c3edfdad6477c132f13b5c70d892fd0c431e403e66a454f170508a626919a83bc65804416d40b70ed4c416a55269a17d87f083648d2983364bd5d5706dadb04377e40eb42692ee84c91e5f89c8ca944b3930512740c84d6d60baf3becbc06b7ebfffa91139c80c996bf0242132d45886712e4fafd84c41095e5cfb7960959edee6b61b73e1929c5667c2e6af9edd7ce3e60014df8d93d314b0c9c2f0903ef3af68c6d413c68528ab5f10ab8dae2452abd11147e4203f29a3381113e3581792b34f587c3470e8bdf21334a0f65f30f96e8f14afc426a22216a7ca31848d98da18e331bb47d6aa3114e46775b48d6f93b8a2f9febdc05b7809a3944c0341f95916eee166be498b51e519d58d48c9e35004d30c56a1b6aab898068cdeb79336ec193d011391327b20f4ff2f59a2da97eac32a3757cf17dd30e0dd93a8db6641c46edd4e84e511f0227372167f1efe27b2154dbb9cea3807b97a330b949c29ed2232db65dcd45e5dfa7899fa9fd8c399a170cddd17c6066ae4082ff271c3c035bc9768126448d4d0bf7bcd301afb26741409bb3a41aadc30e542acb90897681dd587a265f135b9228313c5e161651310caccc2d2baabc5a37ed7107b5cb714c31aed125c58d6590af3f1d63f35f454e09f436ec56571b031ab1ec6c62acc38726486e1e1e6161f3de5496f499b896bbe2b0e4f8899bb40644cc7688a6916691c2d73ea32e95d9b16e204dabb65b214ac2e2b0f335364f01cd188c45c3caa4b72636a5ba57191344cfde8d4a7f6efffbe832d30c35a20a871348b7b261811b4928874e7ec5a8137f2a400ed111403ca76e6d8ad798cf995cbad645a805161b1a49a6719b06bcb8592b042c7ba4d50bafbfc176211be2adb30a67fcc934ce8f7ecf1cb3f1754675d81295fbda5c84073c4056b6a7b64ee404dfd2b84880ddcdb143d819ce1b1ac9a584a300f2a992459c5c4a6c931ccc02140cb1dd9b26777f9e415e2801aad205fbf179917af6eaace402547d2292259d7a540387219d798b92a041645a3f819bad798d2a6403b2042a47af328d6bfc6c8780adbbb9de078435078cb9404197d6980ae79ee64efa650efd7106b40eccfb9e15d6221060f57962b5f7b72b84131b69c6945e3ca48c50e586a06839e04d4570685f30e0e996b02a34c5ed335ba6a3cb26b700e54b9640bd232d638e940cfa18da010bee51be6d479b0c4b54fd01989b0a8a9970c28878f59d68bfe4bce7ad3fe893cf618b295ba1c24092b9e77c361a5247acd992ea30f243625cbae8513e3a1fb49638dcd53cb3df1ff1baa3552357d314b6c795327a16a249c57349bbdfa226a0cbab688441a998e6200cacefcd3a3b5410aad2500361b630adaa4298da11a48e0f74f81904c9409fd4e3d01dc67f933497db3dbfa9ccfcd76a786672d102e4c008c08c18c46f14491d1d8640093275a1741b55366f57685c0013d081843be277cac80500f60805efaa42d3853a392f287df680f27b822edfdd7fc13dcd507c1e214680e2cab164cda6348ff5261613442da4f9a37d5b1454bdff476ccfb9e41108773ae28518be75d3d42144d27d80fcd8427925263975097def335f09e0741e9c06a6c586bd960e71fe47ee42ae58e3f97218809c7ce78eed84369ed857f699262333fcd983e222c3565a35b0cdbbb598282494b1de48e0d086086465946573bdd9f45d7cba0456b13009b31ea9502a1d9ffe2b56935ec40997228063ce93b6e0ded987cd0c4d317312c0ed0aa50093dd005419c2b3c74d4dc6777a1b612b6ee84d5e00dd7945f6c3614b40f204044c3a08bc75ef30eb737e4f7e26f4530aacf9a982481bdb47a20a62313237e04f2bd56ecfd57bceab13be038c4b9b1ec03b2c8ea2db8cdd7e37feae235cbba832c98ec1c8ecff6c9f3a7cceba7974019d659fa96b0b58c3d0f53940633cd6f069336c11f829ab361997d6d306a27a80608ec846a1da8c2c43040cd1422190b2120842c3e443b48b4400c96335b92b2f8a86b1aaff78b08fdde9f7dd313f5eb739d31941067310d27aa38bb1c87f2abbd10649dea384c6c4ac2945320668bdd8c30c2a6e4fb75dbb680f3fd679fe8490fed83005375e6ee7dc5b90a7dd69a474e78843d71fbefd2fc49f2ee1b97cee777f281f4c93f465c4a244d61ab98466a21a95afc57e92d7b2a87eec645edfbe71512bf6d3422778544d744d15432d849643f51b4c100c7138d772e4b364caa8263ca37a2ff4c6a49dec18d683b2c0d675b2b7b5b6653ebb99f41ac0df156c453231081e985a31d655f03cedfca7d96bbb66a04b75055a1ebfafa188db2681b89fc79f906c60f5fd7c492a4f36c3af9468a770c64c77c5312926e0b086447ce8d66e801621aae168d92481aeb44b5ce2f58db2dc5d6f37eea09d52461cfcbcf6df1ee6f027b94e7eb9ca23c62930029fbf2903ca5643be7ece23717a56a371708048dcb5ad1cd765a9e3afb06dba2cbd89369b0fa3ee3e61689c1c8b20b3d5bebbd0babc8a52d81bbc7f50c603026bb80919e55f0ea0d1629fdd7631f95c34f09c41e54b794dfd3c212bbd6d06b0275e82cae77b1c5bb47264bd0fb9119598c6b13e310064f1ccbb352f852f2d001275214518446d8548b04bdc423ebfab5b90458a3722e80a7703a38e06136032f8f171e9fa671c3fb62fffba5728db6ff12e3ad51d7f3d5e0df721f399a132fbe87a3cec22f3d2b8cb5441e7e7aacb65efd3f16bcb030dfeb28c60002be900a0ea61df371565ed14b0f5e2e9c35beaa9d3ee1132cbcc97cbbebc89a8dff951cb211cbac53703257617dc2227953e170c7d57df4d1ee8d53f06615b875447d07850bb78808101b16fb740b90fe69b243ad2c60a1ec11adb3e512f9851a6ce7d3cba9aa9d972ce3ab8c7a1d3552d93ade3b929f8c2becebf333b5db57ec044b7f697786ba1d0d2e7f2e3956ef38c272d23cf7561537d53aeb2c1c9e0956fcedf70e3b18f28367b54f1b6317e37ae06ff280019d4af5c55c04aa77ffee2f00ef0fdcc745faeb7d391f1b1ac38864f24fe241354e7be289b17a7f2ea0b87580bc92cf561af60d27c936b465ec4eea5c57f8e26ac4eaee34f1fd6de8a7e4a8d92653913f935bb02ffd9e6a48b2d876e8a22cd686f945c10883232419231130ea1f7179c797eadf111c7e996748fbd977c7b4daa615c3ff61cb0976c26fa1889a410fbdaadc8e8c295572eeb213749a74ab930f75e3cb73b9e8f4c3a3258b2e3529a11297a01babed608b1a058937574eaee34f52f02b7dee6ecb0c28cadf167cf95cc621f8b5ca1c00e5f7b5ce206a4cc096545666ce66071d7e327e2cd27c3cf975a34baddd13940c3c2ef37a9cc61829d7d30b2bf9d29526ef122671bf4d99303bea513d897aa1739d76148ddaddd6eebfccd6e3162bb0a4df8ae11c266a7223e3a80454a1dcce506e91c4384787c062ee40e6c875f03d6f7a68c2e3a558e4abc20a311c754a63af9e7aa35d0a51d11b71de01cbdf6fcde8b115e3fa48a662703199ebc867207d6e819e0afc954fa8a9a0741029246406499f9a9060258617b03317a9038b74d0fde6f10d4e0fc1ae542f76814ea6e8000fcb1d0105cb6b215980a9139d20622c8e3fd803c32ecfb66ca006c7ec4f16350b221b8a6021942898b73150bc57aa21fa8ac6a03fd01e65e561c9835f8491dced6d81ed26738ee708bdfd95452efe705704f113007f952f43000d0700cc773681dee55ae7803b94cf1ad6e88cf58fe6458472577378f6bf68e0f40028890ceadb23e025d27956f5cf41d25d3b6855cb7f0f918d44b471c4621153575017d8ae6095f33ad3a67317eea40252598db33cefe4868d216b02b8316b87a8ef4eda7e0710d3e03e51c87045e1d1cd463353d90945d78cf5b5351cc8efb084870223de836690ba7baf585a7974a2358ce1f440e35521e21b3ef06a356c6f260fce99e5345d61dd58f6478b4cde552b5d569f58a9b2a82485716c55be7b24cf2004bcffb98d6268b0c72ab2049374b99f8d6ba434e43229eb088e190c97faada9210b0413c2442c4402b63dcd8c6269e0a66ace868939fb30d95bd8ac608168bd417427bcb2162ab41bfe4a589ee79641c0c4c2444ef403edae4433d75d4fb67336c7a00b685e36bbb1e06df7bf57eafa150ac065185e989a303128550db11ae5daa0a1cc7ad3a7336e659edf600e3377386c465d1527da2925d31e11f01f34b0d7ee4552fe6f4189a4c47565cf154801b7d71c89e166c9b5db315244d424653df834ffc7fbd1e012591a45ad4b2780c43d27c41cd90e6cf34f25776aefbf886ac78d9c7e007a38224a945cf994be7558ac58fb32b1a41408650fa67655102f37bc1335ebeb9a0deec29df413df97b0cf0060cb421200ea89f28ec46115800b3d755eebec847aabcc43b9a380715e5669d4df335fa24b27d07b18b626e609e09f2d6808e70ce318c2d57b6c5bfc5753479a2f768c2c48addb036ae49b826b2ace798276611b0d1c1dbe581226d3a6aef90e76e07079b82185c923564a6844c828ea9dafed02ff5d9d0e1af2bcf02e00b8addfb2067c6c1950278c2bf92cbd46fe25910d2c63e9ed19c606f651be6bc66e3cc2d16d39ab1835f48a0a098316c7c732bbde9e5a6a44b6ac15c2db2649e158f0b684bfa11e4c6ffeb2bc36132bc994db923b9ba9e7c3334eddcbb6791fc360816685db3ed12c115924251d3b9893d6cc7b4580922d8c2a8f485faced95cf9b4c3bd8efb03091a78c1f0e59c661dae8f7838f1adc6295fa04e592896199ed4df5e54d513e38d868114edb3846cb5bd621d74839c0bdb8e0706652b52d6061a2f443026e22932ba74539f8bcfd4795b8a2fb26ef50debd72fa8cd03378438b581a2d10e4dad526770e67e40a9585920a65416e9f6c1c3219632829944c35c42129f46b73430b04a1851ba717092dc19b6d6fb0d3072ff6073d3e011a4b39316110fd7db5158597ae9a6a58d4eb20f2113e3c1792922f819b9bf9cde78f6056d1014e490c0eb8074f946010758cb306eda1aba9734cdc68f9ffafa15ad5cf780810cc1d61a0656e822c8cfb89ed17f92b63c42c5d13c11476bb0417dfcd4df814db4eb7405d7d0a52c005b7930382947e7c035322979141eca3a13d5e125fa2541dabc5548c8be0ef7d4b328814845144d0b8e4a4a1adcef92ef1ce3eec6c50aabfa1bcb1f492e8c2018f5ffef0d6dfd8d241cc6a40633d8fa4f757791d1d24f0440ac1ac56214f1041ae184464c26f88a1b207f25e7192227037b8b1321718b755b03958093d751718a83198e0ad505a9e33edd30d7d064ec0ce0b72c6838f90227a9731200e1ab5c81954add3f3d8c095bb027a7c713ad3cc5f006f892e62eddbaa8f64aaf0d67f04dd8f3dac6c43159519406335c754ed807dcc5631100fd8e4223565e7bbdbeaf4eb3d11adacec0cdfef305918ca29b578d3f2ef7976ca9244c9347d31aeb4fb84f585d67010abbbd8b306a94b4d356fa07224d9110e18ed52abf3aff93efc69b24d44f1e9b6537f11f80fe14e90c564ac27ec310ea4382dfb657c741b5d3765a0b7d9ac8b8af84c597b6e8acbaedbe50c5f9b87c98d6e85038c7b4e2c515cc0b32dbe0961f58ac8979e0c5746732fbc23df8e095a86a3d28c5da89232242b64abec71226c0fb4279b6147932aba298fe39d763b743e8a058ef84150933a833881aed398886b70d16ef45d92623a5d4c107f9b39e5e16d800ad1b63843470c3b247b0e28f5845b5e5c72a7c1a5096b4c79573d734f79a6559bdab860dd999854abd20d9d0fe203af743c7f2bce9066a32f74258f29ca99017620641706137bea1cf0c49424c5e7093650518f61d53522ccd9fb72b01505e79a8e1569586a8a14ac3860d24466711801b6bb3526afa51d511b4851bf17929880c9d595dd6bc3d75ef7c9aa27ad6e87fdbb6d063066d35fde72554b00d09c88e4422a9693d1c5c44fefa41b68fe794d956138aa7d366169e28e9c680591ea388539cd3b5db7f578735800002236b195a6090ed8db91bdc4a9fc0b5f8b36d142310766a1a781b2942487b8d181024f54206c0d39235019dd5fe06fa8df44235fcb78b3440594f9375e60dfc7b1e4b7157323884bb866dd35315f80cbf88a80d7f87e9abcb848e2a808e0f28a1be07e62ef2e523f46479d29ec8a74977c173d9d6fa40cdb5aa25c1679efe53f67b75fa29961a9a6e217bbed1f92127d3a78a51c5f7bb01a8fa572bd8f550820ea2af1303a02dbe9c134d10888896b33ad381c68f5053d783550eaab452ad09d531cd5b67c75dd1cb43fb7eca4bcd8a1bbb1f01c14cefcc3ac0eae4b7f465ffbb79c06560ba167dcab777e9d39bc8be3305a422d3b8c8ed110f36496881aaa416bd6cbbc3c32fa2f8b9edced802ec5003b10d1b8e58df3e82be0430d0d794eb09aae6de22e778ecf70f7fb950efd437c780c7b3fb20f42d68bb18f26b1ce62dd2043bbc3ad9ce8de63ec0cf313a06bf17cd758393e820f2379da0ec4024be5ff67180c085244d1b50892b9f11a6f6669fbe31ba988767fe5c634b0ea0bf6d4f526a8bd2681e0a3072e56db5ecf565564d484731f6067cca773dd9b5ecc29d00edcc99cf4702c5f060f53d3bc6602288569630232fcf96d3c6140598a143e9f1c4e268a7a9b20223a773e56769a03683711abcec7bc733bbec3a02d4b299c8a4b214c84135422613c7d64c5ac76fed03de15d73ab18c7e85d2cee25f48f1ca25a57ca6e9d17afb4af3d25556ad1634864beddaecaa182f259554ff3b24dbd50dba7b07be899e86c7ec95df3b3c6c478757d70d06af73596a0afe4dbc1274c7a7666ad946cd14ecafbfa0bf80062854cbc6a7c793edf5b5acefc19515578643f181021c21397aa76c79dc635eceb5a4c36d0cd1d5f997fad31149799159e0bbc83d817fc56d7cfbd5a1b264f7bcd728932b2f4251d86de94f743ff07292551b97e72d3725a2e5d166414fc648f111b305d1e36f4b741a05078469dc42cfb1522b5649ace72917ac3086e66ff683d3a58ab9b4dd37923a35e977a7f54350f98c29f85b56e5a924b1d56a6140b2d1a5f13e6a54d009095ecebf30ab14132d5c3ce8b38b89dfc77089da041708d8ee5bb37a0fddeb4b8164b198c54bf69384192f14d80cbc8c8e00d11e0c324cab331baa9c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
