<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d2ef1a5142986a1704a1c0a846f8ff311e1617d7a50bacfe68edf92585878d8806c2f73da40a2a6707a0dc3b459474284c7df7d7ff558c2ea0eca0a1ce2a82dd9a9a4a76568547f6374249f5b7b0a3840eb92b2c58cdf2e993003391715509971b86335eba164f1bb958c8153a6f9a7d750035a64747c3a82855fa9c5c8cda2ed002bc6831ac67328cd7b98b3c7fa82891265364181d5809f3cae32873c6230634f8d22d29bb7b24a74ef85a4a38af74dcc4fea5f849a95bbb4591b3afee583a9f20e4714eb3b7921cca2ad659d8e44392551678c05edc1d8204cff154f1b05be592d1019f781fe36a2909cee94d45f3c0d077d5c8f2db54023d37bb4e982813dc87e3a925c8a9cf87fa31d1c20eb63828610fa2623039d2bf2610e75d28983e7db1fb86912a1c2e39081025ebb57f5a1c6d66e308c4b6cbed43fa0794ca7d6ba95fd4a65440fed1dfd1588c94d72315d7f428ba3483addfbc1ba6922fc329974f6d96c1e7e687924ac43c393ef0151a8abcacf2fbad17425aadb69598564fb25273a2ad0d52e09d0b39cc43926a8dc656f2c27e1d709eee6a8bb0a455cf0a8f8e549feaa3413e7028dced9bbec8b4c398cb3ceca753859ec2d54c4160c3075eda38e152fad7e4cce13adeee3425c2fb0aa8b973051e515af377552c125248b7035667210c0cd85210f0f65532b99cb3c60dfa43d17766bdeab0b506e9c7a4772e4389fb089702f3c4d5f7a68a9bbb21b373f6c015b890a0b51fd63513eb2a45aef56d8a20c4fd3947588cfd669b9807d5bdb55a0b7a86ce2f5332bcdb93e7d2dc1dce9409f6ffafa7457032988fa0051c21ca096be458c2f27461148712aa01c90badcd0ce0ced622cceae7956e613a1a2a3e68d2305dd5108fde19f055a5da74d76e3631311e694804d8f8d7ab2a5c00dd99f36719f46e17877ed1977a8ab364c418a099fa9f039351b1dc651ea93db6893a1682d68ea8aaaa074cc656ccd35a5f103e0223123c006f9063f8b9091b6f033dd445b3d4b9e376c632a6a1882c4c8ac7ad7977672273e0b14b00d82532117803f310efc62a3c6b9b751faa0d6e4eef1b9a8906c6587b9d07ffcd115d5b209585c1adfb8e890cb4f35554f3e11205f66d3568b353ae61f43d97ec848f4f17a323e95b4822a0e5e5702c13d77c5ad9dcfe9c51fdcfa84e574dce98b304ce3fdb8f576b30a13d0c021eb9997915739668679510529e80ab727922e02455708cb373d0c36ed4d3e12a2d4150ca8a159b4089f4b9d14ecef6c098ff35ac3ac147fe6f335430c751e7ffd42757c1fc1530be8668f0113e8be858fd912899fba0ad91ed3a8fc8bb63353b8f1e4f8b9c5146ac442cfc2bf084b72033bbfbd23d6619a4bb227e5450fa9208fc01e81cde50705bfc54ecc8d1c1a2a9e015cd1f8e05f2025fa7b74973dd788a54c01069ea9a551bc542feb78c6ae30d94d48006dea59b8476672f38a68cadf46ad5114c478896416b90c8648d844223f92059e6cf3d7577558bfa79ae88c87ca00c063b8ed5e4448976ca78a1a799ca37862ab37ad683f9a15a8a4ae6cbe2b3415bcad53c54af9e32e8007e677f58a0a6967041f4dbb2c353c8f6a85de75bc696c6483beb8753e832148d55aee3734a6d350d8cf2a370ecd1139fc23e256ed26f1c85c769072d6ee104c0a01c21e6839e30dca252898810457e17d35e2794cd50cd905849f55922b284444763e46b04c194026b37ce07ef3f39b4dd527a0d71d1853c3e4b56f660a8c9bedcd971085b9f7fdf62ce7dd37ea7d17248174900457ea2d4bd3c6aa00a0d5f8a0752e8ad68f5b6ae81dfbdffeed2e9e31351494e03f50a002f4897bbbacc543921392b89aced55d91ed073d8130cab6e55e6dbceccad4556af15f8a207a3612adae15cc92e99471052a20c90cde916e6a563e2f0bbf5b124ec08a0adff95494f1123c098fc3e06601d1786474c7f1d2c26e7b9619b191f7729d98a02a718e52661a892b7c930c1159749d7f2a456ab9acb5ebe7ca9ef9547256211774ff322647c2a7903a39b8369a5c528f06088120092c5e8c932aaafbb2531732ca33d2032a3cb831faaa53b8e171d64f5e6099ce189ae5e1919088e836125bf74520ed0a05f69d10fd70b3c492df305c86f45d168f21d6066988097e9e3a42f69e1cf87b427b8fc91f788b6fec8afe6a1c7d8f5edba93d57004b360502655bb9302135ab16c70f96dd2fc2e85487d34c1bbdca17c0eedd9dfe1a1694c29c774dae136313d7c3af75f5cdcb55da2101c9cf28aa74a1f8a34c3aea1eb34492abb459837a4435d5cb0676b346fcf35a8de6e05dcb12d9bf73536518c719f27d5d9d485768fb281073e77cf66c2a019a0fb4a266a690704f3acb306968576ecb4e82071ccbf4ecd85ed7fde2172d7f23e219dbd8248e97c8eb716f9e25eea997a8b11bcb4575edb71848b42056466dbebffa800e78d175dd3d581ea9d6fe43fd62c1d4643597cd45a554c04fbe3c50845aadfc45b3cbba7b38caac28d16834b39c5b028bfc83de3d2f952b60a4a0570ccfdd1101e6edb3417ec405f9ad7d26c8c3965cc9494274139095a2c10ef3ba867214bbf682b256eb298241ae33b284a1598038239a1bf936ece86809559f86fa07623ba454761b7ed66c989b72cb5ba72c99d22ccb197311e163dad5aec7330cb4f377e377f615c7aa147c849a54e74b8fbea626c6684ca968b2b2ff8311a5358639811e1a981ba0241875f4d36db426c8f2d04685c0f19e510a47f7786a16e10d83228a7cbe0b8bbc55dca305c0c717266d2d539d2d930a71a8e50ae89a9156f67bbab5e05d44a82ec3a1d0910ae06a6924074a73f40272c3c89d13b7866c9aa85477d8c512a45ad8bbe9586a4fe2441ec61b6978ef1001ecef7cdb7afd918365c0f42b95a00bf2b9539aca63a5e3aa32c2e8e3639d0c5520a883c360705d3165aa2e5b910ffbb25b8aab7b30300a7b3568a1c205f9c0b0d7677995ad704d3530e7c0958543ea49df71db4c8921f656d08838990b385399920be4108a87e95b40be4f769b74a9c627d126e1ae01a966a891ca2d0ea66cf795ffbf419111a19be03ea3ce8d1992b22b7c188ebf67532531937e3f0273dc863922e692187d6211a9d09d4a6620f9cfb74b9bc638328ab65311b6a8f23c9328ede79be7be880ad71e8d00659c65f9cd83847089441cdafc53fc87c21bd55235c4a5e5fec3c9cc3e3a31c4ea386d13017b44852a60556b4526a5d6ea789dfef53f4c629cfd61fe9cde34e0ebd45e167a45e65bfa1291619c94af9a1de4ebe982755da6a82716ca8d95c0c2a307fff31ac0fb6dc5ae83d5a3132deaa85c20ccd23f2a72adad1a2c1c8990661df4c06e511c6cb0947cab40a86bf345e60f84f687a78f2524961270e1c9eae0da496a3b401df6959a2f9783b6745e0a2402b1741cbf3761943a08895e4fe40b98c8fa6498bc06d0013692e753d1dc7d81c2f820151bb5e531e2e6b596aa9e6f351557d1208dae694b899a21fcb80792d2e7ba9b30b1c849099a9613421d3c29ee204cc5976d8c68c456735d85645178e3988d45c3483c00cbdb3e220a62b040b055756772dbb5b83a4ad9efeae97f63b6db05da4fb6a469e175b358f9b6ec1cb78049c635d097f247bb24dc55b883db98c6ed9b6c1a2a8c83a5f246f9340d0ad483bfdd2820ea84302168ff591df56783dd0c6af67b49a3ac97106aa9c04bf23713462b837d12d8b50eaff54b996daccca4852afef6c5d23f270e4bdd2420f584d309858f04d02f71c1b975968caf5718f787e6b76cd124d248da12251fd17b3037efe8c7e843fa3ddcf7e92e0fe5cfdce5cf564bd5d4a2aa2f6db435d9f446229519de999ae39cb5d05817e5ecac26a307ca6bcc488e290968b6303a378b8fbb0f91dbc1049f6e81cf5c8347fef9a0aee6cce3125bbc667679af67bf8c237e9f00d4424f116a721bedda2c15deac88729b33c681ac04fbc3c78751470227e5524138e32034e69f46819fc4c4df0edcb10d42ebecbf9b66fea3953b515cfd6abdaa0cacb32e3c9d2b9247144627d72e87c8b3d69b26464bb8c35d4d2c9402b9553d9cb89d727f836e7f20e93451dbf34bb9c2f952ccedb923ef3365951fa2999b3d03fd2315bce69639fac73225fdc24a47c647b4391cd64977f1b63164a6ddef8ee28eb66d1d696040e3dc7bd6511358ebcf71676cca304d69e4747304b1d9147ee23ac5dd6497ad2588919e288cd46eef7b655ad6d25346d4e798d99da653efdb9b2cd459ef6f2b6d8f14febdf05e59ed473389fde203748906802330c3144eea29f4efb1b5a5d7f35b033860982521c34ae84738e5c03b5c1f0341bf81b7610cb9c5f89c482194b74ec6d06a9440ebf1e44901a739b1b48d5325fb864d6a902846d367477bb6108673d0a10b16b82c710e17ec7ac6909a647cf559d2c4c7af4966bc0add9eddbf213040317d1525e88c889370e39b4e4f0eab76516ffd5d677f9ea8aee133a6db8db8908e9f14b474679ac3e34624b314ee9cac6f34a2544d06c7bc985d4137c4b687066dfd804286c64c2eb9f7bb669e5a021ea1e7f15c1014693f4d9e41d600a88d14c6c498892c8a07a83272ed4244bd8ef88a6efa0464a0a2d861d9269b5b037d5dba75a7b6f60a9667577ab212e4cce0fed276dcc0ec98a2526445af6b445fb0153f94a2bc0a16ec7dd8a6ac2a25feaeec66b00ad24fa35cb2629de81a1929598c99a5a36663450c13e4b2a54d609734436c0241b65c73134c8bdb41fdd717b446dfba46ad2e3d7340d884a2630300cde74da13d21a53a0fd3797c48b52a1ccda924b9316b5c31cd3239c03e3c812e00a1883e978f0440a9da2eaca2c4f5b5c94b4dbc7d5e4006fcb8576ecbc710a764e188d98c999e8979a66a1b7efbd7108933f6ed73954caef255dabff2409b01b097b1aa80225b9b0165ade85123a3e040133789aeaa5383d1ae50700fa7753aa15876355c31f346b5f296bbf400116eed120caa8124ba5c5a2e7e04d966be4288e876706ce8217871c991aecadff3f766b2f59c316143be2e1be9a662ac79bbcd52be429a2e33221745ce1b25d168b5ed344b4df7e0179ee84b63ac37edaff3e64241f474004591b37513a2ba8768db4d9a9924f99ab2e8992ed86cbcd064c27c62882fd8947ccf893ccd3333d9c64e5cf4b6d3e2c0fdb91cc6e65fea13588a785c7f660ff477e70b5869ace5d2f095cf9d666f8fa965e6407d7c6a936a18a1b826bd08931b1935f2f540c55f21e54b85b90924fc4dc750ef3defccecfe2d8523e66f067b4f1bfc8868d2e738927dcb2df40caa50bbcfb5c4a44180445e53e11a79ae8f01ba1de09057fff82bb32f480ec4302b963a9e67814e263d947ceaf5ebb35fe5e84da7f92bc5467d90cfacfc8564e73ee39693f55d2fdbe83d93cff1a688332e311715e02a2a0d7a5697857bea152be7993f87aceed158c1526669c355a53c722ddc947766d2169f54cecdc362bc6f5bc8767cce1559208b27780d925f8ffd4f8d76b79220941355643cac4551bbe06fdde05cb3200b3d7831fdf8f6de310841ef45b29df5b6f0b09a8a1d33e46fa2f8db18d0ede527062a9f3be8dd578bd7939626e93999f8055aebb1c9f6bc467fe2c89f5feb09940206a3e0ee0beaccaa5ef912847561bc4cc7b608c6fd3ad1823966b17f36b0b83145d8b48d9fb9ee86ff2a74ac38c2d464a1494ada39ed5377febdc7c50d0f4b0a4d871276f7fe5926e2389591c896de742fed15794cbdac4f308b581b37ed122a9e89ec4eb3de9cd97590ff0d3798a3a3d67f64cfac989575cbb886eab897a5f9ad8103e0bd4df00b3fa372a49842f9b26b36eb2bd91e61a2a56bf764f2dc7242b53c37294e6a0a9cd5f7d9951903d2c468f7fe5cc3061349981749b0eab37842215078babb67363f8b9d3358ba3d643c062ef5b4cceb2c4504a25f503f14a749957fc35231bce4192005bcb65f4aff6e1d0f5f6b6f18e2c1cf0e04cbba7e43229066805afd73c7bb5ea42b35695694e88672059b8a82a82d3823c9f6486cdf2e1c719f6a1c01cfe80a7b67bfe96cc24458434654efba14538dd291deda8b4fb3192701050895c7ead77400b83b50369f5fbcbf7eb2cc8f05e5325fe7e0b70d75c018da54b1b49b71b707abe2d33a64ff339fcd5a9ddd1db43e9fb8f3b5ac8deaacab7c34aff0fc728038f3b0c2ceb07d103c95c365ed91d82850a4c49037ba8c86546d4ff294932bc08864ee601806b29636ce1fd3b7e7b9756d504cf232857b4b27eb0412664d0a84a4293be0eb4bb51c32507a79eda571025d19da254bdc53abbbb1a3e221dd24eb9a4cb09a96f8db9d052c73b1b3ff9c3b032711cc9037d0145718edba392a7b26e7fc01658c082c674daa495df87f1da39509f705ca85bfa1803ca2f71353a221fe85ce0be138c7f879820726200a8ad66246355f9b9876b6ad53383236c4c58b90679191870114b1a2880d8ce810f64d9a4118cd4e141a08cef0ccd34894515d48c13934b1b5543d696e60a7d5a27e3f50e8b4323b3fcf585057af58454c4a4feb2f7e5dbffd1eccc3b07a3c60d4283fe749bd06d2218ed7a262913ab66ac38db620e340f574f2d12eab5c8519a073c18551ba8fc0b4c2c1a4db75372a32a660f25e18bef6e6df275c24c0dd9f9a10e0458fcd733814101a547ce8561abf3508f90a5ffdbed46ea33715a339dbbfcff75adc609cde3056756eec027573fc6c796e359a8325f6ab6bd9a4289555575a75e22682337580b8d28b7d1763ba2477f728f23c6aa9c6c3896648117043506f81d59d6865cb50ebce5057d062b7d3355b2552ab3e3a05b7e9fa397d5597d698a0d02aec3c54bd36499dac5acbb9d205b4590935d9463f4d988f46fc7849348068715b1b9494d6bf297db065079474d42fe25f5d0a39d10a650e9e9761d53b90608aed8089df859611d8a0e91cf0c61f81a6a927de91074eebdf8d86e0b03800289b2d422b35d10d08ce72012cd94265ccf338cd5fed7bab224f04f2e2cb25f4532e235760c182ce3dc27bb71912d651badce94decf5069b705fbe3765f2e6479ed05ee8ee17ebb968ab6721ff69c35702e096f1a19f453c9ff5acd4347c7515f5464284c1c28bcd47a89799a86d05a60a6e14ea4474bf205244618486d476c6234de2cb38ba675ea08ca70e145ebeca7673605f000ced40fd50008bd729e2f9ced353ffc0dc27ef46a6991552326e0b2c1f3fe488744ec543a959284ad9b52fd374bdd1a7027da7963bdcee19627434b17df7689222d6abc07da561fdec7facc38950dd7632df668781895d747b2c04876a9abd6bdfa8fafdd5ae74f6fdfd5bf9fbe6c19441d1ede6544a14d94f0103976efb8b4dc3232f38e981897a23ff3bbc572ba4843bf19bb02883d2f24ad3b561f37ed781d71271f4225df7e7aa4f63cedcf4396932dfa6d109d27517bb8005a7fcdd1f70a000eb124b82638aa0f1a26b88ba6df662a6dd49bd7bcbb1583facf47ee407dfc602d2a6d47fdb4490e4368c868d23e5923fa0ba825584729a503269f649139bfcbcea114e6fa1f9f8ab323e08e6499fe46132fb7cac77e615df36f6176b3c918381ea38c2ff8da2ea9ad5504a30d83c1f032e4f573e01c6edee9f9fbfb830f8bab502fae4e64dcc2af168656868a2a970e443a1848039669133b5d8b9b7eac7127292248827bcb1e513b3bfb9fb77f39e541f0d4d84b48b9b763b16061a2c835b49ac8ff3c666aa5a13b0c9d503d51045b4a50346ab445824eeb8eaea3be857b3e32000a9ff0495ae712149eac8ae3e75791801c6799a37ae1dc82d201bb46ff3f8f4444745ea130a8d848accc9246c9bc7c951ec4454889bc83c8c9197f88860f976839c50785aa473b04f4dcefbfba7faa588240d6d732d91576f0f076904a97fb20dfdc83175d79a4b2f928a00bad2e4caf3220d50201ae3d3018fff9a36aaee2c2fbc06841a0fbb3e3581928aded0ade040a268530b08e8e3131de724c3eb0f792787cc84f132a4c7acca018ab5ead69d13e7a9d22b8a724c9cc2b0793413b7cbaa435d75cdea90a8e0cd8384a63a74c5398072a101669c974f1b28cd78b29ef6fb1cbc69922406cbc71acee019bd8c48dbbeee031a590dffbb2f853689bf5c422c84c40964a1f03ce48fafb849486617e1b1e80729f4a9007ffbcc89e62e30ca9bd014030dec3c9aaa22ab445afccdb052913c2bad1f5e4fc3fb9d51db0f572d0a03e3a1d675f33d47064b73b80e147b0f37036ed6ee866bc7132e440cfbf29c40e7b593db500f2e8c59fb2981f02ba77dff0d1df133a89c6805f56dfc2ec2685d09284fdba9123694dfedaa2a30b0feee3e2a2e0ab55af0f48685af8b4167ad306cb317cb038827b4a45143bbf71e4eef45128f8797329999c09a539bcf43a68c207909f054ad9fc56c254ccf694d44977f6302dc1e8d313b8b9a307649470fba449b3da33d9790b017f84e5d3baa24a2c47b47bc790a27b37bd1e2dc5cec2c851950dc0de362b74a90fefcfd1a42d303d9a8f10c8ce40de9b749aa1f31ddc91c79b91d43a84e3ff51c49b5071fec6d001ff3e8c2ecbe3ea84f2eab945c814af41e9c21ee28f42b3a66f56ab9e460fcc52cb1241658fa6d214583ab3fff8c583433bcde192b9aaefeedbf47bb38d23c595c7a92f33540274bf9b6ca38805543ffbaae1b31333b5485eb6448a7d74d129ad4d163b147f66a0efb3ba0b658258e9a37f862e23d832851a98ddf5716e2275c369096b798e8b11691ea33b91b537416233457c7af0e9e1404b38ce15941ed90c17e04160a69e6025766fe4dbf76e5d75702c5f4718d91e3f56f0d38216f1c6fd246718da4c138349e5a77288d494ef106fefdf589b4c48c032a4bae890c032d3f038ccf4a875119e08fbe84757b4551a6c0190483fe0031e0c1b0af386e4f9702ce7888bb4b4d1e2e3fe92fd9729eea90405227d3c59f4893a5bcf04efaab99351cb38ec6bb4124b028149dc12cc7db616880087babefbf2f87f1157c7cf8ce1873e6fc90e2e31b8457a08ed28f8c77e9e2df98c8981636c3038920e92cd19bc0f36edd56e319249ee11c86574c7394196c9958338c4d27d914b22bd4916775e58604296ce36b8fa5ca9232e0329bb58ed2fc12fb3ca7dd922705345f884facb562d04e9fa81fb547ed6a42d34cc913f010719429c9dc64cbf9b11501a3894fd77ebbd081b8c9c3297a7483b9a000d0c8ffc1f979b86e1352dd386b55d8d20761d774bf864439661a0fddb99da94b50514cdd60a3c0870e9b6f8a8338b10e0eab8238994a03bfea4a218377930744ad21f417c10e5ef7099a14e035d999dc2152a6c90202560d1ff3274e8c038501a53a6a41ddaf20e1a67cdeed50f6e5bd5fb933b27fd391f7f14afec0ac05ca39fe942d81c0cf4aa4965204b2240ba5e0d6229644eb57e7cf8b13aa6f588f349525942a963cec904681c0c94fb10b1be505ff1d844652dec2accc0b6c0ac16f69dfcf74b872e167efa09e0fdd7410a559de1025e9b09d1db88e316805ab9901a1aeee56ed11b741612a31185212c5ec648d0c37a7dffbc6d0f82bd9107f5f1406f777ab741910c63e3c9409beaf56f671e4230774e39a0a4e86fcbd161d3b97d49610f40cf46ca44952f6ac57622997de6242c47071ac194434c5ec49e7f6b1d2110462fcb8f5151a3bbb9ecc06690cdfca8d8f4733a21e20e54929c47addbb2d88336ed7c64175549a4e4b7b6db899dc96df7b6c06d277e33bb7731ef8254f373244af415cb8f18d0640079ac16dd1398484fda893c8e2e928030737e1f355f68f91dc5ccfabe6630d4eea60b5563a6da3ad6a88a738c65f0f234e4194a8887aa5647268db7215d007aa0491dc32b5e12b58948ba34759fcffe58fd8c00e17177773d8e47c8250e7a9cf3f9e09ae127658e425b9082d31b391ebdd4724fdceb1e562eb55fb96b848033ab5fea2dba06571a0a5860e92b3eee18d3bf3b623005c042fefce23f3824b8e79167be376204d9ca17e87568d66d7c642d7440dda6bb40a8c2ae87c6f32d0e4e3572e672241c662b2eee91bfd09c2f057b768c552d9dba1c042f722ac289ba4f671fcea7201df760d8e3c63db8da5f3f8d5bb140de0d24043320c5d9ff1b111cd5a374eb690b10574fbdde1be5abe2d1c2a43794e11ca93c71dfda04b4bd74e5e21af5818fcbb826b305fbd3c0f2888292145bf1c9b86208c2c1c2674130f99f3d3e6cc97d5a619706e6c44c8d65a222525152390bf1340194dd5d752f3ee6d00b10cafa2850d43d7e0b0305eee4ef718ef2cd74b5109c9298c25d4d6576f19c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
