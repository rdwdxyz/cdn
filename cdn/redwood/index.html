<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a535e3b07c61bb1ed02cc643dbb9fea238bd5f801565b6320a33683196f5d27f013922c9fe27e8481c280de38c2a42e0eeb31ed4a72ce11d790ad7b3606d3995bc554a0b0ee41c7c9497468f3eab7217baf3a2c816463ab26b49bcd47be5b9ef3da59bdd39977e19be04fd4ebb570d4253444e0b0dadbb5b24c0978f195ad1b3831117e7047eeb6056d53a7ff013675925594f9dc3ee8df4df7178fe0a3ff8eae53ca8d1714b64a78e239669020844003f06ec3185b916969de18d10c435ded12617e580dc31bf067bb48705d01993fa3e56f5b332b658f902f4924d5affbb8118782552da61a646ac5b5372007f5ac716a74b8f2be2e1fde0efebfdaeee43f5c3fa6bdd72dbd99be630f99289c473b689702ac453891d26993395b3e293bc1fb8146b561aee7ddb68b0a2ce88b0d6434c585c65794cd81b222c32dd3ed6177962ac2863ddb33d66adf1b6ebb63bc32a1bea15fe6a1ae8126659bbeb0ed9b95b49e14bf1b0a47e963a0b2b5a56a4d4755763b61e07ca6f9bcb13c210c548a0eeffca2b839ed8067af6cdf102e9883b36488cc5f1603187a091f65a60c85c607fbf58cc49ffb54ad53a85d0fd288ed3814c0d7924799ce8910f63955d476b7d691cefb7fe6340e729f4b22367e8495fb59fc3350b1f88da61865b80b4c2d657759457a8b13975a05f76f7202336024445005f377b16af3b4a334779112c60f5e6e43faf76dd66a3f0bbf5cfb33de3c0d1917c9554582dac24ca58a2691dd86c2dbf694ec7a4e3f2bc912f93549be99e04edb471d79558463de1aa2bf1ecb1bb38281faca8cba9f9763797f37ccec0fd7049686cf2689ecea729b092da927f843b9e84248c5de44ef06ceee81c4d6b65347365709e4f4cf3887f69d1ff0b5e6ed88846460a3e6a1796bf450a61ba0fe09d1a4555f666652933751a4e683ff3a744d7bfa3206d17a22e6a28cdea639388ce2f4cded4b05e266791596b8bf48333061668eb9d9249b61d850a03a8ce7879ca2bab4015b55771cf987c8ab520024a09018198e03ebc80172f09836738f4d42bf6ceecc869764d6a977da987d2e6457268818549670533c0fc2a2aae289672594ed0f91f0febc540c5eb05c4cf1ac289dbbc8296662dee12a8041b4ca597e7788019b3ad06dc4b202e5261edca1f80694b00380f4816ed8227dbe497acb6445b01b01028a1a13643d74a7b9a6e66c8d6dbd681efefd3c2d8d2245c8cf92544392e1a3230d5177540211f924f6cf89c953421d795504f4a14ca0f391605d7b44d96e8e814fcfa52b426896c44b5de75a73a01ac96e1e0083fed9218e781393dc5b3cae86c19b94c9cc472feef41eab8984ab050e897c3e7b2f514bc7ae22afb3a66a0583d9fa7eee1aefaf27c9e1c1094810706219387d4f0fb6a7a4baa14bd1fcc33861c78a8c228234ad9b374f854a0dd7d45426dd2b76e55a9095fd1a007e0f77193c64b9e9998aff2621f52abe7e3513d81032d926cf98d9b01ac64b52dc5a94003868c38bff97dd5ba7951fbddd6ed342dd47524aa0e4c15231975d7395a3cb9b13eea7dcec1a6bff8f7fbc75c250c33d6d6c3bc55feeae31d0fbac0a492053bf38bdc492eaae78a67db388ad78c1248aa3ae6f80afed6f1c30a9ae679f17319bfb2f55c2d20f43362f5a5cdbf3c2ad4f84735394dae0f38430affa9948ccfc4adb516a5556c285495a10c928deb8b29adc4b4e8680cb15d2137a3969d062067262270190aaee78136e5a699c1de0ec43a4022e364b5ef3b9098be5848eafd6a93b32bc42aa1728ea430b61b63828d978441c13ffc283058b186fa012d10a4c28ea69564d4d40dae98f820895e573ed8023f9f514599456ae686e26a56c0f99db0317a00d53cbd49c7e9561b44361241cd5ae482dcb820a90d0c52e68f45ac801b1908c488e430db72753f280a68d3ea2f0a206b58cf40f0def359f6cdc1d6cccc737cc246beb308e371d61b8c4d5aabe0c34df927a4b3ac10a2fd31d2463a188891320326e779089555cb86680db127a4e5e1f0d8b40a262e2b5c85069f1bbf5bac930c56adc1d2ac25f2cbe502d3e3eabb17defb768dd7f200d2e486dd0171895faa4f4712b3c85bbbbf22bca79a673371864f313aa1cffe6c940677eadad7f1645bb9fe4530815a6babfb7c27d3b6bea90c4f2d7b8c568d0bb0e6b38daea1da178b96419c641c2a69720d8c9d113d5068e0f37b486cc16d5a80cac6653ff269b25af665a73287dde0952acfa5fe31639cf84ad0d1fa1fb1b83b9bc1bfe14cdb652e32c34876e232fd091895240ba534ccdc562aae3fb6addb4ce64868939cc901861678001e0e38b275c40054f9db1381f7b3f1f844cf178afca2e34ecb5841596380721daba47f96fa251a1f63f76b25307cc82ac480935fb4280129dca0fa9ad0ae88a398d50625b2a145b1392f519375d85ee93e224c53fcafafd0098595ad0b2c2021725fcc18c1bc5b71c03946ee712abc1b6d7e3459de710a7c09cacb596bf663e33aad32fcc75f77fe5241489db3c6fec7af3cb9eb005aced1cc661001ac00c21132c47c985497e2de95b38b5924383e4c8c0ff3af8b77584a5c8aff77f2a09e1f90c536d478a359a0380462170d8d0c8e9a371163eaeac32f026221d34f8d0b0a472bd446ef464e0e861bf3f0a83dc306531121752c7b101db4afc860d7df383b88cd9305988e7ef86d7f7ad3ae40df6f6c0ce9f8be67849f85682045409265db5c41819f36a7a52575d328d9cad4660e4052f29207001df0313f0d378182e0c2c1f9e7d6577520b033e34b29b136b5f43005a12c6b3d357b749ccaa6b6c421590c394ead348229658f6b87f3bbfeae1aaac50b67b52c750a837b013ad99afccbe4b4d5fe47097620df90b0d5b25156c6873910f090ba4d3b520e1f148d8f21f44548668e026b03b3c47328133a150952a74a6929bec10cc71b8d45ea4b97c6fb0899de22206c6372be1a29cfac1513903b23c8496190e5e09bb7f757c6707f67555bc89a63e296e147e62f974bf94a0c8388b92bb3bdd1129a03ce5855f259ff0daf925e43bb332b1b9ef88459c395ce769cbf9f71457764da41f549ef8f5e5f5c62ec54646f724c69ea67a2b3d08bcd05402c1a7a06a4f98035531db2308a9295fb7d080cc6665dfbaaea6af9f851f2c92629144211362a171c10309a9fc5bdec2c7c7c8be8e3014374cf6f2be833886ad50029df296bfc88da3fae6197a6c0f4a9fde7b4ba78c1df59bed3b334cd6583198ed42618397c239af06a30167f06cd82e9432871dbaadf86918bee0e9a06f287427a535c4ea573ecd99bb1680bb2f4c1922f4434aef6d4f3ccefbdf3a8d69a501afc244686c3306497dd10e912427251831604f0fafc04b03fe5979187bbe42ff60c76c9cc200be585730d74495f967971a8f99408d11564f1efd2d268f2407b6db2d3ec08dab4a7999b53d9b19b3d90bd1a826d93290652f2a8d012065089a229eef9c34e77f658d652637e97e29f7eeb273316490cd5ec330ca25b035f8533626bed452f818a8d6d079e0f184631540eef4488b543d18de2efd79c54491e625090d5d9b7e201ac1c26345874cabf7183b349e6f786fb8beb813481e49a2a06384c34ee5c63dd722faf0d0d6824ff0c8f20a6b5c64bb28004ef5898d654698f814fab0e5e374c3db0ea994a7e3eb23ef2302c55704f58e6bc74e5408d0f73ee8a3ab8fef2312bca2118aee994388da997232071186319200b8807121c81729fbdceabc7429bd315a1e81511756e55185e220d188ec6f9457a72a3166d1b1532801b0c05a7c13af76b5ade6c1a330fc1eb02bee6ea9a658c6b5c7dccb403c379dcc8d11e358e8b75d3c3f257b1d21ecd93fd512f2ba49a1ebb1fc8df34681a98932a5e3d9c410f9cc980387009787e3e8ab4e5513d16a255f3285e9684f3653466ea89446756d93b0b1b1c04a9729feab8f803274f70d3e4c6b1b1306805b9f33f10a48b4791ea4ba76714e15d54438e6aa53615c5530c6a9ea3d01661964065580e74ce289dd64b058b85948ec50c9e0344199052afd355cbd050d2574c83222934eef1986027b430665b9d8ab5a590a2a33fbfbb12de9a143c94d62930c112dd25b03276f734f613c8a3e6d08264659c4a7aa70ad0376105c6ae5695d19b52a662a8e5d6d6040405302e9dee92eba9e282a64bf040cc8797e4d0efa82d264dbaa098ed0dfde134a102907842672567fdf6ac7a680d8ce1d609f98dd4d4382629db5733fece4a6f00f190c63a45615420dbcd6a58981add66a828c778ccbd34a559e3e36b186dffef88be4b94b9ffd9479dd28527f654006d6b9524d50e37b81f790080c5254218d4187031ba10198ec93d2efa3b22a8ff2c49cf527b06ebd9165810b18ca95cadef5977b13f65d70b9794b60a8c9a3c78c49b74c0fef9947f5b2f80102b1f51da1e57d64378a0053d7792f12ddbaee79c0ea58937a6b39147527f6bba370e76b667721685e47188ce813f1966f1f4ca2a7e4dc2771d61455346d38c6325e2db4c0aae0e600da1f6efbb118ec3b8ecddfb74a564a84eb8f58eacbdef095a8af234db18aafdffb02d918dbe2eeb224182f08f5346182f6346e53fa60986c3ddea1b75b3ac654cf5784783131631b7efd0854a78e3b44ce327c29c42ce663a65e196982643913204ac810d49f98f62f28b42a69ca36527d7dce9b92e69c3f669274966b5b6ab5575a59b00b3d90268e14ccd3b71ed2660774f9205d0d94892272da1fe0d5e261afd7ef183e77065ee3aaa8ae05038adbfc1d6a2c008c446ac06b7eb126b2a1c396a308aeb9d08e18d00775c7b7cedbf298dc97d9f4eba2eae803ee29113d1d6064acd47bdf678b8b4c30656c2c612eafff3549a803568985712e41772284bcae706a87c013f3ce07553b762875dc9c0666ca3139f743a2ee17abb472638b65f59da6f7ec208c77c015d8fdeb2cf9be2900bd2c36a4e359f3bc1def1e358979463a415fe194fda72e4954cf95529fb1a4352835f497774b500bb7b08bf97f0978d002269b91e998ee7ed03b365f85adbb766ab3ffb490e95ac75e3aefaf3a22d16bd290c214684ad07215925191da7cc6db540002e840da37e68f214f3acbf8d748346cf2dfaebc933829a7c70577bd11bf8e726534eab94932d5a1373ea62d8131145478acb481b7cb3a33b5ea00c9f7ec75fb3947d5b090378ba81a015833e6fe117f36b0b609172ff9aae86560b9609feacf19ae1014972548879acbc1b9bdfbb80c95a5c63625c9dea080882f331ae23534a393d77673f609e1747b4594f5a272c6b75d0d17cbc12acf370bd1f38301b54e740ae68538166596ecf47553fbfa2261cb60801c512a07a0a10ab9dd85e2375b4902ed6a3babe6d422585b3b5ea0a2cc8175dd19907b7764b1a49e7f9c04bfd4f4385a453676678ac74aae955e4b61828569478eb069aee24bacf72de72a6024811927241140732608660a8bf2b122a522fe15d451d9df74771c50aecf62f501a322d91441d69341a68622326068eb722999fb9e79e5e3d132f72e47dcf6c963cbcd6750769e89599c80915907067999ae3fa8d54ee2ad6774a42f5d946fcfe17538fea7b51db4f0cfedb84010c0c534bf953bd6a1e22daae7ac109e15f645e15edd4d06cd4f3170bb827b19112ad5d0199b89ad67a6f90cf70171e6c4e2e7f83fd7afdd7d80b5dda578ed7d3e5a179f5883ad50c17fd3d112dc3bf9bf2d9f0b0b00156a62da1732c2232e9fc09092e4c90463e4095eb896138ccac74a8689ebcd8c8646e191c810f6e178f1f54da5002789cb1732a59b05b21e12056196046c9c19cca2f71996e620c8e4491f4ff42ae57d1b9af7b2d32998d1b46dc4a962e2724efc96eec247caaf941025010e8d020ab3f5e22c8adfbe64bd59d3aa5e29d97d7d0b1bcc8d345e1f5895716920544d0e537a423934f0a640028846caf1c1ca325187dfbfda90178cbbf20da68b2a14343b1295469a00c4d87481b3945faf445f2d303cfc922b5e4b8793d759ffb1cb66e4e762dc037c232108aff71c93e7d42f96a5e7b4dab9bfec79d2fc352b3353b53e367b293d2675407b5a70fe735384cbdf51970575671797cd294a08ace9391de3ad2eddc76d6b5795b5fcf4632d20e553f11ff2e27ef308551a4ce78b93416de53b74e480de6064d4f92cdf0ed54168bb287a141610b74bbeb9d1377f1c313dcabc0c3223bfb7464303c32cf0e36eb5c2402addbf0c7fe73cdd260833fb552899e193ab53ce669ef79bf1d983ad965f27d6d574a58afb484216f71f2c71c9785933195dfbdfdddbceec4c7cd216dede3ecffa5ed4124e247bfd1a5b4e8f0e2fa3ab43e25a818ca4f1e74b130ee6b9b1efae60e8075ed6c31736cac40f378a1d52f074a4dbb89a774088807c474d270a0a2727923fbf47e70cd5d0d574bb4652a9654b717d11de4fe5587f61059ff7cc8b492fcd825601d51e3f906d024a2e2114f0d5510c0d48d86ee03031a8a4c13978dc57b593c812725208e6c06ca8f9a943e8a54ac95b74e7e251a2e07bf74f952d527d8354495cf65a620bbbc985bf46f90e9614663fe73d6dff4030eebaacf5701e4a2d8e3e634d2042ab138f6a11a04aee5049558bb55b623e4ea6efcd6f17231d598c9ba4495cc71b85a4752c54cea70cf3f7c668f8a989fdfc84211f349507d57d07a1f789c58931903a94e1c760a360c71ac16ea032493868a06ebdd840d947d44d8d9ec9a76494dad6dbec8c030f135c722e735012aa2f92e90ac9f7f60504feabad9663b2c8025fbae36deaad8009af1579e64978689d3ddcdd7bc8c3e6c744c5984728cefbe055055c0fcae8df21a0f2ddaaa128486ebd569bb921addce5748d9335d2afe1066e05601feb7e3ae623dacbfdfebf654a544de31d0b1f507750f2345318f40847b344fc2173db0502b346bdb093ecd416065eeb9ab7b6bf39d75c73fc1aa3d9cd36b5c3ce80df3895a328c824f3aa3885aaeccb8bb546592c4e6a6b9964444c55d758a0e99a526939623aed987465efb351618d9289aef7df4b34a73c2d4c4ce835644496af4021b6c701f6d426f0d3de2f56e7b4049a20d776848fa714b2e48c14df2cb01bdc967aafd4fd42a5f39d62427827954ada1ebc33b9cb5554993e9b80901dd51ceacd227a5c745f12c8ada98d94f05994b3dee74c260de8030902b114f270ee965f8037ecf849d3ced98613fe785c70ae91c6c6b23ab9f5d288a3418e0b84936a46d8cc9239dfebad61fd92ec91bf87f61bbf5ba8249a6bb3e849731955e91bf64c9625e0d36d24fe20f33883bb82841b01a4156aacd737c5201bdc4c2e232536e31ecd203e7fb831ca05623a925f1e66abe1471c63907506effb9715d808fb73aaca8f2b46874a317804048f67b4f0641340df02e44181d32d3f838f959ff945d64852dd9dd40c4f85a6712b38101879ca4f04d3bc9eca5cfe073d437bb30ec0beb2da0f999cf79a97728a73fa98294495ed76ea9f7c379d482ca2e29e92fed5b202e7d096fbc629152a34e12bfd8c7ad0532f5ffe573a190d052792d281f3e73a6e91a68b47d76584d6751f2b3fbba5ead39b474122674d19c6a07aea58bc40a3f05c28d556c4877e221830f049d247c04c5084338665817332d08e6687724b4541f8fbf2a99cc6cf0189fc22963c0e664a096920610f6b84faff431416dd073710fc5f6985cfd73e88cc475b1c3ed1f66e1c1bce338dc38b581a0f6c527755066b0fc4ca8f8b297b448c212e0f2e19cb9777b16ca604562375d17f31bd433db4cc728b8b698ab18e34f07d29b23bb61b5717c856c5906b1c111fcc46f3e9f29252a2a1084a4345a95b02c4b592836baa8a4af756c0d46c35010f366f4417cabcb20344fac1cc860971231a31c6b2fc229198a29dc52481baa5324ec0a5f6eae94c4a035471eea2fa61e2be571c85d986d89df4be68c2067cb119fbf35dcd3c929e843156ce8c34ba1ffe8ef5cd96213a4b5882f1d8be9261bfc47a2babdeec7e195f41d3a477312e77b44c3cf4b4051d5c72732548114b17992b531aa83bb950dc78980d246ea257951b51136d3d28b29021145c08dac4defd67af580639fbd7d41956320527701ce41c15e1c2c5288d87c10e1f338c6ca7c23ffd9c9a3cd6c0618399c3baf5269b7b022f07c982b42801964adbd0d368e300ce146998993affcff60d444437ea394f467f347204f4ca284f3450e06bbf960926803938cfaed9260ca471aa164a196e1daebb1121f9be3dde7b6984a2953aec01698caca92e5c7d2950c0767dd9e3782317356c58f2efb1e6905cba39ff0f93f116a55a2b031dbfd4cce81c25ad67ff9ae7b7393131e67fc2a4754eb7831d4687e4ef97eff3e4db4fdfdeea66d47e740e95a071658e1c1f669b0fd9ead5e9cf017e52fac7e4bda97878c739933f8d9d2ee875a50faed5037751eedfd7337b555a817aad6749550a457ce7d0affe879607e0a018281a7667287b593ed343ac8c83dffefa9ab60fdb3ebbfbc898be7a2c3bc1e1b04c1b22a8d7045404c7a185e8d5e9675c7a8d968eb633431b16a2569e0c4ae8ebc12193fb8ad9ceda58bde6e327a2c15fcf7f1fd426a39959a0d68714ff03b1f82b581fc7bc41821603c9ebf3a7477ac9607c2cc87387ef91b080f289a2477b543b33c404b3fda66f87093e4e98ad0673cdef46ddcc626ef71f8f428782d9357006039ada39fe6174e70c71bca92752aaa8e1db0162dca5b7319dec3feef8f47200d6e4a7c1f65063d5e78220aec811b07e526dea3e04525a8c66c26aed045878a772ca4aec1b62a85a300699ad4052f7daf2b605f58ec59a820c7ac7c6e05a47b964eb6adc9f700de79d2b876acd969bba711cb3f2cbe71c6039710a551f317a16abbc2a8d8fe610ef0ec68f5534c7d81ffbe8417938cd0c9e0773260104664ec61a143900870fa1ddb7720b5b3dd667d6b51384a3caeb6b23519704a64b1c494917b5144b2b6bb9f5efc1f70885d564ce5b3058dd4a3d13097bf4fd9c0a901de1ee97298f8f9269493b73226c311559fb7743520556e995127f038b5b5fa00a701a868f908c6ba16261eb2634f766bf68c77257db5ea74c407e55b6f33eacdb374e25d816d7d0baa062b9b388cff0778c6343efbf757c66ff799d2eeedd10f740af9973d25b786f66994a74eb72c21ba56ba0c849a6f3377531ff3aa6fdae798d191df393e2ec1d828210ff0845b5fd25bb0ef73dfcca3069b074984581cd74c38702d538750fb238a216072c15c47fb136405db0dd31b4ea8f01aa489a9e201d7111254f54b65a8d6dcceb6eed559d85fead908c19f19713f91fbe9095b1c3bd4be982dedcf9a3894649899b9471a01ae5f077e4fa0c562f76ebb1e1da3e71b05dfaab2700d3e0088a531d580965b968b36104aadf78da35fde81e9cea584e4d479811e8685a7bae52acc64e11e52e116791e0ea27417a97df12216ab9e247c0362045dc676d558f6c951f8a67a37e1826d3b9f75a9f610b70317287b7b1d0c034e428fc7a1fd5e043a0e950db48e8f0d780cce1e1674ddd9524811e560a68709de1ed0c19035ea81e2547abe68e764851148db7b0c5081023cdb3fbd9128d9d755b1c6eb2fcf6cae669dbaa589fe0ab4c73f9632c0c68e9381f415964241a46d87991342d5fe500def30349d8764e9eb7a895dad3c383d2660723ecceab39fc1d34500d6d0bea913da14da61ecb1011b64bcd1d2c859dc63d99ba1c87f88024e219a10215a1db030526707f3335ace72afaf0ed97c49c8e1f7ad4585e5a28e351dfe560107dd826937dadf99fc2942e4531833129abbbf713384474f61bc8b50875845b82b7923754b25f6d8ca614e899706f9968f17acc04311f6ae9968b2c218eae40eb50833c2fe4750a48d6bf580cb5b4980e518d2baad86b65f176f2fe90bda179c4fe2e2450e0d911f668ff122fcdf65c6774ff0d74f96b2d2761c3d967475a3f9bb57d96b294e38e2a45ab0e9f535b48e90ea60c5ee108e327595806afbd908cdfac3e938fec9fec514bb32d41456fe8323dfbc054810f3ccfbe56bc8835f8df4ac6a66fab707bdfef76dc1e63b67ad99fd65f136948c3f078324999f9f6f41b84aee59d19e2be30a20094074d6c3500050f2d0ff3db952c6a9df8686322f81374567e786f8b7e013e44b1829517d05f0b2944bf5137260f981fbfe3835b41fc56d24919f6901e37912df561533f9acb31a5f2aff5c1ceac97b3076308f0747a12576fbb451c83ec121a1b7c390af16dbbd98542482c8fa986e753d08161030df5c99204090f0e38cdd4fb9aa19730a287609b00453d9a79d3a0980989e5c9c64a400e027501118349835559e40655dd0c92adf2feecea6d625a5c9cd5faa4e39f5ed0003e2634aea9fbd340113a19fb60bb9f8dabb491ec397400ceab6f869cf0ce7a2b6acf6d3548e567f370f287df74d9d9037413f2a8f5d679a971f708ced1374313e03b01d7711974d0741733f844467cc83b3d0922b9d0c9518af91ed01ec95ecea586d371f84ea1a52a66ceb1f77f904f468401d4aeaf5df341ed081de1e94bf44b3117cc4daf1fe0b0d30ff48a8bbff40eded3389e75cd9fbc3d56b1cf6d4421a7399a555345e4aa213d0b75cd7d978e57a2340534f523ab7794f47a54a185b8129e2e42491bdd3e2a0e4c6f547baec806d9569efcd406d5bfde3177c87541040e3b8fc4e4d94debdce914ed067ca2ddf1ceddb565ca607cc099566517fefbb243f53b7871c865245275de363fe5114b59ac171b169274410de761dd89829151e0b8c6fb313629150931c46b3d9b62da1f0d03129e24e30c602448cfd5b0ac706dceb06f03730243dc1a703ae6bbb09e05a814af1cf64c0ac8916b0c13da3d064366213bb46a9458b1b9dcf319f26de4f16a8f09bea6bfa7d0ae11df2dedb94719ac23fbfa5f11d812657b285c246ae31677a312442078bfad5b995434a0681a342eece2ef0922184d02298d81b85b33a6a6d487aeebc39cfe5f1c4d5d05e67d48269e3e41497de5b3a63e226717ff5926616a436dbcfcc1e6995ce988c82ef70aa4ce9187fe77ba1d71ae6582c394394c354b83cf7d3c77da5c9262bf317158f39e4601de4440f60289082fa0262acbdd2213b0de723668bf3bb0e5428ccc295687a163c7f930435c644bdaf11ef25fc8b3a3fbcd2bf3ccb03565cf9d595043b3c6b957b0547e1d812f17d8c37a918e7a7f531b902f153d1aa116d80ed88529824410bcd7d7502da7925d45a2115cf608870648398aeeafa3144f395d6f8be69ebaa4d12dbaba457465c6b2877e84e79287ae431d076ae8ad4c25797d427edc2ca6864b83189281c5ee1de7f7df80f780d7f7f802d41e5e8e668d9f51b96cd0ae23756865c839aa4ed8b02714e71a8f2b0656e90f0554f5b4116d461eb9155470ed97b91f3c71b53e87e3e70229d6ae793c156ec8459350ec6507ed89b7bddbd9d0b6a5200b89aada763196fad4a2b4d688b2f0677a434d914b41bb458084403d8c5fe5dc3f8e32aea077a866a9315abe3a7d726f4dc4828c06376499d48e585e2ea8ef6c285c749b9201d531957bccbf11869f207ec14f0665bd5352fe239a355453c91aa4a6b5ffcb40299cbce8a242e79415c38b7d8dfda30e0617049d3a0a4622b7c8c9a12bea57aba1744b5fa9676aaf76ee12f5e1adf817409af980948cd67fbf5aa6bf0d0cab85de8e33b743562f43eb6d9f3da89d67433515cd1e24b733ce560c87ac6d614478deee2af6882be335c273b981a5895861572d035671a8f903aa7afc4dceaf9020e1afd11a7f3cd57f43aca9a98c511ed817ab0fbd2dac0090d53cc393710aa7e8d215d91f27b90647522d2adfd33f39340777978cf5b8991e8a87939ecc259b5d86c5bc2820a2ff9d36a2f8eada891201520a0b6aa75e63e4615811a47acfe9bc260008c3088f5bbeb76ca03957b2fdb9be26b291c852f31c0d117b3423af7ba45b6ba60f84d26077d3b78f45242c1a94ae5e032db97270f27a08083544c53146a1c5b85c6d1c6ba832f55f43ce1abab7b6f29bf9b57bab38073fb58d760f976ee0f30a0218a8e78f4bf2ccc56ca9cd67c93b3384f3df5fa6a187dd123cfa952c91fff460562f9a72999d2169b19c966227f28db7f9f6e0afc10f535960cd6605c7774bcc3c3544c4b37b3b3d481ba522e872aa03c647c1fac181ce8cf12dd2b9f7ab848eeee69f6f7e96529f9b273f4df9c074bb51f7c38b91473fbf3f353c162b220545fc56a9303a9f5088d24b08dd92d34949327f2a29c66a705c35b8d7f1bd7663110cda151c94f82b1c80c470c4d0477d8a56fd2110ed8447cd70674c31d3f1605816e77d9fa4c9eb649c5132cacd4b80881644dcfa79c92aa4e974b4eff732d4b525afaf6166410e1bf5f977bccc75fc4a9c4ed5984d9b3579889e5e40ca26642972bc9c3fb475a7f6b5a5cf6a0db5f48edf5b7f3dd37b09a4ce927b6389b72ad368a1d1ffcaf0e3ef6405f2907b5b11cc54757bdfe19f75f164e140d1e91bada5c3ccc5f89205b837447116b6a610d1056f0590101929d0c31cb3380b0919ee86ff90a173ba9c72006c8b5b8b51823c984221f5a2aaccb7b65b709719fb445901f013667dcb9aa9d6697889499a01aecab74fdcfe6e5b53be9cde4db0b41224a228594521246f06ca936848d0ffb7526e97cd2afdc9f24ff385de68cea73e7f4311ad791e02308f496a80688d02f33dc0592a3546805f66a05a3810d06972ff1058b54d2e1235838169672ffff3f78de4f1b842baecd3c0dfd8bd5711e1e0c27f1458e6bd61090b9c1cc480b1086830249ce4f8b33363a9ae5084b41a65ec029cd589d324d9866c64af2977a9d966670329d7bb8647f599dba5a0e12a19492ed7d0b6d0def8f7aa80219fc152cac0db732228047ec94eaea1eb5dc0ff3360581f081d16e2016664e6f05208c6730a46cfbe55e87a6f808660a302a7d31ce335cceb5e2777436e55fce309754c52e1a19b2fe50efacf40a74b7b3f938a6745a83e88886624529b29eeb56b03f4b29a44e149a95533b198ac12c847669b6f4d2777f99d73a0dc6b7947f7e547a35bfaeb1c9597e4cc29659e0240f96c7e3a60deb7ca864cb37c43a2346bed31f3ef123d7a3529f3f0fe3216ba69ddd11c17f3152ae2a5ed8b57337914e29df348d4047e7405b92bfc58a295ab4e5975f5b1ce96ca7dc129ec1794ab73d1d796ace773a083eb7ca32ecf624106a75247c121b9f3789179ba75afc48c03f9959fa1bc329e78717ade1e8af0a6f9e2521f68d5e5d1790cf9315489b1fa9c9e88af1d53de9e92b32baf3935c231cf7ed4a0cbe1fb05b76f802756fba2ef6905ea85202880a7b5a6f7406447bf1dc9d2122610830adc1da8a7db7e3946809e50bfac111917b00437d702192c8598c9d2cd5295f5102011d132cfe0cbea0bbaff566d8cb8818111bb4291e216f1346f69f7df2558cdb69df0889847a2dcba532086f6e0e843f8b17c0ab912b74b3528c8c2bf0125486212a30e2e56b0afbba5e2e95f14a2492e6112bb549c25cc637bd18b242fa3d40dce3b496230bd61ffa60d8107f41d29ab874d1345ee7759ce8769273b98b58147712b4175bc29d193c2a01b27e3e4cc9bb9ae87f3f5c3c1cd338caac47455c0b8b659937fef23c076ae7414272ab40d792dcbb914b2e9a63bc53f23cef9617505ad8ef21e120426a3091e41229806bf94a936dbdc39f0bebee0c7c7ed8ef5cad4732addb7723747baf74ba44821187f34e20ee935da3d379979432704a440c5be1f65aa024ec09145423a5ea9e86b22b690d7142b7bc2c6c0ee6fbebfe93d701c4a8119ce385c7bb25f78f97e245f5792f699d83a2244563e34f6cda3a1075c1ff3185d00746aca9eadc7a637169de3664f552e2398b76f0b72f1f64ae92deeb57d01e8ea7b37679ac867022ece27e8a1a8dd45416998dd895590d699c5e504be3c92243d2230b1b62188a3073d1d23015286ec1fc1e51db2895c0e1362f09f61b937c87a869172888cbc4e70d2ae07b471c4c3ca0c119b787ec6239aede5f3297312bf61a94a06f7d07e04392940e384bd79ee4e496a157f1f1c24540cd46855795e92b94aaedb39ee8c5422d9b8d25e1bce2e7549cd7e09c5830468d9fb93bb2cfa0f91bd3c3521b743ad8bde02457eaed00ff3e7b3d5cfd3b6f41ed09a56ff5913adec09e758200344644b6efee4a09fef6c4ac84559cf0a0e9ceb9e5f6c123fdbc2bf0d5c5901dfa1ca9bafa9a36c4a9fc2d4a967614c9e52238d9ea890a8fac35c117387fc1e3e577972389163bc811251a3dba3e49e711ad0966bcc1742098772694277c853d57066a74421d15cc96236a6133da2131e9de087763f1bf05e675410c0a9a074102948c7a9d3a25c4dc45618101a1a2c15393b11c0784cb4b82262561810cbbec2e243e339181bd04d3ae273dae5fff1d952014b71147eafd8f21a91d533bbec45c609316e1bd899c45ef450d5422a0431498f39703ec34b67e79b1a11748d47de945042d4f67a615ef429bbfaec1559ed194dac0c3f3a559e74d630dcf16411ae10284843b239b15ea1dc1a75b7ec246947f2356b7f39b5b338091afe91a2e5dec026d28040a7323fc8428fb860c7666aa59ba8f4df7d0179b3c5911da2c7d6bfb451c13cf8fcb57553b2131f9234dedfa9fbaa1cd1bd646f0f0b414e8eaf7f7c8d07bc27781cc7b2056e52e81698c9abbe65ae999bd86f3acc2c04fafc89e8acff5737d164b2f63d4ea17f663a06bac0361596b9551ae420f9fe4d63898a757382471e1f3cc89dfaf7d755217b90573292309d688e06495665dc0c3014af351294d5ce2ba971770be1368c869ab69e6fca0ae3c234b3f66248c7d468c656cd2d566313e93e48987640e94ce18094d0ccece4775f5a756a2316b2c6db92124a9c86a4d29ae577d431e8e75b0c3641467dbff2403b5e8513672b13e1c657779ce5c5071c127734e45249102df50f508dc836761e45a4252de612b286614d42647be459e21e6522157fedb26e409251d1addeadc3ea9a0ef3ce006407b06d8ba7b78d1c649b14394343b72dd8041ed327a3569da1716b24df7ba92af281462bc6e69cda1872c8bb918d44916d2c729b8147c9b6aa905869e592bc95cd1f011a788b27527af82a93b169847e85b100f89a46851a91ad572c8a83d8089def1670503d3fceeab3d43efc3e356db4880c4e58a78b735714e0fe4391cc832ca8b9679f08b3b47c438757c714bdc82e489045f527f0437ee3d75b2b31e0f1242cba4a9314642d020ab52b142c06b3af464dd350c0fecaaba13c49fecd7c6d9697598a001dd5493f07e744f5fd430b12b0a78513d3b7b13eddf79adac80cecec6c9380cedbd199c05375e0fcebfdc060f547f1601f0586eeca0c8b387a5f9f8785344c60591370d00022c3f043b1940813cf2b0ba8092ebcf3ed42dcfabd7c94aae87fa05bb8c5f396d55120f779c42888c683dabd6f794ac04a23d4d8ae411a9a91300634286bb7be346d656380f1c83393d0a7a3edd4f39fa2da6f5066b1eaec539372f8810bded6cfd21a2de07671a4772fcd8e41a9a3037ce1359e7938ec9e54d38cd5d9c42b31133c8184e092e87ccd1a56e4e9e083122aa0e7bcc96c382e4fe986ecfa912cf4ade055b046dec698bcd221db0d6caa2a03df364c6ccafed04349c48fdd6caa8953a85afee134a97e92edb09b5538dab0c54a9deaa88af803f8e07868bf8c36f029143ae09a2af9c679140e53b29f1d3207568906382bad5544461abeee7fe3a2e067c93f8f47cef7688a2e52135b47c279f908ae53e544b4e77d7a375baafbdc41d0b416ca32e81bcb1f5a71a8fd4ea1c5adf061eb5ec848eb727f94716842591623c317060b4b83a2bd4127dfe6788df8080d48c11f7d043d3c900375be1950138cac53b1dba580058c77aff09be7363b1afe6d5971cb3af67596c235d3e66c8a43876a80f9ef52bf81874e7de9450494ae801ee68c1e0db8517cfb0b178ae845963d1ac88c4a4547ea4f9c406984d25694830ab98ce12c8be62c6c4a75a9f557e485ffb2fb71e9f7c82a109d7005d79dac6883d90d31e5106cf886628151375623cb0d2e6c7bfb415e466b61affd68fe8d67a1f1d13efdcb2419046b9b5f7719644d5b5caed4a82b1ea0707992ad8102199e484b2134a0a934d169163846060e46dc7ddf890eb475ad57a8c4da03c21a3ab5bf11ea681a7e1e89137da894d7fe942a9c674fa748a3e5408ff0efff6a440d540a9e863882c9226597948e0666865d27d47d569403e8bfb930845f56245126ec82eadbd984871cb702b41a70e890d4e3833e9bbbbc8e3e6ddcfc677f1e3a1e68afff63e72d283c012472a46ad7982a7e1a016077db468e36f1225b8b2210ad3ceb6df811a64ac02474fb96a8f18bb9a3c452ba0034d3f9375461157d81857ee5e7ec3995c58aa4e5a39fdb17e3fcf31e5e94acc6c04437499354f65bb554f3fe008cfb6865e86fba4741039af0ab26e5590fae7f4ca14cf6ff8da9568424fa047e4710eeb92c78e0b1a84e75af775bb57dc26153c4905cae4cb9deb72046a50d3e366a3dea9cf673dc6d026d88ed7228a661d42a50f3b8e6a9e7c8903464f7729aec9f816098b7b6c6a39b880ec085e777f71659bb37027b6c591d647a37023a97af96ab101cb377e3c64e10a1cb30099a6ae9d30f6ea3b1ee65530a26465d8a55a941572fd99e300028e6b06ecf671ba09a41f29d6f5b0d99f5d23ed5b7cfc64a8208dbf22222422ecbce7989b2c47527703065605985c307116eeee86d5e714658b65a03999517f953a2da3c460cf0f90b181ba2c910664c711ca8ba34df009dcb1610d06cd66797f63b788f44614a114041415e945061e0c76292c8236996b387e52349f3e919a87432222308ca5477aeb5adf42989da0cc485e4c058bdb9a6f07c05e7f6cc82b4dcc3c9f86ece494b0f1b67cf84e0e6f839bc4f3401d2024245bf6d3ae586292cb085447a676a459354d5a82aa692f0d40bab9f9118011845c830c0973427fd97fca4731f61117db8bb1b5c677a451c2931a6141e6227ee375d2b314a51d69cefcc3ebc4952878e43d14ae83f5cd4865cd40998a2ecd3a33c5c782218daf1755922f16d68fd17dd9054e91ce92ec501e9113265ae7ea72324d2e17bb2db4a5a5699030cf67b6b2d856ac79f5b66084fd1ee88e0df38433c923c35f27d7dd8196a72f937fbac08b145d6e451e18cac89517320b70f3b5c1e15101d0cc7548cdad3cb556c0aca30a95f2c675a2202f55eade0c4325101dc92e4e75ec77189393c13a153b8e7b161f9782d79bc4d6d8aa033b8f0a010a06627bb00aaffafdb2a3ac46ae725e51a88e3abed8e3070db6e41fa4b4e471b9cc87599ffc5e4db3091150b1f15e104fc0baa8c7532241afe135b86bdc04ce5c1d8b22208429a4cae7d9821a474e36f2749737f9c17c494cee7f67cc3e5813f2a9525aed67cb85bde7b6768079f4c33a5d9b79c594a86b39ab656462e8b4df0bf679bbf9e85b2a802a2f24296484ccbb26f48c2234799b86c60107167c0a539b917fc12192cb15e03ba9fdbac4ee272502c7bd083cf842f245e3db6bb9074c057af58075acc1f2ce45f21d5f1e06fc23313ab4fed13062fc44a8ce3024b1fb840cd11598743a9b2b40df2607c97c8540bac62fa0a075bfeb4364ad843e4ee42ebc4ff20188c96e17c2cdbf1d50995de3f274e92f01a1d3b3e0d9d9a2ee1bdee3857f9148523b87c6be4005693e1660cc37dbb221c5cf36e2754097b2f1484a76289ea703c683f4a5a9d0d67cfd18c7b558e26d3f488445d4cc1036374f86cbd220e205c9a2ea0b711ee4f2e32b21ff56415fce93b9eb21b13b61fd5d6c20b60d50ee687b33cf51d2f80894343ac7273839f2cf9b8360f62c07479069de28dabd29c8b49b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
