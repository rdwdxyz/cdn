<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e03f4a36e770a41f566a78346ebf0b4061b56106858872b46726c1d6c5992386169a41f2ddeb3a7cd04b3020ca1744b8ef2f78132c6a65876d07c37d50aa1d04c2d0e40fe98fb3ff92d9959201cb36fd93351a69df7e818d6694dc4c3247e3bb63ac8471daa6d017955516ab7ce8b58550a0a62fb2f0a16d8649fd888d7ec4d27931d1159452cedec2bcce7b3b80518be328ca5d32199c64b4b998c60ab88f19aa71859bfaa2e3038ed13e3cc791fd77180024f8a0ccb50cd08ce3805922256afea781f7028ca14daa77252ba609e39a3a5f45b2efdf2664c5eabec98e95b9804b742793ca8d8616d8cac0d3e53f09a80d0b14ef8fb7138862ac4c92b07b76a336f8a5d99c718317c9d594d4989a742346db165f7c040b4900a7c516e00927eff873f439d0e179695564b993af472158b008bde427fc78fa38c7a390610b0d3208c800ab8989d9177142050923029983a4f4f2dd6b6538472ff0c7d4e7263663b36b40aeff8f6ddedd2a1ac5c0bba0440b574e8f125f65d86a2b99970ae757ae6f876ac9adf0557f07c7af02ecd0e7817d98ad679bd2bd5892c39e93127f8c68de1094706505374f1eecc11d697c0dae3828f24e45bc0ac509e7854b593a7c933fcfd45cb6c38818eb27ccffecc46bd808d29afbc32861ce91d543526648901f85885b38f80f7ec91efc0a6a61fb047f3fa94bc6ce254897bf1ecca0ab3265d43c8e55cb5297a9d4b98d5a9b34235db7ce712288a58f5b7ef956da3517e68d30ee3819fc11461e82bdaba6c6d7ccf97f8b6fbcfef1dcd1ea7053cd0f0c7044660b48adfc3ffefdcd0d6e6cfeafc51cbb6e9d72f1a63a38ac17d6b6899cec16e66603e285b4a6abb143f2b579280b2f922aab16f7959594392da9ca0ab934de22767c05a9e27d952414fc575d254be7e124afe40a43ec608f57993d4e0bc29c24ea9a3b06dacfecafb71df4ebcfc774f9912cbf1fce320f2959050dee30e80f7d50b264b9932d38cb3849edaa597468f9f62ec9125bcd72c666c7972338fe9eb6ef45f8fa23cd72d3bf7363be3247aca51d75bc6759e985495e9a23a1ebea3e3e51df3e7b10cd190fe749479041c66cb116882fbd30d3fbbc0c5fd0cada256d67c984f544dfcafa5378432cb9d39f320a3ea5ce846c46b3862f46358d09dd916f3459d656f5963f934fe63ea987596ddc5e033f689fc424ad6f4a5fa3453bcdd9bf19e368c0d1539c52f5bbcef9fa6d1b9807aa1194e4cff566150403f0dedf2113268e538f32b7729dcd1282df072722751ffe5869693ca73e0af250f25c8728922f592c17e540e7d3f90a838784d6b6ebe0b16344213f9a5d9e84c606c8aa3716f237ad5d531cd017475b1e8bdd4797cee36dd17bc0caf763d24f65a1d2be598865f481a465b28bbd0e45704c5ccc96fb6a9af99b3f4c36d517b992fd775d662997fb46f2f61268d78b9048cf4f0e87f2bcbb32c4f968e2a39fcee7519a3842ea03ffd04aa5a5431a002ce1d422b40b7528e0a41c78979276c49ae3909ff70bc1fd8cc55103bbb83c983772f25153cd4ff8c9e23ca80cf40a21e8a701e456532d27d647e7ea4e5182d46502693f0889c0f41354151f53c113cd8b4759cacffbff2399a58dc54b978b30d7e49e54f619b7f2bd85eb09452a07212c69f34beb00a38866a0476434d04b6ec53d33f3609244c02b0fa41850c328a03016e411bdae26d38f312b451b9102600c3e7b4082efe4a88052ae067841c4639c93df90f2211515bebf11dff531697af8afa3bb08f43c9a86a13bda6661dfb75ee6ff93a0447427a2e738661f1f4abcdd9ae114d48c6635c069746d4f995369246cf9930528414acc762521f0eb43004b4e2d13d0f25c4cc1d72dca0aa4895760e5f072286aef9401aa48586c040fb678267949e4e7a91b47dfd187b44e60a82514ab558067d747c9921975f02110683130afaa570eac47ee3d33caab43ecd0d1f070f459f6de2456c74230492c4273226ea6cfeed79de7fbc26721b5e9b7364a1215d93be57beca7eac7e72a99df27497e516800744501efe338b9a577af1e9147ea3432817c496afc1c4c275192d20ea8d32bead2ac8b48a05132993e04262f311b97610d8809a12d2fcfbf24b80e446e5834aebdd77eadc46829e197c3d7ca00ea73467ef148f0ac6fe4ddc1eaee4d637169f2b0447b3b4540a3db5609712a059265dd530f98d7f27594e7acabd4920f159489dd535df91c4b3840c3247d4cc70573f5cca74bca78bc86aa96560a81224583f1647ce81a362bd9f1d40a7d6e3d73d6abdb447edd1658077c36dd8a2c4c7fb64a0ae9e74953a62d8a00911e73513fff75355837c00602889ff7274c88b497ddd77c10bdf95e797d1e9d3469b87a956784709e0631aad6354cbf5a8e63373448c7386975a6e0c1e9977f67b42c9718dd5fa95948c638df29542950607f829af9a4897b50c142850248a620cb178d53b470b10a0848a317ec5d6ffe8d883e7eab78909fe345bd8fd2242c8b89d81e88086bfcd8f0cf43def863cae60750debe288e35639bae68d1748a432a741890d0a4dfc1adabde00a7f1c740d121a5ba2638b2d7d624ee254efab6e2e1ab3e7de6b5f69fcf0df08a8325a852ca6094354945628f3e643593364eb6a30441e629f594cb2f32c7463b00601d7213a9ee3873ed72a44f05753d9b80b0410db55a678ffc9306bd59b929ad676a2fc440ee8046033f97a895ef618b3ed3e89c315de0168ed45215d7678a9d14453d3db8c373615e12aa631710c6a7f9775201430674ca8671e16a8cacfa069ef118310085dee04d901e93c9ab84a9eec0eed804faa24d2471cbd0808d8955d2bc578a0e707dccb3d089777c9fa2efb188d13d174738b74054714c8e71923dc55277c1cc57d9b7e6bd898a078ca220a96d72d8b863346464800e68eb89d943784f5d23b71cf9c93a7c18a73a225765fed328e94410de38f32bcd0eb2bdf4053d24c22019b6266f4cbeea4d7591eb0a7e495060446e79fd3a6911e0f167941ebd890342be934061f541877e18df6d2625cf1accb39c30517b2504f0e661ddb845eda39aeea4c999bb5f664bfddd7b645ec85169407816e38dd7d52678125150a9aa59cba880827040655b9db218417e83b47f8e77ecc5ee3b3a456f4ba8966d7dada9be43f00a09cccf68a21fc2a7ced6928f1f4246b7badf9551223a0742d2ada92dbc36041e1b66a544a382255b6b4e12d2801d6e1364cc47e7aedcd589a285a2fb66289f5382dec2c9c688bd47e2b9601e2d11cfae4dbf097f31b98e68e51b6b28c6229f074b70f69f5f1c433ad06346c2260e8d0ffacb08b539ed58538d14ca6b23a9dc8f81eb3afcb10e979acad18a4ee8e50a265c2cf60858456481cac5e0217cf8abd48fea6780b26d22ca4fa66d81acd03198523b6d0f9f7ae02b30a4d943671284f6b769098056090e32d1230e58b155ef8545c4fc774ce151a94a6c253ce6c129565205afd5c6c841756ecbced1d3478f9c638c938f2f3f115218a5110758e5f25475dd0e89e6290e784e6b4b28a22f18ccaebef3a02e4c745e828a7ab4e8526b217035ef444cc6b792a55542c27b4a9f0688118cf71cfaf9c2f00d1c0b42026f4820c3b2dd6bc2e1d8144d5497b70bd256d26584366e1171ebb2a2150479263e0f371808be614044ab5a5d81a7afa5c58f8ec154065cd2d6a2ade95c00b67261a6dd67f575fabd5c77185f32bc79da8f8b5c856abe332251ca21015629c86c6d44599342e4040b3959b4acf9780949412264c20c87b4f5403cb0af8e67ddcf5be2e6b72322589d87a11f8aeced1c897f19a69991603fc34332f839d9e9630005b05d372e34e3a92a5ac26573ac3a6ce52db0d70d162b4e9b1c996f3e78b74febdfc8b4d060a7cc4ddc2fc03c40ec41f4b22bdd052afd281f0a6889ff7136f5e4b5b2508d1c5183ce008839bab9b38ac22f543b3ffe93163bd032d929682fb3c7d1db8b06f14803b4a43711f949e9f8925e5524c0b782f60578f46fe1e255b7dfa509dde4baedf93d835a6ef3fd77a741eb26afcaf02bc56097c7ccb9488dc63e43640b6c22b44900d6a44d1846809a938f77b72dbf75a5b2e60251c4bde6eae5f99901ee52eaefe59ec42fe2de7a9bb85fc294860ef9ae910cde39646687c8a5a2ddaf9e68274baa4a301fd5380943c9baec100d4db75e7eca1abf802cf6530952b5c3cf29491a9d24e0b954d4dedfada403b0796b0ad9fb50438a1140b17337842b97e265f40ed134617f8f7847e8d496a938dd5800591ad4ba0a7808ddeef4a59d4d62a0cb680cc26316e683b638dd6d8f7af607138949f48c8b6538584715fa01612a77eb2cdfa790480607bdf6b31106eb591f452239dd4461e055773412902bf321aaffa5f853bfb4e4e9f6c024dfa01420acfe0dd80d00faf883aa18aef107fdb16b0fc79f0982cc11732243b24fd951cdf5a2a4f9df633eec64c5776ee9f08730d83c07087270878352ae2639450f43d1c1149ed13176b73663f91956c22d0881f800bf0f221cce0ab54f57e1e1dcf3bd99b7799dadb2c606e132b818c0f1b6617a62078d02d9aac7e87256f023e9b5659d07becd26f5bc7c849fb0a011b998274cb27ed9f2d6ce6135d8a686ee72364981b93837aceefa71652aeb692171eebb79a4dbc4a525e998e0ca37eff3aaeafec0709b8de99fc5113490eade56709a728bd0a14a7c6723bbd9e7e17c843537a2692e3137aee309ce883b44363a201f5dc13cfa958d03dc7ad5f401ac2676fbd888bf509f53875d4e4aeefcb6ec450922a19ec6095a56a8e8939f21998728a0e39c32092696c39a7cda8799b0fd944147e9e5c3861abc9b61bf120e22917b759732ca014617fc5f7c9bb28b2f80d46038d19d9c79db92acf13028185e6343c1c0b89b56adce035b6099fa81f04f271a56282a8da1d975634213311caea45dd3521945357cf5200cc9fafe2640471ee92a2547d329094259c6dc710dab67afdd88d1ec059ce9551533116ba0314ab0200e0e4437d1699013b6ccf084c36e0d1bdcedfedc5888e83997b62d300c1fd1176bfe45d50d4d43e9f15858712f4c4d3197b274c77b385ee9be506ad5992bc4fca7f3e620070c7affbabb124c14b28431a558ba623cc05cdaf1450bb32ff9e013237356c9ed441b9f1db5edeb96aa638151a5d65c0f4c30193820a2a3c6922fe89f2e790cd8c5918133afda23fe7b9cf11f65f2ced5505d895492bce3fcae849731d4fefa7f112118c865b7e349c2750309bc5611a1934de8d626fcefc34f5db0412ae3cb2a64f19524daa762931eeebd114b437b28a46cc605682c902aac38c4e03bcf6963f0f64d756381a05db0cd0780f98820c498d0f4c2a38b2e3a9529eaf4ce544adac1f1763a380229b5322de5e7f4c6e7c4ff4508759a54ed0fcff45f95651caa21977c230243c59299aea373b41c89131890771331d3ed01f00719c676446256433fa77c57aab56088944923c097d37a395e42403f5e728e27a88c61088134358449ed4c07e0e80d60c3116096097c9c33796bbdb830cda2aa2a5796288d3a2316010322551250ff1e93257271f5d4be6a86df24c6447009ef5add728577cee9f77e8382c623a557171c28a2a397fc814d0677b9fa2940c62b14c7035fdf3ecf37c00f3de6c429640b0507d4e53772a591a48a5eee8c980c55399ea81f5341b339eb31a0da8fae548cf85890ca83634b327890f1de67cf8cf0514095030f925c5258ef5c791405a5935f4c848026d7386a4df860be272a237cbb628321f9fd0c614104623c8a4786f404deeb78d41a352d23ec901c4cf5b1cbd543881f8619264d660fecc64e51425b088a989e1e934a52a80579ccb5c24e458443c2cfec17410334815c050886b861e7348e27c0fa26e5671c2aa059cf1abb61721a955778f633cda10e97811650b8c18b340920145a5906aa7881d75d75e1e019c0d2795b6db8495edf345644d39ec1d4e5dd230c9d9e9a6ae2a49430db8e2d28b305da1f4604aa301aab19a4ac1aa2584a7bb7c5656b2b391e9e926faf0b8177950e444e87bb1759c2297bdcde0e3ce96fb2dec30a2f5a4fbacd4578133642b74aaeec0e8fe548c9360062d58e922aab53123207fce25496a301c8d82bd0b709c09eefd8254e89aa15dfe33af93d4c36a125acb3bf70317a8cf87a3e6d01312a8b059581da41b9f685f270b126b787b4b76e8d4d104da5f22f1934c33eeab6796b9d1ee9e2b3797a86116caf5505ed6c67be699fd31093182bf69df26e989dce742a53a33aa47626a48287ca5c2bba3c66e73a88d7da3705446e023f8f00096afafec3d926d4baf8eaf5fb30317e879c5439e5ac691684e9f559be8c3dcc1d178355c7e14a157c996b84ff8844e9b4c15ac2a98f1583b4b4d4fe3d7b7ad0338fa0bc56c828b2d05affc55b5b048ffa1b83f223aa5c50cefb3dfd12bba1b5d4c6076c9bbb78b3adfccc31b65703d46cf5282d9f540ec2b98ee01f0b56acd0deca52dac5e3b5444ccb6698ed0d23db79acc1209a34862ff8bca5c436c7cafd58717c23b4b2d5d557f1ec4a6bc5e3d0c5eaab548bd2ccaddb0c371d575c1984db54fecb3d0d2efed66d69f46cf33a3d36fd728dfa7064aca15f4138a082593be2ed699ffb26229010dc2ce0d1b8e103e389a4d8e43aaeabd1eb1f94e715b0fd613cdfd699731ce2bdd0af0004f2d6c9ccbcef146bd155efc6a251589ea9b6f59ef4420505756dc22cd6c0974b7264c3b6ddfa8819b5a81a2674e16d70939b96c9bf565cc54c1e7820abcfde25fbc4769804fc780b65e68df02caa8b98afd51f2ae5e73d6630f0565bb045f65d50b2136626bec574502fbd31ec2097d5cf4f4e9020a9d5e12d9429a6356f485fd0f2d597afe143eb23504eb6eaba52473286e5dd43690ac942304fb8e0c3b3b72e929fc092b0b11fea4a468ad704805d30b0fe3dce596deca1d4787486f6ef774cb4e3a2670c5d174b41d77afc0c2c5e14962fb513b2167e0d83e92ab9954c359d709aa86a1cba2021e54b03ab7f2919f397bddd44bd0bc7c97c5232acac6fc369823b8fa616f7b00b9fb23d993afdaeab11c57382fd22dfb28c28c4437d27544f536f5093d3983ca560b58f294051d313e4e00fb9ca734ca5c601df3ebb668fdd9cf4886db531e62623b524a88c22b3184c2edc6bf2ea04fb9b1c4f1c40fe3cfcfe1bddc3007deacc7fe13abfb46de0d74d38e67c699113548704c04ffd1382e4fcf27d159eb27dd543c4623026baac6d4ac0a809fd387db16391fffd6b4b4140be9de61f48a271d446a7389a3bb2fd96f2dd6f411ba08b3c8e0c5d09e18cc38c4163f49dba6e766477284a4463de4ee3adf18139f34f286b7c856e41b029a67ea1297d3b0bc661e2a33272955fa6e4497976b8692d0cea57187843d324eac36dc45b3814f23c6b54b0f5e01264f9bb813911a4d6e99b8c6bbfac67cd0e82dc25d0908e6c9d1d2b59c148026a8b19d05921270077c0ef00f7a95eede86715bad13e2769f41ef4e77835d34a143d0b8d9fbfa3da597d89a8ab3fd18575f67fe1cd416a76bc53a92bf3f3e2c388e082888a5a90c7ad65e094354bf1ffa1bca341c77c41308154ff0b14eba101cb1d5f951ec78e0dd293ce20fba0725698140bc52ce09f09339d4d5f8c6c7f2ea384652986e2c71353701de4b9f55b4a54863bc28af7537db2ac440367e742c84e0925a5e53ae3d0b81cf9247952a9c7c6b5bb10f9eefbd8e2ae4a696e38e40f9e56d04f9416533371382e41c4421b7fc4a7ef58a390860f357d4267a9ce0e9c200e22547d9a175f672db682258a47f04aaabfa15419284368adff165cfcd17c0d2884a867c5f93a5d4d75cebd97090693555198f2ffccb2abf8688b4dc8ff9b0eb7e73ae55b862205404cf47430d8e89240a6be0b1271e69b6339161e58ce67984f6e59234e2d10302347d8d08a57a95d50273aaed743813d19d592c4bd741a44edea8495344922844e19b4e03ba3564b8289bc84735b18e390d5bcb86304f25c0959e9a5cb24f21268d52485c2757e680a1bcb89146997fd1f64c8a48c466737d1463930639c8568a51217b712f302d87b1dddba5af4e6da57f1e4847a7c3b0cf453d5157f105066de7c79092c6f2194786f8256b1ba1d9c6fa2d56b44b84d807acf0a3f78d07a9028b410b67db7c3f80b8f6564232fed76498edca98d8f494cbac449952605b276d40a8758b696d1b757c0ed3afe672f851dd2d4c181cf538b3191535c6af8fa67471b86e22c5f17ff0b88cd6ff967b401743efad9faa9bde27dafde1ea0ae24d13f26cfb54e2b18481b0f11a4f5cf5fd49f3345034474cd1565627c3e37be700a460c022bc20d75f39b2a1364ebd7d07187137abda1a7881b5bf39ff54271639f710e032a72c70d23080dd2afc48a792d34a354c017441e8509655b4e0139196f36242f6a3a077e7a3a96390d49654e602e34d19689adb873c08b62349caa4ba943c8135ef6bd6ca29199ebb04b46c65a922aabb1cb2b96d9d3467f71c814c9910d5629f07c8a33fc84fa82baa85974ad0e21e855bb46f9e6bc24c4484a14dc30d4cabf8181e8ca0347f5e0b5820dc8d1edb6b4e8054c3eecb7af5078b8a919cdc8e9114791345cd0ac1e859a3e73b193ce7152e0b9f7db8420f8a2fd93db5a904a7cba3de5060c32fde2283b2ead73457930bd196969ed54f14c3c2ad1c40c58e754460045fb799df79220d04c6d1c67e64ee4c910a472ad5aa63271d7f420d2c728521297bf8cb97dc0144bc8ade7a2f338e3fc925f2d8dd5c2a11b9b2d03794374b557745ffe5037723eda34509f92f611836d97f65f0837aeaf63adf4234068ae9ee7bf7761868c263b1ab69c9a50bf5463cc9634539318da8b34e8c8bc3e2542d1fde6c9d74c9d30410f699f9e1b5df262d17ea341db0f5f103842a790c8bb4d31ba7ab5a6bd1eb6d2506721499264012170d07cc037fa571c7b36c954dcfce80b91b1daa3b88e2c4e67f5fd590e4fa3ffa6d7957c3290ee0fa118b865fafb1f83033f99da8c26f95531aa2faaeae4d0abe04f277fdee6e66c39a34b074f58779a2f6f6bbb2721fabad9d3c459d23cad8488e8d1b1a3fe353082962b8527f5e9234ecf3a1e430194f63bc2eac8c72244726bd3a164e940de8d453dd664c8eabb5afd483f36e320b7624c6eb6cc66cddfe79e295a87b24d7948b06253d1394824a76baaa928fe8b911e541ed48a174bf0306dc621bd350ee3c8be913656ba04f9b5855e27eeb4baef54014f65550a5485075a4f44163a870345af844cef89ba7b39f160f05f237d98059be2e8c55e205c646eb3aa6059a04bf02fa2c716e22a8b502c1372b6eeef0e013faf8cc27f88154c1ab5fb32b24ef7ab61c25da8f9f36ab80ac552cf0c08a161ed20cbdb3e9ca472aaaa640b8997c984d1d1ec2673cfd56bfd6cc538bb6f5ddc3a62516e739b9ce56d9826793d2d5ca791988fa2fc1c4cbc6b2d5d3de96838d59a373edcbec999db33a1a49f0f8b2c9ddc3cf156cb0321a7e55c06fe2b4f95f81034fbc712977aed43ac532050f73f909e5e47b6dd3861f65e07ab942c9b192854fdd6dda5e1583d574e802931004a7392a529491591355701f26a7426810d8fe4600531777d5def298afda3f4788d18aee1d9cbb369dd709d1f5f248c754233662d151391d450d6eda9e40e3a8f4cd40be462dabb3a29fa15c25a0fea6bd5091ad3c591973d068ac5b05f54a878308bb22fcab6239835c5c5164cd78a495763c7f14836a8912ce4e0a527196b7fe75abc3d572eaaf3d5747682f419a2a68bba7dc84c762ac830d8845032a8c4b0f05f4afc295c19097e0b329df58cfb905b3bd94b8bcca2cbecc3d0ea2fd46ee09e0a33eeebfb0612a85943bbac198b74af72a9a7e4d4b3e18250f9383625b5fd128e0faf2ce76f91f6748b0e7baaf5262b5623f811ddc59ca49393aaa6439fe4172932abe5cddccab9b93202f441a80619b841e9afef0aac46011fb37c104da710d6346315660fc4b81a3a354fc2b0f290738e2d2ae6f5e91d0c88b93e924e935c857f4e9b9d6d414425b54d49549767e3c17cf521ec49a5aefe9a7d5d180f9fa3d3826fc21dbc5ed2ca1d3edcc66b2669508acfb90a2bcb08dc5b144c35f6f7e1e93dc44c65f6d45cc06ecefcbacdbb5097444c8766cbc445b344d3eb870dfd8bdc7ff83a8e25403ebe413564187e3c65c3fb7828bb817052b063ad3a86c89feb4a610d754f2227b9a40031cc6b2f13a642bc40a2688bcd7c15a7823f8ca0ae698063005f65b00f40a49cdee009c7d82c99be35020aec7a327c0ddfc9a8376621936f13de5a25287e644925d7a074f8fc5fb46dd45d6a6c8f52ebf60b394df16b65f39fa4842974aa262927842aa2c8684b6a7d6a135658e6721d95b6f098cce0580ab155ff89b15a96bb95852bf663f530ea8d5262a17f48228bd4a99356711d3d304e248d4b2cc5efdb3c54f232db0fa8c04aba94456a444e3d325b01f55339ac174d8d1be6e944dd55c74cf0b952763b4feeb60dc49fe59c37b592e9ddfd1a2671cbc470d1ab8e2bc6330ac29a35c5c77c71b468341dffa5b92778a672a8086e2d1ecb926285dbe5306b5e604521cf1202087aad9877a3d61483edbacbaf93a524246e358fb1ce832e7a8e557a9868355c4c4e990495b1129a4ad312b4b30d4680722957ed531b93b1e268c0973bc6a8d8e8651f78873f82125cae186029351cbf5e3df6b68630d188da6bed750276d968bd2cf75e2ca4b10de11023d2e70e57d1337015d749024522c9b6b2cba015e6850052e5b697025c848599c63b605bdea5ff2c18fb03c5fb96364ab3bd6a303056c7d0ef4091b2bbb2ee1ea32784fd2ddc9c7d3e045bb63f3a4d71abae14f975a1528649623a9f10499053bc813a62723d4076876be8a62a712697cd9be03c73088094d186ff1a410dc8661d9b6acbccc8db4a532c940cdddd76bb443f29316ddf148f910c98f50105488a1518089756c2fd70ffd48c27e3f33f748a7ada844f72d7f739f505ba46e0635b1b67979507d11f0e80c37db7d9df1c0da4490e8baa2e797c6edae0fc2553ceb7794a2f5e344083400b547c35843808b6d6080da30c5cd3ac91969cbceab26dd05dcb0ceafc8a4031bd254f73e65301af706e29dee15aa9900428bcb618e1a4b6a78b22f97bff723cd5188863a5ee71fe9d18b7d7290767e2a821f503741eb67591ee8c03e33095d0607f36ec1c24dc11d116f6c0aa49cffce3e03b86113aec938c40dd5e89704759b9e43ff97909376a57a526c217dfbbc4ac7d56c983dfbcba12de94c7762c3b08995c1256717b5f1bbaa0dcb3463c69465ffb006ecd0e38745052efbf913fdaf4484739f0fde69c9fbdb05073cc2ecde243c9293b7bfaf652738a65ae8f70e897d1581499dcb54f1eec2c89656e8e7313db8935f1e0c32d005050d4b034c5ebd1cf8cc40ab742aacae152168fd6109db83c02be43f3e9284eb2b134e3a6e73faea8b27dd937186d962f1f88d76f1401dbcc16d0a8759d118583468c6191a0b83dc90ceb7b496ccb218ce7a23b230c08b5c986957814e854e4d01bd895fadb9bb97f786f3d6e88cfbda81d4fafee6d8abe3bc0442f9ffba3d9794f2540fe100afa9e0d9644d11f3bd8e2164a4b75ad92f3941fe1b736af83ff89346db838356a9296914f7d81127e2c6d9635b353c2ca7693cb70975f594c68051c3a79ecc67021a85e45c86ac9e18f5e83921e11954e50ffb7912527f724ae95844086fec14df7ea7e043b58259bb040fbf1aeb27318680ad6cb6eb7d3cda7b828fba4dcb4e6e5837c782a20c1885a4d7289b9aed3c86536feebafc03380b3177c5650318b9756d7811601e9f50873406c773f188d8dc55034f351ad878cb0b46689b16064cf2ae908316b234fddd35cc00d9c9954fc857df8cd5671adcc13ccf6a0f6929eb67838ef1b4a1bb98cbdd70bfa7cbc3f941d608ef8e6c3fffb3f41dd45cd5fc85f2932c6eb08a74479636051b3a1b00d4ec1bc251af7b9dfbb5d5117ace3fac7e05c4b8bf7809a2bd19662f7a796c6a9e975e9eb0060d7c47be5fc84477047a2181c02caf3b040901830ede2db5d65a51b9831f2a9b479f197e15837e12d027f2fe064c99585e785954e98bb26409c406d2956cff089788c6c90ee97344fcf2ff44da8d0e8ce0eed6934e6a4ba39de9b10b1c63bbbac674ce48e4657a9d3740fa9e29c5a9f2ca3e4977f5a44b0f4f6a2e707e02ac63a1197e948e58b42b4e88fb1fb9c29443a5aff8838376687fd2ad692873b7a7a6e7a05810b83f80d345bd7e3236e78d3fbcd3c06380dbb12c3ae9a80c80a9b64074e4c12cb83db126fec44db1f8d755b2eb5151077c2a57b0cdc044b5952d9dd7d102ed3b9f774a76341801201c0e8b467196710a289e3af95764fd0e3255d22ec2b1ad976b150db745d153738c62e0aad0e19eb5d03e25bc3663e0c5d7e649102faea79901dd5f1ede09198034a53110a778967b0ce0b0410884a0aee4c5becd1a0f873a807db111f917090f19fa78b9d76615c51ff1acc5fd5c05f1acee0a83d8a972931420cc2f388a6b83d60f10027c9af67b2224e0ebb038c7c190b76476703874c220ea7815505b15225c4dd4e1c1b309b55d6594fd8b4c4d231dc08b49fcf1d06e938396ad4cdb4c999b39c4325a83390c80cc9f5c3a76c0142167ec14ac579f14b1f9fddeb84639da98752a04c744727c36ab0d456bcc02fcb35dfefe1bc7eb6b6cbc7468e680681d815f0a726d5932c9e4d946939bda925678ef9f26aedbd2b4e7ef2aac2c44094d50b088cc3c73b75f1f6113d5b9a024ae5ac074f719bcbdd0056a02491c117da92fa6b25eec2fa56b43330f70331f2914fef2c44201ecf96924f7dd6f3e708fb2bbaf7e2ad0be2829fab328d5ebc3455982b5442606a0bff464a38883f6b9f3ab38851b33bb0af90c801b2db711aeaa3c50278f9b1d0c0c2b7bb9c6a14bd221ff4bc647ed61b784893b7628e60c857a41a5101f9a9f869372bcb09ce3a8d5b26815211e1eb88b5e5f86e33f58076f17320f1a82962b08becb108446f6e2282bc70bc8ab2910fb14e857e5519b5003f286d5bc506303be124e34e15cb7ac63f8dd78281eb40c2f56207f65cbe0488c842258390101ee2f762c3d7bd05d14b107351dc5d9f48ccbe0cd42b67928fb44d9070af628de07e95cdfca203ee76eeb03be895674c0921d1d3c788543ffc575c0e1b45b58b8579f2d6626e206936235bca68ee39db3004d9d9ac4a5f1baac6d492b5f0c44a1fb0050d6ed29697a9ccd5ed06cc268ee742cf49602b8ceebbbf0a0fe2d581df6254feef0b720a36815618e2c4da1aec6e00a86b99e8dc4ce3106e8096d2d281af428ee66a9359e4061771a4297c7f57ee0b615d9a53b5944b3b3cfa13306e188f7fbb310b88b9ee92946615e6ffeaacefa1d1585ac65a2ebbc5e04f7e928f00e2d9b725b5a4cb86c80a5e66c64660c53f44a1c0fb46f23bbed1572a790d78d925c5f726396dc53ab9b0aef41e24647d8d58fb853538e7602bde3565ca5057536e2c1e46ce80bf151c945b5cbf3571b0ef71f4c861366534277ca8471b2fa4f95afea8f4118cfbabd8dafb1d65b30839972d3a20ce7fa89a504defd3662bcf910e13a69712e16b767899dfc9226939e746702b6587f127eb5539472a1c52ea487d8e6869c8072404de1492bb3f7678ddda33e2e126b3877b40564f3c29bb3f3248b96c11bc2efbf6bab0a59cb418805c835ae5b01593e7328eac0c93d27911a16e965721c298587e3b067c99a111d0d4a9331d31b3cb6c28aeb5ca85898bb56790f1250c3b5e991122b22cd87a273cdf149b37dc952d120d7c555d2981576a42a029021f0ea51b73eb9cb48fbe3413ad6a768873d08b004462808ea92f6f580904bed313c70f7a236d8f67ea016f138ebe5c022d0292230132dbf299e9fa2c4ddc095e1f71f890c613d67f965c412d7efd0a98683e13ef0afb8696a41108cddb55f9aa3d471401a1f4192741bf55fddb7c34a80ce4874583fcfcce0ad04ac9705ad7efe0ea95be63c40bad3e88c20964defabc0df2a3744e1d4796229fb97a7812de394a3b1a322c2dfae5f6c4cc05be0cf14b658848de0fd0922f16030786397afc95c7cc01d91a7e1aaf77d378a6d19afe54ff38b7299ab17249e36cf188581f198a076ca1ef10fac49f92d63fe89e22c9e0752bb52bd665c4f9e3725930a5801b49e75ba1a776db5fbf10a1d842dc1a872b85e3ef137a973f719ec95b3d57fabd1f5be559b93bdf7c9b12b5d1c1ab640e80af3ec7886cb3b3f03ed19817e38d9e03ac0f4cb32c5e2baab20632b2240f47021d0624d3fbd1fa90f6066650030abff535018251cdf71a62c6b283faf151c4cd975cdb7b521e963d1cc56322c565ce0c308d3ab2debe5e179c913c00263629dc19a9d8460a4a5b85c5c14359176e7fe4eca02b82edfa2717b028bdae8b7d0621c4704010a855a6e5be5ad31aa93a08c9d6bf792ee21504d3b289e75fd56c0b6a1593cb12df6e0e1829f444f8b6d7962808b4a8cd820e06411fc84c38185149de99e47f2831c6a96f21b24903e90c1f22ebde844530cb0dfc91b96f0774107f400ca7bd6402acb65eb2ddfa1d2c715418b5008842d37ccd0df5076c4f016bfd9fbcf869cb3aace7a40b39fc9370ce682e6b4aa76d9827fc4c87f5405feb4808f75c264a72590700355f418aaf216bdf1758af5bb0d3ed26a307470b401d747e6117eecd653c3eed28d75797cfd16ab62f0278e2dc81f5519461ac2abbec6f3299d5fdaa2c8ce794cb7ad251cd949bc1949ea1686ffbd294cc546fb39567fe30d1ea9f935a94ce189f6fd16bbb28c52362db8c3a29dba0f0095c2e418531f745a0f53bb9edfc302079370dad6d6c10ddd1aafb63106e2f8be4a7245153791d37e88fbe1eab128c5e289179c62ff16c362cdd2b3ebb5631a8da68f5d0727e47f29f1aa548baa773024490470ed7e8d0c4c1ffa67f563fd52933158306a6e7c59ff793cc55aa95cd7428bb229a7bbc850fe5f384f71499f2c070ce783c5377ca03dda7bb30ce56655e1786fa5b3032d9b440554e7351aff8bff870a6b6aa22ea6dd4ab22322d6805bfaef897d0328fc206e65077f0c103eba5405da5aa7aa225cda6636ed88e543bc02fc1e2e5ad04f976eac2105b0d88bcd81643131a623c7d281b98a32b326155961da070d58c220043cd5194fc43e156e2c615372c0f9c426f906a006baf51e31e9dba070f411abce9e86cfff666ece086a23fe7ba63b82429a36986d0bc1b01fc951c0a431d170cfc1c6fd1433f6f606a213fe45572a59a5c0ed80f23e3655ba0c7a38b22d965cd9fce741ddc8811c9e88c042766799eceaf24a1e43cdc077b142c79e3ff7e85f366e92937f3579a7bdccbe1b8bfb76e31a950fa148e92fe3bea9ba7da29c559dbb1730d9aaf2ee7ca3ae2fddd3e2507506d7d3062872a7c116b6a18fb23fc82c536e7dacb97e3e50e3597bb05ef54508d14fa2fe830c907841ae55d7dfd8efa52d5d8a09867cafbc350d036744e345224307e8e4d81ceb16587cf7baaf931df94d92c9c8fe10ddc50e6f2952358b7c4615d9372391610e7b035d4a4d3923f47180394d9865db512595d73fa09580b1f451a131797e6f5d60a6de5841018219f9d21015fd01e471abb76adb1bcbb3184f21d82dd0b15a66c0a4f2c176768b74ee5611c9d9ee06c2d6c9fae921f83eb4f57ae1c5f598135668ef5fa5e45a00da9590e6969c6a27e04a90d3be8504afb35fb13d10e357dcab1b38ace8cd2675d050d527ea94c53c9737b5301c47c1638dd406f4f52e5fdc69e25dfcfd0ec41e98e51d6d8af12b278f2ea6ab3c0e5fc9b9168a522e7f97de285319709c292abb8373cd658c66eb159e79979a62620a94a1270d205b5a973cfadb406ead32a453dbe818b6362def624bcee1a79a001e6a4de0708a5cc52f7ecf7f800f7703f04ceb52bf3d753528497b3aaba9387831c88893981463e606a7741880e064b63a918c84c239f37aa2309546926e5c7871202b02ba95935dddc812acdee5f6e8c095a7149144fe654163a948c316840c3a595d4ec262502d02dc0346d5645ebd7f42757f9362540b6ecc99871df48f4e10b0a911449555b2d37e7d9e074caad84ae0b509ebcd40f8ce4a6eb3d1260c10af89048cb063c067fb37bf269f921e0313d52a2acd359ef10dfbbeb53f237f210dc8413a9be601b190e02d40777d5baf55e9a7658a0edc6df91236e883b5d788033aa669c8e8390c139afae0333497f88973dcb67105fdde77b8301b8771491e575671846af145dd0d0ce8b09e6e4ed35e100caf2b89c1bbb53205b7d55aaa5fe6c3da7f81bdeb2eeff808cf5ac229f1f16b2c6b2add9383be9be2187b88d9b54591a714177eece1423b2b0feba67ed4010675e3214b20225cc18f4e4324c95f022005dd5965254bd0e81aa4331cecfc3ce128658f176db76218b6b64e41bbb91a8cc802b43ac08835250f2c4be2f9e7c9b1a45b51c20e3039b2bd50687657182a4bf519a29bb45540826f6bbb8ad13afac05d5dd7ed952ca8ca10173dc68f7bcc31ab36c83eebc8aafc71ffe06c8cbd8171ed3ef047c4aecc2267427b22ca3685eba8b3ed601df0b87690e2d14db2114ea8122aa0a5889700d950a0a618bd3daff2e2af753714e8bd0abab979f0b5b2748ae818afaeb2a28009d08c520a7b470da352690f6e8683cde88352dea3214841b12f17e41797d5e12754a43e54016c01a391d2a124668fed708597292345da07564179f92c7e978edc1cb27402cb57fa5e91fa6268d6f898914c005972acddf8eca55ffb51a9f378e7eab8b11bf9b1f96d17a8055c44d298917fecaf8c0c6b47dde025251fe6109d3e22930117869ec3ed3f9d084a4f5517bc326be1c98f747031335496eeeade333d86e164aa90e613df22b72e60b37f406d20711f53023c1ebcc8375b56c0e909d372f4b9ad740e1ef053cc98da9677ad68e1b5890043056ec6d69486ca3890a31b50b6b6ac994ac0065440fcda4a9518593f8a180d034d6fae79cc4d8fd2b56beaa519b0bb49adc1085353dfd94d7a8ea91d9df2ab59e05464e6228ffaeaf521fa6e0d799ec3ce7d21f146193b6d07b43e6687ad9b3d5a1a2aeae122b7b6b8b3a6ae362d9b8b0e79b82183fa50b56c61042b5719078c628a67a6d6194e9369ee9cb5d677e6687a8090145cd0d50ffae8e023413866f904f592afd3c828e35a3f29e20d3edcc6e05948f9492272447ac7d9dd5593c28a4322c78a2e99e4ee5f49118cde21a35f4ed90014c6e9d8765c31b7aa86074becdc830f16920e4e65d3e718cf4f495b44c1e8044359a7e656338990bb4456d26d7bd9cdfd421119ef3946dea76e9b1cdd61d855db02c06788ef444e421842d34f67d0f5de68cdb34a9cf419e97496305d32ea2c33cd24dfb0a5a12edf495b53b88177a224e59ef9a6fa8e010c5b5c8e849bf3206052f0ebab853feb14fdb709fde388d3b4c196b5142538418bdb7f5847380d22de40ff24970349ebfe42667d431d36ed61d8d221892d347efad0a1e43ff67fa4f7071fd6c14a19d12f6aa912bd83982121157ecd5f0af8968e0a3b2db18a1098495849643b75dd0bbbc88406c8d61a6a3b6546b6152b5e8f3e01f777f2d859111f9ec71fe7eb3504e3b8ee2b1d6ec44f936fb6f17e5dd53c57e733b41942d3e4c308482b04fc3188968c630c92c565b58aff3b7f97b9abe4953bbe909356ff472dae6f75fc19f6710a1b289ea977bf124f37ed029e770a5a4c3fcdb33541a42a0b17de2c131b2371f60071368530706d03a797fefbc2592157411811fd32bed311897d367974c4392fd7da4543e4a2d1a7ed7d98c8f57a2407321eef050219125a1f2cd68c3a693c791dd28e62dc50957696c74","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
