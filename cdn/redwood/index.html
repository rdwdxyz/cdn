<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9aa9505d8d75a3a80c98170fa82bcb0e0550eeb3bd88358d09cacbaf397a201651d01dd9109cc840b0857691053adda92e6b451b1d9fac91ee4e56a8a17585f42715da197d617aece98bcd47cb98d0baa54ede4188ce52375c3743b68bbb7c514b19c680e97e58ee4d28e0c5c4b9709bef71add371e4406c6aed33d508cbb061227c1b71bcaaf34a473ce4e18bf73d0bed4ff60e349832d86864bf3d32f218a126a4fe0f7a810589c7bdcbf4201bd4130e3a77518863793c7ac29312c47c85e10924c7301dd5d79bac467690db5d568994e7184b6d44f1fcf74102488130b9f057e7b08ce54ed7087d9d003a873e616953f0813aedc0da0a2d0a4726501e2d1460b1c06dc769dc2a1d25a7086a4a002c627440a2d36acb35c5f5d0b9f5969f0f3a48a559ddd37facc7e51abbc783b0efedb3dcb73dcb4e5180ecb78e3a4236973575d62543c8acafbf95eed90d485e2b19e7fc625f11af2dc04b8caf086b3a7c0b2f50fb87988837b95b12a83ccdc9c58f50495424423fcf916ae084b0866b528b46b74a6dbf8c3fcd3460f8c17f64533bbcd93dff591b26092c7c71803aa9af0b8ba6377bdc88289e9df40f0c43267f3b2d9e46d193b17af3608f479f22f834e8c5e066c827d331d042b2001f09fc6fc0333fab05ab1ccd7290b8ca1857b221eb28d260f171a0b93df7699ef2fe81748bd3a55d02503ffee6cb48d2f849c100b09d31632802165707e66df1af586baef97c6874254788142c473f53d7f4eb4a9123a27f3aaea27e5f50c830f4d3644d0eba60e13bd7d60b7b8c267c7f699d378805aad4b85f3b2771604e79fee725e539a56fca2157ab9c062c4ec2d5ab12d16dc043f7402ac0dab4984bc18b1d84fee5f788c3085352f97307b4c6d1f1bafbaefa9ba159bb5d037424cbc2b792a576364bba2bb881fe268ac68e451e20ddce20ff057261aee3b382e6630c7b0c0fc318c380c46d3b9a708e9088dfb217a764fe58649d505b1fc07d54550b3e5ae89a8e847347e5192be4632b9db701d37dabf398831ccf97541b82d8584f22a6e30e2ecfa7f6945a9b8fdbe7e89a447e2381b9bc4a2a485f17952c8e532d368b11f01f6938a8f632c45626aed047c299e7c82782620013dd65070717560317a8d73b179e2517831446b07082b204ffeb23611c39c8a1da92ae46ee427a4fa4ae81909350093e9b4b512cceab799b5a253b76337739b0ea688e2327041d480ffb698aae75d361f0fccdefefa491f5b31b3f438edc91a9395ed74a06c4ebd78aa7e0cbbb98545bb0746469a4f108888fc0bb3e0d9c1bf8b1c9436cad610a6bb6a948452dca11f08a05d07857ef07e5e83f1fc56f801f5a795ac86d1879f2e34d223d1bc61e24debffe1a92e6159fb8951c5f7a2aa7226e876ccb15672f8179410d0a79e08b82f1fd6bfb67668771defefc92082069bdafc807ff94a86a802e2c2febe7a53118fd2ad7688b19a485806afc57514346a41f0727576c16474f67f3d29385f446473766cd42715fb9634a9c5dfd092241468581ef5c82dd89940cf70a449d1f45d3237dffa1eb0b3a5c9a407f3944fb3600ec1a0bc2ea3a570384c6576b014c221c68d8aaa9c92033b7feca4293081ab86b8fd589ce15f4175d5103bf37654f262fa5ac41e3006bdaa25b6979db287d20bc13e61a3c9b0c452887b3d477f1eec8309b773f636475b77e16b0242b952c978ae986a00c2e6defb81f6b06f7cfc5bd718f3ce4fef0fe2faeea5f2c05caca8e528ddf55abc5e2a96e6a208edecaec8b36f46fc07273b613fdb2c2915cf053a17b24c9d38b4b6187c56a644c987cc09c6237bf44f77e005b552b7fbca919a06b4e437f1b1cd2b259cc18c49263ebf5b8203e8da2fcb4f2848977b4720599d292b27d49f657142d8b82668751a26eca8dc8ffdff18b70c780520217e6b9cb144042d315e31c0662cf2585944a8e3ce762818e5662fdcdca3f6c556bf1723be6f7d191b82a08de2096e2b6a780c3d88eda85c2702c6797ed8ff62c40128c5210fe832e0f7eff7d77b5fa8a3283ac00e23e07ca618a4e88c96db158d4652f6dc21850bf39c274f227f95181d9d76f9544b74552c30ed7465a949f536fd4a05bf4d22377ac9919af1f88500e270386d2283b6dd93a6d0b20e65050c2205cdf12ed4cad831482d52851748c2ba5d5de5e938bf967b2bd7128e2427279991f48e84494890c14417bb66b311fffbc4dde417b2c515be7c31c13d295c877543d7cdd70cb38184bab5e1ecfa26001fc0354234e25829a99b1b39cb0915776556c8415ca0b12f1a257e0d66dbc9c4ff4489858e58c58b196dae200720d8137a78d1a34052157d93ca3f06233a606422bb62af9ed879a9eeed7dcd13df6e3a398a42c77b8396d72a891903b77e6e625a2094e2cd29151619da376efbc674de89c70fdeb9adff02455418389451384adaaffaf37724a7d3019d398ba9e74bc828f39609fa577ef9ed7d765a6de3b3abf75066b48e05da67fc7de3e2a9478da2c7f36774c88c8c79065ba7831f06bfeef719159861c98ae7e9277517647e5379e0df0b9193592ce6d07c55e6240c40701da68768e59865044aee6a836a5f90060a94bdc63c495858779c05e9d9daf3a0daa045e2e9398cd52097e0313808649dc87feb7e9258fb9fe9ebf0193024b9b63e97ca6262e94b169282abc36a70d83274176ab6ec35d7591d561e5cb3022ec369388d7574bd971dedd376ea564fad6640d020e5aa2b8d4ea7d5294483d4755baa1f710011198f18a1e3d0215c1a4e91bc64d00a9a603f26844f36c90ce7ffa36547ad563b4ec8d648e1d90ba62d247ab1a07cf874fd989af757ef7372239e0accbac6d591cc6cae33791d3a948714e2be2df4739372e18ff3fdded4ed695979fff8dbf33b64f5d59595a80a94dc01d6fd9058b771fa00bde61b33e0de93671c1d5fec08dff51e00e2066cd7db7176eccb0f56f4410dbbfdb67801ba55ed73912a5ce266f4006166929bfca14bf3b1a626452cd1de3413fc92924b95ddaa04d58e34bfa9504aa4c731cde9df2d244443b1f03ef0044d6ff82e4f60249c615822f845cd4298929e32c012fd2f9b475dc6642629ee00786630d3f4b47d3a1e9b88fcb534131dca7f3adf66c225f3441ac91f61c6ce5a8f750a5d54bdb6ff7857b468590f5f81a003eabb56979347710aaffdc9c3ed2c4d17eaec52326187062651a26fd5cd46f1af0901001050286a5814c94493274ca3d2061c5f759efd9f2fc31a7281b255dd86e16cdb5586c436645bb2dd5d7c8c8f6b45599c75cdb8bd69e4dd286b02b20be06fd5fad8b387b1d27ed352a1547934389a13f6d9ee85aec67826b0438251daf8ce5761e9e135b875fb1fb13c7fd366c86d876ec5465a4c34f210fa8811b9271e6cbe72050bf494782d285a8da84f98bf19978f8913581f5a754f91583267019aa0facdc05340b74bee46a99585d1f9521aebc482928365c01f3b863e7ce64b9f7dbd1a1c4ff57dc629c26676768a5554d95df22ec952a110cb36f3c6337d1ff278b0cdcd5d092a02d83c248672d974323fcfb7dffe9a027cc9d5de150c5a09f13aab229b897a28b9e0a2c7f05058d22dca1b5ee2a34245d8e2ce51ae02988b821999f3149b22c6dcfee6b6ead712a771d44d6273c2c9cfe5a58740ece0125764822e495ea979b8aa2a8b0c0931cc5cf69f41b1abe9962021a892d0dd63af9fc105b124d779797d2b533753ed1c128ef97436815746971f35ddb315305c00d2c7af099054d6a7c97d748479873363aa370166d113c5987cb7d66653856e06a5a582be2063a39ec04e610aa76b9971150ec7218c80f609d99b7f8557a767ac03b6464ca352dde5b1ee4eeb6231212ad00eaa8bddce18663f19c8a0ff7a13de774be610061dd9e94c6e93c80a18bd339731c2b10362973f955c8e1cb772a25963e63a5785880fcd87a368ced6db79f740a528d77eb2fcc33c19b6c66d05cb3ec403db73a9b681e6da47164f80bd198df8592007f780200fe3d2ee3f87ee69198dc25490460413dbaf15db9f68e092f17ceae0f19d1123617f3fea89ba70a7919cda29b3b0c8fccf59786c3e29973768ebc86a8fb4c5df221d1021cbe4ab112dc00aa0a09cc7ca65b09c9c2f7aaac850ae02d9d7fe2d0de749cfd74b41ab178153046e8f375a7859448f78254b5084ebab4734a1b683482b39007f335bc6f86819c9212d4dcf107b196063192f89d99f16a921a2e0fa1c099a415857fa1e2404b5502810c401ac852132132c66ec24704b399053c26e2365dfb4784cbc46521520b1e604c735b71d2464335954c665849afc3dd14faccc6ac139edcf4a1910fb8ad230575d73bca7eb9c700318bddcb8d7c6ea8dd345e1db6398618d98803da1fb654bf930719309b7c12dd04bae3bc1b476b1b6f1822c24d2ae1a772f25f9f3989a74802b18860321b0d17414eea75edf7a442f3858f48a6fa1d2b7fbde3ed45045837f9e037eccd01cf02845788fa81c26fbb88d1f430bbae693d6e9e5cab5c7df388c74cb850e2c42806726ec028a4021b6d68e11f53dc8f8bce71569285a9d975db57d6ea890dd790864e90da95f281917e07fb3f88056c21c503e6e7ce8cae0af4580a61bef986322bfceddf7706c31fcd3964b6342b464892dde6183187a4b9c6223fd3df8ade3dd85f8346306605f0337046e2cfb37cb8aa13f815f3a4bf2ebc219138368aad666265c9bd47d86c47cf03b0ca523c0809cea3c7d053ae1d5905142699417209d4e1955501fe867b04e6aea72ee49d0bf75cd76f81084a02d0252588cb71ebc46d0cdab1a70fe39488efa79dcd6da78d3a98a14e523fbd1bc51101f5b1eb55516a42353fe02107baff3c638f65fff02b6735f567a59faa5a9f06277501995d5b30480359e5acc5b8d12d86849f1898a432de9333c8c6bada1f3b1bf8a6a074f585448f29c427ac9e20ce3d750563b8f86038e53ee4e0498bd841bc6fd024b7f93b755634cab5e6c23f58fb566b1fd1f6a0f2698f6cf80e4998389e1511c336f5811c949cc3cf56eb8093902183f3654639e34276b92a084b962e6d0e126f50ff67919fae0748e7094092819023f2784593b679da27d113c6483a11c85543d6cd5eca750f0f16bb3d62f558d3661df9995a2798b2b0eb7295a09b192c6715d695d7ca3a4dd376501af2b09cf997a567e1819a46b68f0057c5a4a088d19a8460270b1318215d366f4f64dd4693c42e71977d34d3cf16f103f1263fa843cc193f1b6cd141fc1eb5b4b45390a6348bccc3eaf9b9803b97b02aa614c0bab6661f5f79923e5c30f0d3f0f4defb59fb75c7be7659ff8d42547732a1dea3ac876354524a0d2cdcf76b5e766c6957a6c8a89d3baadf8efc28b719ece59f7cd9b486e59550acfa685056c06123b6c0e4cbaf0795a66a21406cc6440b290357adf9748d85b2c07ea244294f05bd01cbb5c08691af3f3cfad60e23db31c702bb7b04ddb3b690e347c3a21b1898c0d92edc42e8147ff24d68b49c5f77cda666c1e7dfa4781842558b6f10aa81b8ad83332b06d75272ed3679d4745dbd2ac9bd037e16c8487fb91bbf3752524a4b7a12e587ec803134a1f4c76fc636386e7f4e2a0a84d132fadafbdb9e6eb65d9664d880ed4c772e333a6c299bd1ecd9fd86959c0a7178052145687657f2a937628ba1ed938c26ddf0dab93070d6fd8032dd8c2161fa0ab9bfcf7a09954e53a2e40fada841e657f28d174691c7af7403b1ac09721c83f4010a67ea4e56a542e8f70435f5acb28d8498d6818a42e1dcf8e824095e66aa981c4846f3837b132af61e92ee253542785ef28e351fd55e70cb6a9d160a9c9d857b4294c26efd24607a3f73dee464e8ad3d5df13e316c04ba39d1fa80dc8096aad4084eb8025c217f4d85931ac0c0f1e8cc23357437a97a7dc32ab146609c66a5fa9e79531223e4c54e4824f4a12069fd1a3925b776c104e6c56533b17693fe6486bec88ae9faf3bab8271daba33aed8589cfac09a5de2791f73a828af7d6701486580743789d58f85567a7d323971d452019688b3b7468ed0c59c646f4f39d7b81f05229e0966c39b8a90bd436138020dff8092efe73ad8ca264e2632256e93e298a281797b0f791098387bf3775d91937e5cf4461e0428732c35933da70694cc78fe0a274c22a44553003aa47916c3610ad11be7cfa0a61c24dcc44782acf40746774313d7b078b70862e2c3815db4480624925786f56f019d038ec4a221c76466b82202546b9a7ec00ef1f070e3f32b77287fb4e9b680bb8ed4b7c087082560c93f54920466969c90bae67155fc185d41c3240c9e82f794ea4ebb7c99bc59eab4ac23840863bc4f44f2d05eff93eef5744eadfd45a82b17459e0249b799ebc794f8924dbb0ac002bd3a37bc15dab8b2a5d6ffa3fe9dab3a45e0319bb3f136f5649014a7d8b7228981655f7171c94b0ef29a865ae79c21b1061de91754b6c8661e7e0396368b883eddee40f69e87f964d1d5b6c9a31759846ea9b458090fcb00e9e4d1d16989d805d93d825325f4648e4f3c13b45c5bb683e383a155943896d854b8d14e66423ca2eb4fdd457098668fccbeeb16e2c28e931144f95c99548f06b0fe72019069894f1be5c9a841254a8d18ce329740c0a1177e075445646f42f0ad5b9e4a7e16498972cadd663c2eb015db5309009578671015fa2f6c83a4a27857e6b034eb3c455a595b4e176d2addac0d7ca2cb40c6b56fe46713af3028c3ce1b7d77bd997d427cef31a16bbaf7640b2b9517fa8f6c5d71c6e89cb1619d95fb8ead144993b8dc15251eddae9ec3f2ba7d386e0e6b833eb2ff4fac6ec40e14a704d86a5ed3f5f82c334680b785b28a347b2ef585d3618bd82ebd1c3ac4f0712551d503087136ebc306c72adb471597d38d230f6aae01c2d92c0b4b6d0cbf26749370c29b331be3825847700f16b4b96bb9babdc95f845838a511c125ab55b3471c14f4e7b904c60c53137c04f684786c51a8555939cddc87ffbe0231662a0748e8bf39d4989ad593181cf5e78eced8e85d5a6ff637519b59dba9d86b94bac944981a3e8a0df7a2f2252708b43f4cdb5432b47f6e6e67f2a6d8c2318531d32bdbc403618ac48a556b1e1d41d655aa925879d514b51feac83be43ff026558d02ee7a416e38d769e11ea06459162e39af4e15e6f02f23b8aed55311265ded7c86528d0625e0324f8509c3be7b14444833377701d654471a10955d9b73a910b7074b3e639e389c0831b5ab9d0b2630e9c4a12165ec426e68f7000a67e1415f7f9450ef492a08d2fcb96e9786916a985f6a5f66ad313d2738ec9fff7d5b6c04e07a7ae4740def4131bb4b891b00fa7808b245d34f27aeaca65d75ec38e109b99e89f0e9aeebaa4f47ce5b18bdf4934c2d572939dd22cf3f304ae144a14fdc42cae1073793a71bb201313a4eb751f3fc08df15fb8697f2e8498f7365c37d633c7d5da6d03e761ba71d7b6859c88f3f61cd2aadd068e5045ece4b0cc59e7924b765e08948d5094a0e6021a8a7b571f610521d85fb58bc309c9599837e89d69bc93f3a9f628af034a6ae7b8d60f40004311fbeb8f19c476613007d93f097893ac52bdf5a7374279e6d4a2b02df907ce242e2bc1fe898ef2fd1fb0644507015bef75b2ff242839fc02893edb36c7abaef2245324b389f70e95caae02462a0f764f43182acf7b11c25af3576c26662859dad11c23c48dd3d0cb44b1068a81c1286541c328ffa9b1f9cac30846142b52cafabb971429c50110598227ca684b761a43871fc8158868f8f625d8419c573570b0b05b3b84c3c1456f558d296c9a32057472edfe6700f22c97091cb89c66a477888aa1a4f13737089f3dab9bbf70a9faeb87138c48c570f9df99f5b4c2fc1883e3822493bd8d798096c25143826100c69e426ef07ecfebf3ab8acc8996f7f2c6d5abd4428731d3748ad26c1992911f8852939e8b042552cd7d5a45aae267c8ebf74e1b520f4d888e6d07f13a83f1eeaa04dc8b1c26803ef24a4c9d8dabf34a2bba619fd1d09ef74d0b9877939322ab84263004cbdc5948993b7067a5041276da4f158dec8763805d9900cde9d3c252291ed72d060082887a63fab93ce72b5418fb5cc80f1bab559ce02e746ef95043e60c04ce789806d4ef91b9bc062578f4f4ab1e980d84b0d5490cb35338c11244f6aca2ca108680b12bca83bbabd37481f0a8dd729def4911dd3edb2fad61b58d78eb3e884295ef08992c92ace8ded2e37a4adc20685939f2d995eed91bbd47796bbbd1e0260b82d7a0b6f803f7d27d1e74ea1faa837ff5f7b5df9ed205a32d54572f5ea2ea5570345c74da0e8d7a5aa3ed9d028c1e9c2c0a168c04a9e125a16d5543c9e629b52003d3f02d5e4bdc49a1efa996666574fac959b9ee928bbdadcf07c7ebdd125138b28a55c0d6289d1aec2dff1d8e5961c4bd4cdb79fa0aced3e05293342b75d1bc0bc1f7a7587ecd9e45a6876482416a65234a42d8867da22ab25e6387610487ab1078d1587c96588b66fd3be86363bac605cc578245326d76812a24f319ea8ff9aeac3e461618a353c5666fed7a073b6a531774139f8f306c68e2a110ceaa1c23dc733dde63a03f22cc18132a930bc0613ab244b524d917c5dfcd114d9e6e02d36370ddce310028cc8bd48a2bb6611fa648113adb182024a10ce45a0fb046ecdcdd76e5d98aad7cc9188a3ebf539c766e8a190dede43dde44b0e5bddf4315041be1ade098db8e834c34f5bd0efe69fd323c5ddea4fa1ab02cc0702b031b5efa08e5ebc0401233576b7a4d5b2ad3cccd6edb3181e82bce9718af65621c482fdf2ffde90ed2eb4858e127e30fbb7ee8b8facdaf0876b14a6d4b7ec5392253451d0ac4eba24233065666eff7f2450a51531e8ec904e83a5800af1fb518eba716d2475306ac66fe86fa5ce8995e2008813761a73506a4a16fa28ee1e78727abce4c22423cd9703263c0d4e602556a225c0d6721416be4aa024991f65db13f4ad43463e3e08f13f6100cced39ea5eb26f77d764d938f5ad31da5295433b24c077890f4c11f5ec57928320cdf627747d785522496a41a5f376ba4a5fc4289cd50e85dd8041c783e6e8b447304f666eafeca85628e467060be6fd5c9a53ff95876ce377c61bce3b9667475ce0bb8919b04e2f1f7d223a8cf821af3f289e741438cac3983356205ef7a243daa95f8eabfe15dbea94bac4b597f10373ed682010238ad32d878d89c5a7fa26ece066f4006c754d66622fc23435a3c9d724ee14ead82bfc52f6a7ef8f93911b6129e181a1f719e84dddebcd05bb1b141061e364d9e2d01d324f4d7fc9a7510f8f80615e2fca25e1c4ce5b9b433428e4d88da0333b391f914704f80f881041b7d687c5f41fa50770b07aeb929d4ce6de895b9977059dea3e60f094c8785b250907bc0dd89bcf87f2395b96f47b7857da09c08b9ae2df7ce70dae4c95d551b9b7254323fb641ea061ce14881ebc5d9789b18e46bce3dedd99503bfda21ab6d7ed325dd3f9833eb5cc34474fa4248992b04e2e4621acc79af882e6c359895fb81422e6eae6cb4cdb1bc4b97dc17e47a0f72d9b0b9e232ebf810c6daeace0407f5846b4bce4a1ae340841c0374acc938371bf635697abc71ea05367699b13f969692cd4ce808ac7e7fe5b20c6ba22ac03d141c71fdf73d3a300e0fd847e5363634127933b90d43ec4b69b52b3dabf597ae89a71d4e7595d532c86697fa41003dfd5446b189b903fe9bf305ec32d8b394cc96b3fe752031df3ba561c291bc36a19f4e24b681d99375862f589b6f79c92b759afa458cec3125776f905a0c1030d185e5f5929a3dd6847cce686f55635939151c5f91d3f7a6b388f0c1f8a62d8f0d28ac95dcf957ff4796a5fd53df4dfc3fbc5560fb23cc9a17aed0fb8e46d9acd241549b272e9f68d92f77ab3fd701ef45b5e2a18cd4aa1b6e21085dfd4ba1c0b9a9638eda5c072f97e155ef75e0af19d69683c2234dbfdf8aeb3d2b8f78d8c397662588b29a4a34f142ea628c7077dadc520476af76ad6c6ebf79259dfc72151bc43057302208d9f094fd6bc481d723549b50dc0969e54e71ddbcec141bda71be0a287661aba0d0cb9bfe88087cb8f0c84d1e59c44b626c051bca4e65537e84ac173f5fafd25fec274cc7d3e6d6c5fb1e66012abd15b409a5b11d86b59058ee6f18a39020bb302a69754d1be81624bba1c508637b7d28ed29d861f369f59c4c9586b904fafd24e6e902d57e8b9fd497646936d7103bd9b8d757348dd795542da7a14cb239fde08e4af10bef59bcf0fefb401954cc6a14e08b0bc0692d90192cf5ea0f4ef7aa8b0c2cd3a10254264c6516b7bf5e52c0bdd89c5af1364f1dde7d099a3dbb781580bf23825dc50678788309aaa25fc6e6e1c1a1dc7defd717bb1e66041635861cb446a454925cf84101845f824398dcbdd3cf63eb531a7cfd5972ddbccc2d8a61dd7cb97ab3da752f7eade99a8f77664a70abbd488d4fd937da086c360fc084dbc5b3922759b26c6fd4dd1b1fae2572ebdf11fe78f519e99a2adbfa71369c36947cdb0383d1d63188decc1576310cca241043c86ef4456deb783bbb8e7ccb8f9686b362e7855afde65c7bd040b422152a2796b41f30c403cce54c71811c5ff54b6d7d0e5c296aa1c4a1c03be94577a9beb327583120a2a40e0ae9d5c63eb0150b4d768696d6ffb23d7b0fad3107043cc6eb2d24d172a2039006258efc06d4c75c3453ae7f68d90efb866d05e156427fea166e24fd7f9f3f13279e759ceb4c3336858e479f240a0615d0dbf2fcb27010c12e15ab42210d7e7ae64a4166289c6d5d3f0844eb64e284eba3f63cc3398132c160e867bbecb028f93eb39fecdec34fc79aeb50a9d82a48267d2b874b6086ce308b8a0c3bd2874817a21c76b763402818a64863d9bc1dadd6a4161bb46d71ef8af5ce81c3aec8b169a64d13b6a1e0a27a0c78001a3c27efbb992936ec7d8530016781b51ab4e77f5988db8eb30b126e8a738dac07fe13c2082ec20dd077f28450989a6ea701ba0734eb91b831b69ba3bdde7968269764a730739159f88558496c50d4f60dd495ff5bdae1f07e1b8c31a22753dd85a9160949d9145014bc0635db869f84b45b1a331bf22ad1f18e14cb57c413a6227e3495cb5af857bba7597845b12b80c29fe2dd6e41ae9cf26b53855bb6f917b19ad7f28e70805347de67dcaa6e5abdbdfc6ba85b30e4f7354170b927d103142cc5656e9f2574d8979601589807cac50fa2f1a0d20781f7d025e579d3217d0a312c2993ad548ccc887257d33a2449bc0acb3a89ee5ce1547855c500110b17ff7184858374e8249572abede1f9fe0914b7ae54745dcddad7cbba9957bffca6f609b90d8ad19a3d20563d0214327f35adac6579c206eb83a6821f79db8f707ca1a3e52c822dc78a56e641b1beb335992dcbd78990e3400a20900f812e9bb2298b27c340e84d88262def1b684d75a1add6248093cde7aa2ef24918667c6d3c10774f93de4d19dbcbd062b98322b84dbbd3cec36bd87f40a3d553c5d76ab923c8977ab9638a64299bc1cb1b8c169b740c635526d8f6387b155ca367edbc8ea305785542873fffc0db90b1d950f015abe469c5b3825280b4556c79698b6a0b128e333f8fff0dcd57f64e3b127c7a83eb57651ccf5a3b8e86c5401b7d1be69059f5eb899bb44ff52e90f23b5b03d42c8fb57f85fe8fad24d802053ad1ba41af71a45eec3e3b25c7c6321bc03c2c94088c4e836ed4652c91744f0488755be01d352c3121339b78ebff0fe035e7cd862c45169e77791b0f18defbe3e354694d557840d48726865817522cd2642f256dd77256e0f2a12e22d4190ed6b73c3fbc69c630a3cb90c7d3b1d9c1990113a29cd80c5e8131a19015aa1ae0f82be7316309ecd4273dbcbd20eb36fa16613b344d23afe0a0ff66c4b5b4f0c2a1633682ad68ef87adf9f2caf4edb57008012b6b7b801ab06bb6efe50e3a059398fdfd90262ff073201c36d97e2f3cc63fbc4e0bb5b600f36596b3f117f1a97cd0433932994f8d206d93eb05ad3a29bafc8da6564c957942a5e022f58a3f2c925dae715a066043840dd4ccce35f7a57019b6637f2dff34015801790adbb362b196492dc1cba042625ee29f3bb025ffc3e4853e25bd84c34aae44dc0e187cb0cb90161aaacd855757caf564a3e50be354951fca6980bf09f568d0e9c778f50e1a7e6c4d4a8ba65e1b3295f0a3d263b0d64261e6d7bdc15f85826d05a59a91c5a786228334fac20209cdf78d11191ef9a1aeaf30147f3bfb3a58924623f30c0fe34c5104998d765146b1f055c90412941503f182a6409b972e048c48bc669720b6b728729f7303f6de6105a7528a1a70996789f79c3dda0c3fc94157e49ff71c0caa78c02c06fe8a1ce1a24e2b24e1a30c38daef7b5948110087029d8f2ab8cc0e0b4f2c69342a643316ac45c7f6cc00ecaa325e71bb5f7e82068bf7b0a3f93c1b1906d35d375842c4db3329c73e26f1d094160a3e800ad349841b144cb851c443bebe786a3cbdc2fba64d666f5814143c42bfeca671d273053735b14834605e61b417e812ca3ea7ba3355dcf51c4a87fa7504b9d91a592f73fcb44111a74bb73e32240c2555d45a42e6f0ab6675303ebcfe4d9d3d1d86a66ec2fe52bc664f94a093d4c7a808987d68b173cda1041c610b6d0f4386ccda6cef59a11e751b88103f7d3a513ab18f74c95994c25d28d299081169f7334ac3d18a309ae239b338a00bfd5cc934c97e7a1c3ef8bb811f338b4f070e55cabdf17eabbd4fc80708f3c0ea5d296f483ad0c90193146883efb0a77e57cabe365841fb3aedbc66136aa37f8a176424731bc6cddf6ab79e55b4a386bb5a3c1e095f853ad8dc9bcc45a56b1b7d41e251f0d3f6266ff26462d4169cf78ddcfe41a42abf6e9842e8eaf5fe5c39dd0196995eeb0ab724f6c9981f2873bfff06f1859ba93abaa87a38b4055f478227507c0e355d5f08d3d32ec91e4e48805d4454772f287987ef452e9432222546051146775860ea465b45d3891439cfe5bedf7b6208d4c2adecc14428bce48fb9450136390c6ddb2b0d8db59c8dcd8a87e480e70bf34d536c7a319ee54077bcb2a409164de1419f1e058bb8faa8bb56927f6661725ad90f6bbe8f66fba51b70ac75a27e4083b54e8ab3038d907f24b22ebf20e22984f45afef05714a726ceffc0d219802e053f92be7fbd52cb1c4c10a9d96b2596ca12b51832a693d78d963e6bd2be3cc18dea4f13bfacba7eda1a492e7ecc4d39e76114a57711a14ee7090565a11653a0038ebc150fa77b92cb31344104b8bb1aa464689f2029e9747e2d90f5254b1307e85c6620edd9860b371f870f3d0602118f4e790e593644844c6cecfa52a99e555b3cd52ae0251d2aea36b18909da81f76e7ba2c56bcba281d575b62a4172c49bca9e11ac01296ed5a052814e45676513209734432e26ed76edce4380a5b5632949ad48ec101997009a771bf28b8cf3dd0887d26d742b60f6577dba6bf76532d4e9454464c2e468cf93e7901919cfa105d6931f517981fb92ce126b93b4ccfeb470aa8f910f4b85e9e75a63ff18e55b0ad9bcd2ab57261908670822b9901390d457132ee7313592593a3b93a4df6444d50df5e9d0e853613113ad692b3f06eed0aac36e6682debdd7dbe3737d1ce31b4e96f33d93a8e10abab0354c527e013a87dba87b9e527a82c3ff03f28c16e68c670aa4372f08968c63407ce87c1bcd0b78ba19c756ddeccd913124b91193f158dcb90cde55579345ccf0208df792b7b4e3cd5f7d077c39ab150f140cc75e580c7bdf9e076a4586bef628750ff33d2719ed4bf77bb9ccb9066edd79806ef9a340ce69fffcae0201352810801a6244c90424e9928cb64cbcdbd42293a20b615050b473c733e68024356424c12da7068cae2a84f068240eadc3c16b308378e70d54955942da210324efb805b715b1b46b87048a66f55368ef32608973ab386697c970b389d5e20b677593006ba2f2e212b8a5496a136fe6eb8df955ea5c3a2bf342a29fb38ce3b5b86d0f9b35e32de0a17e7df9e8793c36244342bb8c3c9cbb86461744d242f3c561e391fed905250f0f9446239d6cff9645f8903dcfb2fbebb013f275c10905e38ff4aaa529da3883820c05e5ad6c7731ebfe382245b06081380821d2ed621358e245f3caf6d4005c8128e24f34dabe89954d20f2970c1909448a8fb7c119564200666ceb50119ce844e8d4143c82af97fa3e7d66d9b33a8493aab94002673983092b71c3e9e8de3827e49f490c47ce2bd7e42130d23417300ae0ce7697b71f13bcdf904a7d92d2f611fbfbd9c347c77d0b38bd8354f17a14fc07fba69f3b6e7a96a1c86cc1c12f585a33cef0c240f3007349e3e5280f1bcc74a14a5ddc740c2ef418917b6ee556e8a1e72c8b16c5dcabf90762e2a466e0a9082c31f90d0a54c0fc88a68061ba3e214b50c4d73d52ab8bb9c7e48dc2ee39ff50dd03775f2cb04d57b48a765954899e2253b23c89380ce06d8ed737e8c24472fd45ec110ec0d15c673fd506cb1840d4f102f62bedecca2b514211faa5e9fbd6381aa3e4cba23162bec5f352818e7f7937ec955fc5cf38e9ef8c9b41d7f0a62539a7c4c74cff7c616bcc658f07881799d933cbd1395ffc9010395400990a6e18d2f6620b170724cbc9b8b31f5370a043ed845f7c164a17cff60852c617c27438108065201767d0ae61c181e5565edc19a082a2e9a484736d8c3d69f838e19c71ef8bd5b059735f6966fdf93ae9fd75be76213340e5f00927ea034739e00a6ec6c05f8a9f0d8b885804eb1b6203fa8ac2011f82349145c2cfa90e93b7be0099c2dced3f9f20154e3d8f7622d0849f3a36629a0a0bf9574c41faaa543fda9f1fb423b6f29c4d68187f3f7ebca9c7a41e0cd0a843845ffccf87bd493ef0712c732cf944270f71023aa8f9851d81a743b753ee1aa358b70ea7b182b035a10fad7a9f634714701c82ed494f8a8db0a27947e36bedb223fa475b23aaff6c0f0947d0d663b4f396c8dc0c5c26748fd96d8ec9ece8ad9875bf12d16196cb708f20f6b1348167cbd8f1a0c7c2ccb8ed1eb8389e471c8c32869f915aca64d10af0e7c5c6f2cdf6d44160c2bd62d540d1f6ea0d9c5281c5033e000da394fd16b16588b1fccbd862ee30836579638ab01ded76002459fc087da4b86481eedd10b8232c1bd99b86b428ae21f0bc43856f2dfacaea61f5db3ef890636f6850aceff4aad9c94cc47d32e3d83b78dcad67fba76cf5b742a298282b03a741eb66740d4351e0f2c6b3fd0077de0a711408f7196c166e26ff504cc4d0f01200e19ecd5b45dd71197c7c6e93cd937db8ded776141118e55d0897dde6f71348288adb92294f6e0f42d9f1715fbac19e049b6236e68b8fa34cca26510541d60e46e1c8d81efcf6729d780b433c0d34dfbd18dbd839f8a5d052956c9db6b490a48d07db70817fac87960d22242bcd800c7dffe0ec8ee14711793da31a7f04f8d81196d60676006ab917822d7c47c52a55afd6deacf4f03de7f1ca7067f4be51401e96a421b6e90964609a12047ecbd8a9e5c63fb4d6e7e0cd78c803a397d18d661ed293afea1083e788d0deb255c00fab766002dbb09de7e3e4c15a57b003665853758a6325a1e09be7c5e944a85f81138d0d6745a91a96ba2d18d2d5b96e71e30d7a3dfc517c7bf481c430283ca8ae393f843999710f65f59716921e697bad6fb50b9c2207394591c9abff02ac87a15cfa7a68b3011a4f71678935162851357c19767aa9793f6818e21d390a313995222be7504c38064c217d48bda8487942af8d6eeb3108bf850f3122139f2ddef072841f1aab25be6e5628904e63217b9218ee49ee6c93c22aeff1864c19a9d1909f99f30c45bdf69e7525610750ce4b182d1fb5babbb6f1bfec5b6516417b71806e512fb8f8f6b6eca5130c1a72c72696ae9eebd8dbbbf5994d9f6097cb184448562a5573c6cc5cd41954764a5cb9f38a93ecc5910a3084e91ecd2421ceeb44baf4dde88c06d1394b5df3de16b3225158f0f99c3ed88ec42aca1f31839ddc0030529bd8d5613b717431388aa0ee4eb13db725bbe37bd8b09a815c0f4f42b19569f2614d14e0024e740807164f4aadf375799bc5ca400e7d2b92e091030bf88ca5f147f9e727327808a48490f85909b5237a08db9dc9f9877597947aa945255c8f98ca20dd1273495a5799500dc44763e458b9fdea57781eb6f59a108f0f91b0e869cdec0c2a2bcb7152eaf0fe53a83e44d06171a0ecc2d20a6d81465f4a1be837de961ae6692eabcb946344c9227027bb46cf297628a2bfb8721369f24d00b4ae956d5718538da0e9cc02c9d9a138ae23cc52d1871c816fde24bf75c3c143621aa7fc1a9838ed256276c3c0dc04946cdb454faaa227355f55a85a99966828e32c5a5c1fcc9837daf6b36206573764a5ba0014595936fe26382e846587695c1b986579032578c83b356b68ecc7cf5a74f52603b717e25e12e0512c7326ab521c423aa988b1a99b1b01b4b219549819fabb3d2339679d855dd190c07aa4802ea6eaf0e4c9fd4115f627fea28161c8a6c54b55f4201ae15396bb84b8a4b64c9720fd61513726da961b5f63547861f4e93835b6774225cb7a19a804cb77ed160471b90e64622c1dc4e7a79398596922f8b1d28368e07c1735db1c763d52473a50ceece9ef631f36f33f29ae6d57d399a0041e1c1ce1681a003966e93bec9c0fb4559657caac2394652db4b99821c59901230be9b8e23cbb31d78cc6b37acc8ffa05b6efe2b05f171ad6affe210206391bd85e9c0beb592e0441bbdecdf1d0538a9a8c61c52d1aa664342ecc03d00da4b52140194f23c2a02288c17b7b721a91c18a0e4c18111d13052d94c38c2b9f2d1565ee01a6fcba287e3f8a9e0e40ef125562d0a136a4add7e51a2df8e07e5564cbfd88bec9b1bd2e98d5a66c8877fd321f844f0a0ce09c028bbe8db07ab0aba0e3ca566497ea17827f31ba27bd6f8a4a652fc2891ae40a6b7c47ff470650e104a9f47dae581eeac3bcc1349f164d52f49f1825b44080dfd66c6bc8bac0874ec8d92a34997f52805ab24c8eb8a62783839df33b6cd68d243cafc75a4a1c7462f0a5157a26b02baa0d17ee999a05cf9e36a58e7902c64ff37b84d676cf58004169bd4127d67e6c57e3135ed81d4bc8b44d8c32cec80e733269e2a7dafa5d712b92f2f2b05442d69137201f683f5a57e86c8ad336ca6b50163f7386071c47ed85f696c7baea5eab054eb049e9237d255a85e57450a681daf38eba8b20cabc6537cb33dd53d7c3f3ae7d4dfe5d265ef930a6619bacc34648f7ed51084713382c077e2fdf940f3c76f54a1261de2064c0aae153534687cabced9355d3fc07cd83307dfa70e1b12cbebaa2769d6e63239e001d502326c43f8c7d6a4f505b970ececa3b194c8957466c8615517e765459eece699d18d5f24d7b7d7121e68445eb8e79a01988a05e1b25a3dba53b9dfe1febbf50dc930d23e7694c6f090979d0270424fc8d32bc1edf80efb01e85e12c33932444443e48fc5631ba7a8d8b5a102b74c7dcd5b4295ea6d1ee16fbb5193bd07639cfc79ebdf99cdb5b716e4412a957224be8facf6625d92bfc9bceeedd251aef772cdf5bbb185205ec743b072d09004a55d4aa4c5d69c2ccd6a0cf6ebcce62c920cc1e13167441e475b19e6ceef5b99dd977c1cfa0a30ccff73f454fc31a905deaf72b0f253c21e5c2e279f289a8e36f46306cb487c3db1ffc03cba714563d8e5cfb329d9125a53edb2b8768b35e0609a2967bd330b95427a9e3ac5b01db4a8d2f4b13314b62d297e5099846bf6fa8018ac0f426921a2aee666c3a95720f60f22ea820930137cf4edf352dcbb66637dafbc3fe3fa156fe4d35a2970089e3516bcf5c9443507f8a28dffaedb4362d960b2d48f649","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
