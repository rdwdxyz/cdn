<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c12f5db1ebe9e8a88ce41dc1e0c03ef2f05fea77bf95d020da98e13827ed56dcfe132cebabba01902a06efcc6923ac9461446a4d8472b89701d3a817bb9cce3932a896244f71acf6ed454987920b6af9d7f7390ca3f1488f6afc039de71d0d272101836939d0166f86af721abe54db3dd365cc493bcf7b1d51dabf339b7f011704b37f6266d2ef83e69e6f869a7007f5eb7163aa753d13ac0b525c6286a16a6a34e4f7db5bc5744279ba80278002686ce06d85011cf1ec61a1e143fdde2329d7f52370df619cbb4f4dcb0eb1a7bbce6c8859f69dfd85069e2fcf368b90f9df3d227952e6e41eefd1a37e5db43e2fc64ff1e2152d74997f02b18e9193ab4e74684673af3aefb42d98b92549153136be01c177f013a3b0bdefa36c991f9b54dddde9395b059b48d4f7a1d70ff4efb64b9c2a6613b5bc6b683e15253d4d291245d74264d24c2de47781dbbc1d68b443cacc930aca3255d54e9513afa4df3dce16de33c60e1f006b4b89798d4e938ac140e525d0c0ce3f0490158cfa86994afd9d9923fab294635044672d050ea8af93cb77980c467839e8a6a9a23075825089761e36b2bbc3aa86d5e56fa648baefc1561565307f625081bd47b826c241acdc24b5251389ef4222355dbc2fb2e4dd850a566d0507755e6e44d08e92f0320aed54d40174093e4d3c6fd7e088a1a69b0eae18e3be82a59b7cb2ecc7e682e6372465ebe4c0f8e9a85dff369b01df5d578c8beb4058b698812acc9f821837c9066aa0964e92f80f2b25a20acba0a4fcd95c1274292da4033b3d3a9f2ee1fbdb515d5d269dc9c01fbc4d0e77c497832afa355b704d363ff1fbf94296e3dc59ccddea385c8d2b15b9d43ef32042d54d08c0e6c3aebe16e2395dd89748c440c1d4de6e3615efc105450566ddf97a75b25394be045caffa8d6df8e8181b88a08a99d40203abf703c213305b0b0190076e5f4e776a4956fce7332561d531edf9b6c143d337678dc50e81baf8fc9d3a3b854062cccda693a04a366a0d71d10679d10af92f5c8e8676e37580a449c713d2f426c2f92172ca10b81c912ce9afb2d6e58d58f56817ce7a4194c0eb8fa995cc96ef56bf0bef4211aa6bb61d755e22581f9f07deba375d26661202cdad3a9e9feef5f48954fb966e6cbfd97a14a6f253368b72d0505cd3947b1ea455f4104075be05c75163a4d6dda1708e699c30bd1c33f908756835429b0deb384c378a0b23762c8867aac2e7783f20862b4b86217883eeca48d5843ed7a62e2969ab6cef443e66ad16582a7ebf48487e53cb06e1b047562dd96f0dcdc64ad663bda89f42c1225ac08881dd867a4d468d5127c6b2200084d34ec26fc0a544268be01514775edcee749b02dcf26b68ca51a4886c38b6553eec50e944e6e269d24956f748072903fbc5de3b052d71cd28eeec7156a4a805930cc2d6b30a68ab08a90e85afc125359b3c2579de03ded393d5f9e2afa05cf4cbb43425859dea8ccb7037fd4fa57acb06b36dec38a283c6f983ed24bd568fe569f3be4e68ce719765923d5cb8039e11285cfc0f2bb8aaf60cc6a4e6f0d5714433c68577b6994382faccf1ae3a8d5e5ff9ac4f5cd99235b65add519fb1dd4239678f141ce66ac8f3c2e728021ebbfe519fbc16207102b62d2f188776f8be66164f0a624f3cf3c6b01fcb5519f510391e995bdda7145daf515d9d3863d219a27459cb2096a3845f8ff47c59ba7aa22f6dcc60cc2fcd7b9f278c62dc5ab2e223666d085a8f3a3886a7d18c356b86b96ecee63120cd63258e64fa41fcba925a475cf1b407374180acc53242fee8c54d472903d050e782df70dbb84fdda6bee0f476934f1f2eb5f5a4d9bea22ca6ea3b72566f5d2cce19367cbc3a042ccd0d3e99439f24c973d8da3c967e5694e4479af092f93c50ef6688d69fd3800e186dd40579ff60a1c1dc1936d7eaf4a78dad449fdbbe4b65a01906e8c97f00f2feab96a7ddb024efc94b008e70d5195a560f8e016be013d5a596f77095bb110a1a23ad3c5e0c5cc05f6d3b5e8b7bcf48ce1096c478259edb49b938204516b02186413bed5d05ae2856542e54cf4dfa3ab82e977d96287735ab8c2eddac99f4385dcf64ab1e9933ed4e1a75ca1c8f54fcfcb45558b50adc29a3b101dbc327bd148fb9612b4cf8f44094850c8b48852f105ed1f42f14a743cc4e084dc9d4504255e371442fde2db19f21f615cbd9e8ef8e2ccd2a35129221dcfdfc5633c017d81dd952524ed1067d1b410a15515248ff2d977023064232e366659ec3dc843f9b5f8bba7cf832e4b7619b33651a24744b52bc0c75f10e5349f82a476593d07d7d4ab593e968e1e2f2a98eefd5a3fc7b2a06598fc82f20da192e5c5182a71c5d886d71657e4d1a7efc995dc98bc7b683b851d1632ce4a4b18b05829ac25f9cb12586745048b5d3ad7cae920168275941a9eef4f40ec57328d61d2ec623137b098f3676f8a1581a4690584316f0decc860685ff270743f36e532c1cc74ce9921656de57d0054e7e111446a43d3408c3d38efde47d584862e2c688e66ef3c18b07d6724cb8654066d316911f7dc72444305e55108b268c9ba864ce15ce3237d9b9b4d62d30c57fe0f1aa142041b59740be0b7eac4fbcae500726798fd849d90482d9a2140edefd12511608d989afedb8672e209bcdfc4ab10bbf90adce3e78f5c279716dc009cfd36d95d39eae23ed1ab019618f6c27fe678e1de296f37568c6f77ebf8eef0581668e7034f5ebb330d860497731319c8340315b8c0528e372df266cf20f869bdee9c43abe80b4d8350612689d437e42fa052fdac1f30dd6dc232f03f0ecdacaac3e94dd2086bdeca4c6ca6b0ed96c088b4bccc868c9c0a1a83b5d5cfecddff4930f7a7b6475de307fcd88bbd58becc6e71f311bac2e88b4ec6d659ebd7505984b4ab1ffa313b3ef955835aca43daf118f0a79e8e5936d03e71becb445bdd5ec1ad831f945c291be87ec1b63a89b20b73c37604e5bb0779c6318f02aa664cc9915a650d21f9fae60291b628d97a53614a0027846b02470ddbda24ea39f7941af6a2c9830a250ad482767f633f9d36fb85b409016ced6dca8b4ea43f7831d5acf93db5292bdb68f5ec64d8528cd7eb05cbac4a01c2479ef7c80f77198cbd74541c4e991dac45c050389d495df7d086f031137ca2fccbf78320bfeacb956bfb5604ab340d61cee87b4652bc93ac6908983bd961168dc49ea3af5c9902bc8c64c96443216c06d7d63b745242472b6d8c1348750a162f62d05abbe3ed277e33f13ce9cf4153f02f282227fb234f4d51527bc0ecb394be4cf7540e712c7683939bf2770e6d3edf2691e0e7b2e0c45dd91a13b88c741dffcef0cd808c470b4246d52c333c6b4e624553f876eb8b1db0154fcf724f106ad8e76f4230000ac8e371d07993ad05e0de92f1afdedc5905100c4ff5a35aabc0954c2b8716878835bf7063b9e17aa1bcc7fbea301382c7e8ad69954ae01c82d4d094b5081737f740b705bca4a720950064df25789ce7d7f2b808ba2774e033ab6f3adc4f28fa4422d4769c039efda08ff32b254bce4bf420453a2a2db3ba702eed45f59f664e293c837dc7322fa8fd0795cad25b2bacdb7a20f0b99e74949d2a0ce02cd4b287aa70ae643638cb546b06d794588d171bd4bc3a72b0776cffae3e5a24c9b31215de52939071e1c3064f350ccdc4ddeca91ea860d5ce78ec56781122fa58434ca2c710adbc1145667399df463ad668cefdeda8d98127dcf7b3e073198bee681ce2ea0d1c777c12f98a4794ba27cd0ad127259559f298fff011b353e1e5f2a6df5900bb805b66223bfb970db259cb6fb4734ddcea70123ea94de2d98651a9055281467900cb55d4c8cd94f205922e060adf4924b4dbf1e6724e2491fa553f42be4b6c26f8f3d3a64b6b9a6c8aaec9d4fe7b765c283962d912164abec12453726ed511d8f417d77adb55638d4cf365190329a99f3d9d061395091c2452c995463dc05af210b330b29c7d231d0e5a451248d0a30e8a524aa431ac5ab4cb8f4ef40f16e1eaa5137dbd7fa605b7c1d81759028a347111df969ef05a5155216f37085682933c08f13dcc8e3920c53f95b76eeb788278e59510b0c27fe9a35dee8fd37ea2ef9e9191a6de8275cb8b7971bd888f567ea1f91dcc5d6414093daa25ebc398ff83d2eccc0eca445bf57d2460b082c37db313eb0d10b15fc2a88eb8a3a53d215ea928ebc96984935dacae482677f6e9d11320b848789edc0677080b2872852bc14fc82ee4519e25812fba2c92d8a31220ce9cc23ecf2f8271f36d4dd0bde9ccf82ae156db1b05124098680f1715c20a5118efcdce12b7b5fe81e23060a28e87a48053d1190594e74754d159530f691fa6b6e07a23089bfb59b15e72a8c7a810531707e52e248471e60f065bb7e3aae766a502f22bf1cc3c25cbced50dc9dd6c3b5f84b2a55657d2b2a967ac2f8bb83b516f19c9882235995107075fc19691d5d6ba0e44838487486788e33aa017fef0ed12373e101fa9a21212fc3fa8389e88f601cf3e596690c2eccee68bd02e049f2bbb5e530f80a3a3a51836637578885ac0672a0f8b8f439c406136606da8cea90507031b2902efbef5d424a82caa13dd12d6713018ec6348a6f6afc9008b6f5cb94fbec1a3115597f9c6ef0efdf604b41b3f905f739f34913d65d5937b0c3f66d3cf603f9f0a500ac8af13f434f5bef860a1f6ec896b8dc120b8634b48ee296fccdca7d75e4987ad8b2b5fbf80b54f6f356f3487ccf9fba88592dd33e4847f2ba9056bb7d9f4aaf8b16187c3d44ab2df7c819f71292b03a94866a30cacceb12e981ab35bd933576407725fb89b031f04a5026701671e591d98ff4fc281004cb3ba111e5e3d73d666e168aacadb3bc03c6a31e444c154ad770f15f53aa3ac29466ec2d17178fb2a787a9cc2177f5f007ce7efa185d3d9aee21e6325a9a754719b0420c920cb744b277eb41a7c23682232909089bba1f53ba78648327701221ead1be54d66915e8fc7128106ec8c6082fecb30b775a5020d9a7e17d27a143dd296502473f2aa54f7630f4bb35395c8ba8b5685c37367f73daeffcd9a77264b3d063d072d16b1e79445548c18566c4cbcce3c14f9974f5d13a37a495d671bb554bd22533cfbd0da32d285c0ab37300cc8836ee399392d75434436fbea1dc01849af7f5c57680b30eebd8c7cb5322d2c7e1a98ee74719a522892d84254189276c7518fa5d169a1fda641fb2f706ca9f5ae7d4a2bbc49ce51a807c1673b432ff9c6c65ee33502cc11fdc49435eda01cfd92131876704d4bb4fc9f15858296977bf8f7e2331b073ebcb449310530c9311058788e20e3a64cb6e0e130c46375f09abb0577962d305dfe4d14c60307a77f8a6dbe0133cb09a7aa80afdd511fa8a7e86bf2da67c7e951931ba65946c86e1715e850254292f244c4f3264a4155b0e3090e9b2bcddac9929e07eee1307c853dd0e0625373e221cab1fa6424728bacdc1c125f23d8d4f9dc5719f64b53a91a554df6f253799e7a178ba292ec78cefc70d8230f097e027ad7974628b066ed1852223a1659a6c0b204ba5f9b847d329efa58c6d055b01042b2bae60affc0b01140c76cde701698e6d7227e31dc7bf57548bdfd3d536617e775046e9bce3996fe104c11370a680411347e304eb0e45ed8ed2a6d0ea7e163acced7bd398e2d77772cec2887eeab064903bec79c48b1940e91c6a88f49dcfc45ba94bd5595afeefaff3979a3fe62923466922a8e9e9d237d17cbd4bcf51122bf3e5c289cd989f53cff96fc9b7573e16a00f7eb6bd6b970a94b43b35a6d2c03c99e7d841b79ed25f5cedda8b8409dc313d8784168c4fb62797a272efd4c964467bfc4587a7fb67acac15c708cd872cb3974ef96d52a04f46bdb65bc76ad5da7a103d4bfef8ccaf84dab506a94168a9d06977c827b477ca7c3ef1ff7e7d49881ad9961207660ee74764fac7de9e85280d1b424b144e68f35a67aa06815b734604e83de3226a081d543274876ee5e0f75c8addc9f7bf08be0b1f6f34998b04eb20e788496f8cdbefa9fc8ddf13733bc2433480d39cc73ad0ada67be10201207bccae090debe1878f21edeaeca4f90aaf2569a04dbb25cea27864f6562342b04f4e02e791ee8a43a865b37a2d9a09cf4da5d3dcc19d55ef42993971298c39122bf912bba0c730948d2c44af87828b41096dbbd5036584b61608349b2ff8eb6ef41374da51fd065ac5e7c3d8b68c72928d7a511e17fdde964478bc8abf2a8dacf0866c436fa85d4da2764388721bde886cf319477746c9a5289cfe9b959663d45797960c488dcb426a54fbfe606c1b55dff1490257c156e22daa1f23ebabedec2948c3a29093a2f9cb0ec447787c6ab799641eb875257ea39420aef86dc7a2dc5efc9c196939e394b83bab515b78a4dd378855ecc925185c8cbb9f827969cf4395a6b43164f0ce30f072671da36e5bcd3673a749847d384359b74fb90001e20fe63dddbe26788242bdc1e0fd8699727a73fec652b771ed739675151f2bef8ae6b0f637390685327b0582b505e37c8a5c0eeea9975794ab6cb68fb4e0da4bc63155f64e15c901604cfebaca793b48106700945433c97e5f0bc1c708fc739afe461d463dc8ca8759c19a7ca2cb9341cd4e4c3ef397f786347cee292e0f45e535bfcdd8cf215be13f70438aaabaed50d54f9589c8ea05762e13ebb46a3822eec93395cfc7411e7f00d8ed74960ee19242ccd9a63d545a3eac7297a0b0b5e4caa843989a528cdd0757af5da21ca640a6ea0c69409a3015b8fecb29b8447f92bee73e970a90455fd950be027418e6e91dfe6e974086b2aae4df7a4e48228800f6b880a0250938a8d74ee7abf3fd743f116bb450e2ac4d41912658ecd0be82ccb130524fc83057d6d83dc1d5065cb975e38cedfdae54b78d6a618da2f8f1cc5014468809650d89d4dd709b8c0742982dba9a0581019984ec488df776347872653f98994f29ee647605a9adc2ec7909de0975776558c8d8cc97576c4a059daf2d4baa878a642a108bee803f29ff5095d37e189b6c2726b4bc7c868d0426ee4171817f5de1b4e613fddcb403b0edd7d3277277006088d11cd201fc3dbc1924871831897facf5c185fdaf22cb4ef52c3f0184f22e8bc96d21bdd0d3a470b997ca8e3cd450756132a7544768cb2cc94c4efa936c535729ca2447b300e951d81444ac9dc43494dce2ffb9133ddc636e71d97caf19fe8301f37a2a4f46be83532eb5a671886a8fc3a972aa50bdef159deb9893f0826c86aa8fd6b873b309173007a1f14510203fc4fa527785f84365fd35fbd8c0e336a786a5fa97d07050a093a83bd5f0e68ed1af2beebf9c9a1e7357a6ee63b8de965d4f97ecced060c47dfa46dd6be68952ab8f33a815e68064dda56e1cbaecba51af922e1508ee5c9ef1f11ea9bf47928fb67a6cbccf2a050132335ca14bf13855d56043f6106f6a38859879d6f610912d78c387e7ebf9ae17eb3c01ef39152201c96845ea0761170054609fee3aec628723872d6f5563951a334075f94833ccc131780deb05bd139e64078eb463c2d8a1f792bf02ecfa7504d57a72860a7c4545cd8a5478647efd1a13a2cdd50838ece717c5a9009629ba16e9ab34f172aa5939b9faa2a0ad5ce360a05fa728891af2f9b7e4e235420d4ca5ef11d2a06c0128d70104a9183ef3ab0ab5d46022f0314770becd7a8b14c1dac5410c915ed603adc2bb64d35cd647e6796c9b8f6ef3a479e00c6559fc869ce7ae7644ff92e1ddcdef602edfddb88b7de7074a2b6bcc0a71c9af8aefaa2eb4ef167055a421fff4299a9b5ace385e07a89314c334c795fc9fa77afac017c7a8a98c90e606ed8319165d199187231fc0778d65dc13470e1d263aa6cd0c7450ae2a95cf7fb527e0df5b540db1407ed188382ff38be6a159b1fbd214106d0924a916f94cf2c7291134da602f627c54e3363b7c91fb79be5baa52f1035886279d3a3fdaaff865b22ed8286387c5ac0c3735aff42a2b94749b14ea670a78ce0694990f51401522da752f5f458571f66bd910f0d487e18dcf1671615fe5ac506b6236e06ffd86b1108479c6b1165d804db2699816bbedb64f0cbeeee0f4623a7e475388833b17f4540dd8cc14083bf537e15e122a63c51db7551a0ad3c241d79ab17e24e1d85b43bc2e86c37170b65620a5d5b2d85c125f2726e70edecf8e3277c698aa77643f9345d7f6e68b7a27f1301de5a466d6fa45f12c4b9978da08fdba6fe74eadd52b7a124ae987a3e3d93d58bf2d904c5a63afcc12963573bcabff4d9fc84b8d6093d399eb918e6c7a7c7d535f1b1ededab664c745112831e86afc78b57c259fbb5a84d02efada94d3f8b19d4af86e53c90988ec132c78359373fd1036526379f7afa74c5a0a6c366ca32982264cb7f8f661550c9d9e93f5c2cc0daf1450038183532db5c6aa61ccd74f25b807121e0b91ce628710e57d2bd1e61ecbe6f848b0203431257b68573295b1cb2be528908686f37275a7f56b56345990c649068f74c94c06ad8385a9878d01712f304b87981f2647171a943502e60117ada1c67bad2f523e737f17fa2b4c06051137a0dd2c89093ed1d4b0f066c21c8ffb7fcdf553c0a1a9cf704fcaf2eb2623fcbf30ea885691c797f15f1458b2c07c88197301a101c08319b380cf2d1b08bf2b105394fca477abd0c069b1f8b36f11718e4c5ff298a1ab5ec0f15901ad97208ea0ea97ab0148e079c2f4a09cfdaa45823ebb33c398f5b65a2d1cae09712d9789df1faa6e218be52a3493faf91d6ff5a77c5737788a1dbc20502761560efce23006cc08384794bda25352c389542a2b664d7d1189c599914d5004605a48ba19e3fe7a9038cb798aacecc2e5229bc86210aa2a6e74668ccd7eac27a6af20186a05f7d6eee36b5654702793bde4a655b0e7b4f5674fe502daae26dcb3f53576d74b4229ed143df76455dde1e7278dba47e54a43f8ce8488f83b2881ea3fd869f99d412c8676f6612d34911d4ac588e1bb467239f5efe5ec9515e2b99de6d672729eebc392daf5238ab46f92317a50b2f9863ed334e4b98087d77d90b527c851b16a63aeeac7d16e6d551e807b019fc66561c847715ee68ad46f7ff758b4ab0eb74898bf2fc1e5c97b9ac5847597050205ea7ff74e2b80f6a4177eab199e82431ff95deeb16fb82dbe650feac0275210caf5246e9d2ea738e65e2bc61895f2c5b8ffc405285f104cc469774d47eead7884a379a82c7758aac063685374d739c798d945e3451e395f61a70fe8eb22174bc9d1a5b004df85b436263d41189754114f6e8cdb17408137e0d104174c02d1345a4f31709d4c59e015f0843ef61cc2152eb33250f3148b4990c183be81196fb685a1f071929ce0f4a6f63fc49a6af58ef5a48b1162d4e84da8ad287c46675b2c1e548b42b519ce8eae893e205813d184d88d337f37a9e21d73a623495b2f9f3d29d12e07e182810d3e451f40535a3b35b96a83e5b8c4732062f8a2e2a395b47514a2b57fbecf0151a8dab810b118b3c8f32117f74e24f40ad65603e9c6a0af4a98071815896c433ad246da9dcb59e107a9358b726013df9dc02dc6d82660a4b8cb6124b167ee1158939440d4594fd0b897f7d9f7f5907ab3a3117d4b86c6b47b8696875f5beb82faa2ceedab0d8b88d1ef643d4bee1edf7e96eee7ca93ecff5b2e669ff70fae4a414f2b61f0c88e45c2ca8e9b19cbc54c07c40bd9bc521f0e37fb52c6fbe40e43708efc89f7b4ebbeb5bc7cb9ab224b6997cf53a9dda62d3688f237624700b31a9884bf54c85d7bd5c1743a3ae69aedc562f9b8cad81b4f46f77c2fd008b029625d22bc165a1bf0e2a7f05ddb1d137a4934585b7c4a5c7350c4f16be76eaca971899276b121e0fa0519f7ebeaa35782d62154457de6fc625fa3812ef54e7175ef74047ca9677655a4fb4b4fcb86feca8b83ae67239142915c02ed74a74c5ba8f287bddee062588b7a0b008e550911d37aa3ca542b858352b701f9bff4b8034630a654d08c7fbd98bc93b883c211c1cf941c2d2d2ac590c9d002d69baa243b4b43f25ae51ffcb9a545c555b9a0d105b3aeae58bc742bb6623419efe8cac8ed5408b49a5e65527f52a7218a7150897902112b7c9cb1d0a42e81202acb5b830b70196f482e39a55e6fdcf2c088f1a8bb9adedb656e25ec73f555023e0555a839a465895803bae3dcdcad46601c513c1861923fae2f2385e94e82592e2c4a83bb309d229f3b0620530db3b684e192e1daecf25ddba3e1060865bb99e17e905f04f300e80135454723cd99a83cebad4a6ac652d5b526c2025cebb4845db64d096c362cc1acfb570b7cbc57f49f60bcdb1ec2a1ff338df80eab53ed6120f26b5952bd539e7eb4c76f4c4fd99cb2fdcd7e65d86594122ae7de638c198b31f2060283a47cf88b8b5074bcea29c190cb032dd17e6499bf9c862b30fcd1522f414d9a532fbe40a190b16c31cec92cc5acfa27e24942cef62731eba3f56320ae93d8fed085e15adc075d30db228c0dc69bddb76a829d5de96ed60905922355bca2b72d1b694ac54847fabc89d8099d461575b308a7cafd09c12a48fe20364322465cff8ed78bf54fa9864f7b9d51eac26268cbf7cd9c771f22a247b6f1d430c13c4c15ab788b863c3adaccfc6a8f1ece74b718708df87f5f57e1466761207808805f9a22968c73d2c571bbd1d2f464c5e9aa0159f6afe399f8efbf4e7005e52b4c24e9c8cf4c57fe5740774df431355fb22d1ee33082bf50727981626fbc05512b0cf2259a89a0e27be1c219d5d6121ef04a3ae8900d39badb640b4f7df2d1f912c5b028e6ec110b419c06e5678320090db06d26be693d92c4af221f69815536e2554a07a98961f11c73a2a703cbdf4e327f5eb79e536ce47042b306ce918812e7ecce8c4c7d6870cb3057312330302840cc01d8787b80c9e31177e25ddb3e0a647e977446dafc1d471dfd564db696ff0a2aef9bcbb487056f496d415984f4d4935f98f689c7b552fd6b7f0d0605d6be1ff4cd1f27409e1be8611edbebf9dd38cad5b7e346db4e51468c002193716811dfc3ea9a198584f415c45d55ad7c90225f0f9594416c45484bb46943ab0ca23f361668d818652d23321af1fc2d138abec853c9e058b9de21db6443445b147a0882f0167dd84e444bf542e0cd4fb0f6e4f3c4f2f5cac210ebe017839bace1f600544de96e5704f204b66aef213998145bb8d725f525e7a24b2174d8735f91313ab2f67c38abc9fb0939131565c0c49629c0a047713bf2f30229b2c78c00f62b3ef7c7c2a8192a2ceb6b452a2016006fa2c576b8bc66420590e64e97f8dc329acdb4da2a4b7cc33da92afc7131de1703379cf0add09def98616a54c0f1f7334c34abd9d07dd260187d182d06460a069f86a4e518e1ddda40370c9f0416377881694b8da3d922dfdd72cf60f7a4c351eac87a0a181c46189fbdcb9d1d989768126a610f2a8f0335fbcaf0aac7948b1ae748bd291e89be6386c333109a4e30d12f6a007c2742634cd65ecc309ebf9b48fda8e59df50a34f1e7b9f739bee99c3ba60c3540752d35a6b166086e9bffa857ed908675d7de7034f8025cdbae7311056f7f1489870ddf7b261f512d5279cc5d3b954ab324b9864b19c74d59d8248507fdda9921312bdcd64023cea621419c9e0db79a6b3cf89e29661b6ccf13e8c9aadfa99c738a278af8312c4570a366d5426176a88f8b23ba5a749ee7b4d58b121c0bbc4629a4bb6262202eafe2c1bd05d747a894ce54f9755943901bd21d461a8efca41dca1b721f899281e02435700a3c6509648d2aa4c27e356572ecbc2d0ec69c5f579b8f0f03eac079684f5b6612908e46acd6f79981f7368dd067c485ef8a3567090fdfc974165417c8f2d9ef77b2217f44d296f29f03e2d4e91521bbe1e369344507a7882173614debd15c47fdf87c42b50643559263dfb0679cfce3d71f7a880e16b7b0ad1f0a8f3e81549240360f12cccac8b2c061ae07a0900e0806b7247710a6118a665b3bfb64b80aa46c522a497e347ea211d05c506e077e01e5612357cb3be2f9842c0bdfa48683d17743a764fc378fd4ebb5a642f5bc6fb497596a1f1783b84e02bf3084a4863195ce1e9920a630990c39a4f6ecfdf4b280b6f4e2c15254a6d79c9f8b4e9f2e424be38828ff3a558bb6114115f78d0bff2bca926272b1c0042417c33bd88b0236d58e5d5a400baf517fd6a1788d602f23eaad648bfea6019a2912a3a6b2df9b80e299a4240ecda55c35d83c3113442d4851afb8838c029f3d110a060d24d0406fde90672e358117b3cc2079c567a2be73d14bed47cd3d1ea2140f4751108b0f40cc95cffcc0214209f51f06eb3ac5dad738cb22e2d85e415b1a08db5dc28e40cd45345d64a0cc3c0a8a3912307e4bae330e0d3767103c8b46d195ab3403a564fc067cd97cf02e59b8d8641a99a4b246051172536ec0e6c6142e6d05aa0acdf86be9cdf1d9af81607af47c07b29dbde1091fa4b19ccdd478b0d71a696ee3567144de10b5fc3415ae351fe98ecaea79683b79003414fda378e3d7f297d95f7350131f43c559fb611b5c92dfdc7f9cd21cbe935e3543b1ced368d9428a91b08c5c2aa44209a5eb2c2d7b35358efbf51c612dc38565b2bc73d9321ec336640a594a02c46dbd4a7635482daad3840b8efc3d9a908f22690ec7b10092d42aa0c2aabef56a5f1e8241f661b48d1b6469a24a12c851b00d142da2f9ec06944a58ca3d7dbf5a8e9e905a4b7f73ebef35615a0802aefbb5274f5de74d185bac78ca41ef23c3c5bd810de0875191171bbaf037f7b2417c5812ca8a5a4f749c44173cd259933d70a5cc531ebe89f2e8f4d4864d46bc3b798b7ab141934dc6ec19d52cdc4ecf594e7620c5f69282abf8680009da5f385fe51aaa13665693cdb6886cc24398cab064af8f066af6cc98f402a660f7016033234883c5fd3456253825c67c468dfb4fb72b118c51e6164d42d8186b874ee6c4da3b79683873e16acae5098e1823e5bcda1099c689c8de18e5b74b110b07275ece0e7b97e975d0c03eb84a361664fef696ce351c4cb30ffcb5f66beda857e7735dfad3970e09d0909caf16ebc4434ca846fe12a662ce4d2df7cedce8bd0b7bbe07b5f7845897b0770c7182a656060f4c1e2cfad724f9ff4339a9123bca0ba98bac9762f40724a3907181ecdf1fe8a05a8fb73c65b0738f5fdf835bdaa9cf438fea4132a1b59adbbc1c4b90c3dc1b3b3e675b4760bdbde5c7c9fddeb0f44647d54f8283ef1282282d76cbeddbe8069bf5bbd911e8890b50170148b70b47b0b0222280baf2a7ba871015866f6604a92c3a6b4ba1ae0a76f78939d121cfdb777d25933883d5a35c4feccb325d9e99c4bcc6f69b9fd42dd02df0a27cfea7e08d80e25f7e5606afb054e29cd87f71287b2ddf34898f9a4aaff64a8c093539489860a9becb94bd780bbd4bbebed1b8e6a493e0ba89142ee5fcf42e6305c9bdc957a220da41f4aa1c4703aa5deff60f485017d93543eaa0ca362db8becef781c3f4d5a82fcb1ab97f8f2bab2769b6861b4c244750cccd90136632f2f5f535c3242f0d0b1ecf9766d6a649776070c873d311fee16007c041974b6d15d7c264acc246c9a2b03625b9cf8bed1f0b45dd800f13f1ddf1570f7a16db734e995b9f847f65f9aa0f118470dd5ce8cf76318fcc06f59f568e38e4413e6e7a81d32d6f8ef16d1212a7717df4ac727a14b471b1d3a0ff147c54bdb20caea0a497ab5cb1181132986be78bb7402f43be0e6e9c11c9714bc3dd5dab6332665468acd5fde90bf0a79ede6932c8a227f015c507d17cba1cda414e6d58ee91ed0b1b6579c01398ff35ee7f8c665785be622189568d0c7ad249e399417633480c8f4768f926f2cffafaafe87f30eb434a894c634a4b993bb0bfc21d3220544f1a00576bc0df30f7d3a1542157aef2ce1c5e6c15644d0bc0f8bcfebc9e0aa91a1a6e6c86511cc8bf846105037689351b375f01b90d5696dd6a963d13b261e2a0a7d86f84a7241160cbdcf7ad91faf0d3b8aba3378c88d9d2f1472e55ab3cfd59c914cead7d4fe1db2ba8814c139cfeee228d1a2970a5b759b66ea073257a32b56ada1653506b43cee5f92f3b7a633ddf25ce5ca0e4bf636726ef7e13f3506a35e583c2b9840dff6655b565d8b75b3428dec1f44c89f17b3e6287aeab01f4ebb40396d7ab770b61eac527a0f3e816b8e765f2d0a105035db37192f5fee79c78ab59ea9bb57b6666778cff7861cdaa43e3377470baf0349b44b3f63224d72d778276d2c3e4c61bcc58ac23c75de12685dcae864aa2b353470d8972446e3040721720f06c958c51771dc89f012a4fe49c9eb67bfdf05940224644286218aa4f9c3b7d762af511cdf33086fdceb0c92ee6086bf02793d110de102b97e7e121f055199b30ff66d2003751a6acbb1c8d7893226718c8e3b00f6a8ea1eede348f19b74977f851eeec352e8daae0374c71a97a63872f759465baed0eb9bdf0b1baba668f33e3142efd8ab4c601322e730aad0deb7471093981206d46e0da9eff87a9649b4f0891e68a9c707fdb5f8158a0746042790315eb67ed3bfd5846bdd79b28aada3f1953af752b5ad9dece112f84d6e3eb3a667056089bf99a1b34b9da3123466f0e2c50efdf4ab757ea9208a4abf2f39cfef24aa171101f46c2a58443a67f7363803c377815c72065b7cdaef3111a94c541d84abc6f45a6667d49a42bb1c0e8066f64865cb7e42c10b325ef7e3d4c90184f87448157ef856b92380ef23c5cb35cedcf7be7a5802b903fd52d1dcfbdc7b78a538b0f61bc4f030ec2319b961f304c4ef5ee033a52bb430d705e1ef8aa9a1155693b7daf6e206052bd0c90f658b1af0d380e8ecdb9ec17bb50ccb49bacc83fa39e61b5e6fa960790e4fad1098ef36500115c8ddb8cda8d35eeb46b6a489d45a95b6a5c92f7a9a631b97dce028581645008a14ba35480699e607fe9133458ce6dce87d280d149509113437eea9f1482a4c0a43d106a38f45495f1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
