<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4144beaf51b8fdf56512bbe202004d0d5f6911bace98a6f41e244e63aadd0eff79b7ac9a047394659cb1a337123719cd9bd976ef348e4c63405d0e27dc64f7c2bf0f3d94099445ba90d7780a624f7168721bd0530eac9a0916b18593e53cd02e95653c17821b9ff3baaa635a1ef7f7c83c5f8070f9f3ca1d53a1ce30f0be2716a5970dd6f56ef54685a465eba729dbd58287b16d9d83578b3e7fa1ecd147f6a84631784a23af2d6537e4599a936d4a0549c9cd4bcf6756141b1bb4ba66c3d6b073e591fd74d2efb062516d7290d215b24d90b9e70928b75aad162295dd1a349fa09d23b4021a044bbc0aa1e2eb8da9421b4e474366fd153f4f15543ab04c4601dfd42d1c833f1946a42b4895c949e8754b7ea10832b3164930648324d8f968291cc1da60b76f57ab4a90c303ef8d29d4e5adcaf5576ab671edcf0ad7f97f42bb6a8e7e565ee8c887626a0b7fb68451f6e0c79663de6c275de511d4f53fd35a7c32c65fd56b130d55daad89687d456cecfac380805640b0b53804a9ef1dcdb5e1b49bf3bced459e8788765d670c9fb4604f80db845550d2454985ad831e044efc00dd9643bbebe31f2f6f0113e028dc405b51329047b52c4cb392ef4abc0dff5f03d2c05b4801767ef0f3147b8d7ae88d42b08017b90a85cad9a36c7c73b0d5a0973ce6ef2fbc95e15936b92415e11d609e2a4018ecd5b12e022303939201f12edf4dbfc97715a151587380e1325e9f20a023743aa8686772036f8ee10bd77a6043ed7d5617f511c18664407a269fbace9a2ce030b56c28b9cde70f7e130634de94dc5e48984700a6daa37213deca43b1b704c7fa247cc67fc30098e60c391a580125746849c7b3b2ad9c6ad88db3f90ab276be0101221870295b170b56f292fface1420102b8a56846d2ef38894c405b39dc7ac5544e78edc26d3349258d7f897c9c75f84b308afe39acdbbcbfa54541d4b21b9cd172138904c2d0afe147a6c5b355bf77e6316f9f2dbb73d5ed148a88285952b375bf9bd83ecd29df78a6c8b82189e0cb6ad42d2e396516a63995739d54133c88ebc6cb75853aa72e6433f67c1ac72699f4cf2939e92dc57ed49e5f32ee0b96ae32b03aee8456812c63630fd026c6b44bca7ceaf8394cbd33beae41b61902feba970a875cd6f6a7958ee007b04d7b636cbd673638354d4cd280ec52c5863fbb9c201ad9d073615a938f8bec5efab2b0d938db683a3221c8b8dda4e62af4b8bbef9f19b9fad7ba463fcdbbae1841f41dcac535e5fa969b9bd6903c03eca17712f3f4d2e44ebb499a3c4540482750696384e606b41a1781aca84010f0c1378ed5507b3503fa6c35f2cbe036c0823b835bd86737731f4500f5767d214338a3ce72ec50ef60b929aaf900861f4a40258915ffc74e669c1a92ef1e4d045a49212161ac4315ed4c47f8f1cbe4e690837d1266eadd35d479cbb0a4e4454a0669ad8345870b37024256f4be606b074911e2b854f9d0bb4ee8e2289e83ce42fcd160c80d6e201e2740f8e7575960525ec192e15f059eee6ce058cc8703c8569be33ea6af5e1f2feba2ec81082163ea7c3a546d770a908790244895bd44fcdf08247c34bb7d8ca05fae0e7472d7c1e613981f083fbd5295f66b5c304287d031057027fc8279f57f38c3f346fd368d28fb5f15b0081c51dbfcdac5c6e48de0d7d80508b6a3b796762321b267d4d7f4561706fb1ea7414f5edd3300cf679d61156e41a59da970d61131bf51904d1cd808325117a060cd822e2c17443968e288426ff17d5366b0bbb6d73b920ce0e8c507479583916e00c352be3293965bc783187b24fda53618462a83c73986d7b118f6bfb097549ef83f556acf92516e1e4ecce3fbd3b91751f8614983e597bdc12e2dd5339e8ba8196d4c70d650143bc4f498f0c882aa27fe0b7c59b78821a266c847f5cd33c3af13ec14f6a3281206b8c773b422afa7d30d475bd24cb5b61939c2aea356179c435d2d9b54e080783d1ef5684f4a3c8fa874f8173839ba86510968266e7f8292f27f650126af1fea3541ab0e5a08e12332282b99b65048c7fcdf053004f242f6788935ad03d73108ee28f2a2e1be7ec3302c7fa68387f341cb022b58c658a386443484fd5837e4ba264cafab71879c3f53adc0440a54d468d498ab6181ace25edea8a0380a38d912e88286be8a5ccfd06c600899f7e5a5ce5de8e1e7beff5e9f9a2224f364582400a8a67b04d81b55c453bb2071b26755fcbcb37a6fab0cf290907e04dae6bcb84207a302733e745e04696d75a9a9c0b4d1abb74edf8b359026be2450dfb218eca750e2d601ecbdaaf6866e7b2749ffef186326454a37602067df5262a6edb4eefbcb54d1cd267376a6cff8495b791f669ade7a1fbd6cf72d61a33adb7511073a2ded030789aec412a7e29acd24873b8dc621826ea89dd63fb82e8506e6bf5a929ec7ae166bff089d292c2cfc6b927ae8f285aae4e66376b9a0d0c18879315d5344c134ae35926c94e786c06d57bc374fc0a8b0b76569b3972fb0b9f539f4471c6c2c72778974e3756b236c1e95c81a7ff231736c9ff9d4e106cf4ea9aa222ce3694eee99dc0a0c92cbf68ef7e4cbcc9c7290b73ac19aa5660af1d7c9725c54ccf29e0c92d8c58fcc9d4aeaa6d607030c644aa2b55d57d3c5d0fe101cc2278c6d3eab06a932ba2b23d811f119d75ff82556feb7c2901c649d15d787b3c6a113134614b25da81e59ba6939f148195a56b02435eb3ed38223ca69b350880871000f1001073e0d901b4f85066f79f02b3c0ffa197d994f2528cc142aca1b1e71b9f0c57544b9d66e0d0b26bfdac2e6938218743837af3a930038755626fc18a82ce4e3eb498260955ca5313c63187dcf11fad6788a1fc4804e90952338010840b7b4d0dd85fad8bd390a5a58fb7348680bdf8fe1fc7533ba4c47571f57659dc7d890283c8e194ccc6abeae44a8f3da4ba4967e9c18d4061926e2588524a0368393fbba9578985685e0df57bba2d90749a299b5aa5ed5a79146fa3fbdbd816b9d2126575826a2705d333db9af7e290703ad8656ff8a9cbef7ca9a948a8dd41db6176cfc9bd7d4bdd3fff083a430b20c6aa4213eaa493e07c34f29527cba05e14d83c6f1656f6c868d1688d1950115c6405e3e2f0aff89ca86c3e4e60616f175879c9981a2d94a36218a191a7bf09a91d0f4bda863095d251ca591c28a221662ea73f797ce4d21eba10c00041268d39d978c5b91402b3509346dd4120c8083920f9f2a5b909bf49eb070ad90314f3d0d89c0554ec303a85d95f81771886f9048ee4ce1f5ed6038eda78f038561ee6edc55bcd4a047d7902ee42842b71a52bef1dc721aacfaaa71a3758f24871ca934d075284fdc552b9e7c627caef018f161cb546d496051d3b455e635c1929796a8fe7c8af8a582683817d510c33e3807c8813e21eef69e5a1327ee43ecfbe3fe27f2b1d42f44f6b630ae4d12c27687c6519ffb7b7357ee6d09b69638350e2d01d9301921a0305d87fc5996a11fec5d33227be4fc4d8910f70f27660e561192fc29382146de5b239d6104d27271aea656f1837067eba7fc1e6d670f60bcd3cc90e2eee0eb65b22c94919cdab764377362a8ffcd5312afd57d064d154defae79aef39f52877a23caae52187313ed2adb9fd812df6f6449e54ae3b9ddb9b9d5b98fae1c38326f9fa9ddc0c840848cca1b2cc0dac64bcbcadb151391df1816629e778496afb1360d8b9bf65809accc69750928d7767c75466a02f17e2ff5f9b8383e39a661a86c84bc962825eaaaa0c830ac627182112c43139126914f75f78203b79d851e1921cd9707b889bcf9b9489777fa416bed0f530c666475525d714c5e37507a1ceec7eb00809aa4017519e553024cb541024c297c685aa1280bbfb597c282b6e4048d3f6f452874bd1644450ba5ef209960bcb2e03736b0005317ac3b412a2f00ca560722f677f564fbb0a565e3bb3cc2bd66f47857b5dabf450efd73d627213682f3250fa07007e9a1c4c3c2bda477545553b1834257cfb144a7e5e5575f46a79043894d5036e593b785cbad2f831f0ce667a82c384e173d7e726095a93fce9518fb04826069bf8f30548682e892e4ae1a3481f356d8b719f536e79fff665915855cf9833517bc84158ed9ac4889ad5ca5b76ee7e3b297a43f8411b23dbbea538d5479accbde45636e807731c829165c9b1d5459300d6bc342c4ec85381dd2cde6bb1d6781de200446270826e66ebad6cb24a53b094224917ae760e6ed4d4aaceb95650a96f44d9034ca86f0f17e6bdf2eab3c53d0f503ad094a7a4da859eb334e89bf6eb41634aae7294a0f0b015517220fc403c12d8206fccde53bc3063a495873155ea92fb47da4aa1ab43c6c4927789460d95d790abf5fb01aafafd99af8e3ec400284e028a5aa18f81c4d003aeccfa55e6e3eb6c346eb20681193dac2258db199ad554285f89d4c845c3f4d72d95ece06d774afaf7a31fd6fddd7242f53269071de5c5d537d6f10c3d11366c6b39bd3de43a47dfdfad93c8f9eedfb80e7a82c5d5a01665cf371e3c5501640fbabbb77b2335d46dbc9d666d75f906c0b111ec628e2c5b82d755c373a466a056bb80d75e3bc31b4b88e5d94dd43882ea141292471c6a57e2306ce18cfcf045b2e3512edb8f01d6bbf98ca40efc4cdcd88865e5fe85c7a9d43ed812ce28175962106261126abf39cd85f75d3bbf215e650ed66771de0b01833a4febaa1fcc163e16a5b6d00b1314a64e8df28135879bb529d023f6e6844fcae709db6e2475ba817e64dd42a08e71cebb83b8e6a07c1ced8bc7a0bf454ce08748e88ab4e5db9a3e40f942252ebeadb7a51561bed70e44086e4e80bc24a5d42ac28b65e27cc5230608eab85af2cd55b16cb68813f85892c5141011d55de645aa01f13bf812903d0f9930a37ad97db86b5125f89f513ee2be63baea63d003291b76aff001d03153ee07be33bdd573bd938ddb8b20dedaef310ff897b2d97d17dfad06bd3e3b1b15deeeecd2b295715a8c831e35e926ff14dd4cd0a065f993a0c30da0e881e11b8cdae3aeaf963e8ca057e904372079124c409063adf19a73268702fd8d3faf99de835923af02f4adfd366494e0428f17569348bbf5a3248b6832fa8c80fe81c4b7f9f1989c209fbd251cbe39d53db09609a7354169843e7aef38a71fb3b3b078452b0a3d09490f8a3c8057a79169686584939e0982ad554c17652223fdb8863510cee814fbca8a8e9d263000e3ad1046ce6e639fcd28263ca7b99708f17ebda81f4f2f385e5fe8481e04131032ddb9acae97b234d8403423ae22b97c6a65e75da03901e9a4c3c72b75e98b01252807d8f405057549273eb115da36850409aa8cee511a3713bfc6c77557ecb1a2aa54527161a12251e58cd167525a682be251b2074a9206690ca3a3a5eed4c4ce8a5810e21ef6670aea7a119e369315353bcb911bc8bbdec7e128327cbd0e451bac197ace17cd5e3c978159821a571f0cbf8781b46deb9f5dc8e5025ac9c2e6c3fc47cf52ff29e00f27345bb529fd0cf4c3b1e5a4b84ce7c59a4de4d8da2ee50a3f9659795bf8dd205bab109550134d1c681ed8139f3299b931bdd9d6263f2c93194c9d291e7a33ef0cf7ceca85ae2d66c90aff39b46e0688ba8a89acc6cbe98d7e4b93220bbc782c64d8408744d1e243b65f148a738ca914063b19c014a7360022658a38be704574d2e9416a38b71c4b96805e516be624525a047ee95a52932f8060712e9e9f8a95d32c8e36a484cdbd5be2b1f5fec70d83d6c62f74b9af200efa94cd4706cd10458b342ffec4ffc1f99366e830d59eb2bd5f6f648c59af0a92cceb77b347c1208ec465ecef5a58df0823da039c777fd86d67819e8afbfd03f452ace56a6798bdc84699eff28802a418cbff3bd3f70c81959272e26ddbd00303513537da613657b523683c13df04e7e063c0face6101e658512abc294dbcf38a178b58e6bc9108ccc9a22ea28a9f20d94aba62936d24373956620608c2d57bd6975a3f180987d9a5379205d208bff7aaa4f48b4bbec6e2c4de9010b5ce186b9b98ace074a1c2b94d51a3f6c52821720fde46c5e01a420166b8cd463916f1cae6f416b0b334fe82f751f26ac08d7f3df420d479035a9e20edaea46f4a9edcacfc65cae507c306022bdc80f99acf90d1016672482742b0521394db0c16097bacf44cd5a8afdf22e2b1b5c9b12904b158a75a887ca93b73b4ddbd0ddb1f2111b0d2dab9f4b9f63f2759d7508b5debf112e4c56bf956dd35c1e118cfe99c678fd707c64a4af216d73cefe3e308178d230c14e7a152530ed896868fdd68ba614740dacb0c3961d32adc421aa72964806c0da4793248c5bdf803ebfa54c8c86dc0dbc88efe170dc157aae49dd76922f758b52ac0d7ca506a464c241df25bd3b5ddd5c21018e955cc9321d4445a6258da59314aa1d22b6078b348ae22c7d11157e88ffef7239441b67b4c65b8c80bfb9b06e0d232ccd4d46ecaa5599a735f073f832d0ce2623168b44d7fb0fee02f7f601af7f031c952b1970a85b2c44f1ffb06a8ba915b74b9f1f32dd8116452193d47783c8fe0b29b0c5b687b1047c8fee96c7595fa6c44107a90bf486cb4748ce680bf30e919f9d93d770e152b81df281389aaef42724a81c011316fc74e198dbeb04252a682c58db77e9c47d5df78935c766e0b3832b747e534d3d884ef1c883296dc6d1e778e8f0bb48f8b8b1ea1ca7c6bc673a038a66cfcd1c43626c600a99c57a7108e78eb3c927e8f076291300e5580dc7b310386234402abbb2ac3801dbea3b6a4cdf48d2ec48c4df9a9cc0120b64486540a1908234167b43893b63021619bb4d1b76df6532ce5de0b0d6fc14c2dc80370ccb083ae74351d9d0b14226138c850df2999ec729279700c59d1761547481c088c407136749de43fb6605d547c0b3ec64510f967f7e2d3add4195257ec425e0cffd5f5f67bff38a0c584e47cd14512746670024c961b93384034f227d5ae7fdabb73b856b8d73fc42fe270f5e7ee55182681e7e432366f1707d979ed8f36c42e7e65b7ad9aae88cb9c2e119a2c773f95bdd77da8149683591d262490e6ea4905e57949a8947b50fbf5a1e2aea0a8dce972aa25138caea35b2b63e56df31db983cd91f3fd870d71e477841296d78560ca3a47ec6115889ec62d51a8f434ce4bfc567bbd950e1a3f4b87ac77d60b562fcb3bbff127f43b6cd245e6fe4430d256df33b3e85806d6e75e8ca160aa40b27150185c38a73f33bdd0bd82d33a4cf70cad4912c16465c438f2366bdb28adee9444f8847f7c58d7e70a9050ae7892595c10cf64e381f94d38ea7829b7f7c30213e9cd92c360c901508287ad1e7f20311429f3ca3d09e7950dfcceea15efc855eb3676aed88a7019b2ba6be9430891d90952a1e0c39240a95c82dcf30813d589b6ef0933263d817405339f71f8d881e1db86e1f597f6a153817435be1961ceed4b988b2c0072d8c5608532e3c89e06987761abc3bb0d8d12cc7be3a4e5498cc677d028d97af0b3f44c1a68337ffa6fbedc04555e8108997d9ac5d87fab263595d54634e9ed6a889d9e2abcac0eb0bc7731acd11a9a0b74cf100d3a86cdfe932c90512a1fedc8d1537702d8d970d80ca3cda95df4af087354a962a832cd75a93d0362ca3b1679246044057cdb558952b29375c957c3ef76c54de96b93e01137b8660ace8674bbd9d44328a9624ebc7f7cbe9faa20b0c4100daa92c1883611df63454b717f1cf5ea45e8d577362793d13463cd11d2a8ae2e74df5d7d4f2203447187f1806482efd86f553defc2bb1dc81b48d726302fc876e40bba0c04636b8f6a4c7d67c9f0b86ac4c6a09bbbedf1c7565ad931df9b394ef1ae16a7ab2a1b673100cf4af40e773450d985c575a0ba16542535c7daa91375609613ba2ac9a2a71c439e5e960258176fd69b2634849db8da4ee190df26d954360d40599e7a207a5daf91aa63fa450394f56735bd0f08b3bdd0270a0b149667a54e7d49409c02b5c0add4137e6c32e74b0bb1680403e500e0558345a8c544a543d6b522b1547b156ed1396c120eb9730e31e1be04d7f7283529a5410d163171d2ea07df0d9c2adad5d3f3ce3e93967479310b1af564b49273382f229e691f7f3aef94f8e0135a17441c31c2edd83606da0691fe124c3b597b75badfbe3691c6a006d534c31f146d85c8c51a551a0ed3972a0f69dcf237cdefd428da082a40a71461df226adc3d5d750c26f1d86b9ef919ddc22dc7ef9e7fff1739ad1c3c2b9fa910f6b592f7e52994a2ccbfd223ed7fddb188f91d4f77b233c7e394afda8f4b44be5ef458a554032287b95592b59c1de52e7101fba528f94799f46f2f544825e39e11da04f9777d5103a21e8b8d6fbf2788da2e55a7fc4387a5ae3e06f383c0353a3ca1c0342bbc644f5bbf1981a12b6d694e7b69a38d1d1699d9d18f2585ff2870796e453c673523398db6c1a80256dbe1d980a15bb4675288ea9384fbb2f7d40a5b51a55e5c1000c186a51ef3f78290977f0b98b8a68cc23680c529cb2bfd7b64e02b146c3aeef24df039f964c1c09e9281151b9285c1af21d141f55fba7e58e144b12bd795090fd68edad4fb0400c54982947ba9e619174c2fdccd364e04caa9cdd48bec8830e74cf4360f4d5947d8a6f9c1c0c7d5d69ca952112faac4facc99037fde2995a87240b8cca03bd9d31671fac0771b31cabfa7ce153e40b4a204bf8168376d5d9d9e2c5ff249bdf684ee9360858f1bba2a84bf9daa1b91e560da3181b264d44411e2f5abb7fe64581e0418641a4f53a251b2e23b0eeeac56c8a2416db7c5e584c368c190a12f3d223161caea247ce31a396b989944f7b2bdc81c62820ae1f05dca4e2f33f4961e1021b9405b8feba9623a126b744551ab2c621611e4847cd91174f65bb410bbfd3ab1b8b99864383ff65bd71c0d56f006928a4a468177e424208b6327dd6bc22ba52ffabfdd0589514ed8804b144282591af6d05c7823fb59bc630d8316672534b8ff2a483937c53701c14926b329ed777b486b280fe3822d04ba31db5017f39a5f305556947328c177d25a33c560f2123f9b276cda9d3e9c342282394f879cdc563b8b3a065509abc6d3d00845e8def769c53ba89704768f84bab2349a34783517795268a9b1f122b18b7d5fabeab13eae584ed5fa15a31dd40e5f2ef055f2add4240d7ad5af940dfce1ca97902c167f3971cbf267c56acb08e41ae7448467c3797afe3f2d8a45a61b2003ecb8297451332c7bfd6a4f64f8dd78959b3e44edd55d698efa8e527952829d45b8b849e7164661e1c09ac88c312f19bdd41b791b6397bc78dbfd3939498c2d82df249934ec84e10efd8131da1cbc95de57fc4a394bb4fd0e33accaaff2c56de6dab31fac3951e4a6bd677843c3ff5060799cb8d1b07ca0f70eb243276501a27e8cc3edd8d87fc8b0522738a19e2c4f0af8a953a340e4aea4e28da36674fb2b39cea234cd98ddc6a3d5d41b80ad0cc19d7c7ae53a4bbe7d3ce542317304a780a6695bb8219ff860ee90cc29fffec55214c12383fcab52896f19fba6fb727f7e3779731d80ac48c9cdb92fd695afb50f96d56c0dcb77d04bcdd3d68a0af833307fdd8c68205d678b28009f7c9edb1f2b7e6b1fa9281ce4f523da893ea04897dbaadcca25c0953c84ed0e6511763b00f38331853fb2e57b29651db89fa50e0f697286580cb582612e7cc76e456506755f24f4de3844ceb11f400a0b60c9061917aaa4257d9a4c9b138d6ba84857b929e7dd1ef63d55fc7d2f109f414c97c53b99344a8dd8cffd2173f6219251eea829e7791fab5077cea50b449c2465c5d6ede81fd784c15e9694d942e6de8a83c564090df2f28c3c215dda44e0ffeb1565ca3f74cc6943f181928479ae63eae7b1256fd6b52278cef1719a51dfe977a40f72a23ceaad8251560c0059e0dab88f4eb4e5883d0b075058fd6dc8987a6b2c2ec10158f6aca570fca0ae0c6bb0ae854de6af5f0cd17bbb4db6920dff587c3c2b736cdf669ce2a1bc20e4f6cd819cb2118ec8c77c6c8b61587defeeaa910a6c43ee282254ac9b71d1b703f38f78c5918a7f99c086f77c3619a440ad5ae69038f2cbd9cd2c592be22d516d5d2568e2472b156416014623668bba9621714b92f2b2155d6d84668ad25c1abcf37c90c0d61e53e13d07a806e6861fbb19197c06fd8622f80c9633a2852f29811c67a7cecb4a2005c02aec370186715b3ec3f098ffdf6e696fcd46bd32a22498c4f08c02de40d2e488b869a7abd5e016fa4ff1d16fcfc76d7b3441e27883a80327cf781a5b707f2d22bc56375ba51bde61ac410de310a61bef51c9fd050e77fb25081ba8208ad40ba7c3bf67e11a61c406b991b30986c8d7feafbbd4a8122c91bb4d8febf24630be6cf68dcaa31a523a7e89932707a085d1295480d286b4d352279c788169a69c694731ebca4b4524f7db63ed891b83100dbb7896ed2a4ed408774ced617edc3b9bd7969e1d7fa6b5b7f78315c8591b2b706bf1c235af551743dafe3b4bebb20bdff028a936e744c4912135969ecbbecec0b58573180383ef36b2fd3d7af6f43c1eb26289517217536f4ebf2bba29740a3b8b2be8740909b641cccbf87d3b21b492d061a2cead16f5d8cdbde1aebceec48833519bd5b71ee5f353639d26756c5e95cb964fd23a6ed80acaeda7998d558e196aa2c537aabc123eb52a8fa72a441b97a8c551374d486ee1c7bb762784d369047115f6e753a73299f9f3d32292fdabe406ef8caf41a085ccb8313948b5e9237c7ca037ffafc4f98d0ddd96e41572fea429942e9ae6f9a571b5be7ca419b885d0549355709319a676df510732d2cb35dd08f7fa5170dba1dfa68a896508ba53e53aff8e39a81c68688d3ddf0d83cdb57674f03865494f47c02448cda8f91df00bcfc3a22f0de24f978a1cc7d107b64508d967677c538ffe9b53c0c8a4e00e7a1e22b079d96fd64ada94469c19e484b33d1246df53f849de5a5079fa8e152f557f15384373aace7da27e12a7d05657e25830c4c1fa2c353c9bc2b385040d2f3a8d34f102032bd595687d4ff2635fba3980c10ff4095474ee679aeb0ed44664b1ce2b06595bb597b7705d7859a585f6316cc2d8f19d07545662591e4a0f331cee32547cc6f2f439062573930ab47683174d001e008ccc6a289c3dc1c53037e724f510afd534a3ac8671fd642af50c60eb8e6ba0d7ae3fd7198f7b7526ed77f8b09c81e48df6ca9cebaa0f568a74f96d4af8672121bdc28412c1a3f9b604acf88df8dcdf4c8cb874352d867f4c1f486a197bf88e265c46429a8caa4e84d6d5e9517043c0392de410850a7b8d7580a6bdde7f276951f89ec594f948f967c1295cc2fa81ba61115a739193455d32569dbee4b058972fea244e35f8696b93113fef8949bf5bc17377f00d5cac9ff69df0e55f36286ddf87673a72fef6ce982849d7b1cee14d974e1aa50e41ccca1b53516d82dd4cdecbbe2ed2d40efd32cc796e0fd3da5e78b193f7326dbd17b61ac681c74a02bb3802e303c3f8d2432192ce4c4053ec099a8001b661d6be5fc58ad5f8b6665821b2aee07ad2b7997cad6ca34e8247f58f4a1dd70e681a5499a980a3c9890aabfe0ca7fcfe7df8a81be44ebbd9faccd9752e36069d39bab64d04db8b5d9de86c9e0c6e754a1bc2a4ab62819a0906be5e67214861eed4661fac79b722c2c84c07784f430223d2f69548fe734aca88bd71b1ae36c1982c3490da886915e05df7340ecc2941f1896e47388adb34184b5771ffaf00a6fbaab12190f82a71373beab966ba3450280fd6bffd1763df22daa2ea50e075e1e33a1fcfd0a9bffefbd54a6377da9b62728330a19d4ea6e0422ac1c649900e5dab2b43675c57c80d11399dd595669e981774aee5524c25db6f17a129188fb05d8fb718faef1cb86e578961d6567aaae800d742018ee1aa983919c6f9347bf17eb830f921fddd2ebb5a573fd135abfc9d41c3bb2c9010088c9b7492c8ab12d9f141f3499c131bd45aac7eb7ccb6aee41d50e579f4945d194734b21b10b9aeb4b4e040721738cb3e9ec542fee521be43e12428eb83428f98ad3b2d57e3f5093754505167f982c3cd797b552924a3ab06ed4b388d4d4abbf9cb9dac0b41f10c766003962289ec41c8b42291904f51653f8ab04c2bd3519bd2dcdfa8024c9aba4372fe640d6621674f31ab2f064e74e558d8561976b5b1122648e804a77ec36b5e22b273cbf3e90ea625ae9c64ae8f5fbde38c5415ce626225743c8e86cadc7d9225630cfeef1839541c8af24d7c2f73f2c3ea9ed5cd20f999879f459866d427a1248af0833af5a042c31c96e7f600c865d26f99d0c5a3d6cdf6f05fe8d60f2a5e714166ab4b8ab88e2c3537fe0c0b76b49893fa8038b66b9773c6df1697ad2b58142a2d4c500b31a6054a75b6cc230906dc589bed288bdb912c8ff104aa599afae16b6dbf4a0b4d3e31b3a7fc932dde48ec9a7d7fd02749a22857df603788ccec390f6f3a5537f57e65cbe6977145c62324e768096f40533af6043123e5e3fb215a5c1837ea7b85bc2ccc6d126dc7e4032873e05382dbe00fb2a152fab3bae4deb31b48c13d659f024d2ccea95aadb25b2fb21f9a89a4cb8e8427ce1a81346b87e2c0f3f11fa88411d61b05ef3de47211467591a2e40007bfe5b225a4d386556ec5948e71333f3b3ddda749e499ab3b9169157b1a3425bf2e33a19bf83aaf9575b89b0a5c9b8f4e42255a068e2c401b4cdd54e5b1a62102f1c8d87c88bf71ebe6b1a260bc1e9da1a8f76e829161c83b82fa5e8dc80bd3187d0ea82973826b4ba79c9b333051d0831b6bb0c8d0b6efbec2ea4e615fa0d328f2f9ae0ab31b1f9889c96af4ce06db1a250ef472095244d2841531f6ccb5e3b57bdcd6f53acf42befe81553efabd15ff3b46128b3c7a2bb66058ebe182d436b89a8215f924f7b1ec43b1b52d6611b23abee4501c9b4dd685236079912f1a9ea59192510b1df32cc1abdc8e5cbe2fac2be47f96b7d1afcdd797eac248af4b45ec871140d7279ffc11aae9ea6e56a5d8cb9518b68e2823920a4ff1fdccdc8feac96e18e531efcbc62819f41a0474a393946eb22b3f62575b0f6ceea47301ea273da1b518a620a1c5d459c7cadffa96b057e0882aafad3b4ce9edb6b5e17971bd0e246fcca73db7a1529cec357f1f4fcec10d08dfb3ed4460d12b212c29f52b5eb1d41672ea044250ede3054f8e42a5c207003e1d5515d3cf71aea54755ba88084466fbe41411ec91282c1c62483f3fccdf3c297d49932d296d9c35afa87ee3a774e920e3eea3d508594ff2f0dccca9e9ba4627257bf4b061e2d9e0feb8301e1c9d457ce5bee5bae55bdcf50a067812c21466160a91be7674cd33ed7bfd83af1cf74f5ab97c7ba6588d225e04fa40afb79009aea8ce70e46cf3d93c39b78c68728f245a4cd667d5b3cef3c18c089c7476200670656884b822c33e2912ceed5d3f63e7d9800e24d2c594244fa2893645bd8f14a7b67c112aa128dcbd820f1a4f220e119364c29bfb309fd780ea435611f985cd7afed102bc25617b5ac009cdee148939af11e61c150742baa65be4c908682c6827641780464a7a8193a077cd2b969875ddb0b77d05f438f202af49812ed4af6d3e6d84ef2a9362e31a108256db4564a8c2d8bd487d91a16991dbe3dcf21597332e074a1a53c564a68cbef8a29986dc8f0abaa9487a21a25e7fe92ca8b0636d6851907741ef5b25d63bb5c14fb5be7cc223fcad3adac8afe29b827bb1af632fac16f23ed704d687c729890645193938a9420315c3462f9599e9927c84d74d903c69d0c8567b49c1249835f24596a3768fd1dcc02d4f050db4adae35ee80e02f34d62c9c0b38bc670b4fba0ea905e1f5d2416bc570ba7bb19bddf75c3e44a7a0b6baf1e8e6e4d5d43bf143340ae5d6b7c70859383b1bcf32d1a0abf89f77342289485e3a017d7f5b5e87a1a381e260e6b2713ff2252ebeb1df82dae127483ac4a7231c3dd9dfef551d11ec9f96926664d710770ff2f7ecefebf82e9b65ce32e268a17bfeb84b27487c95f0296299b1d51204df3b4fe83c9c6678b6a287f90be98e05f3e77a556f9bacda831512525952b632645fc04cda93327b1a25cc2866e16ee61951b10e37d96ca380f27f6cde700c1b40f9e0f631b8547004cca7984080e34241fead2d09960379848381ec1b97345b698092e233a822acb236fcbb2e0a3f191c8c7b63b8b2ab7ea1d88d781114a381b22b0d1102a485b33aa20a3480383a6291cdfad850d71c3fa00d48fa5cae2d34fd7ee2a205c20bf1afa98539f00462883b7993284d629d88f370e4f9e8ccbaa3b625661843f2e44dea048c00e8d0a9b18372a7f34b0abcaf1ac4e6f067f19c1876d2bed930a87a2cbf87cab004937a1041309668e3f5c2ac2be2e33932290679196da7b562d959c81e3acefd1e9e9478dafb3ca06d940cbfd087d0b51d04ac8d88cbf59ec314ed64a0b2f9ab6c6e88a0233fbf1420c1aa17636c94944f393ddcc693c2962a3039dcc1b2fc47aedd2d15e72771da4da0a64a9ed315ad304d3d7063e2ae4fbb903a254d49ecf1385db3b9fa5e74646b0334d0269683beeed7bc9b2eb4481eb36a226ddf76b33af1d00c341768e6b4ae65b2f3b79bf61935445cd1867de8ace3b443f3a495f37638b785f003efd8890c2281a831f1e7da0a23bc90a6ad7046e43f4e78ea000da473484bc31feddc748a090606480042aeb25d7c0a0931b3351a1c0b820148909b4fd8f32c27363a33a8b8233a764772bffc99fec556ce8a0e05e877508074def57f1cdd82ea814dab1617f5a13db161a4d86ccf5972bf77baddd202dc37bd3d2ea89168321e96d50634c0e77b23935701ccf2edfc83b9b0558f0808f9bc6e41a22d7b678b278de37745458cac999aeb098ca49d81a99a041865ebfad8a6def77d020f0ab0a98bfe1bdd4f131cae5fc02448a124fcfda1585245cf2943f19263ba2a88a7b9524421b7973789eea4c83e25c8aed331c0bf5c382a6caef3f8883a4163aba579dc5d9969f53e404bc728f78f635afc9d5c692a9d4d64defc419385b81ec48eb9eb9898d110170e9d787ee211e9f78308e5c7d30458623e732b42637ddf61eee3042ff2fa8bffdf960c849a1bc0079933f901f2a2a19ca9ec5452ff44fc86086e8155444ad99ce1110053fd36f626832ee7328dc631b59a441ca6142fa33d5dd5afe7c5de56f398b65274583e6d2c3b42ea1fb9f1f4ca187c45230cd846b66f2722da3e947c990b6268c569c3e81813b17fecbea5119b7b58dc21bae3a914db92dd440ec1263c64804bde105d3ed1eef4103da0ac2f1451745081ce6fce80e1263ad88bad06029643ba928b2bddf96ac8ac7b1c9dbd54dc2c9426c71d11290a97ad0640b167053824c7a7a81c5946f1da45cdb4adbca55264a9e5966f3e1a2c4de55f4e738cef47684221fe7bccc8764acf05a2522f608fc840973bfd405e49b248796d6c825f7ead59b4eb1ad9bdbb687588b4b24316484f84a50cfd1c17b93d901976345ddc051590b0d9851074853598216a9294925a0e62706297e2dae10f99a477c3eea148ffca951fb492ad26adeaea9eeb9b7af2e291be128d1fa6abe97fd006452944cad5983349cd80247f8d51bd40469b9de4ab76c991ec55b0f6d0fe160e813151b0a855645edfe0af8f35ac175f55b397ac92cff3a39e1de023f8514c8aa05f9a98a08daf86c78b69a056d5935f4609fb71fb4e2933165b6840ccfc03c26c3e68f31d511de3439586ed96083a2ae91a47c5906e5c31c0dbaa651a6dfc67bc730955992825e93bd5e10d436e75ad5dbd1733e5c9639ad3e87e195491598579a94836b8dd8ad2bc0d44ad8b34d0db19ee66894cd0e3f9c1ffbe8581dc40842830a625c31ddfec44b2f949162d29089db0ed6a6cc8f45a3cf38e3f1acfb2baf6c01463bfd84101a5a8fdcb63be876110b172c3ff8b9e68bc0c3d4926060a16ce04d107d05302d28ec8bed694323b6d7e0f0c7628960aea3d2cfd0bc16f38d71f67f8495c7e9699e1c974f69c95b280d4d8feafee6c0197341a9271b78d4613e3c240b0544c2da6d84e6cfe1415ffd79a45298136e4fd25441b19d32f120004ed49eb20cb47a979a7ac45eba782ea73bae7e8a5f072b5bb7ea8f108014a084e960706df44e42907b41013f4a136a52b0a41da724735ba22ae8f9085ab78a043041d9f8cda6389d081cad22e60d15244b7200873e7e0971092610ffcb292e0d18b6e5979fe66f1e45ec828adedf4ddf9fb8d4a25b2492140dfed5ad703734f94430585ad53004a4657dd4dc3339162e113a7efdd202879da0d4a0bd10b52a34e0ea196a506c13f49f3f844756f1c07123f905a03085bdbc650e70d933954b8cb9c7885961ee2434f50157b9bcbf7c49cc5db6a87537ccbf7cb96205758f01f3d341a90b689247b3a57c24d47dac7641f5a5d492c4c38c4c22e7ccf8d5adfe0a900eccf5ccfb4c63b664da5175b6402831f88d8144b477a7aec0f3641debed2e1dbf8b664b884196fb49188eb6ac04744c982c2a6f42975a61e7391de404a0f72c4bea964c9c49034f69adc43f515ac0b040f25c14a324667dc1ff418bfc80b482e8d6ba2da8f409d242b8b1d2c61c174d498828d036989a17277e2f5cb30d128e13963ffcaebf7887b720847336010311a32be8b3e2c2bf74ffde809813f9a0f92f560a78b5e9cb0841080e3c591ff7cfd0d61529a0eda9784e1702e192a5256901091ce3904f6412b6478d48939a3c0c956beb72396d830dc899fde92fa2fd3a792f9d482be2881fa73d9f81426dd19c1cd066ba13f9488724c6f56d0fa13ff639540170bb4e0385eb152b85d3749aa3a9c7eee6f812b05e9f7c57b81949366b192f8e95f84cd971878849976726da423325c0806e25d0f885f1dd1e7ffff3bdb7fa357ea452aa8bf1dfef328f5bbeab97dcf49969c385973a87a26bfc1129b20ea9895917be2ed436b70bd2882cff5bd6e6a0662bf2f0b833035ed84f5ab97ae873581eeb8f745574370c69cd12ebd44191ad7f2b3743bca26252e8544cda64a02dd8cf74cfe87dde6ba1ae88ebdae275d58bfeaae31556d513ccabee7ca6f670b0a25c178280363119274e65a5b39fc583e34747503ed28161dff4a21846cf4603cb96dff360207a701f82c9b1797fbfb7c4b0fca508335a82a642201cf2b38c4b8179f0801d5b8382963506efdee4ae7ce2d2b848b38f99efc3773e316fd8d5677f61b24f9470d79d46a9de6d7fb736fab7e5f364fa17ab3d595971e0e4f38b2360701b726dbe8cf33459b2960b6b2eff9afef1c378be0f36ad9cec6c9a98df1b096f747e9dcd84b94f03e68b9d106dbccc4a2317fe9e9ec19d3d748cd1065fc99d49b8849087796f8ddeab7d441db7dfc75ac242ae2a93978d885e8474e914bec5dbedbfc39277a8c1da5d193195cf87eb23267647b360b1ee2d0bf511bd296af6785972b249819445f1cfebe06545b127313d1029fe366f795b21098b65ca43621b25a002723532eb0a022c38dadaf3fb9a72b9fdd4f7f258193694bbf0174ed334ea1cce659fd76667f90986ebcdc6375be1a3ab130e1bc6d2c3d5a478669b896713ebac40848eacd9d186c4b27ff65da35579d25cf8f490bdf5f7534c8a2f5af4a144d2426aaff0d15e4adbba22b583faadc98abe3ac27d52556d0d0a49e82b9b04c42da43c136532ebeff2ef6ed69a2936445127cbf7cbcdd90ee0bfdd8629c1eefa9290428f5769a473f3124e389c567791dbff3ba69df45dabf34487d9e23be02bc9652b23a814ce2d4daa0e84d2117867e2b0d2e413bdafa78209e8651b050d61e97c1363689f030926b3560e46ec0f13d7d11660269899124d1a75caa976e0771143071ab69758e1a5f7b09274be948d0953890591c647243785667d6a8a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
