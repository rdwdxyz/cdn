<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"072f222f2ac4f35ceeb3469f38ae2a2d02fdbda9e3bccf214634752edba357246cb486470254773091751c0df1ddd920c66bf34b4974d4b863a04e035eb5433f9e09c5a8cabd0d0e3f25231762c7754efd590b3b1ccc7ad0abea2b8e372880a960a293a9980cf884faa287e96bef24bed552302179b55ac12f78f2c5088ec9137856c5eefa8252a76f9aa7b4ee0bda4b03fefa12808d89878db84d5e1b5e8e35ace5cbbd3d733871a0a50d7cd526e0e64b5108f20daba05363fb556263559a520a38f5e6697dd3185149ac7bccbc75a5e35128aa3849c5f190a5bff8bf92aa99372f90f53af6c773ebc7801da0e771274f1183db697fbcae2140f5874ea1a4652cfa0fcc25add001035ecaba25b4c6bd95af3773de5db751eff78f02b429deafccc295a5995586cd94fb5efb6b31d8860f922a2a9d92c084381c3c0f58f1904386dbf2b9bae1a7ebb0ab99b7ba63c09829f0ce2aa3111d334d2ee5b9b042c3a306b4b991a77f3d869c06f578cf0b7f5c2d55eda29eafe6d49a5c6adbb8f029cc64ac3f8bee1315e2146af99c2491361d90cc9d8e1769d88dba725d99e2e75020c385b31d7d7428eb53a2d578def6926c269ec1841d62023f486234dcb47dcc894438f36644d03d1b63d3be451597bfde8f25e7eca76188158eb12251950b6ecaca29a6888fb518edcf462a7aed60e4ad8a93c6cdbd3c1a8b63d3e272e256919826833583e218e4fe95cd85fe360a3cbeebaf93f8daa95d95b23c816522e469e67e2a6c4b66302af93deb50adc8422b56671a6a29db66ee7a6bd69900d92967ec9bd5a68323d26285ead4164660267cc7785303008b8e5b360b59c2995ef8ba356e8a2f8e4a2ca4d62710e8e9219a7403f10bc25309afd749396d1cc164b68d0f1f2c03203418e91be914d9b1d4d65a06d5cd1fc3b499df58969b87067dd2235a7dd75c790ff13b72ef135f138fe4bfa74500b36959f648cf44b7cb525961e016ca7e307be70a30ddda0b205e15b9e13d6af057f1f92f052fb7c3dd3281dbb3aac398997a52bcba9ba57bf3cb29c9b0af7b0289f5482259800266ff6c0ad978da7a4d1721dac58f632e84a466b96ec789b82f8816adf1bfa425cf82c6a2fc20f5de808ddb29ea6cf353d9e8d5da96fc652fb7f0ede94253701bdcf4395a5bf9343b4625e063f39dd0836e4dbd55e2714131068d3c98a3accb71d9baf94016924d9804d366a1529c38f90d20852a0e8ef3fb77e8b8f25bfbab5e5e541f97de45ccc817bd9074f1015bf674b29da2646f3c6a00a476c44259840195979010d12508a61cca77f024567889d0596978818a678d3268577a3a7c3b62e71956f665a5532053b4bee2b175907edb9086836fafa69c251577fe5efd9b748d1f17948bf4d99ce9ace3344aaa98626e7d46b9869ec8d4ad6afbd4171ceb47be1a536138fa26df7b87b7d5f60893c15b9bac49eb9e82180d88e177b44acd208b267e80de9d0191f1ca01258c61bb5e35302c956ec42261a8c771c0206f9a9160f27adbbb3d75606324a29d5630f5409c85bd91556795bec857a12a7e274465768a2328181379784e3e3f6ef5c44abb04ca1fe2de1193aca7bd01c245eb9d3ccebed5a5e8fdc37ecac666ad60edbd8cf625f9c209e16ec53f2bf9a724e4adb916cb075100b5149a148c04f211b7b1d277617ba2c212dcb2d9149d8ca847ca5955cdc928d153c4d8999dc2ef0ab9a43bf860153d37ceeef5a0445e6c1bccb048874dccc3ee34bf58a57e27dc38e7183da4198a157eb679408505cb961ca89b2d20a052923c846f8de220ad0582ebe97ac2894c9848e5b09528fdc64f2409915a56830192529f657a3a0278bb872b2ae88fb49fde7680444c6089ddd7b87999e2e01a4463235757763343a8285588f1558dbf97bd9e5f383b2045ce98b563e7a837cb33ca26101ce20492f84c9f536939e564159c5d27d5f47f6ad00130f6288918fc370e5811aede5f9099c9835414907c40348456f509ab222868dde1e9020b5d36c485ef12542683c265804a8730067e9f0de53d7a33120a0ded0754555233cff0736889c0a099b5c31e61155c0b55cbebbadd0cdf271ca835f4860e298e24b44d0b5592ed410379e6e5fbdc90fe5b6addc3a26d8e1bccc77e49c032db3d14bd94e53006dcac14dd6ee1d38a9deab29cc217f281ab3aa0e3a24e3759399d0d95e33c6280abe2203b91c834affc4b33013554f6dee5b6794d592be4514ec142b61eaf21f53f9245702bb1c5ffb375afe4e05c41e37f33e6eeea7ed237db64b84083de12647f154f63d135c05197788e013cd9be543205f746dd12b06b0eb3f66c3a4f35ce4bfb6ce49ae037f30b3e78ee7bc473fcc1b2bc0ed4cdb82a5e5405603dd2b2061c06fab61945f6b1ff4bedf7a6fdcbd6d85286e7ff39163ced6b05fc687a0fbac7896c9e2fb88c4bf22fbc9920c88ce51dcb0685bfa2303eda1633bef994afc9cb32e6f23addf3f4b3f9ff3bbf6a2f545050ef791d46548c72e15c6016918aa109aff17e864097bd5a3184052db10e05d6c06a4d5a469283c0882c09bb7aca30991048f64cb50836bd609c1f32197a3b32f77e94d6d992aff244cd27dc48c2301b498228fbf4a0241dee7742a07d80eddaae54806b9810cd8e42f49e5dfc4a3c4248caf3e83dbb88a3136c8e79c14a251d4a76002b088ab320b2c5696f77828cfac9cbbbc0f6e3bac0cbb7655695dd7072e20aaee243283261a7d4e446efecfd7219d039e0964219b8de2376bfa1550ad30b5d92b3f17fd07b5958f7557d0ef270b10b4227757e692c33e5be2af3d7ceb98374be0c6e8ac5f892795bfa5d598eb0a6e788fbd9510d6232893c673a44874a71b73f24c17f47d84aa204628297ce0be90dbe36f8903fcf79c2011e84038d5db686c4ed248023e3e60600de30d4d85830f664a4c7ab21b189afc6471fc55b109e888fff9feeea139d4218c1ba9aad354f00e762b32c8ede2455eaca588a8f2683095670b19d13af4f2b44de99e29647167fbc29e93c86a5ed2a5029dec3d27ffaee298056b958495cc1f74bbf32c24f199cbfb38ec28ca17a06ec8560eccf6c843489142dae5715049ec398b585244f45c586a9524323c9089d7af1c71ebaca1daa5e77f60bd27268a83e76295e28acb6dd7ae57e660ed3d98822cd4db85775ad3337d054b7dee2b4675a9e6b55f0378f399b5524133e4a9c11cd303d4d980e5595f80ea4d96105303c224378142b7e492c67b7259b46f0541d180709419ed15bbb744912a4f4c88ef78b724381d2244a22038e78c22716d8c4bcbf75691a3bde5f8dc13ab55460899107e558a30a7215dbec50075e72403ad790227c7097beb9f4b37cc9c52e22105417574819f6ee2ec8999b78522200a82c796baeb0f6cabb039baacdc883062956e049ce44d45ecb635ce77db884b41a3ac43d311c1f8496a50b6306227ac9b94d80ff6c38abfc9834acc3a1838f749e0595b1c84f9cc08c847761564e1c31e73ad297c11afbae698fb7b610659da0afa34da0e6ecec50454e3af9e2ede1e558ccabdbfe56b67c3224994e5fa776345586eb4c87f3c6993f3e60470e06cbc0c835392e5824a25b78ff8cb51967a43cfda65c1cc941e045fc82527f1abd5bc9f6875bdd12f238bbbad0de252132afca181299f4b0b622710570d71949fc820db4af20090964bd7437a013865f2e9f709b021f29a33e28c8993599c00fcb5716c0912271164171ae445fb9fdc476dfcd85c231350e4f11e67d74521da9f57f707f0e56c75ea79bddba0670c219b84db7d1035db49977a3f01db91ac2b9f9801eb2eea7f6ec9e07dbab4506a08b408a4b79ac06270bdd0f612b7ee6accf8ffa2c3d0c2d8274b315d81dbcee2d4ee3de403ae757816f2491ebd867a3ea8a5442dd8df12d40cb6a8ca5b5ec98d41d04d6568d748442d7308bdb38916301ff85c277bc66d58a1a72a54eb6fcccfd8262ddde479e55fdd715ea47c492c5860a81ba19f91aaef383433d260d509729770fff995f5d45916e558a47077ec645297dcc68b0f826313412ac4c78c0193c4af02014d34f52953bc270e178e962110cda6ca81c1d12d6f15df674181d52d0c37563adb1f6a223eb2e43b8cd40e4c6daf1c27f02cc41177a46eef3bcc7049a926a45fad3e68d9f490915a699c99fb3de914268d8d1b261d3ed0dafd9b5a7506427179442c606d36ad5860a8a884aec9df05ac73807fd0937adaef7c706d699eee3861579f182fb8c5a19bf2dc3b33303d1a2e3932e68182b89a0ac00982b7e70149b38eebc65fb69615deaabcd79723dd1e193e42364e6147924dbe9e42865e4d6ab5e09edb5cdaa64120985fd7ab44bb21c0ed642fd75c5eaf9409b89d011ab0f8779336e91971ae576b5130ca65d976a8fc9593e902404d521f2ee42092a07a18d75bbfb0cc144a2959b92cfbf316a48f1650d4055c09b0107e6d5b2ae73c646a2e93d1f8eeb54c11a3b44febda00701d77dfb66686c4930ae5e1a60f2024c47d8bdcf3ae76c1fb3fe2c1e763645a3602cb9dcf2f1d1fdbf68edeec0d8b2075f78cde22d28464f104c07beb09ad7d331a4b9e82ca5bc263da2b323106d6446febfa99dff0b49f4e3fcae57ba7136a7a288231f9544dfd9bfc76dcc5c9026c7fd2ba04b43b85c36c5ffbf8fb9927ca9dc2a777b2b39d4e54669fc360003092e3e6498de3e050447742e8f9b913910da35b34c8d4ff1a873f18d68c7e782bb6da35658999694d31078e3599c3f63cb7e5feae9abdc80f48e32780178bf2547225bc5967837a8ab96ffe1a347e7ae1729e10977822fa5c17f532aa86066d312aaca459e3f42ae9a0394e241e99d9ab07a6930273cbea82b64018b6eb05ae7783184fd72109896bcf4e40de80854421d712132be3f77fa564ac96bbba402875336bf2d5c4678e4dc15f7c720d2334c92b39aaafdda66dcdf9b69b8590051a98ae7e95ac4953b146c28e71b17a960e270054eae6b153835a96f491a5222190cee7e92343a293ebcbfbcc7846e8ff1d5749213de10ecb6a41b2b01fa3624231b5a11641ca8542d0219683de3e010fd73dc0839635016b701c978e15c1727ebb1c35d1a83c49d474fd901e08b9e7a2c8b8d1e7bd9bec289a9be69f77d84d5bee93abfa8e80ae90ac732537106bc3b01034bdcb99dffe72cc7089fa24245782c32b7954f53ed608ba252998e95ed9c8649e2679bb2015b272f3b59a0a67ed216b5d50e27555a7fea9f574107ba3412fce072b2a899169e38f4ae690d7183d7e60efeaf2594203c05b92fe064b93185bc10f003b6bdcd866b02e237266fafad98aa41709d6c511d77a70d9fe3877e4949061d6cbf71215a5ca61adb99e30682d3a52777f5437b53e6a86b467154c57f0e543168e8d851e541270f13a562c03c74b7bda2e8cf6492bc9b45edd8b337b7820132f69ebf1967b004f353786b7c9e02050e9c78a629e010bb27d2aa6d3920c6d4a59fa2ee68304a06236b0ef11959aa3b2a8afb37b2bffd3017627425c241528df13fd0b278a8d3e69ffc041b9aad1cc2e683b7738261bc77e734be89b6299a97240de641a92cccd0ee89f0d15f3f1a0779bc2bc8072b8be7323f5ec8c20068b597a8560d47a3240c64a2b2a354666ca514ba62c734474e7b9711d63ba39b79b65bcf5a64cfe97c71838fe3400e6c8c9524c6fc02ab96d51d2aab2ebee003b32ae59b6f4266632ae266d3f5e1dd1dd0831817ce2310cf5b46f8adb04d7516fd4637d65b68865b848df185566e978b1256b87b7afffc5040d42f4c8df8ebf646f5f01b469c6e49d59d7dd8a07c5dd5afdad43bfa9561b244ed8d7c1215eae2d1e2ee093c4324def007e9ad010bd6f1a028be786f5aa204534b695221e46bebdc1cbbcd43a32f12064143a022421468516fd83485e0f11f11dddea225e4a9e5b8defffc4bb8d4eb6ab6f74fde4a89553af22d5355a5b6420b6a229540ee1cecbecfea7b2b51e21a586fe99ac9d98cdc57520f2d4e73e32ddc1967797e8a33fe5405f6dc6d052a280a8520c6c605aa1691ba24d7425c443dc2a2c5b39163128af0d2d0d4dd29fe5da154fe856166e624facc42500129b14baf64e8654ad9f3586e130ffbbf4dda3e05ded7c0ae471ebb5908bab90b5420a0d1e5cd04479e40b37ecdd69647608190a78ae3e207c60ac68763925238ff452df0337ffa4d686ab047f2aa1a4e865af57cb38c4a5247ded2d0610324bd8f311584cb818ea1cfde841932de2f2f7326eabb22efc7e81d9427551940bdaa8d2084a991a37727cae77a2298206cd509699d58f5b69a5a71f6669c46f77a924127f30545e262d06223ba8acd7e03b16378fd583b2e731f535c9e8fe5a85f19938ecf9359693e683f556b919e5d3b9d109d2af4b6d97bd6af6ef9957c07938dc3fe29dde6cb9cc7d4ebbf0aa3839e36d266e086e5b0efd7c451287de9f4c05f7979fa5521929dd18beb35acd9cf4e87bb856503c3340995ebb0d99a3e7526ed975e1606a9ba623dab2508513ac3df09a45ec6f3d9db01a593a77e9880521f4d71c453f9244ac75feb4a840142e04f155e26aefdcfc61b41741576178ac684474538f44ff9fcc447e65fcbbbbaafcb1088855509a7db9b660ab702fe291512d0c8a17cf6dd146aa15a2529b93fca7a38dddebfa163a17f14c9660fda64d1806538890841d248d5c973c8ba440ca8f5aa992a544ef9fc363dec80d60b11b8ab207c0a6f6d78b0b6bdb37cc35139fa6e86d7e1f2010fe242baee869e88c5798eaa93ba0de077b919b573897b77c2cb37145198f0c6c1b6ee7da4e2ec880c23433e2f74d2560c43f54a075b3f1778f98e8f8a8bbddff71c1a58b902aa5e13561689d97763b53d07c9d80b42ac2cbf46d11cf3fafd9baa0496c3f9fb3055f17dee31f0f8f5cef2aec48cb4523062b82140f1ccc2d97377df93237ecde9ed20bd833fa9b10d8a163a3eb7682dadf6168c8c6446b1e6b8ee69eca1e71acef4434d4e27c9a6145a692bfcdfdb76b447dd0969c9791d37fc02c849ef3d749f8202cab73ad3c22b9b46e7510deec569b9ce865e05c1ca5627b51424661f1067053deaad15b08d379eae52b433e020a5fc6ba8868371fde1a88ae89a611eb19a39a1606f1cf757319e079cb548537cf3e6927025fbf7659afa26d3817343c633cd7924df324f59f40b8bc39e4ae17e53aaa22dbed0fe4db854ea644c3c22e184c9a37652801703d4d908fc66ad0dbf7f9e0842f092fa5943e017cf2d8dcdb25cd217830d29b47f636726832a6d563c1419f529e530d8eb40240e692c483fba7514f488fd9a0af85a526540e76f22c64d3fc07cc43386d34e39b681e468f71131c6b2b0ae87b9c16fe5918a05b76b7c4b6533147662901f85c7031bfbfe886b23ebb987abbb9efac462b1dc26d9a24bfa77433cb87f6a7d3962c41f0281a90b8b7bc831565b4a6af638e2b5512f03a361c517c53b3cb5485aaf98646e1aa01e8dcae0756779a0de662f221dadfb8e445c296c7e17e1254f0ae0da95f7c9247b5ba97f99b3c66a8731a4cd7e6a8d7979854228c54ccce6634d42286e37f32a584fd3ade44466d70e9c17678df6b1e9572dc752a0ebd95dccf22a0dc2ab0bdbd45588f33e954614292415f75e44cadbb26bc8b48dfb52db4d3149a814964b52ed8d2a12d90246b30e842241001476ece0a2986f9d3aa6494b061acbb1a53fe5df1264ed56f535af79ecaf94dd2153b3470fed8d35c4cafb6e20320c3bbae74d5b5b84a2af231650ec4a57a95a1325e4b1496558e306c19234987b84559d61e0e2d30004fa9183bad503df0db57af0130a26ce65d8ead7c0bd354b1044274248c9d6ec3eb7cd6177f1f7fa7b672f0ab9a11694c32500b0afb75e72eac57c6feb71cd556f8654d7cb89843334e6cc3c0880ea44a82496aeec25bab980ab7f36eb94bc72cd1ff489044a92fe5eb595be1e30f623c45820c554a1fbc72fca657cdc0eeb00e9e357db05d6023cea73002417bfce6da6feeea93c8177126525db8caa35574dcbbe9b0d8045121cb427cabad57569b648464f257f877da0df417a51bdc4a23f366c437ae588070d4718bbacc71583a65435d58c6a7bc6b485ebc5671ee2d1bfa0aa8b150fba195813e6aa745c93cd479817f7c2a1d91ee59bf20b5284596f8cfe8e7a48d55b464a8536f677d71ab25f374cdda37dcb258197bbb436e2c9707e9bd9a518fae886c1aabb94e501b5421e132b13129a464de7e3b070fa55443c34ada1ebbbaae761b842e3b5d7bf45bf87447833707b5461adbcadd879c7667c2cf54053deb0f546b18384abc286cf2277e8ad7fcb61b7703050439bf628a162930567dddc46012b9bb93314893e3940d007fd96b62d3b0b11fb85873c8f31003f83d986c82207b59ee03c42fb8f632cfbf5c63aa6b404fd691fc47002520a65c32d1fef1dba6ee188a7e2cec609ebdbd88be67b2ce5637c209431b213bb731426f6c36c84094cdd3aeb6538a8f54dcab3472d0ceb14dad9dd6f203cf1df0938c7a8ccf5f3e964add2f2e44f04f90ca0c90411664515d0993f85c81b1dbab9d708552cde1414ed5d3818112685dde66e554f008a0b3dfa50b440e67c0c52b56bba4180fbebe8bb3558e6de38efaceafef9eb11cf27d755c44022df0f043777452b5234fdec505335111afd86c25def84331e2efc136b0bf08e6b97564f7af7eafe16a33fc5d43e6f7337b4e34f39c4ffbc48b7899426b5f8c067c6a18f59dca0dc306f785efa67befa287bc080e02c9791a76518f3ea65e7d1daf3d46583026fd04c0e518e5111eee189a3a6955e659ae9a9096089625b2caa950cc497383ccc96904247c891df1da155e09024dc3f35afa93e6ba5304cb8336a410a77d06554a722b23882139baeb76f6f3e312b6b2187a4d8776d5688df40a5c9255b477e3cd5af510ee8c308f98c269f1258b4296dfb0f1a441e12d584240ff4bf55690ff201bbb2e0f97f2e743b2764be7de057f843782033077790b760f8f25136139a24b2d4c577cc48bb2d157a44d8eb0db64630f0853e40c80c4484ee17f67ce19866fd66422481049b320a417f81d818b45f73623b23d95171568bf3ae7e3e26fe7b6948effa58673c769cdae148b303328f6e4bce88215624bf90ebfe8811efbcbd249051278fcd47a927f73e1b67c2bd78b87411d4072b421b4c480d3d40f86f3e10f408b4f0b4912c432ba17c26abdc9a8eec70e7a8ffa9845a763e3f6ad8afa7dce1f6b8bf470a4cca06a014fb7393e163fa4ceccd24f5de29f2a5d858b13120c10333941c75e119a21c893d280177313c5eb718baae1c7b106736a6dd1ced951ac81809da59360e3f59e2116841e840ab5b89276c16cadc773a92581318a9c6c737b8a1f0d6b248c25baf934ce9eab656358e879ee87a76abdc23724c1044fb9d3df6967357fdc6f9d97807b10f21a0de2a20bbc0a20e936e7e7054ab601853a9c3c977fe03caded0322670406f8fa3efd505bf79f0416ad21f63aad94d137558ba66d12d0ed69b7f52520bf6694a0a8e48c18625b92ac67abc5d1392a0cb5ea1e52ea286650b9d7a2513d0d4a2d8505a0350d2de278ab58985f72edf633baf6c9356047db24eb1c965021bc1abdbd28606047226e3d1c1b64ad1131ff29da6d972bb43daa4d82c60c3bbda9cf98afc2577fb77dcc3538908339d2891de9ac10167a63ef5554e7ffd4554ba7a17797aa0001f8e6501efa3fa9bb4f8ce1c4ad7e90d366506e7d3197d556edd8305c71be2f9c64ee256a78463863d2fa5e290f4eecfd39951d829e3be26677d2696354cafc764a0df62cc03121d3084e391f0bd8894042265bea01b75b95525a80d13b71e5b898b27394d39ee88dc98f219e092f75afffcefc11203898ad914839796224c6e3d1a4087afaf04da7ff5e2bf1f0fbbbfea8837fe28d99adc8209b450fc42d7be5b1fd6b48228cebcf174f500700026520bf5f77cb928572fad6c203b0ef8653a3b1f95e311e20be31b04873fb88d9fed6c0c0cc1af8ddb372641e86125a732bb5d400b9f2883f79c3668f1e18ae34fe78ede31447a7d25aeda275eb133cf32baa862baa1b681077d908b469d18fbf718d5aa5de29bab5ddf62bec49697f25c90685206b355d1aae1bf81e04967b71acf3f21fb9516f0e0d9738967aa6c7a09e6fa3a8abcd6b09979ddd8d93586f143ac39042e6b3521ace7c5b2bd2d67a41f95333951b1459e4956cc3157fd9ffd4d7c39da130c0a269fac3d90548b1d9713a922feb08c06daf9d02c08ce433b8f88b861ce652ab43ab6ab89e15e62f3b01b2e15f8cc83eece0c63a8f921c2a4e7427e7884309d4706c417aad1a88edafd435850cc0f09c12e210669d935c1b42d04cab8ac51f9122f382b08d506d025f7cd0fdc1037bf3ef73e7c76a15760461e193e8fcf272d240397fb391644126b85b1776eac464146d78254741fdb6d3c3b25666cfaa6982b88d7e74bac4a04c6bef99d1291b607abf2c3c9d52ba737494587fffc6935b8d40b6c914d417feff9149e77bcaa8b4f1b8a3a00c399b46eb792a23dd4acda39183d8c7aed6c2fe2a1f76a89c2bbc0c1b718f87793232685070a221d6bb62930e31f5fd43608d0265d4e32b579578ac1f954f6fdf8f6bd10998701a7e63936798e498df55759af93991c000ec4034af3d1f8ffc56e4425bc21bb583b6223de0eefbc650b7af012871ddd7d3475a4300e05ebf74f5431a6598db0856d155e65d9aed878155d5637fe50455737d1f0be5c4d1eede708f8b5da13b4977fac1f74f1c181b7f35c3d6f39d9c03c80de1d50d08ce2af37e72f8e2873478c13e7c30e78e94d7027ab0a4bed5ef865f2575b2b8b4dbc7e364b4cc267f2d84c83ab2b405eee886fed3741a927c5d9a132a5b6e4146b7105915087af592a92cf5f76686221690703f807b577797d1710464d535ba67c21ae4e272eb5cd1365ee3b5321141025d8ce467f0668c30f9ae2af1bc991471f0693102f98c76335f3eaaa8ec87410a33be40abbde06ed1b3c9249883d52677bbeedeb718f659094eca309b4d66fc1e09adaf9e5ee59ecda3ed70e2190204dbb1e4ab552ed3d620658a0625226b9d0d8d09237d74a052d21bdbafa49de0d07bc8e5019f79e71cc34662c87493d6a67156d327347416d6f23021483aab5baa64761f4a6f0b7065ea1ceb641d575676ac03f43716fa27b84c385618aec5fa50e4a2281f25aa296ec99c5c3707afa5975495c2ddf74acc9f11fb626e9fa6f611ceade26cc77215286c215eaa87bf2fc64cf6ad9b62f3bb730b7f9061b32124c64ca2f926490c6c8a81e0e7330ef56f4e5e56b9da442ada60e1d0f19fb47f8bdba92fea6ca7ece93817ea9595a2f5bb9f2c186eb40478cc1a11ca625780670438ecaa94f7745518305285e16fcee4274e475812062deaba358037e77e295e3b70fc405b87670f96f6a44fa21b78d45a32f4f3d9bf1adcc17c0884d2dcf86fdd1543c06033a1fb7d370d4f57911fe0b6e37fb4db16956a4192f0739215331b56baa8284c9c401fe71e6463216fe47817b9c2c30087a8fd55c136ab0ef802acdcaf8a07d40c6f53931f49a3526d4d21ac9bca0f8865b4568edbd8231fe8d67a0f43d5881d5dc078c5aa636a65c89ae0477e4e5f9d9a9b0a5ad45722c545fd839d1f13323ebe4caac085326800468db0850ecae83f6964dcd96eecd1098eec63f58f7e890f280a434eaa42be997445bf879a09c4c59ea88760fde7cfd7d16d4f17e6eee6f1a24fe50e8fd54ebe7658176e223147e888896b0cf93b127e37f1ee041ada72f141c940a541cf9c08c5482f6a4ba943aee4e98a595687a67cc768288a86626b9d07caf33da923a4d864f10507aabf4dfb8fc812df82835d084325b155d9544cb364b9852fd62a01c0e7880aa43837b5e444adb28fc30742330df380d6cb6111584b5202b0d3385d93c38ff9f4e63e3b6f2f70ef428f04be1e620c61c5714eede805d034a7f896e464fe77aaeca422ff69ba5d5c59743c79da2d2f58b7ffcb3e4e8396d8ea2477fe033a6af0deb78e2b74eae4eb03d7e6edea6604264fbce2b13c7d5d172fcec622e186b7d5323b7c5b29f75e5dcd4ed72f70bb2866b9514bf5ab0829bfc583f1eed14f1bc4d568c828f62d6bb14a8d58d37174f156937b3aec1d9ad56a3e0cbb23be2f6bf99f91358beb279e40fe4efa1ae006e0e2a035f63f34a94a267692bf4eeb24e166e0cee19559e34ba41f357a27d39a3b123d1c927567085ff33ad205155ca92cf3163c5713ecf0e3cfbcaa6a89408adcd13484d4e7756dc5edc823a211fccc26b14f99cec8d58f24f537d327867e4a0b58b7f116c64eccf1dff3410e6c562355e6f1f817401e67282825dcb1177cda2583a8262a7ce934886efdd6b90cf06960300611ffa4106aa1fde3506d08a77f38234a3409abb26ab9c80e6d6eb2e635a72173b801baa801e396e69551c5b8f3e79948ad74edac77f768415f56d4a379cb3723b4adc42a5ac23ef01c9ecc3d787f95a777ea698aa7e7fa4a3a4601b2c4e056e439a8abb4f2d36446c42955bc772a64c15123823d264cd22b8904cc5901f4fec6f0480cd379e370199e51b138098499561e3996b36105898dcf33898e83da2df42d80c438e4547dc8219938d23cc4b0d1c5df0892c694273897daf2423ae91275272a8799bd7a5c63879bf4a097976bd1889c04c79d6b7f6db7e40c59645aa4c208554d7ee9247ab9a7acc4324de422f70907b494a48ed5e2834281923b6f39e9531f7ef4aace1a5661e9c77cae48e3a80b0c8226497caaddfab87312aef78ac130d2c913d95baa08c50eb21163ffe24e633ab926126638cbfb4a928441d2d26d17d102afafea499183b340784642bc65bdf8cabdb4b7ffeac49e8a8be69a8eac0f9fe12506408125cdc1bc40db513b2dceaffbce22742dbfe15a17eb83570e9939907b0a75a313103b034646bf5c16de03174cd63c364c6539d3d1119830d26897d45bbefdeae2de591b69cbc61302e29e56f829db409703455fbf44d0ba989a3a287f007d074a26cdffe071e2bec243e6ce26b2675e2edc11d68e0f89502f38efa91c142d7bfaecfea1b08bf0388bfafa09f2f37a02e557a0200c48a7ee75f8b28958afd53d5acd23326378d81216bd0e34f5b85d3c9f86dcc5df7af7bcd2d19c314044d0ce11b596454f51536361b999971b09edb287d6155a4da829910b45d7202508bafa55b3284a74549da26c09064a8a77538e932df79b807b315d9e6693c358337a04570f1e20ce48ccd13c3e01393878201a240e262e51df837e82128f2d8685153b8a92c5c143a3d305491a8206a31b9658c00aa2f6a02a7a9d84ffff3438ddd00b61a175cc7eb5d427748c36e77a26d3e58ad1f3c4e73fbaa3d8bd65984a046e1ed22e624711baaa2a552dff3c2af006e3d24dc60bdd233fe85d001bd08518eb2211fd9419071ff35f6d64253697be86db5114490e6f9aea7312857b9333059aee0adb288aa221c1ce89df261c9e5540fd7d841c74a9551782d4a89781ab340b3ef46a506ed62f00398749af42adcd4b54b7fbe4b62ed9b8ae4e6f3d19f0c9c716ebff5582c56e5e555b700061593c7701b7b755edc82c38b78b827e0b138e2bc95e7af90b7c2e320dd8403df0fa739a000b2bab0e08ee9c78819c80d0053c8426d0aec4902bba580c63b3c48b1783e7a33806485a938aa195d0d51591e6772d780e7a3b4a5ca59f4e85995b56390b0069f85c461ff364bb6f74f2deca968688b61c35f423c46158d000e493b67807679c5c735bbe7e15dbca145f98ef0ba1425531d0f0ef2bd0268399d665c61bcad0bb22a87368bea56b9b343628a327cd1fca324edf4434d51f4bd896ef7d112052b372911c59ee4509805b06eec867ed1acea6c6ffb5ab9633edfdebe8fb55031dccd7577e89fefe5176bcb4d1be1fc32d559ca1f9a11d2587653034651ccd4cdf55d2af0da63fc5e906235358583c70c1606c225bc6b4b3a040b1406bd174369ae31333223f93d7420d612644c8b559abd4ed10247ae16f01c791c492e74a6369d31c80e6d37a09fc2a9fc90eb2d6ad16b7b49d9233faf9f8c853ef13a55183aef5ab03e11864e084df98761a3cc43521267b313f931963f86f251a8e99321af4903babf46db3b3a2d9f81e2fbe02d27b5d86b379b2b5e614abc5b6bdf357abb4590f99ad88c63eca9125d0ada8909a5bfeb2441cd2f03f5119cfbacbcb3d28c3721c9a5f4809e4a6627d0834fcc8c896c11649c40ed1a9862f0d128184226050ccd011703dc2ceca68f84321b56707d312642df1756c93d9aa4268a7f49281ff1af5c3545e43052179f38ae143e7043a717d2cafd3cebe7ba89183c14942f2e790af116743c277aef974732b081b6b0436ecebe31c1e2daa5e08a6fde71b7efafc6f5d66e21bd70eaf538b5150ac6773babb86fa4f4c8fe78bc3eb61b293ce6f6fcee132011891b93c41df0c3cfb4a94932f85c5307ab136c8e8330a4b8447544cf17ad7343cbd3af5a150a8188df0ef8eada2af033b6dec394534f6b69aef50dda01e33db0311b3a2c9e3e0d9f034816f51cd2e9a981d4236a0eb76482755684ff4068a59c78342c54d9c5270ecd2f2dee552b2927bb1fe60a9bf8b43f929f0017adfc879e16fe18f9bb1c9d2c36747cde74679a5a469476fef71440e6e7b4502d725e3face0d77aaf0c69eb8cec5ccdc753a781c01cb57192ee96ddc4b9b937143b51a4caa36bc1ca816692355b4f4b020c4389e879746099870de0822c47b4895cadad2a3ca9744bf2ff2fb4ad4c06ef2b7932c470ee756294af5af07b72900d3f29b403eb0be3312dcf34c0885600eae967b6a00bb6002c0c2e6b05a013bec3a75ea9386aa427fba4e9c33272c7d7198c5e483dd32793774a541c955affbfadcd9ab9ef0d8c47a68832c735aa2caa3819f011330164f053af4e1fdfd5db47c86921652c658f34dfe7d661239b95a7ebad5504a4aeff4c090495bd50a272f654830a7b183dc79fb6fe0fff827b1b4d1ac34931d516562d42601014c3c5944c9ef78f4938b1900f415ec126c3f888b6ac6e3f490895630ddf6d218d93c70b66074dff0851337b30e50d3beba49e5b8a721945d634280612b1eb94d0f35d2376006160d094f0a78bd910bed6afa2a8c9454f37a6ce491db162a8ccb4f63db82e9c5c42886bf3ec56f7cf3bc88433400dc6fb8b30e135888e098efabbea8077a0c6cc5bd3b104255e53cc9bdebbee4c5cd45066c755d10992deb1e763bd0c21dad443a1ba1f02029497e92122468b2f41a2321a0c6f930650a81577dbc6a9e03eb21894c3fc44f49361319dc157cfdc1d4280001688ccd562ad6c52132ab59f47470962d08667b3d9bedcc78f0bc41d5dbd03f7b3f1baf2f6feacfcdefe25e9f7fc1a8fe6643e26b1fc04e905cbd6fb6413a9d2bc715523ad327baff1bb34ae877b3574b40bb3cf6ebeb0f2fda0cb6bb9d959b1db76190a7a9f623807ee9abc097c344414b008eed29ee139b5b6e381e6b2992af9bd58ab545c91faec759bc154f6f204f0074106bd0c42a988d5e7792ba989c116721d592eb7a68e6cdd27f50ea8388b742865ee4d903c93e80cea66d08197bf34e8bdf346d2f4b458d41ccb26b8d107d1aaeb023fa9f04d75f3256da1d328d3a7391f42d0ac3da9d1eb32583998de10afa23af5ec9fe02ca0cf4559c86f3a217261d09304a46898063d5f1e254c2df09c26badbc8e93f98e6f21a73dc6c6b5ff7695c87f4a556536ea4a411498ed443e1da07beb5038cd1eab3ce5e682b84637880eb8cf6b572448665e181e1d56f5a19108b8cf7bf7b4228967ce3e955e495adb06855238ef4b9a550fabe12718b522420978e84b248da4d9d77374d2f6fecedf12865cc4d0ca5b397eb892f910a79d439381748e3db0fb33f41098842163243629d47fdf64811f9735e3dce868810aba5231989bbfb68d64047303cef33b8a1916c3745ce2c8e688401cdb3e2ad08c1ff309b71b1626c0df7e89003ddd2fae5936014235f18d271e186e4132240c89a8b8f791ebfc567839fc193ae30328438616657aef12c94d94b13deccef1a62d00a8f1616b98841c88e68483abbc0e822adc887cb563d5d838d5fc22020f4fc31c37b1f5bd8743e0ea5e69a20de1cd46974d35069875592f729a1270dc7c73d3fcdd77d779621ba9df6f18e628b83cedb63084a8f06d023784f5a2f96f778fc92f8c16f8667eb8cd31aa445dfaefbf54c4777699b83966ce31b625eb0328cea42ba806283906d98deb370f7a591f5aa84b31251aaa0b44e92bff8e50f76da963109f54dd4fa79b31f9435b9648ecbbf42918a4f2acad5cadb1ce8e651c5d87f0083540a56c8da5b9ba713f011cb22ec100221d79bec9484b6340ce258a8049a4d971536ce9efcc76b860d5e584a2aa775401e98bd3b94e6f42e8eb5888e6845f6c84c02ddadb24ccdf8ca0687d8a7f7ee41ef1f269b15103f3beaa97843755c0b3c7f2d3b84f0b2e5b0c11a40043c78f3c4d0ec180b95010c594e71de3c72dd1b257bb0776ae0a63454d89949e95290a3c7ef71273117b14fe21280043ef1a4b517b6b9fca2dc94d73ee4262cac59ec9d0ca380c046c8c1ebaaaf4ecb7b77eb952f155b143d92c526fa6ea849b0332cbe9f79c856239f691771ff42472198fb90f5902431e62ba618489ee95076e944b52fd721c528fa1cdbf0e262b4cb7a9e1adcba8171f08601a60552b73a2c6834c92a819a567fa72cab261571838b0add867f149a116d84570aafeb1186dc5f1d025e40322523770cb38e63f7026a463b3587ae2403480c42265df32eb101d55ba10c25914f7c4fe70a5012398101c77bdbfa52ad7cd8c258c847bb9696fa5b1dfe45d82546f1e9eb96f14114b172c0a151d4c9fa7b87b86814d595bd07eb58b8f1131a50abd31e7ab147b4b5262e1cfdb84164bed7b543841da8683388c1a304038f8109b01842f26c2b77981bcfc1a52db578d25accc27bc06a7869ca07991ff3674ba60efdd6c3631af1a31647790f6dd352ad0b53a9170f662e99b3e4af2d71c88b794fa90592ea86765d5dc58a41ec1d95cf854f28e4c977709ddd17a109ce4b5f49e77ab199071b856fc131e21eb804b6d8a67967a34b6303b87f6eba7bc06c266616d0f4ab3720da6b1c692ba929e85525134f21ed20930e75435c128cf64ccc48092b74b4225b863485d268986e2165db750f0a3e77e1578975a432192065921cb7892a378b0e759b41871554ad3073e680a03e2136295002a873f6fbb2de198ea4c196ccec55b14367d9264349496fb8a0b0f8f27e74eb93e5d4da0805c85328f8881e747959a61ccb12d6573bddd8b4c5fc89dbd1949d73f4dea91c865a8047f6b02f88b8aa8ab9fb5097a0ae503ab3873d83ca24e5894a9d5b52a1f1b5fa6e8f4a1e393f34414686ba1bee52c1f92b779b674c55f3ab2b37c5147c1c8a85e2aea0c01645536d6374c0f72e0738b024c97dd3e387f16988e395df8577e26176828f85d3cb4549e0fad904bc8d198a9cb13ee541e1e98940df454aaebb52973841dc8c568166545c97878a967e86ff9136597581d11129f1c5127d936aa3513641582ead7f7ef4690b9695fca97af610ec16a74d077271df0c4b44195affcc1ce07726b2c43ab3eecf9b02ebb5d34cc767d9dbe74bdc5ff850098ed086972c107b6174c0cc96eec176f16cbec247c30c929fb4302f49bfacf036e7f5aeba57c069e835fe11049b0b717876216246047f5dce5fbf635fbf066ebb80853752285fee1a7436c57f7853b6675e494380ed38ad615f43c5d5199e5c47a89158c41c1c68dfdb28cb7d7a56e81c321197c47ab1cbec2a74cd9c2e79fec90a9e87628c502454df095108fb518c10e25fd4d151cc684513802c45d43adc2bbbbcfd84c120aefbbed66916ce809e57d1d5728c41","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
