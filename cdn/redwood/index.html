<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b5435a735ed75fa7aea979b4a48ca59cb36478f91cb1ad1c2874c42b349180fbc911ee09883e0665843f98249773f43a1cb50a4b78c0b57ccc5852b7fcc06c02c646cbc43f5da06592782a9cd410dd50de841a229d879cba65b15bb319bb4bad2227ef832ae698e2a504140bdee8fe42dcc7ad282817061081c77cc9269187ea7eb03a39a8ca1bbb57ea2e47e48eb4dd0739ae6d4a1974409b9c464dc485ee0216df49d85737c51b0cc08e460008f61d8e664a05f175e2ed38f31d6a27b4aab7ff5cb36c65b8d75d8ffa68010cf29eaafd4dbf5e8776699e7cc684ee019c4dd5f0c4541602631752c8ed4c3fff0b94cd9f1bd7952e9bd95e8568679da6438422a5c5c1b424462e1b68753221b56743d51e806648ca9b80d1e6e9360af2a65e6c3348beb47cfa8a2403f2a8da059071a2f5f64fa62f8b9dd095f82ec538388732d9de89f274006c9e7be1b10dcfb9df5e5bb57c29cec9ce2af732e728603d3cf7909c240d1fe4cee6f35d8e2d97ce0ca91dc859776cd2ea5d0f1aaf49045d5d6286a94fdd7e758d097d3fb4dd472c3d339a0b13a62595d64b853f8a607911380e43f913115474176ce66c065e5a59cc294ac785a092561c44628d88d61679450e29b99bb6e8ee0ae770b5109d7b157dd32ee5c86d80a50aafc4db933c6036bd06c0401adc9b7904324540b43b6aa9419adf0f3dca315c33c8e60c1f5644b691c7c5c77419fee63fae6dbff8de8203bfb15b622bc67569f64668e5fb5d0835563118a3c8d259408ffc0b54c139684be2c7110718594acaa8016c368838f68d404dbdaaaa769b73a339d02f833a4e4bd7f419403895c8c48d9c65291007fd7408dbdc8fdab3136c3caa7597fd10aa1cee2c458bf2b8710dc47b33a2962ebeee07f52555167f231d9aaa645a2dc6549c4cbcd026082829c001524d469e614148eae3bb2c20508ca085a797ceb64318fa44ce09a09459601c678219b8d8426105d395f56717eff56feba858b1dca4cf33f8039ef6714f36f452eb5c276403a58269c410d0812140f7c3308de71c83411be859bf3a518a8342b23775c3a55ff29c684a9ca6ac6d51c4d1cad2d70103a1955b10ce4c6aefb655d4e6e30d4c65223a31407718fd1bbb64c6c77bd750a9a9563384c787e0fcc4648d13cb22b66a4540bb05218db2f223c9a68054f8503aeae217121aeb40edc49a679e760af7811ce5daf2d732d3941fa65a4facc9c39f0fac6672066706a22367aed71f0c1e4ef241ab0d2d321d248c57f737bc089f3b76270a75e0dbbf08fb83989dc706c4b6236152fb4863452ffe89dfcfdb94604db6d90562a05cf8448bf6896d15a3eb00f36340db803d0ed7aee38843dd161de6c81031b007c415cdbc89302b5d922a0b192a9f587c8bae69659f9cbed28ac31466bc22303568c2b54b40376b3e1bb53bdb4a0b104145f162d557b95ea8c942f2a7f58e2b9165c148879d2cbdfae7100944ba197c52573b17b4b19ece0fbd3107d44cedc29ec0866a9818ef7d3ad204b07e188466006d6b01d873e0af80fa54c704dfcf346e079eeb0d9619e13076dc43f7e30d9f12fccceb625e9f9542c0792122114c570040a9ce5152d62b298eb70550260dbf41e15f50b90d0153743e866e3af1907b9a37afdb288e7bdd6d37a9e702dae01faf93eb901e1a41cd60d8fc386b98a30188c3baafabe605021a2deb45d8cefe88d4022fb1b367c6b9fc1c998a34ce1fc135faba14b3d00e9dc0b4f633bd3623f13030ba64ff36d3bc3b19430e1406144627141c27954c0792765135db6e9aebe2bc77fbb03f059bea318adf43b63720ebb9f83e2002b2c12670d88668940eb1ab4726647ab06950cb6029f6cf638453ad08318e1205f2f7141e6c3726dc78b018593024cbb7ad410a20e80e6db74a4b703f8021b9a31110052454ef603b9d1df4224d509c5e894d3ad04408a0997c3521214739034dc4859dff0dfe4c8764848e58a6f688339ee44f5aefee9be53e8d811b1374eb0c2c8fcd3d262074aaa494e1de5d90066a7b934ec42cff39d7543ff6c1f3c268ced765c4b759d22a8d080252c77dc9dc01ed834fbfc829a4e54f1d35b2bc87cded9910512b12ccf0893d5ae6200127092d366ba952a51b1bf8826b211d715e9bc863c33db2f35f5f580c71f71f361321588914d9d969486599865c014c89abe505c8b330b39642f0fcb0f889d902151726f2d7c94787af2caca700fba432169069e353524860c57ddc557e30e3fc2584597b54f071c0109980ce93d2dac96a035805ba05d4a1232a7d467289942fd16b4ac9a9bbabb2dd7161c624b08893b6f3576ebf6ea74c28a858910ae7fa13eafb6984292efefd86249fff9a5b0e4e32720790a4457a72f245efa2f0e1f0655f7d7639c361b513c6d5800b69d78c9af309e5fb930b21991590c7a2df4a58bcf290a1c156059dc04133ae1c47150fcee4b7a9f781cf29ac1fe610afdd2ad8e6cd2997f9b28eb552ed7e4cc6d956e60ef36a2b0f90c191dca867b406e38332e07965bb33e2594645a95eee6db76c305f475620c8a23f014136a69dd04afd2547e93a1faddef5aa8ff7def9b565a794ca1ec724bbad2deb5d736528a4b86c0af36425ed4c277fd0091251b4f51971c54fe2a27a7c3a8e0648ea061ce9d9301c812348cea4faa8c0656607c401d54915e78c01736ea2bb9d50ae9e01c045547b0ebcf904beb82235bfb95344157ff0d7689b9b5b5c2181d03be7eee083524b140436da7e117c4c3542a18c33eb85e8cb9230f64ed231c933338f38417129955afd65969e56151d15c50671587a6434d1dcb113708be316f4e4a2c0bd7f9f891b40ec0f3f4ad83b251b23695e6227a82177f1f6de9a7e0a9ccfdb690616ec27338b46a0d694937f18074614d22080fa97211d1d39a673f64b0ad218f916e5587fa4c1f12d84f5d4dd75a73f5126741a39e5be200dc01d8170a3f2f0041335963e0769f56156fb0c4e8304e8a0b5702719b81389ce40cc68d67d0588c7f96012161645a3c70e01e06bc77a3fb8e3df29854465d92b92b601d1e3308826c138424f6fec991c63c3979310cb6bfdd715a8786695b8089e4f914b8bdf5bece7497db43f24abb7aff05d7bcc7ccdc038a878dd6ef16876e43dcf11936c21e9df5902e00b3d53a7c8bd01d14c702bee56cefa9dfd4ebb99ca256935bec763640411d5b350c13e33545f49dc7d06c7d594c4a36204beb286ef4221e8e4f10295415f7cf753b8a8b47c2210f77b7eb3f8acc4da62cfd357eebf75d751bdc8c8a255291bbc1914669b4580d0e9b4ce228a2e53d04383ab420fd6be48967056398742d448e207d7dcfc770b23259e5c30ebf4b7b62d190f5c2c25e2b5617b0d2770cdba5874e06819dac0c3def82a4b1cca4bfeb721c9a4c40305e02bb4d0f7fe25925c0f36fd1a6c6b0e1f8259b62c99fc57d32ce8414e6bc35b40c5453c5aee0ecc49ca8861f7d5526da3cca9797205668db61c738a3dcc10c2aedf644e0e22c7bed0cb1b9b86dd92a7ca8d362b31b5449faf975d9a36abfaaa9ff80ef2182aead227fe0f3ae11dcfbb8dbfddf910a87e871577dffe0abc633ea29a1ac70405fdd031e6a0ac363b8fa5549e1b1d401bcf13c174601033e08e5127148014167bfbd881019bfc90b4afb63d0e6089f0daeea9b85b705b3b2cf52c75e8773e9fb05467009508c02824dbeea1f1a76ea7bdcbbe2b866b850510c9e3bd144c4b771e85be981f477cbdc4e9f14c34a545e5def98a25faf3ae1e943d06eb1f912e0f771853bd49e668535b20ef3d315dbe41a1710e0866472041218676b37ec12ececce4850a2e91c7446979e2ad32efe2e2909b9a88851faae06ea628e9d6beb3ffb3a54cf80359fabe152f0e49475f3ac36b41d47c458315fab87ecdac5e81b6037f810d6a119b364395bdadee8e8aa381ba9a12eb76c9b73e51e117ab70fa1ba58a30db24f9d1b6c5ba9abdb33912c48051274c2c4c72c2897d360464ebd45ac31088082e4d97b4a80893955e2ab49857f8ac9a0e6ff2ce6431a1ddc6da57f8643130351559c1fb9095d08a94d7f0fbcfb19766b5f84b17b51aa851490dad7f5e8cfc873c516b0807cb6f753cc43d188d05f0ed51e25f93fcdfd650188deab29dbbd51ba1a875c0abd531e7eaf7c083b1cdc0b6be7624642a113e9f7864a806459490f890a4299e8ba8d199dd051d44d7aa87eb6f4bf4759af7276ac768b84a6e9ae6b3d4fe0cc836e7e5bad61731e0c3ad445fdf618b021a85acb581a288c026bb8a157c02c68c5405a3fa1c73deec0c250e1ebf85e8448339784b31c70633cccfc7c90dfd93c954effac91e5f7df32ea1f330b84eb597d1d4f81f8d85c581a2b24f6dbfd0d0cf55c1fec20c88a4edb940206fa555d76f9adb8d8036641dde39d0acde250606a197723ad70436bfa6a6f96a38d0981988a519e21cadb98a19d57809dd472ea851522215c937555a61cfa4d56f466711905d8fea9b70d5209bc0d1e13a89e7207975a303f56f83416cc2dfc562b33167520d4f6b5eca57426a9562137e9e5ded37a26ed791976fd766aafef5ed3704d6accbc3e0a01f95f2106ae9a2bb7ce93d36ca3edaf5b0926462432bb294a9a7eaa259891606745b923391a6e1d9c189682c67c97218415a6a5804624ce7ca0bd22e52474c65f94edabeda0dce037a36ed7b0e50258a7f098cd8f12801a07857e91af6ac164e957c1dc2a029627dc06e977d4c9e3536dac6f2677cba46e432f29e23695305a7f0ecf239314f3308a1f17c67842bc595e4cfdb9e2d81b8f0b46af29bb67fd1eaeb1f803e0080f11e7a93b73ef1052f9ef33dacc6c068e743e671f2576991803e8647c28da1441ec7acbb1fef34a8258bbb461f21b688ee29515717c4bd605863823f43d30d773f4477586ae57876b72f2e2e9de0ffe295efa1a84e4e65e952789f05b11ee0dcb2198e6072415e0238eff6b58bbbe72879d922c40ec3086c3c211207150fd4cfe0362e7d6c5fbb1121504bf48779f8cbce7fcf870dd79a16c10e601d7aa16a91fae64a9fd8d144df43af9a92313631b14399158ed1166480c9f19d7dd6e1c2dddb73adc03c7e8810e32527417d1c7dfc1d9eb020b6102623a4542fd2c0bd07959e79c69041aa121f1d6d724e559ca95fb23c7c0cc68e706b00a94a358fd9a9f1647a144cd1df0f8bf2b63554f92c2ab042bcc100e03ae85fd5390e057c052f18e7ae5cf4a4e365ddb1511abeb8fa6a8cba5e9e338b7bcb397cc621ad4b6077010837346137860588249a59e37a205d779fbffbbe7247cc2aa56a9670af616409686bb041250bab2d3a00caa379583ba7912ef890d3e0a29ebe17cc5cb420ca5119bffb18e6684160a1f6b6d67eb227ab603de4450e131e6088868869f4e79b29ff1f65c106feb8c88d689161db3ee48826fa838915e6986f9ec88227166a607630c73dad8fc93ff840482dac7b9fc55b1d07a2b1ab48d5151f6be00a7cd1381c5371390e6886add54c2f1026ac3d05d7a1a6f65fcf47e64bb2ff949c1200f0f39cb3b85b565cc983a6d10e868dffb296de6e00a49d6f91043035728f457cca7ae031e8167532ba818c551016cc8620b49dba485daa7a0fd40fd8bb5d4af5ecc824b99c389e8b9ecef38676b4aba426b83044ab762e8731e3f71025cd5cd16db5bf44b350ba3e423fb3817dcc347fcfe3646bc3825509e8b58a62a630c4826af686a8e35212191886a3f3c23a823d8822fac3d0f7a132354cbe4b279f4b52a5506e14e701103883fc306c5794e4025f8bc644789498d1711b5ecf4e68af26cf7330005d55908b51e8a7c5e9665265288d89e5720e75d15e90e2280f0e66c7aa6c1d57b6661ca5a9120e0f36197af3051e0e6dbee470f08e0254f3526995a89db9d39e636d68dffcbaef5bc6a1f40b892a8053f05c332982fef98a929f8dbfac8efec2560da78ba2bdbfb6720190364bf929db2b1a6cc1f3f1e5df58a4f61603e9ab013623767be09f6133e6c48271c7862c49e2595933d0d3ccf79a3eb9db4f92e449ae29e1603f3467e76687c0eced442ddf49b8c49d6d42aa552c1ab03848e3def3f2ebb556268cc3eb1d24d5dd6ecc1176d5d56ed0dbeef4cdac4a554faf3b819c0c3c0a44638fad59f34940df4cfaee5e7d8c280bded1af34cea4710df0789d35bb50ea9b77eb8b0ba215a5b0de930f0811df72be8ddc3b00f29bb50aa3300735c6778da758700968ca575333eb59d659369d481d618d1141a878a7b529f0df9fa83faa2c3e0a48738b163c3a18aeb30eb9abfff03a15790052f48c4d05d7d91ce0ae5ae062f95df11ef60afc4a2cbcc914cb93b6b7fe67f98bd8910cc673f53aabe2a4487a836aeb59bf2f0072e2b1359ef2f4535cc5f5c6b31914b4c4f8583244dc0ff40fd5098b911cda11eda6ab9b84ef707fbe2090013c55eec067d01f489c80253902a6cb53bdfe49ac50cd3ef4bc1de8104c0382d99242265d64abc0d56bf4d3c7239074d6ee1dac717a254d27011b3c41fd1fcb94c3faecdd1107b207b93ca266a14c47f62d1592f09abdbddb4147b56a9387c574e0be325407e25bbf801cf8d350e502fa9ad8a80b395450e13200ac29aa8ff829b1faafcdfba84730b0e66cf5dd88da2fbade697f95a920f5810b3b8f80f14e9b07d49c5cef415bd39dc7132f37a61e110994c9b41018620817cefe77fff10d404bd456fb54a226bb6bba9a9e37a5c085cee300f64fbe65f3019aa85a4f784c7198df0f2dd6745622cc76761add949b1a8012e80bd585568ead990e1bd914abad94b2d16f5d5b5059b619418e7a9f75afa60f1155e4d1640beb697f61f8a47782348ce2f836fe4b5e2e5e2770c6ff239d528cf728f1e692642057d2994713909593b21120d16a626ac233f0ff4e1721e5adbdafec408eb3af3dfacecadae2df9bd07518fdd559b92aa6c5c2050faec16a58f65e0331839fcf04b93bfadc12b370ae28e31d8380a73159c6462384b621dccdc263d8e1aa99640e99bf721c0698c94577715d62cbf0d2a93d8754ec71870c89d4ce70b230bd3afbc17af29d8397dee96ecb60d3ef37d8cfea136f46a5b5bb41fae02a356e7b1baa02c90aa3e2fef520a032e2128eddddfa7d28a7c874e9127a92e4205d5825724770f8a4053476f9fff702a45d8d6bca43dd973b062bd8d03f9db4604ae7fa847fbbb1463caa65bc69cce91e6a67268b13afe5556bc9ece016c844c1b6322b6d1662360dd5bcd31e70801c19dc14590950ffed9f1b7be09bb32ecbb5a9dc06080144fe53f6c77c50c32eabedd767d711e6f2a2d5624a7d773fed1ffd8ac5df78cad3e6d0d5b1fb241864aa8dca404312b9417488f3f8c3022c19f4f4f0d0a6269675711c8a2161eeae010525f24328836fd4b92f33a8e8b25bd9f4486b1631a2e1f2ebfa515258af0be400a634ab3d41a4dd0605bf685e2a44fa1bb60eff228bed6e7da8fd93ed692c870379298fb6bb69e4a4f9864343963502e3fa7032f1669dcf7a3785e9b90204c7d94e1f896f9dd62970f9aca44a4175cbce51261db862660b61b9a9017b194cdd12b0f5028bf8ea2f53259d660c9d340c1a82dea60263c0f42e0b60ae2ee00d9b737f8742ccdc6b66f10354b0ca1ee84748cde7baf8f7557422578ee217c09d40be90d5df4c90a228dfc14d4ab5df548ee389f1549c5c1d7946b8a25470a26450200748d346cd91241ce8af99606cba3a0356d699a6f93df1e8d050b723acbaff60ea511dc11a2c14c6adf3bdb2155843a6f949540ca582e647eda21c86e82c29740a84f9d5b446c5fb9ece9c6c30754e22a37ba1d0a9237e153bab78e03c22d445600b23284ccdde7c35bfc3225fb5efdcdfdb0a2d7b47af61fb8feb1b10c9eaadae0105e4b51bd31ef8641ea979823050dfc4a099cee61cd45140cf502900173b8bbffd4d85a342340b61d66a8dee2ac14702ba5aa3eebe06b80b1614ac758f1700646de50b3cbb3869f8e70e571ba15704f665d3436db8320b347924dbbaf4940a9e4cb43490f1bc453c8572230c410c084dd0b22cbd6135d98d77c753b8791fc58265df9bd196010451ece1e12130bf65b0755607c3a0ac4d21ccbb4dfaa74b9fdec873a7527cac953ab03a829a54601b30997513d7d2e462efc616b6a3d996cae668bf9e2c5ef2e56f916f9804636265762ca2671ef2672055c9ee69079319e4638fbdf070cf7cefca5d78828793463b5f55bc5adae8b894de870c1b155dcc54aa2fe5ec65a39e59e8db60e8aa416ea3e12230e65c249f1d3c72654fb6a1a4a23b87683b1cfcf0e6160fa97cf28059d209912216ccacad4f56af1920fa09f99463604af9b13c6f6c90a1232cba84ef11dd8a3f69ac57b8c0df7d26b18416d6aaad1bd4b810585bb5405a1a3df8840a0c54fd5954aed6c1ba327d742615ffb8c624b4ba2559da8743484c07a4c1ddb642f7a7a61542683ae7c7c30265233b18242801fe411dc1edff3982db31733d1226c6f306e526c1c9e61d5e0b78fb32a873ebb33f98b8ba6026ca393c975bef256bf2c96248b349591154387405e7ad2f4ece3ae6dc98f6531b5718cb63f1e87d871061e24b669ee48a6adabcb91035527ac7e72457285b789df165e69178bc455c8f11623f7a1d9115766bc846280112bb7d0047a2a9e14d45ebe2aac8001dc6a956fe87c619340773223c427bd87db6d82cc1f6b567933c87ef709ea6e3058e6ccb50c3bea05ee9df4083db086dcbcfa1ee1c7d6210e61ff597a87986ead3c79128ad7d44c411e7deb8d07cf9f5afc29192e72217f91590fa92d1f1d3057eee48b46cd36d0e44a749e01abfea7f3fac1c1697632c1e784664647f69838a76dc820f5f92f1d7b16701bbf3199211ea174e9870cca6495f1066b72a80c3fd5096e8580e6dde3f3e6182b14bfc3b32cf6f7cdff08f983b8cc51dd4c972b48cbbc0395d6391229d9a20ead50124d57f7d0480f33baa4ed6b55de298f33c2b542911c313ed2f631770fb95d85ba0e99b0c67e3f32eba0fa3589c7ac1e0679e16c5e79d7aeda27154b4454e8e9d2b9d3c60487b530384459b8b7f6c965481b89162499b7ea960d3e36f79d04f4b53ae3b7a6c01c8f6b912640513f79fdcf76ff82ef4c3525eb3abc189b305e1b2a10fc167ef421dbe32085edb0157bec6d9b13d127d90cff4c5de86bd2e883c7b0de1bd4a9c9df56d8826fa5bc278beb0d2e2866c983b86b6aa3586b8bf92d47337cf7cecc5ae8acf40ae668e82d7d8aa95e6d95df8d2bdc3e94bb6d1390d0f61392adfeab4240398cd14d2bb1eb8eed5f22dfee107df62e6a915be769a607b6cb89377190fb8ae7925c3395017803bcbb00326ce653bbb81b45d15add23b7a8e8ce0b2a5f0ddfce05f8d11aa5854c660c44ce6f1ef584a27351b29a4beac1a4767528f1ae39f5860a33fb95cd0a91a3cdfa6d22c565bdce34af9cb4ba924ad9cd3f22e1afcd193c7f8b5e5ef8ae89d316e8cfa91046b00587c4c009b66d2748eb925f0f3e26ace22974936fcfed3d912959bbb9b0498c7031dff8a736322ddbdf1afb23c760e95e91d31b019e350a1fc524dbc5ea344e4d4ebe04a52cc06d7252702f6c05d8ced44b1dddc2fde5095be627ad4c23a65b5718433edb3aa8ccec336372b1fa32159cd6a451ffc8a7296a234423f1a6718495b57bba64cb3b00364a780d683d0dbcfaeaa2523a5019f23b37a242e6480d6fbbbea7bc60059ebeb75c2f0a2f593a8eb4c455c37d0ca33c6499bcc58622ac4b52b1ad2fbe0674eb98d07d029ba1dbfb9794b73e46b69d1ec7a2dbc0af8ef10a4dc06405f69a047426a236d733f3da1d33b984c691ecb1e8cce5b450e73fd9d706a821b81f9825a70ee811ae7473523d6b45e74df4d9a25fb336e8404e545b1d41aee8513b85417d687cc4fc9ba14368b6bb2a44bd2350bd0c6dd16d97a6451439ed69f862d3232fd23eb8e2df1b90619c2c26b07e3d8ac469205533cebf11f34894add4dd66072eb9921c9edbfc14331e4c55d43b946e62e1c05a5d20e5d4cbdbbcf3d2ec9e9e936a65886673cec1bb5662ff293e4c38f109fc1492ed5c843d854e54ad6fc3b19880d44601e298c508f37efcf506cfa92dc946a5828a0c077c98e867da82d931d4c8c8a765294c7e6545f67671cd789531c822993fc213368c0b75a83359b683024aa7f380de08d9a60c14086bf185234f997ec5c39bd4d8ee5e18f8328baa65ad6bbbe98210d361627a39749ef07ddc695421ddca1351b8a8a1434374189269a13d4aad7aea053a9f654a6a3705878c5bb1fba70300b10c731ecdc66984df3b9ea937f6802e8f0bf2de912c7d3659c3c987638a832137344685dcb6a3243a3c9f254d6adce98d4840ffe25ddcb84955e8d43966541d4fcc17568823905683364c4eaf29af38e77fa034487822240c3d9cb513c9f0b0c1a2d588b5d7d860b792f296fc8b17d309c37489750c05b5051725f3945d6bbb433ec64b09e3d98747d87e99ab3067057767aa583d92c0a1bf8cff24aa879126a51994b9a9d31f0ebf169b350d52ba0fb326c619e8977caf901dbb37b1723ea105ad035625c540aca4ef3f602a01c2f6f53ab23744526f69a13a7ef4af1770fdc928df856a580d59de0de6a87cf4cac2cfaa9aef185a74591f90d65e3d6090d3be9f0f50a94621f0a8a4b893c2880ac37101ce8e2f7abce1ed157686b241ba4bdfcc929becfddf0f102f1d662f3bcaeb681d730ad7f57a1d0fa30c89422385dbd33c8295e262fe2ffbbb9fa166f0c82ea0dac68a6e95a41236f75b9bfd3ed55d6c5ec4f52f3d8fe900dc39867f4581f8df8fb2ef5c75d64f6c8797dfb4a7b2f65d68e06763f1a71162a25b560c64e5e81c4f8064c1629d2e06eb0c24ea98f54ec86c6ceb8a9ad42d9b8078edab6e7a677e93d0c702ad6f88e39edf93114482306fc8d1e8bc6a1484d3c85db137b98d8270884003d649622c10c31a4be204e477c6b54130b1a1633cb64be661fe1a40d5738fa9132bfeb2859487c9e47b7136bb6034eca1402343ede4327051fe887118f67d973fd7c40bc2973e43ba7225183949813863d6ad9af163b1a498dc15e151476d88a5af82e93dbbb89b37664c78ab07fd0e94baf62a75b668282a3bdf1ffe162a690a85650b24178730975e921939220bdb3965e9e50ebd275ef47f271a6a0f1c2573b9f89c63b27c9db4ca7a45814827fcf30135a97ecbf6ad4bc50d83f5441a29406777be3800ee23397a17730a89d5da43304721ffbeb16778b159351e935a759da3999fa2ec677921e81c0a6c39a42aaece6091ed25df184b972678e606a6d201e36cbcbdbe10b270af2d651a2d6034f44e905e44dd0f2f8c64187efe26c5943302ce7f0deb27da336ad50ad5fa68def1afac94fb38cb0b09ec2f2cbaed0ad97e93f181b9a2166895974c3d76d08d0a4e8b613dd4879a8f001b8114adf93d24aaae78e23b41f94e9276eef76c8a3fb029112cc2f0d3020fd6246f7404086a552dfece227dd929bc566bd4b646c7bb9e2503a98ef82c314d04f195c14e202ee5084a6200a80af7669ee71ca5f20a43378d23a9ddf617c4cd0f92a99698564300082faafb9fa906c9a817e61672ae3a14e984596662e05c5a46b6dd61ca3d811d01a16e6674df216309591acc192adc6687144630f3e82781892f52a4e776d47e3172336f5af65c893a24ef68381795d7bf783cfcae7d545c14bde26af2d2bd1d89ffd46df2d993975e9efcdfe8d0b12bd28b6d1e238025b37b23d0c79e5d6bc7d5980e8fb28cf8eeb69416cf9a94300a46f8c8757f5593a9f26479294233c583dcb4de45aa45d461915fb9aee553222e029fd2ade4374ce4f57322455b261d9105a467431f7e135624843b0b5f638707769c7cbcd0fec5d333b8a63ac2e58ce7f9a0f312fb1f9dac3d33c2d2e1f042060d39093b472605a922c10c2a58ecc8d805c9498b983cbe0f5c7d7bbc0aca339bf939260f3ba6d89dee1571b4a9b7aa91595450bc847c9efafda882639b3166f21df4d387ffc888eed6d38d7cdc25c183ebb011bc4f5eb99dbb57850da9ccb28b1478b07f9c36290e52c9aab7499d06dbf7acc1076dd13be1d32730160b0e93d1f28d8b41c9e9fdab0d8489537b663824e3ddd59fb200fcf80844159288057f6649ff913fc00f1807090b38f30a3b6d21dea8da41f18e4159b063f7fd7c990a837d635316997be464fd4d13a88a45b68aaa718dcab0308d7e5e5e3565041cf7879c3649453fbc6eb28ddfc7dc646a0f9577d0906ce2e344e352952ee74498be24169bfc31b75bc9c6b4d421ae7e7ceb58df1f847439f1372fdf4fad66075c8ef428e92b480c1efa810b3a22a443e6cc0148ef50d55acd9dbfc321c400c3612c0188b2fe2309fd0bb36461f0aca6f61c679aa16e6f6b715e360d6fa532b9a33e9c1e8cdc65d8361f8beca563fe78204a9164fd0d4ca6840e7634714184a8e0aa23e0ea7531470610c90654ff34ed4cb07898f7ac728426108d7169a67fba30e9d368d228ee0ca98e1b20f068b36f00c9b71a9c36578ecac626b679447ad715d59aa0510f6fb42c03d120f7fd0aa926f04d8c7c0d3e2c96e46d8032b221685d4cb6c18eb20267b149265f7246cf849760a1012e0a8ae3a0367e9ef052a41642db7819b874c8ba1b8ea59865ff7083dd0f9ef5279c307cf94b509d0c28ad4dad922186f5f01b9580e88c9534bab36e9a2b0845ad5d8eb80253dca7e0292a425faeb24217d3264ea7adb5e27b64689474bdf1f1b59a27ab378dda73488af8e5640bc50ef6ffd90cba9bbc85233fa4ac0794df5814d33efa5f415ec23512de6d2af1312447e437b6a0910d9cc3788192aec5ef2fd4093259ad4224cbe646b0efbba43d955904c3c437c85fa5319e92f9ad4bdab4c8bf66f7079a2313ec22e067123a2af9c369beaca5098c3419b9355436e92f97a2dc5d3d7a1bf88d2a68185249245ed6784cf86f5c4c75d06c03bbf11ad5ca08fc7c2ab174c7de32915d1946b081757cd8e1474092b57175e9afef175aced71b2db93bb467009a81af3a70eb5045c390f905fbe2077a9738447b85e9d9b0ae6ff37a9eb3050003cc983fc26e5e8371bd58f0ae7c9f7de8a3f9bd725126276038b59e39b81e4eec9e5700d95cb7fc54827fd46fd53e09822c4b468fbd7d269734b79e06c2cbf4dc39aef7c5efbbdf42d8c2ffad862e32ebe41ea8ce295692cff1b47c1e43fc5375d4932fca250818a9721ec3cf06aa2d4a8129758ecbf4fd09908884e1783cb3f4ed5198c7d1b9fc74826dae2d5baeead9f906a6e4fe730e70dc94759683d06ee2015b76253f10eebc42b8f97849dbed58f1773945c46f0ab188e9f41d347b978f8980983168fa4c3356b267ac127720669a90a3eedac8823ec8fda363aaa1645a0466a5c2ff0948135a8d761609a741635d1f56b29ac87c6128a357142b83a0999b4280908d7c63fc90ad98de2dcda24612097662f1dcc553952780e604cc313b5eea5b203806ba46a14f2419ca017a33856e5e1d346ce96be5e5f7327c1ac1fa25a586813a4d5d08088a3b284723f8ef4cdf6ba2c46008136027c931061c2f872176a90e738fa886dcc878f6678cf6612bfd91bfa815067d3444a9cae71fd08906dadfface5e8f85986e899f3320b36fd0a585e39123652ab47ea688492ec88d47418c545df71f826867ae30dbb8adba550157ce1e195973aef176bc7f5790693cea1a86f8013523e9e48b84849535f1a06de84ede57da8ffa7b6712a00a7cea2603ba8a7dd04d552fc02e31d5a03442680106a97729aa5e855c863499a4036657b9ea82cfe0aaa470f4c89c453dabfe51582012dc939413028f07c2de4896a9f21b4e39fd54f912af774404b7ffb70d9b21793b8d3e7669b9e1b561e35ba9a8ec61971963ef45ccf7b4da6befb16afdeeed77ad4a890bb23a1f2300e1fbc1cbc037c098d69546810a3fdb587f8a52e6e134ec7d5f64b19e1378e05977b970b2277d4b357e2ae3c5975f7f94836bf92e2335039e5ad50d22c7eb8b2ffc4b87a7b728134d2f6d8dab768997304fa34492a48335be7bb9be4d544c9ab5c95d640e38e9a9d23110fb584d0d3bf70d18f39772ab021746870cb6f36a93ac75bf52157cb0b866403db7135be65c3a09791677f64d7ab6203c9bef2fee1d534c8562ae2af4191d09601b186c2388cfbfcb18ce1dbeeac8f54ff5c09335f8ed717d96bc8e868cfe5acb6176638507a00e9772ef4d89f18e33832d362d3ac536ead3577e6243ea3475e41862baf5d619210bca40b764ea67869ece10f5ee795b5e00188a9d67333eaffc8b3dd87e96464d5cc41475a212e8bf995059b5b46aa3c9e381f510e2c171d62c0ae0ec08b3af7a22bccb175d6e7f6fed89657d52714fba8cb56216fa216aa113bc701de05e9507c5addcd796350419f22ca1acaced835da969e3a06d752d4a84060565749a5229a1381e63f3fc9a2b7c4024e4943b03cf7e3d457a2ddddaf36acd01dece12a135757e3e0d22917b8c3f81d9893d386916ffbcd9c257c2b2b7cce0c60daf267b62f4f7ddad497c025a0d66beae01a1a865daa232583a11327435e25dcc25e6d0eff4a7ac3bfb9c70d7f3a90ec79a95b2dd5066fed5f4474cf2d380c5c3c1496972bc7cfd49ccf73ba805bf7858342c84c22c1665f2afc0ddc991afc4d82467588e17c3f8d00fdeff6dd2848700116ba376156ab96d7dee78908524a98a7408eba541c689720ebf99d4ce14813797c6374d023b1c32ff22664e9e59e5d179566db86911b75f7874e2938712227626125bbe320a9551a0d259dd5cb37a2ff2fb19749697427453c2c0585f9dea9c42460463df53c559435f18abaea2d1f26315351bf5ab35d4b98a96bff5685385cea25e6e136f24e51bbf3cea200d1eb4371344239f35183fbae4a7bca1ab16e3aa1a9d60f396ca67166d5e68548e7d4c5b622ae3d474862cfd99d70201b286df8babd9b7337809ab8c671334dc28caad9e6772f62492a14dc7a2d3fe2ac39e36f5bc22a4576919cff22675872c901ff027890ec40c789522d9bff79aefc8879bbadc7e82418af5a41b0f70088189822d6b8c631ca7dc7db98f4802c2c85c4ce433f60fe3c2e0f42543b7f135e5950dbad4f770792e66dd5993c879fa841bdfc94928a9d26c2552997a72537e630c3ff84f26d608d231cc5966c2f1c05b3e5291b9c3d52efacd1753ba39a9fe60901c1f560edf2348511eece5bc06c51da73a12e666af1a1d781f6110d59f0b6490155809a08c0e172b74d2659cfa244a166ed1b4e1b19a9e5363a9fb75772535d49c579b439a25ea18e8f75d9cce8472fe1ca695fc2c52aed0d67dc5d5e8e361820a49ce170760b7b8eb5ef360b5c9511ed8372e9fe50bfd2b89346bf8fd75f939d327debc69e23f4b51fe63710a88e663c4451fccff06df039cc2d459c29afe4536f6d11e0632c32ff4d65552b8c10109ed31593458a5eef9b36ceefc3e4c3a728bd48ab27d1318b4eee3a69f16f2f56e491162de0fdaaca5f6f987418225d7c4da8be78d576da5e8c504ec4eb36eca6a29651a907a2ec61ba68e04d7ed46fb1c2e95644d6f9b67ae86022cdc29d72f1fef87a067fe1f87dac24a7f561d4374d2068d9c1211eadf94dbab7069e47791ecfe2062489bc391951f7a32923686363ff17039eb52a7300a57ee655d343b2d2b0611632cce4cce2ca9eb6f09329a25e2ad51a04dd6db5ded831a764c8fc66638d36febdb691be0d23335576142ec99e676aacfebf4621022bf5dce62b28c74859c435b4076b57e7b08badbe45a51a1b21e15e18d27b133c0e8446bbcac52ef285070873e3e1ea013b5468ab4613d21ae4b3f81a7f67b74cd0be9b4e04230c97a27e1969bad37ee6bc790a12e3628676b5b2093454f109b79eae0bfb4ffef872a155e562fa71822fbfa447cfe1865338f1dc263ab78db73aa399ef8519b99a35190fbbe4fb4e4661eac69782bdf555aaa3beda33327af08a680280f577c45bb55f61cb7837860683730026eb100e30b9eb2215e6131b697be3815d0782e863eb10ff82f1e6d8d920cf08f5b705f39a0e87884e93fc3bef4705a17f62bbd71899113cd6044df74947918a3f267f83e751eb6d5a5d5a7417a1fc2799a1ab34eff2fbb8afeaac01715e1c94aeadca2330bdcc011d5919193d8ca232f312c8ec60fbe78b0bc007570fdbf7a1cb50c754f3704bb986d721d845e9a750b2355e29da0b8364abd03eabc90abe887901d807b685a80b92ed6d9a06de30048da772b796b6c5dbb294678c6bd039af52d9af4c81c6b902b636cd002c2647a30611f80788b59f73ded8652d5477424c2e4441c88117aad3712deec8bd3da7c938df92cb537cad29b3cb22e87b82adbd2445054de11365de6e18d450a395f580aa3d80f06aad4275b867336a9664ad03a673223da9f149c9b609d55d21381d8f480e05d4cd31171ba571c868fc77d37d6d3b79bc3c4545517fae5604591880f9e99994fdc87f0c4fd2feee345e7733a0ad6dc068e715283220f3ee29a5e0b50350fb022fa8e6f9d8af10897974d74915f41627732b2f5d6f906a402a337dc0d29c0ff0c4d6ff36e7234e2b7277f8a35ea2e8443019ab921450646f7badd8256aed8c84e44ec248c2429d521ce8c4b3ecdf139bb4068f8ca1c024ec7b13235f7a8b987b8d9ddf4dd3c4085e1b2a92b3ef5164321d8ac4bc0ed5b4d9c29660f5783d9c2ea03d558f44e878b1ea2617bb6d30a245c008d53827d7d800731f0fb496e659b2a20158d8e04a486669ede881eff5fdef06af37ed5a273855d662fbe3480bdf230a120eff235bf143a914b5fe6555d5c3aa45a9621880dbbec8aa01c7ab65df63f6d54652d84e95eccdd912a367fbbe4e0c0bea9bd0793630e0cf1b58af7e42b47c2ec2200daa25831d0a2b4032ad50b8dd8a7d2ffd8f47279cebb9adcd6dd52d8a6d8db75bcfe109b4de6ce1ca3fd5be9ce19ada3a95b58c96e768a14156ee38be8751ae95fd474f860704dd97171d49e2ceedd342d9d211e1c527b6f3bb66f11119236479eb9102e266658ecb1c4090868ab781999006b6439c80035bd3d4724c83d8ee612ba24713d9fb26bddb0310c10c8546a5278edc96bc7b323255c5bd8ac4b0ac48ac8b6c5c922c1c6268c1747124ee7a387e0f7e321ae9bb92f93c6388d083fbdaf9c81740519340c47d3b06c54b44e4aef494730da6ea6b45a911d19fd1b58cf5915cb44a247440f572ab02a994f3f7fddcb07adeb1853ecf77d94e95ad66d4c5b990da610a2543af7096a9bab38101ca116b83291479a3d0ffebd0e3c42a3c30479f78ab42cd71e6daaf5be4d76ff9fcbae2fb0916945f8b0455d65cfce51b151b8ec38885086234879913ba09226904715267402b19273e72f4bbc549126653f0dbb1eb29bc6f4940373ee3e4fb713455de2bc57f885947c64945e5591c354fbd9729e291e30845f33f88239a180f557556be57572fefe70c466dbb2b83e9cb225df82c042d6e5e81980890084dbf366b97066f087c336d59c44f6f60ca523a549afef54e74c315ff2e6f4bbdabbc906ef87ec3568dbb1a8a6a66a1e5aacc156378ddcb5940dce731fb32a37354fc9ff675e77a2a27d3a35f378315fcd5b3ed2f35862b147ea2d0c5543418d58479ba88ade616e36ba92d47b8687e077bc4f6d280a69e38a0461331f4029a3dbf71059656ffaf202f9478d6864e7b561c8928bff3c9b91de65cb199a4618e80ce38a77fbbf674644644ccf493ab0ac9f94b276c2427a351d78ba78ddd1d1c14fb93cc9c6db48e913da8848a25d941e924a523a18077d1066d112dc1659d978b469ec7205c6f3915921f4cb235015feee0ff7c5582efa9ee888480bb9797c3631c4553c41be96dcd4c97b6821470a6c3692b5b8ad16d97dcb3262ca43e78b9f4b70daf76b6ef75ba7b406d9e0df328d2c629d85d3ef5f5f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
