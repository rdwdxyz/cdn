<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5126edac9753a4d6f3783fa38ba5cc27e7168e89ef313f45ddf47d2f2077f02512c564bf7fd1084d399bb8363b2bab539f97c2d7c3bacdc0b0ec60b618b46c5dd32cd21431fd3223c3abc21a2f293515f7716bc9083c3586f2b4269325e5800fced36de493edfead20e8899e60a83b86c1650bf2372d9763804f709b698153ed37c732323c1a148b272485ddf1001a52abe684393878285832fead9d82cd94a0f91dcf77de51b0d6a7824535ee65af1cdf21851ed58761d04aff2c6d672ab66aa525fb0b29c15112c7f5ee295439d95d82bbdae201f793635137f32b4edafea02dfd5b1fa46f2092a9711d54eac42d7593759e4340de9ff7f5dd83a56d51ed96d328a2722e81667defa6b170e7f98ca58f85394e58f4d26807f4a4e47dfb8dfc77f1ad05f4903f30aa2e884571202fb392a0eab65440927846b2403f831fd2746488a5a751b16ab20e5e3ba51ab113fe1e3c413825c1a02b6cdeccfb4f9a52a2715f5d70eb31b3ac59a930065df471283b616ca59e2455a7766e61a8e2931ac7fc10501c4d59266c221724c40019bca56098b5baacf50589cc6ff5ae1a734c81c9f7e19137bed4a547153332872f1e4696e7971cfdfc9520380adaac07678c0285af74194af3770d8774c6dafd98f466c4290135f12a1866780037f007317dc04c94fd160f3aa2c736da185c2d4cc9ef3e20ab3271a176d3f6132c2fec4c11f9966c9426ff8fb365b0a6ba498ba132b9199f577a84c3e19d4e18120e2e8f1666c4455c5f42516d8aeeab5da0de2c0e48cd491dff9176b44e54fc4053cd12d759ab142bec6d3795c8d41d8698a34a86f0ab9e3b2badfba1adc3d7fb641986361ea9b61ccf73cf8fffff6648529bffc982142496193ee1da44bcda0986f24d692f1caba9f8926f05d7477fef21b9531a9628360dfe955f9b4b7582e48177b0a8fa1637ec5c945197e8cbe234efe07206b6469f2597c6dafe73a8768f2ca1d2556118a3014b0430cc5fff1529079a4b94db1a043c4d26b625dd3b6280626dce383740f94944f1afe01208cba9639d5caa7b936add16ed8347a3a31f060159193e23a682795eb416d39128720426527960149b557b8eee244ac91447b8681c88819c169084fb07465974c5bcc86b261657e2ddad6d058a1e5609642681ca75feab5f36d153441f3a6f7435605a9bfcab6a248556cd637ddc4c628b4066dd4548a4c943daff50ae43bcfc72c135608d607b4a3771aa6cbd4f4309cbedd23636c76e7dffa7caf9763fa719140d85e84b2ae56e867af255667f66475017b6acead4d0ac30224c2e46f4beb9ba9b6249a3719c32fc15236cdc3e1a4ec1f4ba70f8c06e2a08b01c8fc9d65f6bf6ce49480aeca4f3431237c832e65f602d450eb9f77255f4130748c9baa2f1b2bbdecaa3fbe5511532a7bdcec811ddd2b3d57eb431a2b6db19f74a2e86c7774efeca7b01a1ad3f3c902caf1503d81661de91abb2be00518429078d297b19f64be4b63e9b066c75642157c0f103d96b5c1b7e38917fb6c65c5bd6c99548a2f05f0ead0410298ae37c84e9502c5ddf0a10b1dd1f127d6d04cb0947eaea2e63900abc9232c5d678fb674fb51a841dcaf951c58e633dcfe8c4105571517b34a953c9680a23d3ba13a35371e66c3fe25f0da32ab0ced1c88cb64d011ba07ed056850ee46cb1f6f95b071404080e209956d3fd7b992b190d280362c9ed588c7f26ba16a10b3ef7a0293763754cf4b96f9cb6712a70d019e18edabd859365f38ce3bcac6e59c75fdab4697dd6f9661869e5a4d9a4b79b7f206f0bb49bb625723bddeb428c47298e97eb7d807c49b7db78c493bbaea5224d25a3fec143102097a59c9afeab98b3b376bc117d0124558d2860ddeb3fb26bab62323e9f386401d4939e4ab2fee361f1970c8c2e80bb493a741763dfcabe89dfa0c0f358d61efd878efed8590b75ced8ed1246d22c1ac2569c0ce0f1d96fc6490863aa124a7a711e44606b32c21aea05f0d58f3cb88e44b0145a2ef5ad8865c45006629c8d7f9ebdca14e6563ad8a70d5d9273136f8566da598bdd686930b26a418475d954060acbf4470d3f82d28e387ddea7faee40f84932c606f16e6b3d186604b8c8fe8c0fd95d4676cc80b12d7149d3e7a8016cbf735e2a59c51e4da44870ffc376aef22b5efab0b7fde26f1afd639dfcd570b7115e514ff53c071cd2c758c9b0086badd43045b8c09e2236dc8f9adfb8f6cc6fbbde0aa1e8fb4589a1e8b02e9887ac60dc28cd493ddcd2f3e17fc123ce9b0e77fdc5495c8ab8d30bb3d3a627a4b62b74d1b175cf29b7cd0df8fa5cec5ac8dd1a62009491ed7fa3cafa4f14e7f28e1e97ed6098af1e151cf62dd3d4c9b4b6938b83c4b9d327fbe51830151c591c1c137f1346a99cf3da580dc413cbdce0f19b63a26794ad8e5aa42d60705450c070b9bcae395e7a419fab3e085558271cd9fd1b0ae40986d61acfbd28b342fa72fa96e5eaaa96832685cbb0ec1ae60a30362d81b9bd0cd281f4f46db3dc043a947564fbeb76acf64e920933eac40d03ff152c5e243ec2d87d141dc330a108d656d627d9f868788e777c14576ab81de621582f0eb19d677f44fd99e789a3877885c094cd05e7d20dbe4358ebf64be638672b14e70ae96ae929ae305b7ce40e00401e58b1396479950a9de0c6252b1c3d8754856d36068940084c589487032cc63a5e4417b5fae1196af89163f07b762fd7cd11c4b02c4d842cdf99a1cc5e7b17b15db0660354a4309537f1cf29921dcdac9ee9392142707d9313a526cf4c78888a0f4efbd4cf8e09d4dbba7cc4f2bea07eeb2959b0d510ac03c2c9466545996371a4724c56af8501642927b301272785cb6e92e36d62935fa9998781af64ec210fc8557f8fc254373e37155445071fbbb8806cb1676eb9f70f69555670e24318943b76c80b431c8ac53006cfd0e567476b555b41f3e5ee971cdb1157642e5d27a253d4c9d05875608a228267533ca90689c21b2cb284b68965da3cebfea7a5ad15671d6937b4bca59f5004ff38e08b57991a9412f5dfdf9bf528bac0d24ab2e7664b2f21488c733a6d8e9e4f3fdddaa4cb0b6d82467a7d322b58aa9eed8003e4e3fd71573f138d88c62bb3f00d1973fefac347aa194fcafd9541b0cb6f3f0702eb6e2c5e7d436861d272e0c4608f5f0968cff8252f93553bf5db75fb19de9e5b65b2b376e3b5ca26268a785f29c9ba08d21921d3bd4445d42c2396b4e674034df858bb5cda197af7543af442291a75f315ebf0758bd33ef591deccb0b4e849a05a8ba3538a3c67d1bff45d66e24fcb718917cd07cc5c36c70df3e9d178ecdd55f4cced54b1581bd8313cb67a9e4ef7e9e1c97a40035305a200c36d901ba379099bfcd50192aa168d26904aee271a581e7957d0b2959cdf672acc07c4befe099932cd0bc56c3436875c68a40f2be09144ecd035861a57bc7d98a0123b2a426f3258b6d9119c1450be11f5d46fa709c64a1b271e622821959242ec98d0a6f15d307cb48608d008bb4f62f9b7e10e0603707c1d8af0b3d39997e430f3ac71e847f3bcf1b133dba896ce5f84e1931c30ae16ac01eadaeff7e0b413b41cee4957f88a812620f91ae5d04b1f7a04a7cc0fbcafe31d9585394928743033851bf0c5cf75caea686c15c358d9dbd4b5c2c7dbf39a9239d53859c1d1bddb9fa3c891f139760a2217340d8f8040a29c554510c32c24c1618523a1b6feefeeced9d57ea9099c78533967dc2d7cf2b2e8980b12cc8b990a0b9d497262c8ba1ae63d1194cf1a06add8b0d9f0bd498f3a564923bfe5515fd1bbf3eeec4f72666935f44fed35d0612d02a3b43af0839d9c5597ba3bad20c1808c030c0d45608ef9a3df741103a27043165578636cdc88b54a07e921252afcfab3485bbabd17cf3c2e63bd2a86bc439b2e60c3cd86245aac42966247cce71406cba922b0b06b76723e265658e49d086f81e919f75d08bf76c6ebe785e5286a6cd615fddbbb70d171ed47043d9f048da4e7ad3d09f670a074bc16b41964dc0e963c3dba3c74d337f49714f88eadeaac96f7cebccfff41e5a930481b6fa6f87099cc77fb628164c816ea2676fdd508ff99bab925e309cc628aeeea2282bf5246372880c237c7801436eb01b4410ee8cdfabe2033bc31ffab6906066dd643a9ce6f6bc87e08f017188fe5d0301ee786aaef47732c7e13f0e18be2bdce292f60ea083f16d4ca458526b0fd22a6a1aae89b1fdfe42d39ac38cd4ba409a595c5e21b7a8a47c5f082dd5f27f48c092fb111714aaa2a953c69ce3a4950b2cc44e8d5c0451c6ea0ee1b0af890e27171ebbf6263e20fb0a71896a32878a2b62ce59fce89c591e8cca04126de869eda40fa3e76cbfb45445c50eb09f963ea9470cbead51366b5edfeb5f88d66f4a98805c840f1ba274e59f258165deddeb5253e4c52fd901092bfd4b55f3062ad4714da8c7ec6a30dd5cc046f5d1d8f5e78f058e54b089d45bfcdfae481aac51c282a9ca0b5a29759546080ed54cf9082ccddcddb358d2f187c21e8035b83aa8d37de14f0816ac6618ef1968396b4cf667a3ed76781cdc1189c32ca0a79a3a8df744d7178c62a0a617219520e7da4769b698fbb558243ac442bbb2b7a4ac67224a2ddf298a80fdee390fae46e99e38023b10f1119618a66592fc4cbea599fe1b4a3e0b1791c5e4d48bf077a74ed7ab19ff0a8d9ac54df212de5172dc1d96c753638bd7b237042d45e83e83d5b0e96a45491711ca663896ae71d68b9b2af5d0c575455593a974c17b567831833bffcc7dbf8fa0027efa2c5010354ef65e6e9b8ebafe3b9d1cea6500be727a8811dda0c3b42247df21973a2745bd066d16b86a85cc49cf6befdc4f9598f998cfb5a2392a754a3327aebe402015889804fa36fc56d5a8a64d3744bc59c175bb4e11654185e5776a97912a18c3e36d52c287c91da73e62de3a9ddfdd4f6987b24c137bcdadbd89644772ef01389c9eae32dbeb4323e1c7bb680736e453eb660416916d6c92fd3c2a2ffca46d201e08c80a47ef6fe8b0b5919fd451b4c92adf23e9eb302619aa7bde301dc14a7543c8815729eac284deb2e6fd56fa46447bf9b87b20d8add1356ce32d6ef466743b19481e39327b15a8ecc0dbaef43c494b82eb50e27c5f2a83e1abe6143abd2872a67d5bde955d3a55101264c3c77dae289cfe94b4dbd720bac9ffe86bd83889dad1b0ebd81f60ecf5641a002f061d2da7499055e259a8fe70e98546747a7cff1b5dc1851d1bea7ea080ff7e5ae2c70463eae9a07b5d327d533460cd83b2a8800939ab0187d6e5a3025a4dcbedf3e2a559ac195e2bb626317cfca9866e46b34d87ae550a4520c7f0ceb17868929e9caa0161fa2da48e12c5cfe953d318820050a47dd0b06cf8d277bccf36822652e1b75ee311bd7ac7ced1461bad9dbde5b0aca6df034e60b5679bae0678d412170381c45845b270aa1c54d009021e6e9b383200e4fb82aa0b0444f4e17525b1520bdbb1273924847a9c36e90a68f639fc74a827ac4ad49362cce4ed92d796700d626765f98ac241b4064926c0cb69c768a6a024d533bc384b86935fd3857f8f11733f09eb37985f39594cc8d1d2d886f55d1e89e6785586dcf26703d63d436c53dcaef7d07947adb4161419c7fe3c490a70367fa25e9478b9c99ba25c0060b744f88d986cb43e1940d91b96faba4b32f425685f94fa3e1b573d1dd2b70e132ba6c350e61fd8db05682f3cb1f597be1d486c6f2b2476279cc2b095364219f4c6f7fce34b7c55d0a544d542db84062359ac3e2da999b572dde30320f4816dd7a9c16e2d022318a429840232f869d98e9f4b6055e9f16f5e2834e195a15d1aa4f4b6ba7313679cf9d6d1b11253686501dc085eae27ea4336b63c95e737d2a352612a7a09a13bd1407774b007b68246b7482d5c276d5a473587100ecfde069ac9c46164ad861053a33b9ef5b99b46f8e239d361d015cdc35065f06aa3957cf2b7f718fd8442b7548798333b8d326e145008e0383633eaaf3b7e579aefaa5f22fec0aade2642e45c46dd8587d0a9695a7c0a01aef92cf63c70888de11911dd6023b19fc2f1bcb63d6970966bc6bbf3859e21b0f0173e68a5312f708f564aaefcc8023406c80195b7cae72113a153f3e748a56094f166a9502744517b3cfcd22f8ca7ba00932b1550bd7db22669c582528c0dd1afaf48ebec753fd2a84393decdb0793a106b338a861d034ca2acadc7781aa3f427b4d46f7633b53cc849d46375f8e86442a7184dc52b8d41839cb13b707a4f4ee4606bc8f2dc54c7a57facd4c3df5ce26900a53e75777e6af4f91d0f89edfe0dd2555ce03f37c7206b9505f06d74d9306f3044412af8343a1a2511477bc4bc459cc28ce5faa2baabbbbd2f16bc54a5ba0743c182e86fe589c65fb8e7eb0a32b826442f5176a65d9db5d6d310d7318a0099ca00a7d67c6792d635ffe4c50da040263ac56252f48f96a37d107cc50a74c452df616e73ad6dc3b8a0d240fac049683a9698ec2537dc7b95316d2e3eef66a4645a0b6c71c6f28005591e6c5c37d915ff2e9a06ca23e68449cc2238b9eed3219a4e90402ccbb88544b19fa596bef6a3fc6cf6dd48094449322af9c44a1aa94b4c22eccf9b70aecaac1af6181807ff34bdffae9204694feffa4c72bd3658fd896946c094248cc1b249d4acace7b3b9d22bbf8c706da65b0ba8ff741acde27e3c3a7dbd20dcaab3aa29d5b50d52e540a7c63b5508b09554cdbf2c490fde95e5f2296f5b513805ce3ba71d91c9a9962daea5d70a1d9eb7213ba440e1a528e1e30e846a7d227c8f36c83deb7c0088ec55365a2b669fd26653a9fe0770f6cb2d3fcb3af1f1ab7ffc51b595b2d6e7cc20ac4b015e0a488473691fcc4ad061b90960c21bc750944a2b8e4322395dfc73d668c416ca5ec063fd71f8221c9aff3599d2e241c7b428fb6ee8358c70521c15d795e19b36541c292666ef2dc8d2536c12277e5463c274193d10d33bb929a9788dee2512d0ce0786b20df1c7e6bde25f1da9f45481938cd8cd27cb876e3184de9056aca0affe8ff969f71270b2d5c1e1dd36040d2eeab559bd1beeb268f1c631e658b218a4bdae8013102b78b49cbe476dfffb81703e193cb0009cdfc3e7fade5e687f69160d96476e886a320fc13f615a5a95b808f5da18f126e2fb2d6887963183d6e4f294278fab12dcf8cf96f4ca70843542457459a1a767f0690fc793c2ec3b92c40c4fd142fde4884393eab0ec0e7440bc077f16369d044500b7fc5c94fab9842e07920db4242363b965550eddf358dcb6b486523815b4a399f65b76e5f402aad8c9feb0ac792fb2a1720c4da1a23afe509e8f0e2b77f47aa497682992529deb16e3e3bf92cbb76ec378e9539d760113cd86419dedecc50511ca139947992185bf0aa61e4a94224e1e7fc79cb9a7eb37a02a677ff7391a81fa10e4d7ed66d191b4f297aad91971fbaaa64f61bd01170de368170819654c17c440a361dc200db8cc08bb68de785a5ead83296c06ca159b779d786bedd8869b1c82141875427280d1bd023437296c9e169f997b253a7d43383068d7e62a49afc1a78831dc3fa282431c549d9757a78797fcdda6fedc025f44db4f38064d433b3e35eb100ecb00a6a8a1d32703e5466deef8a66618d042eebea5380cfd9ad7e30c5990b54897f2269a90b052c93bcfa8992dc9a871f96eb4ee5c1d5ee3881b3c0653e782d4675dddc6c0cba327ba1d5ba564af05daf79e1053036b21f1f9e1f60238ac29ced5f9a6ea963950932bb9f94e5aa9cc61afcd17c8ffbc2d5b18b064fc888021ec2c229c491ddc331c0e0aad54d96d6e4c2b92046b39c7e957dddf5ccd461fbc496c84189bd6d3fb476aee9848f17e12cd7c06cb3e6580064afd6350036ad656a7d1c3a9da06f5d50e8da0241d9cd05dc9197f7d59ce3f7d7d1e678ec06fc294456d69d7192273efc296317234fca394067b3152b1faa184406fe748a9ee09f524951e480a704b07d54e995facaa3efb617bdef300a79b223e7592fe5996d0644a8925acfc3b69758f4c7302848f2941f5b42fc3515fae15dfd96d5a6eecb995f1a5a7685c75c1dc3fa21b5acc6ba2021a44f8575150a4298149b009a1aeab6150e82deafc0ee585b0b368399503731929f9c563834358ae6bf1192ccace736b3f5229f3b381ad37ea9f8e48fb98b0959252617d42e893639c09b955cb0c30891d503bcc0e5b55456698b96ee1d49c8cf12ce7394d288bbe4c6f2e4e7019c97aebdab953aad733e85ac0fad399bf32d1fb6e4732567ea1ea7c6a8c733417024606e4ce25995535650e3f42913b9899503ee1dfa8def5f0ee6f43a246d6997dc03a11a801992b7e692f9440c6c353eebbe6dae7a3538043b16e6fa3fb35a316fb79e680c5e3cc88942d7100f2b76e6b66c80c7cb5394e260968f05ce580f3618479b0eb713695a91a4c60848157da82e8e1ef84c1229687e7ea8adcc72ed9b82965206754da51137f36c7b1fce001818edd70a54f5f386dff85b25c776521b2bd9a98a0ce06bbdec7744950aff62f5a3be584228df560d5ae451d500ebad943d672e76393c2aa1aceb2c795b1ca9f9cde9f8d265b5c2319d19cf7158cc7601df69d032bf373dc366ab48b00f2e24b349489a5cd443c48802e29a2f03200baf1721931910490226471367ee324a80b94d88507281243ef3a0d283b6a56762fa0c6bba5342ec43d569925c6666fab0fad38f6cb251abe9b62153668789e353d265d0e97a70dc1cc51d486b9b4f57a46967179cac656d7f344e5969ad6ab84246efbfd6a369e2c1ac947274d2875ed62c5671a290ba5eff76c6531be2e8bd4a94ba242d17cc4a650eec0ff2c88166188dfae50327bd11af84036b3949727fab73bb1569681fc9aa3686bef4236e5fbc7087eb49f58120d7d4a4d046d2175317e095dfae8a902f065f4356f662d636ea4c58840a8288f4c950a591fcde617dd8e1e5e005eb794488650a3b2798320571f59840cbf90d946e4b0bc3b2e27882cd2b7d5d3319ec5d55c5ae7f4596535726fcc12160edbdf72b5925ba70d89ac9bb8be9b50cdba1bacde31acc5378f3a14eda7b7bf3c35ebc4dd35ae3ffcaa0df3c8b6f877257dbf0f458ef97085d2477133c5780206bc39f31ff587ee3885e32157680cf076f725058d3895c4b4f697983a563b9aed01ab416cb3d3448b03872ce1f07194cc38e79e102b69ccf5753f6c4163d221793f744502c481b4767b4127ba0eb68b7a82f678221b2f4b7d688f2e3422cdc1db023d5a06bb8f7b0aad03eccc6234dca39f0d5b61550b03fcaed913f944ee82cc5fa9d42dff374e46aad4168abcfb63af101e51a689d428aaa36f446ee92a11a31307702e49bb20612d25fa18910f7d4b8603cb3721fe8be8d8b28bf91a11a27c729b0b944089e12f7bb3dbec6d89a0ff5cbce839edf894507a293994d4be7f8523671c0279e3d9a76d9937d50249e38951aab965c776ed572a05769f062b58f99492b7f7acb28bd3fd03a6859fc451fe5b4a691b0a2070860631bf499b253ce1b664667a533c82730449746248700c759f00e5123ad684fd7ce374ee13d0bedcb20133dcc24ca8876db1a837506533c6a32771dcffd7eb89504859898eed6d8a9a7dafd37c59cec843da3a0b4ce7a79d33453a8ef11d443f62ec0a023dd630f0579218452278c893f747d78fb0ecf5c2efde412441950d9e6f61c6487a14de4261b694ef88e93dd257d2ca748204ed01b0d6d498fab1b9ede95392ddd89b518b4078f46768891b9363992f30df823808bb6b97e5eea50ba1fc2f77e5bd8e97ea6b5a04165eecb5677d0a29017f2de04cef82cc8b954d80d4da86f2f7ad3665cdc906c52c7fd2a49dc7b1fc12a512eddfddbf183d7fd8b916df9193c0afb356e70c3d1e0bc7bc957a7cee066942917f622fb4ceee695e8ccd408e87796cead838e99943aa1d7cf8331718184f73aa36a269567a05766c1102362bef2326f7947351123da0fc9d48dc557bd9b16f15949f4053302a397c3e41527448ad930adecc42bfb266a302387da7b65fede751c9ebc43eba0bf0fe3000ffdd719a2b302c6a8311d39da63c9e5b487911b3da80ca735fe228961aeebc2ecabb8d093547d5c9603cee4150a704b901f5eda44880dfcad186f02e15509539bfba216501ab1bac7783ad65f2b5555441aabcc752b8556a6a3721ef84fd87d2a1259e6ec5add0332c5ab07e1d6c0b59cdc55f9f9950e463a4d02814bfd964a7dfcd7fc44245820b716cd640c712fe72b0b229cf9b2222d35f1063af7cad9708ea96e35ede5d000f41f0cbcad1f4c0b0804f9d99cdfcd2d67e47a39169e1918aeaad0ee2452251ea2cb428775388ca35124d096af18dc505fd1ab52d653f6c72d31acb9df81cb725940a2573f34d68ea4b0a603b7f7c86bfd9c4c5ce8d1b002d060979ba2c422ec559c228d2bca7b4a2d9a8214accef2c3e17f8cc9b630442851bbcfe2fae2b72ff36de40b4452e854719f9ed55a1b02c67be476a02d08297fe63f029a3ac833312b14b6ee90e7337755ec9083d5752444a39250c2013c96926774ffe73131894c4d874789fe17fd8057e0c13b8d9d60aa1227f0a0e38c5cf49057639821a33a90fee21205d819bb1365ad376b95fdd27fe285704b65b9c6ee74e6254625bf3adcb153ffa65df35094c0dc25bc99ce079c58b23ba01379989a8578d84a50c434d841899d51b9e19c710b21491b3bfa97eb56ead59005457f8bbca0180bb6090c73f032c7ca36a1e6d4e2a7d2eff7401fac9cefd62d47bd7843ac2699b156dcad1f9de0635a7b960a0365efd10dca02a1ecd3ace916513e4f1f5598022059e325df7b160e56cb42ec320e7bbed6f9b7eaad81471b5841cb3658d05fe7c8e22691a231a441489f7cad00f5e44d129b5bfad013e72b87ce116d91f41d789b3fd23d5ecadab7edd7e183b9b8463a22721cc2d85b082de1d08c7ef5479fe26a6a102770e52223f1bf9fea891f3a501c03f09dbecd1d40118d1ffa81b92394767871b21d10df45dd2a696b7b34d60f4af3393bf5a20270bc2564da83874c24eb3d403da2e4fe7df583532326807f0f115d8a86303cff09e33a2eb824ce16efabdf93f5694c57d3c9c1f647e6a7ce00a456857420ac92ffda034c01f019ddf40fd43e30380189d9229b058bfea7f5596aeb7c8820ec8208c1c8d0d6b7fc67d2e74df74b465b743ebfcd7394363694b0c2b9f6277a02c89b64b442d780a3cecda39453c146f10b1f3f7accbc983513a6ddc8271e1929dc7ec1d4a6406f6e2e3a28737741d7bbab8d6c152487ee7da3ec8fbfa0fb8fcf1f78a4c2fa8af2f481dc91c6fde3eddacecc1e1c9204b85c9260adec29eaf374704586e96f09bad613a95a7c7f6dd159eb921e84d1f91e2d1b88da0135e910dbe81b812d8229779867f1e2ac94d0837d72733b36b75ffe0c27dd0edeb059a27a73af5648d342881bc5c864a45098559c5350f22b7147693fa16b95d9d61e8c9970e7d686bc6e5542ae973772a5d9c0dccbe1c0e266ad24c9349902bba74846b0a6056ac8ac49b3ae5c208a0cc7a8206098562ffebf9f51d5d36b6297998c3fe42dd92e662299b6a10066093628953a23b7c85d084e362957c1b0b6d3ba96a31008694d7c3f0587dd43c1a39af5bcdcee514a6aa947325a4c1cc24aa24458740806affd0d4225109ca0aa975ea2b31ec04a599082bb149a9f901acb15afcb62b86b93106b0980e34264ed9148738d68af862cc39321c00861c948bb30b498ae8aa531e22bc67ca3679906f53dfff439dbd88e308900103d0b6e86b76032df56223fd4b34e70f709c3ee49a02ce9fa612e19888c224c29f3b4c6b6d8f1733c7a0049e9ea0a51b1ae1a5a3fa43d0ca8a79f85c2a8153c44deccdfc19242e6ebfc301fb44bc7519eb0b8d1acec27ec6346753c72876993b35cd9465963d3b1bd3bfe7469fd01cd5c865f11787808303bf5f8a8fac60fcd25a22b69305bc3c9bdd0439ade597218ddb44a6b0568d1030b0193d5f69a94f0bdd8f8417879558d47f469d8bc6785f8379b6da77c85281c899bbb3d813cbc35bfacc517849c7f70d5b4b646b1b84d7bcaea2364960dbad018d9db2adef0001de7c1ad6a367dce4dab5e2c1f3552d1fa8ae27c50773e15b35723833c88e2012c47bf5f004dc4042b1cc85925aaaf073a300fe6f56297b7a34211873f4507d58578b6b06f6f0b0daf5157b0c9ba979ad0b11976a923c5eda9fc479bd1ac40bbafecd46ccfc54a8af61cfaf83be80a28bddf703c3be2a753dd047df6320db65f3498e912820312bd161401b2d25dd6697deb091618dc9aca2eb1b2dc50e417dbd6071385efd999ffce32dd28298cda2558db2e8ae5c65632b3440fc888d3c7b2fccfb6c5f75a354b2d36816de9a4f28794ac06e4832f01516d8b030c8c028274720862a0992831e25d5cdf6a3392c94c9e9f22880d427a53abc74b900c96c03a9d522c35dae07ea6cd05717f8dfc555ec76c26ee262d35ca665010f661954a6c74d007439e84931e2233e91249934a126ca77ba8fe029fe0e3a6c852eb55f39fa378faf9abc174d0dd10239ec46f0988fe485b676735224fea59ff646ea33a22e0335c7133949444f07c957ded53107d7b35ec6518d862a3c8ed40ef303343ff4405626463e0ab3e4c85c65c20d6405b62f39c579b1fb1a82a9d0618fe4c04710a0ea924f14d3b83338c4a708a62d71b586a4393b9ca4cfab2fa4364311047567ca3aa129b8cfd7acf19fdd8ec8fd65c03a35507e06280b8bdf54d3204bb5cd543c4f3bba5f1933969fe61199f0f3646f0f085b34a93b8fcaac1734cff3e06ddce97ce678f5ddb9450033d03f9c27dbda36399ac78512da0ce36b848cf61878da9c87404e8239067aeb7f8952c128296ef318c8694d0f991812733a3df281a288be69528a61d481efc58cb5f8c47abcdaa69a56fdedc0d15e064919a33004bf5161e07304e80a03c9bdf4c07914afb4c2a993dbb8fc9ed1d78615340ce746d96df3435f4c103f4d0937c663cef095c4ec5252f3801785015a8a60229447ff82889fa47f4a6c31d86df29c94c9803d50f4070019c605ae069dfd4ada08be8aea7351324f1d5b07e87a8bb72b012109463e2eca1d1a450396c035a83f275cdf34c2b6df50e69d68ed5939c00f28206c089e3b034af49948330743d65494a84a5966247d9001bdd706c9078369864ab38d625981d26d3d96a6928154167b54d61c0bb33ddeac166df83182ea812b25bb0ef1a0a828fd2ed4ed83c3bd45647991fa3034e4c998b7b54e5ed5f07e1d069c6b654ddb7eb210e498ce9a4c1870b2e89e78f7ecea39139eb512458d51ad66480f56e770ce3b0f870dac68713994856cf34ecafd76ee7a3516a96426cd6811ae96c2ac4fb548748b33fa1d1164ff359e8347b94e409fbbf79d03415b4fc3a1dd4c5dc54b6f6020c020485afd40f655478471e675bb469a6db354b68e2719457fd500717b8f20299bf31ffc5ce2218b1cb2fb855a78bdb830f19e685e4465d08edf9ba25a84f6ac43d9b275932be73efddc8d878a719fef598496e79d7dd86913944e3417168df8e0ef3cfe91e1c9209fac0e13a47c6f8461ca41e5edb7da1737fb2e23cd2e4e900c651d3f928745f2807801e83f046e23de019b633415b2a6c0d687e5c7dc6505d78df0fbda2e1d624b0514bbcf2c5f4411c9d999340e5075bc91a7bf74c758bfb15220884328d40f7d95f92aaadfa5e45fab248b445a82966e202ef890254dcb83779ae07bd31231051b84d69b7ec215ea4bf519b99d38fc44aef8efb11e3d85b22db499b503148a1cb4a27409483701f7e5133379222d2ac1218552248063cb9ed92c31131fcdff74a27273d103fda76bbfdbc9fdc096a640c64ecdbbe18b213072a4125a2d338542b5affb0651984e3547d162822b73f9cd1757b9e34570c1dc84732309d6f350841706d0cc8ea713eccef0b153a5d702f5035d1e3da34b2096dc67f3e00f29e1cea7e5e3800eb872e2398e16bc23feb8cca32ab58181b3b14bd9d2034a2b448c92297361500ebe09b2e7398571e89e4e954a83e87b39b55766dc9c0c9d23c30fc5271506cc4b7e7b3b7663b8e07bb220590ee231c0acbb635f1604dbb344c5de585154ae6fc59117a9b0dc196073b913ff26b4170423296673c45017b9fa625db3d6279fd87ee1faa7056794eef4161a2150b2ea6c3fefda91b40a2e4d9b222610c13ca19988312181c5e2c4df513c9b44442dd241df3ee11e1a1e0d628086cd41317eb90c3275fd1ed78774e2cae6a6d121a46fc77aa4db1593cc91cf056ab301f3410494fb95be37bc9354a6fa2006191f4bc75455d87fd27e550d6d9fe1944b9aab5fc3dd939bd3189af592cf7a33423a188b7255fae107276d0fe613a53f916cee4b75023abefa31eb4143ab8cf5131cb1d8ad40e8168f82d021734287607681556e69c9da4a9b66aef1702c5ad0a7cae84cf919ba07e58856bcf06062131ded714017c31aeee69deb27e548908c5238be7f75228fc912d88d60d47dc603345afe20afebcccaa2aed01518ddaaec303a36c90d9cd3cee2da946df61e62b73edbce1cbc070dda8649084e00e2d67a39e960481bb25a589c359d3e39a2a6693cd40e1fbb34149544066574d94c324aaa08721334f3bac82a29727aef0993df629188ef60190654fb6de9f41dcbd108b7ed9f4f904619e6f421521e66ffe5da6fb6af2b940b6efcb568c46b9df4ce05ad24c61afe205b6506947d63abdd9b82edebf4210c25a859c0d2ddc0c5c39795b8b6a19e2ee0feefb790f8dd0ed8a637d18d11da063b5c4797787323fb7487b3378bd99128e940d693e234afe5891ecb7cc56462856b868bb932ee59e8b8e686e8f9275e3a6d70ec2cc65da14715641039d49d0eb0f1e74a307a1c2766c255c1cde04cec8037ec65d95d5cb068bf120d0b7f9339bd112eb150f7fb34e401b5b28f1ac50d8e6cc820a30d1f16213c74c6911eb14a039292578386b00aedfa1d9f2a8c575139de986840888107b039a80c1f0e95f32af62a1feafce60e9403d836aa0b7e5dc76f00195f319dfbf3bb1ffb314823894b1fac08d1231af68716138732f6606135c1068c3211fcb7df61ca4be69f76279eb1ef2afe529b09540cf39bfccea697c72e48f54cf86947eff8df950d132f2446c48d3c7699a6a67cb14182db8eb56db5158f17c5b7aa132e2f65f138297ce27f9bf37c2d50cac25e786d9b7492b76ccc2d431754529976b0e02116a5655b2cb403254fd6b1d3cbca9e796153d6ec295ddfa09e5194cb2d32a85c27f8f035d5104a158b695b448da90f1d19c0e31c8833f4fb4b509d22aa59dfe550b0c5a482191522ac66312f0bc90424f010b75659b4a338caca7011eb5fb905a4bd72f24aaf10bbda51313d4abea638c1c486d02869d6d482ae4a5fdc8de336cbaeeabbe631376a38824833b209e704eb293c287cb491f5fe880c0cd56cea427a01dd8e21be52c047117351f1ef55b7c6fa02e3c55a73d0904bb90d693f995f6583be8e7e2c360308284ac63f27cc7586d13923382abdf93ea84fda741f14d82d176a6957b70c9317a54b969dbfc5e4cac0450c7a95b2787d4ba9cd0d8a719c6d3324e7b568de7834fcb76bc4dab6c862517609fdc6ad0b0fde7aba1a78ce7dd973462e713d10b1428a6406e6f0d6872ab081b8f74d98a0b8dd9a795df2dfd7db0d6f339ec9c7e432f23747e7da31d758e6e88640dedb93156bfe86217df26c141748064d9452ee84d1d604644e759624a7d5875beefd242df533ef370f01f75ea0e4ba903778471fad55bd93733e8c61a45b1e5e3dd8713a5863769dfbf28b7fb8bb183916c88a63258986499075152a19f0314e8cf0cdd31d38e1045a33e9631b656a14e42a16075906d1d01e9396bf42978052f886ee737157b786c72b5b5b5d7413d8440c48db44d31bbc516e2c4fe21dd827013fe2ed15fbf5df8e870144a24901c2315bc56f1ba11d53d434da68812996c81f01ccd0628a2d43c54fd460174bbd0eb38b8049a6ba3e86daa23fcca11f1b8ae288535452534a4db234ba55b80c64c8a39fc6a072cc35ef221aa1415e077eb4b6144ffaa66b338994e7cceba9cbc8c110298a37cd248a43d7107c1684dc3d072e8949b28437dbacf073f06701eb0ab0f410a52d12213865fc63242146da6c9cc3534f0df17144bd6b39950157d63e9c9892bdeb7c38f6217f25085fec629189de18b25a78c1e116d94e30e71e82c18e56cd863c2a7ff2d454a0fd3ef924540640069fd03c8742a538db7810857b7b68dbf6a7118ceb8cceeb41927f6757a2b121364b81113c8de65a6cc1c5d4b9dd8ad51aec59c150954c66dfac278b9104d20fd84fb7630a40d362073b97315a4c172a4e6e2347b1689cef02130620613e088b2e0728555fd9a44ae717bc721b693eaaa6d3c1b6b4eb0c20f005cbac9bd3c629f77d776f98ad9c24b1001399cb8ba58176a1fd0331b6b9d15e1f6e6e94a73442c0a1a001f6618081ebce527283d47fa29e4a82db70d927a9c02599786a63b6a2c3b4f46dfe9754e48a11e266e696637f28d5672ce92d072a62fad3f64ed6b8d21b3cda5991db3b397a6d5dacab713f931d3239422d68465971deb1b705396db9cef7cb5e98c1cf5a15887d0b412c50331f9b9673d86246fd691f69ab6463f0fa854628f001983e241bbdd6ac438a5bc1da9e00f898b7d5d2f6af8ef36fbdf86a359b71709653b0061c2d66857bc6fb080204be1306abe53c2299c83710fb00243e0ab08f6aa1b35dc497e2e68b3198fb1447b06822c57e38335d66235353bc9d5fced9400bb204e16b515fb6f31c4fdef92e1381728fa3e727da9228e7c5119d5dc3e372202435e116a1159760489b7069ed1ce3fa7a189d4535d189b4f2105d321b5ac4452c44b48ee693ed9d271bcd75a186b76c3e2b1a55f137bc0ffa0bb3ed338f30bdd1cabd9d697599a89c0211384a434735a76bd931145114349f85157e315598b57e6c2c22c03a392fd1218c5b7c80bd68817c4af11c02776d93a7528f9eab08964e593ff236054cd2012b8ea6ad48e1749033e64504ecbf5ad0ac5d1ec6ede91307c94b09586b19d4ddf02c8793eb16e5244c6e2720012a6458a3db489da3435e8fb402c57d55104dac1d9b0ca4282828ba10b01336a8a41f3ffbfafbaee3e3dd97c085c5e76f8388f90c2f2d0dfcc0ad10c311c60f189e0799e0ef9f41dd2cc7b89b94389d3d383067633560daec749aadaa941f09c92a831ff6d8b78d69f5f8212dd010cde8cad2c14db010566c414f85f26957fe579b772bacb805dacd1c8566b9707ea9aec8e4b280cf4b432e9207bdac0048bf41c7deda04d50df6b8b90d0e6b4eb73409318554f43c0a60fefc92cae70a4d299201eaf3f7d66b9cc1bbbd73331d2b0e0e7f99c5ae4af8f9e2a39c7796bba21c35cc75216fe2ecc75869c955a92641a03cad0a6263787fd3dbd1cf5d7851d42402063835c7d3171341656ea774ee42f339fd9ed92ca1fca6ee76559ed1f4a355be8e1461406b484ade38be85d9a914d22a8e50cc5333937a2dc317834e8b4452726bddb338a1727c46264085dcc4eaf02bd357673692ab41dc975b78d35b758caa4eef4e43817914dd64a582a80f8996f43c73d01a382fe9b3a9ddcaa0db195ac4384de8e702ce7c231bea6fea39c33028aa3b76a50fe991662191007a8736a44d556f9a254ac1bcd8cc5ad91085a585c1affef25c2ff16b0bd4510acb1a214ba0ca0ad7f123bc98a59a2f4aeff9ecad305f03043e5dba4671d26c5c3289588c0a36ffd757e3ddb02fb33747640e9c9708f44aaf35bd2d09720d249a60a11ef9627c76da130e1b826876a7b4a01cd295a3364b369fca622c7ef48c5c7174e50faffbd9340884082249a6418c7cc52d175b9b4a04d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
