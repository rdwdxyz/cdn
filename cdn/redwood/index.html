<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1fd6b16ffd784bbad0a2419ab14cabe6d54579fb8ed6570e2ac5281445c41e4e48cd7b75522de72b1f0865581c43c7c7f54850106de6304739ee960df306a879ab98bdc0a9fbf4710f8244d0b4fc2656b7561122cc3fe569cad73d980af5950a919663f603ef546282eab60682f1d465d861b0b780fc0a2db57a79f821ddea68c5a04162989a51c73cc05249a15a5eee36dc1365b669e7ed003e46f975b57fa86e29e9dbda4ade697f16adb3d2f4dabaa0805e1d6b0704b4317f2714fd67e3ef855a4a811d6231f709d31c3761d7485beb6cfcf4eeff57d6564dd47fa52829b4067c57550301b1b37aba7ba624a7c77b247e6fe792f4cfb6ae2f8d4a996055203f2b856eb3d3a67f16d569356ddcfd421497890f4d663cb8c3a3148533141d11d8a14c6f932bfac3c3e2486c37bc8e68743c1d6cbe596ff87b4ed08af2e59056289721ef1f30e2c5ee010dd874f49a77a0524980110fd8208a827ba909b474806ae8e80dfb0628f16202aaca0b8685532cec51b975c9cef4722bc3b871eea61a04fa2fe69268924663b781ef990b35e0350e0c2d2f6b77ce376bb995ccfde21d21f585b3c062f6d2eebe2daf0820928084d4551c3b4ca11162bc65cf4a902da7fcf72bea41c3c2bdc086bfb11d77898d2ed69535dd6c1529d1c2e8ff3ff8366f0e142180814c0e39fa9db95ada54d9fa17f053214220a4492b823a5bb3b6b18d66ccc4a51c90b1e5b20aacb6b8d3c78301472e9b4c6ffd527974cc57e201ebe409440aac44c97fa8487565db9c77df2d2afc2f6d2971f1c4b3992d63ee6f0e983ffd7369c54f2c935a1b87df2f243ce7637ffceafdf8ab58482c98c2754b06e6be4e3e520b01d89c1b70332894f790afa26f6ef97fe88a3b50e15107cf26cba9da73498dda2dd53c1c08068b277ab689b9f58765c06ec3c4c90849568b0836cf4da289be2a40cd550cb7ee6cf5674da9aa143d0719eae19473e50ae3ca88face1367d704437f5861660c66ce277f61f21464945930455640188b8da221dd93968112ed1caa3ae821bd9abc7f62f1cbe80ab1a0119f5794eeb72412f22f9123e48de638d7a9ebbc6086950356661e6a55c79578e70bd71803575ebca7b3f780355e7a3e5c2554dcf34216a4fd9678a3483740ab5c62e0ebfb94ed02c106292a60ae243c0e97785b39e35bfecc8c068259cb53960fbc435fe36792da2942dd268731db773db392672025bae97c9d993b785eee2d39cdd7af2883c14e4caf438655edc8ac3b9021e4bb5b12be6fc59327e22d0aae3fe383f0d427be3152f09f1353150e8f5328432e6bcc8e7d6c03571e346bbd312a6cd428f9debf0d0038d7d293d3b95dcd37817cf8df4be6b31040f62670f3097d371353ff54b287fc5c90f981eb6affac58d78150dac1038fb9539950708e4fa07bc2138f0be142409afc743a3d6b2198a1434c604cd93f5812dea292bcc35c46c6ffb4681b57a6e96fd996478affa1bb53a1b606378b3e8d91156ba7d7dc13ce3301c9ff187f40daf7f6e3bd4a5f7bbc6c1b841d047463ee48557643067cbb2c4c50aa31c74873e8fad228fecab09bf26a123dfa84a71891bacdb7ef76851ec1480bc570015f97dc63ef523e375d878c3bf6442878fed747665cbf78245e909d9ec461b593c3b6dbc3b7c04dd417a0f1c45c99291ddc1674e51e95daa82f1ef2530fa4dcfd60340b64d55e50663edfc37670027739a3476a45dae919f6608c259dd1ccea7e60e787a46cfc1b07bd80cff39d202eea0539ae1e3c907cd576f5aa3518285232bc8257d36575a70566f025c6802ab90b6c96e1cc2ce833fddc4048d60ff34e10912f866103cdbd03ff9bedd438f467146c758c5c98faf9b415cb4de4c3c0cebc81b3369b49f1c8761d504499886db7043763c66a936f15fa347b988036146d4589d269387a42d21681d29b60d9d2c0f6e53d43fe58f96b03f907a50acf6183cd24ae93b42578f5c43113f029716ae20e9df4953ce21372dd37a4b461e607e007debd85253735c78e89258427a59b77fda64a786e9590e59be45d1bde21c505d3a4eb5a607fdb14c82647187757f84c1633969b1774b73eddadbf31f847a927bd58f8b7fdd0b48a2625e9df53f4a5da096841070294d987cb045dee58500a870a84f7c8440a1b3aa747e8242bd97332317d9f83d2154188adb858c15beba757dc6260cb0407b11950d6a1fdb5cfa2a1f00924aa2435194f009b198716da892e75aaea7f6dc9a122aeecd90b89ea5a692b26ce07d98cc84522425dccf0a75a921f210661ea86f6fc4ea87eb61bb5c0d01f7fbc3efb0223fe3aad7e342aa2a4dbb3b0c17e208fba77d6846fc14a01e11db243abc855d3e102d1287bd5c236f1a24ec0b7686340df734ec913fb12383e57398d129717e6a19c30a220bdebf8d8c33b9c4ef04ded9df13f9d476bc3417d64fefee78ab11069806058f17ef6cc7896bfb2288169ea95779f4aa2e2fa64d0119db34aac7ce0397a8e1f9647d9e3e18d3fc1088b2c9a0301a6ee7b8a4b9d0bc32b805a3d469b7336ccc8ebd082bcfc2269a097a94fe44b2213f3552eadce9a7fd99d6fafc78948f3f46dd812288a5c08a78e979d361b1c2829d8b266461d4908e5a0bee0e39b488a5e66cbc193ab233845a67c08c0ebf2c4627ec5b2bf985d2dc9796849287aaf344ce1e69ee273ff36c3a1cab32ecaf819bf8ea473381e2263e1d8ff60cce995c03f9849f051f4f0f0316b629bf83ea985b8107b90bd4f0ebb684353fc81db6988190a61ecd48747679dc8dcdb3a3e8b6df85ad0a63d061b181576f394d21a15ce3760aecb27f7d06e3073b1a84562e4fcc90ef2225178c3c5bf4cc60f61b57fb9c93c8acb2bdef5f5119caec89f5dfdf9c7fd8e2cd32541b9def25afd9bfd68190c0a1c34d8d4f33237d6c394c7068ba0fdf52179c2d2dad696147081d2e1ddbbd838912a55dea0ae6284932048b5650582657a9de66f804a527ee7a9e5b354a3d231223d6e7d1a84b9e6b74c5a71bfb31710e6f9eb4e4eb3e26586ffe7a59f5481964acc4eefcfc2ce843aca00b093cc6e1c681842cebb6df602784cffa06a63d1b7f2ca7a2d1114af33fd5c35ca5933ad224b527785167229ea1bc8d08625f530b9322a8421bba37c05ffa424c62936635ca24c9003bec6182d81a6f913257f6e00195402519c0646cce444b94f8f712b71ffc256a8a47328f93b1312b22531450cc49067499cd5315417986d40f4196994e6636fe43dc5fdb8812128794d2f97c28c88268b6a00ef8142eafb9195ff574ab9244718fb635976d91b455ec12d6ca6fe6834df94cc36db8a65d4192da1d42db8fc05124314aa64357a55e80de6de20a4c23e36e59bbe519589bbde8845da421f02c8474a2b9dbf96126b2fa654d3f7eede09d895b450c889147db454594822aff6b6ef42a2a14af4d82aeee32eaa117440e94a9c9bd80a77555be60159f4a5da98dcaab826696339fbc560df09339461f6897445ab42e67163690785134cf2e701f61ebb83b37c87d3dd5789bd6c7e3429772e7b3e32bffd2ecf5ed8629a4d46b02ff38355b9db70c3436e5c25b7928aaf8f8d2b557fc137b1e669390a445276e5dfc2df15afd6f628f2174dd131e12b7cb6a7234b73a66a902059c81cc90c583b2c14765bc6c48afdfa2596032319961af9acdb3c2dda0b4d09fa7b2c4db0fe3d53b1f6fb7bc12144922d09df79283f2a36f99dff82609bc0a6e6d2460e5da326e7b3cb66dc99de1f1c49e82a88c3929dfb9aa8d637758395a7ddc6a79d6087c613b6fcca05f5117fb123cec12ec9826aac84a65df88d1aa2ff187d91993e34e22e4011ef69e21f3af4ee858196bd1d0b24d56c9938fbe9c5a0016e7927194b98cf3aaa09b9b32fdcc497ea6d3120103d839e15f3a190471e82323b8fd9d1037d171b731862b156705b9816321f124ea69db2569f9752fdad586edbca5de84034bb7e01eb6593124e0bcb87547a84ad35aea0d98a0db64bcf865f86a953c993243f826be6afc4ff8e76ff91187715c865ae149b9b0f9059262686ded6301217b4025525cc63bb141eca1519627cbcc076fda3554bb0c4dc382c5f1140b7929d6061f96fe6fa90c8ece70fee5a36fc59aa196657e961c15ad7aad2804c1167ec64be348211938d99d5ef0d25d98d4d49f34b029dd4d9f01a278b0cb0fcec0a724c5f72eee41de1e7da2ca1ba8578e3cb5ae5e8bf60bd0230e52dcb236d0e91a47488e06a01c6d59bfea88ece108c6f6dd673cd48c788c0114bc2030b512a9c3bdb62e938f331f023881a1b5df825ffc5596a530bd6b28d7e519fe962f012dbc33acc05a639255b3e4cbf0fba6c905dffa1ea1f211c4830eea543d13e639f62422d0aa3df3d44b1899543b3c03b16587a149e5a11136650572328f121be07fe407911ebd1108b6a0b7ee7dcf1067c6bc900b8f5d744d38902ef83ff14194a4a00e7b4ecb2176c03dfc3cc44dbfcafc6df551cd881f2456dd7b2c4d87f994288a541e6a407e01568a9931a5408d163c3296cd1b3e56e3fde46cafab1b4f5dd7886de77d1e4f7603254a35339503c4c38e8e2e591e90160e7b29d7afe64e94828bb08b4d992ce2859951551e992476b2ac54e4ed415f661f1efb6a63942d47776e7dd3619684ed0a09b55c6db103362283ebb61aa0a20965d7566108445663bf88b972b3067c718740f70690633f78b50ecea4a9182e0afe8fffb157c05fc8a5a4470d9594d19bc2119446aa3d9132d3c655204ed411bb80b24ae83a4ce3c4c39296f872d8600a076b854bdc98b71f11dbc1e3d1022fa08b102398316955717d0c426f4e5c23cbbaf22e4ad6ad2f1a85c59133c21350d81aa73dffa27e8c9fb32ed8b17eb560f767864d351e7203c0f4e7c5fa84ce7b346cb6a54bc953f3a2e1b69bee092227298b300e899de430c225de65428acd5e0c1226d491a945e877ab6119cb7b2b0e117f2bd062a44dc804fe6fe21a4867ea8b973ae652909a29b57b40ca5e10e79f8d3fdb8f0144c3be0bc07a2f42045eaf5164037e9d313a054fda81bc1ab5b1de53c5f3b4dde20f086d61ad7bdbb00226f03e28068502167febf462b90f5e55bdc472b3a97216dec19f15cae2eb43f9bb7d677dfe41d3418c34adedd43043b8303104ca25204c93d46611d193b20ce067978060df49f5493c72acdf0db9d81eccf9dc255dcce57bbd84f5499bf62f92832af10483b2100a7dd5f550647374abe60a1c89c810afd5506944fd29744ac87ad8eba4c4e354b07aa16fbe0404b4621e830eec240cfecf0305148ce54b39b31ff354e1d867fea18b0374a616fea3f6cfb118251f4e7f0ca52d1c2c6e3439253bba8c77b8215ec3b0b1c8bd958d5f7f7368c6a7c5e743c702509cf0ab9273936fd571882375ffdd0d5a4639c5a65d6e4f0923969fd14e8174299610317fc9f7ee9f0bb51513ab4cf6a93584594c0446c64087de9fa4e4856a0bac4c79ea3764a457b87ce2343de85c9271be4836ee0006cfdabf75355c5fa290b40da07a798dec901db4067e64cc2e8de00040768c480e0d15ef297f9530f380ca492a1328c2435ffe5144c9404bb5b657a2fe93700ee0b3995aefe4c4d8fe27c900c93a7ffb69e243d84b11f2a930782dfd84e97f28c14f95862aa648549cb65aa4cc5db21d4a028f60f2465c18e745dde201298b5d8987220230618cd7126f52d7d60b21a7a400a377b3e1a2692a59e32b95c79ade48b7dafaf302aa8627046f5c7a0e2d023bc0319ebd20c4bb89efc3149377a1f913c57e8e39a2d79bca1a79c3d5b6ee9f70f27087b5d7804ab5df2b87b10d6e6a8f5cdb81100f0b666ffbde77981fbe16d26233a3ac5a17c33e714ee2a83eb486e8b394d0c8e14ed2677fdc1df722a8daddb5921f1fd0e7e4010109c6883ab322dac111c80af31755d12ed7fef60551a89d55fb374a486445165037cd6c51b688a1cf73aae3b4aa3c155c6d019877a48814805b3654a235aa62f6ad19ab7f9682b4504b1628d9fdcbe0193478c52a56d2fb6b451f66b2c035aaa65a093fc2a1871d18037dfd8552f2050833a2167420fb4567f628dfc345042ee3549e600b66b8c3690674ef9da1ac5a525ea375002c803953ac1d38d19ec41d597d8b34c282f9f4b43f6141dbdfd6aa8474fe154d18316f4050fdd620ba14fa47e6b8e85f7b95963166186605d01d305d825c369efa18255bfd83775184767e5870a417c8cb97c3c256fcdb771e54fadc6b24179bf9bbfe6affa73f7263d74605cf17441312cb3047619455bc4f74eece2903085b97262e4c1bccb056101add4e11672fdd5dd20f9b72142f96421f4630994e0f4ae2721896dba37c23eb665da44ae0c181c562dd9fe1b9dc214fe90ec50e0ff42bafcb9bf3cf87c02b5a9520343b5e7158e125fd0414f93c9b6f5741d0126fe03c324afc1310d62473e6c68c074f42438ad0325d53fa9f4574d728f396e95706c2c27b4c134606bf3fdc3660851650462f754c10f1ec79678771d8509baa379889e3f0788ea5ae180fff4bba20fcfed690e0141e5e85145e0fdd884449857ed5462e413b82b4e1f0816ad9e2af13a9bdc096177bccacc14c880216167311b6d1a88ab15451b49bf840698a9f5c2b03cb3cf249d4362321d3443d88eb4e185fb2f4bb716b0130a0704f339cc7cdd61b835b9bdb4a853cf2ef7741faf8abd4bc8e432a1876c0d6f5e148a18775d7af1b375b11b4d4c45ad46249ac9a8aceaf3be87c9996fffbbc5293f110cf5271b76474ca2be85fdbe13fd2973a569e0dd3eb813fb1e5aff331b1ab2457d492cf03f6760be6f040d76cd6e5dba3db69587194dcc5db7ec5121432f6d8e9d92017ee38c3b6278ee29fde794ffbf9c09e39f5eac6bf21fe5e61f464330c9c37c16521e90de986f674bafa7dfc62a5dc350f11f23a163346d9fe4c8653336d4a73262bb0e0b810b0e8d2aeb560c969611515ce914f54003ad3f85d0004fbe1d4d97d26dcbcec95689c24d66e1c51be174826e2c8f857a22010d9d85011ac3b1392409ffd78eaaf0da16e257c828aa3558ecc88b498ec6f69ef6b1d623d10823266f4741440c5d3d6da6bb2f325405249ccece86791b4226d0929a45ec948b986607e62457da432092fdf0f605e36266e1089a2b9eb68dc6dacdaa2d17353d3320c83c648851ab03593a9037c39fc7d65d19acff85939da914cdf0ea1baff83581ac1b950b5856fb5a9d874d8a1a9bbd8f42e399642cdd888cbd781ad92674c4f7793ca7cb141fe31e470cd2dfe92e00db3256bef5bf5a7a100a463c3057dc845b6254cfb00a75a0abb4dff809013ef0d5ba7a1122ad699ba6a915616d850e38873cbcfe5b546c61b9449cb3b7bbe6d7b37d8d7efbf6dfb4ef7335fb75c4649ec2c005c7853d25f1dbd0dc190c2534e2baab67289ff5a79bb71c387d211c75502abdd4d6600d6b09464ec6a010c82f3dbb937a5263844c25683346822fdd490eeeb658a7fa0faeda3d495e916db1883a9e02dfd8c297de3566786af3e2612f94e36d94b755d9efa99e358c49cac678c5fabb2dbdb742f02cd4569426451397c671eb357a0c5b09ec90ae8b04021dad7e2dbd3211ded8a51e836cedec652efbb66335c66025c631a97b383c152471bb7334221bf6fe6c6313243e14f4906064d9828db070c32fa27c6638282293f1f53806e855edb3fdf426cc4926fad62ea951851f377235635694317444778143bb57cc8803f1a763446f887a8503223a6e7d073dfde4dc7551fea6b74b446cdcdb1861d313ba9b7bef7a22dd5aac0721695f7fd7aed6675a369766129c9379b3a78306b1561c544ee999b9eed5810f655b8ed6182d716141062953e4caa3c9b7701f1c4862ea1f44b1a40281c86e2d3aa6b13d449d5a736707fab53ca0511faed5cbd4265d864edba2672580167e6220e2cb144104ac4124e261f572b4d654cd9bf84fa59e63834a4ca96215043b4d7632d367ddde91d630d9bfd697970fea2304fe3721c784408d0d376c43797171df7692d119a7c5d60f647f29a8bf1104a3d24c7c7bafe5f0c37da28bcc6599ccb140ccc5e7f8ccfc888c30be642cf0fd739224c6b6c5773129d39be5402e60560516beeb0f79ff53e44fdc5cef06682f067e814d7a0d5c23835823e9c1188b4306f83e26d36d38aad1bc6379ee010a55eae5c000565475773020ee446f1692599b02b2902650fa8fd067990bf0584778fc114dc540c7b3701d53b81d07db41d6c2dac51be09e35f8b9d4d80b527823cf128d1b8d3c52b46838375c57dac127193e8c27059878403cb064d0a72bc2a4f5be52810df021e18b5e082c70b570e112455b8694c15172935d9726f01a8d775a19c006f851cb46bccbbc63809cf9df765764bdf3b0e578c2e31c8f5634a07a73fad7382d2493382f71fa90f4d1cd5d5ec818650d338747525705b20e7a84fc360aa336fbf7f6863e8f2ea38d205db1c12995ba319be09eece3c1c04bc47605f696e339dafd624aa30fe6dc67d175c736376d7818080533b49b21b6cac19108afe3d0a89b423ac6befbd83028b4ba38f7b19e6ce7453494f10bec7802d46b2d7f8fe37cea3c8b9ad78e4717ee47c110955f4c5694dea1610fa6c2850091c8ee0ce323d6b8d633d7e50d042e7d28bb84d024de5373c8a4e01effcc59ae93d652c287bf75d56d982b941c7dd7683ba7abd974e0874b50587c8c91f59f8365a703a60701087715cb7f625b18de09fb200f18f6ef23c26bc97eb944631dd526cf174477e9f8d788909722cacac4307bf22352309077cacc8b3fe5616fd799edcb805b7f2467d8d611385c9563c201cec696638c6d7e9b1d1dddc79ac26b631f279cc2f8784280c5de8e215910552025057189178634d2fa677aee5b72bf384b886bdb906417d741b842a8e6c2daf6540ea8bd0facb66d76aa7a055926179e7c5f14959239d5e5a5eb7f918f40c8575a5910ef6a6f7bb521c8816a08510f3b8c639eb2e9266db146355e9dbe517facecc641683847f698c9c04ee05dce9ad7cd83b2de008dadfddd9c1806c91b4d7c28ba83cb7c70379ff6605adc9dd5c87812730091d25c477cd6cefbe20ba4fd0f43e8b4973244bbfc6300783c6bed773016b254bf7af8cb9f8c3f5125b9e924344a929782a067cd228d727bdff1eb5a0603f26a05dc43b8b4d81b8a9bce95b74d39594be9c203786d290a0fa4f2d5107424359f8acc3395410d5f2b06a8f06db8b64142bfc40abec231bae40a78840c4e4de07062f066207909fcdb46d908b63c504b35ea822ff21ff760ed94961ba36310d48a8292e8940155d736be6c0be27343a56d1d9712942705550cf236290a519372c801495a94a8e768498b1f48c84bd401bbffae0cdacfb6234cf78f1196af75f831fdf444121327b819e2935f371075ed847bdf0dbbf5e5e90674f4a74f2d4d042b428fc7c1f9c29baf6984315b21783a0c9616ee4313cfae5667b546b733de4847f31ecd088ab77774e7605f045298317a2f71de14b715ecd835f3169d9bfaa591b36df0d316ec8f7f08eea5e5ec87d84bed2f1a888abf76772b74a5c271ea56c30d08ae4a08867f35150ea49225d966afa27bdb6e64de09a509481028ab220941fdb97646b306042c7a750c50dcdc10643ef9749c43d1716f4a1e5da223e340fef29ae4eaca8451306a5ae7cb36d6dc7696e6d443d8ecb0f1d618529844e268c2b3cb2f3f8ad0114a0e5be50a3acfc935c08807ada64aec15480868a11103a4b9b7ed0f2a8c8a4eefc38d1be10487112e77cd02b043a2b3018e5a8711778da2f2aac8a711f32d17bd3da5af4571566c5020bee80ecf206610f1f6bab4f50ec33b2decc87a05353d1afce048d6d664000121a5c5120f36e1ab1aa1f02b6b765504d798b60ed2c59b42ff0ccc7d2ba592f51ac0915b3ae1343a0b5be4220d398d43c1607c0282539b5e29aa1bafa63e228c3744e14be980feda4edd610537c9679e4754fc9d439f2b1f223bbe94719f829cd26436c665d9fa36a6299325e4398972c376c93c5cf89aa7a5deb446456675677bfe007aa872b68f2946b1b223fa4753e13f016c79dd7f38974fa090b8fefeeeefb3208df8bd79214dfc53d5587c012f737dede42627754078ecbc7f17469953256c9aa79ff7b532d1c854fe13655cc9a505dd51deefc706714b2a91ff8985ded3633e2f0da0235aada0e67ae4a546b925f0df168283dbe983e35d771a87b51c1abfa8b348915ed5a8c2008d60daf4cb7e699b44c981b386390f02f6800524b7e956c4356341d7f3668ab4825f8144f60ed1cb23cd558d99c6ab484eceae091c8ff425f74b978bf330a9338c5ad8c42addda140deb59b0a3ca3b02900faa91c165c80d5c638cae92b34a9543d871b9cae586405de1b554bf6e5620da4353bdd28ee5d1db2ff23e96f524f56bfe53666a379023f4b1578fcd50bd0f4db7a58e709018dcf2bfe19fe1106cf057aa9b7677c9367830379f2719093e6c9367a42e2d4cc50f338ac97a77a5d21f4c812bdea979a2fe1dc443537c14b44a02757f603496a99c3a58e1ea8d29d64bd26599cbc56a7505e581f309362d61d5757b331afaeb418aa72e32e9706bc57b49b27cccd7cbcae9fc90d3cdfa8e4ab8313388f2a5164fbd3de183df359a525777a08bbf2ac6989a4355c437ef8379429b60e8e6f9e806b818aab44465a38530d140401d1897c9357df573ff83750e8fe4889a3aedb3ed3d6bcc574c10defff4c623bfb272ace8b6cb4cbf713c629f155efdc22e2fff4cacf05ec463418a08955f5b019c7237c2c669e5877cc6cc4018fa9001b4c88bbda0d416351c307c3ef8a9231a55cbdd64f3bbb128b11cbc6f427b2c0279940ce5ee7635cb7a3b7947f3cc1e8fc0331c8906bb0f75a69639b488c74a83d2eb8be090c2ec0ccc857f32244a1b35b45435b9d4b8a2645cbf53743e0683927ad486de8cf81e09bdb068a605895464af00224a4c0bfaf96cd83f3fc337ef8be99629ec20ba2fd4813b6ff784fa121a877c249a784d12b338ba687c6a7f118cf147768429c98ce418c0ff5a8fa78ae55933f1710b64eb0dcb6356e12238487d58ac47b3253e25722046485854e0ae84660bca13efb2340b5414cfe5b60001c143e9b061593ed41c1067d2e02ee4a3c45687171f64a88e56a5b06fcb085263c261a4926e5ba5c0569f1d740bde64613c3ea115dc4e8c40f2b5cfb3509b254abf64a28921ae6605193106c09ae96d42c9136176707edd6fee4b4e0f596b7e7635f432497fa986d5bfa9399809293907d5a9d1140b758ea66c2624db372a3d27e4ba67208e41651673e13b5ea735e75a8141c14f3b1cf29415628ef7a73076f0840ede99ff94d0858748a405b1b18dabf71946d3e237c5fd2da4baa1474df64ed7d7aa7330d4e50529ad1c29b353ed32066058a9eeb94dacf7a06cf98bae493c3ebbed7c051620bc32eb5e36c5b7dc0268b77a3b71ccfd004ef52072275519153a35b3afab105d3d45209a9f060ef80c5a8909e12991a5fbb31d6f995e4d84aeccd10b0d281f4b90a32dcd68491dba501e616960bc3bff30e92eb19a2b2b4949abe3ea03f7412213cd0ed3cb225f6a79a55538e3febfecf5e2c58f0b01c52bcccfbd3c414b6ba602dee0550dadbeccc81e84f9bbb8e88e37b0464d63a014c6a5db38a25662f5a1ca4e40460133f291888e23eeb20d2f5db431c87a4249d997e4a96317adf1d22c80d22d090f3042cb79b05b7bcb65a6f5576117ed84e571d62ddbb4d177601696750b0f39bc2c08533d0f06f65a26bb21a0b360e48afc79e8957593156cf358aca0ce36142987494578e7be09c18d6ef836d053a8c05fd5b3f0b763bfaa436e535635571d025703ee42f98121a6c5300c166d2da3020ad73a8d0342f466941f7188340660728f4840391e7a70ae4cb4d845bb2b455852ce79139f9b98dd6bac2cc3364ec14f707b1fa6dd5a8d26846e6055d4e75432f7c3691a040963000d729b6037cc46f15d95182461a3d9cf10428bfc8f4b60931416cbd20bec3320519e61d07dd9afb32df97be30ea1e2cee46f0d8c856a2abb4fcae371981754b4c50f04fd6f7b023998eec2da6447ecf18ca3f60b92ba15d990b13413391305ca8e43c52117bf677607672915d9b9c407cbac359664d64a9993edec3c01a62fb06c3967bbd7154b3d15acac67b2f37a08ed3fd80ce97a607a518c2b26ed523365cae376ae1ff5a61cce375100b4f75449ecec047b925299d64c02a605429bfbe12b81faf7bd04f31ba4e916f7c9121ffaf4d33c6e6ab5e1366313de26346f6610f42dd8272658ccf681b0a4a7db2efd778f1cadc79455e863f2d8b556ad2736839e301085a9303afff1b7445e519d7d946d20738583819a525e5b3f5fd57bc5c7a3d6e8c35133971e059115b5e55855ca25d3f47e56131fea52588e2c0fdd41f67f187544d34d99281fe454c21de2b469b67c78abfb94738fcac8b18bb628ecdf72d2f5822046f16cb6a3a54c2d7e425aa17f2143f547b28fcfbed8e6d2045abe76c108f98f0cb5bab4e9d9c9c84e02edf5b5c5afbdfc5154ce5544b47a2254795133f8a9b2d9867127d75519774619a693c709ceaa80ecd79d0d96dd616f708917bed3c1d96773e2b4a294b01d4144965c58659224e77d01d6cbcd1498bf196c00b84b18821b5a67e5b5328c85b16ee31ccdb1e4f87dfa47cee8004d920d12a9be06369dce5b544d91a8b42abece1b0b0b77ff701ebec0bed9571711205135ce7e0c9a634b3603f18b168bd315531ec35237cfaa374a162a6d3b2f00894f0e731939c5dbd7b88d34dd03f9ff1592c40595dafa3a1cb66e99c7485c8a1e7e348b0ba3aa4c4aa6cf3ab2f7d50e27f065e15a653d4384f777741dcd8e84af44e481fba8f89cacab59026030f60ec56fa57d278c9af67618c2b09bacc1590bde56f62232a5caf000958ea2b52b00b70a74f3e97c9ed18b0f74c106457aab1c8949ac26b9323b06c7ae0d8f119e64d104f062cc91f2384d1fafdecaa619cce48be20fdee746e38690ebf1e9e6d0aca402ef165ceca7ca26a5e4f3456d6b06df0f652002824d59a09108de10df5873ebf035d3b7c34c2c34ab44feacab46466a8fa805cc9f0f00ab44f7dbdfac868b71f92aef53986ffc52d9561fa1ce4b120449f54b77889ae353575aa3b59d818484ad2f74da81f1fb5b51a99e0778f4be9c4bc343aff918c73e2ebf43be2f12dbc2f0c20ed34bd5f2da0236cd38ff05dea8cfbf9bd92ba283ed240f4ee49cc283133efa3014965ca5fd3a1e8ca40043d76c31a0ff44bc32116f4de0c27b578bccbfd4061d2a4115902101e593a51b82df3379f0f4c92c8adf3b1425f4cf4c69ef5a0c5afd45eaae9d32c42a1d3fd055b940e4a6cbbb090d55754f365b0da3195053f67d0010556cd80f095f9ef7503d98273767359864940535299211b3e6fdfa9db864d2c50821818f224d8cf6d71a5bd0ad36dff50e955953554a45fb354f025f963d92f634ffb1892d24074e8b97f0ae174bd809ea392c1a1e25ae1767249b851fa4b14f77500b2c21fa8f5710c80f2911aef7d978078dd5b2bff578d8fc587e28957ae11dad76293fcfa8e6026c425ab1cb48c9b3fa3da568112c95e83b6b6381ad2bee2c6e79fd2ca9237a6bca617596860d676ba8761357150f971de25d81f4fc507081813bf9e093eeaa4ca0fe8052b7d54d7cb16b1cdc11dac5a4eb828b4dd3989952fc2ca818d9da14395552dc8a35c18195bc4afb5436bc1317d6001c67f8d3630ea68cc4d81eee31da32ff3a827f19fc8c615c3b254db1a075bcb5c3d1f7ba7d81a2faa0458dfab6ba3299be812e5d403a98bcc2cfdab471930a0f52f7925cb27dd6e53ce6fe2441c98a8869e1d4ecb9e821e3070d5e76d231ebbbf0909cd97b484f7db284394ccc4fba24cf51cb63426b6c32517610dbbe4fe8b018f80ebc16b4722c949eec0eb4f87d1c83074246c8eca749e0e8ce85e77e48a86961f4f7e4cec4d11b5778b56a8110ef005adda50c05b80a746912dfaf1a2a064ae878b01eae90173712376881cbba93a5e348f765937ca7db63d5554aec721c90dc406ccca12f97027f8dce5ed12c614495b312b10cfc1a04673b35adb17ea17b7e7d8fdb24a6012b4c70b3feb0a3c19d4d847b2a9518536e0ad815ee559b99fd6e9d9eb525bd5475f4eb7c92c6d46e58d2101689a42b0ce7173855ab25f1a8a8b64a9dd03893d8d60b3834ad48eec9949bffb48095c53e23ee3288e9be13dc0e96301ed8e50a6e9617430bee5ae33f6eb302fb3ecbaf9d14989f2d2e9f87dc72006700e482b319cb053f565c04219448359756588dededed9633d48e3f46bd4b9e70bdf15fd4c1d034ee7feb2c7a5f08b627ff1cc964a2d725d620e2af376a56884ffe7c28b0c74eed058b37635732471186a55bdf5800aac050204f66cd0f61181e4195d85d476bee4ff17a6f0b46a0168fd47dab7314eada35034b7f769ce4b031663720a28e9e4746b618b05a50df09aed9bd60385b744a6b1ebe3b105ff5872a5b6e99ffcd47c9b1a9b0ab0519578b10f7a9268c8663ac4b3d7783b1363cc0751fcb2246965f9b47087fc0f3e7e215e3956a615c0d6a9204b63e7553378e1ff8f03ea223a211e2ad8a75cc53a44967f575057f9b4ead0aa7e5b54b38b385685fa6739fccca74243cb1a285376932e710727f69a0e818ecb3d72709a7f1eb64e6387bb8ad60a6aa207fd22757ba75eb8ecd2dd356c075c16f31c6dee4d48403c70e404cb325e58ec71abfb5f5b5d924145210b62185395dc262ccbee45b34807cb90bd9b33b19b06b2c3234a6733bbfcc392c66405f20e8d139a2eb455473f3a466dc425e8e638cabf89e5299ed7087d31fa5bcf986853370c27abfd0dde7a7aef13dda53144ee2825d3842c0a4aec68c71976b65d5825603d31962facf18858d1308323fa0ff3c66bbddd44f2735ecd5995b9b92cae064d2f1361f8adf5073f60afc82ba2655a8d666bb459cc7dc9a03fe1e3c075aa9d9fa8617429b45cfbe84ea58b55885dd5f1bf2d6e8ce23d8a4c9c642b96d496ba181fad3fccbce40bd9d1ef15a84c4a6f22879524e440a52e522192ae89404ee4fe3c7840cf234aa1fdfd4921fa301e238d5222974b5414832a7c0704822a74088b4b1034bc813063b99c7757b96568b975643a240de6530b42769df5da61feee5cce7d77859fdb349c16ce194f30f4b4caf016323d5b12dda4a0ec9fe822177724c484d5128cc6778803f2fdbbae8ec643ba884cbff83f41d0c8e6e4f767da690a837bd797549c3cee44468683d3ea8111c60be0f91014a7c50fc2d140da54d57a82cca68999c262410af6b06eaaea761b6c9141addd00c51e22cd663635d1731a95ccefb5372c76700f2021d15741de8c7be9852f726ce966617206af534fa12b0ccf9e6c6322e89136eaa00a8fb5363c8ecb69c037f2e4065e91b2417b378e9125e088da97b3cea422321f71323b08e4e45d0f56c4c03a392eff02dc391fb02d0321c1bb5b54b6d13462ae3ea024851b3d3fc23465dbfbb984cd0adb8418e6fd403550054fa5393d2c7cbf2506570e20e2f30735d00e8c489cb57c5e985c2bf2de77497e52c79610b09572ac00bb6b5f5b50659e402f46e09d3bfd900a8e97c319326df2cebfc79166dee1f9e9a96efc73ba7ec99fa67d05a32f71fcfd16ddba873304fbe29f81f82982b7196e7c19914e207a06e2cfa55cb049749cad6dc7c7a723802e30059a827e84fa2a776e1471a1add27db27b7146d5b9e76f4b4890a06ae3f01d38d7e87cd3f22a86931970ec891c357a84cfe557f0939bd3e6537f49a63468dd5bbbeeccc357bc786e51254acb93e6a96d86d79ae8c531e137052d7a3504e870022be23cc04be739b4fa5bbf480e6c7473752b2eafde90d665514ff4d5cb8fc9c5093b58a03b7c5aa68f537cdd5fd9e08afd7bcb3c98c6a1341d7159dfe19c3cbb156afa4d3e938aa9616842d06f1cb93ac9c86d2fcc99e3f66892a91d724f250a4d1cb797b601c77f714158fe642b19c4d20b8feee00159c8fa611d905ddec03f19989cfa144e64d24e5c5b6f1288b7876b1a1ff96893216803c5b5177fcf6a60ca44de770c722e1579d4eaf469383486bca719610dc8fb87674d25850eb8e025dee7b45c2217aad0a69929adc5028903e50b4c4aa5a0999dbfbe40315046d6c8a4956ef3e9a0feb1a6f4fe185d341985a4cb992f9f4bb07fc830485faa6a153f1073ef91f89ff4099acc18fe011310e00407bc582f834cfe9250776e6f7538db44a364d7c739fe5ce39c72caf1f3330078138d7e91915bc6344af148d1b2004dfa38ff7436411f85b20d9159d9fcba63e4b10460442bd6f291e52ae43b6cdfec6b1f8429051475a0a148216d426e15b76ef144f3bea57bc4f7faebc56710697bdb04113b3895742b0a8b4bd55eb6e0e63c54486765d2787201af8308f947ab39f06a6b0bc9785531e358a6a45a9d3e8d4a9bd70501213016f94f4db124de27c8ad170387324c4a2dda12c96bafae83af50370c620ba3b8ca83c18cf9dad6fd9566dd9f2dd549bcda944e3083a661ed670df8e0a2017b3efee62765489ff2d469111c86cc601112aeb7d5aa1dee06768b1f239885eafb8c8633f340ae5ab0700a60c3167237f41aade69f780e8e800e0ea8a1a559ed691081dc89b11311f9444b6fc0159e88bb8aeff3e029f2e6db53e6be432ba8f85dbef8aa0cc66b71ba78ebe9fc2d3caa8fff8f0ffcdd90a71e557da465bac825d4d796b6a9029d0d8f425842485e16622c07fd862c5cced38f92fdb91c941044693623b208b19d89ae585d4e5cce4c53024df9d2601137507371ae4d22a9060738f6088cf648b36c911d6f45b87acbea008d048631da7a7c691f24d19b1d9305b16ee4cef6383f60be445f50439acd12696245f15235713e8e2af80ba5e722ffb2ba135f66f92dc0fd6efcf08ed7564b08229bd578dd38e22aecf5e0a2ab6fcbf2f735ccc08c46b975ea18c3d394d7bd509b0f169251081dede878ccd4fe65f828b4125b8847adaed76d08a54301b86f260397d07f046124bbfd3f686ca79d6f59542d65ca5a2d0b4646e6e22cf57b0cec9b4274ddede9b9c99622410ea0689a3872f7280eec845e5c4f7c78c51e0990491f587c8995c1395c7cb1dc10d5e2fd827b117aeb57d736861a25010f4e946bdb9a89684d4292fc0fcd62cc4ea92171b69e0180c8c9fc961b44d1a12cf375a918fab6a88dde1f2e71ca2dbb8e637d34e51d0047de8f3fd658ea0c75cbaa8e56d7ff98867d025d15c6427e7c6c3c66b97bdf8bd185dfb6426798edaab48f1f999318469027c32e0afe04e5b6055daa41d7bad40eb5afb4d31ee414f36e00b9ad504841c0ea096c6fabb7b009647935e876966e933b80c56d6bc71c224c77b7ed399cba9ec10c2706685a62b81bdf2023446fac17eb4ac7e30757ec4ab6ac0e037375760f462b6e5d2d34d0d5d0d16da20b9ea358afc6630e43791cc8b3727887bf6aa9c35057f8a34e21d2e8e41a75971f4e60af794a38076be671c6cce3b44356948a20697dd0acb53ebe5a312f916da1cb5e993360f3958e29b40d5fd0b599c59003358f99be59f1de60516de11a85864eb564c8bf4bd3ba527679944b04715cda0303e8ebac506ee4354d5ea6a11b9778f37c8f2b51ae46e5178344da435612c9768c3e8b5c0c460eee852a6beadeb889f5709b8b77fcaf43296086133975f53119fbe34c76682b8028946205b04eadb996c35183de6446b6d61d102628d3e89ad2c41e366fd041ca0613f2fbcd1e8f22a94b21409dba8bc2061854bd5a4a06a7ed36f4fc8e22e539539663ba595a6dd7baaea9ad20dd4263f40097fdefef18eea0db6f9ebacadb81e0fb1c4a624cbccbf959a4e1b1d800ff444e6185f875f6d0db144bf911cff1941395bd990968ad18b6fee","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
