<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2fd838bed0ae26bb265a93c5dc003d73364969144a14b8c3d268c354ebe96fe2cd5d984aad347a53cfcdb0a357cb70e616c5a6ad7620f5b4fe7b599335a92df935e431b6728e1993e2523d193f24d41c5809a4337db0423d80b0ed2631a214fe14c046bd503867af2327982a27f6a9decc8909e8d874ffbf1ddad81f3b9dddd9d7051443e98395b66d852dd15d29d6e44536e52b229abee00a1ff16f1797903f1fd88cc6b89cfa068adfc2ee1d582fdaa9a20267735f5111c52c5b69685dc5c1120de040066751a4f2932cc2c835dc5e8ae0c55de3ad47970f92ccb8133534c94c8be681ffbc8c22181c7578391b80b6b16af71661eb86c8ff21912b7d0d821b3464e7398f0eb303aa61f9865509d10dd97cc7ff9a7ab9b12022c5ecc164f5ed955bb3aab0ffc40c0e93cc3e45a86c4c9a320e8556b4a317c6ff329530356a1f160a3365d94316c0e70b8d923c083e27b586cf6d016e1fef9c9f6832948d181aa2de083c3ab5255d0fdbcf946a03736df9f9d8e963339cae05a6d829689cbec64b4dd3955c8acb9b7f47bf2aea453a17d13247c124c27e1da9d6b649dfe900862d1b9020d5e1dc4df41b0d328c9ca3fae16810e30049bf0242c050dc0eb708f24aa8895cc1453d7df10b41853c0c4a92fcf57da93ef6297c32a9a28ddb55ca5b4e308d6ba98c189f1f9346c360591b37490796ba4483513841cad70f2d2c47bc2f37ee4ee1218a48f458e720e27f37a927f07043d84189f6da97413021097f1e5aaedb804f910d5b458a00782ca7c2b3effed65de644e76b47a64060f4edb5a3e4e4a8bcd8ce7976c2f24c0af28a2378534e8a73a1b46a84539c477de0f3f7b32e4c6acde3cbbe415d227bc668b9d7af57eff9124e6eb6e753e72673f639a7e5bb284ad5d75ae1adc73b50105eb5a2dbfc42054d451cb98cfbb1503c01e79258c6ebfc2eee763f2d2a9d522ec61950ef8c8bb22f0ffd5357f8a2ff7071e2c9fd5bc7e3e140614e84e12a9360860dc851d0ff1dd22281acaef4f8a34b54eb3efd4244e59908dbb5614166b652f4f1cf5f47ea40bd0001587581aa1c6094e1a330266c01da73947a4d56543551562a20743a6b45902c85f28154a45474a885afa26f1b6228845bacef7cc84eb953b2e2bb0ccbbebb2402ce2d9be77e3fd2735329f52ca13f8b4bb07d733b41dfe47f23788391e7caf4e4b50ddba61d1d34f01c9ee1a61b7d6548744783c75f508501f3f979d9982ebd22db3aa66762c961c8dc8f7a63fc01719a95aea8df045c260b3a8bb1d5718fbd91d0c6e5f3ee27c5c30e3837661b254410c30659701dda0bb6cedc9b2ceb56c560e295f5ae903b647fe5a9752540ae2d2e80929b45f3965b45720145c9496d383a17132b5f9a94000e0bf3adff95b3c4e342497551bf12082ef79bf31b4d8dd861f23b4dda855f5ed8a6bb3f1f25e75c23a852007798adb45e6c4263c0c40470bc1ef9fd796bf7664656bf8796d41604c346648ce756df783f84b51e24b41fc5446b1dadfc4c9a0bcf0baffa63de106989dbe4e7e9e9df5e60e65e5bdfe21480dfcab7da413293e6577bd6fa16655b66dbf9e04de265e04243ba918259ae98128353681b585dbacb167ce7d100ddacac32ef86011da58e1002957d51656348b12f19179cb9ac9acfcd77a5ca0e3ce40fa010e10a3b1caf4d4e05b657b46edaa49d76c5756a9af55406ce21094cc07b5fc875e7a0945fa6ea705a32c2532e53765a355654652816dbe8ddf68085e70408bfefb5af1e682a2ac9581dce775c79dc05c631e61c4518f21ce8943e014f819de0e43f1a64264f1b1dac14d5aa4d46bfcf98635cfdcb2a2b41f594539bc062cfc0775283b10ce7474d2b62a38a307f7db5b1469f86a7037c1fed6f23ddbb07b40873be2325bffcbc64d5b8ee1cfc0536f742031a6e34dbeab1d2b818ccee6ee4b8489995cb602c239f6cd65819118e03e2053102696da09b480bb295c6f60c42e53fedd8e31066694df300112a90bf7cc4c4196dead6c45ab5abdbcab16c28945b563df8d3c95ccb3930ed10b8bbde567d9adc044787b29049e681e0f509ffd2ae38fd36aeaf99b6f855041af3879a4f1df9a92851c184c3aa7fd8afcf28210dc3673fce30cc021c129cf6708f5aa3d1b3a5c4823877c81eb90386384bd2c8e4bd166fab3f32181291651ad53b0c6911a92e5f496baab04cc8f2eb3497c014f78aba37dcd848198f494557f0d3d37fb26c7bd706a69ce97ba9c12eec3a58609143081719bc9da56ded66ee83f7162be20d8ffb96b5d02c41ba0a0e249e5a594ca37dce6e258dab9e59de11c8ffdab77e329425635080fe99fb42290772e26fe75cd785fc79c46814fbb813e1981545508d8ce06922226fc6561b1761d1875a1e0755cfa1b6f64226830858959dbd95bc6c1e0eedf6075b011a445b8db13af47ccbe133a0986bfed7305a64b05b24afaf17a7ea9fe77537e708b593051cafde0b416e653ab4ba997d972f4773c3a3c7751b274e3394aa6047e7e96fcc383f301cf0ec647e835205799c1cf947604a5c49dc2b47eb2e239ff97b8c3e138992a40baafe0a6f3569aa869660ef9c2e0c033edcc9c910265798d3a257a703f3d84240edeca5fb96ddd8ea0499bfe77b63bc36d9d56c5e6afcc4ebac2b335cadbce512dc62aad44d6fe2c065706865dc0061f3d046998a82d001e4712f0a313ce6457eb8d7b349c076ee7aa9b734f84ef1ca2196254cd9cff7358765ea47a4ddac2e2e3e7a78e6dd2b96447be3d58e085af6fb866bfdbb01d3589920e5d23be8ad0890fd1b8872215313ba4500578b5ff35e37c9727608d2e30faccc338e2b30b14f29218603bac93e28f8ecb1fe434e35c5745b0f0b2126f2d58315f03a7da58625890e1e1150ec1f6db0d5ba442288767981f993b335b89aa7166eb80cc34e300c0483798c4a1aa0974f57c3519e9a37db3c5ff6649397274a562df1a076e090396d5a34aa4278a68e1a7b0d146df8b39d3f132dd046edb4511c8a08dc96428e0b6783f1fae96eb65c0a3b432e55465c3dd8b0e2ffa4374621c6d07de0783e83267a5172ca22e97b6312242754a5ec54607718668f2b6c10883239579ea12789e1db885cb70455552d5143374c9f4adc370ad50688a91256bbd253e70b94c85d530567c30fd0364ef3b4168a1fee6e83dac498c989f89ea4544bc2a4e0acd0cfe135149471390b98100dce8dfe4bc717ac7c600033758ee838cecf2e597958d88765d1db7234985fc1d99c393c17c16e10e824ade4cfabc3c5599f8f867fd2168f530a574f75cd1280a997c370631d9b2b096c584bbcd9b7bc3dc2df3866b98de07dc1965099890359c88f11139ba35923994890e7b726dc885f32d8f5e13c4da2bd6567ea57dbd133ee16b9b4be5e35c4e3d21deb6aae5959b474d2c93f104f9826dbeed3e8da01c26cc101cf26de8be1d93d34cf1978f802d53230002d0ad26ee4b2b9cce16d4e052c1ef0d7ff8218bdd304d74e6360551390865ce046908711ce03a5f54ca8323f26e5c3706b8ae822f793e3aed0f92acae12188cf0583f1f4907d1325ce0d125414f15c5dcd69d4eee6b6d9bcf60a20cd4dc8bbc276f0047a8406889fe72a7d1ba05efcf0a289e9273e41a267df1fbd44a1534fb805e516ec9c7c6bf50ebe9f673268bffddaedbfe873c9227001bfa352bfc309e13eb86c3be42edaf3f5d27d388b6dd369751fab87a499eef1de6aaa52668a23153e13a067ae110bd108dcc33ae7636d0ef9fdf81c59cdcb01c4f16c75f96cd4a1bc913e54bc780b5a254ba91aa00170efd8b271780590aecbff0e1096f2970cef684f8d800760b7a400503801f070a3a06226e99a2ef1a6baac3e19bfaa9857e93236f879baf558f7e7d65e3a35352ccbd2cc458fe16688996b1f752394ccdcd8a6557d8f8d8a2b91a3a7f1ca296a5e62b2f89f77b1b8fed96dfa8adaf2a56094c5f8192ece3628067bd715d82ffe1b46035474cb5f72432029df0fc41c53c51995d78e787c5dfaacaa0f9e95f27ee45e98f38e846b0862a82faf8e3081d7fec44d21ab98daba649fa904cb79f00d76c6cd471fdb63829a203953a76a1be27a9689aec551695260a3ff322bfc2f7b299635093109c648347eb284787cef872f10224a42fb7f4505d14a6aee2468a3e601eaeb77abcb627134ccb713c928105476bcb10904640471ab1340f504b511704062c3ce73c355f93b3c8e736658d8062a7cce9a29b5895ec7a270814b85de0c6d871552e2eb5a97d756866d174ce1be465d7d41c250f3fe58dfa05cf77263dcda9113c9a684df978daaae7294be8ede624983c234a7d710ab06cd71e08e7727d50d229e2c2e794c28702addaab3290e7bcec2ee4aec97c27df0984334d8eaa5a224e055a16c32ed248609097304ddfe67f70a948f54aea66db62a9553316ddac0c41af41c578ad4cab195f1d87be1edcb0ec415b04248e71654ad1e3aba9606fcc22327828d21f4020d9435b30b3d09beffb4e393b7fed2faac3c1d9dbd322720787719161a5823b0921a66f582941e73746e1133b69b6c69890237c7120f37d5aba472f4c52096def21978632bb6bc9137ac6d08a14e3cb90bf3bcacba8c6b4e0006eff1969cc3d5e698cea2dc845855048c68803b13776aeb42552d08fa7235131a4c45514b80557097bdf4b066cf470df7254e62b9c4aa64014f11513829363d9e744c3d44fb1ae85603ee16324095b6f2cdb05d95ff94732bc1e7b479a8d5d4c430a2c848564ab2f03afefaf26bc71e7fe953e1c164a7bb0a4ed1e66ecbe39f371583f7197441aaa1b5ef9eba48696b9a382b851973b97a91efb970a3b16a63966dc5574acb7fef37bd2fc50b6e261736fda723d2c6e55110d2a00ca2bda3b5362fdb5ed487dd97c11de8986b2a9b81f5b32a9eafab6fa578fd8b2e4de8df41bbb1effe6a22551f722fdde6d04e7dc59f4d9492b5b4c535c1ae32d12482ad78aa332a167f43eaadd1472babd255b79add6b96411430ee766f3ecfcbe00cdf88794b9a9518143cc67ee75fc3bd33b51871854604ce50273142a21795a59b293d501fe23e2e46022d54090ed9a30a9c16b9ac1ca7529a4a6c5c2ba4d0a9a2686206ce2143d826c39297e2dd9d3c1d404b3182812476b86b04c2017569fed7bb689a55516199f58bcee9e95278361b7d7b8457959ed44fc8599b4402b0fff637d7124e2876aae170adf85bcb51df9c4f92ceb9e3df68dca2bad9ceb0d27542186c4faa990f0603a48df0ef445b4f5b18d28c64d4aafdc9fac2e84b548d96cb26f0068863ad6cd15f1aa400e463570752ee127f0168052af48b67f5e2d2403ccbd7696f0402eaacea4008bcc37bc433428dc34001baf61ee1c9821cbae61ffb9712e7a93c519abbfb564aab203bae7505d5814b736ce671ce5a5b9e4d11555c740fbe3fa4b8f77d0d6025db27ea27fa8ea53e53a4ffbd729eb770b9c2ece268f37917b0c86e03c34fa6f945ade5fc2f48b68ac68df54fca50043aa79248dbe1605d89646221082ec1b7be9a1de664d3332ca1dfa2eb6f7fdf654e09ba4b7e4d27506c93a067c3147a78817e9a143079b00eaa5fd986d33984eb25e6af21edf6c9ec3e864055b60d00317d3d96e98c1a6173982b7f7d0ed31d4b377318285badca4336c2fefd47a769c23e0201b0b4b4da6782143ec93f7a3adc98b65035d75bacf4cb7c98e0b3554a24861df5334bca9aa8b5dfbbdd878146cb6e95fe3c8c48a421fa79baa94479ab7d8976c057aa655d1c3e8e5b79f06d6a9aa4c847232f31c252588befa19a726b85cb65c2f2392a0f5875ddf1e01019d4903dff236356898d06560a693bf5de77c148c86fee238e4126633ba53753779c061fc9d99dd26b53fad82fed86e6c898f2f61969d37ac1960cb3009b9cf8e6aa93dcef13df5bd26eb0b10cd5c0252f9ecdffc4083c52d59d9032605294a6df0b68d276def7147ed6d3e1f792be2abf1ac5a22e141588bca7d0957cef88f5d1855a9b5fcccfb01607e7f13125cbf398ac25c8b5b1dc1ad5bbca94c3ba59a609cf64c9f5164020f2b8e6e386c41f13db7705936f397c07863b509e1fef796d5916340a3acab46e78a5afe725c9e18047c56c7777ff5db1bda30ebc877d2737c3a4bc7e1ab25c0961d4966ec4bc1455eaf7e6a595e8b9264079373803c1128d65287c8181f5c6ff7c0dbf6a00641176c6ef6f8b721306af1915a4433d3280bad0ce3c28f1300e7e70bb65e3757fa8a33933a7d42f117cb9354c22999658283d4f0db9ffed147c36231c2921e1f6001831e3bcd351d19e48ec7da7c9bbc86245da570190f964db5b90d396528375ef374e35a09dfaafa924e53619b4044f37f4ae09f15e7346d32e2e658526b367f40195e33e4227946a3b8dc9108fca32e90fb2a80d42fbc8c1944acb78f8ae0a7d638489da1e724c4e6c89571b1cb7dacfb91d801c2376d6f3f52737936c56526b9f7b00bbc76c7afcbd34c901faf0967f84f6f1d0d632b98c4e60b52cfa823e5b9ade680f9b8f5a73e08dbbf2d678adf172cd4302cfdc0b3d865cacdad10fab42b7aeff6d3ee37f5000c61967a9f089ab2efbf821b2fe82bff3858600b8df1a28c232a48c989fa0b3bed4c177f7d601107b562329c496d046054b9ae652577cf8b62d30d4d05251d4e0cfa9155416a3622a6f48b18339276dfae14195904f69fd54c382feb00d698907eea45badc4155ddd8ce0a5674f379d92c5277f9884321a2715510bd5d9f81c038b41dbbdc73613b8c4cfde9d3ff4ee0ded08159f582f3c3f2771b4d166104e8572cc527a6e1a725abfb4d8d400e2732d7c14037dc04b3e1e1f6e0f562343f05727b1927d0cae5b34b82aceb621f323d07caa3dbae07bb0c987e12bcdb2fb593849cebbc3e51da0b778190d9a4ab9613934d43abccf63cf564af569e6752fc8c4a23f84323906ffb97f03417e33fb29a3bc5664408a8ca059a3635ec2f756fe7ec4e6ff8223ce0a268699d22688c612919de690ca619ece50b6d1fff81c150d57daf7c0887924bcc0bdb659681e3cab825b31b5e27b6c17dd459271552e4d6fca75938a2bbfdf7db832889d7e88dcdff0b4193910f03bf14f7f6411f8992ebf793071ac5a40a2f521f296ed97058d67019d2e2d81176fa5347204450d5019615160537e2a1fba0ea1a37fb3b155c491cfa50e646741bf1293b3d143e091000a4cee97ce07847b44ac316dcf3d4707d9ff95eb31203fb2a83c2f1bf39087f369d547e2891f61b83a10c8a7d79d8bd9efa84513034fa4d729fa2663146fd22d6215016224f8ef20ba1aa1b2e1d3d2f30ce4258959710fd79af0cedf121c76de67a1888f99a3a1cd46b933ca80542c8d07ca07966fc7a06ea420c2d435ec661572fd861898faeceffcad4b3ccdab067e96031688aeccbbb0f0ff2ffd6705e4e0120d66c72032f80e3c1dad8b805d798b5e544a9dc9af39829c57379ab2d9d57477379b27e170a66a9b13dc12b192b140e2a43949c6d17a540bb3461e28a6ef6fc03ae29499449e5850f680093b275e2a93280d4c406f81b29dd2b82629316eac00fe84113cb2209784b5436ce63923e58fdeca862a3efcf8f98061c95edf29504717d02034d48e17897e5b0295848bf425e56f91b84f09a38496644454e242acbba6918985c151d3cddcafccbaa0ec447fb435b5b488f28e25f69f93a226c2899adfcb61db283b6bc57adff46c8699e60f06b3bec84309c4881167bbb9aa5093b866465520372caa0a4dfd907e9d1c816cfc912655efdbdbd1d8d413eccbb538a1e670f5b171d3482d27a6a63f478fd5d52ba8f52f749e7530add09b4e2dd3c232e06975200ae85f47e6cffb4537273f3808d9eb8f842921fa5bd3699f75411b8fef7a46c249782c76f6f7568e51bf237ef46f4a338628e1648d4c2c018c7e2381334dfc866ab4f554f8cc1d86b0847e7b28940d28aab866d9df46709f358c797ba532654712e695b174673e764a1b7e9a6efa47627150b16bb419c5eb695b2aa0f8a95fc3159233a8890dd22e8fa92c2d2236c6f9aab4a91c02bc949e75790148349d1bf1f305c722612fb7eb87fc412a4a67dfa53b7b68b75fc679e13fe3143a8f4367c054d022a76ed4eae81736085e61ef16ae86e4771e09f4e1a334c9cbea6ee1a7de523527a98f4f42e2a6585a8a39fca2fece050f6eea609fb284ba6591b3e016c66c4ed3bd60e12e9e7e67c6e5381ee29e9767a6398db9a7e02e54fd6be8bf45157b89a4324ae350f168e1d1f9b58956c6a05a1849f9d013c0bf4ca3e14e9623cf5bf64efa08582c5cc7a2b394f4cfde9eb5a78034634c0ebc21e79815cff855d757f3dce973e0c93b2310fd03838fff670a39562eca2d72812dd17fcbcb6e3bc73c9e5bb4f30ca4387ca5e9eabce264e284e8888be8956f25be9e24800b4d813594365332349d78ce4025557689a8b98f543a58ce85e7f1bab4aaffd8eaf2bcea7bb9c033a111b2dd625c1f81b9091e0aa3d3caf65db991355d5e016f1df4b8d812f21c892c51fbcd446b1fb5fc1145a52b34f27c83a6dd4376fb0d5d8c2cf37a69948e66488ff3d0b9fa2c6d0a99facfb33078665a6c8435527ad542be59c019a4793e07fc8559ef424be395c7bf32befa04e9c69235301617b068a987648c64e5841a60b3aacdb772cbe92638e27b2455e8639d6c5f939306fc72f57b627fe25de0d2a5c19ab54c8b212955c39fdd9f1633a136ec6819b9b256e679af67f5d165dd2a129d09122d7cffe4857347657efff6a2e2584ba0217bf7b4db748cb2fc98d358c6a248e9b6958d0994d6fa9624a930ef13a6b19987ba9cf0957e80c4a8752a9a0d0a56860d0b293e54dfea7d3ad4fb3864dbed18881c91cb84c4d1dbdaa66aae368512470090e58667409c803b1d416215143469d99a39b4e415615a37dd851f204fa38e3aef3532e8867877d713c7dc5157dc723165d1481c2fff759b0c004aaafa1763bacec7d83bcffb6e3971f10f6089f65c2b7a8a2a24ffb37a20d1aae0b4bf16f1e76628d557cd252fdb229ee06cb71ed5c808e3d7734b3031568c9b7bbf1fc2a5017132990f9aba349538f9920f9e2ddd6cd17fe2acb38551dfd39ca85c2f875ffb75501f3773b5ded8def7e3fbc8a8ab971113894131d8449e484378da73ba100ec6d889eab14f72e40c7a80094e1ebb224e789b439046bf40d6807812f079e519cef935d724934c8d728101392cca3675abc462bbae58dde59c61f01ebbc5d521282a53c0c7c26bd3f26eab5702825d9de9be203c8512b959d271723edb043ba6d88992523e1161b358a6bc47d11a52f288ea5b1eb1104eb4b5217d97274e928b41f1e8eb1700e617b0f873e75d0302ee96cdda6f53cb12d8d87d5890ac23f751ca7e8789f1ede50be0d25dd3b48c4f79de77aa415b9cc469d0295ef27dee53501a4735c31afcef72640d4615e110ef874e006c486e1781dd2a20c41dd026cdad6255c5238e2a9b951a6fd2a2e5aa76a18285256c602c3e8c878c01bead56341f1e3f0afb20f25e7ba2a219159df803b5d4f378f069336842282c49c27ea5297da665807120c3aef60d395a5e9954a810564d8dbe7e6e5bd1400dc207d721805e1fba91617dc4f9f6115e04855d0a60106edef0471ae6681928d7e3871fda70e30d8e464d037112c404009024ec475305854fa0f8a0f54bfe0e9b0b0843b94d073e2bf761e579160e1b604630d80e5af1ac611a9d9c7bbb8013dbee2e640f4f86dea6c2d2fcd162667fdf1a53ebb02ea47fce0cbace88136b10e465bdf371fcdd796a07832bd0f7e8b611b8d3fbdfb13cdc270c8f060cac6db87f9d74dc6fdbc2194f18511b4a79737389f2738c2f49144ef3f7ca5d0d5c6edd26ec0348188670d4d09d24487a5073138246f01f9cadd6cce4e2def3b8dc081014af9c2bc24c1084798b9bf4d7f9d87037faf73a3901bc02bd0be5703de9ee27279d56819db5d48ece970615e33a011d6b02e0b3d2694a3977fed003cd745d5238087b6d5f79b749e43a8457da0738b1a4f231e3ac986b6534f40b1d2baa6676ac584bf48f548ea09e9b5c1187af528e3eb89e4368711e18f7462bd2b40e5cab93d250293bdc11922ce639b2c4c28ca329724776eb8009b9ab4806eee3537c97cbbd2f61faa285a5d52405b31ce12fdcb05872fc83395323f8386968c57d4c8823fe3592588ce68ce021c814b92b42ef1a3aff3733c21b150a3bc2c1baa92998ed38d785f14a40a39a180c81307daa73fdbba9a16efa297c5f4526615e67fb4ac5d316b7b4da60357fa8792ee2cf516ab3f8644765f8605261a00b8008a328fefe9406f5a4f3bc10fd469797d87b112f8ac3edd07f235f1452e694c536c0b2b803b405993573461795980c0f81341ba4b48b9becc1aa3687bc1a6edde5d17c7b1c16efb71c729578ca6ffd9e664f7a7b23656a320479693b162ea7ba2dca4aa277bb816676c2b3655abbaa4a2668a9650947ced0cbc98521d5c9148d0bcf838c2a955e09dcd058694b28189f085ff92746f9278a5db0e472b52d98facc4d6503a863e397dbe3508843fbf4064714500d01758d962e2bac870399568a13fbbfee4d5867d216620ab496d4f5e8d2f8cfcb556320dfa5a3afeb0b20ddc15801ee073b91e946fe52358fdfde8c50dcb8336e6cdfceaf8eff9284ea78a4cbc32d3bcbafd4efc92e2a1ec4093c49f1a44b62f2357e4a5c09de4dda0b824ab4a04047351f80b86e35421b82aa09fd6b89e4d8a54ff07183350d6883d02e8f07141adc7a3b8ee6b4bd925f5e9aa1b05e127cf7ee563bd2e6ab13ab3c75cd417e44fa49a74d3471029dba3ab88e80c125328081d90245bf64c06f2e01d3a29f9619b540afc7f1774283c24403e59e4eb4051bf53a734ced5e85b8e84c8e7d7ab37f551d26a7aa20b99ab86ad8d53e35698fe64705b2d22a42614df990116e78b00e54aac050e77059ac31a6db82708d945497339ae379d2e96565fee4b7aa015f6cd813d10589df7d978594726f64ec727b6c03c234c8e940088ba0f08bbdf3109ab0fdca23b1da38729270ec76e5c64fe7cd82f83e7df494411f9e98f68bd0f2878a7ab43f1a03b13a403a00e0af2ca045e19d5100d13c58137c3a74d673c975f482366c96358396bacb3f9bc4dd240994e151b6ed39837438362108788f4a376a7e7ed69e944b5fd9551696970070b81d708865952a862b183dfd3b970692247e9df526cf1bfbbb1acf99999a64cc8bd95875bf65e57890166e99436056d6171890eff49ff1d1e01874742c00989c33e5cc9b3cfee2b75c8aba2f913f3422ae4bf6bd0d0e5637071b89d67c5552b464e4ec11332bc0240cd0003e9cde20a5a80d0f5b507c724219b1e877fdd415a4603f6e530fe2e6efe971b6136f8471c1477da70756d626d3ca4a9ec1f5d846227e8106911da75324363613c7601f97643618e616629f8278a89b9b4cdc1c0ca131003c79f41864bd8d0ccbe4b3e2645158803c86d6e468996863b780175f92624c3d51202e865104458b32b4a726e5b1f13f2ff36e576f50fd39220ca42b91b73eb8e3bc70b70839c7ebe0c217973dc6f5674ab61d96111ae50cabd5d5eec53b338ee54f593be23a09118c4274ddb84b709c847772c47b831f823b5e26603a7b96c2f544afe8d8757024885b4b8ff66208e2ed82ecab0df1f6363d3929ec751dff614218c1c0bb1358539069a1e292bd3063e1bc94b883ff50b61056140fa488848e6e1ef5c2e61869abcd6e6a22051f27fe088a93f625f7f25fe88fd0d746fe6d9baf6fc753981ddcbcb52f9286801289cd74f0c3efa75d4eb8d5ca0a53d7809ceccb0f7c11ea4cdd5c6033e4f36b973e2d60fad068a3544eba58caff3557c45a480560b1a05c3d96182567ffe21273684cd7fcc30332475d1cb141d37b29a9a1b2be4b7d55b406378a5c6bd41bef25e47ec030e596f635b36c4280e613a8e3ac2a6d1f6d645057766b76e20d441164612f0f4c9aa1426b4b0aefbe1fcd34e50bcde87202bcf59396ef34677cb913566e993a3ca38b588b102fa079937fd99695533ed4badf74dbf9d896541209c920a06ede8b8d895fbe53eb449acafe219e0fca86fffb201e63b4b887dc1f3a87c6fe65db6804a77236951ed7962f41172847457865b952e5715a4b065bb0e35f0315cf46b4de0329df5e4efdf948707dbc5e5a328667cfe1c67d1cee4858f9114c1c61635c808f901430461638026a99f3cbcf6e6285a3289ebba80c4a19fef96a0d70be9953640515907cfa71e70656362862cbcb770c811664c7e71aab2974c27f80ea9bc03f9e6af775ff329b74d5dc4ad7f8d8ee89e1e9ea8fee3117e3e56d533c21e4fbdabc81aaa1eaf9446cf37947642e8205db66f9001dcce2e7558b842a1ab520b5890d6db5976cd3ad599c5a84f5ce89b30f60430a6aa8836e23a5faf8ecbf0781a461cba1502655caf8581a7965fc81e38d6ef3c3a6826f5b940387b7f8a3f7a11f5fd4dfde756316a6fe6e373b818d0c6e16a7a0023343b9bbbd648279ae48e805df57ccea104f821c2577b5b5a455c658a54193d1ffab2f779020d410f607688495ffa66875a63018b52938bf4cbd5a9ede909054265c784b64fb99c000dafe0fa50d3e2c142ce2af025b0785a8f268ad1695058a0b763a3e38a9a19d9655e81afddd5f08f445b54781f3b16e4bfbe2326e4d1595dab75b0daf9cd60c1836d50585958876e36ad3250fd13ea2af2e55485f3f28ec67cda1e434c3a2361671a06dbb781c8958e452bcb0f4eba6e01e9a2507dd375a6e935b8534197340061b71fe865e28c33695f29eee4ccac2184b7c7f52145223051223f683dc8808a86d90dbc21658c178f5c098f0bac57d60cfda6982baa4c00209c7d450af0b07ef26360be1f3ae9932adeeeb3f98adccb1ef9df9afca4ea93d90bdca6abd9c58e4944528ba4c9dc3be577a8a4e4db8876b057aa7021a2202e0bfa8183498543b5351be0288097248c66acbd4eb107f9b7969f8d654a84554ff71dd16718a63e39abcf630c4438493af02db62e3689a153a2927032a439e06aed61af4fa04f97af550ad4cc976f0143aa13685f505e71c35b1ab9daec550ccb1d23d0a803acdcba7f220eccb8f140c715ee36cb62da6bb5d98d59be84a0259552fc0e319181c0c2fce84d2d699286945be0a10f6188c5b9c232cddd7afa23d1934be23702e8982701e329bd4f67444615ee837cdcb131625cd990ea1cb5aa9fb6615302e1a028c5a352854f55a9e436ff4149055bf2c2171068ccc9929a52085c92f66ea3883946282c0ee8dca89d3ab23454b90a10fab30458c84ab6f80e3ac31bc804391a891b67dd4bf84eb368e8d5920f0b685af59cdfafedc23b2d9cf3cd5345463efeb5fbbceb79ca5481eae656ea4a3b9cc4d4bdb1bab65e9d06dcdc9182aa59aacb8743941e2198cd73dcf57a223bded962493e3894a34ccc4d36c071f44acb6b14d0b9537aa5fa845f73670afdfa9eda6a3421d9dfc083e5997efd291a54d2f00b9ab0bf6a1f1dadc50db0704d92dc0f4f4ff5a83ee236f4c34c628dc5d28850a399dd9e92e8820be808ae0806f55f35faa9adb7d89cdf7465934194cdbb64d7ec69f424d7b0a3de905da7a2f9e674051003adcfa05ca35bc363cabf8bd1578eff394f7ccca06693978305e9820bafe9eabdae5ffdf2d2a948d2d14ea98a50b8365af0ccf1be15cbd8d22eaaf6ca07ee9afc97f2a24013858a386641c122801ca8af456dcbf2133420911d72c19ef41a58f7dbb6b4d9dc119d54c67efecff649079d972b56319d3a9b37d4f043f1c3364104d84def0b6fb419d0b46e75cfbd058ecf0425f043cc274573c4d4f291b74f5de5d4ed40404ebad6da603a442c0de80c87753dd0df8ef3978e960eec6494228c9027fedec689d56ab4cf6f98114c1714f210562ad3e0ef700402fa63067a0d5e82ba10082ac84d5b9294489ff4b8719c4483cc583ee0be4a235dc3963ce147ff50207666802a876b0775884c45d39e3a2429c92b0f85572aa614c90f5c531c9d3e078d1b70019554ec8e4a488213d96da62dd95f6b832dede3d3504e4bed4287c9b9ef4cdb20bfb7e7e392a382ffd8c675501aa83359074dc54043c61148422ba6ad81b62f84e8d664a0c056ff0d5ac6b1f275efe86e2c9480661dfc322054c21c4395a42120c532060581e83a56cedd4f2efc92bc36f487150a746ed92fb39a61aa057b305b972e625c1f9eaae18637401730c3f3fbc9dd19e174770a483ddf32037874644d607ae8b9f898bd4f1a39f98523b7ce21b74f6cf74087002c141e0606cf80cd89bb7348996cf272db7d69363274a6efb4fdf59b4d85ab7aefe8d7d9309bcd7d8c23360edcd6700464a5c665dca0a12032247e07f353b15321abb33c8499b6f68b0bb7bd726fafadeeb26fb38456414dd65ac510a3cfbb393b7ac1a631152b17ac4ac52ca4f42aa30af7736e03dfeb6bef076db9429ba7e025b2e7357db7fe012f101d94461b11b7ddbd420585763a80236aa237c452c4a4ecd64e4ffc91f124c27d71dd3a4ec5c203882faf50ce491047d1ddeab73c8f79983bef166a14d5a7095161bd0effc2c2ffb9dcac5b8b80ac80d484b637cdfa1e6cd222461e5103d225e3d07b7f126160d355b047e76e6b596ac14296a9d8b31bc7f4d256a30417afd5ff986049b38dba3b5c4f69b03ae4f29250aa5b1e5ec8a23a0b586303ee2c1103848748f1802bc53edb9679322328ec2a41b0a9bee533f0f4de1a168d19b6feeaf697c1a341bb16a1d3ccec5e7d0c9b606d48c226b341ac0f563d6d05187e673c66fc95aed340d8ccac05ba87961c142bf17b8218bcfb644bfdb426fc8c0beea8ab6a24a6ba51694f5ef06ae36b6a6c646e67072e962b43e04204f92c6ad2b89291522e76575a284de70d9f59e7b2ee2200f41063242e7dbf01eb185110ae3eb8ddc0fb74dd0cf9581a8c0931abafc8f74c7f62528213395a806ca4ae05a0960dded7c47f6bf77b0e28f7b3d2ecd8564dd21759234dd779df79526ef24bee7c7a867a221209add41b7e6baa1bfc621dbc9cb988933c89c30b7caf00113090e37215ca8c4bdd3a65a79184bda31e8818c39b85219cb16303b4ab916185b533501766057cd02e9d4e217255c69ee647522503d5de50df5a9625ddb5232590cadf66261c4dcb0a66e4110a110081a9af3267b80185494181cfc0605a2e839d2663c32684848b507fffc1f1b308c926428de6d23c1050b7f5dc1f59fdead65fcd68f9ecce6f6b97edcd05ec6f402c45c08ce62a58e7d392ffa0fb99dd2b5adcc8198f986e9377c02867d81e45fb00108c4268c69626bb25beeb50f25ff4a5589c38111513317f29059058a6e243b0e416575117ca5660bd77cd6f764967a9f1b6bce312163efb2295ae8fbbbbe86f0f1980806ac6d7542e348a43737d0b849195c4c45bce044724e6648fe285db38e6a84b60a6cf472bdcc6191719e04fe16e737b48c8e1c8bce0ba3c420739856a88789c772fa97ab80d256d7bed0378248e90e74dca377720321bab684c39b169bd42b288b6f4677bc69ea3737e46914fdcb6722617b91286d41246ca9658bcaa72d1363f808103ef279529444b909189125615006d262efed38022452ba2912a480c0352016fbea8d6968a1c1c5aff49da83a953231621876999ec49754e0d1c4c572abe84986d676397eb4bbc040464932b80b11e0ecba9863f6ecfb63583278fe2c2d6de2a3d1a835c69cda2d48fdbfe5afcfdf259e117a0228206a936e337cec0fba5b618970f0ff1d94281e1a73b6b4df8734ca3cca58fe9aa90f283b3739dccfd996fd15a6894c0a5ca3a7646ef5c1b7e0cfb833f2215c1c26f178ce58eae80102ed64b62c08041eba90673ef6fcfbf5e05fee9b5b47cd34f54a9ef34210fe76dd053f206c0fdf2d8199bd9392466af987c68d64110051fab63b59dbcdf4109c58de7ad8ba17c2e7132889a81a4a0fb23b182e155d372c838c3e1ab2af44cf71ca272fd4c42cc2473c2ab7ea90f2502c17e420b6d916c77bf9ecf07b3a7c5dbd29629d6c91a26df8f74e576f804fb0b29c7b39eb3adcebc173d6d1056829eea2d235c39a4a67bb0387dae09bb61cae39c55fd84ddce552955a436b7546ad62a38fc5d76db19198d19e04241e7de6054fa5b07840065ec4617a7a31142e5ad9c9cd104a3a20907dfc60afc56c6779b7453891af1fa609956aeb94babd1e1934ee50cb683ebe062769575631fcfa5a39923adaf4d94908b0c986d07546797fcbb53f5796ac324f98638f0369ada0d1f09dfa874ab11b027e0897d43ecaabe0665abd348d9b97cf002328f3fa839e6736a06c2ce542ee0cd02e5f8ab2d0ff5a34dac6db3ace11dadee5608bd1ba19616fa8d5af5bdd6aac5f28b0c6ae47076bb3b51858c40d3aa141d8eac8912a80c2e37ba56ff3c6aa791e1c1abe0bb03a909518705dc6a5691f9e5c9d8f4d2560374188ff5624bad8f21eb82b0da9d7bc995cd4b74184413ec322bd4ea2f67ad1b270072585647e7f158cc0f7ecd4c95edfcf7cff095335c85742131acb8a194e7bafc8efb72d52ce39132a45b1899ffa9a5053c33980fc28bd29b25dcf9e985ae66a1c535dcdd4a10174a624d8ac4e1db9a2ffbac648030a62263bbf21024fafd2650f955adbdc838ab294d249bd8b4bf5472882391dd2586077c9b0769dd64100abd80cfb566e49b89d9ffc786b0452fd1d550fdeed24bd9bc34d9b6258d266f1bff278ebe63364dd46db378935a047380641ac895cf27ef6a92174ec200547b8d977d59e7b0d39362fa61cadd9416d5a3389062927c5df9482eaabe0a952f2e664decedc2da187d40c1d91e2ea87dc80c078505fc899b5f84a33cbf39090aab6afab64ab7303478b3ac093d7b7f405f7f730f531c8a5c75ff30de9e8d35aa05206adb5293f2120ff9e0e18d91104835ac8274ffccf8b54a95bfadae4559b56ff4b7c1a0b602bc81a186ede873649064b8b48809796ee9a5bd3963e5d2c51d3132c33e5bc955ad1588917f1301d4fb0b17edfa9c612497406f1f640b944399f2799d10b72518b57e21eb6c02350a14b27401dd3a7de957d9dee6676ac61272b37e2ee5d124aaad61b351423d7e21658191e3dc9a3f2fd83e82d94eb7c6f93aa04bd7c86c0469fd101e43a9658a550fe3a1d36f7a7129c5784ea006464f072cdf529d593b1963d7ca24fa5e582248b54d05e9abe5a458ad02b99f7228b26d67b896ebaf8185c4391b3a576d069360bd4584ab34e915ffe90bf27a83e4e4998db81fe9df10580f35e3a64f31bd8fdbf5332350b84854feb3773fbe01d6180d180f8df663e12a08276e93df4270743a48661b8d31370b60b3b1d37b8baddd1d99b58c9f7cfd7a8e318c5b60f5701aa4bf8f6be0dee5cc533f4055b4abb828e86b2a37ccc8884a5cd4748b4a64d9ad2f9f1b8033fdbcde67683e231e6cceb71f667c33958822722e8499d056aa52b95ded6566c203e46e120ff7d4f9378cd25e8e7965898b6725ef683eb50c9e5724ceb13f05cfc15c91cbc0556a3a54f279c3bfc4314cf84f88cf6b45ddc89781bd5e8121cd4ba6456e279fdf90b5571667fd74c02344aadb71aef7a997280bdd4692f57e1ae742fca8adba9acdf9806f6d1e6651ab88c2618147fa3ebf676dbf52f3cd3cbf77ee0fa983f05306a827634d8acf2aaae5690b500e43fd8b609f514a040c8395bcf1289f6e69f2b8538e90a8dab1cdc767d90863f722fa84de4115bd5d205f42afe4c44c01fe8fc6fcb39429ff301370dce4654006a0bf75a2f2a9274af3e6bbf0a755f8ca0fa4267a56c57e458c222061d91f702678b3f02682c4df358d517de9fb23d778ad276b77e430d89e641034a71fa80792c1ac592fb260876cdbd9041289ae8489613531c7e3e5fada33cf845f4a9e4fb426726b04dc16e67c561f5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
