<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"323032680f99bf6782e68b0e3d649db6741bfc10f4efbc22cf3c950e73df4c9726dbda557664ff0fd84fc02726c838ee7755b18e69ba5cf6c12a9292e199cff28b7fde6255265d850a149f4c97b7557fe81e6757fb9b99ec8c1579e174ee230bdd79dd6699e49988283b305119e9472507c1b68af0f7f437ecea848d5e9afe2dda4c318d87ae51dd08f4ce1c648fc6b27d16cda816e81df6d011f30dc9d6039aa1d6e396644fdcd053d2466e5126c834da9512a3d841ddfe6d9c0fd4c7a7083f09faa62d7470412efadbc9214d71bdd8b6b7bea31c38b180cb18e33ed4f3c5742a893a430915370db22b83682c7526d085ddb5b3e7b70d04d197f75ab29fc82849fce558295dabad6192240e86a6b3161b43f0953d6ef8f16550073b752cebd39897199dd6c5ef76c45f50bb2ae2be2fdd6494df2d1602d4eba4f5994436e44049729e197e1ff0193a3a4c1851332d1e37dd47204f9cacd5e4511c356b321a5850b78d4805004feb286e46671703388d294fc241a185eaee1b85925af62d314b5d101acd966c3e6903af7bc9f86fb8feb9d2f19337b5d831e36e16c4c055031ead7f93131b3badaa2ab454f5d74f5d4a24ff8706f7748aee24714f730e293937c01fbcd046ddc11178ca7c574c95e07310d41538a90cdde09b5812d2a19e39417c4d6ef4a4bbde73a3dae8448df0c534191dd2755196d0302623101081ec58f4164ef743a3ab33b53f709a5bc3c1957736ccb0bd34637af5905b2746a75a61b75c4189916b37f6294e5ca40d34454615eca85de56b128a9c016069cbc89f3fbbe73f967e12565e0a7e1351ca2f4f214e1b979c94277c7412fadfecaf6d8f11f15c860a01d8fe94e5b86dd306492b577b8fa74afaf8b24c03d91e5454320d952fdae71429305b5c706ea344dec23664170b9bc17d8ee0b26f02c8485621489170a6736be0c9c1dc632626e08a25dbf2465eabda5461cf55ed27556dae8281c42608087b9f3a7efc28d56c7e95e9c6caeaa7c7fae3538b8664cdaf3b6c9b9da11047fa3b2f2dd325d1a2f9cbf3af6985351ba3200ed86f9295790ece42b34b1c243a2da655143f847d4aee24b07afd8d69284104ed074b88fba84d616ac0e5814279c0e9819e7b73a7d705b294c280d3cdae3dd59b49b7091142bc7502917a653dca1f8c24225791f3fcfddfa52ab60f3077d9b739b46b22b5f99e5d2dee87e53eb68ea971e1ea5bac382bbb3f525b9eb1de732666931bb298a685ebd140358ba9320375d7fd1bd695003165554d419d414129670ad53e517d61d8933791bb827b2e89efac15a36c4120f978f78ad141f2406c3e7adb759a07ff9c0efe0acd10778107947b6dd73e672d83ab5e5b8edeefed76eb5655ff9f3f93212180718216b7271c3ac3d452c4dce0dfce828fe6146665b0584db1c3e16c2b07b704b77d07e9883eb4b01ecdab7d60c12b89dba12e900a2db86cfe54abf53a3cc17e62d6ae9d44b5560486d69c1d20f6331e2ab15d0ac9a7129a13d25d64a92abc765a162c4cd858c1c826271a066e516ae1ad90fe983f496551ef499f205340eb01bd8bcea9a217917a8a5dbc9d06ecd05155dca9a9cea7513639256b1f8477cda4449b3715e75228b10b47876549271958423afcdba9e8ed1524466fd349fb91c2e7490db8143eba15be9b1cd95a09cd95d4381bb414ab2c8d206e589ea15a4e190fa76d7a2d1dac097bcb919da8a0e69abf5c9dbd52c99987f0fcd45f661a22f62bf98e3fbf7cae69b32f881bfdbf1c17c90bd1d17dc9068b702e2961761488e058549935b61823a3219998087deeb307533cb9b36dd46774f9d9ae4ed95eee60b8791979599bc82e81e9bd9e66f993380882638d8beb1049ee7f3c690bba016e14a69558118effe6a7c668cbd64d6707701c3d9bff1f317eba447efc9814389cbd44f4525d44a4fe05bec68af73227b17c778b5159ac435f0c8450ce2297b46c1479a738492f869e3190224684bbfaa77e4a4369015094ab8b61a9b94fda78cf7ca6a9490a9f64f1f0c5b011964fb478fa847524e5a4365c630a82e1040f5dbc85c55029da0c8d378012fe449eff917730ae45c27f2160900279e18e0857ee290d838bbeb8b5d7f959b68c22d87e2c94dbac1c4f9eed4018fb85de1590dcb1f6cb1cd75dd6c88f8910be3c4ee95a79d1b314a8dfe473396834edb426e9c44b44071be89e785459a3d72e3a46912f469688084cf1f14bcb9866684dd50615aef643e3e554e894572ba6b854479553f4792e18f3da0607a28d725c4b05c1347245e654d48fc1b0f82cb30dd58b17a69ea78ad9755f3944b24850f5fb494315e6e75cbe256499d715499f0f8059cdcc0e93c6d902df4727792e020065ef4d0608bfe0d1bac64fd8efe17c553882becd0daa5d19a1f236c50fe7596901b1ba9a4a0d28329febde09c8e951205e7d36509dbbab4b03429374b13466c254016ad8286778cbf7d002eef98a0344440b00348a6960a78364e0dd9f89d25e649ebf3359e6fa1729fcc0748a15b1f27cfca5be460e6425a9bd497a8d7a5d5250d0621055aceafd934005cb6546f5ea9d939ba986962c9396126c0b720ad28528e86f10df60f5f1e36006ca2ac50720e77c9c471b63181fab89158755f50b2ee25ff738fa5c5fcb96178289209d1e6f51130f21c16d80898be8626b2cd983ab315e5d2e71af912d448381933185425121ffc0237845d7fedd15435640881f54d308085bf9563ba3a6c66d2739dbe4e0a646fb6d16a913bc464b6693843ccb352cd2e1a9634c18531a50a8ce01b8f989313cda8ada4352d6ce31bbc5b2192ea0326798cc697e974f8f8ef929f155961fa1cd105b18625ba242c853d5c5883371f6edd34ffced1eec114872d5b91fea6bced0debe2439f77acc86584d7224183da6d580875489868c6a59881b6c244b1dfe87ee900f9fdfea0e5730b5dfe290a05eb6b2e5fefaff7b3ef1d5985f9e77653ecc7cac6d8341821acc6ef68f49795b7424c0e6e4f2f84e4b05b45ee3a7f5f2fd5d997a1b6f06eebd0c2fb4f210c38d6e787c7dadc409a164433787066053f7242a245535d3385b23f634f3b034d3f39911df5840b2af962beb1409309955f0cec0fbbce70314a8b329483dd3fc263798791a3f1ddcad4998b5525e096eceb7f2c1298331940f6c9de34961e3630a00c5e5b5e830f917e1cff2533c5530e06daebc47197336f21a915e35d80d169b0b250dff0fe876b89c8061dc3f9e69f45f9752625031bf8a4f9d472f890631b1b7b1b70e2ce98777644f9600ad16a7aeb4221a7675de926b400e2d6361b72b7263f74c00f8a08a68a7d6a9626d3350be27c35fa62eb401bf0b7644bde409653d02f77973a4d30cbfeb557fc2c6624cfef1309c3279328057ce1142a0e9139230ff1fd8224edbfe846bbbe537d949f7b0a8de8a87e9cf25d3c5e60d4aa240e62b00faf0e53723564cb159e611bfb6f83e4c6a1cfbb3a7c910ac097ab75740ab25eff17375d6bf9d9bf2c3b81878203abe2cc60a8fba36cdf63b5feddce95b855b29661d0477ed9c9247cdd5ff839e4ee245195dcb2aa2b5d39d0d289334a5bbeb7285e0f14b990194dca961025ef17b3f9a4486b81a66a43d0211f37cf831fc683e0c713d8aaa8557d52cc356638c724cda4bf0bbe96e875730e480a5f97f82263ab31318e3999d3a8c96ae24fff49713559dac476fa0214a2e046b0bb655f7cd038c63bdecb8daf5ffec5da5ef8aab6a91f9e5f21ed0eae80bbb9fc9fe0e329aa9d9b3a3a879c0f6be50bbadd2640516b07d66149d3ca9906d508b94e6c0161bee7a238c1b59d2e1b986b95aed0b1c5b35387d6e8c2a7651349517c6b59b4658cb0e82ee34e53f00c6f19f812f0884547ed9b70467e44f415caa8b828fa43eae321bd92fe53e006cf9742c1806d53d653e6e8ab0208969c0630ffc0079b66c3b92626b086375d860428e9587c576daeb8d8d5281b437efdca183082075f4191556c0ee706070c97ec19eed258da6c5c3cb4d7b12318b0ae90830ae111a9cd4302f6205e2aa3ab557ac456de21c6823e955ae8b6e10f0cb719246ce7d250291469dd45a62a78d3355ec2c1bb5c8054526c9700e6d175c10927b3d59176f1203b4dcf84c3f67fe1872ef0d302483fd4e6f77ca0fee3b59e46205ba07e7401a3ceabaa1204f52a892bf23dd2399fa1b934d3fc3e128cf14a225b8a750161781d795673809468cd44a3e97e49caef0a6f4f622b94e12dc70833957199117ef93214dfae67e5d7cff472bdda19f05ab3c91d7be617b0662755cf0fa045bc89b4684f2b9e3ab8b5cbb26d9b873a4397124ffb590ba787852976d2a6062206ca65e21f73ec3b37eb7adcc5f7c1f318818b160e730a3e192061c387fc84d9999129e4614253164a411773a567035dc216bb9d6b42c029e2f49faa2173f0c0273c5d528a0ff2a4b8360d184217297ea659dab0318d78f7063d0f6fac64c4a3cdb9154405244537ae48b032c78a9827a2e4d0ce0275c2ab780b2861bc33b5f7a4ab6a8495f46e84b5c1eca347c3ab418842fef95a18b58a1c9a1352f0a571bfe0f30fd53afca6e35ee8a2af0572c3b11393331bfed0f393a10ab2f780f963793bc81e3b1e34682bc3da69424be5f410fa40a1d20f2dab10ad2336a732406c2af28ea090fbddd8b6da6562f5ddef6d0be50f77b8ce9f0c7a4d6baaa1c24d2bbd4af880be63548e6353858d73c121a72c3168e59cb19c70d25b41bb13ac43fd1237c1f3c66cf890785ae24ebef9ae149b4d51e0206fd61f012180812e1ad5e3d3163810b72d51d40be80a0da9c1ecd6cfba02616a1d57b03264eabcb020794cd318cf10ca2b82f3e4115202314df8408baeb9fb95bb265d3c7de0dc46f0052dea490977381421c1b376070259df4f8f0f839502498650a31adb67283be4e497881b89edc52ce6bd273ff71141e52227f1ee3a3fc090ca9d54a64ae30e8c9c57034783c21064a2b1f4e1cfed4da73cee5c6bdf5afd43f8fdab7bc39a3ead1c80ee0c1b9fd3b4b5c0c348e2b1eeb56eb2fd3576a461ab0e8d707cde06b04ced1291c7a6ad4d0c52e361a8f61492dca9d158eecc21906d127723de1f83b9a64398b91f18edac24bcc8463cafe02a51731b28fcdb8d6222ba4d0822a595d00d0d0a4ab27d93578f7f728eed262d7c3e84a47e5f867cf17cc39a89ab0234dca30d456d5b4ba8aa444c7c35585f9160214ac7af400fb59b5d7d8f9a4bc764b363aeb3518c9d05410d7eed403a6862d80274a8e4c63a953dad09339c03d258c37e3848302a97eb7e6cb418c128ee5e457933914531274798706f7dfda6846c7fe30da2f5c579da44c7a102611a6d670ffb6d6113a08d348caac0e069cb8688448bc9ae469c725ebda4a85fe9a40dc44655bffd8a12559fbbc579c56014679e1b8e22b85154ffe8fa0c42b2a973666f323bf1b79a1f8d7aa944872f3ae71a51591183ec9a9f42c8cef3f843135032f6bdd673b655d72112f87c7734a44bb7d3caaeb401daccb198fba9e1567fc2ec80ac9a7e444b96b18edd7cf9810e52ca8964fa5161b308236991a461b0515e3f4d312448a1c38e2f34f4bb7e25a89a2d92aee4966abbba2fefad70c1aa5962562f8198abf501053524797b342837c88a72857b9642504cb5d3bedbceafdc3c193028e214815de7f09d09fe3dd6b8ed4f40b9b73db6b89b3800a9db199e113de69dde6e0abae7d1dac0df7d5f2ede1f42b6c36a96bbfc3f20a1127f0ca90e5bf9de65e27107056f35c5b88781f714b2a86dd61ec7af239415940537ddda3dd9927005be1577e72be298855b56d9729fa577a44c44dd5604c917d68cc2cc11f2dabf4619106127e4dbfe6bddc2d721266daebc3d1bb56a5497345b15db75ad860eadc45889a69f61973c5f68361a8e7dd8d9910db74d5d70d6e5df7537fd1ad2d63cb56cda6da342d909e8fdea983b96f874acb671f0d9a5bde62655dafe169469dbedcbd36992a76895514db77b36954eab7ef090ff2d46872a09144b40cbd99c1417b14ba4f6801bc9d85e3296b19fb40986a27587bfbe62b85843d4af058ef9abd0cefa794d1042541860b4c8c5b4c18f8daed8874972349c7a69fd09b048f349f3f96a3b397be3f6b041da2a5095a00500f48fb4dab8e18a4889de4fafe7c0f669a530bf1057d5843cba09848f0dd9c025c5d9635e3995341f94140101c258a9f9ea7eb37be9db8344e01839764ecb2d7c27f38f8c2c571604aeb6c32e5203dbe743e6e5d8de11fbc1cfbef3a05f47c536cefa2b573fb4a9e5ba94d4a695b66c80aeb53c60ef378aae94a61fbb64b673e5d5a4a5118ff1523ddf34a7f722f1f5c6e02bcce7bcc67f9ec2d0326c5e92ebf0c94f67ec8d5c21b93cbc8fec3920f113d39831feeb71ae9d4b4b5cd813f875a19fe9806a19f868d8a0c70c328960206918c7460524a53da9f8820a6dff32488a03cc3b5960512d5cde8798c98d9a18682a7d89bd80583265eef66e920302c35e83a6700d368d6e459ffcaa81669427874976162d617bc498c766de0a1be0b120052f72d14a8b06d3c83eedbe596a80280db21624f6556c4d31595bf69db691649322ea9a01d4ec93fbb2a7e20cfbf5342f5663b2fb42587ac722d96bed90ffc9277bc6735d2da18c8015988659433573739251edb01d55c9c0f7c6c7fd1252581a0c32db647f1175c5d77e1a28a1c4dbf0a153b0027db97ec68c32c03a97a7a2f4106315f64923b7cd6e8011fd8b4f1c06a7129355e045612b22c3e198fddc5c7951fd6fc19ed51518a1d1a951ceb94c3bf1f05170585e55951172d94e84f5902490e8f8a5c40c0e16cb09ad31b9cbae8b8fd1636bb0997c9ced1610834dbcad62fb0562e08d4ee13b97705e51105a8d23d91dd06f30fd0ae9bfff4a28b9c6617a6d6d09b3c20d030ad5fa64cd06f586cfbda53736837247bf5fe1e583d951d440bc010b707dc7ad5673e0bffcb9b45f3fd96906ab7e36ae86196f582e62978bb8ba4d871e172e8c5e5b2e208d1fbe0a31f847894e64bdb402ef9957d60cfa537e5915ea7069490d5f978e72d38ef9c8ec0c3b8d8170cc489689d9c1e29b4389485a5b1e74b0097a73151904a2a90a6438085427f2375b9d7229612d2bc99d91de2f94ebd2151e6eed20903f592029d348032b92973705141fe52aceb63b086b1eac072506bb61ba7bdcd65b91035b5701b4f751c86da0b4527935b4d0ca1e1e126b2fa8bb04f1182406a780bbe0af718ec54b00da52e6ce8de7a8ca67c7c52d563b71328b95c8fe58db08ed99fb7960ae0d43f310ee6660b89f654e5cd15a423c4d7fc23def3f286f3a33df5b25ef6903e123b7e1ece8b548a287197e8491a111bacbe82ea7d87fb2bfe73cc9f1e992752ebc36a04fe4b9f9debe1e04a6988171acfde541be89f1a150169814d089ae3d5617a84ec78d900f1042c43c4ecb956a8aad9e19f40e78d654fddc80bc2534282b3ba145d22781145b1d8701076c87dc483681569dfdc8df2a7e5dbbe9ebd513c7ce09d968b9ab96bce7932980e33357f3f581fe682ca63696f82413de74ffc7baf5860c5b2cef32ee0925cfc8f0511116e4dcc4bab354653c5d2375969cbdb2898055ac21f3eebe5ab0cca180e82d8fff197fc82b5fa8ecaa82142a4826fa9e9573f51846bd120bc7de03de5bd3dd4cc5dc3a3279412c6839171f6b2094793ebcfb587fd32f27904bad11b42bb167566f797eaf117a47837c0758cf41d1ccf0e93e8624af62c2bc1af6b6d72bf608ed43c63047455a30ab70d1f04320ffd4149c28f06eb1366745b7ab1790956f0e3f5982fdf557773939d09448100a5a906978e101beb671bb17b71ff6ca30bf5499470ebfd432d4f990deb9c6ae9d4cd4454ff1c51313a3c8025acab94e55c372f76a9e8ff2e828b150fcb8e354ea4c641f2e20485c52b5731b49230ee76dd836bbb9595f6a04ea332df8dc3b548671fff84f3db5fe37818108f6409c00e778f7e6f60849cf02986aea983633f9c697792ededa558b829299693ef88d3b6c19099bc4770fd88835ec82eae82843f3f027454d70683d9ff76cab4e6cac8b40c5c5e1567ecc0e01b2240d2fb862403741a0c229822c48043fe84e7ad3d194a21d3f6752609807a6355abb0586cb417fdf40903b269fc842940b3b0ec219b7e48aaecc4cc30fb28bda40beb210e0847a621186e04cb63b4b41c20cc09c5ab861a5291f2fbb12d47a8a8fe83f7c40ee3c9d46d4ba3138eaa9e52a8264d4d96b7b5344e2f7dd64837eb2ae3236c8241990e8d8dfa0ef99724b559d01ec23e8f8906a12fa57b2190ddb126c601e0a0ab3ded6e0f2f5f85899926485d9b8dec847dc18998fd9ef59e2273c5b740adaba9bc3bff5e2a405e9a2c3313417059a07353742477567363a4dfb6c9d5a0c22b5b37ec952753ddcc2203f245374f02f814d16ae5298f144fa901d922fd8719db6ced4054a0f59ee2fe6f5f649a18da81318c33d97cb907fe23950f7bfa188f31c4a8b9e7555168da049fe58f9b43cd709dd6ab10250c421e60b221fd281c20adc2d70e5269dee9bb59ed0f88caa74603642ae57fd68095d53ad15efc55248e8d953bbefb593d11cca2c3e0259347036cca62f03458af38a9ede1690bf57afb9cc33c2aa1bcf444a4ec82eafc348e41b4e8d886f1cbc6ce0874f02dc2b09edee6775a00495e2a954b910989f831a0027f4cf9daa986f42e51430655da50bad9588722000952b4ffaac8afbc5e56339177255dcaa3ff44324d2a87890a66697051444dbd1089d153d79f1d8db008f5a6940c4fab6dc14abef9cdbfada92c111c9105bfe01bf392adefb85d435b82c265005334706a90af4c9350b422fe99edf29cc2171f24b95c13efeea84c932d64456cba01e29d00d72d4ba7f6986f3d703174625467e6c81a17ad321b765d4408170fb1200ce2dce5bfcda855077e1004f7244ae2ddb718d1167ac6c87b1f099d78adefa7116a9af64a039a83d942b56e84db9fa32b697c08f50352add405d5b8b1a9c44fbf97492bad5298784c8f5fd0f62da434298ab022823bce752d5be7d2dc0e1b21077fe774695ea7b69812c21fb80948cee890e269def959498a7811ff00f58d99770d2ff4363e94afffac987dc4fe7a845b5822ce0eb8f5769a4be66fc0271f4c490272254e02d87ee7da4c436f0d63e2c4f67a9e5d12abc79fc83ffa683c4d0451891c6d415e69803adf43315ab01ca2b9cd7f68a0f74a4ab9963206e4724bbc35334f85c18afe451d832210fae93931d4fbf5f91d644518026dbe7a6e7ca3cf34eac321743a2ffbb19a36b6bfc851ab2490bfb7d6f88e5f9f9643bee19816bec6e3147ccdf3174386f2e5e31629288005fed6c74bf78c14aff148a7d8525e577ac5def8a4cd2bddb574fe44db93049c2bd34192537ea46ebbfb0e3459d8b3eb2926e8a08e1e730fdffc89d408b2e1a5e952bf3eac374883bec364e91c6116ec77a92946e39221c15be15f06f6d1536918915b4fe6049520139a350a8de97bfa14b35ccaed61e5a5b268551c88086b8d23f5eef98573a95b4875ba25d6d298d92ace1b9e64f3e7df836fcb4be5fd2a9eda192e6a03f39f239aa62fd6d91996ce0d9905d8928b3d91dad47ee04431bff37ceb84d751917fc9349c7f098ddac1b3a35197a9ec37e46328dca6418762aa5d82a9118631e7bd701731a54d5d545cd2f955135fe47589d88f52cc49c6139e3fe9e62ee4647bbf40df595bb53b5904db37f0d287a85b1b115aecdd29bf3edac36100c2e2a1042a4ca53cdf23d4cb25145bb594e3dfa0d8acd5b668e7b58ab135477d01dbaaa6e85893b0040322f57106ff182213379619c6921834ec2cb43fdf9368d9d2206fddeb1898e5fc0e5ebb485e338021fe4321452efebe25dc60031e622757dcbece39f7fbc453bd1e84f8aa3d2f9d646bf663e8070cdfa0977fad06dddf77890012c1b4ccd4ca403a66edc568860a9123ec4e244b51340b255dc47948b14dbd9b9bab4162307c5cb56fafddd50af9fc86ff402660fdd97cc204c4427bae92336801d580922e4a31cfde98d07999b3260602672198599e84179230fb351fc782a24d2740f98b1748fd7bfbad1d64ef29f87e38c137583de0abf2407fc7e6bde3e57224e4a8dca5f7043e69499a082fbc161f245f7291ebe13512f27c27d7a9df32b93394e31b21a0e9d811aa52e0189bd09d081811ebeefb5d547906b8b73f74361023fbfd222e282665c6f40cf58f25e6ca5d6e84329523712d362e696d7b2a2bc7dcf3a0537b49390692bd563348036d503d0143b145fcf5b4fa462c541ce1870bd175e0b84b19dfce97081af87c63e592c5b0d908dbbaa7654e8e9c486782e6ff223a5720d40b6875d1f0fca6e34029c40fb006e3be79852f1ddf9f7ad9553be23328f3d109f08429c4cd838daa19208da465a228c1a0bd9c626ee072556b5af3428795dd064719ef014dfc1fc4de4d7470f6fad93010b0332ebe29daaecd4500daa2f1c02c60d32960f10f78bb0e68de86e25338369da4635c9506e31fe7d3eb910dbc4f78f4289ecec13e3d97d34426112f852f3f29ab611ccfdd137780f0f9d6e1ce5539da71fd10ac86f081e27213730fe54becf4f959f8e13d97dff2fa080ebac1fb9e0ad2b6e31acb5953221b1e6e359e6bd455696b5db2c5d677197c7f9fcd38b1bf5b217fa780b8b9a59845684a9ef07cfeaab20c0b0c0761f7183c70e593dd41f42dcb9aa386d57cad432e3a133c888b190c59ec53823e8f468953d888b4b03193de2b8ca07bcba67f724d804d0a7316db48c53271c942087fc8cf99aad1c8e1bd28b7e45a1d13d6008c918ff692a28a2a7715acbc488cdd2908578ca869829e8e9f429677504be5dcf73439102b608d9221eb569902d512ae7b626cf9fa69bd5324014c4a4cbe81d0301bbd8f28e4fb95ecf7eba53ea26142e978daf7f80aef846f82caf6d5dc0f2d6c0a3abf1c90e59693c38155c77c2f38f5f090eb29fea9df0b5eed47af41620d57ca91399f493b4c09f573d6a8139b8070c9e7071cb23186dc2e2db5c7021c7c34bd61284ecb5bbdead92de6eb11ee1f59b51eecd26e5d60d4caf4188daeddc4e10da775b4f16094f682ab11c826dfb048d5532f899bcd5c820cdf399109055cb5ab5cf39d984e9beff3730319c281e8f63f1cb02269130c02be4c904fbea3a47eee9ec978063b1d68b67e67734610f6eccf9243d0865eff855cfe742325800a8e89f7a283109fb65020c8123b8431a58dd31ca07e74506af3bda720ce13b8627a8049a607ef97660884c5697c808e9ac0cc0ba100762b03f5e807873dbeee34e360b136cb6b66a3e61ea9dc0210e09a438dfde17d7201948655835cf53cebac086c0a4070de11b8a9bdd2d14669bb0a05d7351fe5a681d32ad68db08fbc192cd4da0b4d8ede85344ae840a26a5012d65084ff2c823e0d0e44b5e4ccf1abc65c400d9c91724ce1b3031d66a1d0b04abf4e063191235a194d11ac97a13170a72f1ca6b12e1c791a4f673990b73b4392a52e735f8efdaf4a77fd442140275905991bb1f047887db12feb0a8227e75bc9726d9772c111dbf53d4964a9163c29d6bf8a08f41e3c08035f6548a2af41be50ec1e6f04127dbb899af92e8b94fa31756d47a57fb004ad1e6474a891bcfb78525f436f6e320dad8c1fad9792d4f0a155857b31ca61e6a1510439a3ef48a15631b43c0cd1d72b894de667a7e09b4147f6bb7ec675965146c1c63a7adeca008b64e93dafc288ba67f6ac2cc12a23785ac18d831d40b7f074637850664736f3804723b468d1a76141445a526ea1ac740519ab910176a463bf8673faf3dffd424d43caa2ebd813ad21f710045d0e7c02a215dfd1ca49a56419211a8e4cf361f6e3550492635ec3db6ba8dcd9b4d924455bcbf068f808b85395b7e9f64e71f4a432a2f1af5c07dae0dc960447ecc3a48cc810030c6487ed4818bd64b3f4a4a894ddc87bb7058fe9fcbfbe9b0edd1110ec469e2d6eb4c0396bbfe6a74e58a36444dcc5768b05c599449b5545b958cb22c1a18f4e930605ba14df45ffaccde72204f01de1f5e4c9e42c3ca445a9b6db517b3249ba2511b02655bf616221f1f9b0677500d9efaa5f20c728315e0f1026338ebb566dcb0e588a493a3f0d116a937d278029137ebfc3f6debfb19bcee1e8158d2473c56604f0f017ecd8df1234a93d1018bbe4e7af0e88774107c3909d8f8069775741c038bdc0b2460cc22e67332b05f0a3adb5d092f8064ff8c31a5f648c68a1b4c5706ba30d07ee1a873becd713b3e6ada11115293058d654d3ac4660867cd406f2f4fc66c0874b549cd6ee1c3cb8fd7a517474cd1fc4dd041e3257d5119f682137760031dfa1a35c86756534326baa4b5a2a892514dd5e326fec282cca5e3609daa94dc5e2304d72aed883b54b1d5b80d360c0f6f8454052d486528861ed571ea80bb068cc2e2f88ae6cf74085ce58f8a59bb55edfc750b000cde68a41914ae5e8072c69d420615e9e374113d7ce78eb6ddd9fb2763440f341602404fa5f2c84755080207dafa3cab1eb9e71cf992260c112dc426b93980b42b127813ebbb8595e1bc1c396fa8d40af434296d3b51634120887dda7c9c0d2e32d47f952191f53fe9e2069b60cffab1b062a2b8f43f980fe63ce6db5141893c64656bfa195ed2889bd941c723076a49e41483c496c9eb63e81266b240e0c7b2d06f4692a0dae1772e33a1bc2285bb73ea3b0596348dfaea641a8b405b78a64e41a905470ef6289f00d89c5d4f36d0e5c362d9730561a30ad1d6acc38c64c36eb1f8c14b507b597f9a673a73df266e071f135add7bb3cc61741d89517da164fe6cda7132c83c2f07615bd355789d1c18d876b91e235ff7355d4581289725d1ef9f2b8047a5e798cacd1ffbf350e05d7e2d010ab0b3ae0fcf1dad91c0b71adb2c9101970dda8f09656f0411450bb6143ad58ae2b6b90213b5c99066d8a4eaa022a536c95626c5a329417108b724045124598fd87efdb9d0b2b520aa2ebe89d4f4d6d5b47ea83bb75d31dac29c985df2d6657a6cff9c02253e00d073efdf31aaac1b4c7bc0b58112101907dbf250291b18803cc9a250d2620eb62f8b8a6612af6e2d49a7174443a871cbf589062570c5a899563fe6789cca592d41af3dc537b87a36720a05204620270bbe2155e6916e59698ac8da2326f14f942fd6be46156b2101f8235b91970e79ee48f311b6f6a4a3e91125ed350ba30d328685f354218ba2293945e01c34797ea0cc654421f40f01ed85c5471d642d8da2525854ac11c3bd0c833c68a949fcd3a494e79c5ca46e8d8f74825a7c2816180cb6e91ff148684bbd1a36a23182341dba263ca1d30ce6ba6024693390c0295392f144b247d0193753885266687fea8da978687ba649b07fdb9d7ca7d0f510ecf6324a9f5cc45cc255acc6eee95452487ae048bd0406c5dda49a16ec8fbf8e658503be0129d8b43ed217ca3e60d6c47cf8ef135d97f03ce4f616b4f9c0f95a28db319fa96d27e3529fd4e228157222e7a1cfaeeac03667be1248c32ec889762746ddf8e2711a643f6f5ad8c913515b25bef687698289c488f06a8b50ca86e8f16dcec6b1866d4b39cce55880f0bb04f61cac59550521a766e4fe0c41fc52bb55eddd12d2398b8b730a3d03e8f94f406e3916d87f453bcfb84c912a0cd1c357b3d805c4b72c224435436090579273b72d06338235ddbde89aa6e02046b17c5abb6e2e1c638ae8adb6e721892c3b7fa26e629bc0912623b4d91c5df8269890f7b2e075c26976b75720db85d3c43033e6c76e18d5a59adadaecd0d0195e16c1c3ced98fb10ff3c6b18d72852acc773d3fe6aeb242525b80659b349e8af0827efb3f5a226a411049a07059db3479c42202b8a1efa8d93342b61e33e914e3c660fc2c4b26a63969b64c26c49dda882cead9645dbf8913bd95ec48be3b1558cac64bbf7f23039e57dc0325715e230b36e7f104962b1080a6bdcc11809b414666f16232cdd625207144ae203aebacff449185a47078c79520a0ca1b5ce6ca8dddfd1dc4f980f247e0ff84ab8e9976e65feef883880d9b935b4ef04091404380439da06eb8946690b2b624ef79d97aef13c7d8f583402a2627c371031527bc552a37a7abdcfc4510e8cb155b58f7a339ad171f36925b0154bddf6b6175ef4e5b30a6388ac1f27263341d216f561516bec0940f884fde1347e38d86a685b51f0f2eaf60d6f432e5138e3571f1cb35f59e5509b2588cd164fe8f210c64187e067a6c7840865df384f23e2021ff7d520b6b6b4b42eeb9b3e04df8c4a93863ae73c6d6a5558f31f00157817a04ae614e12c1c319ed3fd6382c1027e26dd8dccc3f2f819b6357ec3b9b35baa299658ade988c33bacffb77887f95e4cff3f40ab0c736cb37bfdd19b3d96cc4bae4df60fca447b81f5c92e80ea7dcb32fd06401105de14d47b2a4985b8cc620b2f58d6bccfbaa63c271fe08356d114325bcf07121b86b85a8b1bb95db573daa45da7485cabbd69a1b629ee9c5617e99db8125f714dfc6f67badfc4b0e93b2dd4dab4c25daa525277a40c9e50c98dd81a257d4f73ee7ea889f1e880857e717a29654b69f916121116cb9665ae07d7340fe5700d0eefdd95920701538724382195d1dd5ab1f093c7c1c4f8b6d89aa517a00907aa04f016325fc50d23ac06729edf9c81339af16a67a53e85b642bd0832d4291eb2e707941de04c15407e2db9905abbf8f184df2fa90ea8844cb65d2496b69d44ddbb43cd9a04342ea099ad18beb45fb8c4d61182f302edf6b695ae1a56c08a8e5de7b174921be514d790425a441d52c78274ed5fb4b415a513c23783ec9a5daa5d27d7a83a320750b13c525640214e593978000b65499bceabef0d67c1371e123256db0f65fe74816c01a7cec2ac9fe5d25afadb2273f2c15627659ad7e531ec8b293645e70ef933361ac2eaa713e10c059cd32b285759426196c1818a2baf358775beb28749a188cdd5544c841b00b90ef0bee7d0f3c073d5deda1d2d4fdc36fa9300cce0023008f9e4946dfcb3782c03370b431748e84b24a8c39667f2885dbf5f99c0c1bb20d32000121acc5cc412bb95ee89356606594cb46bb834b576ccb3f177be21b4bd794ddad2b0892d55c127e8f6bfb99ce5c4bce0eb1779f175d3384b0d512221502b54500af433fec92343dfbbb39319e4789bb915cea91e911eefb9abd0ba366c17a8b34b884d436f81b68f20452f14a75f0c6ad5af43a54dd30d29b8121041233ef8db747b9e069da3ae6c4f2c8085177eb31727cffdf27705fb25006461ae136e0bcd06dc7de085532e393de0d322bea272f024b5959e86d1db566560e9e39ff1fa1163ab42c2477a938aef9138739ed6dedd1a6e09824999ec740c763ddaf99dfd6c60bd2a276ba0d8cda8f7f9d871eed04f06bc9a8782ad850eff739e7204106f15d8fe343a1d1cacdc34a9384cd94b474c0dd73ec3ecbfa16ef7dc2b60149b2610f8f8f5f3c326794a6369d9e769a4de72eb54a6fc9bae1867aca68ba07f64aefdc3c143babf99b22ba694cc42ba1b1dd168d203fb2901a122a14146f97eb6566dd8d39dc8e3ff9eec25690c5a7a20074d03762565485a25a9e6fc711419d4e3065bf39ba959297025b8e8b6d4f05a3f95dc7a87a2bc9c2a9ef5b8f28a747112cb46c4968a321fd47e5d1300a5e44212e766f1c024b06029d5de8550c7ea407fec563d45c4cfd91f8b567069c287c391d472fc6d855aed310abbee81c97605f1ea5f0c632c93a9575e6a94d6ef009a4ff30a4024ba341faf2b6abbf28411edb5812b921ad45487cac9ae46fbf6d851f0c647374f01814b453d841ce6aa972e82a25a9f0a21614be886d6a017adb47b54412f0d27e5f7d8da5cc28be55a536495fb6c309f2feea65e86b167fa7432aa9063d0c7b1a0aa5d142ec8f2ebd79ffeedd8094d34daa6e27f32f44f34d7273e5d74c4451682e80e2d6553886d2a79fab43ac6b4438ef817ba78fce21cd9e47409a153f44beef416b7998fb26f86b698b1b9c030d305f99324543b19f20fa2d9d606820dadb3ec5c752febcf61d7225e26d8ce45707bca0164512c7484411f1ec52685ab2c391fd19f707822d43803d62e63071ac7971465ee36654b4e41b7a6c7db46438754efe6c34d3cb16ad5f2118fbf69e8dfd03a516e37c410d6031e59c708928ecfddc0204bf012029df477d3e43859dfecd7d9aa479590fb19612ee0d2e5ce5078aa88274d5941eb930e3618275c4803639d6982287f341fae99f7f7c5115e0626646f7978376e2e3ba79d71ae08c8bbe8fff2d4558e3f3c371bddea4ddc33d084d7acbfef86ee99bf7b3349aa1dc46c9d12d0bf1470a806322a87a02009163d994e83f6a372f1d4e63168f2a36e0c4f16f01022d8dca3b76c2b6439c1294de813c436d64ef90c7aaf2ccc991944464ed2487cf480ef04f298bae92c60c5014d7d0e363207bd1280c98f30c3dbe5c2749d76b19552d285a4d6b1f4f91720bb702f5f25d207954879ace806e4cad47d2dd1f724229ca009aeba5dbd9c8cdd03dbb69f09bfa3f7e365d7254718c7f5c0f4ab9f24ce8c44d9887f64ac28f51102b88c42391a8298dd51d7dfda18a7edb41de5b52749938b32cd60c3139d89c46bb435fca03ba2f7d473ef3c28064f1d69717c0ec63e6e469440499ad5590e2701fb4069678288b13ac67894ab95bbf705f69cca8f49d32ce721282c9da53d0b65fb62f3f05a73c2562de4d6c9c8e7eea7c4f96b9dcd875298ffa8deb47b0d0f0d3cdd7638714f0c9c9d6d92394ccde10fad010ad4c5ebb07666ddbf5d7fece6e9b08754e7b2804de2c76a87a991626bc07aa10190e62cf5e1430c923f0d1270617f2f1271c315d35947a8080e1acde4f67fe57a4b486b719f64e9ad488beabfcfe85529262a0ef31cadabcc1759d1a707aea35e940d29b7f7713c1866278cb97c1934b0b4145bfb6bb94b36833c66237950c2867d76796fd2895676a898fab338233ea83f43a76f7fa2acc84f30b940ac72460097d388248e73c7257f1c604efa2b2ddbbfbc5180bde3019f756a684b2af7aac3607cc806f439a82ff6a27dc771e1e6ac1a07b5a73ea1b72f3847a1a988e980e6788e33ac786eff50763461af1c6937b97c00bd90e014fa5b3cdb87b5bad652c5b977e161fb9c5672d21f9a97edc8aef2f4051adca6a8be8db11e90953ccdd5cdee2b26b7b094217cfb2f9a543a194d9135458c6c16f1bf664c0744f0376187eaee22a69f15fb05d6bbb2db6737bab578233ea63d7c4906e9c9ef3fc4fb4ad5487060e677fa9f84c7cd1181e2e710cece63495e4b6465a0cf30903f906446dd8f4de97c5b897d97bb8d9b23e978b230fc0ba36e76f8540df4f70e121d89ebb4075b7cf921eba5ab545696dbd9286cabd1a25969b1577077c98fe89486a3b9c73da4a9c09999c2109bf5356a2d6a122f2890b71f287a19f74353854c168b0f24d1758c09ef328780adc06a1c9e8c3c3a651f832509dc651e629ff0c396827d9fa0b9082e4ffbd68fe20cd93076b386da569a52d00b3d8988436f1a97a22dfae94486764877d4233b068b5e207a30f4b1daafd9356ea97570aa91177c6e9d06b91e3641e69674136cd8457642e5ee1019bdf12fefa49452e2d19a61ea3cb67a9fd7421260e14c2ef3e9e13f8efa435308543589d37fdcf4e74a9a8e950922794e3b05dfc6e8cce2f3eb242255a9aa0fb296fc03f7e1efabce7c4d51e6cbafd2fc8c3165f4fc822e263ae36f22f97cb4ed830e26e808f98bc37fca3e16ecd0607e8c1f711783c5390e1953afd5b5ffe84d5fb4ec8686bf8f463815dff315e25785eaf9cae8d4842ee61d160ac9d1844caba769373b7542342def69871980c1d90618ba54db0d283857afd36e0077f6b9625f7d40283e19e0c3d47b196fb5c05f86","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
