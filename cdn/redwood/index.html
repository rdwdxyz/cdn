<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e83a8043377d687f9d04c3f1c1a3c54c258a6c6ead0513f119d68306e70a22ae8304172cd0960e5780665478d9d6ceeaadb7e9b08b57a0adfc99d3fee4110cfb8c3c03c19db81985f2b7dd0014b848cf7b4495b14323b4f9bdca3a26220490fa575b77d9d481de6afe7b473f24fd45d470494a26bad72d7723b41b1cb5a65c0f12555a4f91b8eb4bea4d13eb41a2dba31b494e362495ca7e06fccd068260bd1fc6fdf2bdb2840c0ad135ebc50c6d53db7569b1c7976e94137f3e92f46c216c155eb33c40987aebca38893ed64f2c43d67ea94042b20b78c65c3103aade084e433715098f9d8bf8aa68936f015bee617b07d6bd5f7145db892166d7e0590072fc15d3519a6e9d939ae6b57ea6380f00c9973d8876c351af2ab2f03df0aae2c1f201e4bb832d679dfe34d38bbbf421623be7ce0119b39ecbae81b510a0cb7a02c9490f6ed9bb3dd970829d695b760570d5829e33ec733669d1507d463f97c940906988ecc135ab6b0ef9886c1f7808dad1db192eefd2c2166f225771b4d3b3bf9545efddb6d52417bce0cd13290997e1562c746bee7482043f6b259d4219a7d18e6b68c43c0caa6d3521ea5814414454e9aee880c9c9532fa92cfe843370cb989aed31aab592722fcbe2a4ca9c4e8b54d31591ece82408e8ec1042e9136f1ec3ab56502c1bf75198416dac0267d4f002ab3533ba1b256a7a02485a82b4c48919842d812d70eebe872c1cbe05c310c2d5dec6d9daeeea031bef5b65ad67b7141a30de3d3c683104213e80b3a55421acb93648573342e2c3e07b1257254abfd78487db8bb80df3ed69097b4c5204e9db9933f1978cbcc5d3a6835939181f81d87d39384aca7b9cb9c4233936ddf8f4bc3cb6d13218298d33278dad57170f93f2b6125db6c4bd881ede0fdfe5f58afeb6b58b1d770d7fd3bf007638f6b0b5107ab8177128cd1f7268eb099b0c06e4b253cd2557ac6e81e3fe2370b881851a3227a5090a003f08668bc0433a8b82e88a7525933431bc5a912a3bb545bcaab66407d123ad0c52ba8993e7ab0ff3f7a5700cf00023f6315e50fec189067ed3367825d99ae650946c726f21db58af0fe6a5850c5cddb8990c0eddfabff582c08086ec09e07bf20fe6e17a34683964e6a49b45d532ed9e1d46b3f8ab39dee04c31176a8ac7c7b896eb5eadf1b0b4089c2d053922d2db89da97b4137fcd29062f3d539e4360ad018e1d280287d7b2a085f64ae57c3b260831893654c32008d991f8f088e8b85784dc28fd06629eabef92e49c3d4b677bc70b1c6b07062d30a8f5d39753e2b900ff13ab665415f30c4a204bcce8e3baf6dec0129dca1fa5813256aded860d856a22818b932e5daa6382498618469ace1ea3fdafbd940f19cf74964e5ec137c86ede99213223ccc66926233faad62efd0d197e282c9c24b8855468dec61514ed90a91d11658b1b43f804e3245106333f3416788642ccec18a2b7b3b01c93d11a60f277b03ea1b5ccbc53d3fe7ae7e56a76a271543e4c2b7ad49d10cac6ec8a1284c242fcaa983855ad5c3ced52e838b625f8353fba2f1b69c346593ce99a228eba2ca553e38031f59c3c93ba8eeff64bcb68501952d6bd872e50c362b740d82f25cf66a6d1bcf07eaae794d28f08b5550b5315f227de42933dd860e91e16852154048126a80761eb56387337d8d7f681d0e3f2947407c3a08acb327a33cdaea73e82fe164e2a3a165e8373d30e59a15df6b51edcd874595b0af971cdd799afb508eaba9a1aa862b254a451ea7a745b1ac17c7bc592e38e4d03ec63ca412c6fed6027f5167d7a91f535025e2f0135213ee4e3448f7830dc071b4417b853a02ad60f8e124944a1a7ed3327ab53ac86332e5a70a0ccd2af97ad5dbeb90243e32229381847384227beb677b7764a25f74a190370f24d220d99f7f534ac09cf4aa3ffbcd9445463b023a760b5c6c5144087eece3d92dd2e4ed1ec482a9af8155150747f0369f18e6a3bdec2d0cfded937391dd3f1b6fe9d274508f68c147b9e72170a8f934dd97986a6bf98b004f672ec6f48efdb5f84a1445dd4bebd8e375f77222a3a15638f29872cf991bb92054da2c8afc58503f80e0f6c67404bb7f2552faaf18094d6bd18e7c754296c1b944cc04f588f706c8bfce43f1aa471670d4cb8e0039797094c41aa030f92b746967faa445bc3d66fd7c6c9b4191521b40586d2430a5538d66c03be2c293e1d038423b1163fdb82bb7f2f2c5b01f4228caaaf2dad5d59e14f5e58aae7ddeb302c13279842986cacf9c5650b8ca160218f3a62265e23b7d82c22451cea01c2869ef574ec19c7344abeb67bb4b1a540b2facb449e25da6b6e8802605fbcf0b51c05717a6d6e87157e57546dc044a83883f484ce61527bf20693d7ea18e90d6056ca4ea0fa0fee86bf9eeea78963ee058dc827c686064799ad5526ed10ada5725e341c2876f05726e74b2f3cbc165141beb380d6b0ec254e9b3195c2668dedec4b1e2101c45cff1eaa7a9a88d4ba52ad780e2552f76993e7e85057fdcb28765362b82d0329e4fcb911837bcff2c49de16bf4fdd49e12a33a37d2eec163290ac4a4c97c58222347d925daa42515f214625c72e623c48b14b74760d699f2cb150ae360ec7cfc3e1f071f9dcc28fcf7dfe838448ba068ad168cb475c758b7b42b5f3b8d04d8358ba3902734e940f17d85aa6f3ee94c4a1d2520ade3c9f56d008ec2cdb12ed39af08ff137dad2f41ac12ccc27147ff056f568a8b88dd0aab7063ea657c62ce429062705986693a63e10a76eee1398c7a0625eaf2b0dd198f4d6c549a4b778dc7e290299eb45bc40f3864d45f5d035951da671093d8d2e3bd78292823ef63b7481259e1f901784ac45320af8678e9e3aceb4a0b0b065c1c4ab2398446963db06bf4d99b3892275d9f1ae4845f7f592b438236b002c47a695e5e432be45022174379c459500cb5c65471be7e8a9ed54d1eafdb9c43449949ee650ecce81d4cc83dcec02df7b88f8ecd96a554db3422e2904eaeadda91db6085fc3870a939f0edd4a36312bf47d8f97d684cde5890f812e7d6e7bc6809628382bf05e8f02a9074c45d373f6adae26ab566413cf7ac5bff07c8de683e437f5b4ab959396e8dc15b5802421bd2f32b68ef9726b89ebe3db105089273d2b259ac96971d0626c6567a5ff418ef7c74f556175659561f737bde0d439b9c8e52b3205be833aef443a5eb230dae9aa03b672cf904ce40b0b15977587a5e862ac84011ed83bea45043cc266169219bb150c98d9bb7d1d2fc83e4f177fc99747d82f7a2b0f1379676a54a4da77b2705af248ea8349d7820d1375a0e0cdd3aa5fbc3ed12c5e1fe50160d672787349e6b94541581b74bb4ce9062a351d49a0e4fea8942918b3885e3aca2cc38a21b9de199c10c429399056fe10f45af8888d1442b44ee7ed3957a204ead2e27ce804561dc1d8003fc0f9bb43651ea2578e8ca6e37eda23e681cfb0404f496944fd7624c1639aab194b9256a39f74817c0f749f33d9171d54051f2aa3b444c819cb4fe617c268d8e5725ae4393a829ec52b0448d92b9f85694ef8cbe6fa40ce0342f437556dbd31900616a41bc1c60ece8b5e2ae078c7edb7159780cdc954fb6c521e3a7e2a004008eac0ae31ad92ef763030be1c4fd95400f2018d8aee634c7d8b10ba0f1f6a970a3364cd214d53d65e4dc424f53cb083d568d752ce24bcbf7af5aa004aa30ae1e3fc97176dac89ddcbde350482e8e68f6b8187267d8fd8bc83c5e3cc0215d81a06b451f36311d077e428dc5f3293fdd4c6bdb78443f7deebcdcd825225582464ece483713ec929fa05ae946ceeb5d62feac733673e026d9190a7182d2f9271a0ad64986cb6182bb69e568a56eccf0f846c35b76393c3ecf9ddaab2a6e1ac46cffc82e93c9d87c77f514bbacad26c080da1a0ef2447938c975ae89ca9d4ffbda6a11182856f5c2cc13d507c62c4d829fdd1ca191e0f9eb8abc0f01dc87db32556d6818733195bbcd92edfe0520eafabd6c6bcfa53c0c54d112068f5c065db29f70f506ea57d03aed5a73ad90db8065ce086b84b220a542ae92509cc99d4186254ae7c1b9cbc070d8f28e425108f0ab9ae608f3e11ad2bf210f2201a82545fdb278a230aeeca21157d25a7fd89a4ae2a6445bce8a79d4ef0a6587652c02b6da8218a0e409779b1b286be3b73d57cc25b905284460f01e1bdfbcf86e991a48ee23d9be37fa97977001c6c1e27834862bb8e9dd245791e719f0e25f9acb52948ac8bce57506b7d50b72847580e285e0877934558080d06a05d663c6e212aeec19f39a20f708c53365bd4e94929757933d0d7b68d43bd5b673ffed0c5232d235bb9e077ba5f873fbb26f7b4913293397d6fecf11f5b33695b260661c6bf80cd80a268daff4859a9b800c765a1837a4942a0ab6b574f4312150d215fce5c34f34ef280ef7bb7fe4229a0ca016eff4487a490493cccde7cf272958312ac3bd358c242af870d55fc847b125e0613f8386b1ac513dd7f7e72417d9a9c4abf375a39c70a93a21683c9f1c4d9edc258f3509073658978a130ae542043e32156a8572b85599152a6d7b00880d0da0a1c7008a207fe2902a713e851e43088ecaf8959f8186e91769838d1b4c1689edca0a5acad9fcf4926a5f8a41d81ff4452939b77821189c826d3f48bda67dec00a8d3713ffb55c345b9994c0063d4de535428cce3740b1e00100e32b4e7199c63360e0f2b4ccd1467439975449e343a5f31fae33cb2412be311722bf583c2a0807b848b2ec2e38fe77778882837d090b50c2b02c081e98d34ddd27ea4dbf2712d25d7b547dab4ec9a83823472e6bf9133b27bb0261f8422d1fa0712052f98546b0be32bb121faac70529673545aa5b25d04161e8aa31f35acb4b42fe879c82895d785d965331bb47342102a63bfec89f16028dcb436d9258a5ab66742ce73cf884c6653fe4b8747f4819882146b2fe482cfce8d338129ee2794b70cb50a0daa082b1ee4bee2762e5a5ed836fde51f0615ac3bb8c4df4cfb99717acf7520de8ce941875c85352d140f4f5d3baf1ea746f1688755076903b52328b4089b43e85ddf0722b071799d8018a94678c9c33ce593fb0cfd0a604307cc9387747db6ef05e7cb5cb1fca84986aad26ed00aa7abc03647480528fefd39822086507214fdfeeb6a4195cbe1381395438949a09dae4e7ca2849e7cbdb5314adf511b65e288b6cb7d2abf05b154c7a9d718e86751b52689c7d5da7380436a8b6e5e4e6aa7c9b6f67dceebc18de507c8d4fda12fb8057038307807d3ca56496f2d0556e84c1648a19a44a24df77fa4d9d8d636f43db783f5246e00d4ae47bf0fbff7bc83530615a7bda850a8f6b8830ebc596370f9c213ca8903cadc4792b8b84fed31c175b56a46e4ff15c442f7016291506b294e3377efd0f40a3a8c8f8af3c2cc2fbdea86112807ddc0a8bad4f9f80c3d7a1e298d6d372b50b3d6b24af2c427616841a34187d901003ab8da8134be599511d3ea26cd9e4788ed6562d68293be53028a17de941d5ddac212bd7dc07608a8376314f8d034de83166c5ea8facd89a13d70e0220ac53c3179ddf53d06c6582e15fddf043d62ff805381f43e7bc12b5caba62e989f555ac241bf04085bf0b4f0f67ab80086988e80b886b14176ab8e18d708f4aa730afa299b66bbe28d22c9891231e01c03396a532862d9e5c11be64674f53660fccda98ba01c8091d6173c7e903df292067400f9c21ca1a85087f7377c4fff89c37cd208c2e16795e6b323cdd0f6d984b0d5ca3c9be7b3f790ff2d7966fa2b95eb177d292fbd3df70f39dba4be18e0f75042c3fc67b92d3fc733f63ec047c590efca8a27dd4f34cacea8452dd6ddab1e5bd3a0282f4ea94e07158030067944e478abd16c3f3f527f27d582683b436a6c12faa54ef2adb2b620dede964032ad13f8f6a105f2c80592bdd5a5e7d504f16060110fdf5b138ae04d06e0643694f9d420f9ca5bf39b6b235d5bf787129e8e3ccf0e4199b64994e8e4bf9c0edb9e0543cdafaac36e52ab0c31dbbddb7ea38cd50cbe7edb95c3dac1b817ac8a97cd6a7f8450fffc393826935dc04cd9d1bb257b9bbd4765ef1f2b474edb4f480d7517f2f9149a5ca998b740c6efe0ac4dcc91af38b663fb699ac3541088a4cb2dbe598e07abb23bab21a6044d8eca87882e877472a475febe330fc31d3d07e9cc24a44fb5bf675be93cf9880cb5fa0affe14b9d6e1abea231d2f92c399d5041099901795ca2e8556858f7f22b432d0465ffe53260d76dd4e83744aba815d73870106613eb7f373229e0d8b5c647eb67ffa08783f33983eadf7a1bf2e6aa3edd5b05c1fd89a1f58cb8ef7caa4eeb7aa5a08505f433f8e24ed1a9524a701eb8eec6d4d32f42fe023959b799b3bca9a3fdffd75023b1ca13b0ffa1a8c8b4ba34e4aeccfe056edd5024404f06bffe65ca64268368e0777f968836f7e69e6ec6105c8113bde9a28d89fde5bb77fbaeb12db11d94cf4bbe079e12fc862345af068ff3638b7b027950cd1e1ac2171e692267fa772b3113eb1c4df5318549d0ab46df738058e42d5a0afc7c0e56b91bcaa31f0e05b6f5506a3ae56a9cfedfa09fdb30e622cf548fb4dae3834403beb3e28be59712bf4a8214c7c48018abd40246960686f10894c12706ff523d5e4e49ce8d2e4c047976ac9612d7039a843337dc0860b0e210eef19cf050e898b169b7c9949716876e117b87029f1d64f2a4fbe3d4a03624bd501def5d9ecc40b1414ea7da7b572626ea5b63eb1005665bc12b79e86fddecadf0185f1f1c78677d8c9536393bdb3da8dcca8935aee163f4bb5f23dad6dbf2166a8d91aadb5c8de96068393089325ad908e011590dc76b7c90c5dc1e0add3cd080899803fdac761a2b1f20c28ec21761e14d807950dd4ac5f8861ab979147615697b5d9a5794cf7c31b782f304558361320a35c07ec7cc6b2bef77a0006c6b0a1c8722a6df0fd3e5b9cec08c99269df83199e7e2593d9a75622eb54b0cafa87034c03145f9ca181e469616726293c39f80745573f4f671f095884287344290939e1d39348a5bc07781399279a728cf9036bcf54e4b5c7b49475dd806988e4eab34f062b515e919c0366dd0ce8f225e6d2f21a2c4894e885eafc4443de2d3b81e0a61fd16a9b41641f594015a12e013fd40fdb84e6fc6a0ae6a7be63a85155720bff0108c8a25392ade5c5fd826a3155be978bbff8f5f258863d86f9a0a7ba130efec70f0e3818a77d47b41d9bc5ab39f686a0563b07bbec0ec50d22051448c7e68a34646ddc82ddb0fe6d78c33e524c5f3014038fdcf5552e1369df06272a1ca3bf70b46b6fac9d96b913e6e99106020dbf93ab9b063112df17bfc8c84c714cb0fc8b11b870237ddbcf6c993d6af311932eca3927a6f2dcead70c0e2a772f64a6f96435578846ea4dbfb8946c0fa3ef925cb28326c1ea9b24c99ce8aa0843557d0aea7c3f8e41825070eeb47a4fabc153de05b6ba24be4def064d20f51b56c44ee1ba2b152d5bc338596fdff6df541a88e927821fd9ace17084fde39efe770405c787fb07223851effce5346e507d2ca563b388c1fdf91f1bee3b254e3a7252d9834a91d4d947b259d389c4acba5c47c24afdeb45ea682ef4cf6768e85b8a8c8430fab036fa2dd486936504489f441fe58e5d0ff0adbe1fef4ea83d9e38afdb1f289bc027c9f1e4dda97361d09947a7d5c985cdb907659439b92daa273188312bdf2e410030dc9ecf0d65f834ecca7a0544bbcbc3757d0328268646ed8e100b0c16d507904d129ede8cb50ff2b3e938a8a0f6b98abbd8219186bff932e3c994ecb13546660fbcd97ce966a9e8e82b028a4497452dcc6d9b62c29214cf0e31721f3428987727eedb42efb8b144c64ab7671cd98c5b120a8f1375ab1b1c067da837717ca1d9238cd9855ed23755e01def75e358d1245babdaccc37f53c1e4737e1bed0c43f407f2c7fdf5d386143a096d5a6548cb5a63e1034b7a1afa338e86daa84f052947f6ea0c81f01ef18751e348433fef84add3fe1cb15b5a712933b0f123ee235b85afe346f227f7c77c34c0954502b947af272945f00fb39d091d337808f76ccd59155282da2bfa7a8c088575d9936d0e5669bb0ea87caed3e0171e408588cf3b29cb87c34b98cecd86722690da258f0eaa046f6ac79928dcee83e11d801c24caa32a2145a75e3ef7fd78e68a4a6c6cce59dec3e9f2da13a006af94e2f97e631b776fe75911fe80e90451319551003a832a3901869e72cc6c59efc9075f84db5b6e128fd3ecac9a6abf03030598a04d4807ef80ad522fc58258215a82ca15aec5010d03c5d8e0e495433b7514bb83787a7b6dd2dfd119db68b3c97f4f2e9a2fce012082d50cb93a707e7d8480e108555f5fd0d0d6329e2028c8ce41683f247dd7473b3910622c163958e6dac065db75a9dea236230d278cb479f44cec5901d48025740ffe1690e5cd6c0e446fdb5d947914525a792a3bc05b18091c5b5ce20c672385e5b0f62d76d80e5f2acc9ccddb40f506dba0cc151a261a9850d9009adf708fd3387f0cbf3fa34afed6c492e9adc92580fe5e561b2a07aeb3ee544e562b7c6aa62f2230402d43c1acaf708b5beff97964f04f2dfac15e988d179396c2027ab17e18e15f4ad39f0b823e38f908f8b6fc37c812eb6fbf0b9b0f824fc57d045d77b2c2e0b6f6277ba7c4e77056007ce6ef197c5ef08d8fe9d7fffa00a439e9fd99dae2f431fce0907fb2d42c855731dc735ee71110c5bd9e8644acc603b6c9055f928758c90a64898ea0973565f4cc2f125287706296833d555fbf539c478040f3c385dbd8b429d4bfe8fbe8b335ebdf5cb5f86b4afd0a766e423db975937f3f95dcaa5afd20384970f593b3504c6cca51575d90bd45c9752110e307729c9a6b72c21dade4c00d4556c78d3aa9aa279fd968191f84a8223d3288802f214186692755eea4468c92745a2a94274afc26e7c7c0efb6bbd7907d0549ab4d0b56a521c75e831534acda09ddcc30d1f9d1e6d089eb3af2f7a2711f1325fde35bf754a16d02688699619e263a93ba604292c6b5c752fa78d2e353ac4ee978dabc0cbfaa55d257816fd58d80a139f5bb112c30a119478257e7aaffd413b477f9b5b1ef57f0e84217b0637f5355ff30aef7134444379c0daeb48168f54f38d97ffd146d6bff7350f86fb5eca51f29eb7c934ca2d0223ee417824cbd04ef1d39aca074bf64301f04962ba8aceb4e84edd7cf14770f3bb9b95730d7bb06058ba0d131725fded26a856acde3973c353be591967ea2ddfbef16c8640442349d147878069a426a8dc07737e424d5b49c3cc64f85201668b27729659dfdb7888e903c6d6965d0527e6cee7d8938838cf33f97424f536e9069b8e30247a15265cc6eba5c172021c319781bbc7bbd78fe7feee4b2467a25d4c546a10f9fdd9b0c537bd27929568c667b9a953fbf59c10700b92c79998222a0ff51135a6bc448fcf83e3e7d5258b87a5dbf604fce479f44c93d9f0c95815cbfe0c0b107d6cb59e55ad4e3123daf08bd7797533656ac01b3937726c7a04a05b3185f0f859bd56410b51b6fba925ff2c393bc21cf161d89259c33cfa7298b88bf674bbef8e01f3c5bd68385d4f884cec8cbcf19214b547d6cc03aaf200772f8540d6747e3796ba977ede81efc24ee0fda7c72c4ea6ff911cf5ff46f0bebc843c9e2d5e840b51f85d296915be4cf7081d1265958f989f45b2231d6f1d1ff33c4e02b423fecf77d94478c274dede3bdad65c881ecd2c7269465199d740761a58cf5c90814d3135e700d0fafb379034544e9a45c91cd349dc0c1bcccda39dca82785c72a27654bd1d745f97ad84ecca49ff30377016c546801d3d74490a6157709ff6d2077d8b62b0d1e2dbc75e4fc68eb1625d89f7ee8a176c96146b66def170ac6986434b4bd2f35cddfd0e6a22e1e53c82a995f3cc78966b99fce4f46b06dbc684d7be42ac277501a884f042f2fdc0b83798c1acc1e7a082a7cf7ffe10c89e1b5a0c8e1e87dd85e08b8204e9f02152e6a47ec39df65955e586d973bb7e7b7a9060ae830635ebc1c589b1c12a8f0b3bd1a0a1e535899d1dd5e3b3934a73a4b093660de6fb415fada0842cbb023267766e7d270d7b34bc3d67ec66fe4ede38a09117b0779f335429dad7065df62eec59287d2519a1e9fe29ba4efca60fb97cc265ddb2fd28c2b4127527da17f731f576e43adc9c1e1d72670f2a3e44e060d8a886c2c9e9ebada0dcf192cfdf096dd2353d2fbb41ffffd62535854e80919c2b3f3fa953fb3c78d9693f7974966b648a33400b2f7788958197cb83401b85b97231a9105cbf57aed0ddc5ca604913bf1abe4cef502a827634e3548c1f08c749dd3ffdfc9172718df98b26405205687b7c1cadf9c171e0676b4366999935538025485fa88efba8771868e56c1156b16406e165530e47aa5efd5346992c2167b66dfbf7a9c7e326c6c5fc42dc4ea05f86e96da8a048569d046f4a5eb7133ea2632ba0bd726d37d332dbff655738a6742707e1fdc6566824b88a9bdfbdf979cf78d49c9ff6239d00a14483b478c5c618451654a36f0593258a6abe243f07a4cf27a03d731b93850a7e7b922a9782ee3ea011cee0a35aa0e8b3451617a973324be13279a21334f0492c156aa9388416457fba5f9e8cdfb22f52f22e0d6cea1e6c4356d2fc01df3355a30bc23f92a9246e2880e6f99e3d307a770fc3f1ce66c2d99e8115b0fb894972b8de7889ab843bbadd6d2cc1a701e7a4d7c1a00822c604386d2f9d0c3051157f058a84324df997c32d7d1f802d64100a0c2b4c7b8c99c8b962dbdbb7472411bd0ff9a7f2f31fcbb3cecaa4d847a4f4542bea3451427b7bcf6777f6a2a5bb99687aed2a83687825693db903ac3a9557276c21815943e7e44d05891984ec9642a7172bb8d39968ba6fcb443d9316ed817a704b9acc690c1b9d05d467176f60c62aeb57de0b04d568806c4ca08546845a20b36c8df6f390364af266ade9450548896909e075c0adb170bb9ef4029f7350ad21cec0627d3a8543aa583b77d3683174cdc94abbdf06b33fbce95799597d621d648eb6e28815135f667f599abb5e855e193c5b826e2d45d1766a96f00b17e32cb809e8efaee59ba4b3ae8373e107da34de98a12768f56b7c73e793a61c60178cdbcb80014f174a1f53ebdd427bd651cfb2456424b8b88e094ac465c27612ba934daaf68b96371adc889b75abb7aa463809e3c1d9fab49c1e76f505673d24527e56b179b7f86cbe4179bcccf467946638d1b6025329dc7658372d6e5483435cb27de2114bd06ceebf5651b5b248e90940d517308b767016e9e51a81a54a2424bf3f4afb1b21e602246005eadf8aedbd07d8c2878293851f78ed8bb3528491ecc2ab90ca5c22178edcc875ea618ce086eed94148834e2e2d269a8f624254e6507958d2a379388c17ca01994d74710fb78f5ff54084d160bced158deab8994ff726a712835634a1904a424fd1d292f02bd83b97d2262a86c060d350a0d6d14d086e6f162520c46968b4e9f8ac317cbeb94f4f5ae435bfccf1d8399c4e9fab62968041fe41d4618c04a87c7f07d4a9d1dc1ef0a1e114fdafd2e374362609dbb062b0452f1bec1fb2dafaf9ba937672d9c14f32cd50e5e9a49ad540fc8cbaf907a8cc7eeca7897017bfaaf29db5be1d6a3b01d0a3abf90ee16d6aab35e11ad503754208b217fb5b988f894c52244e311230e0253fc4a603711c19a4fd6b1029273e5e75318b91acf806a9fd52be1d3f4e3d688f301e3b75bd837037f3e546f959daffd683c9e32d7b585262d0b868beb1010eb1b68eeca314ff1a317ad570e0d2f9d64d3ae0f6f0cdb15b9a81224834a8da0d2157749c0b10413fd842c39ab045f620a91e94832b58b0e6154fb923289203607b341d7597b9a4dfd02bcfdba4dc69d53aa54d53f4ddca3b522df6443a5027602c8d9d66168efb23836a6787b24f57631314719273faf13c572dd6731272ab6d611313dac24f5af20e8a0e66678ad90956a6b86c4e5032ae30081ffdfb3a3ccfb1c9fcdc9dad8a8cfe06213d737a3f40eb90a09aadff3c1bf4315a2d15a35d04ce0869dca140bf1d770bf5d23d3a319383d88dd6f9d16e9f1d5a713ebeb7b8a30fa54a4e3ed1cab178fc8f57802a3cb3d1daca5bea70477480fc60233f85800ca63f5998faf70482d04f66295126a36fb2ef73ed5d8b75e054e22eda41283540ea85400800170bd70201fed1d4245bff5f5a17ebb3a9faa79fe845bdb8c1b355db8cd6d054726974f3c289adee5c954de21738a8bc623f8254aac0f110125c189efb953d069d8b6e0ff5e9ba73bda009b1515d9b49bca89990e781db020354d30913ab91d6d89aa1c65af4ccb5d0d8159007f45ed26ce2b4964acf694445c6d1e44376a6fb7612557091fac52b215035a8bddff63e130d8e2874cb315d1a8e7f582d3647d07e8d48431c9a633df4bf44d4dcd813e68e331fb69075287d7aec7a9b888ed8a2111742277fd5a9150cb9752e9b35f42f5cb4cc6147ce7f9dedec19d177cc696708b3df0165f693f10df4e1b24c216b98f8c85536628da1bad66df79f39c6e9612b6090a074342fbc4c561462b2df66ad4c96d7dce158ad12a7b7ad1345185c7065c13934a6f641d2e2afe01d9866b8f550c25ee648ec5fe107d2b1818e5568e60e60b0fd05dafb551cda634eb9f1eda6508f92494a7a882435ac9566c7bc7a746bf93ae24326225b6bb9bbc70790dc82e4c4e36f98013c36b3f7d39b5c30087daa17fb47c71e2478b60a36e3fdb4b473e0812e031683e6fc74c5fd926821f557d0591abc308367b744bc19eed3c9db8da91f8ff39556fe762292bf08d84fef0a27bbdf9dbca2365fd0941055810d8637cf67018e9789aadd1e8b0a2e7cf083e2a7f3e3f21548774d030a202c1af4c0f2bad621ee898e773d13f52bcd1db65816c2eae4ddc7c6d71d34f47156c4fa98de2c16c10621e3567dbed9ef42e2a47f398541bb71139aae31fb4a496a3fd3b01fe65141b4b8c6ce7b57559c18b6e10d2d1f020c836a85f0655f2e6f2b1e3a70a8eeba0c0d4f61335c749d92505c2750767758a171b80ce546412101589adb2e66458323f3131c7a78187ec26053d6ac8b95a458d7550d07fc939ff54f71dadf6c4dfd62fd2492c7e74480fbbbb22e7d813ce9088b4ba03ee91e345ef79ed0117918e4c7e2815292dd9684a2b33fd83d04ae70bd7977ec8b01b9a6082c4b524d7272596733dc24df3237e51dd97d53b0db1afd502b042f307433a63d5bd98d15f235b6b9fee8877ae1aa7818c5af0247e91628e06fcd696ccf4776d7bdd5dac8da0a88c38fe425f737886bd205c666c4fefc2aea2bad27124c7da9868b865411eb90d980bd3511c010a48d908b6fc7b4e6efba425b9c690e408122adf4e7431cef8520f8a5d9b316fdf417a08204fa80f4c83441532c7d9fbf7155063587ec9c7933aac1b8fd1b5a63655ae11902c8d1b2b2c5335c73728661ad3687b94dbed2d4c89e485ca74bfa4d13345f662b2cea4527abe6589b6b0b170401cab9fbfcba95152d1c35801185d4195115b4232341c166717fe84c1298fb21473c32b5077f9b17348e82978922f0b63ebc413977959273cacd5cd8be2fa7937a29d43a8f06bb7fc1ae2eca7681b0ffa6557b916112801b867eb1bd230c6ada77ad1090800b4be0cb7f0b244c51ca7933e6327284618052f7b2eccd829f3d27f10e9c730384d755b962c0bfdb810ea05994e5ebc00e3ce5aa2573bee63b33c28133226f733a1c0d4704de52b4618848437d7481cd1e69ceec5ea4cf0e6676287b109d89c3e1b9b94857750e37157fff77a567a51df22a6c49ffef2903f2b673939971e408ae2d59ed148bfd35a4156c6e3932c7299cc7a8ae769f28aeed9d80f043431d9c7b0d9fae4666945c24e3f4eac97a85919de0bddf5f391d68e9ab0028fa4b46fa085eeb4cc7910c4cead2c99b57ec2411995c7c60d36a91df39e10ec7385edee380713b0a0ed54feb6bf43c91fc3ab9382407c92a4f47575e120da8363c500c3270c9bc13f95598342c93f77e1d1d8f7040eff4db820ee22d9e843a367528e96c085fb0f02426d591e803e15582a0a7a7930189bc3bd968c8ee93db06d10a77fb4e856b4e58b1a3efb937d0ee7bc8f59ad8ee49dc60ead148af113384e21a0c2b72592eb988c7e1535b7a849038a1c8e6928cde3b17443d47aad082aec42b4c96ade21d803e937794f95eaf8865481dbd3011f768c68d33cef2fb95e95ff8dfc92a1d0484bb344e1b5627dc219a0ba89febbf5cd67c26167d30ff85b7791e556357e316bdd5adbb780d84da2161b773574168a042d8012f24400995be5e4eba9e3c24b467c6ba615c6f7d057911f4ea02c3aee62dee402a5e1e842a1a341fe60f695438f6840a43e05ea6b80937fce4e30d8b730f6c9b83a1dae2eb461913636d930e250c39f96b268ba75f3ec0f56038740fd14c3643ee8a64f7e7674df7428f14a5389807f3e5237e52f23693ee2eeb049b603ff13f01ba6e9bb8268acf63946ac36d7eae427724db67412a1d4fd0b275ef6a0878b233db5490dfafc9db986403d819aebc6553e9de207811aff18d7c98dcb201a8b9a36315642d7e8b37de4ebdca3ea3b753cc1285b2beaea918f424610a75c7068879abdbe627012b1f38e2ab5b8bc199f4bc6829d55aeaf3e6be4b814b7cfc1271db8c3beec546801825b78c4f38ae4fc32ff282b342b5dfbb7756bb4b47202d0974bdaa4d5c9bb1c684634319cb059e61ecb6271df38b788a92ee155e7c18ed5141d1a8b8688abc1bf558555e6c92a74ae64d3c7c45b7b876d648be991e99865fd2f60922d31a377190585b59d7b576dd38703653c86c3986a6003c163aa3a9686786bc1e5bc1197e4f1ac18b44ef231a16e4db47472357aebc98c2f3932ccc414c3b4c3b809a84c9164d37058fb3fa18127fcb2462ed0d7a0e84082ef416580638788afc5a79e4a7bf6440131e518d35745ed2467b4766e2daf21b616dd0164c3a36a0bc830e34f15829748e5caf279acc53525322712d9b3e4dddb0d969d948b105115e40bd9205fdd74adbbdeee366435b8413cafd0c26e6b29feb19137ce1a540bd7b8f8bd4acb391a9352cfdb12e0cd2728e6635c394e88469fd0038c17acfc1ab3abbeee1ae12e80c160fd6b680298683ed3df86183a8dba80f4d56039b110ca287e2a0eed46bab813468a70c8cba55ec7b2b07c1cfc6531a1fd9f8ce3b0008ee0aca9885271e32c2cb415c659dea9bc9c72769f076b0f1eb4c422481627eaec335796996772cb0ae942a52f4647cb7c85cf2c5bec78cd63b941cf870b1b7885c3a0fb019129a4aad3b5f4eaf4b7962826deaa8c7887a29031e996ad599c5aa11d4b68a11650378cf9d1675b89efabf45730320a4bbb02c0daf027676707e333cefa6b952b43e3285d749b66ce4a1335f6637ee9f559dde667b73ec12baf428036787457073f005c16bc088eef7d83d0d22f600fb23a310ea8e9c98161c2fad58dcf784c2d77b7feb497901988ec418418c2f52ca385413fe799d181338c30514de9f41de52867f2b4d1f0d3f3e32abbc8de805c0d13fe20d4b1d52cc46bab250fe3aee32d1636d1a2fefbfc53fdb78f84584769f73b6bb8def9bc607885b0ca8b7a0cc52f330de566da9be7b05bfbe7c42b36f31afb54b3f7bb5fb3be2cc604b248e316720d3f1102e45e66c159986f9d5aa17589955da006bcf1fc306f0a55f45435753d3cb95da6cddfcca3e6927dc1622645669642bf70888a525375ffae0e2390d152e3931bc6f4016b0a3eed0c85177d252246fc939e4fd24147ea75e6593d4cc318ae04987e728d10be44154f759e1e35e5fdc64a0e63e45e7f6a29ae488f9b61fb7b52d8c09c81b3ce69f242eedff1b4567e1efd14a82e0527edcd5b2fc6d3a9d7f98b5704f5d9f3c66709c582f4c649c97e5f2b0085b4f4891ff4d568fd1ed14f8939a6faec7e4319370ae63c9642cde23741f55f843a5b6af0a9514425c9d698712c4556f81e619623caeb097bda0d871f6aad071a9eaa3c0bcacabd0b6cf417b06c8f0bec5cb3fe0654eb52c98599c8b6fcbce781f1c3e73f882d02bb3d74cab3cb675c6659f632aaf3f18e7c61a5385727538d2f1888903f073777d2d505ef11e2aab20cba6aff280340fc473409148049ebceb5aa11f2d882850680f4d2c3f8c9f8912e0e99806bfb587b6e3fea1ff733e388faa50724d0624f064f0029f9805155fa6ad406f407cf4cad2b5ef326b1ffed04e7f1bce6df10e609951eeb61481e9160898819767a297409befbd2af5730590140bd25787f634e5d574e6ad11dab7bab49c98f92f72a565bed08e5dc7019e5344487b9c0eccc8182958db132a5158824b1a7c0409752f1566cfef1d7e2cf230c11f2e1c64e260858663d3854f0cf8733b9c8bd7e4239e5c07485525c9409548ead98e6bd2361250baccb0b58a53be3cdcde75223403d13d350f091a77c6d696b278ed50bed0b591736b2bd9a7ac5c2b45b1d53f68c5f34309941a622cc3840f6ceecc2c25a6fe10e9caf164d3ba836ec8c86993e4610084dfacf06a783181016315a1309fd554fd27ad38172dd7f86ba21c9aca36c5613239e99c91f83b4618ed6a317069912fd237c568ac13db6806c2802f481950abf9a7f8e1ec57e0d997b4db91c857bafe6659e1d7c6f4e4b63e0bd6945d8f3b794aa37a401e2eb3f4664b13349971e1f503410aea53283d2449745ac6e234c66a21681d9eb5d44980ae98954c15dce9cdd5d99f3114e9e29b384b51c71f391f79367638e21434059c758273da18352377a09056d1fdc177ebee43c8f633940d815eb180c9855cd6ec74b99dd4fce606279d26d7ec6198b126f9fd40908822a5572bcd0a40188322e8d280016fc6bbf3e5a7643429138459e75634437bd02819f4970f019a85cf3d92c4211f6d8a175ba21b01e3ed017bca67e5cf4f0396d5f62eabed391309e1a138bf94a70494fa5b62144247e39120f7a575f4ab5393730b160df85302256542cc630f8fce7c4d23d5a09b9f76612679f0236ae3d326b7b6de1d3f1eb25c986c68548d51085ad7103c85491f4966d2a081883f7c402ea66e5ca687011603443132d9404cbc3d099e4a7d9e4bf772684fe1c54357ecc1f8cb73ac9b95dbd338a2fd478e3c54c69144f685d8292191fe5547092fb4bfe76a20fa4f384abd8f2fdf51bd0e36955a6add679106042699362edabc86f2a28f79453fe52a1510d0999365ae95913de1013ee03f0b78392ce215a31a7c0091fa0214f935e462dde609b2c88718a308d1ab222e044e55048fbceceda101de018b6d31bc0752c65db6456ef0cfde2374ba7399a5381b13115d6c77df004f0e57b0c9809c250d61b9cca177dea90ff003cb1633b0a8a6f23f72c083f30f31549c857bf6d1fcc1bda2bd974c07f0af26d2ade7ef5c028d7211924dee86fefc949f2f148c2484ca807e87b47219386da2147c8bd6e0fdfab927baae1a026bb9fb5ee59aadaef7c8b37c711ab48a872628800ecdf43fc81db840cb48bd1212bede8047d7160c2fe026dfa45e58170214f8d443ce26b081e72e0fc9d2301bbb4771ee4859c711da55e631604972b3196ce5e6d63bb32d0920e7c3345e7008abdca0bb25ae20383e699dc59a3a6cb5ee85a4988ea84da2b71e122fd935c69ffbc47ecb299bc4655b7057578f5ad5edf0690234d8c43995b6d91e6c663fb44bedde44cdc86b350f6c609793a3353673360716a219dbff41bd214a07a81fea022b77b52c8abbb7f0111d0944032e1e85282a07fe54d5255ef8f842aba75ff55d1cd757b91a983c1a80ce879897398cb7606591d5053b2cced0727d031f69a0daf59d772e52e29defd7011a8c875fb23f6de41574ca3a4386e6dec579385","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
