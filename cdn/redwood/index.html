<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc755f1395b6e3397af30a0e0aafed166e8fbf4315bd2534e8cdb3f19676b8de0f1efcd00e557fcc06ace8224e72c3133c13ee9aa72542b4487ce516e7180ca3fb14ad90095b4ec7731de13ceb46d7888121ce654941e34a28b5e6ce02cf6dd9628e507ec5641879cf20e30dd33267b041c5c204faa06884eb6d917b68ef6894764a80e1726c3474ce0cab4b6ee6898c7b079dd55b63cb6ae2a91b07c4345ad75311ba1051eacf3ab0113f2f15daf78e72218ca323a675fead79c639cc243f3413e49e5f0a297442cbdc95dda39f6c1083dcc6cb674b985a61aef8c1d75c582623e31566b2f690fbb4db7dffe86e83caead4c74f6f3329ddfa6d24912a92dfea84d4ca441e58e0db8db43153bc4c81ca05f0369dc6ca5288a48fe8367c8012949b26595f4a165a719dd04ae4b24b917c47b71d6b4bffd82b8a85ad0a04b10d534b91abaee3660c9f06444912512762488c002a48dc4010cdb7ff069c78fc679df83b21a6483ae10d6322d13b7cd3295843b7afa0893c5dedb793a02622643a7fab28327f5422f9fe7b619cea231cd719b7cf8295bd3c5ce119559a6b77c77a7f31c3466ec9ef2032ac893f0e3ca80e58572777ebfdeb061f28928cda5ae0b0aaecf23a49726ff4ad04848646c9372cb02bd7b29210ef6560c2c3eef265bb4b4118859524ad157099fb35b3b097456557873b822bf9239c22b403e31074dc77e400baf2493ee158b360cd9f42585781ec1ef4898f3128193ccf6f131860ab62c3f0a52ab6a1a1011813f0f0806d2ee84b416fdb0a53b8ca672fd3465125b6f5b40f6648ad3eb0ec412b4ce4370d7dfab90368906727e7fd5474681e08e8536e346bf01a4876d7452bb30a09d018cfb8ccfed393d09f036e3a6183caf9f8da4f8f5248bd7eaa797ff7f511529c2f29f51521a1de4ed649334f0b34b297de5d471ccd823b82c4790291edddfa9c701bf7004e32178e06340c5a75b8445d0ee1b0201ad6aba9e63c57ef6252f5f488102860b1ba54ecc14dc55c1efb73bedd14ea04e32db330d89cf6249da2b64a419f541da6e4515e7561fba0f637cbd7aa22e525b566ee928fc9ec66ebf48100e0fb6bd2fdbcf5ff25694a7a6347d1deeb1134dbc16985f63b28a39cbc78b7e366a8cb5a70c0c27ae88904be3c4c7aba1563ecee0b48cdb1e2991a4d8081d50315027953ecaac9cff05cc8e7cb08934945ee11d01410482e88e4f36096e5c9eda15ef5f09898547528d7119971126a525c731d71e04a3f169d0db76eeea223805acc85b6dc6f2d44063db4559c2e658f560cf6d45d957aca7303410a2c67e94631a41cee1e485f6133931be44f294c19c6743040754b957dd528ce5f9fc43062d530ca8fa7164edb78d0373c90ae4dc69096274be8583124d984728e9ad7240eb4d4a789a2ec181cebcf023b01ca65e6d633ff2b3ddad87eac5e938509ea33d8e773a369cd6db085591981fcb62c0b62a3c2817cffac5c577ba0a27f75a39447507d0b9005809295b9c6fedd531fc629d07e6a0fe96dd951dc4b59f4e4a210b3b7d3efca77c078daf530891e5e1c99b01934f50a4daad0908c08487624bee096cca32c34ad54ec9348b10f4509a23ffee58640e787e66e32120a3f46612af6661d4f1a4a6ced3a4ab0fc9465b6f1bdc0aa369d713d32153a320b01cf2694cfb325c3249fd6b870b3ca54489d166b776d39f6aa82f5ccda2a53aea55784ff1ce769ed896cf09df865e06d256778601a35bff4d1c24866870901ed845d964e5445677a8a9e20a334255942a46e93419779be770bd7ca334b56e225f96bbb9efeb2d69d761866a80fa1a8d5c6db69e92a5e1111b033a4a5ce8a4b951c428619dccb0c5c0b49c5df80067a2a73e289c2af8d922172de5b86a81751fe6093369c3e93b1746735ecd6a0d46bf45010276e8430945293a25c518e21230c1626a268ef5dfd21f96fbeb9affe151a5140559f343fd2c3c1043beca157bfc9dec50b9dc6de4004bb0efd471ec8836b5a0e85ec10686304da4aed531b626a9ad0736f1869933f60ed3627f963fc1ff3cc7d2dced753db567047e1ba0bd3c9f11e96174422242bf7ae9d60ac96860e2f2bab6f1315af8793065c174c3d7866828faf545ca6ddfabb2a94264880010bbd70e924de929eb2aa0fbb2171e8be6b5d7fa3502938345939be51ad5ccc33fcbb9591eec2f049287bd9475ba19a48ccca0183c58bad76df44a791f414952a185e220bd3f1f2105126a0f2d5a4243b8df8f14760f598981d235083d4b8df317eb88e972985d43a03c1e699db103c82ac835f2bf24579be3a1db88585e2057b4399aa45d62a893b7a3eeb5e9c9e7b0b00c51723a5c753eef2c9ea2e57a538beba76b7d5e6c59811a0581dbb4e55e8a0be92f5d927782f9f44784f36c5fe0bf565a7418e48650e021f4b04b88c37e6b874c5e2857f646a2da807668a7ba90bbc7577a1acf6ddce1cdf9be1101df13114d381338f8c952c62a4c96b7ee1099b183ba74ea1265d9daa03e97b9edd819acd53c815af6963f1ddd847c1fdcc1649f92f2e955638da6c088b039dc7b86389448f431c53c64dd5ee17691f7db2ee7a890a98aed3e59201938a55938b41016e726d9235539e14a864c4a1af7bb133dbec031e06e1a251c74cf7323c6f00331ab4b0a4289c9bf9a54db993de34d1f062becb08382ab74040a6b70e06d9e81449a1e93a791f061cf51baa291311b9b4592cb6dc06d815754eedfa9cda484415bfc75eba99becb6299f7ebaa6ce9eeef0d33e963b63f7f779273b89cbabfbe1104fd10ab56cf62dfc3b2f64d714be97793df2a81864837e72ac92903cebadc57109fb40a9adb763d40efb445ea1a185dba3a5c57db97cef53a28bbcd7fb4dcccee2ae390c6b7d5c6cb6839025ef6d7bc586d04edadea9d9b525611acb73b9a768332f11480f316029854dff4927c9c2f3715798eba1bdf01f354afa75310e411554a73b808afbce76eb580384f1a0556381f80b4a9b12bf99f97cf4cffff33a10e92a135e92e6a452ac14c2f2c97a6095f25c0994d4ddcb1bf5117c4c068686b52347196c043f6c149faeb9b24188a4eeb56c8f51758615bc0ea0a880e6a236f0250ea147bfc10d070c93c6d97fc8959566a9ac2fdd2dc797cc14fcd55401b93d9faefe06075577d94a240cd1b558932aa783d5520872eba5801ac9c2b3d20fe36fc1ec3e96362fe0f4d06950e2edd4b20329be865992d0f7286abf3a1b41e7414e5afa92ecc8350610ac60dcc2033bd78b162af666a91d9917e83e207c4b9d7e0215cf096c6c78302e11f52af630dd19104cc88a54b566cdb2010c637f87b610c8dd51c1d422787747c41eb2549e3fa0340be13d9580481721248ef4ab64f5f7f60cc859c8a2c5e1f36b7dd80eee3eaf965a7858172c3a980a4207ae57b7778ecf1d0eef951a911fdc9eaab2e98a597ce6a051222e7b624e7497c438c8e7930576e225a49603b5bf919303cb433c1fba5427e2eb830f6873c1f6ca76bc18130aad8da82c8171f6d1914e09cd51d2a9f6f4d5a559af6eb6bf0febca4bf01dba42ad9c0011a313acd1a48241fb1c5f56047bca08f84350a8e65d34d5a46393cd690363e74e776f0c02e408160eb0efdc5d4638535b68ac618dfae4990e490cdbf94906c0b9742fb3a8077a22c2497577e17aaecd2053328df1a45a5483ad767ac36207ebe7931a1a664b593fbafb695578c3a3dfb79a1c99f59f40769c31d8b508d5f867138b18ed44bf992ea36d59f4eca6f2cdb09c3d08b597e0cc40c93cf14be1d0b6a3ae641cc81f2fbd030469bf0b16341d80b19d42acd8bbf4ec5f66f400eff825d77d5a93f66c7c68e41fcf71acccf9146fd7757f4148c0ba877f4c395d34c495c0746aa235497bdffda16525a8294300f7786a28cb6af613623790b927e5385a74c1829cbb13e65aae8cd727b0e5aa78b16c4097c61bcc87d1cd086d53efab420cbfb730661542720382e803292cc109c93caddb1e369d10ffac168455f9762886395244eecd7cccfa64ad50e74c1d5256c0789da94bdbc19caf0ba3b0cbea2b0907381115f441f6e97a97d7ff8e8ea4f9c8f0f83cb98772d66bbbf17f8a4b2a69f715ca53c33cf5d5ef3a9651fb517faf30ee6f9cd9025020c226035690cfe85b8f42ee45a34838938d4246fba57d82b67b9bea7b4220a689c5777eb761d52d90e6c167bc2ef42ab7f30d76640b325cb34d261fb01b2177bec54305dcdd0959a24118348d77beb42825afebebe940abefa93f77d54b49123e84fd7ae3da4e4fcaaf9c06875a237d0ad261ac072c9e435c1f5d7c22408229aa542e7450fbef25ee987f093b5875a93555a41cd465818291bc2051b664850b7254953acb879ba47c1d6128e1203698690c4b3f4bb792ca0532ebb678ed152d0db65b5b2b36184766eac741db5c264df407c4548be31c949c48521845d9949cc9a9f4aa98e7f8a1c52b932894d46fb8afba3b10c59841b642efd73e599fa7d5a54b5ee482a1a52aa5c44c55e5bfdb5d4e28418372b506a1549f6a9ed95998f0717b3709e5795a52d53b8dd858ecba7e147e5c514aea107b87ddeab07a8238fde351d42bc8fb4030226ae285ca3f4d977a6fbc61058ddd570cfe654df58a92828c2c06811ac4ef13097aee64f511cded6ce820ee68c1a832d81ed75e1dc1312a4a2863fd0971883dcba7c7a5921704dc91fc4548c82b7e0014d3ca710996a2e1e4218091e1c12da61d52386010e0e7274f37ab93063814133a42df3d5d2e5678e23e8edaaa39a2c593c548a3edecf23ccfdc6dacdf62418a62d80de1d2e96228a2bd2194fb7f21f8d3bb314c35fd11b3d34058f28d8373fa2452899d2e2d97e5dfdb328a5c29b57c1f0a7ac853a8be63f96f563e670829302e9d2669cbf92cd15193997f19ae0b69bb948f74e63f0d00e94316d0ba0da8895fb1fa72f3d9408946b56b2e2bb5fc8e1373d1e958ef3c378ee4a8044370ca2a3dbc94f62d79f56635eed2833616be99c98471e60b54d00be521df1c32e206fbc0d64eb2dde97e677ff1fa73699d681a9cb35950b1af8dae1e938219556d6517c2fa635b1d651031145b6a14ca51c8714b63f566f11d68b77ab4165f5e81714dd5880f00b30f472cd21559a6da60be972954bba4c7c3245660dea1bae5e45fea25873dfdfc8348a33fd8b08e62a1cbcfc339ab1e018962006235bf7897e55b5e3ac3a65ed8377b7fd71c1e24e708247e9832835369fe6ae207107bd08218b56caeefe9bcc3921d4cf9f367f72811cc0028724a840d99ccc94fd50cd2f3529f693369bb9b4b5a92f05aa94154ba877b00c30679088ee61e1379da0ee2043a5003dbe431736e7ff26b1799dbd304e245796e06bde7d2f7dfd9f60046ec6a4948b5950e14a37cd8333e0258893b25fe36b64a99e20d1371f6abf37e0ceec4543ad8702a9aaa2151ed6cc5f5bd0ccc385ca2cce277111fe393ea5c444f27de662d2c7e53154a55f7372a114668164ff93ec4f00e79d8227937511f50a1163249de0df1b15f8f9ab6a5352974138078c7756a7423283eb6287ad0cf16220d8c2cbddd062cc0c4014dd5e0b6dde68919a15870348871d10663c14eb24993aed375a9c01037194595c22e7286df7370e6c993dc597fb25eff61b40d794cc878b00a23eca4f70d9ab8bb06516ee9c979d9268231fe7dfab8bf33dae449c5ea21ff6bcd2f6bfd10d61971beb4fddfd677e5ff6f0a9d501f30fd1a7fdba2810cd7d3b2cabf7a7302969411f8709c23610c3f3e8e0537faf42bac8bb70b38a7175d1953fe7f94c011310c0ee2d89d0e07d33fc6afd8215cf7fbcf360a71a8048481a168e6d014f6cbec26c5c7579b751feca520100e09405bd59d063578cea0f24f82ae813b2497fa997691bb1f282c91214851be67bb2f0cc23068c863644891da9d20197326c7dc657417d99f4aec18dff1e34199d166f9eeffca08caf047be3b7b1b1aa5cb4f26d9467797fb5b7203c0db01488b32580272260c3923449d5462701d1e9c83b43dcd362216c5a4ce83a75c2fa8f71db1be55ea303689ed56ebe7a1533e48df52729fdf61a8c002b2041a501041b95e1c3bd60470ab07869e846bd6b020900aed5e3f6ede20bc3c9d66721f822eb07c51a3ece0a767072734d0c48d8808c7c05132c9f65bbade99523845fc91cf11a8897e5792cc14677ef001fc159b7f32ce334603b99e882dc075c73b8e8c90792b8dbb48cfd0eaabbff79fccdfec535bcc67bf158bbb6c43b543047c4c7b3911e41b82c507939e4d54fdaf7ca3be7df67e1211b9434de7edad45ed2e44875c337f42d234316c2b8626a77ba280c30d70271009522b3e3009e5d3d618d580c9df141651f73bb2d215e29f3042dd75343ab3d9b11cb78c9c460d66eae0e272a27992f80896f9d78256037679d5c14f32e8d258a45612008bdd90835c3ecc4de6babd28fe32d10da60b4002a47c3f589a3b7ed1f66fe3ec820cfdab14cf66d0e7bd01eed5c66626ce0c20d1d63276f01c5cd13954794f42b2b0a02b756e415951e2ab1176b4405586df9aecc044db0f2093c92127283fe33bfddb27deda6174d0c2442b7e3867f78f55eb5d29c092acc48f0c93012b347745383f100afe577dc026f7cef736872b741728db119d21ad22ee10e57b490696b330be43dae815545f6dc4497d0d8666d53d5c1d9e04a15624dabe17656c6242be0c469b7d99f0aa27927f46f7ebc202f2299bf3652dd1bb2c381192726f4adb37631f12aaa6512619ed6540876f502163e43516d191d1bfd05e31d6c33beea91f4cc269cd000b2faa3210243841ce6c9447a1766b27d3511a6d95250192d3f517525699905910ab82f9dbbe3d563d7643abb35d1293b8e13050693bf68accc0cfb8d9042f8cd685f43baec4a6c162546d587a42c61e876557b8eafc9fdfabfa1cfad3b7c7bd726a5abc4b70eb8a9aec3f3a7c968cf8bcc4b802ba16288807a7ee9eba6b4ae24a6833633b2dd56b4f377e82047682cda7a7122304b790976508c182cc0fa21d32c4f9a5cff8da34ea09d360d43c96c09f5a559de8e620d8b9be62a3b409a83832cd146f56175fd0ff0c239ec4ad78e35ebcd383d10264de73ceebae691c4cee68c30afcc7a3207673698278abd09f8bacaabf1ce617ad20ab0089a6d463f7d376957417fc5d66e0bcc112e415e1e03d33fb7545b64c40b9f057404da7b80d73c18b6e5eb4129574ab83423ad65e75defef1ea3d6f26a36e067ea69867200ed4a5ecb81009006bd8ff69ac91c19f1a9d4024df86652c61eea2b8f7e8d07ec68352a1124a89ed192a8e44d6218f2985dbe2f8fc66d890d6e3705ea6bedf4b9b8b783219fc8fe7a8e6a2f40c93659a0d90f611f18a698e19cebdd9557a838bf44da63f7f4f866db1769c0c50aea3b8c553e159ec69733a229bbaa8c07eaba143033fe70f043063c593bb6d460ae57ed1ae64952fcdbd114ab6cff569ae8e7f40dc8a5ad86c1dbba34b4b2e286ae00216ff166002e72da24584e4c65c8b854ebfaf4fca148862b1c0814e006935d8c17479ebd5dff22b0a5beeb151c9dcc6d5602da6e72e7f1fe17874babd2fa8a471dcf0abbe99d3f8afb4e3a999d4505f89235ecaaa2e23ffd73f768298c8c1fc28bef5f3e8d0ac06a930415648da2dfe301af5c365bfb6097c3cd3b20fe4a4edf5a83e18d3a9cd615491516487213abddb9c53d3678a2c9b61b245457e9559c6cfb70e7ac8dd6624d90397506412589a96d6bc56006603c8035e90f0fe7e44a32975a89a03edcb8015e3bdf56245a9d304596f20085e8ec314e83ce66cb4fb4a79e20d56f8f4d7aa9beb883f533e77357bf0f1b8bd3e3b2b4d45f2c284997bc6f801ffbd52e5556b9cfe70bf8ac78c79e7131088166ea87779d37b230103cf790e126b345444bca86c647902133b997983dca903ac2a6379ada9dd8e3860e5eca97e935ba63b1edfacf419a3f79c0f527396d5a16ac98beeda035e366fa56dbb89bd46e4105c3cbebc9e737d1ce9a22791007fcc21534f0f41215fd230ee75c96e9f7a2a155b329a79a8c4fa233293104ad558e55378fd97864041576bf178d5c27ee0f2d51c3d7747ce08ded88b8b772c792547af01fea890ccf6944d5126fe77d81e20ba323cae606262878ca51e332cf15a2e2feba6427fda7c4d1f1b7cb680d0b698f8ad8ce616c555ed9c347ccde7e73a1de2aee38a58a75e719d0d0def40c7d1254fb70c9595efdd88c184667b90b11306d184912560cd4b800ea06bf62a2a5999db7cf9f8cda6b30ce4579310b91f79cb6646b036fd230844eab8c81ba9013a176acef9b1d4067cc595ceffc9eb98fa004048c3c7cd9a2a9de61ab3d3f9d36fe806464d56251ab6ecf7c2c582f071dfcfafe0ce18d87f592e7876e15b31dee14e21e72e2bb147e07d463701c46960fa0516b63c4ead4c12f5bc3de8886190f4a8823a614bf46fecf0f8c5b2f5f4ddf576e3dcb2cdf853833138e12e69a9686cc4539867d2f736a35496cbfb194c5150aa9ace9a870ade499367928f294f032f43877d513f32a41ca14364693b9e69114de116fed42eced52e551813ae4e3dc89fddd28b9f3280dbcfab8413905ec153c2df274133142a030f836814d89d893c0f9443f27c77942303849ab0f06b73d798ec3eeefe7ca270d7a73778c9600623642becbce79ef95f9b60398eb98fd10fed071939946ac495c1af7193619f551206afb58afdba5cb96644fdcaf2c4217c7aa224ab8b06659838d0d87a1e8d21465db32993fedf99db3827291459126ef25952b11ecced3e801d8f2dcc2cf7c8a907c650d2ccc3944519786ef222b273d1f857531b30a3016315f994b0078edde837ea5fc4ceca92081b031138e3f9c983a77eac417224dfa2a7886912f1d64ed4256c4f1b548cc520d693265f2fae207e3f3e751bff03d5a3d4f415e6b27d016cb25938ebc7c87046ce2d9c16e644ac92e0badc46185f2db6e1836c1bb7f8d54dfcc098ef38f0b986e593278fa13e38e9ff447b5fc33e61598e7295cd7d60d39973543875fd4593591ca9529d0cce2efe781a0c053fd9016b7aae622253af4194369f3f50c4cb627979502d3e19ae186d6cac70a87a9bb0b20433438a8811a9ab23b7f82f16363288b4a9ed9862ed4777883e3ae12d6f00fb9558f759a50939358bfcb3db1b83984a1c9288bc42869400a2ec36c50d00b9651c28090c7ddfb564761d38bc0b2288dc9caea5443540c9acbf268dfc9245042a9e26497f0c582dbec4339b588dd2cee456eee0fd707ba187521248dcb2c5232f265ad1962e0e9e935893ca61f3d2c55bce0f0fd9ceb4788c730d6cca48b1034cfe8203e6dbecb4930332b9ccc960fc536c5d43c516bffee64995f7e5a297e11a991bc0d34e96d30777dce1bdf31164b822118a9541a1f9483fab43823e74504b3b04cb9496e9475b9da8fef6d46409d61709cae929b060ef19d3d7afe537df29adb9035a229ff638a8e75b956c854a344d70564327230e5c7509d7acc7bc46d23f470cd00a0c90d32f8a69cc80707667e45c171c2d029b0bdcaf59e62f45dbcc135d7e0a3f5572dd6589de2089235bd345c5e4b7b9e60b8b69ccee8e26631ffce4891ce17078b3926ae5aa0ecf5809992f334d9c1df654e12648aff27659ce74742de5852077b364e277a3f922b8ece685350b85b578698078db624d801088328e4ce462bdc1853bf5c594672c8103a4100bf098f4bbe2eb693f863301fa573d66a8b35f375d014505c358ce5b2bb43b5ddc1d891d3e770086f5020cce00a2ee0ea3f10a54caf2b2cba0e73a0668b8fabcab115ce0bb54d4dabeef452093e8fdb31a53a00da6ce8b564c58c43e06412b51875a731a5d7b04852d453f90fbf349ea362850c5de2e851eb34f001586f462895c97a21b277364d61d738e8da1b248aa00b4ec303b783d88fd43ef99775fa3e6a438d3fe93dd17b5a5fbb4529df937eae391690397c50978bee7a682ef3f5d773c5cb942cb1c073a136c0c0436056bb2ed0fea2574b4f130e5cc23e6b878dabbc2d756eaaa2b893d1cfaacf43d17005920f5dc9ef041b563c1a6a1ff8c6eaa140e0eb166a2fc8689e5ccb45d81d1f17c421fc9b17b79b549c8db337437b5c4ffb1b12c05fc82db5b5808cb920ddebbe0b01ab689987411caa9f2d43dadd6d620b68fd7fd5a1773c0503b6613f1c94b24b06eef7071f66e5314e4712b3fad17a53206ae685f150ec6e758246720392e85d4329f1490dcafab11eee23667915c18981b9a94c297a56a01e6a652176a1eb0bfd36d715f8fc66daa9d767a83fa4a01bad66051c46","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
