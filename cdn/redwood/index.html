<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5d36c15662650bf228c38eb5d2d5b73af16c33e2535fcec41a9e0f5387c50900f488fcf82d1cbe684a1a358fc9781bd9a5ab174a4caa677d5bd78e1f3f02e3348583780e13f5b98ef94fc2a13e1c2b9b9447b9cd0078d234831cec48e9f5e86f16bb0a824dacbe134d168dfd9abb3a3a2107ce3910f21686880019e2a6ba6bb1813c4ed7031bab3af34ba21ff056535497c1aeb641b5ef0d94fc8612f607c5f04b2e2725d07431e5c58b3e21a98695fb9b934c6cefd9d73bf0e4b146f2d14b0ef698f6e5ba213ae5ee07c2f68484e99bc5bf1df6744a337b6980f2b5ca62a699dd367362d05855573865453cee939542877752e668074892d166639e8941b657fb4a83a981d0c3e0c315738ffe6124f2250af662b81f9fa1db64a5f71aba3920238b7704afb608257a5dfd22a8bc3679f595b490c55fba3df6e658410e9b7fa7a663a3795ee6ac34588db33e81d71197652c6205ad5609d3072dc6452dbafe99a2198f7aebdd2eecf09ef90ed97c5f74754971779108d5b875aa17845646780fa0e74b6fa2643d2604297a27d083dcc08863bf1353c6d334a8b3aef51d3e6d5cab444e41ea4c0ed426286d0eb1156a0c124149dcea2cb9184fa0d8eaed54cdf5230a6a9333afcf415924216bec15996de34474f82809488d66959e6fe03fee10349ae0086c3fc5895c6444c04a985c5a1b3ec34f9691e4acae088f3f6ec0a9fa64d5bfbda856dc5a7736a907ec9d62945f5d42e5d28cbbec98418e8bb70139f0616daef754be5a1acdb35f12c467deea135c4b559e4bd550e0f30c863f8499b4c7d7eacca38572208102caeccae71913e73aa046ca9a17cff294df91a26b206673fab5f5b334316d73b30d662ed38e109e68f9345e3b42219e674a7afe0098e3f534e85b838db8ae6ecceb6b498e60e7c3e2ad161f28d0f236b963c7140c0f9c7da63bdcf4b74e226cf3ef4d5d6e667be6ec22e7fc6aed2ec22e675c15495e565bf6900ee2a7112fb3a7ee3411d080d5abde7dc9eac3dd0585e4564731703300bf4dfba3459454c399e29b4d2e613cd5e0f6b4158955e0e61cd52d0afcf33f6299ea3335a1745fbc957bb39d963de10f81b10f04e7c62402ce287012d28aa43a03aae38cc090d006cd91d21a758ef665d9e0aa34646cb3e9ceb22846bba43a69f5263d59cb7136277ee354ce263383ae1884c4d965d4537e81311a36c1f3f4025a2b85533b06d7d003105e82b478ee4b6181a01d2450cb14b9b5d5562e0192b5fe1cb230499a92bd7a3b4a0487f13cd9d26c1b1a2be9ee38eb31ecd2972a9f41fbd355569cf1a36989e2c3cda22ef442fed9834f9ed2f15f13884768866eb9b3a5599e6fc18953b01b404e5a3878198e9e4d36b96d54665dc20d57f1e93d7199da51d4d207f4aba178d8a8ed3ec7033aca02741d255b0a204cc72612819817acc959657099e72ef133dce3d469fc381dba31e63d9dc4c47705a90d11fe6958fb61afc9e85c27c39dcfb8eb825c9e5af28bd2016a8cbfdef73d243e3e328ffdfe694bda91adb11e30fff079bb6f8907b18fa073807ddbf527d7469fd5dea3f543b427d13aa5fa9169cbb9b7909fb9414e084b571d33002cef5f335b5290c28cf123f11ed723da1a095dbc5920decf8dfd68c9b8cc9e1a6a980ea43880f22916a5b29825f9c561d35aee7fe50d656e7321dd98da0bf8b8a524893c99b818f6ba5a9bc551cc186f4d6aa9e417bdd939262dfc33682f368a0508ed09062ad48670c8caa1687cc27afc2788ca92ccc1ee63be96813386ac54747c44e2ce220731cc09621fd315c65fa3ee3654fd53e31118c1316e2316cfeffb099719e10489cec41292a3e233001aa9a0b8bae3e6be51116eaa432ac4aa035b49f5608a08edbc2dbd454d0136c35fc6286594da19eedf6ba2841eae591b13a9541af1d0ba8b9708dd97535f623f8ad6a842c6baecf814888543f59161f2d91c3531a09001f957e0b6bd8af97588870f17a0906deb77867969592be06ae7e9e92a584961afe03274e3a651613487c5f58b7bd011411e04d6f3d676d180ae19437952372d874451516d633ade00d2f11f778a5ecf739ba7ac8e69783b285a90cdd4c0a0d9ce1ee9a73338192e5119a9c9a12d3463b60a397bbf0490a20dffabb9e0399dac4c2cd3f8ef19c414e8caaf5806e4c62187a8ef9d1a75386dd13addb03b24dfa7570097da6aa01fd7bd44b90863f4b58ab1d4973a382c492598520d0b44b68946c679abe1152740063b4509e8ec061e2548ce80e41e5e884a21a907b20bf63e0021232657cd9f497b71bb278123f9e02041b1e753b196365293a61acb3e42219f70c00849bbf314acf65edc5ca9acaa2e1f5fb75700c801eb8ce95de90f6913eabc02964d2f2ea449e3be73c4bc1f09b9a085e6e658a6eeabdf4b6e25568fce08b17b9d56d09c84b55a9bc9510262f35fea4d8ba29fec1ca81abc65d796a7d61c4f273394437afd16c807f66cc30092614b623efe3e76fa7ce7ee56f6002a6c71987bfd4635def88d45262e34e07193252aad82521227d1844fb119585107aee694a4fbf94ef066e6dc95c1bb8dede93ccf8aac767c94ae3bc8ed2147d25b0a3251c5f67a9563d38ceabb41c54f5d28857583182bf1b07d7e792828e1c8fa06df66bd16214c48d2d448394ac2046b394d6690dbacb53ea8ec6973b2c04632fb90c4d4561f10ff7e41f0528e3f34c0762ee8e72f05510536ee1fff94d5bff00eaf0be5262a451332323890f619821340a2550ad343d4ad3d242788d879727fd4c229f7283e575124690d120146b1c152adb10e0a6548791a9733cf263224d0d6946d51e9237d5698a9d45e20aec966848f24b1cf8a1eb78513da88bca9dd2c6eb752273f21d3ea92df801dc1b2202f6f697d98a0a4e29278b3d90417aa1d18ec7a4a92b54933ae34f957d9a646be0b28d4aa83aa844d90334d17454fe9fcd48efc5b5161a6b7006f4b83ca886f8d386a26a2a3df27842cbfccc4b0f87c6e4c2ae2d5be6d8cbb6e6d2d82fda64043c0142ae6488661cc89f1e515d59dde2a7f5c4aa130e37ed0fca19e5f299e1df5afe2aa0a1959ff5b1bcb0e4318af4d13ab6c59e00eb6213eb8ed60c06caaa4455b4697050d330cdf43fce985c203a727177414b9a7586daad935e9d57c749ead3fee064617f4345fe4e3c641aed313a5130144f4e6149310e4a25020553ca1989cf16e1311d1f885175f43711853e95651f5bc767608328384532a0c8a85d2e60e94e5c8c67e99c3f6c5f45cda4a37acfccc27e37d35f5137e5b7bdc54cd241aa97e10864b7ca98cf2e2566d34f6c37de4fa79336c3be0d61555bfc1e86d89918ace0525aa430a3bea55ae70d2a712b1653fce59af543c391abe9f37d60cd20e312a413bd6b8f53b4fdc9d7507bd7e7505c875e73dc4e6cf474d703762013d43db5bbf68fd77f8a300139d4c551889148b966fb0925a7ed5a38420531ce4131562e9a5e146f723661f2a3b20094545cbcde9d2a1fe2e3cf343092a80c8d87537548e0a2502366604d0becc36709f666b68ab895623c70b6c6a7627e4d100f709cefbf769e2529feb27c355003b8e8374516774b1c6ad54b3b1d8aa3a3784468860cbe874d891ac7aaa31b0d9ab683ccc6ce0b9d0b90caa1d83e82dc8e1ff8502eee14da9e8c448b8e121731c61a1b4462b2f0fb209953cd80677a23ae48f1a2dd47c8d2aa68562e68da00be5c48a994e79e376484bd650c507efba72dc1e8937bf47da08ecdf6a50a4fc0f4571b7652727e6dd4349cecfc90c9506bace9578616ebc18c392f366a2ded810d924961f49b807244082eaa2293e784ea0de9a60bc9ba17327fcb0d1e23181092490a5944102bdbb958c84df98fd04cd788182f564117967998f8ae49f688aa776dee447033f828682bac0c8370198883041ff1842d18480674577cdeff4df0c865d7ccbd006dd3731727788acf0eb7e53636616c157ad75235a5ccdc98dff2cd2851d7f4ffecdf425a6c34f88ddbcf1286877d74803cc256fabc3ace8abff2d357c0c71cad3123cc59ebf4957bdc16a4455151fdf28dc6f3fd492cf4cf03db43db561fa152f5f8d756ca359f65c34ca34d8df463519188d4898feee6b33ca1c119697849710abb0b62e4553c56fc964ed834bb11c19bf2e53072cbb8b051876f7c617c560867d28c1299134a1b03f38dc165675910ed199b9409f3da34abc8b4310a2c56925b1d3817ae9a5766d4e60ef7ed95af6070a3cde32472e8c45129fa7bfc3eabaf4f4f0afa2386ec252de0f2b57d51928e0acdcf35695529fe468b71cf4f67882999ea86ebfe36befd9075198da954558fd19dcc58eb05cb3cad014dcbac31f6c763562ab6326cc21f195ac565324dc379fa8f02ff877991643fe7ed9a6d93b667ff24d12e4d775d3a1a78ce9be62f5025cdfa4b0875530998b6f4e0ac0c385c168032c3fadbe9eaba7c5cc5b5ce24ebe552d9a8a0531d1ba7f6877ce12a321da6276ea2493bd7715ae1a1907ed8a1454a33906e80f3d3bef6d403c663ae6d6fdb52fd59d204634e6e6787eb60d17b7b07518fd4565cefb6287def58f1122806c7ac34a949ec8d4b0dc429ac1194f9373d7a1372101034363aacec786f6c472b6f80a9f9197c09abf1c43c70f4a89dcad4171280741ee6b312c6149f498181aafd10e27260f7bce75acff5d49d1586facebe3b90c95fb19e05d98190f78a9b07843e00311ac83bb2e979aab0d6d8753e9f457b182ce867d379173adf313c1262ddf6e6617aa9e6ee7791aa1591748a569eaa3867f1059ea2bf677adee665a2357f6860564b6da104cc0022bb98ee3219715781b2093e2d2a9ed8457a7fdbb16db78fab32973c9117a11b7324dfd11a52d62ac57fb377dbcca90a64622886cf19e05de362125863d4178e50d6675fe6b25b8ed91e34a2420ac6254c210f4daa9e10b84af1a7b75c336057f86f73bd9905c819165405552c7e5a366915934fc5c78e9a727d6b5aab385451f4633d4150b38112ea55862f7ab809f5cfe793834e702e7cb5e2255cc1f3682d1e2f82d0c00aef0dcdb9b5b12c0d7659bb2eab7f5212e96e38c4ddb0a07bbf33d6104619c47b70f007ef3cbde758edceeb3368396ed99d28cf232921f24faebc7a060f9c57f47813e715d80f49f809242af0ab80f022b66aa26275dd5b7c54b2662a0968bbe19aa2f509bf9134bcfe75d98c43cba7d2ec095f0036f90bf5777ba48dc5081d1b8ad494d655419a431b2e994583ba9f104cc941d09f980b451bb7034ca2d17c8f02ed7b8615fccea31f7b2801acedcd6c7c83323871aa34eaa350b9f1a178d4417a2b6367792a2f170fbfc1f179ae7d4730101d7311dffe834f57015e455cfe7bff04c14eceb31abd0c04bc6742ceaa97d3aad81e827584e3f09e30f1ba4a0338a6fc44730bcd87790c0799fbd9ebfa6316b2c2bb249d7aec7e0fbaa420facb7cc931a99b3b3f3ad8bcf94c4d6565d8ceeaa913b6c3b8eb0f25d293730a334826917b1c0e3514a09701170e4c5521a0b9f2d281ba9b54e50a77fa4f1d0ccc8e9fdcbb9699cad28cad0126d84d0592b0969cc87b11795705859b95e20dc82e1055c360fc358a7e7351e8a6dfad518e144624f0c416739601f5c453c6e0a982a87e4e1f595549df5f8a366c5968f20db8c2427d9e42ffc6688abf61c59c3078affacf5515f48184b5503c22a50bb47e3bf700ddfe4e667d0fe72211de1938899944d42c41194a7fb124a074e8aa773d1e8b6db04f6bfcd1561ec5b5c8292726853959c4904aa83fe4a88bf8d6fb8702bd43fd7ed623cf33c7c557fa7a8e44cb250951240bf5d3cd2eab8efa0212f53b74a692c5191255fded21448fe55b1f3aee370a20b70bbbf054d174d791bc3af34487585cf3e312723763b0eb903bb7e65ef04e40fc239b2d2dc83050ba6a06c5c81c4fc59c13b776472b80da2e5d40f1ebafa171c84b32352841f9f4babca0c9d96bcd606883079c6636aa7d84be2bb4348e9b03d9803dae226f900210299e64d1540b851a9513eacd22e8d1e748e3f4855a9bb26e3d5857603f2dd7bc41d543e59ea4e21890e339d1d2834687b889d0e830aba9fc34ccae830a84f99bc4f2e23d32c6ac1b3785624df97196369b651b38297c27a2222cc6f166505680a5f8d5cd6ae463e9771309429c055aa7ac799f8d894b58fda22f55f267ba130820c184c2c1bba594fcee2fc8ad66bf805044e6ae4c279bb761aab08a41436a1ac00a23b4860a393e7924cef7e3b3990a6345426bf9abfb261ccca85420cb93ae95884371999b181ad2c7a91c39828909395774a600535e5dcec7a9b3e09347266739d465256d637fe716dfe16607e767b133f3841d6468989640062a8c1f704a453f3c62b87ae6bb2d6168d4535b109e4041e4f8ce7d3c1ef93d1b9559bf3c9840dd6f6976953a630352d5b6b4632fdaa1ddecbcbadd101453a42c55a693ba5716d9ac0fea21fccb9aa0222dd65f6efb7e8d64656ab9b839afb9ff98e3abc2f1c30278fc6e01aa44744f0bd3ed9ee314dcf15d35015b4f23f7002017a94de80582fbb0da1807c794f23afca6d6e9f10d9b7ca471fa5c09995f82e70d1931adf3c4b7d06b990a9c98f409e7b81f0c8842c75d8c15225bdee5fdafadc309eec26f095e99eb758461808893509947eaa22efdb359834afdba440cdde4742c6cc4fde5e83ed584da321be4f09352cfebc64689dd2d5d4002e234b53876a302f0cb32c0951ddd51c5ac0f4be5847251f3c9db53c4753efd9447524eb80fc2440f700c51405ad3ffd1816bae7aa203ceb253056d529e3c6f7db52cf0e06f4635919adf591657ac757265c6d566848e80458402ca834800a47b62f0c2b6c4a01bb5c91c6ea944781810f77a45b5f1f633a747bbcd42b5474afec18fc72de5534610de87f5cdaf63c8b3d0a8264c2ac75c8e208432eccb18de9d686a29b27abff5171e279f5e668223956ff6077681495d8525c3edbe404a69fd9dd94793ff6f65952ed66d202c132820ec89e5151125aff456526e324622333dd474ce858124d0b6fbc89c1d282e1b194cb6d548d226daa18f3c1d484c62f3d7a5b98e742e984a751cfe59eba34d519e9f7b523ff7e78732cb82133ac2ea13c65d6f4b2b717802e28a9de8262b5ede4a8135071127a81041ee7530d49a9600ceb0eec7cec7d45ebfe826120c97d023c8e929988c014e6338a2a9479136f7337f7c1727f27c55ce12d01a81274baca432c4e34a0d953083dd59c7745d729d88590f193e344d69354a7bbe9b1bafdfd7cb00c0b5665f97e6035ff886369ee6d3c4df791187983d0e2874031dd8a69651d1fc1d819e556b52f03a4d9be9c5d79ff7443abaa224042e80f0ee515bf2c25713ebada397719f671f1b9b2af72de341aaa24c4860287e91f27b1f48abd7764e579aabfba561cb3c709d94097d7f757176b61ae991687c2901cd9450e59a4d16cb5738da5b29f46530d283702b6a023b8c6236ef5e5cdeabf463dd45d65c97b95fdeb1bc01064bca1143e815ef41d434c667793a512d16381cffd3879ca005dcedeb1d02b3cd9c893b93ecfbc155cf644439db688afebd03cc1e1e5bb9676511579467ef8e716fbc05ea5073e478860d1d57e66b8805217ff8bcd78f0a967d7a6032107fde2a5f42beb4f374e871fc58cebc82838a2d5defc9fde693822edde48707a303c8b04dcd03dbce2bcdcc4d74bc938e5036deaebd45a2e0aa12b7d6c0edccb6aca81af1cac266b6a91244bd7daaa90742f718b0cd6d3b403dc51737aa0a807c2552316333aa6dd98701e52ff10269061311f56c0b6eec297d97148f5f21a1c01e1ca79974b0e11563b48bc3d22d32266ee3d83dc60d1d52982c06351111f427b2855fda90437d754519348f4d272f031d1ceb59200f3deaaf17fde3c66e337eadcfc9d4561d4ca545edf0174e8c1effd20ac2cd8e136df54fd379829e4798cbb2f44b28a2293310ba8baea1669985dd229c9a9527b5b00b09f3632b71a9e26c7d756719be8e303a31dcec91325876d58fbd2bbb3ea42007b3b99a25739dde40528476c890b9b3ec25d53bed17acafd0cba16ab958b4cc73949a0bbec8f1c52acf91d0a7cf4967f19c6ca05abb94806f07ef15b258ea4f11f9832c4320d0e040d74b5f1e841fda61fe9c23eb24e6bc3bea9254e0a86becab9d1608ff9f5b467f6b8c20877006cea89af1cdbcdf00a00a859aaf45ee48c9b4f979e1349f37eaf6d169da58dda878c302f1bd9cce2b760159882633c2218c222c48dc912f7af3677e51c30750aafca3203537dff29ff429dbb7eab27732a6d7d4b728a59cd1cc7b6d7edd4c4e83f68f896d899d4a0dff6b39930c24428b1b5df06eab659be07d0d6bbc9288d511b171c4aec7cd516fb8f2b3840fd708850a5bc6e41604fc08485e1d6963b42173c885ef03c5ed9dce0a08e98e286eea9e1dc79a26433002ca1d06d615bc72038434f8a9aac9bc01675eed9fac64dac664bc18327fd7b2f8e4b40549317c0eca6ee0f41ea3202ea223671c46cff30d06a244700e55a87a9f5e5cdde25a1549b42649ea818be0c5291511d80296bba0f58e3a5c164db9ec59586eabc5b60989884016071e903708e1f136c6826826cc02e81b1f4dd8d5d84238b530ef16af18755c6240012cdd0377217c8a191e704baacafd00ee00558d0ce614130a2027534bd43c7ab5f69e3888a6b53c70de45bd8cd1a6b38df019e3e9fbe5d42d9cb6064f80df508fc6265e58ae5caa2c1ed4146c9c5acf523e66f3c4f47149b3bd330eac58dca8a49b9818c67506556562a5f54e0744680418e33d35a0767d86bb031a3d294787202c04261650f67bfd26ef6253e747477bda31d50f022292e126df15f17e5ff4b7685c07c96f71060e542e45c5b85c7b25a60988822d88e825ffe9cfb1ddeed7e74003d1a7476c84c2e8af78044c58dfdb92a7dce6fc79f9be3d281b47a41d9d651b0e6c32c5e454c0388303593b9f6a33c2af11513dbcf43659e4691e2d5d72ab934757c474fc09d2f474ae6f018bc679f68dd34956539160d5d380cd1acb12eded033bb884da7c411786abfef98fa26503fa1149fc475ab1ce5fe486a775c1c32d361ff3e39399fc0533d5901ec263f899e49dcc49ba68299c97870cf031345a269c93510b7aba76fe27139c2b04e2d53e838f9a3d74e4e5e31567ff5bd3d07ee38e5e199676460d7ffaa332e1d1c6a394fa594d68d4577db68365529e8923a9f37552a672108abee0a8b1fca5cb96a05ce2bacd4c9ca2e3e104a78df0abefaa70dbc48f9a980597363928b0cbe4167ab684702c1b08f1fccc4e1e1208a14acd113bc4d3998f17ddc48ac58b2660e5a710c11db84467f15d13ba29217ec3af410356132fc84eccf7aebc867af7b23343b0b8242635cf5464a8f13bf73d9c0b3d16e666a76da6b249a8f0dbf31e122ea8f649e8649f734db4fe3fd2cf884088b84bda8e6c512dd91631a9efdf016f5298a775c91369cb8b7cd1f946e960fd8751c90b5fb744353e3a41fa8279be19e57af3060feae6cf0a7a9db7c5cdabc8a8f8cc519d18c9a53fa3a568ad89acdc84acf52e183a6987d8a569fbbd2df35b0ffd6db498341385baef8c2b2ac81337bd50efe2b6188ea07c30b822f26ce8caf635f3e538b088c801740ad357d7741975752e1e454f25781a1fd1ee6d3de5ab5d116569b00efbcb094374e1ccac43f570afd2a691f0b7c08516e8301ae807de55e28ef0644726c546d19faad1b72d7d092ecc508e0729917b19b594fe67fb967b5d001149eb98acb1f7882c8febc5be721e4ddb381a823bb6f914847b8209c3902c7a6236176077abd296bc59e017edd5d43d724dd8f65c1efd66bda315f1157866f92c6654a642532dc8989d49e769f80da0425766a2225004328b3f6d1f952b4cd7ea8e9450e3392be2db0c61137fa684a90140cba08edef5e227b82f80c48670d53365640337a77dc150bf697803903d024389922c06f97b205f7a085ce54e25dbf40f372f58d64f384fc2dfb9ce42ce8cb08ecaafa091d19d8a01ef3af142360afaef414aaccb90330c10bbc760696c6e6706d19142d40c57a8cf14fca608d2b23a38e2e1a53f582357a7b52a63dfce9fde4a5ea9f28e47a9fd1a1cc40b8e39b2c4a2f8d5abc2dfa9d523c06b1e4383ed6d8be63ec14ddd02464d5248b9ece4b68102b2eac6ee33ab672649c91e0c469c0a3a3897ca89c3c32c987cff7b1da62bacd529d04f8b6e113ef53b70b38c0cf0eae3b05aea5e698a4303029b4c733c5250fa8bda1f22b28a387f1ebd1f1ceda6995252a1578250492ed8511557333ae6367b28ec1ea7ae27262aac31f26d3fd853d5c2567005e342d6b9f50b0b17df70b146aedbd2d34686f9979c08abd29d76f64fd6c3f84e75d2c70b0943f7db29fa49b87c79a4c213d5c6a528629f9e0b0aadff0efe2b97facd8cb63d6975d08bf99190a30c88e001966450a4d6a7c1c9c016044198dad8f6d7267d3242d315626f07b36a16ab0e9b01cdbf3d079c39fb976d5ce8e69864b0b06f952238e5ff5b36fff98e085e6928cc6d644528a2c1708ac284bb32569369246407ae994b9e6fbf1c29e715e94f3525ed0529086205d50d0f7453a37f4cc56304cd76561677e543a2077316746ad0219c96178754cb74fa5c36d6ae8e3348159651ed6e2b06adb85c9ff3c1955ae4400321e530d850fc35188254c6b0d6631c7f5c65314591c5218afb97a3573e656700b347170233a7fdf65bc8b477c3193a9b4d1390ed9ab3de48043a9bc4aadbfa7008ef601793046a77919ab44f82a3373f80648c07eb45ec36f85236c4191708ab7e376184d2e771944be0ac518f3fdd83f2f8e5bad677be716cd4cdf00b23337dc9fab8254a93385cdc4f812a388b5bcc160b2faec79b6c968ef4b924d1fd4ff61f3473558c37ba718c0fadf43c09bfec211f7b35769491e92176c19003813110f08d3916e82e5180457d94396e25aca2276067d42e2c29aa6787f26f28fbd69bbe1c5277503f5b93acce89d0234c68406f0e96dac91b1e18a5a9c95a78c98dc40e14157f100c89ac07b873f3ba1e4b220f3a5bee8bea5b5c556fc68b51edfbde52818082c4599a6125e21d1f092f90206807b2c9a5e2801988226577247f8642d03ea141870ec11beaa5654f9e83957cf663a0ceb624d4d897731fc48d0382cd6f0ef6befc260cfe5a7f947d895f2b0adfc25bddfaa3d17894101c5dea2adb0756493831189aba8d204dbdbc3dc4169f1880bb8cca81ef420a5f8d1cc4c6873258fdbd227ea51603d22e9fc0c02279971bd63541916b5e7ceadc4cbe26841322e5e53a5d84ffc7df8d4acb61f08293d0a9726a6e576b3a4ac8d8fb82271adc84381192c94836aaa546133e24627d2a5b5d13f302f0a988ba7fe4fd8fce6180aba7c95903f417a81a06091b8d2f9a0d7f8a11189be081a6109e33895387fb9a842ba8bdb4f63ba2b7565140755c6189af60acb768eaa66dc7abadcc7722b7b85e9a5b229081fabfd9468aa8a1dd51d22b99b331cd075808521145f538df9458740070ccabade54df190e1aeab06680d5d2158275832073692962219b4e30f241f34a58c3bfb713906593df563ec32c79b3c42e34501ef7313443d3bad95fd735eea57819d0c1febe23ecedaa60ef643c7fa2763fff9d4d09cdce6da3402a31726ae59793b449133c67814cb3fb51d2da4fd7d1cfb10b5d960cfe0eba3735a4ba5a7fe9817e52ae9d82c2b27f43482a7e0bd7d3bff046ceaa8a9b0daca49671688986a7a48f11276c6842449ee13b9f392e5843aaf3d2932c381a2ebf9e151e41e99ad706f47efc482445e9e5ce4f587d4f966b01c327f6399cf778d8e089f2284bd38d06f87a8a0622bcccb52a549b8ec18a1e1eebeb782546d05432c5b642c45e9711abc8db9cba9cb91ba28b999682a87f309662ed1f5d0c5c72083faac2b331c90987dc32f2fb1b7e043831e02fb05adc030349f1267ef9da0d538ed07b478bdd9dc5c99850ac7ef9a0e0aa2370bd678610a05ad55c13b0d6a34bdbc5c9782b0942c06d1ee98cd7d3c852e85f39a6934a81e23ae1e1e9d3c755e2547c6be6cf37088800e8117052b98a5b9be4de7c4b4c8e639b38205ecfa612a13ddee7b054414ef9012860190a0637952ef5dc40fcc8dddf6b6fade96017623b1fbf839e9711afe177bd16b88a57a9ad705235a692442df1ee575250e99cb0b6b4227a03882c368a40d60c78267ea24c95629897d7f6db31c8a10c3467e77ae299daa3bdfdba39e2c9f99c0a8e96bfd5c7c52d72695069f864eee26af18178203bc2a34d1925789c86913d0756d27e1c6519bcbb5539009b25d163e081a63cdb74c0a98baebcdb9e0416aa427dd7f121f834fdd6455b7425029b760a605637b3ffe1681be6743afca6dfff629d0c48ed988dfead4e42fa19b37033feb1d5edf963f9b82a860d6f3736ae14a5ec877941ec0fda5d2cb5297f299e8f999d20b3c17bcf5d6d6bfe129f728900ed2bac344f6effc6a12318b136d1be270cedde6c5e6273d43bfe153ac829568bd4ad66e3e79d67a6227e8fa0b78488bae08391ed109053de0f03103aa3ee31b3f091bc14f41d791f6539bda9ef5d23e203687360622c58c7c452b816cde6200315e716cd4339f6bee7eabcb983ac40a3b0e22adcd28d11a245a51a388e0595d6d8bb40de127f0db064537c596727182cbb29d8899ded96d1cf161a2adf2144ed10ae0926ec28af0a8449771063f349082a10c9e3db5ded80b0a989fe88ed4a65a400d05e49e5e59829832a8ae5ed5f8d2cbe55da7677ec42cbc2ec9cc49ad8401381ae5659f30f921f9b7ad5a5a471b5cc112fb3181aa5c6e8e15ec6db2560173799086949cd1b5fd8f6582b55ed0ffd493c35a012bdcd1ff555b9d6d9a7071bd7d893b128ae86e3f16a1871bc6dad8cd685e692f8e30f234270efa4d6f85569f7d645227091b3962c91bb76b35ec2214a769e15dc96102bd16fd9ac4d019ab2c169862297447ea5fccfab5e78beaa0404c3abfaf22fa21a8f9af75bfc7c9d11806b087345e6641f225f74dd0b5527257e39102edf95f86fee8100d98ff53433c2063ede7d669e6ee37c5f1a45aa7672b504be1e795fa61346009cef7e80b7e8ca98303ccec4ea173f1274951b6cad3f0b21b16e1122298279245b6996031133d7ef873eb7ff57b673d2d1a702f8f2740564dc3741824ddbc1047ea38e0d7578ec1a0a29c98aefa2a74362c8d51ee875404823c344c274a9bb0c85749f2ea201273cee4e161c6b44d75f1370bd666bfd36a672718471470bdedc68b61642aabd8fdca111f5049c3a7cd9b694a69df3533ef8bd9dd71198971ce9b4ab0c058e904313bafd2238f393a195019559837759295d7ce4421bfb4ebaa747a4f426c7851f8ee04e09360dc612e83fa1c86d23b2e4b5c214bae17f3bb798f79fb8a61ce5c371cc0c1d6c26096b4d39294b24cdb351141ef910c91e63304bff8b5539cd7b856c835c1524bf04f9035c3ae24b3bab1d896e00c705e37fa5f1827c6cb18a29dc0038b21359228e07a380bf702f6f95736179f346dd5b77a1905e9aa468706a1bfd734e4e1abbed65a51f6fe8f4846a6a3ef53c3940a6e2977b73e1cc685b6fe605d9868ed3aee1efc1e493ffeed149a562bd188a437841331f1c75acce68c707cb0f12ca7530dfc1764a0fc9b077bbb29a77442d5279ecadddea1ba8a3ecdd28831f501cfbfd6f581144b8d9b4a479fffbd94057ea635b34f7c2a2db719b20b35559300bac8064b28238dc831077d9a3e81e462293f6afbbd571fbf68159bf7d6f4024d65f96177f537d37fd8bf13d1eeb26d9b5bdec8874f88a87b70436b29d2eeadca4749e7167db9723ad10abe69ad11b7d4bbcb938fda332e2195d40be6dfc29deba7d5f1e9593eb157ae0ed820c1295d0dcc23472af19264b3cdedef20b6f2f6439790405a3b6fbe3d8df062c3f71521c29ef6e577bbb8438115bee137f09ddc9efa54d48d0c5f1113994b033a4ba6f22b4ab13fb0b265beefb0935fa4b2c881a456b2551947bb8e89bc4ce63697c332751ed2eae81f0445f59e362f48d7b9cce16a2fc14efdc7e2561bdc66d922a60ca1872bd888d359b2c709e51be508438b3a25c69b7979956b6c6e119d9fa2572a6d57483380856711c1f82697d75691a59a4a1bfd6ff0c8519ede91fc3d33cab9328a302bd92553a78854b7097930ee1db05066f2eed0bd87aceaa48efbb58adead0df12a7c4c24abbc0e70fad3005bd437abe08655ca8473b5a575e5648f025fff177d1fd20020e3c3390b05a99b0741fd3905eecac7a12f5315a4032b631e2508043ac8f36ab1e0e11063ecd6ac9643543b34aa775829b21ba3b28c76b04ed53bb7afb274567bd1c928d3e17a8ee70d6ebc40044a63f1c20483e29e51e478952635680ed4e1464fe1b5138a8a32aa0af9e4cbc936f5eb04dd95c32400abd91a8d54bea03f8ee719c07fee01114f0421e26d1c3da20ebac16e7063d6e511ecf5102b6e840e7d3155f04a07b69bf11d32dc8618dff3a1a71a4483a5a6b840a7154dfa2d130c4c45158ab526808c2d9ee325c85de2bd18b63824a068d87a3fd5b1becfb8f13b391d276be383354aad329595d25ffd5ea305602dce710f0ad8af26659bf697967e16993aa0750d46b5e8aeb062c64096cd8af35decc605614de30fd4878c14154dd6ca706729da005d75a93559ddb9ec048263e59455926b464c9adbd6a48c7b8cd212f54e839fb5d9128f4b2594ecfca81c002a8c55d6db0d29615a74a296fada31910ad9e30af84574cc9c8bf480231755603a104246ed2aa9b5383b85e1b1759d84319fd159d2782d306ff2568de530da2b39e4af1ab00bd42ffb7e530d239f6be6868041bf09f8d7f3debc1f1a54b2fff4f1ea7698769ab20fe0d85978e3a9674af967447117c752fdccace88f3986b538ef0f4450a709db36edac59bd3a88c4abce7cf3748b81efbb8cd6f858656e1fbd2ae396869248e7ad6038f42f9fe8a51961a2aae7d10ed76b9bb0c0f0788b72645f5e2912b7afd5ec8e018390af74382a29d2f3ddda6fac5324fa58d40ea92c2be2084e6c83b64f90a38bffb791764d036a7bc78fe1c525a518a3da72779bb782248cb360fabdf7cdb2f84c46d7340109564f855369e87e23ab8dd4a117219333bf851e0a16862dbc36893028de56eef724f578bfca440736730530d381c681a3b98b9e67f5412ad0eda192c6c96a7872bd9e8815605ff539e07ed20fb934d72e18397f8e04f98f33ecda61d240d1941f0590315ed933cb9fcff6db832cb16afb72bec97036aa448ae6d0a7db7ac390f69a0a023d97463bbbeaf14b289891cf15d944bab3f3d86a4e604152c231c5dbdef49cae1a600d9f8735fb58fad2d48987e750758bc649195538e685d1e56602f54ba8e05319086d68519bb899691521c80dcf186b74df5d17109da620475e4677c6e4c24e802d0f702fe0825f61a785ca335607741f4d3b93d173e482b739c403aebce1696e9368b3ac33bea91a2fe37331fd35daa9ea18a0f60e90feac7e8dce4570e41b3091066e15bc2dc295f20f796a7eadef066aac36016c558c358dba9cbdbff9e2907fe7856416540d3ba146a1402805ffd6e988f1c9823354e086b7fe136c6f2d00902a35a0913d145588afe8de5cc6c022fd886feb40ec7c5178040cfe807d6adb9cd19720f6cc4bdea928f1c421d248cd6198fc6872898b719adc69339e0f7499fec2ca9a13f3a0d5426d8f5846308336703eeff4b46db47a4f0e2d8e45a3e1b5a80287139116f7664de9119276ddb8d18afcf0c64ff4f1d54ed4e2d5a45b555a5d3275459feb49ba09eebcd681357a6d79c03e17c0a46cd3c03417ea0749b8cc7c8545401588691a9086da8011900388eebacc7f02a803cb6845e6f094636f9d162e14228a0a311755d5919feb4b9f92794fb55a68522cc091f855910d866a3c75c1cc6ebbbd529c9b4d5132a625242e65a909cfe18ae3d945db9bc3e94d169ac10d56703003dc941a41ee438a9a850bd42708b8ed0414b18382fc27d92ef7a2048e02ccc0a62d49b0a090ecbf1b667725052238c4450af53364a5a2db4467c4b5ddbfebf1bf5457e60202f11b28efe32e89923d4d96b810660bc11967484bc7a6f8eaa54017b6f38c9d3034b99266ce0e3abcbe9f0ddff29209fbdbb6a473f8b63a140d2af2b36f050d64249d417999694232757cb206e8c15e36b7f6d009ff14da8ad856855661fb577197ecb6689911c68e580858a06b65a2261f7a2764fb588f3188dc31dabd675a78fd1a0716940a5f1927f9463d8f5189a4cbb9f86e3e96259b302133bbadd83e8cbd083a6eef4d6231083b8a3ebf330314fc2cc95cae6c97dcaa3d0210db6e7079a8ff63e2f8f14cfce914148951c1789469aeae26be26cc0482b01a4fc3a8a32ea6caef9d8f1afdeb4d866529317ec9bd1842cc756b3716537ed88863065a2fbb0ad803872cb3cce5c3478636da88c327d77f384fdf203b0519e57520a6db050a51d8bf6ace711a84fd296f52a8492d243eee41d9fe47885200d7af93fd565b72eaf268f74729dc30fd86722f0d54be522689974881da69e2295d1465caf2ae4397a1808aa848c8c158a78e1e6622851e9e30edc7d9f4b3d589c4fb4f189e693dc52343cef6c076117c74503f8037e51dd6933561d62e8a81744a13827b884ac568fcf5eedd956dd5e07f57d5eda8c0d4db3554097e32c90a6496110060085c43e913f955680dacf441c5123c33614668f814095e18c566d262c7f5ad5250a1f0dfa4b398a1f8381dd955d7cbc7d8998764e9fa80c4305f4090dab5edadb1503218068221b3f224d654f0f55ad92211f83f94c2255e271f9808511eee44865441fac02744b66b56f2fce79002e2209c467bfa8c159e82ac0c3b447e1fd2602a32e651bfe1a70496930603a0f01e0ddac9db6089070de2070fd0f35bbd5cd4f4002fac695aa9c3dab8538ef073c3c31225e9254ae1c80e910064f845bc7db854c016227d54a1673b908fe40c0e967014bc32e3647713580c371f655ec51411dc54af76d954999843492a3a0c6ec04a528ddfc6c26ae728e96ddc0231de4b60504214b35a62e10785783a489d6c1cabd7c26a6cc6fb71f7861c134929be93b93ba6f5bc10eb2d7e9d4d1d8f46177cdf431f2a67d0cf07642dd497b2b53cbcb5ee4448fa65234fa8870a5161f8cac963e5635f3c8fd2333de9fd90d03c069ff5ba91ae67a5200972d499ecb43545bcda1c2d816ec00b78e2363ee8cba1468b9d1a3b97d70a98e8d22d2128219b6721446a843454f38aadc341edc8f41d613607966b769e5a73d40310d870c9b6266875c810a4eaa416ca16e1839eee4c8005d6bafd2d5a3066a88ddc20bf5fdf6aeffbbafa05a0946f11a2b95c0f1bbabb23219a7c7f39f97a55e570508722a0756a2df8cb43476c24d62f07b1fef89a99d00cb7bcd229dafddbd77ebc7105e9deec6a543ce5f116efab30c11c5458161adff0109ce9baeb827aa79c57557a05875ff5ef190cb1f29bfe1f7ebbaff57a03eb860b65d09bde484383067578c5169ecbf68821999547ae243a8cca334e75fccf49569f77b3dcdbc2f2f24f6e5fa1b45d4927fcae39b7b572a675239fb2490597b88d1b1513bf37387d92785397ecb7ec76783ec470c88981d9b9b4275b7bbf7d116b754adba88b20896b26d0862f37daea170995ff77c9ff8a4f0ce9700a90d593f474394d019b99d668a494889cac99ace78d806ea311770934476bfc268a3dc4be40143576ad4f1dd4f9c8f239212f7b854f3ee129bb61cb4176bcd5def08ee0fb2613cd8e575cb8922ed249def861ca5b3a389636ec4728401493573902f8c610d6d6972b04d9a323ab39b80a8ee977e22ff63dc9eaed6e892c588317d098523825c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
