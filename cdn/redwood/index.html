<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"07d3a376f70d2a8b338a4f345e620c58450402e957430c8b90f881b1dd370bd606991ddf2645e6bcb65cbd8108538033822e6f62c81ab1de6196527f0f175f1a88f09bc0f1004c002b337d14516b12ebc954c1ef1d424bb53af9d6d10b91399dc7c550874e7bda399b5cc965d655600d08cc9c29e566e92d6db1ac65e641b898bab458662dc4dd328986843ca7f19c1846ae6e219504bc59af234c71778ef25c9c89b322b56b05aded3b7983c8a524be5c64b8d2cf136327fbbf6e6ec702dff74c25d6c05c2dcef3f16663aef5e175b24c968af7adf7ef70e147d6ead669f011e91638f4ad873495042e440d925e8ad5eeaa03a8f380701e0f8e688b76c1ae2f786b01c61ab7fd8bc570cf8c67dc0c020680c1fa8b4728ad1daba6bbd35e854413136ce7afa05261c2d3c3384fcae97618e366cc8685322c3261206a4bd5d14b62b12ce75ca4356644d8a0af4c7523620dc536ab72be0126e83ccd11d313293ec3271edb416f7e0d35058e003386e57943d54ac0e2faeeca0afe7a5708a1b756e4da308bc3bb4c1114df15d96d62b12ffc0dfe108f1aa3768bea775c8520962daf6e2a2fc46a6e0bff8f00660f114efa490105ab78d3af9ed7d43491d3f57d60e6063f0f4d8bd7c32d87e3c21139531913f5dbb2a2cc3d42e91a182473d5c3949b5361a4c8da24da19954814b39b1e617677e525c7b5a06eb61ff3aedf4861ac1e16c22ae08f2c6b931d6e2cf74874154075bc0501cdfe8aa0705cf0d912b5ab2e3b1809061f765fe77f9e8eeaa84fb96a3bb840d1a4dd299f0ac1655e12360d4dc545c320cd92e2462b5be8cda74b1852c195cb416dd55f7171d86111a0a1b73042c681768a6906b32822b468bba87c02fb77f3ab57bf262609c925c7008eee122bc63deebf597b1771388c8903d6c9dd1400d968fe2d394889dc693606c08edb1c5d5534a78fb1ea59cdd1ffd519ad15ccafdabd8553947e41b5ca669056e83488c0ea1b86fd888a9313bf9422ced4197b4003ce8b8ee9f3a4ad1bba5659796acef7d2e2c795e72d97c39695a1cbe5c32aa562dc7c3a3dded809b7e54e48204a02d1a987968c66e1541697663d5eb3a7324c98fe9b996471b84ca5be39d93b424d2a2c6da5db8591fddfe1669907e552d895989c7f8c1117f7f4c404cb7ff59d4f56d4efdccd3113b1aa9161076b3f473663f81338423f875cba9ee79ca8f258e0a76e03dbe240aa6f6e84c847e31c2ea6bdf32069f7ca8e591cb3deca88be052b02d1c90f9675049c7ad5bc32cbd6fa2d548fb7ecd0abf98c33975acb7913019d21e79aab8b0a3a013ec838a5798c247ebeca4a0e2845ee4ac6fd272ae5de3b0c97f751edc185f6d68ce6f74597a0b008e844d6c808da2328ff4bc706c610c1f4ee073cbbeb72d9b373d4818fb33b6dfe93ae50bceb4d6189aa1a76842487db3aac917cbe6d5a22c13c701b3c959a51e62e6fddae8384de7237ad90edea01a6e379e4cf422d5abc30af5966838461ff2bbb2287c0b4cca1fde901eeac4cca062d3909a1fe2f3c8268dbc909dbc5ce7101773af85f7633427688071891e2c678c32e52d77933622438e17e30b1e800d886f566a782f2f733228eb8c183791e5feb2b449663064d673907432cd8ac74bd94a1aeb88aa1e163b480e3923c22c5952670a2a64116a6c883d8d0e3883e747ca189ab4ff2c1c06069f235aa90fb87d99985bb47d7db1f991a705577b39cfb26799814f2470ad6f16e138f91a2a1ea142625dab18f5e88205210504964995649e5ee81338c1d218cf376708889963cd9d4a8e8c912274e07924c9e81ecc1c93ef85f5007392cac7c9bddcbfe27d9ec19c541f6813b860970f57df149faae943b434a226ead6407c848bd3999c53bb819d92762e9407b233125b11883971cd7be7fa157526ff27ccdb71e8009bf0480b44e4b0a4fd62c4ba879a68377cb74900c20f159f2eb58c5a8696fb434571d2b59411bb4a097ef35e3e01622c7c57307d0796b7d8ac6a7699122dc31a00840847ca77f554f9a103c924a1e1dc3a44f3b7fd09762858b8399ea139aa5d4457b59c402db5005e5084e78b00f0464b639c0b8c1d4468f41551957247eee9f1b2361a1d75bbe7f619eb7d075f41168617d26d859077b94002ace9af53fb32a63ab3481e40d06ee5a3d38bba15fecc7fd20b5d3b3a95f152415e8be1dd561b5bb1988378cca9b89db88528fe110490738f296bbf83a90e093f374dd7ab29f9d38a9bd0893f9d9321c87a11f0f73b1bab39b6ae8ef28acf730c980f777721b12fd3bb080c1c4e17a4348cfbc64c613e6e08ccb3c0d3f161075a3cf41fbb08d04abcea1be440268366b67556529cbd7727d880176b66a798394ba97a1ff66dc55616078edb13818b283ecaa285e4a76c0cbf606d79f4eb1460cdeda98e08a09d6e1c208d994fe074e724fbf5655b30f46674ececdfb3d5ab20fbad638ae7ad57f2f13d14bdf54b5c2bd251436b7b1e624a5819cfa227090eba73a379aa33217f14e55f9e80dc970745e835b66f9fc5a71ef9759892dbfc14d9cf5fa5c85c276bdc9826945bf86005cb4873208da8446577fb1f4f5c22b4ddc47a9f73614945e28933d99eba2c8108a5bb8793d7ec748c3e4dfb94cab34007fc572e26478efb884adba2b71ad337e8edbb02dba895eddc8a5a965d2363492d4275f5d4fca7aa70f64742c0b08fa46f77ad47349b6deac6d7000cb0ea20d45993d35b41690bba384ebd44a2d1eb338787fc5633bb92707eba2b36df2f3ce7e1ee41d9a11a7ae214c06a1369a563c758430b597814594327f4fa6c850888716931b8b6250c9c1dc539f2fd33fa07271b4c6eed404dd240256fdeb622491cdb55549619e9fb3a335f4079f3a98ef07d1581a1b2834c3eb4009c43b12a040001f56315feb58e310753601ecc46a15b1e68fa328f9287d1535000c7b3888909ed55fe9718e25c12a1d4b79383a40ee086f5486b702d71e4c86ec3c276cd697379675115831dfa726d06f6873860593e1db4deaf2d6c0da2f08cebe05db814bf0c8f3aa69cc396bcceae8e45675c62a65d054b8c6638bc771e003f030207ec29ee83737f1e9a4c93bac492069f2309d469723f84e9413ddfce235ae8e2b63e47c1c49b5a113cd8c3aff2b16a7e1b901c289e75a54f985334e90d1fa7140b2b49524101295289a5960a23badb1542c88178038b9a3b197f6afee4a04e014c45bdc2cbd43c5ec562756832c47f3f687e54e1587330af324328e6b9a625e737ee9fe4a807f00843de942d9687ba5f40f9fdf8948a6c9bfc2b254658a1ebf3ad2d70eb55037c59303fae403d1e8993dd303215fabf7c73b32fa07d53853da3098152d30e4e305bbabcadf13fa7e30205b89762cdedc525f863c494539e60031a9ca6ce3cda773e81775ee87cba2b7759eb0688dcc04bac1c0e8a2fa911b09ee966c3674bee0fa77258ad66c0248513f0201255fa161d44b690955f7a76f90dd3b2ef9de8b874ab8fde9001823d150c5888c3841f843dab435d0ded18b55c315fcab2b53b8e45372233a2956a983ce44ab523450b01f6bdbed3d1667d8d140066439a9fe871b45755524805d56026fda15611692d2cb48cdb4d6f4eb4dd3a28155c70973c00811eac423d824c7e51b922eeeaec0c25a04eb7640bdf9461b5edac0a08277080f0096930848b67e3b16df513cd05f78fe34160205252f7fc7151051c7de34d0788f4e962acd1ddef2fb015966d742597638fc84781318c90446b1e26d8fdfb1b6a6a423512d18d46e942cbb8c88bcfb13d96f0626f8d71e56627707fc16f3d787a09542b308b6b268dd911a5f0c7a6156b994565b77de7ea31044ec947086011cbee6e0b770c4d9434fc0c9315a85a9766f6d96801084ecf887bd29cb24fc7699452d58d998dc61c7abccf6640da2d31a8e571eeb9320c66f1d6d51aa0282bbbbae4062b409c630bf157eb650057945e24c8ee2ba565d6750a4eae5176abeccbeaa35c829673f77f79ccb7146ebde181cb997ba0d44f493a44163e0d02573c9ff2ace164e09e16e0705a20dd4c9eba0bb05506f930ea5f9c8540048ebaecd8e1e1ce7b013ee9bf684bc71bcbb803ab68eeddc0ce72d34413fc5ac66895d417adef9a7fd60a945beebe518c82c1494939fa8b5685bc2c746e0d1db0f512d8310ffcdaa885fd45820e2fc099701cfc514347604601909a7c5d8065905c146a6c5523c87aaa571d50c071c6a734d8e81a97511442040f49c4bcd17c97fe73bd27f1f47920d2a1131599281cc13c59e6520c4a39461d0085835867d06ff854c83bdcd0dc45826449b062229f255f027b9091478f90ba30ca9c0916e316c68046854a46796aa2a3777710ea85f4ceb38f3b533c8fdc11085709f53481c64fb8baf94c30f8eb65c028fba35172273b7a184005efbaf5ddc845d8a61ef48bcd5fdce70971c0685eba86564837d1afd01b514a79a6a96c03fd4bcf88f3a684ae79b87da4dab8c9171fea5bc37d67ccecd2eacaac33cac9aa4040ee7ebd0de82ba5a959575ed9a2fde462bee5c3949cd039dcc29a7dcbf4262075401e0a6ff3753e917000b8cda32bd5bf6f8b6b6adbefc31eb200612821216fa94c73f469f27c82a5c9b4a1db9e6cbf407cca33973e657c51da096fd7a297fea7e92c5c6da13199929e8960922353cbb4378d183afa4a20bff8e759a3587201bc4759d232af79031422b496e02d2b3002b7cd6cedab820a7315d5bee23beb0cc9ce12a88e74a2cc197fe2d065d048ad241204ea3846267309a61b319765dd7375edf79e81d6ae716f6f1e5d7a35ac79015ba9fd6c4c41c5bfc3e2f21087108ebcc292a6db84472f65b1235b519907f82d5382c3517caa06331cf4b74e7cac8954fcdcf47655135e5903ac4f521698a0537f3cd8ec5da0691a253012beac90a42a1994d0e6a896dc4a1809f7b83912e1c39ee02015afdfc545e9269e1eafe2c73444390f19adc76013ca6a73718307d5cd9dd5965cfb94d1ba774bb7c5ae98250aace4ed97810a7f84fd5b0fa2c6a47fe3571646c5e232adf4f5dd94598136afa690d3e372aba562bb7332ffabc6a25a594ae8747ff56483cb7b4279a5ebc8c4a69d857f8ddd2e0b5bddc9cc4c51152e01907439e77928da751d3b9660b1e45b59d040393fb27f4b881003796988f56ba50f33a435e9a0890ec27907ebd9e6c465ad23cd079bd1e0e7d6f5d901dbb9a527f617cfef3a7ab5d6e51a8c6218801b2f221d9d45269db69e246e2a20885ae192907df09a347ce05c43f586771ff1d5f1c06ebfbc6320b1035100033311612591155ead1cb4436d521fdceb736a16b9f7fd25d29b2e628cc1d8a2cc00b6b04606b3cb1a5ea69b39a4f120fa38b896cbbb379532adbfe142c93ce11e285ec0d2e66e731975dec412d7bdce0f3d816b08c60902f055aa89c065139141e75e57571f26769ce6f1a75e5f89bdff53f51c1b9743aa95e65e02c0d63d5f8e4eeb724623557169ec22a93f0f68922ce2fd979359747cce2998e443b3d2df0ee38002e898a4aebcf5de479d4208c835706a9f901872aeb696e1562bac3226f5c836539270f0840aa9ac2f8ade5faa088ccd16b71d567af497418d68474beedf5e6f689b5b4a0f1c0a65e86a2e267c760246aa10f3e63b8c99bc010ddbaa612513d38cb183d189c1b1cc0cb1da7eeda70958a93067fa3de92823113d54ba7653ff55382de17590037ca3307a767aae9cdfc7bd24182d678852a4ff6804aa713db462cf2215679b4b02105cedd2e7c0832fc9f7d2f139006f3e3c94b1f346a35690245b2b3075fc0976d3a27ded654106d28336c4fcd3a0b85e8c53e14cac8944ae84470e1002625ed4ed6b390b9b14e066fa92a74a18f8b4831e565a85da004662dcbd58b9294eb296ca2d760c88197105c5e4f61dcc1748b97125b79416fc40179c9c1d5750ab6bae38f1ff5eeafcd6fecb9e8de66009738980199beeac18199419cb41cea2d80e619449c30c95ea0963c17d2c1fb68cd39cd7e286f9162ce48c31d63210314770d9a9e002d7760e9712d6290d2afa803a3b91db926443b519f4105be2a03298b65ac0c6b232d08856374311b9427618b35815a34ce61b78b69e0cf73475d2688a32445241c9171d67bdeb116b1fd4fb6101b38b72c1c9dd530cafd40842dcf6e60f7558cd5d3d7703f572d9f691a446fbd7001d9fd85849ffab514c7aab7a833e04c712fbf749a20420512de90b797c2542ba30cad6dbc9b30cbc5da363a1f016e97d225931701e37569e7799b97cadb95420050d2ca9319c1b7c928758acf29852f00eeed460257488d2c81832eb07c98ba8a1ad42501de6b6e8acdf116de33cd6e82b8f04d846d9d4fd0080324a8f2d97302b3a4423813c572a359e25a6b15c0239f4b2c51312bdbb6aae2af88f2229717596627f7ece846d5ca3f18f38c9c2dc36b5f97cd46c360025b1a5f1935037c5ee55a673580d83cb521e3ef077e9d7435761e6a7e5341fff071d6a6f35285d333212dacccdef826537fc838c574c44eb379d7eba319a16108fdb22ae5f53e4b3ad75ad77ffda7e08d247450b816373372c161ac8e52e146cc4383c514bd198f88cc413ce6f8b7e48a7491e2c6a276fafc22958c9fb2b563cb226c99b0227fb9cadec5a05f42a4fb1e734dedf2b200aeb48c242ddc7db0ec824c89ca333f4b8de1e8062c311b1f7de3230f0aea18550c2a597371b5d6adc0016d7705f5eac28b903bb91064f1076c6b9d672f618a2877ea381561e61fc63a4552e8f164aa6d6760a317bb36e46284ed5297025bdb385b3af26d6d9d9d1116213eae3270802914e71e305792d9b6ef71bbe51ac02407c86e5eb363b34fb792d688fa6c266d94fa806537b81008743f13a3f238510e2b24b42c1c5d09c1654e435f98b136eaef83a636751b2941751e357c650768af92fb3de5da08a24afcb9d4b383aca61211e1104a678576c1eaed8ffa457f00334a6222b5796cbcb18987eee2e313e968bd8676da90896f023ec3c29511bfa6d4af191011cdbc291a9935f72cece23f651ae10fad1e991294e2af98a820c3a239bc66a728a699c3610c61420d7a572b8c347ffccee4a71b0abd22068cf5ff9ae12116f6cc1be74c3740daab7b74f3385981cb9fa5cc667debd2e0f13b822971d85c045eb0112143d8fb238c06764248da7900a508ea8bb968fda91385aa9541ae36e25da9a1d13399a17f0eca6271a0d2fa3f0b77633328792891e9c9f873828ef5539eb550892a5ff8ef80fed7b43374b5b6ea7b02fa1759373e7efe6e7baebd2cb786d659020e5e9370e4e4805efb100830183a8b10e41135c9c0af12f173e32e4aa21b3ef807941dd0be9bd88019e437782b9fbfc485b04a26bd4aa9dd6cad240a4610f2279ff2a6d3cc9636922ebaa08fa616e5066f53c4832eb43afa2f14cee5a8ee069acbc2e157416b28d3b5ddfa718375546319d221c317604707e64e1928d1141938c96c7e77f92760a4d8ce2a6b2dbe9d72a5b6ac2ae6fa84d0d8f4d83e55cdc068dfbb0e893eb1fa0ec3b66908de1f8d85bd37914b9fb6fac289ae29ceb5d05451b67a438a66da1602539945d34e345e15d94cf8eea81b5c0515cefc4c26e26330e6b2f1752ea89acbc85e384ac93f908503210f24a0aaebac7e1bfbc778ed267a51ad2fd87a6771d7ad84c6102af440270ee808d72eead1d82418fad4ebb38f8f93a92a1f1bfbe628a45d9df1399b3eaf1b3f7094b132aa0add6da53f1892949d4f00b3d015f780c6ababb665d1ff6cfeb8838cf804f8792573d226d23393722b2edb198d1221fdf142e02a5d23b792fba14302a64f8ee2663b9de14e47c055ca4bfab6e9b84196b11527fdf99f032e131739d604ad1bd855734095f79be0d0bacca41e27d1774183850520d458e89eff01874f1e17372630bec559e6b054dce50857e060e97b5549126d07a5b584530c9b39db92a2c21e2365e98f49e286bb68408797480a08ceebae4f0415d6a0a62cb5dfbeb97bec0e2e09251f17fd443597bf70c6487e2337d5bd0dde559400ab67fc4587d939b6ffb073eff5fbcd16dcea1bf67e23164e5eb44d7d5458ff2360dd7f05768ea76d260f857d581e66b4d873846938d4e4686a7af61c7b559b08513938cafae09a4f0e0fb9b82c9591b846a7b595f71f1fc22d2a636d3efdd9d82d6051e5b511ea1da46586345fdfab1aceb1e4019f261dd6ff53866cc8c65a5a8fd407fcad93d997c9bf8b4e25fc2f5f7f031ff0f1e50417b85eb53a6c33bf5e099715f0a2fc6ff887c403966c47681b05a5b020654c18a8bc19733b9b2c6a74215847a020bba0bd57a40f6a0c90411a262bf167210fcbaa6725943550e3cee33a3aab86678ec5327a92740a50d58c93e9ea8b90dd791a9ad36f619a551f14619bae313fc5236eb2418454d0a9242bd90ae0bece9323cd435e81d506bf1308346ab0dcfe6107eab74882ae1ae41218c169ff9654242ff8babe7c13da5ce51f11a9858606c1684dbc98694d6a946156c58fc730d403ae1c11a64f3d41aaf742eeefe2d2ff7d2b029e920e2be9adf6bdadd7910e732d0b396bd697b96727206c0ed9358d40ca7e66ccab0cacf95ef06add23c3c18a2c2d70ba8cca1c65b75be1a03445442d2a74c27ff25eb538d351a0d5e0a0ab29d136be20f83d532338f521ab4d452156e66d43e0e809854655ef28ab5009263496f71fe6cf00ffddf8b8c195397552101b1f73612ddf975ee5d9940f82cef5fa50f444c76a11f2b9e0475bd3ee4d9fea91eb71c04df465c283d1969706660856b5c6cbcf56c2ebe1dc6cd11311fcf2bd9971ee2b7befb1facfd0944c9804559675371bd42a7e7e8f9436d5c26dabefdbdc35eef5b45d982b82de6d6304d2ec752e78882dda3878cd48b8c36701001af703c18ae840b7497a4d97e21fb663dc88c6006d8ee026fb8082be9210db2bca3f8d09ffc83a3767ecda91a3de00cd5a716db3fdf4cd42e85490a2fff51edd1b0cb30e0f5f54344c9bd52ca09cdf835845c5085ab0fc65e9c7599ece0fd513b6f20c814ed3acbf787010f4b5af51e3d055d4e6ac2bdf57eb921d28c7efd69608b6413abacb8ae611b3a23448517ad005141ed6419870a99dd18223db399324b7a961f3d44811a693a033799719d2c6c94162da876ff6552c9c9862f876c428381e3a1f2fe310b0a101d30c5551cdef6d8ac269a19dd25e56549653a7708b8195dec8c8485c07492af318215d98a9af419ea1305777016ebe1025e25441e0a113055ea25b01317bde9a897c60c43e444040109a65c1494edbf3f5c449f960b48152770ac6b4ca5cd4502f63355c245cd98b40aff31b0f11556c0453b4376f4dd096f43d11dc3cd4cfb572f1eea5144b34bc02c7fa11ff9fa4a1e46c705bf1759748d6d7d5ea28e28c329cd1bcf50ecfad45ab4beed44320ad34e5e93a6c3f506443e02076be5c8c84a4acd791df1956f9f560af387a9037b91f44e43d872f78c837e4ef9454b73ea152bd3526076efb468a39f0f0c191455193a0143058af5d2d498d3b1308a7c4e74acfd868a63d59cac01449b63be21ad06f6d5cb8cac166d174ec9013e0054ed33dcb8a8086fccdb2f6264e41a677ebaf95c4c52ec929e27a9838ff6787bd9cfd74f61dd022d731b2ab8812a79f48499dc5bb1198fb338bf8facb8bd901d316ac028d395b16d029cd12230643c103a5225b09a17ada45bddc4af82a51ddbbdeebd4ff12a7314de79f7b35052f488831ab2243e8d2ea71f673b5b3f399141ed5a29dcd67efed6c93c0fc8e004549a30dfee8d15c6e74a9dc00fdf048a0b49f88e1b6213a346976660645af73c27673e43581d51deeed5dacf4fd3bbd13df5ee8395adfd177f678328c191bad3ea94c87922faeb6cfe92f5578cb6fc84ac62f3be436c1fcb4c9d5584ccc3623ba7ce0cbde885f96562eeefac54b287f23dd55c9f0755bd256bfa0c8b783298d87606c645ea8c34e42cefeb376a38fabbae2b1e101fd516af5330ca1c7aafb3810c8cb70a8affeeb77e398a3500f086fd90592d0f94b81547de0f3fc9803b5506a04d2ab9e3380636e411154250be17ef34d162bca2cf21e700632ea4b00b16e9aaec4d93659f2260034ea0f632eab619b8b3914bf8609ee0e4016370a72bdd6a675a2c6704c6b5221181213e5ac633e387dbd6986b4d92ed2e6cf8b8a05fed5bac463ba49760ceccec940070c80a2f4910cf95aa60aecd7815667ffe3fc25bff0e36779b67e6037dd8de920edd3a3355a3969a3ecd0a1b5f00a72d4f2fd75b530fcd60dfca57849455f5d6e77f3b1c6343d87ffc8b877d073a2ff65c41f6ff58bfeac03d948df03eab080ead0f9af419fe86ad2d48b2a1fb43b8e2b3a04ac9c74b4e5db7b7920c0f3a64e1e553ea8e46eb0b4591957eac8eff7b455940813fc7dc3b30766b9c238b227a34a12fd8e9308c0457ac63251845a1dab9f6117b59178eb88c77d001360f733a429587d37c7cb4581d0aa1e362ae23ca61be4a4be326facbcc0fa43f3efacd0c7f7bd4963b2b70844ad18d8fccb781d6f5fd4767e7378fc4c8d011ab7337e0ff51fb514fd7be58e5df81972a5f5957bee757a9cd47bec109b8d7ce6ba58e4907d3f7250fc39cea0f73a385fb7c42d4731c3d5f938f1cbc6c8b0f1535f12c255b162fe466593a1479555c384e457b8f103897819990f3ab6a55f0d627a9f957351d9ffca20a9b536263740155bf2bbcd618894e47339955bb56cfd6e420524191f7b6802a8d78ce154885d33627df6e403d14366f90f1efe5f00341ddfebd57c6314e7978fcc2574ad295fc782c8dab6a48c86727c011f6268e62c621adfb85daee55b8e122511d8cca6a1814f705182a9f99f19eeb621bfe4520cab3e1903ca2b06f54c48ca820e5189354980fab986685ab9af044b133a10f18d8f6c546bcfcc6fae1cb931e2bf4b5de559e98bd4b47e8dae43338706ec2699f5f7dbafffe4717fcb9ccc4f3ae29253fd92f604c71810aa6ae99d5305b9085de5d24866e8eef91a1fcca856c84168bb395584178dcdc3666a405bebba549ca1fd4e1797f2ea7bd2752f9ca05739bf68a2be5f9a020034fa4d97f38aaccd07f98bedc432baf01542ecf129185ae494d4f510735eb0171c63752a40b3c1af7deec35aec2c1aa3b97d55d27f62c18ae9e7f082abbb8bdd3f3bf7f581e9487a7513c9d9a9ecea9159038f57c4ba308f7b6e65f4cc34ea27cf6fd922cb47917a6b3ca7aca3befdc88619c6eb47b4888b8c40a2c95c6720f79802a7fddd6f5de19436dcce6622ff0466990205d51096f933c61ae96b033a966ee2189553539d4f7d5b32a4fc0968847865f161ad0f201b50e57b5ffb9c19222ffc6ccb0dccb673d9b2d53f78ddc249a6bc32df8ad235514f75ae680573e4cf222a56ee3747672fad19dc8e217904468b167cd2803492a650febe00deebae33bf328131f6691353d8bc55de9021c3d9bf43aa831930a934eeb023734ab4baf9159f67e57448bffb4521f32f0dcd31001e2978bb1d8908a284bb2e82f595d43a4a5b86540cdfa6d5fc05a87cdbd85047e8f1962a686d698395a4de6dfb8e010bdd52c130bb847ec4b3437e4fd7be1c4bb26f4c037627a780d7a4106e5c187647c3582f774f5a1ad1be5e19cfea7dd0aed2f5fb41d0c10814fabaae7c98cdb8fd9bad3ac0dfc1de43a2e2919f99cf40d99cde3aa922273715b51d266b0fb8045b1930b3e43d96744cf393f4e4eabc0b0a1b25ceaa44f868563b37691274af3938dc9e215dbdcf7a07aa8845755795a55ae208428072f9c6bf5f80addc02292d832a8f4f42c8fcedf3236cd04e6ab033ebbd1b2cbaf3d560f33d51dcd16cdaa4a49429653ca6ca869aabbc8cac99b10ecc69e66df503580ded3d6fe92d1599df7e33429a9eb1edd767afe827f38037d2aa7c63490c1021b95c25adfd7c0d4e365ca62c7585b98a8bbb3978742dc95edc1191a8c1764a7415bf0e2aa4077685b9ccf8bf17774fbeafe74d60623b19b4ed1449df479ec0898c6bae18ca23687eaebcdaf475abe84971d6d2abada7c256cd150f06bbd538913ea87069b636c8253a5b61c6e3b622d3245185e13cc70a48ab9dd682ad144852058eab59d17a635a852b8bea75645dbb2ccd0e4a11cfeb7d4ceab92b81da3638f598a4240b95110367287e281957c4285b7917b0624fa0b1e7bb8786a5a4f51d0171d4fd2f85c5e7663a3b7a96b62d9beaa20a83b4682ddc034e3c61f5b6346bb3a90b3212d8e09b208d0e40ae13010c2d3b356362558442bbe1d29127a3ce9bb006db9410576b1c16479b4f9362ac716d1cc445f3eb45914347a96129c3acda7ee874cf35634c0fe608448b8c1f67ab91abcdf5a04b2cd83efca22466c1e9d9975538e86ad69b0b2bbaeea7fd2a46a22cae80266a564f537b4522f93ca6feabc9ea4981e85083faf806dceb6534c7675d1e9e1746028fee98cececeb953375613045b4586972718eec9da6654bab8aebdab906f839df0fc4c5bc5d8543031c050b344594336f948bd0d6a719b1e55f502608b37378e5cef497404dbdd93986f463ddf65aff572c7f1063d5c27ffbd1647d227925700cb229064fde7ac11163407dab0d3bf81cfc554a7dcb98d29fd97e02ed673970998b7e010fb19b78b452b6e3433114d3088a05e0aea226127fcb4f4306a49e7bc69dec2a620f58b685e6cb7f0694449031d1a65f85652862d1b9ca0530df5af5cf897c57fba2671058f542000b42d24fda2c7225df5621b310922d21311c1f92d54bade5e48319d8519da1ac959899d78f720fc8f41a8d7bad41c2bc8160445cf18ec17f91a7587752dd2649a74a2b0059b4a7b7ef9194b1db5ead407c1a9fe67ab02a06330c2bfe7e877c4c4d23510b0c05eb5a97f2b8753fb10de0328cfcc6096ee37a70688584ba6b3ed8a3027125f78d60acda256d9acc82a520104e4a6e5347e388c43ace919e5f40a1ac97bd6e1f021dbf429a99789842a04d0a85fa906c08a0fe044f55afbf2eb950f474002903ca73c37cb47399f595457a2a5d7fd60db4a6378ae7a7f5ddb2e7d7fce662dd250c5a4e6be2fc06aa15303f1ebd21b8fa10c209cce5a5404490422ce4f991a35f69c4c20545681b6871e65ff3171c5024c2d4252156a0287129645cbdf0c71382689ff2f85f2f187dcce749c54ad2e4bd7bd21eb2f0d6024ade6fc822626f3e6bac163e9b2957bb7c9e137730e08f1cbb5cc6f89136690b2594e71905c1755910fa2bbcf5817de18a5917a0015622b6d65fd7f68bb418aeb2237652266ef0910e3ee0d9ab5f1bf799c90c2f0ad507b8e26898d0fa48999e86cca96d5718f94eed8cba9a22c46a1cab1dedda662d1598cc6d2dc0bb9c033cfb5583743f9827e03cee45f540546cbbe51528e9f6f25dc1559b4b8f59017f1ce0b79dba15fbcdfef56f599f3d386d385b53146c7293d0f959fd98d028fcd19484a1aa050fb6d54d8106b6f07c90fb5a796c0b2a1bff6935d0fab5d02212d3e7ca0fcb1459b63732de1b0a86e57d3d4ff11188a85913658c4f88bb90443f6b78cb4870428f3f069e0123b6574e41e4705e20f28d885390d4c94fcb446617da9f90fbcab5e70e185787c53ce0a1e5b891497203290aedcf483abee2fc020df06c466a1480173e9b7d5f91e0ab4c0f024b8ae47b48d77bb092c9d5bb1d507d57d6d3e43dac717da2f3f1a1b17a25a115d48d9e2dbff3b7d48d3fbeb22e8f35759940a8ac42a3a7519164f20b39d7986fc69710fe4af9a29968512751d57f84f826e13da5f9c4d0a5392523893c8a54ffdbf2f4a8646e3fe098bc76de72c870870958e01b78b30e33405acd278e9ff056cdde66265549c5919f201f3aa2778019b4c006e1b31b4fde350437e447cdd08d2cdf866947e6030134ee876d9fed529a549292601a93c5584f3ece5408cc00dabb6d04124ea884d9090551ebb334c7abec50ea1133408fc1dd423106c928c0302ceac302607715865e10618542c99fa0de955b145169c920b2e3d9898b0645432d0d0a889a244692ff850a54193bc320a2c04abef51076a96dd03b90aaa4983ec9fd25322d6af91762d35a92311060b1a5df697f017ffc31001d59ffa0781476f8c07ca897fde0345889e5d377e6803c6331ee6ec0b42569e875c2d1b8785f767ac093e8efdedc419d8edc5b5d5b5423aef12848aded9a0061b5f847ea8d89c79519f65adbebde3196020b5d05f7a742a05a1cfeab25a6c404ea6cb002612590231bf579b8966bc68ccdd45d81f1415447c1bcc0bdd4f108fcdeb048ad3f834c0799cd21ef30fb7dd7ccb2758241c828780e48838dcd98ee68876a3b0fd2725c2556600fa0c1e4e71bd2f3b059bcafa443fcc719cd7d43e2403088ac028500c680de11e90d6fc52e663b85d5439e9038ad8287d68fda837f205885e957f17e13f608d0342a4aae120d107cbde8761fd63eece4832094100734aef74bf14da83fe03a8559afa758048743fb15bbae34c43fed81d5d31975ee37fe5e5c11a30a04a90a006b32f40ce22c95b0031fb48cbcdfb0f43c83ccb8204c0741b202757536212d8e45a93e922300f3f782364733a5a4e93313a491001036bb813158c3d8017c1d67fe03b5de280ee4fd3414ca6df5d7b9807a0899f60715dc49d117a1b67f78b25c90577deca8197de5b5d5ad6fb26c36da6fd1727c3cbc41dab764b8981315d47b2a6c3ab0e7cbfdcb46002f669c1460427c4943f9451bc9919f904d79b52e42b04d6bffa3ec9d6155a72b977995f58395c40a64e137297c2415ecdd732ff6c7f6ff7dc97b4c24e32c00d8190e9ac4d34575c8c9ccbb8198870a86b4ef46d72f1a687119e120a02702458069c1fa403ce7b6ef6c12a60184cc4241a1c90df7436308a3ccc61b2ea34fe1111259e30671b81d6f1080a425582619b371dbad2d6950ede297236b5dac076d87dabaf5064713249fda5020b1179d412641c8d172b34321a519a43b42721c498695e03032cb388b2db7144cec0cd45b6fdcc7afa44840a08461eade539fa80afc70bc41a3f66a8edb4b585a9ef5b6e870cafde494699bd4155df5e24c4bb4218ed3be7dc66219927d9b0122967fc781c65ae78efec70614344860714536a7a92428a54e4a0a4b8f4c22c5e8770994b3bfdaebdd70eb0284283a5092aedeecc5d0284ec32d9bad4fe87e11e4de7d0bb8fcca36698ff8c2731c500bfa8c3e660a447b38bcc814d176db4f2ba828c629216b6114b4567a46298a5681eea1bd86a28f483f7052ea8ab41e0b557cc0bef1fe5927691fca8c3ff60c7e7889b119cdcf7ecacb3b28b9013545f196d15911dec4b503599035f962f121bed6ec5ed83029d875acf8ea3e01914a7fd6e5f9e164448b509e786b58bd576ebcf0949a80991d1fea5c0b137b731ec057bd89061ff579e29fc4217dc287a5748ab10e2965f95ccffcaf2ab2c27382dfa9c03aa96f848d0ecde5e101ffbee1fd98709856069c5b710c5f7f9384e401417a512e09e9a8089438ab3b6ca349ecaf7c0bc51dfa49cdd07523fd301bcf390a506c8ed333c8d8ed1a932c03e98b2149182edfd83db576102b3109ea7cfc19f2b1c3d301e627bf2b6dac41600f3dbe27182c3296b246b7f7092447e5f2b3454a1622e08b49fe21760787265edc4c5bd68415534704d7828647dc75fc920e6d370586ae3e7ac1a8dbcdff22521cd1c8b876476be41c36e215158eef11b44caf871f3078b133e15d724abcfcd403f634f61ac95003784c8f54b63b7b9144b8e024778aa0135420695ba8604d3f53d7d9ac195026243b1c8f7e2a5083919d2de2ed9d76b4f2f2ff3b92fa31a76f8d229efadc29132a619be33e8ee2cd4c011f67066e18acf661ef313cf284c600f408416504a06b3b4593efb5e126ebc8f287ef1efbf9566e3aa78d951c5170cacb352132171b3c7ac249cd6e5f67075cee6715dd979c7d8566cf12f1516748d6f395997448765651c8d0b47a4103d4f76fc654da9a832e1f2aee145eaef0230d6b7ce2954e0979eb33630473ef2d919bb9c1444324b8b11ef0a269152559fc2ba79d00ad633bec09c8dc803cc7cd4967718f2e033d2b3baeb30e738b0b3bd922d01b9233adce79a556c0dbb15f4f6e2681be7a801122d1a0a618c5dfadcd908244a055d031bdfd85e9ee094be950ec2bb16138f5ba13d78fe11018f64b78360929808d8718f15c3c85d62c77d76ae67945e47358511e0c633a49d0db409d0a69583c7acb68d03fb974d1516fcd67f4e6773c06f785e5fc5accfed0488a451a9931f3633aa66be0bea5db42f324cb26640daa0a004b147adea85f9d1ad376dd149562b9a56ab175cb43989d868a1d29652bcd38908662071427d733f74bb4d5d3e0d57fa408a99af6bcf101098102eeb495ca9b5072e7bc96d79569bd151ece7dd87f92485b05ea495e68c2890fbea7e002aa3695c8248dd8d82cfcd9df06609fae19f45945a21c2adfd3181eea24c8356032282051c529d60716e3001370c4f3c77f377358a5f28e876de6c13d9dd9681363b8c434f44267eb7bf9e39f77001f3c21323d409707e9a238d55237a1a025c70e4cb5d07e983dd2dce99ab3ae1b0a67bcab4119d7a64997d9b025a899517fde2b641a19baf5cc71a116a22437033f12c210f68fe698e7aaf737b1c7289fc09ccaa67582a5255664270ff9f6999e34ba7910de13fc09f80bc37e9c8eae59fefaa86f0245ec59a88dacf667fd0c41aeb25c2603ddb661a769fa3bbcc39089f11ad7ac7a4812fea66561d3419eb4544de62c5c72a2e8d34abec60089e53044c2ad31fb2aa5d8e716b566315987d305d6ac9d385ea51b6802c04ab9cfa540a36f4b0d1ccc15c45229fe74c62e1135c6f319f47ef0941eeb629c265d7181e29fb25a0df90923691a352de767f8c152866929928ddcdcf8f75adcd3f1560f285c591e88ce311ed3c0b222f7803613c7e726003e458b3e9bafe9c164b72e3485aa583b30b447ab98e4330e47b5d553a0151326d6aa01ecbdf5e458e39c86e67e8c50af8b6511624fad622516d643dcdbf5b26324ee968c65a5c2ca223a4e9cdd021c7228b7d95db1e1cbf86c7ff645103017597d2bfa1ccf94edbe9d2a3c3698ec2c6f416757f1e70bdd42cd6a2f64bec2de86f64d3e7495f6494f8e4d27856f794a782f09eb1d6f25ab30b37a46b5437c858b7273b0283611d94a150889d9d7e134747f3875fc8f48713619a039ff0eda5a29abe89fc2db4f1fa66712305eb01d733b810dd46dbe4cb1b5dce1dd445ae312406f023214b69604e73600b599db522ddab6732004f444a9f785a3bcc99b1e6a7a3f60b91aafb43545f94eb5b51cde0081fd034fb99144cb9a251b0c93e418c24122e79a1299463cad5cd460bd64662844c2198cd86d798d0643aee9b50001ad7c041df9eda09b1eb4de029aab2d17615398ee54ac2ef89305c3463eb5e3af7e90d3f5e0806929a317b69f3cace91bf9697a5e2bf44e4fb77e84b0885a84ab9a3e4b3b406e49f826b408778faef8bd3d36b0c429f2a7828c8e2c7f565f49cbed7222149953f41bd665b102363405847214f283251772ec3222b4bf50718da8cac4101fb10311e38bdff9ca4774d35567010937154f34087fc00b9ace1ed1a79f87cbcb24c9dc23706541e0c94a4c5e26a6a3c978750ae5719926749c0a5570510400147893bfb5de10fdc58cf626bff19d5a7884bfb45719d2957e6e103392b0c32e031d76bb1b83aac4ef7f229702971a62acd31ddc6e4e7bd2b04146640bbfb84c230c9f1dfb8b5b34248878bb5e1121aa9765219ed01614e0f974c05b6a9409f81d394fe3460049308de7a6b8a833c3c8b5f88a6a3abfbc9145191df1b84b93ac69b50f65bce0b2d2679018cda3b7c957b85c5cef4178d636a2f70da9d70f4abcd9ec30e3b7f848ed689348158a36a0de19a9710eb5a086c447c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
