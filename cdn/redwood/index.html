<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb3f4ec0418bd2cf2accebc750fcd19d7ef55423bf64ca2a36c8d315702937345cce05b545eabf21c2845e0c18f20fa9e3c3e41283ec26334d846c4f9b9177e0000d44f767c47cbfbbd6d1fab995982c058114ac02245ebb8cb2e000a97bb2a515576555dffb63261585d40c23d27bbeed6e130d4a5c3f867648736bbdfd5fb789f50190745ca263449846f31218e3f29282ea8fc13a9ddc51f23aba4f7654ea5e0735cc536d981ee3ffc7bbcb37da50f988a93d4bfbb9ee23aa420b201d931216fadb706f236c343875e3a560ad7655e4c2ef90710c372428302ab7a2fb3df86a5be26116d976e60ffa0f78dd8653654a0df043d30856d4e23a528beeba14abc1234f7ce0a7ff7a6faa5ac78fad199da4a61a7c5e3cd9b3de0d1e06530cc3fe734b919d72e435acdf98ae28965454ef8b378d79e4a9a734afafec368b1c8c89fac8f1567ccf8408108351ffdd94070e18e7efad803b44d0c4d4198c9b9cf4a8acf10b2608eba7809016284c253d42df43ae370593a7b9948892c29581d432d123cc8bb3c8e172876882364b76740da15c722acc52c655578cd17a8f6e5d3df87c0bcd872e00e3545400ce8175228a7d4011f6c208bf5359e8ea781dd6acb7efde0a4ee01c480be1dab41cb6b2e006c4f13d9f6a4e46fc61713851aa3076f80132249ff3b5d560f2313424dfde842b0b6bddb1d98d5633d0cf8db21647b9dc0ff4d17716cb8f51804595faf8ee929baa8e30f1fe8a02605ac58cb7988bfcd2eecae4a2d0e0fd29674e2926735fc37228c70ddc1263fe68f97911e85b498409f58bd825d33bfec33b923a42a5d18d7549c8b4bfb7f0ab620c643a3fd43a959692733727ffba1e551ac5481c98c831224c4d631aebdd3ac0742744f6f8d1c50c819ac8d69b10919b40a17953a1628d3005475ebbc4e03eeea748b966b537707f5216a266f4d3597e26791b2c09d678aaee21c50f56232be877579fe0e35008cd069fdafdc2a8c565a7c46481f4acde27dd2f2c05f7d4d0d96b7201319b8aacdbc773cd025f91f3bde08411a8d1362f325561b7c07f15f2eb2f14065afb65a3836ae2ac6c481de837cc3bed154b73336a1973a173d0364d3a59767008afcf094df9c9c3c6e507ec774ad9064774b5adc2658b306b81742151612a2869de4b6b572ef5c8ce9a72b324539a305d35470e05e3203a123904b1ad6057f1e41c8aec081f99a27e65e92a96abab340f855209188ae3e4c5b1e76364079c0c1da777e1bbccc954d59e5ca8cdd9b087c1da7c00a198f3b5511940a255674bef8864d7df21545af51b7586c6a90b9b7944e9d6b5782bca7e51311b85ba57eea3d1bd93303af8ef8d64dd95d0a5ee3f5067807a088927b62f4b9d10e57a99fbf6f2cdf4cf1ed2553d28d7e149f360d766970e7344f9f94f4180194abe9310dd2b1df0e93999b80dc317d122a442193b45eaa23f9b65c1c7799e9701a56a5dd346dfd3424dfa3e8e91adabdca6b10f7db659b96181d5d60fff2b6fd8bdf95bd0cf8b947e88f8f8069d35fd43381fea6d18e3a71a442a44837f1e57a927be7325394d8705af4723b569a21330a8ce8366b7f0fdcffa17cd835a5a5d5dd1bb020ce939cd5e9fd3fa6d784ffbb32c8f01c7e38ed445a387f0e9063a68499a2358fe2f7cca3953d0db33260220f9712cd7d24a90c53c336fd6abf649e111ef66a31b19f224219a8f82f4218853a41ad08be709a1d1d7f599239799ebef8f3c4cfe3d4be9d0188293bac5a255e7adf9c63b0e8f1c7b87214c4d88cf1fc98d3e8c592a9ca812b965411d7730ada13979993c8aaf1aa12c47d581eb28b34295d5dddac0c06155f9d434bef4043cac6996b1d0d2970990a6945dcdb9ae2c1e5626f6761f09bc6ce58c70b4ca755678396012e4eba74706124f37852917e1982033b66861859449b90b07b216e8c4fe67de2bae7f89acd7f41e4630418b9f8468d19955239738586eeed2c1f6dc7d69ccd0505c85df4cffceccf2f5607c0a1279526d4f2084cc04ccf104ea6d848e1161ba89d5fdb7e48499f5159c46e00df29da8679778e6e47aa33d6a5f504c8f164749f1849ad227aa217f0d6fe79fca268d12a63ec6e781b926814ed8fb414e35c657b6660f6cac73a0fb1d67b1a4d9810eaa2dd927d569e64bbf54697b712761d754b9852ea3c191d690c0295c3b45f122e2b356c9703acf75dba048c00d6fbe865ac6abc9b9dfc1947f674ef637952a4b8fea9595655ef93a32b49101d2ba1ee327a98dd702759c53a3a429f779784588ab217d347cfc874d321bb835b9149df07d298b53f684396c87c6995eb1da32e2814f72c77823efa781d6a66f3900147a7271dfc964190a45b4b59322fdbea8693f36752ed7f64445eb4e5311f5ed1e0785d01531c6d225bf0394e02c3909b54660cdff9b05a37a519d725a281732657324bc23ad07cfdc7b6988998d7b7a80b96e6701e92f1d98c83c389a980f74e4c4922ad91cb6214a501c52b6422fa283b2904243cabd271c3e8cd325bbe9fdf245861046ba9b69105b09f17e3b4453ee6cfa234cd2aecca1fccfbc621f8b72e9d6da1971e79456c1d4afeb44d6b3aa602de1109c338a55c609063a94797fd5a24fe99d3f1d8d25396d93a36160bf47c17c1c0ab06b13b42fac410f4252daf2047702730a4c22b85c61d2fbe0930ca62bfc0a8f27da9f0ba7f1fdc86cb3c49dea01358f910225b98ad74032d0a1d4a745f8932cdf30abaacb88101f882c994749968c324f11273664039bad1d51bfc7ef5e29dffd5d067a5393e40e515da0681bd27f65a1bc85e96f02ba3eda14b2783d43f4f04e9d794b13e24ae0417e79083297195ea9265bc43776ee7efdfe52e7327266b7e7ee703ce2638fedca4579cbf01fa555f428ef71c8613cca9b92b7aa3f2b1a9043e12fadfe350e5175c98f2a65d6a0f86dff3f4e111e057b9fe19be016017644e809671ad5443b10c00332d863872a509ca53c58c726aa625f27852a88ebfbc432b3235d91b4c42265a675bbb18a5d32447d87968620c5c09c3f133c47aa147fc62f66cb4c7ca5fdf756ff31621e392da02e97e579eb8fe854d77a1850e065cd65beedf099460b08e631c8d1e66569ed6b1c524648a744ede343fbc60f9ca97243dc9e1d39926b4d2c9682924fd6491a4a7c6663e0c74bfaf6015dde9d95b3e7e5ac91fff55515aefc8300186b35ec2c1a3b0d0f1fefd9e9d8cd653262b3a176b32de305c58edf6b8f9565c7f4c4fa94e256293af0afddec687ea047f23fd69009bbf562af44492ddccc41793827980dd259525a5f118b7a8aafd235bcf673eb4f4f6adc88de97f28b7a46b855dedbaa1c719e75a996c6193ee31c1fe73643673aafb9b311049e0fbe7f8f0e19dd7e6848eb927f4f32ae5d4af66039704d5bbf2619f481c6178d8ae1aac9418ce72be8fa9a8ed14a3e1ebc841a7b9042304b721ddc53295e430d78e978145176caee4c550246f68aa7818ed3e72d94a51f9deaf07991113bc9f302fd84bc8f302dea3a09602e7b742ca6e780710e7854f2375e6719ac174606a3ed143ee3e6521432aa8e21e409c59ae30cdf1612502033ebc05fc3eb800369274ac8063e171b840bf9f4220eca92c6e9cbef63c3e96a5a7a30c382551f5546b4ab5396ebee2f4f879a1f06d96536de174ac3c6500f805563564ed7ae58cc374bce245a0ba89adf2006d0b7dc6ce91f21d98f981e97d5564aa60bbc5496ead926e4e9f8f7ad11da86d1db82fa737586cc2bd297d3218dc918fc0e59e16932f26cf650c807037ba458496c460391a6e2e524a5af30ddc954bdc46b3c834e3972a69b0d2104fca9377bf0d2aa98e45ee9852d67a4c894d95aa5faa552587db3650ee5553600c4ba7eaf593c74fbeb0990752f8803c33e7650a03c680084fa80a8edcd60dacdf04bdfae262e5230639859051f9bddfcafbebe14b0e51938fcb0203750ec7031e20146b95b4de7247dfe325f80e5d443c4b66d84147c19dddb20d7bf40f8654872db2d899dec1cc9b3b0ac2bb60e5fd7b39273a22630aeed1c1f11f36ceac138554ee40c078c5830939e66bb1ceda71076d1b15fd0ad92ca827cc527aaa8acd31230f2a035bc5d9c80f57deb45f5fc913598e4b4e9ba1e9b17eafe57f0fd3b8e7d2824cf5671a8ac33476c4d08b42027c5d5ad4336fa9502467ec2df00427acf110928662b8c3669235ff3b9ca5c39a5bc5832506a7e19e1dbb2184f99f3e1db84fc7088ab604f7870540f53208c48b94a6ecbf6a8ae4587b8a0cd8f64463f0abbbd9d1ca848509d578b23204d41a32e5f404ae025887ad52af6112d0c3236de4bec635ded4511694306d718297c63ddbb0fcee377739f0c774e623409bea28fd3770700dab187c05360069246b8d24d28ed6a5d0e41c741e90630dd7940a72aac7a589b3ca939c1047769c163c22b58a95250d3f7a2f2fe33e326f6980171f24bf4293d0d4950134ada4ce3a06829aa430461b8fe6b32ab1ce5bdcdfa4b8aa08be47b11119cee375036825c990bc253e593b575f39e66f1f3a217bddd9188c83a77da6841ab3fde9983dabbe8965f5c9f06c77a3c78b867535bc56bba48f5c9725e7bced0816e2270c5680d1562aaa9933074db393836941c6114c8a49abc50f26269b8adc8e003ec042859503283992226ca5712837dfdd85f89eeee60eff8b1489495fa4b3d3b3d9296ff01c143cfc484f921d2fa0d19323789197f1180f234afa855fa7ea38219eaf268901aab959af1d887f057b8135758aebca910c7a3175604ec8e4695c2602702c7d79ae4a1228ec7c453c46c015154c1e13667af9dc24002afabcb6a7f8b23e7acad96f5532c01057d3da270d4c8829b957851b4847b00aa07e37bea1213dbc7249cf1d5a5d898f589f002545d2def53bc2ad08885bcc8adf5156ac421c011190c16f7fe77b00a7322ca156c9076d8198e82f9f87e91a47590ac6f30f10624fa1b7b824163797fae8090cf652c8c3adb081402f9fd95d8bd7455ba3c670d49958d30931f94df6cf28356f3ba550aa5f37c23c2faf28331130d7bdd1a56860e8dcbfe752952112b12d471d149c65450e283f862fc7ae93d941219e566708f478ce4775f3f7f3cf9b768074b26dbfc7a674e7cf7b97521b66ead84dc0b8e36e535beb77789cdbd198b885e7aca1c4fcdf1aa68b627c26dafcadad586583982fc5edc6213afc02aad80d0cc5fae7eb4d5bb38db6bba5ac54252f58005daa8a4124b7e5ad0f164eaca6e035568c70fea2071995d5c3534fc5186cefb86aef647b10a031c4ce912e1c4cc092f1119650aeb50f7bfdc93a47b61316708888d0df96f2b15aa81fba61e4055bc0e53aa08678ee0298fa2cab5434ef1daca030396f88e5efd088a95c5f8b257d4c3632de97eeda6980ffe7d970afedb2672735181acf80806039d9136e5f82dbf96b6099ac45a6732264b06d0b5f342683723fcf9a49ab06651419192e852c7e1609f49b73e031d706aa2245db22e4463cb7c83c366341acf6295493b0c956ad9632868bb971f91ac809421117c7621a4cef2ad2f6e6d855daa73c837a4f19a7eb243a1ce5bd26ca43b980e8ca13c2eedda615f2854bb70cc7474b1fb36fa8169f668cd7584df094a2c1b014aa491eb10e7e288e8a9319968448b8944297bd5bb1e8797c3fe532a549d205de07fb6d53b5f9bf73cb4ee7401659a8071ed2da6491c0e6b226439e10534d07c757464fe048fef537c83fb3fda56f2773edf71226e847d83264af34ee9328419a2f735f83eef8dca87256e6a9ad6ceffb7724162f002cf9a910be3cbfb051ffb9c571c5702ad34cd6fd735f0b84bef87f0f7197b1a993ecf3ff81c451adfc385eea8cf4f498ed7b90c0bb2162fa9099ff4b9dd4ba5152aefd6b30617abe5f3b2aa8b5d42c09aabdd12c3858a1e5f8384877c6a4730300e3b60d02373c6a5cb66919592bbcd54b104e3b5f7c42ce72d3d32a073a40323e731cd54cd47cfc04a76977d81c2d0fe6033b0207824a2561ad2ae8487803187fb964bc6407ff584a2d63ca8b4861819c470294805840eb878ab8c8f259d053125fa22dd46ab82df458b8b71784a2755d1a3b513362e0813b05ff2af476c2f84af5b2c8d34b616b2c1f3ce3b7cbb24033194c6dfd56b1583fa7f0d4a6a2ad7ccd1477c18f42778ac1d07dae515303743d97bedba837fcbdb67f5d713c03de3ae2cb2477197a7e29710b996641de29efe978bc0d0f99451145592d13359aa2cba33797ddbb67b3f4254ece2378ee220672b95574e3b3c42c423875ad0deefac6857b164afa866cb17adde14db0edeb14c0ad48bbccde29ab9547cb05213138d8a03ccbd2d33daf1b2871c05049bfc30f15b241fe35ef1d4beadb28cd41bed22b2501d3a6df39078272a8a47b29dbc3a45a5dfa358ee619ddd2a565fceb0a7a20003676298dee191e8428feb8cf07a2774ed468d8ae93f46583b571ac28358c5ffb3a8355c3c68c409397fe575900bdee428bf19427d8a06f25c15de91b61857391dbe8d55d2d489fbf36d4a4adafb84c93214711ec83e598387848c2aeb43b7813caf259af515ccc486f9d196c42cc2c02f6a41f514dc9a70d67aba17c2ee318e08067a80fbc9a8a9373582a1796a5c05689fe43ad06f57777a73ff1ea09627b6e4cbabedd96396a5ad1e8caa9753827d57af59eebbd6dcaebb3a64ee398dc79468f79d7828d59a8271fc293741e99858384cb995030fa31d9188fe390ea8c14f0693f5cb9f3963690891324395c8f4a352565eb3ccfbd500b3293692a5c3c99e9e05fb2491fc51f89bdedbf107ade8fc9b1ffdecaf946310c60582782a6202fa6f06395cfb0ad69f4d49075c882653ed21c361adb53477298431e9d7888908fad112e557452cfc7e79aac8696cd59ae397cc6b50cce03d95826f4a3336b2abd98fe1251fd85aad315b7e99adb2a5ff765d5abd622d7fedda59b45a05367df988d30813e54069fc8dec513826c534a30cc6fc07413c3583e038a168cf061df8fb4cbb4c01b508448cdf2a5d455a3997a99abf496b07cde263dddefb6653aca1a2b0d840042b1f12cdd618212ed67349df7f432572da162579d3a07a4689fa8ca5b4f2ac948004a8d9e275502e1660f5ff258eae055cc772b8d2c115b5e1c80da22cf889b18be5ceed2e232aabf3b937b3df1a96fc5301059f31cc7bb126150c235726509c67ad9dcf0fdd7911451f87f8c045a064e846501788f77b293fffa8158fd19d93d668c1ebf06909b74286d9fa769ba8491298e060454115a4528ed48255e84e5fef40cc54e567cec8323fbd178322005dc9d7d31ce3f6d36a481e0ae66649a68491311013569c212ed2aea114606afceeb9b79b18ff7bccb5b5ac5d5bf112debbed8d9ec716a5bb16a922cae5b0ebb29be02fc2a9e22580b326bcdcdffc3850161345fdf50fe8a77e8dc3cfbd30d3efd5ed25b39339b4d6c01f4e78bfc9c250d306d15a4acf037896b5c7d427afac3e7126be341a490d4398f8a77bd286dadf796f9b495181a480afabbb024974ac2c33bf57c71df207309b559bb2c54ddad7d45c3e6fd007cf02af5f6cfa7f4a76ab33205f963b554a97c5e33e8b140fdbfbf4a7296f67b8e6e8e67479825f1e743da4d0aee1d032c647fc7de16b3d7f8efc222ae6276add2c41febd0a075fe4c1a623279e4957666979a59001accd2e6ed1fcf184687672b40cb17311ed63d97b90d726bb77f2316a9a35feba9f4bc8a46ac3edd34f8f4556640e7b99f08fc0d5d659ae762419bdf912abea97c9767fba39fbfd59f747b2162e467b437a659c72c90e88d812bbe9deff51ce4bd1c4b89a995d2945041ac2d3b60b3b27cb5a98d7ee51cbe14de276659266806baa686e58573e1e28e5ad747b9bb761234357b32cabba732c898ccf8dca335a2b519f307d6112d7c669293e9dc871cd69bdff838eab9321bc650e387bd957ec06757a853f470d9da1f61d739b86ffa09091232b4e14d8b226d0b395fe94b6a80ba0d2bcb2f94db9724e7b310be476d013a47e4e7abfccda2d91c61a04bb4408117a27886563d7fcdc93af1b6120a4f10f3e6c73e5c2133a627dda17e319b7cd57a6535aeaaaa969f639ab8663aabb8a76af1b20c99197701f975fc2b22784cf78bb8c480f0b166062e1ad8228bd7a11feafe1b1fdbf8d405b693dd93b093cf645355ef8f496e9698efe199f426d4c0fc3872f9416ef48cf4f81f47824cedda6ca7e2f8a1141c5ff09c0eb40d784a3502de28fbadc81223f50a9a9d5882de2fe1517ad27c1e793412ce59226e5cacf0e435d61c0999659d75aa8151209721cd89a225086d4ac733ba6828d614a150fc8b2ce10a6f2b10e607dbb544952f307b9c03e47f59b6f6661c3314531e92a5e947725a25ab4e5edff6e6cd0396fbd9aadda67b9fa2deccabe5287c6cf4bcad908095fdde0eac33db0fef17e4a17586f8ed4bfaa4dbd66b09901798a399640aea03463d5e0b5d2304ed739eac1e319a29d99434bc61989cd601eafff21a2d02da29123d8149ca5a92cc899cd3bdca2415203af6e1db15f6c7315d329a0374ed7c0c454219aff983b3277fe7602c841c142ae83a5d499df7281ba4b8f2a088acad7fb9534f04a507d85bc541a05ffe23a4262934ae283993823d6714951424543b7d0151c2a6345c3cffa79757bc70b2366b04ea30d6f4fedf6a44a28da9f29b4bab70040341e8adae1ea8526028bfa4ecb79775327c62e5d69d94d8f3e62c19fcffa0eff2d0425902c4088ca6080993dd15e7321358b3b706f17fecae00bc22de2230998769ad2f1331931efe6b60c3fe660b075f23749bd4fdb54310471dbdd06171777f563147cce28820473d08486c0d2b99c26099d87e5c73660593a442efb50b403040ca48fa46b0488cb91627148d3150f451e3de8c9097367e906ef461d75be027ae5a820892f7084a28a267cea157c928ea2281d8a2bc100e155957c4ab0b54b1c7b606260610851c6a2e1799eb870dca737696eba61f49df28798f31c4c765957fb3cb079194f8bd4a751ba366470e79a28b4f2c1edf25934c3192a28045a9f97637b98d789a69d230c412750cb382771f19f2eeb63b2ff33b15839da42d4c7b0b8e15036f604d25017cfed04af3c3b51dad6ccefd1c6c69fbd5bdc0b370443026ad0e9de8b26f0e9b35613067e5f9aa8cdfca14f921196a74e9249e88aa96266802274f354e16abc85fc43c7dd9ea52009c7c396577cb3e4f7332295061774404c14742b39b0d5ca61f61561156915b45e45713a32631df32d2a5dcec7627b6feecbc8b6f0b6d20bfc0994a7c555fc5ca996a2f98dd68e4425eaffcbbb7400d3c90e8c5061f84172b99971a567631e649aedb2a8b92669e41d3a042c4f81a18b2e8693091e3dfce64e384dac799b294d466106340ff9da86db12a047b39a714b0d5624ddca7356f17b348ff2ee360b57bfbdec914ee5c1d8aaad96a4c58870b88061c352f29a27786c600e505e4f60a82b92a11c830f56d29af976b7dd992a8659aaf5c81012ba573155f6ce168f65d9808d2f5557cfb1c488c830e79e89e41725a7375d41942a4c3fcc97195b2430f83ba23f460a7f1b3d90982e687ef515b7916b8c5061806abbba85925d086c61ac8dbb1e8b35da53f23b5733863fb6a22c0b360f182bc35a52ffcf8de76767b8d508a259f62959d9b9d44d4f7cffb7356f34802292f96ed2e13b8c3d14ce5ef74ca1d7256c4eabe4d20d281c48ffd96432826bdb14fda5c26c5a6468ee488380858d6a4678cde39cb2e6d7b89124bb5df83e95c5b839d556c7816e39690a1bad1cda226e4e90d491274a0bbc8f0a1e7ff23157ec6b9602711d2d3dbf1cfe73d7a3d1b458a3cf13e9270746c7b95f40a3df57064238c52675cc5ae40819e471d728fd587e7bdb7ea9cbaf80a2e83a09a6581a73ee08130f128aebecd83b84ed9678fc1449660aad053e7d1504567557f878c78d30a0e299273d65a09fde7a2366b2988eb212a054c31fb3bee31dfb93f9643da2f16a2975df5c81ccef2883d6c0100996059df982659f318c37dd95c4847b8657e347599b1935c9e60481f0aad9a224608e5bddb752451c9d1117c7532ebb640aaaa4df962da5e958404b75331b9a2311c24cd636dbe78eacd482c357c4abecab2562907af116c593881b56f679112cd70a5ed0a46e4f3bf7e057e766e4ef8b5e753ddb6fbe51333c9cb8fadb16f49f99a22312bc2bf56ab55932d7487b3cc54bd290af5f6e58e22dbe425118c49b6ca4c95b7ac9c40a04c59c9654672b9f43d2f393444a3cb34d61038578c4df4da71a6e0396c47f0ac0df6de39f7dbf78a865afaadacba65f865b8ffaa55c5fb8de5713595c0fb991e4582c3f8801ab0ae232fa34c7b008388599406e450c58646a075de6d164bf3e029850200ba35ab831e157b5399ec7498aab0f7030c88bfdb837a20d5536e9bd6c9477b76b7ea2b79b787a37bd39da2b9a060a1d4c33aa4ee5d9488c9a9f07edc2a8a98679743acdd10159f940d40452c197ca4245102d32270eb59898ab769e61f40e63c63cdf20a2edf87d66749d1fbb925a4cbad41623864d75334e731d53c1855e60915e3e2283afa93f18702d9ef538c37e03b3a4edb1bc25acddd56c93c46142add0ba76258e6530d39ce12f074c5a5877b8a3630a2445dffd5f48bae01839d5fd680af901453d1b355c64156997020bd4b233d731833dde8a369b0af2bdb821890b025004843d8b98d1522dd7fe06837105aa9027c91e346091a19e29401c808679929c58cf390ed2d15d87d73bae79ef312d180515efc66b44a93d17b2c84eb2b1db1ad2930288f10213d2e82dbb8566440250948e9a660d4f2e9fcb8ccaa7263e056cbb6aa6bd2900c0a219bd60d2241321a60ecc3d757d1ffa43252c23ebc53b0052fe2bc563356af0cc864ca69ba5bf307a211aa00ccf0335bb93a7215fbcb607d3f0d7f35ceace1fa940dfb89ef6ab3ea2d243d8a4d63500e14e82feb1dbf888a79448b0e5cd1f2f0e77e2d0c850bdb19f32ccc0112b58f1a31ba20c5aea52ff632df2ad93fedc1f85aadb9d46d8fffbbc0fbc7d6af9fdad82b6c66bf2ed5404d52da3c6019b1c14a2d6a6478bd980cc0ebaa11cc31c295160da99ab4e85bbd27cd7c2c890a92a168dade0affac07a350d64e5d9a628c3781513a98941bfba6a880b7a52cbe30f83d3cbe581e28412a459f3a38186ee19f3200d7ed489933c068bf6d47d72838b0736ee2ddb1d85e1668f331a32a31afd5ed1c89108f143efe4fd71f859ddcd8c940e2bf89703f50a7b1c3bc4197bd6c0a0f5a7fb9a6c0fda061e6c4742eaf847f28bc72266782690debd561c3707be7457923cdabd337e5df0d5df1ca1bf6ac0faffa11a1611fe63cde3a70575fe03c04485bf85076807f00f41c5262d8398a0d3925cf76b2826c72f365fb00e94c996b5a21614f2bc54cb3ec052213ea11932c77ea4f6bf8bf6d82dd18ee59ac672b5a12f43338b08328e76aa55789c8953a61238fcc81e673c160c555b27248968653e17f9bbf9a97461e01c4d5402728fbc58fc0e889c174eae97baeecd4f7fe6412184b34b2842400dbad1ca62285df56aabe0c3b4e7daaac543d592aa231f111debb3b393af72380d99c25dd74a14f52ef5d9c6553697ef362c2f8c9772ce3062bab514e6f61b2bdeb743e0df0b863cc1844b753aba0fb9157c3b53487fe2f20e8e3abf1501f6ea73705d80a8761be36343b29c5943ae5c8c1143f37d74b3c1fe5d8f542ea3590c1018313edcde240422a5bcc86fb6b7e58dee265bfd7a8379d0e54f0857bb9ab851f17a4d60e959b1a96e34390b684a9917a274be4d8a1d5f681c45ddc23b1e14e185005a55a87c323110dd56b1a2cf3f80da7841515a03ed5b258dde293650ce7369708d2eef0d1403f8d3a65e7ef4a29dc269a5bfb4c4d2e6a8627b3e8654ab01ee7cc12ae9f6d8f43f94058f324926155f00f43f876623be5ae885529ce7299749204a1b741322e30aa85bc98d6042b3e7482d0f93a7fe4b783128efdb3da04294360d2ea48f9f25604aa2ded810a58ba24b2467e5cb1c0d8ac4c0a1790d52a1e5826ec582828985708e0ebc7af1cafac6de9443ade7e141e6d93cfe8d20db397e7b164807b6115f982bf3a46a6fcbe552bc80bc65172b401fd05aa505035aae2df764f248d5f7eff5105f8c1e980e2de69f1c5e309793ddd50d1177b1f4e4ced7b4489a17b3c076129be8a0bfb85acb4a7fecdb7e156082a3b0224ed06ca9f7ed240d495f56a9a6b369b8325604ebe77c5904ff82459cb912dd1fdf67512e26966c0e46bd7547bf66caf22352a8d8c1c7e943fa7c799eeb68287c414a1044d1fca1592cc2c53eef4f9df073c9860f05a78fc75b682dd4f6addf29c5ddf9a766e75d805cd03e8e988c3b0adf7b6de00d0eeac35faa1478fbfe88bc46af30cee82416b8e3689c58bf28e6b40ad84e1db4b3eeeeadcff9002cecb6dd3b79012622b92621baa9dcaf99778afa734dc992238abaf3f2576dd13bef92fe6f4cd00ee848af22fd517236e6324d25db19151425c4219abcac12693fea979300259f567009888fc6cd21771b8a81b33e5c52556b0294dd7ce2a74f271bd62b745f1b3471240726fdf69277748e3b73aa8940038b87abc52d0ad4679a1d9c08f263ff4407dabbd6d5dc9f18a913974c0736fc81d5ec5c78c2cfeb33e342cfafd1dae5c720ae40d12c75bd219672b942c69bf8d9b7a2b541de73c915820a4f351723a5044cb9914f62c8c36a1cbf3d00a48edbf9c39dd908f45f0f6f34939554f947993889a135b96be67485b3dff72aa3ad80abc13daf3e4a296e135a6fafb5ac5676050fad880da03f542f40cda7c0e3f32287362b38a10a483ea3c78f75c3fd908643089ca7b85f67cf45e320e7f65fe9561fcece651dd1e6551cd48bab9c3a10995cf8f267990a9c6cbf3fe7d4a4969db07d45b2ddd7bb26a6103dcc068a5c9821b7ebb6801987a5cc5011278b571964c1a543b9aaab46162a038d5429af559f7ccee21e2e7dfe5d3bdc88c886db1201ce6ac34a09c332f714ea541957ebac1d019ae8d9faf55fb1663271ca4317729af71475f080375fddecc5397bd757af12030ccb29948359962f7906f886f8c9ec86cc09dd47cd6c06b6462b3da9c610547a42b7f70a43e7eada144c1bae2490879a729849c3fe171fcc3ce016781f27c8ab1ea985e244e6fb5b28cf0fce07e6da1e5a97920bfcd4741e5e801bdcc7d35d195de60c357e2c8538defeab26fe916cb83b3f828473deabdb2c38f93b4515b1878342e7f3c3c8a8f914376ebf9dc7b76786580e64e8bbc65d04a37c98dffb19a84c4b7ccef0d48620725faf57259d6b9476c570e012af7efb01e6ef0a50e6c9484aad37d9ded551d2b335b53d8830508b882efae65cc82dc3df775943d2b5ed99c075581b4085871bbed4aa979842b3c0aa61e0d0587c0265ab7b206743924837156968eb39f16799e7934f4e2f0a596984fa964e08bd4b4679fedfa842be8b42549dc0173939ec122dc2fa06e541ca097ab90adc6f3fd3b7a946fc3f282438f627173523575315d467085df582e0e5f8235479a878d76db688055fc504633a51ad11929515be80730b2f66912839c59e22df2169ba37ab084a986011ce9cf64e8b2c74b83eeae99765b610004d57187cf95757af90be27519346e86910ea3e28893ced42764aae3a8070f7c9a2ba5f3c5651d62d09d40c64091e17e114fa1f906615068a74105d6586a1a8070e2dfe1885c38d05b8c8f3c8d8f442cc3bdd2e372c44b4cca128902e83a2671e151adb952a9a168aa02ba9e35995ac3307765f3e5bb5c9ba726c234529f7ca5f6bf8c8a9261b0f9ad1214c5d5a32757281efd25052590de7fcb9c96064e284278556357a44192c7803b331268acc2a1e45c09d91dbff82a3f5871805931a09b012304963e0b34aadee7175fe7006566b9870e0f4bb24af2f788fb0494c26e8d18d68f79d8af20b886b333a447a3a00872f871fd8137af7b94bc5e44af99d2f636a5dc93f06b4bf9c451e21aa793f3e9805d2bd99fe40198291827ccb0493c5b21ea1e176ad561953c03b280603e7a457badb5a4ac07e49109e3eaf5d191284d6a72efb3b95575eb9b7d61a51226a43b88110a38902f853612759961b885c0e7fd699128d20991e197a891c2c6dbbd212c36f8fd9121a73a3e3bec08c90c804f84f33406ae978427c6b63f479295b887e42c53ffc479041cd792e54b6e1def95b4c1a0ccc6a228542ffcddf58177cc1d0ccd890ea89565539e02538fa5978b490b22e3ed00af23c8f219b56ff44b398ad4bd272db3c13c798aa0277b74c40fe85997e3e740bfd5cf61162a0138c97353b91e3495e342aca383acd8f386bfc9b1f0bdb147a7210bc35d5ce1894315c5731ca073180b415a737a5e592fc42c1f7b118f5eaea3fa089735aec8a020247faec1ad464cb83e635e3492c432c22e9f6d13405e82125314183627a9b12033418719c38f66a25349e9b29e67082a2e14e824c18399f7e5ac4e69a6a7da890701b4bc092ca2c8d5dc636ed81bfaf66bf2884f4a197791a4dfb48afcf775fe6d2866ca1327c47dba0361a2b545c486e0b1745f5e4f7782563f2e1ad58c1bd1bc7606ffcfd9d756bfb0dbca7e8180968d93b220813563832e189500313f8a05fd2f2ebc5f04980ee2ca66039d6ba04809a8b2accbfbf40a63240b5a2b515896dd977c356c630ec03e254036ff006b973e7750f713c8b1dacd3ffead0319ddcd73bbe358296122a24040a7add64436c1b0381cc7373e963ca7654fd4b2961114110d3fa564908f914f017bd5e875be531ec43cad86e07e09ac7aef31dbe133eb31902bc909632146caa9573f76041bd97b3677809cfe4f96c88eba11f198011a16dc6103dab13f091afd0a38e66c63bdaacf18f2ef4fcc56ce8ccdaf215aab430de7ee4545a207180fcc47da4d027955fceb065fd49815170d1382ee7e4d680f3a3e1e0c753c9539b9d87a01464f88bef78b0d41f937bb579f81334c999e175687eb0a136ab2c46ed867bd38d89cf85c8901b971c9036d1d58b678ea0bfe30ae3d2adf7bb4bec10c81ffe6eb42e22a63be92e4d19e76ab5acdecf363b241c02b5293260b4240cfde0680ab303e7b08f84a483881a78c5613ffab385153f9c47d3ef613b44a6ee1b476019ea0af54ec19b60b5ec7d23a3013379f00bd62ca50c1e469700c61b924745fccbdd2804561f7b84a6961b5ba40fd773e65a79cc89a56791ccd3f46de2f274ce6160b267c2c0ce8ec225beee6ce3468f050b2caecef8b20f014f1fd85d1804971c151626cfdc5c8c9a6d8f44cc11d1ed456ded5b94d51413414aa88f3cb884e1fcafbb804566e6a31e2b469e0d6ad07d19529bbd41e395774f2429d544050de8d52d79f14b4495afd189fadf969507b8b62ff5e52617be55b41e3c7a2cdfa44eca8f0d0bfc73e3210cea5a83d6f4b36e5b042c76b01f62b0c7b045b59806d15504571669e6d1624853ce998ae11fc86675488d10f12b31e8686fe2a5fbeb588f114107e9a1ef2bf7c7480f25bbfed0596e210aa108ded384d1f0d4ec282ad8d43c439ca150e1b31b640445d4af13529895805df2bc6e89988ad15360c5826d46e279583c0908f33af82354ffc9b2f8886064f2c8df6a610bc79a58907e24c88948d636917892fe4b891a203bda2fa15a265c5235d6aa1922251dc148fd7aba99e470c93cce79b5d4649cc4aa07b207aa954acaa4417d1daf0769e6b6f167d414933efb8874202a2fdfc4a6f7b01326b0f6a6c6195876e40592479926811d00b56f5a646b0186869474265edc93d11a1c6d3931a3eaf7359fc4fad3d824249fdae34df936b5c5311d0d2e709dfc3dd5b181daf91a82eb8a8780fd549eef43d74308da0655a67ec7654c9c23ae27fa4d4035a4b17589e7b4bc2113b6a8e375ac78681d1517cdea2db760bb752b9e51956fc60786de08e930385d4b9b4bf2f9dba9ad5e163ab6401e801e9dc552b4fd773259f32ed04348e47bf3956f9879cb181cefa9314e11554993d4f847dea52f37045111b4bc625da74dfe9a74f174400831580a24495eecdbd9313e2c61a82db3281018457155f919f780bfb54e974b6216672b41a6319dd056ef4f5209685497632ba48b471d3120a7cc054933f31c08bc35fb981b9c701a65cc69076441e3bac22cf34bd60b3c79ddbb328e296910587922fda989cfc7f011c25b05f75769dfb01cfa3f89ba0975f7f08b1989febe8d4dae34c2331aa3f896c2571fe81633ab5ca611e0a2c90240b866c6926133395947b1ba12cd155a9bb7fa7b0f4f9267d748ca25c5241aab74e0d5a0605d9f678eb17f13f741fd1320f9ac0acecd46ada43c2255168bad68c3a822d0f3022359c60d16a7ac35d270a08c26d73cc6d129837b8951ce12671d513e54d77723c76e725c0eabf3aa0c7bcff98d2a0e522bffb1555862a7e57a98e09cf7ef953a7b5568060900fadba522190f32a16958b5963d79065c077202319cb689c0762c84f2ddbfcf4ae0cae777209fa73cf2501973db910babb4b9cb8c01ae9fe8861ae67f0ff79f0628dfb893a6daed903cc36b47d8563d60392433e46ed764673d263177b52d8b5401ea32b39e2a7e1dc319b23814bc9e247b238cf5c0a60a64ef9e5b96ee4f608295813474ea74f499cc703129dcc572bb1faf063ab924043d027967b3f1b0f63bd6af22af24524cc91eed90f8d84d808af9a53438c176dee6d1fc05107a2dd71baa0229a28ce286cd1e8635cabc5ff1cc941997105581d9119aa31ac9e929b22e66e38daa54e888519bdcb9cec6f66046717590d6a3bf956e339c1b35af9cc2523fad9255156b3c2e207c13492e628553708afa02de8da07c1afffb9b23dca9bbae03d0ff9c887eb4e050cee5224f5b240187a08012dfb66e615595aa4e184463339c9df4a34142c8fc6235082e95a804e9029badacd4ce3627b58ded98ff0daeebf897a7ba71279eef8fd06fb4ea8d6f3e8bedeed72695bf7168547d14241fc786b924efcb4d9e4824876f3a4af94f8c87682962a83410680d92b3ede3a8ec9ca6ef481b1b03c9a0ec71374a035873d6ba038aa75b3379c66ee14ffa90ae9e026b406c0e7e6ec0c4a6f783aff2f907386bd9add883679423dff66f1b08e99a9b67b5999dbe72083bfe5bc1b1ebd0cb5074b7d35c3035290524922e78af318a671222508d85c4dbc82888c28c4e669535585d95f41862d8bb342703c105949bf0f43514a9543c98606d0797bb626a619a27fc69bd2f44748d719ca91fd0b6ac301a9213f19b00d38d10d4e794989e9b5cc6c65ebde26f43060ac3f9e74300b78d6f6c5c2a194f9e36b4bbe65b07f9ab30e94e2c1f0e9ebcc95b43ae3e8249984347dec093318cc50ca368fe483831af5bed249bf28d43f7b1e20014274a5a3cba6625e8c569f4f118893db89855c31b6a046a70f1ddf8017b55c8b2f184fb36b537f627a1bf25043e291886472ab379758bcc4f6cc4f393f0a699109926ec6df8e41c7ca1bec38f1eb7d025be6320a33b1a0dcbdd60c5ea9293b28f8bb6e940a1db28a916b26eca034c1864772a9e717a50050853ee04eb588306dd29a0a6d8b2bbacfcf91bb6b57badd23ebfc7b895c7051ad8f2b9af4c9435054b26c1e97c7e4a5ad4f5b38ecde028d17b4de68e3ea06b813a8f2ad814005f57284f9200cae216f1331d29d1e89bc66a01f9b7b9c4bec804cd46ad0057eda456df4d9cce0f385970b2fc471c5125bdd59441df0f0505cce97facf8954e43ebad454853bc8c84a4cd126449ea3b7255e5b3ca4864bf16ef307f1f1e932683cd41a84151aaa9b915eb782f747eae8a5ba9b18ddd46c21e38a0083bfa4fb26ceb2f22407337fd731bc611ee510f6a52acdb148bc92d35da77f0e099729ef5b405","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
