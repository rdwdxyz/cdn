<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b16df1ea1111ffb37715db438f12ad9b2de92d94a91e95a50a09c172727ebf0e91207510febaba51c4769d54498b2eeb03b51d0f6a1b5a7fb3739b5f22807c20bd4fd953ce70f2373595215be57ad914b06a08dd0732cee0a3a545cacaa60e7317c8b0b5b9ad12a0686c96f3bea1e82e830d83b5e90db04dfd5b9a27e412b80589b389bbb07f08c77e7b3db92a75f729bbaa3844b4abc532681abe6db3f5a4c76211ea4e00ae3f5a59b17af735677499c7ac1dbf07b237a7a62d05fbb235143fd04a9fa010a64a47b9f6bbe16ea4ce963cdd72d1e7938cd35b1a5aa46538420110a48d96d3c90e65720e7e2fc07f90c8b01fea3e0eda53ad10b60564302d5a296786f678661ed4289558d7dfadd60fbdff03fee86894464d1df41b358c021a405fd769e3d137d592fdd161b127c8a890dad59df5d84f885b243d55cac9f8e1879dc13b7e92a184be89bf57bc5894c91227f96c883929a63210e3a01f2c32a6bcaea2340f4c9cf371c88b72f04b3f5679d0fb9d491df5389a52cfd845413a5bf38f1783e08ae746a2f23e80656fd6494e479845ca803151fd88c33a08e0c555f1b82119e7521937bbd152fdf644f71c7e4f919290465a5f0531722cf294dc908815fa20ed884372af550229f53eb4617af800645eabe122537c4d1556d14985dd7e69c9a943efecd9a21b56286e3b4b91a834637ab55a8b467be20a2de44d065b28780c707d8bcebcc3db8a6284e2923dcdd6e4dae6e5df41be04a0b71c5dbc5d74f69e7a60929792447f0b39108e8951764fe1a8ec5f979f7c856d5326577ca74b2eab26ef5bb6d754875a436101d238070e63f4915675175766df5f871520af94dbc624ddb073b5ba8859413907c3434927a9853e04269555dbc0aba99bdc978ac3fb3f727b73e5ffb94d7d9a7d17fb082d391bb6ec6fb0c280a5fc33d4062fde25bb8414e515dc8d353505c55f4f4fe926a9bac37c97581d0a7df0eeb81f60bb858d33f1829e892734258b980a849d6dc01acfff78b1c290b0abd753dea0c50378ceea36c7ca631fa89de140496125a9db97b21c450e697284898cd1d4d2d8698c68030b7b6a70cfb34937c3661fef64e927a33ffe9dc8d53c01527feaab32c2a60619d546040a6f1425c9b80b0cda711a24240feb2f8eefa09bf2ba28633c931182d36b09b54d45ccfca3df5ad11db93789cf87bcbce255a7425a43c4b23219da3b5c9cbfd4fd5d080dd13cef71b0deede829f02bea13ff0c543f9bb798a493b5b9b6ef417c6c0f4798ad7d3e9002e0522005062cbd5124f445e318f227e13f458e03a2e25b6b13f59d279aa0709cc2bd8f1414871b9f7a0bd2d67405649df701573fcadba1f2c1d552fe64115ebc03306a44cb32a3ae57acd9377cab6af04a2ba55070669ea76c69d72b6dab86667f24f815671afd8a99275b151232fecaa4db8429adc2a9f58269e21096bba581f76b1fe717dff74dde7bca9f92769b11ce0029f948236c1fba94e9f67836cf2ea0270d1d4165ba085eee684d40d013a0ee3be9b3d2791b27060b780c41a51429984333406a1139c0dfd0ad119409196d56ae6bc85ba7d5a210aa4dd05b09e2edb5be130d2aeed489675cd0af2c24a621ca005f777a61252500190f5f8e6df942576213849eca1b3fc7a22d61c9dc559dc7acaabe9157c67334f7449864320975fbcfc721458cb5efc0fc700a18a7734632f65b61308c764f4b9a81161e0b65d16385a0bbaa5e076a569bc10ac0c42070c18ce0fb25f0e4d9ab423d60270b0df8ff064c598dfcc1ba94768d490402e7ea552520de3049c3ecb42f7de9942e16b1477256a0f0fe617a70898dcaa8fbc37805f65502ea0f6e982efdd0c95174d834a7229778771086bfe229aa4d3c0c23c9405d1dd62654d4fd8df2fc22e14645f717f309b2cc9db7b1d6d5ffa76074eff10d301083c499d297cb25fc4783814715cd1119df9e36f075873bd411d7b8a80139b6b27ce97af263b776790b0f442c98ee4a8d92231ee4f6df555597376b7f505f0458c6c77a2364b367c4938aa8d9c1815f241c74bfb16c7f5eaa36a299b6fec266435c77f8106e193e0ed86a27498598df2580313f387e26f71a799f93ae3b934365a64b29e1ed7fce6f9c91301aaf5155edad9d83759fc871195ebb73fa51dc0eb1861e5cf11bba97320e089bc7289ce1001ca28ad3e792cb8655f4d84cd702d53099052d98358e32fa0c3a4ca5853b77a5cd4f9a17ee27287a55f90f043d424eb04551793b95746905eefd81522d9ed26e1230bdcafcb32a070bd5c66ee7aaf6ccb6074d1b57ce35a6d2316fb2b791aefff247554c2ccf3469c9e4710748a358aec8dbfdf9f29373e3a1164d5e3925079db56008a780d4eed1a9183970c2b301f9e49294c552262ba645fd088aea0138a25523dd66025f2078180039e967c135c31d4b1ff95b0a626e10d291097512d181e5fcdc09a3441e660aeb205a24e739833c32abff2ac9a98f021ee2aa53b37d57ae70c9afff3573d396280be0c48b491f01f10afba82c664ad1e6c08391dd7e1eb6577db63a82a8105f9b3ef6b3af50bf7c8a4093ba5dbbbcb73c04621d69d45039cffe14fcf196f0197599dffde5797ff1837aedd68d61e53ed1e30e9b818ea5d0e511e1fc8c334c0087abf8ee3ef7927c608468eedecf5e6bc27a750e574edba00abd14646e386698018176f97152a2cbfbd3d931bff6f6d01102b71814fdfb80a5d4d8050687cde214a3e52bb18ea315fd6099b5134390baad54aa3137416e8f5f2da060d11aac7d2d6ab7e14d61f2a4dd4eb271d8729b15592eea11f28085d75344ea655d21e2cbc058ddda6046ed45c6953755c5757dcc990f6ddac905e1eaa80378614ccc0813b380cdb1e854575fb626de7095bbe2581c5221e84764acad7d2efb8380f7d280c9330b26344b3d587a54f1a343bea8a892ab2b70813e6ab144fa52d9578f295b980094fa9739463454c37a7db780afeffd7f0cf7262c2ccee54fe4c50bbf73b87de022c7e49f3fec4e57c7e93c73c5b13392fbfebc6ebb0ff293924a8f4837e6d2cafec845d743a3a3a8247cdfc3e3494a18e5f508a93307cee6239eff2f662fa75de9d187161b2e2a24c2851f42794e9ac130bb78c74e15b8c0649b362b1eeb6a25c2833ab90b796cafc6131fbc6fe551b3870504d8ade87204e665d0358f855c53daee85e6bc1af413aee6a695b69358a6b698cb55f34d099f3bbe821d9324c17f8cac4cdc09db9319f880073a6850111ced11eb7336bdd5e87cbfee016cb7fc13d0e2e7884f9c1162f6a35fec4d2424dc812a04440236de948270da0d8390285b8f7ac07ee7bfd1811aa233a51f616b0fff0ee445b975110e0d664979714f0a019306ceca5c8624abec57c9496e4875ac57df807208f787d40dcacdfe13e939c63e8b63b465016bcb3791e04c9515d3f620fcfca0a615d45b6d168354829213891c2ca1727d945f0dcdd63ace4fedf79185634452200775ee5d1440db0ee22abffcbb3ee5a51982403cd2aa736f2f38d4161733d2991d93b3c842ea6d46b7557dbb5a88fb7619897575fcda1f98b9717483a9ed0238709bc4f3d397339115b8dcc7da042c071097636ad3f6c38a4b94a8d84b88161307cfb1a9bc7682bd61a725dbb04032855e97cfeefb39e31fd02106cec69fe5275ffd167c8ad1a9c517237364dac016e5441c93b51bae137b43b6497686a450a2a79e865797a72c2869c6f1e033c4911bc9399cd0a5b3cefcb05a2133f0e6ad56d10db9db6c4514ae8961633fa9da479e2e98f80bddd130b18848aecddf9090681111e2059c4f7f4e09da3065e83b61a144cf349f38e0769a8f6f5025251f061978bb5ad6b9261d61ed17424027684c8142c607fa40fbf60465d87bbd5e7524ddb51ca7d6bda34a4a08a9c242bc3e2d787ffd60118856c2266ccc89a58e6828d5bfb47121f9b4d9bfef705bc77964e66f4f4a051d339dff050d5a3b14c9d782b7a24aa95a7140cf95dec8216441693cb1c8c253f5719933e97af52e0bb219a0cc768363a656b718c8291e14a92e9992a881fb58bce1d0f755799abb2384252d1e94f20d35cca4812659d222fd09d0cf8fd49a3e4d5601e4e7505a3c181ff096b7daf82d743f0b838436a2647fadc3c9d580e97b98eb9e48823614bb2014799b882c8e65996e81846c66143ec50d2835a27649ee3c11705e70a43aac7d47bfb9685e23ec1f4ffedc5e7612edb154c7f122ea55562fb2056e916e29b060fd5e9ccda6c4b82cada66b6661acfae51ff3f1c69fcfb8a67fb1c71d112d9ae8d28a16c6d48083d376c349f78dd1f44131e79e68afabb60ccedba6a1f3a643253f5c535cec532eaa55dd403ea29438557f7bab897a102ef580611e4440da660a9d38f00288237a87ab3d94988aa8b080a616c9ebcf96aea49895ed422ec6650ed3a29fe47ecffbbaa0d26a6e6fe4477bf89a47e20802168be222132dedd39ed26f7a351e86d116948a2dbb4eef02c76b6c9647e69e607021afb2ac55b991690e32f9317fe52c8029444b49171623deafe689ed34bcdfdb5c915d8f385c55d0dd85b7ff38159e9b5fb4972582462d72a4c85fbd31a475ca8f2feee62d8018163dcc3d5969ca2f3825f7936219d08fdb1e5990197978764faa390b5f56ef622d7003523f10ce1757e906b9f99606f9ce1f31ec88c4ab1b7e617c95f5397b25d7656de2cca8174d48a60d8438ba7dd205a23beeed3e77e8fee30257d23b01318ad1a2efa5a522effbe1f45726b7b44d311bd0a2bb31fd8b1fd70a5334ab900ee45d781eb32c26ea63afd8829f982100937c63aead1455eee81f7622aad7abd7fba6aad1eaa1375d6c82aeb07bc658d0cfbe7ed38c862908b886e91b99ce590245d6e5ea4dc18d46e64d1bc85c83f1bfba45a4dd81c243fc2bfe56091df981cb1e00a18e34b4b6ae372bd30df6a5d6e23f88da4b874e7eeaa27c5c467ef5ac4dd5a2c6e2cb395d3762a4ac5635b85b3ecacf0ee43a580d08063b6c83d0a822698a43d41680b42eabc3a90fa6b3295f8ede2b3a6e26c9165b0c74f3d5bcfff85c03922321e2123fcaa33b2d619dfc97c5d73a5386bde61c023989e364e74d0ab76f04c96cf8a8d5fbe24cbe5f149bd899b04fa64a2896b42e85a634933be405e871e60ee1d54c0e5be9457222c58f4c4afdd8ed12310a373fe219be95ec8548d06c0b2de914b312c449232731d12dd567953eb22a1c74be4e24062188be320f2067d55e82726166b92825ea2c543d242fe83b31c368913be423d7a673fe134a8ef57f1c978ea5c73cfd76142c90167455d54242b090d6d8199724819bffd2403fa27f33bfb2c2c2764efa4d2bc821f6833afafc993ad80aa8d6e67c8a4c52118cf373ace7930f3d1312eb2421a880dda4472107de366ac5b6e993630c614ed44e3c64a33d800f8623c49f7f7d52f4032a347e54531b2a93d2308a47c26758aa7d0e1e955ede32ffaaae122fb08ccb62fd4be6faee73820a96c4559176d18a820672dd6adc00f3b5c52f5386885e9f37b7a9a1574245452b616f4b816c7dd69bee9c74e1f806ecdf75eda1c27998a545598a90c937bbbe74ea157311797a83aeaf5d40d34e9cbcb8d8df2a5e30e0b2a5a0dd953aad113870276c963504f35562c8794ce62ec02b8c05afd3f49c12006d20a89963eb10be477c47e73549e355bf56f0e7b61f47b0b7f1797509a95b284c6430b3b90aca4850100470d923f0849618c44904bcaa972f9f5fd4d76b3077afd5dff85143269c78a393ac15c2e0fa41767ade51de9fdd9556679fb81e0a551797f26f89ef29aee0a8624828e91bc934cd95e9912d14cb990b6572db7b1c58798def01e3dac925e4c27ff34a60d6ca0ef1ccf0fce3b93d553ea95c52ed324f0ee8b5f9afe3eedb917980e6c83499888ddb41023f0b823473ce3da29449158f88fa320934453b683f20fe5c68d79d9b2bfcbe26a52f43bc3deb94efb3f412c280e79dded6af171500026fba6291946371a7c9c2262833b8e5cc476ad39fd6a6f166ffb1efaccc06a64688c1749378eefd65635b51b9717f0a4e3744d63ba04654eb39c3718930cc270d363990a4fb8e883fa507859fa20641b5b27fe8d546bcd5427b6b2a7024154c516e52d5d8822189790f0b9000a2ef585476e1a16d768b4416e58922bca5e0a8e2f1b492554a33d2ad8f8d4f0e79353e08466ab50eadc50bab08902cfa2dbea2df7a5280025fcbb355be00991dc5db28006df13caec370bc7f29aa04ec7bec4d9f3b7561dd00eabf5f1379eab28b929aa8a60a5c5b69fc4efa67612c6491fcf22c3c7483833f1ff07e5c8f07011c5d2f4aed0be426e602ded77609eac5c843381ac2195cb84c75e0bcdfd82798b0aee6357529b99d2861ec2652887df1c01e065de24245636072b83bc4c7d6024e69c6b5ad4ef4c63a9892384e3d55aab55fb2348eb9176895bc97f100afa333186db0fbcf339b2f40176ca8e327d4000f3e9a6ccf5b215f275116bf960d97614681ae58255ff56f9191660c2e138998f2a48ebe9a76e007f7a9f05694d2e847eb9175f352ebdf1ffc45b77777b2f2ee403c7867bf2ee7ea29bb74c80e2e45bbb3f15a66aff44cb5cae921fa62a2b39badfa3cc8f2cadeea1fad6d86f53b8f0755fec89eca0b55b234361c739890cfb05875638a8c80f23e00f7e95ebb1774a02664a8f3568819b4f4ef1ce221580f846b0663e62a01e0a1003c1276224f25f4d62ceb27dc62cc883c54502ef79cb8694b2260c7e6a8353758ca752279149f9ed1cdea686f6b9c3d1ec6bdcd7f2d2acefb8ebde9b78f329126becd7c8dc9252737f6a15e74b328f677fc4abdf222a363e1fba97bcd02eae8ffb08d722888d5e738484df7100941224d606d7821dc4103997f9cf242abcb0f72e5b07280925e1aa24e3443073c6e22410993e823f0679d68a4642c6ea37fb176b6afd5d035d3e359d38fee9666ae07ce015e7a89c31b9f05d709acd9f29c93b800d4653aba83e369cb70f0d35ba9ce665a0c02d4ce68166a79a30f4ff8c94565708034dfc9ebde31389fa7ef27d3dcecd22cce78ba9371a0ae0062ef6469bd64773ebd9504ce5fa0242b69b364cf2339403a458ee20b6722291a36561ea8599bd8224107f09b0ab6ec748f736e5fd43863a774ddf47c93cc5f52f9239c09fbf1de9a78d62997d87027d540c00f5debb663962676727a598fcb0c036a9f93519cb20822f3022ee2d2466098b3ea7f43f4251308bd0db8a58b11d253247d63d0178e2c6888465f8b33587dbbd2bcd5308348b7a8daadc88c53d7a8303d9d42ad238b140aec05538f418e9671c9c53f8220694f2736a7d64b22e38c77f55756908b0d006b89ee3f3e7ba5b95b9063564c51863423e44711ed94dc2cbc26788544ebde60ce9f426cee4677cf3e6bcf396e7a60f527d317fbaa71de9aba1615372249ef8dae12a34c47a61ffb049487457c3ba483f0e9740c87987f12faebffce1f1416a4b4a70a0c81a12ca7ae6f1dd38272e284f2cdb4699fee4a4fbb0c84f08162c0e22a8984d6a8be226e854c691aa7377ed1225102ffefc8e145046bfba44f2ca3a5b34f4a0f0c06443057ac91e36786877875327c17aa87e654a202a1ed510ced83c64636a6d334bdc034fa1a497fab0c8182fb301c14c157f34425d3eb1e8e92ff291c5687f65baed99e217ceb11a66c739373e1c1dec190d9b4e5e5b2ecf90e02f616ee0d14160332507efac56425c97517b6ce92cb8c8b136e72ff739255d3366d472eaac56ef107ea25faf6f82992ae19d1f7098d6d3c59addbac9fe0d26a886fd960fd2c3c73d42c6d879aa0e96281d57104ecb618508800057500232a98ef3f91e5c78b166e925d81b1350db20a0a411ed904a34f8022f120e7d0e9e95f7542cbf280bc3ae6b493b0cb80360ed9ec9f7be85439f0042f5791de6fe5b214ca2f298a6952c2fbb892d1002cb2822c27e59384126507d512bd1c12c6034eb2fedc7294b901c01d5d0ef3a7b276e0a1d7f54e692f78e6d0bfd73c777dbce80b662ce99fc3dc9257ead2b36e380c9210a1e99cea5a914ea7eaa7dfb2a43445b351b6f23e72ec3be7373fd8d648eb67a67f7e4a48001ae3a9d749bfcc1fd6e1486f9d162f17109ee9363ecbf1f043fddca0c3119ea7de21cb4c388b8520199878f508f81f42f93a5dcd6ee9788a64dd57caf67c9f78201267d573436eadd5b12adff525febbf081073d2c02035868884a89f9a9eed50163322694b0b0fb7c81e0ab00d0752405caf40fe938691dee420d24b8194ce4f7dc272e490a2ae4b8b3117ae062662b072432bb8a31fabc88914253223779284347aa224031843ca2d730cbc71fd392131beb6343acd9d9ed9fc876416c2a5ce55034aabf06dfb0181317e30affdd718294517f6f9a98359354e3c2a944dcbcf75f1fab0f9e9cf7bc0acf9a961cf7a15b8bd3a12f64d9c384ff1413eae7507ea931c1a0b0f61c1e4b60d72f93a4563fa72d3bae546d5582e2d194fc760c17e626d27d2ddbac408d35e605e66d426756358a2e3072e3080a1a4fef3ab8d3cb999756ab9ff894d2a678d70ec493049df4fb30e744417cc0686be6c3a0d72e9c222ad32ea5af0059dd94e8fc2a3eea2f32e43df1c98daa3cc745efd041f5b668838559fbd81c53b691ece70696e33fb5b2ee20bb1504731190dd7cf445698980be6f33daba9b570183ed0d76e410bc663f6488f873b3b92437742db55db5110a6a25f413a38a99cbce8f3ffb613ec0ff28ba3ffd369092c4f47db602d056df052c3c819def805192d1f3b0d57f91b307e55f3bc36cf5369018b76941d6c31ac04483fd3028327e428063965dc77e2239ab196751c4a92a59dbabdfce3918392d3b45811b4203fb9cc92455b54d23e834c194809fd14184201eccb71ad0ad7db264293205b4ede9bd059fc61c469c6e6bb8e917aab1fb0912b599659f01e9fc1f2c865c2d860055496144afd6f18f01bea661f33ddbd576b149f29f9f318104b202007944b2de38ff9e6352c3b8d4d96e25c9ea517ef33324ad5c6de016ebb724e937f0521eed65b80c10b2becef1b242bc9b00555437f55454573b55a695ea0209660b0e359e4a340056941c0cd7403aea8286eda273e807a2b850ccd8c2516ad28ee1ce4d76aec92951847a314b378cb2d562d84353f0daf131c7190370fe7e43ee446e521fd3c88c790cf5f8dee428ed913792c2c5559291ce5800835ddd1c065cd5bf9415f9ec1ed93293db4934409461ebacb505883324c31db89308fbb95f101b9e0fabc99386626c10653209d8f97cb49cbefac5e9190b531ff4da9daff83d45964a82e5760aafbf0515f37817861e6b844fbccd3782f4767ff4859acd42dd9323f292fb18ee3195e9efeea4c9cac12fb5894ef9930bf8a990aaa99bc59b78b6cbeaae9daf6c3df97457085ef5567caf51d01b64faca1a3b010b08a78f531a05c0f1f267d5a58018541ddd6800a35f3f4c91cde1d6df552252dd0b577170d11616e0ebdc6a686d374a2ac5b50030981056ca74b73c99893bb78334ebde9903d81c57d89c4389d8757fad3eb857903c14adb6743939c22d57aacd2065f211725da2b4133e0f5be14d842eca776a1bbc89ecf818b55e6b52832eb7d79c1e3737aca9702e9970179dd564ab24b3b3e0fc10450440f357c18132d33437d512de645b0cf856e4d6d47be808c4179753d364ba77b8bfc6a40eb496f6613e596e8d92add4e6a2fbe0ca293abcc8d650bb7804eb3c701f540d60df072141b1cd026e74d4bc3a8a951b2ac243b336279f1a843ac591edb48d4e5acbc2b39ebaa1d5afdc9accd86dacdf609956e043d7ef4acffba6cabbb3082e59a3e58e0482fdbccc6a531dbb7676f92b06414476bf029dacef0e6655edbd432640ccc38e43c678d2f671a417071496f9dc827c51237d759a62e2066ecd56324698ba7402b82e2465f445fbc157b8177d4aa792a211a81a34b0f348aad1bc9a31eff7e18e616685545087331813e53bf7e1415636d9885f5de52df097081b86b45ea98206cc0bb2ffcaff212497aa8b5d1dcb51ffbbbba821b4414739064a721bd0a1cf720b905f110ad762617a15ccd906bd14486eef23946cd5986b022e6d297f1ff80effb00f5d9565f2bfb10dd5b8649594d02acb9be57bf379490b759304f6624326bfb4d794dc51487c1807656c07cd25738e2575acaf89a3c1313040b647288afac8263bebd50bc6bb293e5e91d3ce2bcf0bd889a8c2ddfc51f46dc274c1484d25bf5f11d08caa2545009eafa3895fa12d34a3f6d06fa8cd3b524602cef58093bcc6bb8935da39d37707c4b033acd5d86b440e66fda4af1fa44b59f00d4f9c6ae1d6c1e6d57bef6b2ba97061c719f9ae9c3cffcdfd6c6880151344113d56824c91c485fc5363b780f6d6f574f8a42d023532ece55c8e86a8c80a6337fdf616568b9d23db231fc22aeb1dc3db121e6df22cb473278e5783979b7e2adc795033ac1920e3cd140fd68052bc2ae520adf6f1f3369674d622a78909065bb5909836cd5cb23f33f2ca1e4dfc434bc43a449d55de2b914f39089c81104979ade74f2218267bb3a627ef1c5007e1e190b3b5c929b93ad31d04957b8d8791b9d0a7a15bc31e1d2b910f2f601369969f7fd4fd3a8ffa258848b7d6d1f725d5161dda4b8514edd7f1173c4f4b4576df337b10b0f116ac755489ecec3979072840052692a2093a4291dd2072e5e9a8071879418dd4b3a1ad604f851444c7a3d3b9335aba00f8823bc87a09518fbe217d78f0d00b0c64b2b0f4b1390726ad2dc2dbc226fe170eb287cdddeff0bcfe0dcbe9ef8285e463281afd0c1d8042ee230420788412acc486ab242d37ef2ff8546be3569f22bcb06f2f0027ce867a93a38fe7a993c31f5f011d47e4946046c6df9157332d9a267d893006ff171a1a894f60dc75a34ac98fc6d5f7c9be428937ad26d8b58e79d5481940b7fda49a58b5611e63ab6ccaf4ff6c086f10c5a4ef3d20ec012ecb298dd2c6e919f79daea6858cddf24db0875c9ae6dd2f55614b1a26786c73392cfec454c1a5c9cd47a76ed16604a95bb96e72dd6e850335ed4c76b618e5b9d61499f6a6c10c413d5bdb823fd6c82213788c4b5e19df9127e7811927046445fb23b28bf58c3a8086d0b9045bb0fa3d442447bfd69fa5df12626450f2d275549a7af66a28f855df3dcdf33df6bee181dca159e68b358fbfa193d794dfd354ad0a3156273771cf1acca10e64f8ccc7e3eb5b283b9c2b693ea9f0657ca4f408b87ec5abb6656d2268b2e7647f8e9c5fc6116144566e2c438eef3542616e5c16f3df7f28a559a8c109d5e67767e3e17afc68b2b235902cd05b2e6399dffea594046b1f03b7908491124ca7573149b60e254cf8ae837be987c59e8a951a7dfb1209e1f768669e4fa6d218a6d46175813fa3c78f477b83d2c394cb6d6bcb716a8a9b886239e6b4f840f3502b64968d722dcedacdefaaf1a6c7102c74fa13f017e6e3c4c9a2d071ade9163dc608d61b8702df09ab52953024c5f696903f2289ce5f0b48e1ba174e5b60782b92d0b90647aec24bc2eebef03ddacb5238e224fd2128b0ebe43e8308a3896c8f900ba83851c1e4d8c9e09fc8e2762712a396211f4bffcc028de3cf29d1dba941d2bd64f86970ffe0c9dac21799b096ff2a4d6abbfcf571a0e06c54cec614a448f707d9c6a3f94d9770c15ee5886c896cf74c52e522e835e2939b0ef0cf7db2fbd8389384522e67a0aad3b40f1f202e692896c2619b0bbe56a2264b6bcb639a707395cb5d36530c52fd065457e65b6739499478722d3d25dede19dde98f7a4324df508cd953595c15729f1cafe9b4d14dd7b2962a4044e2c41fe952454e3239d8f797c9f705120f0226858f8d552675f97831e4131bc0bcdd2dc138b219823c0f037c852861a8fa3a5f2eb9d1388f940b5186303adb976d99ea0b0fca063c0d422e1fa0c6c2a491cfafd441e15ac66f3b7de7f14e3eb49266c3d0d3c79ca8933dc76d07f3ea41729c02bbf2f5125d2e045dbc1c94c7713dc8ab5286c19be027847a8766d3582cb1fe61f6df0cecc36a4b087596515efafffab4489726659282cc3a30929c3a26cd3f74c427c9be41119899ee94b6a0c560d39a3604c85b4a1f2f555d2be213a4270ab691a89394ebdb78c1f6dc61bfa3f3feb963dc6fedb701a14fddcc16839f2634b816c5ccbae13bceaca71584d6e3e0fa348dfbed43d23f6ff872dfe7c822e53d8b73001f58fb2b22bbb6229cc4ec269fa20f3e81fbc35a814f4bfca4bb8736e25bb76a45d64a26c910d39a8038db97870b06fb15f9aa0df3213c209ae4c8224a0dd27e835ad474a2d3ccad47fd85d16891d008a141317e4c5815617590e3f27c625796ce7f5db6839f3c922b5b9a54c3f4000cfb0c0a8d2f530188c3b9e53654aadd9cdb3cf33dbbbc516d5ddb572a70b7859b5a85bb378f026cb348b2b7b030a1ef296f5ea49d2f0aa198e301d6646e9cbf75b2c018fb679c479d46ee31aa7c6bfe2a61b3b3298900f096acd0da41e396be12e069c27055c79c393a697aa7cceb1ab023ce711dc3b6aa8ebb194ab9f9bcb499aae2bfe68211ca8e2db29aac866ba3e848e9e8871ed64dc31c1ec38e1d070374b65e4cb145d89beefcb14cb5fb6e4ca4e839a425bd220287a2b8718508d16fda32ef499bb0e3630bc1d94f16dca38c996e35bafb93dab2f30ce528b51dd96b1a1d286d4c6091cfcf0d002dc5fbe31e58dd9e78616a82bbeb39b1ed69d162ca8bd5279b930429be16433ff0e9abbe728ade8c9b224836620706961f5632efffafda2ef8d8e9f34aaca0c96eda149f57e4d817d85a965521f969f4cc8a46b13a4e1005d3c4af6fda8c8561673fdb5ed7aa02594e9395573020fb259596eaf3713dc7a37389bc1f551628d7a6a19b709fc88151f3054e7814658cdfaf807ea2959f04698d9be4a717e577233e931aabaf3c0e72787fc30cb38e18df3448e665005753cdecbf4e614714968bfc9bf0eb9ec86c52d726a2dc5dfc2e830fdec04e9788717c55b1f6572f674c01fee2e3a5596c4871616ee6642a0d78894c234914e39f8c9cdc291583cca89d7580141cb2e7be42204d80271571c74b759e4fb472a3cd35479c4270e0f31b99277c768f30f19bdfba6b37bf054fa45a2066129a9a10c32bc3f4ff4ec035220e7097ea422d07def069aea030f7fb9b3140f8c3a7667b1e79a84898a35ce0708079d97f0e1bb346e4e15ffed0e345e6fa031f4c8c867365bcba95af841b08134420e04d21a12decd5c8e1aca368ce0e32f2bde89cd16201f190287e5221a0e47ec484650c0398cf7d650f69fd26612f428172cc5e28a6e62cf841250ba35c2ec44bc7cbab0ac4e3a0a5e174c9dd60961b3aa7ea9a817ed43fe37968224c1f5e821adf7ccbbaa56b5344c0d85afec92bb7886e637c6e51011a4c61beace4d30c5011495d38f7d3d655ff65522443a213dcf384d14c37953efbf587d771309458a0a8556b73672249a27416e307b2552675ed7adfd203f49c1a9bb64d2e5f23c34e2f6ffff7289ede0ccbf23c07991879692a5d309c2c024865f40f2b7a3e81be58233d3955e31d4087ac0d89f1c99d6bcf6c461f4de8003b14389460b4806125a261a259ab927553114ef707f0217fa6c3a409f0dfd6c6d9eb1f7457f599f01ebbf27b9f80fb4477525aa9f0d4a0783e8687186cefcefdc7a049fac27b0b19bf7b425ce04176bbd24c20c595979969aa7ccb4db511e0e6ede25754b0108b41055229fbf4cf5879793a2f2d4579791c3ad73dcd787ef1a504515913d1cb418e5cc80f5c708b348e5752f9e2f2174308a3d5be86ca0c0c912e4cf9d7d619eb9762a3e9a867e95ea1bc6517b5aefd952b50f14076f1f56f216a612abf98d76f51548851ccb421405a3345ec54b5bb43f1550599c33b45e2902995717a92b8cac85e081ce8febe85c627b776aa358a33495f6c0ec97640b13dd0ddef987bf19564c23b820ee05ba6fdc80584213378012ac1faaefcad668e24e5e699d23c814e568c6d8653bfa72590ba362305a277394ce5ce16c446e8646a2c21d12d5d3d776d491ed362fc76fac30dfebb901ef727d73b60312a6e01a53b61bd2e1db8600f7b0a2775c24a5181a463df3693cb4cb1165921db51380ace86eb9dfb5f415fc442b8e0adbc584d6f3eb0893905941d682ef8b671597a8f1e04d576778af1dbe2acd1dc45ba9f82696f6408766608c91cc34d26d1aac93998836d52de08559fdd7574626d81eefbee17389ee3546ed409fd3864a2fd0a462b254bff2236251454abc5c378505bfbe9922866551e668e8c4762405e4a7769d41dd03d6c0810e3fef1dec7069dd95be0b5baac2c399b81a2e6f89d9ebdd1fb56ab1e1ae14462507d4c4a68806c487590bc7e64c257d4988724212864a0bee775ba37310003fde7e29d6956e42a42ca85572f4c3526d5d29d1c0e2c408a7c8fd5b989a9c7ddc2aff42f6f798cd5b511ef7b4e09e462b7e1d01f8cd9d8ae38326e778e890f51aaf22f029b1d38566f40b83ae2af52545e607a5f01bf0c1b65ad11e78c588b74c8af4303afac05f826134b14b136e1a0de6b55c99f90733493420fc4225548712c1f8308414a650eb0c7acc5e1dd6356097efc805329ab85098d88bc494830b2f73757f26d96542d3de9352c3ca0042567227d81b315e7a045e8cd74b070c8464ae8c1e3b7a0b63f22f8356ad999d26ff3af627b03f5f9a93fff6253b3d384372cf383144ae1680a1357dfc9dcffcb38c280ef0b9546cba114877b412c80d43cb2a7c5a0d6bdaff5caf9fd6fd31b9e2fa970b22774be1790f3504c3a7aad5134879afbb0a4e618329fa372a4422f51cb9e5f1cbe988a8880fd9dd4280927831bc1eaf35b21b82d2687a5922232c804d5f9f1396c0f7a7ed7892846e53398e6427a23517fc5c1e5e56883624c37b2e747dda1dfbb735ebc7168831946ce56953e8eee714d082309c9bb505fc94d20f50876a99c0d4cde85ba66d4b3040fc1bc3a53915f6da0454b655f2f28735694e1eff3ec801911ac893abbd5cd2137a824064dae17a948eada23ef70b2320a116c25e00d40acca4b0e37b6aec0aea113ecfcfeea6c7a1a70cfa3e8813e1fe0788dad27bab02f952841dc52a3a47d16510c14837aa2dfb53bacf043f115190500d23763cb564bdb9564b31975771122188f13078eb14a48e4fb198bf0b9a6948b879c3c7f06fc532b745b12ef03a285156fb272cb8bde18107c6846d56ae91811c430accaf015933bf9f1f4317cbad8d0acb28e256ccbc13007213cf3abc68dcb4d02e387c110fece3626594fd9b33e704ea59cf22d7a65dcbc4dd3964f73d28e89ed8fa79031d800f72cbea44ebb468ac32bab7d9ccb0685cadd767f4bfec74aef0be305c8b77e26a846a821c21546370f606131e3f4456c4fb2d74220264dd839be96ea3640a521543d614fe921f618773db1d4756430126644ead17e7d2652c7d825fdbabf78adcad95e0a97ed8f36babb4f2915be0ba6d14ae4786f37f5313114628c820e960e56ed924a2cf17f37250d4ee7d4823246bc9982f3340e77af1be73979d2cd54ca2c41a8868337c96f665b8c52469fa2e6c6a5c2163394be45b1f0bbdf348cf08409d57aded6677db49cb0c0e9ff412816acd98aac69ff0ca47693416964b68146afd25379f88fd4daf9704c6d9d0aab6f5bb61a4bc3254a46efbda39ed93e2c337535c7fa36fbacd3a1f445f95c4b28a1a1cbce181d991db9a6530284097ae8117442d8fc87e8e804f04394f2bdef61e21673471241935eb0cd0f8bced620767c800a4c6048151fd6c1accf13862d4a284d2acd99d4cfd48ae629ea4903c6a31f743e0dd6cfc947dcf6271c3d57e3ff6478aa7ceaa51b317df31ab234329402401a512c10cbd558b1c138cdcb39ba60dda6dbdde33100db183d4233b503e593fcbebcce57bf97a7844753257f656dab3ad143234d7a912d5f03e08833851da0bc26daf9b9977ed4a736baac01feabece7959b50af740942fa911fcf9ae022a61e72f78b813c507abf65eb1043e14f1ab4149c8c63480cc55e342626f47e311ee21e4817f3d8270467d0e990af900be0c2e7f689399e9981a574f739bdb4e6b9cff2237a01690cbdf56ad01d2e73957593e59f2852946f945570a7884d9fd4eaf026bfceea81ec42f1d840853e59d2350c9d5b24b1f1716641ef040e74d0d54c5e0ef46c5d174af02c35eaa0423430adfef76fbe2a4a0bba0f51388fd132acc27729a4d6c8a5239b994bc6ca4a8b43b62fa4bd8bcfd6976b9fae347d6699d4dcba350c03d5f37e2ef68894daeab71986127106e8fe5215e9e315b070d22b4db6f8ba83facf54e6acc8c13bbbb766bd6f9a023fd8e1d6e841459001cefc48147b707700385a16cd9984c80265af367d930c793abb0ad7afd3500112db941b38144338cdfe2aa8c11d2f3d50631bafca4efa402a706bc975ae46fee5fafaecd7998fc79d7c5b7d407c36251105b1efbead7b574ffba4bb2ee6fd1c91bae374a0e2feed52c9d69374c70c8f5b87d2a3ea0eb13d88388f7bc5ab38fde288ce7383ea7857cb4365f0fb903e0aec0937dce9eefa5eb481ffffb9d9a3afaa8e0c88a31e47c2b98a019547c5f53f7c8c19dcf8277b3d84270653c37d1b0e5c25fc5f08a3a99126d76e5e06caae89300569540698536ae890b3187b324ac3ae6f3a9d74d7206db926782576015e9b967ee759a7c9f469be278e8194241b78810346922afdbd55de6be39edb7f506307d8d20682cbceeadda2fbde7241cb4d985ac8ffe330613ca5b596de0eb5e8fa45a23130bb68d4f5cffbf70ea1adf2e68b8271c1f56618ebff27823a50c03e36de59085e3261f3cb31f72f2d82d5bb199517c73f6a3290635a903fb240ef4ed55b6c57b8b84e012672e7941f0fbd5da3a6ddfce63545d894cc39185fb95b97c714c3e430b696b5b1ac9aa438a5a958fe49e228e29377a4e4cf956e56c5d6497f4d6e4632afcc5358554cb32a241ebe2af047ada24fbe0e138548db889f479f6916ac46342b660bdb52b8b8cee027bbdfdfb66a82e0abf84e6cfd037c4fbeab57e31214312e440f6cbaca340bdd903b32e79c24528d18ef31c109246523e0ea44006e8daa04be05a20694f2dccabb4235f931ffebef70b69012824747cb8467cd02cc40998455a4aa68063cc420b480eedad252ad7520e456620e1ef31b24ad3c93572135fac1096d96c88a0b9fd8d5171244bc6388f1be665145efde6e5b9b4a8912a6a7d9b8b151cc63fb5d57c1b4bbd239f2128eff245a756a41432b0d21b9dd79fc882943096311432ae049fa28899562e50051df2bcb9a237f2239b2c7192dbecae80a1784af04a0f0182f1739812a36eebc978a0688a3ad47cf30def863d383c2a83da71fbe5363519a13a3949507ea966ec45f8b949294e650d2666639c306a8ee426077c63700641d08a3597620bcc735d5bfdc34bd33b2e3114a12ad605c6f75bc23d7a70af0563ab767e262c7318297c8fe80a46c7f3f028cc2034ff35d6e278df08187a1b7e9fc55c3cbf790faa2036448b5f04d874dd60bc92a2ff82a7c42946a0f532d18ac258f50402d89a0680c53ec9379f7ac99bacb30e2a0e753a330e62bd1e4e445c2fcafe5ad9c787f3e2244a917ad9a0ef1bf817bc5dc6df3bb2c8de6d76d00d2539f7c2ab91032d1904a5512d636b28e483e8345ce25aaacff63fd818eaadb578c53af3ad446763bbfac0b16fa2d518fefeb4231d3db1ff0ff3171f849ec211385b807829a30c49df4d9841785e55513fe7f8038de142ec89994825b68cdc8572f9cecab9e7b8920daaf3affd1cdb7a32f584935aafe45309e475f065b4510133fe1a7f64f9d041c9a8aafa8fd61fcf60dd6e7828d55fc6c9ea3ca92aea0c855728a85fa8d70e6a21431","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
