<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5839e23d6e3eeaa3a8405da4058c91129f1a3507bbab9b726d217ca12c1a4b86558c5da8abb79420f1a3bb0dcdec1a5ebadcb9aca6597f651a300a5641a12df387fef5da8984501a1c529b756ffb203f1a2cfb5aee0f35df0784796a028c0893acd5abef0b547cece91863d423117db1e7bfa8e50c618482f89bf8b6cf9e487926ac5524ca7467b3e45cf192c4b7d4407428b74606a7acc33747fd0b0b471948f545f2f9381cca3158bc20f0e9e0e1264732fb0b7f7269c2542a55d110ab7e803ee8d9d4c438f1b21989727ea66fa54593c09417053dd88022525608cdf5644cd60fa1b7faeeba218b42258837d9c2434ef830b3710a473c9e56480e652fca690f372d179e2a28596c6428c1595b0a036da5df87666edb46759f4c7fccca985cb0be334200ed6425a63de01d7a63e3db77dcc0a22e73e6c46a37bb61810fe064522681da69dd38b50263fab9dd71cdc1415bc39b5c0bd0e721258e8f4263ed4658b4aab9ce4e9787c0c386efbbc411735f6f0655e9b19c891015af6f813b1b96a816cf3b972b6729423134636dc6cb230bc538763c4507a3818f6abbf4e495317ef0466d30a93cd9497b80e4ac31732268cf28f6e2a32cdc1d80ede1ab5e34c94af1ae74b609b27858273f8f51018ffa66fd7d4b9b2102144d42cceb065515fe88a4dcc3b4f98335fde0beadc88a0818e8822ca40cf734b5db268723d650be879e7f16bec9a77cd4093516127cbade04745ab7ee3172711de1a2dd02489886eb949a4ddd11a62eb6f68dbcd4e0ff72f1e8a7b49251dc49796f179c6466abe8a61c98e29e3be00c16c6b7d469878e744ffe5b8cae4a3307bcc5a9b016236c63265ded2c01349a910aa1a88f7d8babb0b9aa8a4b6304578f7935880883e650ccc7dc7d80a43eb0e7676ff77a4a01a24ad679e7313c9cf46b71fb4ffcbc3fa52278003af4cf05426f46a3588b6ab1c4ad20cdf7a9f50cad8b2b617819f7d4d6517c7137597ee318f7d27acad9c27991a4f62d54ceccb3307916e41b89923fab9499795f7d42c640832b6658f152d4fd8adb0217cbb45d9094dd02f4387efcef22a21da21935bcea65cb7e96e44d30c0848d7565d87e6090bb8f33d617a886e4a3e0aea148cee770d24581ba14b0fd322bf865c1dba8b2a6ece3e1b7839879bf7844c7bb691c3f93e76062f4ca6ceb6262b959a5e1b73d410f137254467f36db83459513e1dee8bf9a99c1c80e948e8c6810e300a2d7d6d5df8bc1c4a73711febd4b598a028a440a3c4703f43beadda9c0f5041af972ab92229236b332141d406d3f927e468813a533018ca2f00ba150a25999d998ff46843a7c3a1113f864396be27b1bbc65f1a0559d3acf48347876b057aabebbfdb65b9e2159d7349e201ac0d3d1567307aa6956e44bb8d09521ead112a3a8e62608108dc33919fdefae55797e7ac19fa11a16342709474cfc8f676822a73db7e7b0f5eabc8c1ef0f8eedef16584e45bffb795b6e6cf55189ec61e2d8a8ae09ba3d610f22b36b2d4c0dd8a312dbf24696256087eb29ed1cd2bd92b81b74f61a0c691e5e72660ddc6bb3f5deced4bb0157ea2f1510d90828205ec65a2d9e06e05e53bdf807ac383233d1fdca32ac5ed844bfbfe8d1f68b6fb2921bf27b192ec3b04672931c8f63cbdfbababe6370d268b5b36a01cc71180e1fe6a1c18ecc5f6d86a62c6c197b2547a41ab943f3f1ef020ef1523a9a9f4d4f40c13426e8cf0ceffa45ed0bdd32e9fc7e7385e5e8909b55c21f2580e44365c4b6c9f48cf7dadf74eb8a2dcef486bd5b295d62e71e19c93b0418bb580d007f9fff041101d836eefeac57698b74924587127ddace83bf5b7aadf110016d3b107c223b50ce2a044cd2eb8cdf26eaffc7ba8b6d8f3a1d92285e2b6bbdd79cc4cf4afe2b90416a4b16f07ac42b44b8fb9f4cf8c8dfe8536b3525d11183504c4abec6aff120ec865775c08bed624ccc051dfbbc63920c05dcccdc127774b6587f63d12f63574a1d3adceff87fe24d547c9105f6aaca1d0ef3f61fd65dfbae5ca88efaaa58799bad8ab61e6930f7a5403865caf1e129dd046d24680f2933adec71ae5068d7577d49627a2d2fa2fa8ee6e97cf305770f9eb13371c6535095570e509a1d1f61ff6277830ec31c8971df78aee9576df89e44d928f5768a6ad2f7150f1b4248d89939bd6d1141c2b266155ed189c2f124585c1c52efd45316ee3fdcf0b2f1c7ee69ab3bb5022112205619d7a04c648106ecc973de423879d9e4fb44ccc99825925f4be73b8218326d1bb97c8c1cee77ec0b5dc9345bcf021895296f5ee9f626108f710b3e75e001458370b162dba00b6b91a73ac50efcd68560b39480a031b711731a29ffc68b2fccccbd1768731396bb8370916f106642772964fe03c0f1d275309ac6e348329cef07ac69756ee5cf20aaeb2d9d522a6242f5d6614ff5b225a85d55256d8b3d238ec4e70d531833f37f98477cdf467ec172dbd991b082cf8a418fa905bca20e8713cb7effbf62be6fd31d4d1792c44da20b729ca089b74a04505a014da4ab822b32cb87c4ca3698ac87b8963f0f0ccfcd1f99752122a81f991b4b4436a5ee1df3331e3eaa53da6b326418016243ec14065a01acd037e2abcd11f006bee28c1d735fac1b19836e41a1916416c8107c55b10904603d4087f8223e59aa935b172e25e486e25ae772ae2992ec208aa3ea8e73d7584467721ea1ee8c977f17d20eb55e65ad8ff93dab55630ddd4d9f8933a948a10f384e2d1b91fb0376f83a2a279a37ccf73b824443a1621da6a024d1af7bdbb7d8a3c07cd73df17018d3c006b6be56497b7572d6191e7154c4691fafc2f97ce7fe47251b6ddfa1564f7e22ffef9042d263ce563c1fdfa7777365bfa00fa9b01fd088dc8b7e29f2f4a9aa9ae5a60decab24df4dc1cfa22319aa87051e081e9bd3fca262ec0cd3bcba0f56cd45f1691d5a1b112b7bccd3d727b27670cf0be9406f392286415d1a0333dbaf12ffede4578b8962aa9d87ce3c94828817513a9e20431df05018e45a58786499c1cc03128996cf5979d847f87e33a2be916e83901a82ef801fe207c12834c3b9a6b866a43b61b094b3c2fea06f12f9ad672876f60dc2bc8fe1d7cea8d322f08124203da8f3fee0e2a4db71411d02ca70751075f0aa9e8aee21fbdaa06b46e93043ff971cb3424b6f23b9e3ac9407eaef9fb715c66dc40b66bf5b3d6ddf1d68b542339d1ace69418bede87b9ae303bbf22ebcb4d3456b5e3bf3df58937d3bf7bc3553067095edd072d427e86162b6d152c1e140307c1696b1d5c154cced3c16bdc8cd21e93dbbd7c247d07a66962c896fa6b9334ef25cabd18ff3cd7ff701b8ed2bf07a54ea6d3f15f4ba9f645752db1f639c6add7b33862b6f8eaeaaf1ac4803471dfd66879aaf3f383cf9e091f6a6208a37eb47d4800919aaaca2375e58ce8281e6fdd9426a90622ee709fef33f113355f8ca7a9f32520008fbb539256553c23fb477133db9f2aa443acf7e8a27702a66d0ad5968a4656e04f6be07a79b69853b17ebcca20ed327ec997b2730179d74aec3e98cb3634e32a1f653945fe2cd2e944476ef7e99afb9965c32fbc66b959071ed90735a9bd7fb2f09aea48bd06290f8428b61f34d197b034662287c97fefc8b843a2dd21e133e3cd3cd3105374e64234677eb1cea54414e1c3c06918a77f18ced6caf1672f02ccb024f13e87c6c834d4f60b29ff22da6f0e74644364ac4352e04d52183c03d32588378573ac3058651039d764908d1bbc342d4384bdd4ac5a1f387d295c04f1a2b3f58d97018bd6398de6f9d0e434fc6ea159ba343cb6c343aa9c8a1b93597559bee1cd1ea7ecd1bc71a6ba84d2ea012e3cb7f981639915e6e719e52098f7413f269b6abae60d051e37b61717a3c59b7aff89118b72d5195bd9b8ba8cc9ef2c36732b43cf43f700673c7bc2d2504fb4ed121fc012d0ff5bc400c62d3cb4b546989f91b08877106c768c39b2911ecb6a1928ae196018a40ef8ed30021b9fcf3644c7f7bf3ce908038bc266de5c208a4d014f09401bff03795e36172ffd6df717dced96992f9845b63c4b4e04374b75d3b482ca4b61fac3c8ecef16a914d942e874cd4aed752bc461febc9d0bdb60dc0524704bc489071a2e8f390b3206f83fd5b27861d43142030c77ecaa3ae3e4d4e8af264aba372a92fb1915ee2dd3764a090bd09039c16e0205c9edad72a9916af977524e125752074072c31774e1c4ec5452ff7dcf2355a567b17c10868291ee73b29e7b4cfc67a7d293c30795d42f9a0c8e71846857d75cd1cd14b6745306cd1e3147934e525d2b6e749d990bc9e87a57951984a60b0f27c68d05d2fc7ce900fb9ff5d1998536bbf4ddb6794d91e9a523fd64f45a742c4ed9607dcc1f3a9a3c9136a868bc30bd000a235ecf98fcb22457fc216c0e80f1ec6b627306a1f02f9843e309bb5d0054e91d961bb7adfcb6df0879c51c84b5e8289f6f6ca590689f931f93f8e784c6529a564dccdbd1e42d4569ea0923ecf2cd0afa468890ce5d9bf4c9f018abaf9b0a2eb5c402115b35e492f0b15a1421f29692d1a71e3c30a08948ebf7868526a145c0978cb80946fb1183818a6ab9b0773a91ffb9ad24d041e7a50a829a7756a49f3cfb6304792f5f1ab2829d2cde55db270cdf8576e559821e904d78ffb900a639c5536c9ab076fb81c7f2c4ab667a1df021ba69f44c977bb2d8fecb4cd15bce926a8d338c7b5c963e6408aa74489baf5b600e28e1895f631ef72e0c34fb9292973f5586ef2e8f0d7f3329ffed4fd3930e28e5ee2129c4c6f77bd1dfed21db9435aeae99d1ccdca4ddbe7cf95f967863ada2a800c3bdbfef8af53106297f2c7a07583ec93e2208663c305e1c72ff82655316ad11ab3177a4f25310dcc454ae7b2ad555e22b1f016c682b32d54a8145721e2a0ec96f866c702828d151e7a62c7bbca6b72b8ac74a5dbb3d91a0074337c677678996f269a02eb49fe9a50535338cdf9a49f5a5eb87ece50f983277a1120feca801b10a4ae265537fd17d86f882534781f62a1cae2afbae8fe2f8bed1297ffbeaafc31a472067a3b84b3807d115faf9caca3c3256e6bb381168c4acd6031c50d7e486548322218f8b705030e12e9538d84d2beba98529867032bf4b86ceb46d36a1e731d204cbc314901a49984a935346611e214160c95ddcb9570f9e41d50e52cf77134200751f280df5e7e6e34b4b01d23d81952c24179e9e8da0a98858a15d20d898d14e805f6544ac91db83e225dcc71c98e05837641bb0cab71995e3ffd1675cca326593a13d91ee2cffd423afe78f58a3a87d150efe79b461d41465bd9f2766a340ffa8eb73fc34f888ece71f41cb2188c0311e96b0f5872a177b75876a1b9eba62569fa0ca6e4c1b3f48a12ffd091759c7ba82acb3fa388f532a847210aedc3434fe17eb78569eec344064425c5643d76ba597756eb3e342b73641e37485ba6a078032892e97820dcf09e3e65813785029b481a602addaaddb869ea27d8ba1c5b6c22aee71c54a7deb3e1ace386764afa51367e0bf1f04dcf816e61149b1c53174bd27384f765799bbdd49315448c532c465b54a57692a7c52799f7cc3536560c0473ebceab76e581d0a6aa4d79f56975769e28d4b4d0aad7fa571d47045425b77ba59643b50b878f3b81ba3d5322b7d05137aeb5c9c8439e515fd187b43b78a836ed6a7afb8df9378d30c04f92ef7e3bf35798d2ac4a2120016c9d10a9ddda9dd2b069b304bb1347bd4b6ee32f1035cbf299f25eb1df7cd29cf2d7859e9855b9ee0784032c34c7125882269d8c662a4c86b30da37870145601317cdfd792d326579d13a81db1ef99aba0bc903c2eb674d46320b76015d5a1f28b7ddbcf2e3775781f7b54074330514f75fec85c81498b510ffce95401616556a750902a3fdba48d842431a782738ede2efda1d509e5abe37a26220795f85f981447e442f6e22d11641612e403d0dd604f3416c680a50a713b39d8ae0febe0f810c89fa415b9724f3b53659f5eb4188d5b1679faa9803f83cc7c284b2d6e92f1e5b178510fab82ac35a87b2c494071f9e48f73f61666629935ef94ce48b88bf633923d2ee69869306c867fabe919f8c7ddb6970839139a237e694e5bb1ae2f92b85bf0864a44ab63d5e525625da5c2c5f6078bb68224ea8054450cfb015d8cd44b11d24a2e20dae55b8a548efc98cc56e4e427e9332603c4c0049a4e8064f50de0b422cf35ca76c871cea2c0329c58c820d8f20dbd88bf09430e381840cf892ff81daa12122df3d09cbb01951a460e243df38addbd08d1284ecaff2e082073df29070aa2781f5465e12be244d1f8b818b3251b7540fd428c8be668b13e2c8c5a02a29529a7926100ee059022f675342e7275b3df2dd6d2d611da14d1c18d849fbd97446c8b8fd6bbc4728a5a3d3514aa1da33783ff6d12b5cccb0985d7bc6f39af086e82ecf656c19ab24f6387f6946cdb670842f88656642aa712a8811696f39892170fa7c362439feb0579382fee46e616e0f58715c23d5aa85c93692dcafea316721b0415900a00014caf10f0cfb4375ca136d16caa72036ca16883b3a256dbbda190471cead2095508b6e7d7ffc5bf41e469a92bbcc9a52f4862adc2c7ccc029b41367d11101b45d7ca3a300f431defe388ca1ee29d48e5ce2a4ff1e89b5fcff42407f83f0db5823b515d409db07517ee93761b7f03bd0f894c00d8bdb6cf3c53ef7158904477bff395ff3c81513f31abe9d778af9dc19432057e76f01a1a078f8e6534b1c8625c7d8be3a7bbd24c5940875fc018919ac0babc472c0c854ebebe701c02c54ebb144af3cac1620e5f34f16527fa36580675eaa53fc2a0d57817a8f02ed0bd4a079d0970582f453ce3fa6cb2da9138cfe87eb434b445e736cff1f9a71e2dea537e678c1437431245994ef7645f99fb3319c823ab4f5bffa2225b32f19a609e290a314f23ed853a46492e4fc09163be38bc82f5c3fff0835af3b32419749811727c6d2c2dfbcd92ada7a88e34afbd65277ebe3508f519312a5ec71a9febb38cb6e6ce8f95e7ce6e00c0af15fcf696a0e24d14d5f575673954ed1c49b7a8f68b849307c1b2b07dc32c7bd290251e161a6f87ecbf45c96445b48d41a6f8eb2f99fe631dc92cd5cb47c160a4fffcc8c9987207f6414e0200350455f278a3fa3831de38b3bcc4d804f97cec6e4abf926f6c50c15a624a5a7d4f8bfb5ada7faf685db0507647bb0262647d5271fcb27c858a5134c82e67863012c6f40c03230066544ae30b344c95e52b8a1350a909060cb3d14aa0c522effeec9b061fcfe686e0e3163936ad539b8a3c1e178bc1aeb50141d76b172869f20fbb2d2a5a0d3024438956e4bf359e6a057925882fd81c0f40f21714085da39bb184f7f17becf76abb0980f4ed1fc5da35de620815c35c6d5129fa7b975d28265b3e57306aa2f9da0e62e8a4653ab7a57227e3a2ee9515026b194790e7357524ced978bd4944b7989dcdd3322215f92b085e54bde98e09446893951acc5e65c69b202ac9b4c248a7f576115ed8e65c5f9cc7887d6cdcd755af17a76d0d963f98925dac6e3e1006adbc3069c848d563fe277ca337746618eb889d39212e6ac65bb0010372a98270d44dea200221cb79a3e4891b2d07ec5580af8ea252b289d729591cc3e9190c0134fd9b8daba102ed9f2e9c711b0d96b97cc26dcb423504c314f3b1b901b799be2112fdc21d89fcb9a3b506a1f851a2ec1244da2543d82eef5800f955dac94de488af1f045ed0b4b16075fc816c8f366799471a79db0a0e86e475b9a95623a55cdbb76d67d6cd661973902733ee8c655b6a245469a62bdcfcc284f973fb5e8d358d1120fb46dace3a655f6700eed3a536088144b8f512c9efbf8102c1ff91b2d6c691dd61c8db3afc974b84dd95aed265d99032c79d82dd4850e045b4a8c764b42b2c86db3cca34df6e26e4fdd269038ddd9a7654098d088f620337502a3e58e8aa8aff2acdb943fdde5fd8c8cef7e2da6ab7c830f86a49c1ed277e4d01444981668291a884252cfb476c092d7c7a7414e4d72c6f5a493ef4c052fb561ab49774b15c6acc3de7b55f27883c4016b4c67e6482522795f01618d5b20d8b59bd402687d7f07a23f6ac8000f62234efc831e73e766536f8c9f9d5d0844a5ffef5d45ab2f53041cde2e90f3d9096745714a9a40ea1aab750cdb54db81bcdd577d4e0ee85646c2a274a9be11bf035d3deae88f6075b5aa4537f2966332d0a3e02dcfb342e3563e64ceeea945a8af17ee436e17bc566a4ab096747fea372e0997977b1ddeb658b5ef8f57f874494d28d8a324cc93dc0f1b12f51f4bc777284ce999ec2e1aa192d28982e669e3c166a4ac3510a63e3a9198e32dc0ec17153ff3aedaed145df7372df38d58033058cbcb30cbb4b6aade3b9258a4841e6f3bb1aba675e5d2f3b74c7906dd344c4a081cab6af4a14759cf4e5b1d6b1f777b67b38fa3b6ffdec6d4d15464a05f408f21ea5186d4395484752f264ca41290866c8cb1c0c6d6a4bf62325e559f227a0c82011e2aec88580775107710f60a52e01472c8fdda911f25d146f9f6eada708164729b4877d77c198a81d35a83e062e0536b5cc802e8ae3e81350ea6d83fd854d0e9b27a34eb0c7b1cd25005aa484f1a79d14be268d751706063b1f3b48ac3e705c096831ea36200ec5c27cc5de78c9c3927711ab708846a6200987cc690bfe6040dc2ffe8eda4039d6486d365537fc922c85a8ba82ca03acf0bab6a108cc923a1bb5a571e6f9cecaec64d92b5a002ef13327c7dd7cdc7db8a87ba27f2ff5bc29e93f95bc0dff5e98f736b71351b8060a16269e1bc19beef8245bb223222a4df96e1b3a9b5b15f86a6039243deed02fcf061a9831e4302536f4d5d68b5f8f925e510397b65c33d2c60def09589895fd5d85f8fa539c8268f255a05970472695eade93f90ca1def08722c7c5681985e422e132222e0e28633058d468d9b8f9ca8d1ce395fc5be367847e38d9bf863e30444a51e2ee0f691119b308083d76b17f1564eafafe63ce4a8e12eb750c5deb7aacc76b814826543e5c0551dddc6344fedee66fe68eddb4a9a69cb17725d80d8186d2353ce048641ee5ce7ee12e491611feb17a7fc4ed961cd657559209689a09e4d8e0d38676960f114d539cd8f88ecca51ba4f09f83a82cd1f454bfa913213c616b216f133392a3849b920ddeaf0329b98fdcc5602edf00cc88d91f2d412d63ef1c5f4697dab07e6667630ebb8d39bc2caa1df1989c5df2952fb5fdc99de249f32d8df1e2d6ec1f6cea051dd44fc7b1f88bd157454cf212aa7c379f9158ca16cc476012c4e3769e51f0c996cf4c17f081c32ce30e3e5fa473dbc59aba2f9ecd400b0b3ce7f993229f2fc9a969689949842e7c4658aee19acc1c186be9e1271649822c7f9a83abf10460546edf7a82fec57c97e2390568aae5439205f98f566e06b4a6ee9496b8728c27e86e1b49422cbefdbadb102c6f072b35e605f639f526accc0b8f38c33d0108e1cf8134a6a4baa7204aa1a76cf960c0d75c37b26a5543d4cbe23fef82b4db47c0ddbafee52cd2d2b2f30616b6b592d3f438e60890c46002aab97cd9daad3adb5a88fd2146f1531e842001dda94d8be471f6c230fdafdb3e2df5553e70aa4274fe5d018cc47737f38932b1fd0390f7d476fe7df3fa8d5a0912060dc10837de861a8f687ee18e1346d2e6c83a1f02eadb7248c2a6345a7a26e2ac92fca77141c83f75ace00e5e50f0cfd8c19a8cd345b17f2a4a31774830a689e38f9afbe21eb08e26f29d14c7925bcc84474c00244b03839e6e19af59786716da9ac29944aca2622f4c99eaea3cdc767284bbdcb8a11b1ba4f7e30ae83bbe3831023f08b23d6bd8e58c4c095ea2fdcd954d2244df9a78a2861a09829730602eea5fe2db4f1db6600ff51d19b5cd19cc58010808eecbd18a6d97260cc651d8e2cee483af93414261ca340956000051bcd1c8793597faed99878dce1f54be6f4e0a547763142701818c83e5793acc6300c9fdbb6cf3c1d8f5b30cd2795c81463bf78ce41d91d3617368fd0b63a3ad4444312eb6c5a475d024e69adedf916354b6425ece0d0f088bfd8d02cec1fe2582ae5ac21a424757901889ec0f460d6604e9b0cb31b37edc3058f39611ba24d94040351bdf4a4fd5a88794acdc8fa423a55369ab1947853fb27a4bcfd7413e1adf5321276b94ee33deaf4d7c92f86a595f4d2a4d4df3b4bce879037cce994a2013c2f2ee2f67a84db5cb6775b78f7f36a3a01c0f65003e3e1ab2bded29e512f39fd6478cf8e58d7639ceba7fc257b7f632b1f1589e5ebddb17809f7ab3689d1c8133be8a8ffe76f7202d1e3d4c2f800406ca522e02da3594afa77c777db8085268157feabdd947de4a883bdafd0db262fca3e7691be5502f2c7a1b1e802d2386bbba1654e068d43aea5e67468eb63898573fde5602fbee79036e082609dc27710486602c086964868aa917d5633bb4d2548cccf921481ed2ea194d9b62711ac9bc1c3b4e20d7a2f235590b4e4916048c79bed2df2deb5dfe041e62f385465015de0319fdda6c6aaa809b27bad4a928c267920422c8902a0536a35668f1b1ff25feca532e5f6a4427863a1c186d35c8f7b9a3fb8304f361c32b63545627805177476c9359bcf0b1ee3cda3731e74867de6d15128d03db357c46c428e69afe5b6f7f5d8ca4a504d30118b4f40d9249b70f5dd2e248371f2c2cfccca0b8cbe316be71a4e30e3ed5620c83ad75f1fbf21a59f8ab659e2f8da9a23d0a8afc70c9955d6605bea78535778422784dc2bad99804d86c1ea9e7f8f3a818dbe27cd1dcb3d0bae8e39f9c3db7c2a9aa72666fdfcd55dfb60e45dd9be1b5411de7573d7bc9229ece18a18e98b97de2d1b8d1dcf2169d2a4039d6832c89039d49e736cebb8b2d77bb77a7b1c77d3234ffcc14c3899873147afef5f0b0e067f395e043ad68bd19b19e52a62c303748c809ae191576dc8484c0e294a5bc838ff0bdd7f69142c4ba60fcd38a81cd24c56e132219279b4d2b8728a31cd4677791279fa53b939795e434fd6fb22d85ca44fd22ef2692e9b3bc39c87b033541084cfe4b7bddaf858070ec9eb5df71bfd82527c27bcf78ebddfc96c7983165b10b37a6534c4ffc6aa127ddaf50e76f20ed2f284736cc0458d212cc2aab7becf4b474e5e4500e11251331540b20bfe28fc1766b1e4bb23c528041de633a05e6a1d27990980183c6b72f50acd1f9c102ab17a828222a39eb80aedd1411715bd16fbe271cbaa8db9db2ea4590ff50e44bf9b2631e92da38508b197976e4c455112dde735b80765fa46da25b74783ddd311c5672cf1b2dbeaa508a75de621e8fe86e106111b1fad1e831b9dc140ee111718986e2a936c2d5255997aa4e0984b9897feffea5c9bb0e107321229b4728381a30e7083b5a0592431166838b649216b270d2ea263fd695592ead77aa1f13d93de60d445edd089f45e0dffc1721c686b4259d4f949e2efed33d4089b110fa11514ec60c948eb678afff288ea449b9c54ccc6138aed55f843523ee4e39144f1f6e4f9fcec95cd0a5f6083adb401126e79870cbed47fadcca62225f1e3af8d663102d20faf6fa11cc26c18b86f569ad95aedb9de0ec66341a0371d35cd0119c1ff325e63ef2b3306476a4071d4ecf82ff046170b3eaa6f78acd07ab64629fa6082961cf09e904028a59bfeae69c6152e2515eda4992b6cec827897a9b8d5b805a17a61fd5ce734ff15bdc556dcfeb54cb62a8c13807d7c7f373f2561f9c027b21908ed5debb1d5a9e186047afa58b782bf4d1c9b3e83f0188b13ec7f9346908431fea9d093577e39cb3683c7d68b35c2bb4fd7ea6faebd6cc83d183cbe940c5576772e128ed46470f73d66f1be3007148f4a1fe2f8f68b006aa1749e0b7762fa67c677a8b9b3edcfbd9285a3fee98ca3cb74f9c792c9b682970b0e8dcd9c90f12a3835777833ace760960a266610f36d1f353df58354e6d64444b9b57a9f38e167bda6918e96bdf739c03e427fd4c074b21418179833674bc1e1b042c357e3711f380c70521e881eb4c4abd7d52c68b0b29c68d7cacb0b5989ebdf7b19b18a1f4f5428be61ea5db4a341f3d1822bd153f4a817a74bff3d31c358d6280129d0215d551fac8d48596ea30b7209272098e6bcd03469445fbc9a86188dbd357ecef625af7e6b7b6fb2153f449dda3e9b58a1746a00df8fcdb7bfbc00c23801f19311059571670b914618b6f2fa5a43d5df4b08650a1085f2408e0c1a77abf0f0abab7a272584ff450f2a027be11f2479490e26bcab01dc85eeccc49d1746abc90bbae730c987575558944ae505fd39dd0ae0b1d83893819174552fe8f660cdc3af25679a382c48d99711e216cd8de92888aa3c99a4b47f50fd79629a2490bdabe259be65ba4f2abdd4e2e8592d28163ca6d8afc3293111308d644b6766569017e77e94c57ae2379c36ef0524a02e641d1dd70911ac5f72404ea933330ac7b22b45a519d38e14152cb0fe7201ef7b02a1c7afab193aba328d3c35de3f69d9043aefed304cf239cbf37397edf560c87e0541dd6350097e9419734fa893f07a23b8dbe0f70bf2ea6f007e30142d31b134b4a04d7e246bd45862359dcd89764527255b52e2423ba323d7e58fb6a4f0d0db1a714e6b5f262af4d9bc093a6d864a16a3f278dda8f5d0172776c9ad745910c3a724c3d5a80ab840faa7383254fc3bfda806c5524c6bf8a2165f93975a42f7dd7e829a9c10e82ce7971652165acafb7cee154bbcabbb5612f1715975425b82b4ef1b1c5a9ec7631b1daf38b5f02cc655c099c2667d95f18540af98a2812a3ba23f992c09451ed55b6e5aebc32f0aeef2dbbd3bdf9aa7f266e26f7afb86afc9aab3a79b1933c488195bc18cabb2781c3921f4f31251de9a50b9d240b50766fd32bb26f317370d9797b2990b030a35b438b11e2b1869857986ee84de68402ac891fa0f163fcf4f9a16dc721f764817f20f4296f3bdafad256d7074fc6ea175c694e15fc357c6d52ecadba53211947db45707bd420f79aaac3c16d0d6b6c45dd2cab2949a4351809139b621f2998e0c9c38662b1c0cde87c514da98d0b3403628410770ddbdebd68c0a0762614ca270b32fab716a09f370eb8f08a4de966ca57470b86730130323396264a47c65a62dd82c46d0de508b91252ff428a301f840470f2d6c82fe844f23b7873e06ebd456582b8fe8a04ac71d56b2dea2f37aa5c0c61001bb264a39a974addc499c867508bb0f3d09fa1dd0240e144b9f57a049c7bc15bf56f254e1f12bd2964d1fee69c7e6abfd1943b3443dfe4068fe5f089f6c8ad398251fbb1e33008d2bbb07bd1920a68e16210d7e64de9200afc877d321c979545dafb92950fdc5f1608eddaeb264206b3c7103991112c23a3b8699bde81958f1abfba5f3ed454f0af19aa511bdd88928c4289de601e591d8d810c82ff0f50a62140508965978e9f64e602a0cb2feb04080e17c6efb58a384ba3f3278cb476d662180bc4baa27bb372895dedb47360ccca76434f534909a03afb7d61e60fdbee91acccf855c74c7c92313574ecdb3d71db4de5f3ddfd3adf6c79a0a0b7fa78aade5f2554c80d2ef3899977ee55df305d048b6c7146e7075a28148488f47932cdf05e9bd864aedf2122e201712cc1786d4d12cfa2ec8fcdb0116d88e7c8e74a858ac842a329e619874f613791826c708dd7f40064c8b1499688be3f5c8144e41284fbec4836e954fbf99c9257da5acd6f005de90ce7918a93961ef93fddbe0fa4dbd0bf405c9bafd679f1392a63c2caf21658781bbd523d2bac91e71608b622e3c2773bd8448406623a6ab7da1c149da5bc81a59735add11d5ee9048e9bc97792f71e816fc006837d7775d63b27329e4d2d20c4b5399c3a5185ff9253546c9501d0faa6543187a9d5032fb5b0eba9cde2a94dfdc2d9b9848804c09ecfe8426aa955599ba4f5995272cafdd5bead51b64dca03a60e76245c21181860ee3eea438fa800d8bb185dc6999cfffdda64ce0ff2e73373ac172963cd0f0de41ac1fbd12ec9db11b270f7a372bae77ee6e176c9942d9f3da908ea1d046999c2002f9b38f3c666853c63b06a8d3efab660c64b04ad26ba3ec523728a856f66a0dedd34cdfdb21cca6318d2d91bab29577f3e4bd6f6cdb973895d4ee37f65a7398980db9a1cd83fc779b4825f5a4f854afbb4fdb8efd18931a822cf05080a53bd46fc392f69e144256a7ce17dbca272bc92d0d6274bb72439914cede1084bfb6bdd13b74e05c4094917327255eae1be2b970282556fc8bfff566e8c3e498ef1f01882b5a69fc09a87463f3c26dc0515a317f62b69ef7c8a77786e2f529329eedba97351555e4c03273386788ef57f0b4a6601f4dcec917998ff86bb976997ddbb555f8ea20ea0d6862954bec72c193ac7a1e5e91e1a0d2820d95592de28045cfbbd76efce3f13985293fdc7718669d2a9e3ab50b9dcad6b052c4c52a5441cebb82ecf621caa7afd61becf87764523f78954d3e39f7487f80331def541612f3ebb01a560be17b65438fbc635d41ca0b1c65202652c6ed8574ef47514b728edfe08184141cee2956ad880e267c9f0b871cc3a93da722965a9605ba0680ade8fdd6b7610695f802876dc62ecb07acb94d4168889704cd6702405e5e0fecf6c4bfff90ba4dfb97bbb268fe911514eb0d5c252fcf8635d1f8d1c7c9d6dd4ea640543ee7244f7b65a171fb5f7215044bd209095000d7cfc1b53a953982abacfc6df7d939397219d82461cfc37b0dedbfa27838bb1f1249d176a821f5b7b4aad4828930239cf8bffbeb56c7088f788019053becd11667b38dfea007f040458a1aeb850a4dbeb4c46edc750ef3af1da0c1092e9be281e80f414fbf50a0dc6982c2a9d2e9f87d245a0b8474486003a57ee03074d0bec5a86f66202e1f8c7cdd9b71f0128fd77c90043bf6ea2f80873276bc78a6fd48c8b4e444817fb4ec41367df0704bdeeaf9722d9d9a7366998fbc90125ca2266839e1f5cf97b5e0bca2a683ee5a1876222d429d6314ff31fd097e8c6dbfa9ba931680caceab5980aab0d7276829dd67fb567f55933ae88e48bece0cfeb56b7dc952156c9f31936a525f310f972b5447cff7bcf2765c88cdfa9ec0530cbefce44ae336d366086eaa53d89c01bae7106280ebd08b7c8c8f17a520a206eaf8e7dad9cc73793eb96686c18a1d1593769e06eb5b1230c8e97e52b1f73a6869eae901506bd4c50a24b5667de2c13525f0b614a43c705fb5405e66dd9e1f85207d2af5969a63d998d5a92e7f7e417ed0693b0cbd1ced9a3f417c1338098990a3d62a5cbb6a11396947a68d1301f431b624cf76816e1d32b930220a209d96d9d1522baefd399dc0b455edf306cdb053d6fa770f362ee6414f1efa631a2a846ee458744c2e2edd1fa9555e5ec9c40d51522780aaad4fa8d75fe9237b198eda1ed7409d9e86a89cc5c6ea8a39319940c7f1b53c9cc908435d34608e8410b316304fbbc7fa2131618b001f020dc5f25dd6c4180aff6789be5753dcab101fd3e2609e9ef767fcfc480607d0b50eebab88a1f004923eba2a8320250614bc2d9e7e4cb1c8b49136cd5792cc9cda6098fd55cb9910afec9958d2ad1be5ac1275a135f1d757a1827afaa3696a16475f3051335c36448a196854dff00af9c3270149e040b6c8822640ac767c475f8cd6c618d919c0111617a319f371da8985f647ed22d302003c1ebe35f12efb3d45c208a3b47d05c170557825cc7526e804a934f0dd6b41bb58bc540bf8d889ea8f385fd9c5694a27dfc3442675fda2a9ee20ab7ce8e87843dab34ac7f828e1ef36e7c3763fa9c8a610b076bb246d1a32e0f6d0b5ba96e712e782278c5436e0a0ae21cc8d772fd904c0771f4548e1a98e146dfe05259cc66e1fc0ab4ac6ed6651aba0096753c49af67e33a24dd909b304933d110a2e90b86fde7474cac7ac756ef6e07161260237aac7e9fe9591eff70e0abdb4fc0f0c8a904bf56472084e24739e55623296881dbf9715abc7fc9d1f30f4359abdc2b94d602c127c8c0812202d62b1b3dc3c3e6b9a39c9e3cc4561076e883f1a3c3d4ad00b40d2e838bb4dbd3e15f1e70d8ccf4afa02a9a7bfdcd2c022c4e552263fddcc1c4e3fe1a3dc6f184b26bc3437fc73aca7c03f4df15d294291b4647a8e8ad0e00f2e0b4ebe5735288d717c92c2cb4a394a75c3b04e2c8db2b17fd248fd2d2ca8880a560c39469f8e2906362d2e6dc6d4f0dd19da475a7de8240bf95119c74e3a266bb34e0be26aeb2b5b20325b8a5b2f4df101e75a25d9b06fc23d2dd2bcd2d591b1b78a5dc4690224ff97be4cbc77be12132e0d38d9e158a1cec8118c62cf4ddc0dab9c8b3638d7f3dcfc0866bbfbe6741184df0932cc4c293eb8278360a4fc0ea3ba8ad7ac44537403b3d4909ea6830b2b62b84c3d1226413c7c86e8bc3c58542b73269117b1aa930fc669708ebf527e6db451fdfd9db100a657be53db3f2f308ddf767c6465ba4d1ce4003bc5b949384dfdcb536f3d4a0b1e475d3af9d8aeb8525ef5cef40fed87aa7572da2eb2c3d054a4151bc8769e741444a04b413f2dbe0ed7389c345a57eba1867ee0970e5d4726f4da207951a30e9e74077b8d9c4768d9c155e32aab2d5969d48adb78b8afcad5675c194c7e04f0affa166d570d89cc0cd5e9d5761bf5864d7147f6ba3d33a561f7855818dc79136e15eb21319fea79407de26ba597a75aa3b94af4099cad1d4106dbd5b3d142fc3a7fc8ef8db5176a7cacd6f06e67692cf4b860bfc4fea9e4202f79564e3b1336b1d9637b4e19d5eea712c0c05057a4db38220dbc4f28f404539b7d71bb1cba274651d76dc07f6ad137ce210f7df6ab6930444a90578424a2e022111bc4839c81e04938b4cec5a292c777529e86ea16ca36de640af7ccffaef8ddb0a0e1c648b348182264ff7c42f62e04fb860e3063a985863035e1bc65a8bd4af755cfd3d981a11fd844b7f7994e0e2c1889674e233c7b053319fc28523ce18bec707bdf318c03ee2e8b3c4515d01feec99d3b18c1424d5b8df1e4db9ad605f21629adce98f1d800c117404c23797762b5edd075adab97a243b7055b49ed466ba0c3a0bb7cd7adb3e20bd8cd0fa741542e4276cc869ecdd8d95035c548f974ab324df2795d57c3ee2995414b5266f0126d764820d5adbd35591f7b1ad6a1f845147aec97d70db21c45c5a55db47e0500fa175e3f66f5b852d5d2aa2f1dbd55552b601c52173cba67534905f4c71351cc46266f36546381d2ef7cd7398c3a9ee173ac31db8f9e19b7f03f8389b1b43e5091bc0fc5e9bdb0c2781ef71fbbbc07b741f5f9ee0a225929fc5d302b04cf046f0ab9cde98c5630e2ca1a4104c82b382b9813dc74a28e7eb3caac2594c3b7af02b3eec5de86500ea71177fb9a8756905b0f6d80f8a9e38babd0df91fa4996a9f6493184fcdf7658654b2b023a5b5aa332242086337dff20d90b98fede7a23c76ba085829bb6e9f4e33265ea827248d6e7c4e769aace4152fc7388f969e1723e024ffd90fa78de41afa77d679e2e8d96010f629f330b3e4fa91d847f29a8e72f82edd8862e88c7df0bf20882f8a5b379186c62ce41b7f5d965887b7dbcaa76f3b0de91ba454bbfdfc5573d748d1e87a82da13bea3f8165dddb2e4e5da3a80aa89b83f503ac4795f94995d8a4bb7cd5bd2b3e08a35a5808a7ea170017cbfed85901e43c9f4d86553153ca77a7c2b00c5b153a144965b559aa2e9eca151c7ef31dd9d0e6cd2a08f17a0fabb7bf6153bd7ba10a94bb618c4bd66028004b9912201d76efb89fa3ceaea72304aaab103fccf431704fa6c3c4b98556dc72b72267ec19ddf7ff88c42467acfcf1752ea65467c2b6eda66a5f84efebf327c8f895721a3be6cd78eb6b8ff956f25be03454d9d34d19d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
