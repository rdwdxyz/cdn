<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a47b33dd759f235b28a45e535db68926c996c17a9c24fd3e82c4e0eeb4886d8d913dca5b29f77ed4ca623794b7f5e50018f47abfc1b2fd49253abcf0b7580ed22970324f3a48077ae1626250a6a6547111ecd2641df9e3074b540e7a710c9d5f9246e6beb06600cd7aeeeae538a8b735ee7f4784dcb03b803284006a63eb0f0fafac1a6c6df329c51ced7ceea2f1897309d940bb6c29f405675e2414f9986331e2f7b6c3dee9540fb85669f2ddf925ed7ee9f9b4fdb359bde05e5349ec08d0c266d9d51c13cf6f868f3fabd936c98083ee4d2635cceeec8a2214d5bfb3ff1dd78a4371c0afc81684ab3acf177f2e2a4101074992ad1438d804956db1a40ea0260f4da31e18d77197f5dd041c73c30ea4bf9ad748670a4f6677b6a28509c76273e3ed5b07bd8952ccea314e8dc04ee36cc7323afcfd62ee8a050c61e97f3d716a90856c06604ff4b6b8f15b1d6f412ffc2f7ef23b031528f2e8e5d3e7990106c018bcf01d494925cdac857c888d44a2defcee29ab5f5319dee653d915709fc6d8dfd94f3f680fbccdad161b362c8ed879634e100c28f365b1fd4e4d06382961a617e6f8444d04650b2d4e49929e58102a467812ae70489c95fff292ef98d2ffd8d1a991e5606d61c211f14a0ecf4e45210f93e749212e3537ab217f072d0f8221f47b889a203cbf39b93bc5fd1b24c7a28f74b7b40bf02a56e902514601ad0cbe499a8f0370b37f3536a889512812629117fae0395e2145cc03833be6611a8d5b29d432231b896ad0036bb62d871733dba6556511d0251e13e00700b5acdc0d5fd084cc2471e5dca1be484dd5a357e0b77fdd24148420a7af9d663e5d292c0c0c20ef6fd4f21e095aa0fbc355a450ac13ec34f06bb6becf9a6baa6bb10e13333f30f62ed5fd2147871f121e693e1ba83ae52061cf433f6072f07a2b51f0371c621ab56a0032d86959a7db6a49b352076a7bb59889f07edb61e31bdd0e0ecd11b7c1d2a9998b1652daad70b4743b72f4e16f86c369b007764e23b634cc2e84b0e3d3d923f1692539c379c322087e5357ac737272be09e99316e2622bf6c241d1f3aa5ad6141b3900ed85cd32aa46e711696f110df35a2637b7a50dfdfd8e30a1fc0afede00a9d831ff77ebee6cfef077e3d2c2bcd0ad655c352a33fd23013e1fc5f74740438ed1ab2eee42535b0748281474077313d2819074608b0b72711f9c1ae3c4a1900e572b5eacc4830a3a6e20300f24a7af3d4274de322a2259ba24e1f6213371ab0b34aabc1ca088d336d56e46d8581b405d165f34a77ecb39c4f64c922195752c36c997c6026e51a97f1d5b478ad2458d4eb9a4fe836b4ddaf0ec638c9d0689fc4c621419540ffe4bfc1ee02c3f942f3eb9421b03a9ac9e420a30d4d5ccb99bb87e6ed8dcc6afb9983f0aa8f4978bfb71ab3ec826f6857e5f3df40f224782f83c86298c6b75a8e417b83a4118b5eddf963dd42abef600aebb4a279b40a4585c8353c4325df7a34551746782f3a47beb4f74ff826fa63459ccbb0e55fb614fe4736c2107e0c98ea0aa45508ca0c5c0c315504cd050f6245534f2cb1647aa7af12d7baf54d340b103cde4b23b99f4bdf4e50c45e297c8473b56073d613988dd1923e5b90d294dc2fddd60359c39e0c3d4ef015578659b2ca28dc7316766a60e4bc731fe2921218b3b5fc8c8ff25a6458b30cd687e0706d220408a6a8772e4c0776ae5e329457401015ab6e61c74adc3c91cf1ad22cd40f8d1608a55a68761d8f1491d8c1604047fde7e30e7d7b2fd684935bf26c762e85ef5bbeef65c0c56555bded5b1e97a70ae7d2105f7ecb72f163f233e92b8341f6091fc79b7249ee61af0caa4df1e82b516ca50f4fc1b7ccb606d533298ded2ef47fe19c4d0b53bdd1810732f4f208f7cf2966f720a1f6e9fd8af65ca861e7fb2af1d60fa0528a8c1cd056b594d1860019cd4b848f0d8fdb95a66fe33dca6e586c1010df7d4de48cca0c0c08eac56b0c3817f4eb88dc62aee26579431252455febcb6ef96e14e38e75183792b407f6addd1a16b8208dfa25d287f58dfcdf74ee845e9af7efb25b548b5b8c39473fd002cb8ac32017ccffb0d5fe19809e2a0329ee1044d0dc526a1bb5faee912cb065f961493c0f19ec2f945ca06e5a8a8aac181b6d2d2ffd23ca8218b639ce6d67faaaadafd4d9c1f54bb46469ec423ab2e2067772725c885dfcd9a1bb3d447472d0aef484bdcabd60d1d85384c53181b2c63bbead23944945d5ab0e3a798b87aca7afad49171f00b0dbeed033a8da491ab74dfe2d30f218d23d8492edd34aa6cefb6ad5a0d4a9e9e764f82315106c2c5032b0588d8466dd719bb4d1e12e47bc230da5b7f931b9032564894eada7704b4c199669c2e9fc519313395c343c70d516c241f72cc39e4c62e7e8b9345d96b84c542bdadeef04f31cd789eb3000a4d3f2b387d57d12cd471e9655bfefb01c6b7dcf44da35f353d43fa7c7909c3251ac27d092d1a65afbae334ffeb1b76ca31d05539160796156f4e533bea7732546c0b05704359786f2ecfa3d28ec1b2b3ba6815bb4143f44819d7657454eb91427f115e1e8e6e6ce690dcef115f5a184c9258a2b15d87136dca022a1949b28e40f280fee8491d62f8cfb508558013b0d316a85ecaf63c074a51d7a12bd631a3df1be52bf787e6636ff0a973e442e2b710c91988fd8e32664a23108ad034ea953b1edd91c30184886ce266cbff706efd576080deef3081f24276a435113ed0b1f61a14c004f68f567abfde4ea514d66b08c960439c326b854b694e2ff3c013435b04d76584dcaf71131bb41d27dc75029190a4204106254ddd2772b874708e8aaea12c3e975499676b604cf1ff866b1702201937eade5c6f2a0354350c791ad93b8b874bc9e922a5c2c94d25e423f7c2ca0db46f948ef3c012d8f0b7a3461b02b023082765d3bf9921028f0fa5f670097186e4605672387094388053526006ecbabf79eed0b86961a2f3e90574a1dac0277e998f3e128a254719d269bd875d883da7e27d7d8e0581d9f473ce5d84d818cc88d3f0414827b93cfc9b7d896cdb43f04fcb9d01841a9939ccafe72bd10f8fc117883785d26714322e0146cf630d0957bd2a4489c02baf48fa9210c692edc024d94ebad1ed3c3c09ef1e32f963588c4eecc57a4d497a87b90ac00c4ce5e279421191520f1218c589941e31ca7596810a483d56442639b301a92efe50ce85ed4f9515237c4027b78606fa094fae7c13f59476539682f7c020a1446390b8570410d3c511b65f5b8f53b82bbe989244dccfbb5b0cf9c8cf3ab1dec913180690743ae9634991cac003afa325fcfb2908749251eac42be34cee8c8091d1562f28e3bde5d90b360b2e2626bf1360b95e6c0424cd51495cb2327ecf33a32e7509f1962719b62df30dc12ae6c4cdc37883d89da50eaad15f81734d9860377893ced440c02117889b042c243e23a9b90ee830f43852b4e20f52f5f0dbceb87d251cdd6a77beda48c338a1bda5ae1ec2345ad90fe8fa4222430a05250414f19afb45d9590bff97b266708cfafdb3613e340153f9f82558096678504a57b339a6edb692292afe64bb1c6ff4abf668f5a9fe51de7a41869a929a90904dc24894055ea4d266b461ce975520a46471b210ca4a542da9f18f749977a681e5560b9fccfa0c9d0b95bb57b8b6bf26f98ab0bc703b3dffcc6314e277cfee4a609bf8a1c7c8ebeb209aef3be1e862edf9b44598ccd950080e94f4073f4a9c7e2f1c49cc1520c8a634728ca88177bad2cd9ec047003fb903339bfb84ead64ab195f8b2d13e716b09111fe36ad8c73a77a71b942a4c4c264eba6a9577c6711855769e32b74b86f10c3e7ab8966685979e77bd1fde926cd55ff7388a9f48af2241268fffe7827096d297a84e20b2ac252f6edd67502ee708fdeb47b725eb5d70f04e15a43846b763d4c9e8ce2868c5dba675d85f2c833ed6ec9cdf8d8a15664476e27b8ea9a2978bae722bdbcec546e340a835339447953b11cee91055f2fab1874e667b04d5dc3385dabe1e47f662a72d6a311842bd04adbc0151d9138ce21e253605db215ab683a0724c85c868bccfec5cc87f4c4930b59d004fc6c543ab0fb0b8243f3a54979bd00914f9095890bf34d16f398658b1fcf93dc82c1b5dce2a1d5c15db4822062a9a8949b4304d262cbb0e5567e55945ec160009b756d2c58db15eeea4b82d20fcd70d7a7bdfb897451ae0b3d54b5179915e779d23db69bf81356e288945ac66354f17593351ee780121a10b083b4df576c728119ba92b1524a6497472af3666a12a935309937879a49608c06419c83dcebd6a4288b07b60e76a9199c2d484986a188db2cf2232e360281fbba3c091555d61fc3ab291fcf63598cdceaad2ed9a20ca499366a801be5733787457c4fc2b734693a0ad02cf38469658dd50eb66d2f9451c0de1a0424c85b5a6eb5d7ac06761bf34eebbaff21a9a93f50f3f08e02becabf8b2f2cc79f293af872429e33978056caa3511efa05ebc093c031b1fcdff9c8a9ff34a45b6c5f4dc1896028eb2b6d86d6a45f54d5c108c73026a9b3cf7bbc850ea9fd1053b24bb6863f02174ab4691d4ff71858cb5903b8501fdb88ecd739195d231e4ff59aa88d85d859440ff0525ef451fc13ff5bdbdf0a556347e26f12428e4e8aa6d4d11ced3f689c0b852b12e458c4a975eef5c40e9009ad7ddf17f3384b301260de7166c0c2e75a32ad51eba0b5e3cad9d2b51e02f178dd6216883f94103e9f834c9cd7970df75d172ff6ac665cbea92ad2c32cf4349d2b894cf36896b886864e2bee8851f406aecd68bb35277c25ca517a9bb23cef16cd2e8738659ab5aa45207257c38a1af0133ed13c6e64b76f3a0b6193020e4b252d52d8c1a2bd809c2f581dcf2c3701b5d5ef32f44c2a720b7b533eaa4e13d0cee909c9388822e98689509886aee3e54ca08dd7b40da50ed75ac82580e0728031660d4b509679fbfb907608ab04aff61261c2419956b047175947d6981695202eb28c8e8e4c0665245d74c0687f24d897283c7155bad804ff86877c7c49d158fe316cd130a06db2941db48e20ce6ca391195fb30dc6697077b094de42f6ed463ba0a89ca37e6097144caecade0f510acb9139b87bfa3aac904b1f1350df0d243e52813abb44a133310b7c8e0e96c098867e88e9615ce1ce161aac1fd65112932534ff49b48050ca9fa23fb2abcc8596c8b1cb6c3cb48c90eae381086f829f99db5edf5e917ae0141ed7289b735a2cc785ad7049a653ad56d4640a586127ca334e4499ca4cbc925c8bd17bf717fc76822ac605ab364b19caadabdfc1627ced7e325014ed5d9c6704145b90b73fb8e0f6dbfd200367c07f407b803ee60446c75754faf35ce87004b2f0f880c64672a51ab74e7dd1b59ed58993a192c60ac2bda4a24125e5dd25dae66141e96658c190b5b89605496bb348eb069b9e3d9f14a482e34f445af29cdc7bd68095448e7a40ea1df47c01d0677e278ecbd9107f40bd422649df36a9f9e2aaf95b3e4717725b1ac35c4c85c4b79ed4452bf1ee43d8026c0f552812d13dfca9a8852ba083a7741d95afda7b518f3848463b498433bc21b1b735a72cf05954f4a0f1e158cd565977c555cc26dedb75cafcd98e6427588e82564c2476a3cef2b916768cebfae78c8cee8a8457032c73790a8493a7166dbbd9dfdc7d28d304f8092650e4f2491bf222fb3ef5b5835c3d47d1b40dab9388dea34185e0ded22a0d2b45cae304daa2bfa3f6400c01e94236e0899fe374d881bbb4491ff4bc7fc9ca2c321a3ff2e4aaf792f59fd490fc80718a7c12af696e0833f4b9fcc6fbf78e4b05938db3f01828fb28767b5d2ff5e3f52a5eaddd0961a2a9e58895bac8e2343c9294ce32219eeb1aa8af8c891fbb291bf4e7f1b0d68d3eb3341dd6ed3b19a38043c9fdcf55a8acdacf4198d27298e7f9e8eb3730a0a3b9043857440fdafdcc0b982909512343761c5b1515269989f86ddf79a26acf2f931b723e66a07ab4899b3590a5069cda31372569e26334e4a48e787a296bad107e2a43f9e4af371d488cf8e3cd4efb15d583097e36694bff2453944c28a460e5ff98a983b8a188e0c8461f476cc6413db3346ed253d27487fcd5a77c5fb85f47550211e453e017b3e567bac7768d12962e818c53ab3fb90a21a293ab09975b41c13efa761ead0989e4bfa92c4e273d95a2f4a53f3cc0274b000304a28c8d5a1a72ff85e1641c9cc0ebd1ceb91fdb0e59848bbd83a9441a76283e8b7fbd65681937f8143be88795204715327705b3cbc12db5f714bb25c0934c0dc4724ad584c346a878d1bd3ecfd441f3db5aae6ccc6971eef89ad445f6235f1d8d7192a196966ce04d6573d4a2c5135df45d31d1859a605ebe1846110ecc811f912e64b3417f70e87aa3d4280c5fcc51b8c2edcbcc844465cc19df84d2e616d2fc3ec2f75a5a0c24ce83f044eccca6b607776de25ec0b8a1b73a3ae6d40f0203303f67a312d15ca739952097809f2ca9729bf9d0489f10b6f6a505323878a87875fb01c24aec803877773a07d6c52d6b18fb6120ff8e978b0026499af0f480928432b607038acfb408bd01f5156e289f3a5c3caa4752c17d2697c73d1d2ba5d3c329c54210df40c96ddf46bb75ab4dd4a6c19c6660f56415940452683915a19bbefcb2734b2ebc4c87796a05a1cad35eed09ca9b9956d2450d546f37dd2d9d9b2b540b187526963b1f60e4b665f8ab669e11b6eb7624e9ff3d52940e883c528a03fac5a03c6886fb9b5888ac0831701e892a672fb747067fc607c8d6864bb37f7f7d2d1f6679818752ba7b270a84ce39a72cd4661c04469c4759e7f308ca0ae5dab44e6b58acee939dca9d8c6b05989ec620bc11b9fe382aa79553f66b2a9c3303c78361c57c24b4770b6ea4bdc0d61719e47fb081be32db6ae8bc4c3ad6bb45bb7d30bd1bf8d9ff78b61b548d516ed490cf20fd0afa4e071366876f7b305abba7a914b1f4a17bdd2220b9e7784ba49ad097f1e287820c5d067af3178fb4fd12b4e5be29ff04359b5fa9d2d79d1930cb546c894db9816be7858358976b09352913064a171aa85a6ae6157ce2a3de6706d5fbf262d73fbdb4ab514f4d966b590d8fdfb01b84967a2702bae5680e8cc79491d70715889bf3f60a0e76cb14f33d8d8e8382a59bb72c0c4dee7f5fb5009ed8526adff3de8aacf1cd84dc287677798264b5449afaac332c8dcda2ebeaae7583ee7c90f693fb49e7e926d6ef381f219040022cd47ba184061f0df2c5e97be04b9770e649d949bad6a6e9ad54984e7b6cdbbfdefe5d58e6396936e08711e54bc2c272e4528afd8db3150d7bad25fc0082ae99ec22c2eeadbc60b5c0e1cffe66443b4424424a889407bbd330aff34d84cbc78d63fd3343b65cb7c437852310043d7d35540af3dba0d8d6af2494d89cbae8fa12b1c0a6f2ecf7d7d7209d7c3334b8421721c47847f48b9de37007c4c71b37f910257b2c5079825bf4d94a654c930277ab990b5432e6ff895930f53ab4b93b7a5d85143622141cd3c453b282ccf684d679f2bea1179e9b487b4d89604ee949bea06cdd1e58286294a09c2a9a309353b5bccb5e033f93aad4794ee450487ebe2d77c7a888fabbe2069b1046ece26a3e7186dc6bd7b26f2d5935ef19f0b8802a42bb64b2a2ff3c30241ad24c86597af1758dcfbaa48e89c1c402f6b5db48dbff397d523e1257c9b0c72a6363529a846fa84352c208c09e22a5278bd5e81e6b6c1b207bcb8cb6cd7abe6d3c538408d16cab0d714a4672ec6cacbe2f52fa30d3ac0480ee432996be85a51cbb10133cf35e5f7308f1883b32d54686dc88846620fc776824b597b4fd39bf5004ef7384f30cf090e12f28c7d44d83166175b4ac6743c069f7e4721bcc53b9739b08066e65f51199627f3f32efa6f8d070159394e730b51f767779d9e7df5722f985fc6788c5553c63af6ac8b3059a39eca7af99d97a8edf7e4ee9ceb0195f893296cc14f5f84d36f5699d94c8193c7feb360b1134ca451e57eecbef29a60f90205020d7d9bdddef547d61f46d8304d27e57d12da9d9680ba06fd9df69f0e4b77dd3b016097ef52953c6cf4f93e055cdb85838e2ade95bc9aeaece6847cbc9dd34d5b956331ec8de6a2e04c9b40fb76617106e138d239e285c667ab7ed3486b07d8f9845d63c452fb0f28fb48476d75623f4ff1172a88a70b4eb0487e236badaff7944f54831706ee6ba5ca3211df7f41d97c8ba7846f28db0ab8aae5b1b3da3f57dfb61a18c270b523d386855556fc9268e6f14a70e4ec3315842d8ffe98960034b62bfcc9c2b3968cf11f693316494be0ff354074d0b8f8c13d7ac63448e000b9f7282d8f0f0734d30b9e21f80d9b9577c01208186dc44bc854ee09376824e260e2309693c106d8875e2407c7b8c73de40a3ac925aa918e229956fdb5f001b426580ea7eb74f10c5e5500174ae77c3c195b1462d3147546b14aabe54260d9510e859e2700c0a275c4dd84b32084d4de0115a05a40e42b9fa269a7c1b4695f5c85701380b3049a478a0bfdff91ffc24ad32a242cdae5e834064ed6fa3da0e8c1cf08aa695cbf9f87911e21377e5aa6125bf8970a637ddc3d2f73c050de27a3f7b0f7a2f594ce1ae2c7e9cb3ffc2d32e9dfa2baa7766ca52c251d4ac4309cb4f4c17706ee906695a6d30f7e1f9f9e8f8877e8961f1ded7e0f91c72cc05a6e966a144b1f43b5be2eecf927de57ff34f5d976f4e0eae02c413714b3738772aebf3fe85a39a4eac436e4de8d5e719521711697cb37786116f299b2963912cdc615830c3d89a03cabca12277ead4d6ae23b8f77eeab1fd08e7f9d35f28fcdeacd39df2aedcdcc03f54c5567bf7480e27a9e2af934917e0ce9aa24ddea442092d3868b6fda621c8c5f1946e04fb2e9ba91f63aff3e9307a9d71514d92a3d18ec554c1d241a0ead80b458190b5e73c26819a7cc9c5ddd322a7ecc6ac6ac40f6ed412e0eabcd339d7e8eb3f272a71b3c82bd709178212e43e184c018565defa416332912674e80d8634976b9f4d9f33f3ecac0774f57437d03f20b02290beb1540dfbde98a7b385441e33a0fc62d826ea566bccee67004c6ed7a5856f21ff198a4ea3fffae2e233d7fc4df84a609992b0393f216a5ece1b2a6c0b240a1e1a80efa3cd13c6b494382d849a5bfcb3e8090039a42ff8cade99d10ee8db33e681aa71ba5d4c3170d7bb1a6f90bc28be4a4ef95e095e87dd35cd09469b9a1667cecf05474db5966d7b553c5b8e961b3228550dc9d00cd282e85bdf88f8a9e1cb331cd92f6ddd808035b313fbfb3682b9d71596b2a8c9ff4d02377c4ac8953115991ed232fc7a9af47d1be8129f82a7665bfcf36c9006d1ce8699aa974d6f43f7b0832153eeb84b96475798dcc790101a8ad8f0695f765c44ff51563c950a45aef8c9adcd8d35062584da7daa4539d56bdda140fc0151313dcf25cde7fd1c1f6a9a6487fec8095d51aa165e2bbe39aaefb39a6dc1141a20df4a796aca731248a49f42e9d2b5b0780e68e8ffdb5469164c9dec5bbe70e4ca8429b515dd965690931b59b2c6389c05c11ec07e264a70e95fcea1670d401879a209a34d84f50f7063d23e2c5f658060d0120bce6451da08176b716bb98cbf49a0eab0ca90ec61850ab26d750ddc6626926de3c55a3b315ba31679b36f68163b5ff90b460c50c2f57b6533728156281d2cc092ac959b7508df513c01c0f839e1578850dd17c9ed1c1880968c1a5c08cf93649e78a492cfea550c29f850d327a82ca5745d9e47aaafd29a0378e3d9cac7d177333fb5c461711c612aa41b98e3f9ffbc07e7953d7e4430d26b683defa3b1850782790e0b906b9bf76f4daedb0ee666853519b82139d1d7a556b372cbe5536f7395f6fbe646e45861bcff945bab8d0b5ada2d261bce771c39a513bcfae68d33698f286735e9154210eb162409a5ec94398401901fab130fab3e72923d64c91ceee862158f89a3dbcc0218072b11a9344108521ca9d2c8cffc07a02c9ba8d97f2f24c3ec340087303731f4c417bedcbe55b27bd0584b18fe32c3a919fe81ea96e3c69d9418150ad7036292ad868857c512ed84c093f77158674b0b18128260f062fb427cd1f1b1d476011d4cda887a200da98937dfccbaa26c47323c9b4fe5f2404d277abf361b9870c81448d3e2987d1008fe6bb707e82948dbbac129fb006918cc09241d53228e9f9aea8432363aecd80983a4cae6a18d1a74ee60a0e60401dfb5d69028b8e2883dcf3542709258b5d3432fb1f9f2f776e0557de94c734eb20c834f9ce89baaa5b345aed7d0430ac0bc42ec4eb4a411fff12967a1dfd550e0d7d09622f34f6190744c8555222d306638b88b0b0021dfd2a606e42d305cc5e4e89e950bb5213cf679aee9f7c7c3cecd96151934d68c40ddc27df852bc1b41eb71287a6c93ebcd44011d1e2149336d0560e1ca49bcb8e07904433cf6c8761c46de201de54a9c07ed8ace5e5856546b0d8821b875ab4a1bdf24b61be43b8a2dff784e4fae8652c1b2d9faaafd3f4623af77eb0ef252bcafbe733d0f3a01ccc308814907688d79bf1d96bdd2791da15a5262e38c1b29e9dff64a282cf56c66e0ad7c16cf1efdd679ddf78e24faf2776eb58827fd9948c4e245307988de4bf8fbc1349fd2ebaf52d0a8b38141c1b881794b7513f502af9200e3ad57857ad26e4555dcbf6bcbb084ab1d2724f988d2212b02aa0ba7319aacd3a9110c2697a974fcec912f1222fff68eeb0d6886596a741645d1a40dcc9cec4c2225ccb2f80a3b2d8c9ee2e18b026d2abebe2ebf94544db071eec800286a7d2f0d9cc93b107ec4bce07db7cadef4e5857cb7b3fef969d6af1325540bccb35662c93cbebf8c469ab24390c35c91f750ae5d6517cdc51a3281f6b098323c2fad104a9c7343d169d2c418e564d87133f9577db42fe3d02774874cf096219965c0d8a5f52246e6dc68f159be19440484abdb93ce40e3cec815b0a90484525fe92972002aef516432ca8e878db392ea18fa2f0e91cafd6471ac33cb7ea38e878c9bce46529d68591fc9ec60f74102a1837c57f2bca36630ef824b00034b9c2448ce9d5c660e9d8dde513581cd1ae499549d6693388427226ed250ba8f42be82c0d1cc18ccb7c24602777e386f019d785c88130e105f99cb8f4cb405d91e08d6eff1b5ab0f8ac444b6edd0d2579cb21f25f7082b0a96fd68e6213c30488a617b7ca18071cad40dee009d0b9ac681629b4ec961710b9e4a9966d19980c7a03779c7d61c1d69eb586415a8b82d74f304131aaa6763d707cea577b21364865f61df3eff7febb524e59909925650013966f80802ca689a2598bd25bb34ff7e4d337ac3c6bc6562061f2463abb3244cc87e8f31ab6799c56b50dcba4d8487da3bfa1619293ce16a95b2d907fe0fa41621c9eb9ab1acc066a1b06c73f1f7384ed8a7d8df3cd93a9172f6f766a3ee10c22425998f423e70d3d46606c6cbe3295e091604d275154c8fe27dbea73b69e1aac3a9b8aca7ab91ebef24be35ea4501ff365465f4c1e38c1576a361cab2b46d961078e790a675285a8decc8f97dfa176028e450ef53540eccafbdaa3e8fbc1a8aea675398a46b939c0864a6ed58f100b9a24e7346ec868f24788b7faf80eb45ebc2cce6ec25a171d40df9da442623094555bb66634af9f6b3b594c6654ff4f6b4795214e2a7999fa44a0bd52d1280b09fa3cb5e0deb1bcfe584945b1ce0ca1ce463774763139cfcdd08267d06b0dd93fc9be785d2daee6d762299cd294461449e8518bdb7bc63f40a3e7147cb0bdb0556910be1607e88893155545f9b300bd1917584f40b194c6546831e347a63dc17078b2b3505519a7e7219a696768894ca352e9b073ed592e5be747e9e0d390de14a2f4c3984c29bedc6d15ba29ff8642ad6754550122afe0894cc6dd538b7be2e32b127818a24c18fdfd231750b8884ac44276e067cb70704af6fec281a8b43e7c629a493cc74bac0cae99a39cc99fdcc1a6e345fb069d257f82d7284e5e246e1a1b250d56d88c317cf5dad1c8cf00f250a7d86be9428967ecf0aae0d400daae20898c0b51af4f9917673b7e602653297c8aab21001fde8285658b34c35be434c920aecd70036701f86c317d7a809c088b5497fb87449348353ae69b696b4bc7dedaf0cd18ac62e77cc467b5e72dffa171d03aa51687aff32f0e2e7853dd5c76122dc2057d1158643bc419f14c4daf52dce59be721cf82f115affedf5e72e713677260b7315e63c57d4df80f412e005abcf0e3c8a5fe58c540fe2db51239ae5f02865483e9204033659ba18bcceeeb1b930fe2b304b7f0526081e7bb1c778c3cde4d0e0cee21a68b3dbec763fa66b6a23fd715da915936045e7e883f7fa539b47644ffdf6fbbfba2fa26220a6afa2fce2fb9166001c2fb2404b84ee06d68cd6310995e923c6039d7dede9564229057559d94b1d3db2b680fbce16cedf5e5d34e2f0500954021edf4ebaaf1a327ea04f8155565e410c6235b8fc7c1000731df927c8afd4359104ce949cc0cd995e1a37f915c7f131e43849c7edc00e7561e3f2c91f24657c378e25583c1f199dcf3e656c86db45cf2d5ebbad0586afed28c0432e023574b78431cdad88fdbc89574494c0204b269d82623109bb0014d3d6a9e7d2d44ed9e5f76e0b5e19257ccb767cf7a95c7f8d9c1fef548aa6c15f723a4069d55f0310a3226e5a44fc7c40c885091e8a4e7bc95354c668ae91b559f15826a2e7ffd93f635e73ab00fca84c832444d907128ef60d0e787c3da42188b1944e424bbbc96d305c86a71df37fc9eae4dd48b0d852ad0e8ef6bb8c2372f99809f8c61fcbaf06a5205054fafc9f09df7853b4f0aaee200e49ff1ac73670e2130397f8fe7c6a68d0d72c1a3215186d67c7f5d2ab1bb35d9eff48e8411ec28c6086be9eb6446347a80e51afc75e00211064bb1ba2ce45ef8cbfbacdb5f896fc32b1007bed9076adace5cb4363094a289d9530b6d41162f860fa6153fc376a8f39bd17b13073d6fdd76a50faf0ff03020b87d91f1da54e78f29002d5e04dd530e9a2f2975f33765a56e0761d45596925154692e9198583859429ed38311a000d828289d769278a4836a7f43c445b1eba021f1acffd8291eb576c61fd31924486b7f94a8e1ece0bc0a8705f2c73dbf569b1cd2190f8be5b67ab8cdeb7ecd44375d6f590ba1476445196671d08c5993f346dd709a1141aafe09d1b7bfc2c25460d0c0ffad3b6c8904624a7e54c09ffd26ffc410a71ca032529f760592a993fcbc458c6ce7605bfbedb68c21818c2b2413304dfeaf1eca385fa9b4573010b982e5b76968fedc966fc02b478bf15d937df3b8d5e218b3e83741ce15e00c4ae51d42d581d52b6642455c68940cb325757d31852b42f8ddcfb3b4d44e3881b2365433582567d929307df24310738662690fd2305976705baababdd044451709c5405dd61b5c1301bb9c6cef83d6ef637d1e881dd8f9fc8c7dce8e69b2e87bf35bfe0b884d6735741df26bec5efd9acb4abea32c527d5f1aeb307b469a5ebb05979844b291d9dc860e7ae0a23f9b9bfd58a550e6698c12ceb053279715fe950be37bd5bca78df1888f4d6d2f2d190221d78cd981a9fa39f613a09d0541f14a8e8131e94c314ea93640b017f192b6191c543d23824f0c061403c9ed414c866077e8fd8d77da5bf0a5842a353314f6afe35b4d5478d4603ee82e8367b118887685ac3cc78a396a5229dc6ae1588961a0d6f6f74473382053bfac5bd4bc6027611008e9e1b25b7161fa5ca82a7e15ba2cc325e552b44fc21079e1e3cc6d70e2129229e2b01e04d623702b86d671908972ec1ad143b6bdea855422aa421b4e1ea7676555d2f7d597a592834a70dd6cd7d9fabf4ef30603716d628344003113a4e65b872b8ba0955f91b8d07fb59f494a00297de806940b06ecb8e63a7c46958c68bbfa7538f080aad927f60d41053ccb64692ee5ba6805eae0cc314222bf3f4ba34d11e0b298e0dbb05fa1e56673b7aa3a62bb11d1d2d89c3c6113847aab8bd26b3b231df43bb0e49ba91ab654a51976352c7ca4304b9c26b4dd0040bb4a72d9e6828e836e102aa232465f2063396c85276109b598d354bf09d34d9953cd707217c5e32ba855ce66d015da4018a534d978ca9d600c7b267e620f1b04dd9c5aeb172230f3c5d6e03a75ec428ed45b102a8db8a47c341f2986238705e248195c299ee5af24ca3d8bb1c58f9b3a128a07542162e174bda0219d231c54be76cd66ac37479c60bf5cd96757e38eb3e0b201193e2bb6c6af46f1ff124cc58a319de11df8684ee61183f8dfda2abe3a0bc9207f2928250294182fac277c8eb30cda7093aa568cee0931d0b0d488a71e220581513fe8cbf00c0a71ef212225836212149785ea79c01e5c3ef0cdf05f99388fcd9a978128879ad85486deeea7a973fb6e9fabe0fa05bf83be42a96ac23c68d45628fa4e5553cce329382cab0d51dfe43ae8c81eea12beeb87844dd6615f15eecea482b92010e751e3153c86224b214a87283cbd6d1fe4a38492302ed0e1acb9973a86935fed6c9d696a96d2c4737c1b828f43c3a3b1f5dbdafccc6120ab3f72d2fffff752d504d6a0c29958ffd78b302dfc9f48890a78328720f807bbd558143c978a30042d9dd860cd1eada014ec2bfc1c1ae792df109e5bdfce1411635ce9fbaa5c6f0a9a96582be99a2d4972c6379ba719fafc64b8859c94741fe14353614d9f807c63b74803ae7b435196f4a2e4087f55796634fca76f241134edf4dd2d3c58eb8e3cbe840a2747eb55283fce6ced8beacf45b1eb4b784d21d252a9de6ee0b96702490183a3ef31861d88e441398b9a4d4ceb4cb55feba4e2fa72169fa9b4fbedef9741331ecdc9a7a69cc480de93facdb7136da2b1297f4fb8e469015fc60b517315e21e9a1b2bf818adaa2314b537d5a62cdc03e751ffc3ff271f3918a327e808972975df63cdbdb6e4f97a4c8a864b46b70987fe06fa4cf759636b0b8bb17eba61596e6edaadecd33655ffbdfab0e75e8a91514dd73644ca7fee0acfc309f297f49a4de76a6d138fe5a3ac4818d4abe2222a04d74845556d1e5edeb3a98766ca8789baf05413eedd9267e4c4175aadb1f217fa2a9bc6830e8e8920d08b94647eccd0f37c731116f0a51f58ad0c6ec1a0d9da73cc6d0120c1d521a846c06fc30531bfb57cdc774c21791d0318d1bf455ddce530d3961a7706ae0429b779fb5f961f0fb140a2bd780d78097ef40925e048a1cba80ff097da714138a39bb43bf7c80cd5ab9db7d70f96a47231466267579d032f5a2ea51e5ededbbe30ca900a5f996121e6f4bb4f1f72f24ae653bd683001e742829589894fd180dc3f9d6c7e055b715c21b52f2c4148480272baffdda321daa001b9baaefcabf9ff208b1a4a7720972abb65b003803f44234286ed2c7692a96d4553859609438d0f7ee19b52d46a85b6de03c32c44c7c6c67072db6b1114061eeea1eefd140bb55dc04afed9c4f1d8ff0bc6b9291d0bf0accbb89a9106af9323a88d6352c54d443a655d1f83beea1938685b90b08e680447f3f51a2b71271ed2fcc2c4d6bdf559a92ed735151f8f917ace05826d4487e8dd951288afe8d0a392a04ddd0ea6495e937b5a8e164284bd9d53d863546bb851c624e0e7a3b46b2cc5995b2cc733a1db1a6e72c567805d711cb0ffc5df98ed0052225f7544b198f2d973ebcdf396ceb6f3ea06dbda2e812608490ffd852881610bb38c151f4922c98dbd7631a76303c8164362be82badf7b63a02bd01020f1d35c573c0c04dc24264e30917480784f01fb13c72db9a68fcd7fd66a86f8f6a53e0726e776d5a52595363222fd6fa317c33218a75f87ca54c66d12c1f579b349b50ae15b32f2ba529e0f1379924aea090da65d23211d6590d20d2c83d9b52ce320a62a660cc70df64e9a5d573ce2ac73eed02bd75a32b3afd8444fbd7bfcbaf3b94a1dda49aaa2bd98d6151b6c4456879d1864c0cf6888a47d343fd51bc075eb9b7f820cbea0151c67e3fd3282cd574500b5d87fa6bef5a6ea0afaa1d821c8b7458d7b7268d3a03473484f3cee4454124848efeb9eb01818cdd10d47d5d68645fdcba0fdc4cddbf2889157a27cc793f837b14990e6f2706f01092758839eb9c137b7d0b6ec8e7c2274c98a919a6156d04806942d18ff89198b511e9c5abcf9164694e45a2650430000ed4b78dd31a231bbd41e0290f97655e7b38ae0c3f6b577a81d424998582b2b6bcbf4d54279623bd4cf2694a58e49d23d8e6ca920902752822cf02dff6ddf2cde07db5fa0cbb024558b48c28fda3d251a8d0ff88fd6b33b2174d181f8c882bbbe4933f223a3120d8ea23dfd1339671aff80cbec6de3c8f9bb9173f3c2b3e29432b12ce19406204b4554787110256722eb327d3ef740fc73dc61a90fe8777793fbfc1960bf2167e788080651fd62b0c697cd797145a715453bcfb9f30e683f4203d5202761b6bbffaafedbab45b0f88b346fbc41b1b8bf5ff2082ae6eb2fce578a9db9512be4bf541164fdde2b6e66362f6bd2b36aa3fd942039130cdce8c3cbb7fabb2df6b30708042aeef573dc0a1bcbc6d98862dcef3eb79ad0d60672c1d5c5b9e8a1c6e5a4af45a3a64df165c61971ea9f6a38253cb97ee4f10432ec31f9a89b490f73bd94d5de5a33ca565100f4194a5a3789a80065e8723d63a366032467563ac887624674a601597069b40e8c11f45e5b3a64bcd22533bdcdf810d7d84a5e5c68102dc597b2e2e8ce1c4dd49376be0c17a46991c64a2e9ac3f9afc780c65a9b4f228ed7427c339898c26f64eb3933b6fff6b3a93e4b7c0c01472735ff62d714ef2fa0d99423b6e718db170e876e4f1dc42258a9f38124ea0c32a8a77f445107109787f95e7ad93bfbceb572520a9f7cca1521980b0f66294ba1843dd59ed73647218195435fde8671bb4672f042c37befc399eb1b81cf9b8ff5019573b02915def0b453c12436ce0002e84441e680f02e2ff1e2c18162cb8d57fccff8e154b1211eecede156ba5fc66c877c6b675a26af90d7e5c2586041f25318e9d47a7ae987ea85e0f3779fc627d7c3a6a6d958a165b76d22984859991d8893f6a107b5dc4c7c892745ef23dd9163542eac8466f83dc18ea34487e8aef6e5cd0554ba4c91cb624a739ab22d44491711253c2ff298d17b1e09485bb3584110908ace06d5a19fce16fe3cb23a56e269361f718f58857457071f2fb2875583bcb8a60ece328edb219b4e4034bf92413c1b6ed1ca1e148a495851c97c86f6d3dcb48503bbcd6365f55a313add5b6106b5e36359efcadd572ce486412c7c376b2767790203a1b432227fbd1820995f570b5e38cbb3d51a9a755a15f93527a5003a675ad8b91ad54db4d458dad1b4599d759930ae2be1abe0f36cf16613812be76982d4710f4932fa9507728c4dae7d65aa29a6de13ceb2b5bb1cd49c27a7addc6119bbac77ee81dad7849ed806a69fc206b95bfc6f6a14b41c3cdf3e35cdad88eb0ded4c19662e96d098b0828b04a584fbaf4fe9c5e9ed8c2edca0a81eb183602191406a7073fdaed9cc9001fa7afe0ebfb107df6d594d50bfb337d24487b6ea3e0ca2898b6f49c5ae3d51674e897a374cec568e0a711699128932fa6107dbeae70cdddac496c88f63ebea1929986300ad27a483b2e29355f0751bfeef913b789fab700df9b3e5324c0667533da018ee2d635222a6f223ff2d82c7f702fd8e4b89b8437eb02235f137449d4af8f9c4c483d280d1c670d8d42071dca96ad0c04e60cdf47673686b9c922c536a26ff32f49df466a2918e9dc5573d59fec0cf77fedd8c6fb0014333ad220b2f9c15c15f88a38e5cf8bd276b9c8f039b0ab0b1e025ed3033ca147f4a9b9861cb52bc7ea23e0e4afbe21758cc1a4194c1d6f18f698a882ddf270d9b5db47fcac9c58d779","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
