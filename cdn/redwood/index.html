<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf3a8a4fd759c2c4a21248a2a5db4e71597c78657957ec3cddbc1f4aa159dbd262048854f6f07049d8af81d80bdb6c5b371db2d197601e6dbf836eefc77ff884a6687714b8f98e4504ddbb2a452739a58703cdbbfe5ce224805e0d357fb99fd8949f5af0f21ffb09d98cc9e6d750b04bb0b71e12d84e4915170c3bba536f2053defe6f3186ca1f33fe19abccafc395b8cb50837adc72b12b304130a90585166d8808e7a6d287b621a96737e973556b82461993aa4d91272615d804d38bf81ace84d80119c96316ebf0fc1fce7dc1062e8a85ba2c8e0f2da48e80b28bc87cc4e7b5819a1856a8f7ac87af6a8560d85d53192e4023512962b77d0b2e653e3e74c2785eecf6b1a1f71a5bf576ec04c84fa58b0238d941f45ef689bc16414dcc9bb127a71ba8c637bfaafd458e8d17eb9146c1b7b74434cba01aaf6c1051c68b6153d079c7fe7a7a6db255c115641d463cacca3142c8622930747a7eb2a3a68c40dd35eafdf2a259f8bd962250fa3c7d5131ada7d79af92a6f3f2467186f9257acf5a6cad7e13a8878de5722d23ec12c7eafc2fec7452a537430f8dd33b6d0053651418d8eb42a5bd0388b8f2a04f6840c35f6377fe45e6cf53f0cd819eae72451069c73a3e2136af5631cf3226a1cb1572d98aad73150f4c419e2a6c7a80a74515d9ab4154c650b9d76d6d78f602b8c447cd4e7e09deca9184ab7b9a120eba0a969424beafbe6a8485fb7cb5cb5667c418727938ebd078625c783bbb4215b402de75341878ae0785b50bf95f059dd945494139f441a0fc901f074c1f3f5d441e65587116098cf64133fac763f81c4b902fd6acbdc18fdd537672869ec88d3ae3ee9c76d3ed1878ad9bc544d5a87a00ceafddcbca3dac761d2217e4115b1da4d6e2a26a5b4478502b23a79b520e6f86daef89cd6da47d9d64f8ee0c99a395bea36b89305b5fe237b429e4c50534c1d6806438a7cd24888ef9495e97c2fa8f7a634865ae033767b86f92f429c09f39d9d6cb387d029f74d2eaf641bb13703dd915ea0b605c2bde374fc8e6c0e62a36806524083b5247296ae596267c6d48396ae5308ec474277664278c840edb43825273cdab817fc793cb1c6f871b98005def1ae3066a8f172cd060af857cc6a4c785e4beba463069b8a2c844d6b4def617c34e7d7b6db71afd005ceb8d110f4f0fb0a75eb1a4c6a0db4fc3f8e0f19646f45b393dd1dd684782c82e6208ff3e157ad6385a15bee2f0d35ed0443ff7a7351f519dd85378c551ead65844e3c72a8a1a6a0f5882e8ae91f371bdcd9a4020fa4ae8a8dbc6637109d679294779dc15672b7872a1d855313dbe496734c52734b9da4ae13268a25e34bd57d152a245033dff8170a35ce50e9abb558d8f27e9330dd1eb19dd76f4e018b02d3538d3c15b528c8fdfea3c2dfa8d15bb77acd2b9f83080fc67a8ceff8a96f3f82c3487e48ad1fcd0f196c9e467ebafd31a1e0f5aef562b9d4ca6d317cb291e80ed91b8de03e5d392fc93d0960854439f2d39b9af8ae886dfb2322d6dbaadc0c7d7de3ba83a30cd3ab7f6d841fd3a826ec814debecd23dac20dd6d7070c8d00211f6e17a364f4e99f2e51c03757896a569a02314da04ffb750054fc2b2ab690aee958b6dad4ff491cd69b015e658c556887afee0ef8299875f25e6e170f31f674dfda94c0e2b4ed05f96eb47988a12150c3e750e78e5d18174bc049cd9b74b33fb88f84ac0f8ee3380760c3113411b0a98f09e47492b022f5deaaae26112d70e09e11ec387fbc5828b8a2b24609dd5db4231499b57ad6df60d64d08ea92d4c3fa19411d6e9d89bc5fdc04461e2221109a136f0b259dc8932f3014efc9ed47600cc53b421f1e6a6b1d0e9edac9d12f51b6fcb69d010b09e621b8676c87027b843ffa17a1437399837130ac751a6cdfe555e6e3a911bd4734dbff71a4f410ab6621cc6ca7e01ef8daef3c264cf7d19da9355040aee262367db4e978ebe03f07a813bfdbfc1469cf490e7ddf89819c0f9a60bcbd8a08b6ae442478843ee6983954aedae18eb76df25622e0d27a9ffb6d8ff90afaa08cd1504e52a96528d365857261ffda0db32f1a8541a681e2d97036d13c484757e1de26352000e49acb43764eb04edcaa7096c7aa9e9c04c19e43e4e6f2e6ee686692ac5cfc0e6728592d8f31f73e23490590dee43d0bd55cc377ecf3068c521b34b981e40e271983eb2a7d07f9ac8028c003f3831e025a46771aeadc840156338a05c8fb3c8d6c725cf04c0246482941499b164cd430497206a7a6f4c76e4293f22e82806c75e91029b6f6fc51e0c4dba978b06d3a770bf91de97c45ecc127ab6180c533e2def2fd2d7caab33621df431fdda67ccf0a64a704464d31b3d6e75db8ee42e051738c1ed6e619cbdd76312723c0db2cd9f8c00905e2239dc39d596986f97ced7986286bbf141a62fc4a60923877c8f8bffaa2cb9baa98d01360ffa00c289093993c2306faa01371e7afcc8df0ad9c48739692bb75cc5e233704e331de1299e287d89b4285e2992455a55f078f6694754b4846f9b9c6f27dde44d676082aaac59884d967733f6f17dbf279305128571e8563fd5dfe37f4282d274233c7aa9332618796a9579ee3b0b8c811f37794c296c9bac258dbf9447376f129847cbe0d46f728f98bc29eb8bf923c93311cad5525879c5420abef0aa1bdcc41375613e031c67aa3aa7636e7be7fc9a7b9d58e67c7bcdc43916f4110be02a86fbe624cca7a9b08b9fcadfb0dc11490eb8de71b58c27902d5abce2b352d0948514e3933545f5d16496d9f1259433f3fa5948e843aa88c73784f69c5f06ae5c78b4e05139920ea39bd40feb58809c4f5e3fedb78586c8b3e27a58a0d59aaa7d1605e2c8c335587b87ce1cc44c222411a8332484c4f71c6b494a1a8b63f35a9166a436ae4835b5990a142638fede1ef93fbe8f1d2a7299113a1c150fd27d05e96df59e8462071e8d0f2e5a8bd297c21c6893427391d20d3702c47fa8b112dc92f399d7000631d51a3703cb09538780ed640a741334092d5ed68473eb4cd8e9fe7f64a4d64714f04c8066fd806d6a2b9e778ab56e23bfeb118f30f48ad577494a7d6d29f717af67d7e35d935444176cbc67f9419c71f5cc47442a19e401da7a110c97d92acfc625743e4301b00948c5cc2485ffae492d8341822b9e20c2956d5f5a12fc101811b7c7558eeb80a569f90e57ea5baa9e5187c751f917aaedb995c27ef1ee2934904fbf45827c456bfb5c894e7c74b7430096e3f51ad845a34639ee75a45fa7fc4a50706aa8e26c19e576523e124396512f6497e9c1d03c034f92441002cbbe0009a7c72335ec826e01220f1a9ec26167651d438fe2e87193ca39afec77cbffc5b0ebf61170b0dbf31db7dcb41f18eea7e9f5a629bb77e36978bb5993b06709e11cd97b8da97706635fa9a447eb5b18b06edeeb78f688b5dc0899e5095ef10a645ee4750b9492af4ae21c1ae4a76a30b867f71a47b531f96242a10486ab272da68bf0e4446a061ebb93463e8cd81ed72adf0fb6b7c253ac53abb8f5c1a95029660300d059b539d37dafac53270b9328b9965ce0ec0bf3b5f2d02f652cc98d3cac364267e0c142c203517fe309a6965c1c7f8ba3562f0aa333aaa4db00c68e9be289fdb402958028d64620b25a9f3cd92923a37f2746410b07090625667bcf4a3fb8d09ecf585834f4b0279f4fb9d2764d99d6ee8fc46336ad10f337be61b78c194c06dd09ca311c840449c58fad6d4fd7b0000bb11d25ea4d1a2b6d20f255f5d2d3b14464336cc0401ad104e11add162358dde02a0f09aa15a2eb3e757563994df6ab3a12ee887713db1d3f8d8b4676bd4eabbe6f545cfa603c855d3b2dd0dfdf23927a1d1c84c7aa80a794085605ee60d72c541dab64d5547f43cb83a440568d7bee4e73f2c8a00294a2713437ed43ed3c9a12a2d83ff1f989417189efa0fde65aa977df17c29ac8bdd9ca37da217f5f5e9d1ffbbbde475923ecc229911926f1fce6d3dafc66aa81f5640b0a634d89888c1c6be1cb6f2b52f2bf31518e7400e86efc56f9c7ffab5cb8945cd77ea40f9cd96b8f15d55f9005cbb04f0b3c02758a3b9d802ca9729a189c22b1ab3379fc28aef04ea5964fc991d84a9692a2e04d3aa56160e95d16046228221891c8f9e8807f0983230ea2170d25c5d8572abd81775aacf03d6890fa5c899d2d534293d4aff325e11f3da4ab9acc160afd5d6501d6ab214082c29dced19a8297c6be6cf867874a3995069ed0ddd44e83a33ad80a4a4aa46b34dee6a642db477d77c7074380b4d3330919260c48456a4077bb99a9bd035801711e1c5def060b481f5343d52ed66da306a94affc8923dea1f4b34f3ff2ab429c1eea51d0f8f4e9d6b2f0616c5709b3ccddd1a120bc389d3c1aafe18d5fdc3f758447ce00f85446a568025575c07832ad1dd25f143bc5558e3181eb14fed4ada9d23881e702356f35304fce6020bc373da07dc83f383541bdb55e540f20bc0f5ac492c23a6fee69a44de7fee5231786de953daea2f30eb9fbf56bbe6fa0377b51b9fd3fa0a2637b946e6d04da9403a1c5c56f9898f5a7b8c1bc0e4f9562a89e937ba5571c020b0c151b1bd60e0f5401b0d7a9004a99ed895c0e06df2c88d9236b39c37f9212eccf65b8b967453bb554aa69017897414162d80f31f8623cea45ac8d843ecedf78d07abadb9482c46aeb9fff8f882afb0b80852537b47d55eaca85b90216fc48ae4a69f6c4d7614b829a8a0daa4a5010f8487b1366a7f08c56bde8cec77785e90290868157d532c59e262760a1b016f051f4c7161349b6b2a199e251d05d6ab6b5cc75c97ad183ceea309104bf32314719ca226c9d51f43807e19596d1e2221ce9b36d2f91cd40e811789010424ddd6ecbecb009fde07ea4fbb6310165e4c4ba51790d9a5dadf77419a735f52b9807dee9a685dd9ee65a47b76be110ce16a9e8c447cb8bad97ec4751c6a344e915c311f08f20ee775e357f3ac5f3a6260bcbcb7abe2f7b28c46da1de4557baf80cc257d231fdb8806d2bfde8a35ea943f79bdeefed232047a55443f08519e3f00c8ce766e00008f80c6a5da962c169ca239973c5d071aa25a0af9f1a70f2757a7ab4fcf0df5f2542f603c3b8b876dd9fecb199ce5aca40cfbcc4557be92aa26c1b138b317bffc97650cf50ba1fa16b8ae9c4a583faa1464f9a7f72ec978517a55b9f92151b6b0e4978498016f8d96adeed8fe51fc942dba84512a2bcd356a217ef331fc64ae5d09fc6c691aa408313df7f51bee93fb02364f76d7bec8cbe79990645b5b467c3d0542a1282587e3dddd55300603ec5a32736ef58740b4e8311976419c0b7c903215ba84b8a29c068bce45bbda5d24793fd285d93efdc039b890fbd916e7fa1ed74f2859984bfebbffcc8b97827bb6708c3dfe144050d207c6bf1ffdc92b929fa72f905cf99c76d06dea4101a170e3f6a787c54f1ec857d4180805e04059cb7291c936171431fb1cb23ac5ebc2126dbf742635f95a6735664de1db09226485bd658ff42e14fa2f4baf9f2957b37a585870f16b218ca83b227a50aa0ed97c35edd129f7b73ebbdf152be3a1adb8b2b91c2da6e51c90479fc8e0e06c77fb5545ec5f81b8889e05f42b5b86635af952c22d45b29720eef8db4ad6bacd1ce2bc975aad99f597c5e145bc456af28e8b5f411774c864e4d2512c66915af27a8f0a2c77b3cfc40dc5cc07b6352bb4276aefcdb81b197360c5371c3408b71fc6b76c761138611b56b49c3cdc27e03a32fc512444e6502fc85ef2f42467b0a97c2f85514100ea987034e5fb883c9b5f341707b2cbba72b4c0fe94c377c755b826b9db2160647786c55b561f500277aa9e6fb9d11ea9d92ddce1b60f53426569ae7a257500d3e800192b7b74074e5d8d84aeb79c91000c2e1258dd682ff0c8caa77dea0dc74371476040ea3b40542e4898da49ca96e86363bdec248a68f7f6c3f1ab8f3ba0d00976be66ee4559e9a4c06bf34705d8e765c713cc8acbdd11cd39b55b191b588c541bf55e91a03e2fbb8054914e89189146f1caff87e1989137d259c619900498db1b2df44e7af9eff5dc7a43fd7f41ac8f3784c5962614728e9b76c927f9a075b7ed86fb87b1daee41f015fc7ead8405cb2e2ec38c1dc686c88cc842f3bb4a557dbcca93d811ba91c504c27896b6023982bb5d8a75665dbc36aebbfa7986c6554879989132efad2de7f50cc2fb21cf3f24691de0c66eef9af35fa7e4dffdb6be38bb7ac5ed0aa997b872e7806bf4901f155afa9f8ffe788dd9dde4a6788c3b75acee65892f69fbe01970dc0cd62bcb98a197868bd1431498f627a54daf0877025269ceffcc59ee9a036200305be164f789d184f2bcc85396bea25b315ca593175ed7875ea46fa59b822753cf52fb529720e5138b330f5beddd995a7b07459cefd477600b428e2b1cb0d98d2c3f20d524d29764e179db2a63c1cfac3079a017175f6212e7a61e7b4ffc73a75452b9bf7e38e798e9199c1f738e2e0eaf39e52194dfec521831fc2c694476f2c0322a6c0190017309b41becdeefae3c625368bc44c485ae4b40a59988632e2f765ade953f23c9f2e435030b6fbdcec68cee6c3ad94c732a7cebe63009a5c2732e85f3a24c7ca584399f2483a27900a1eb67fb4c74d6d7f87f0a331e3500c04097340d526bf75688158fbbbcb040dd39c1d9dac2664d63c515a0e0b757737bf04d7b19454d48ef7e1079c87a4d69bd3e49d7ed1f65ccd9fa14377453cff1176fc7737af7207fccd9c9a5277c96afabfa1496c7ffa75c3a67675e7ac7e331ac45d7529280a642d4c84549e04acd55f0e71ccd149d3509e81f433490448a43cc87b24fc0c3ffe761c319478f76a61ebac4433cace0dd5b835675d3b8a3045ac346485ff103f5f3c983d99617f80988740549bdfe4ebf6106341c94f6ef185a6cab0786a2dd3e9aaa9b12de192e3a524565043505173689836a5b1732fb368dab501f4dc6d111fd988010e91a34364fb08ad5acb53591eeac452d6593f043f36a6cf3e93279198b7a4c674e38fc1d2d3db1519568e8e5c395137fba228406613b21e88c7ba204ad3773e84d627e540c81bc4d610cccb8956de2669a7fe2338f1d428ec924cf96c3d909fde7819989c376901707dd227ef4c7bf2d8cd16fe8495cd6c90a4eb9616fd0cb8203990dc9c026fb2050b6af03b681f3750ce68fde37c23d7a4c9cb8ca6119a86a18d8c67fd03692480ef8c4b9d91c222573060b6c05d94af13e06f12e376eda90db81701158e86d9ce28247c15350f685eab98b88732ecbdbb3469ce4f15a8b3f70a6e81fa8c37890d94c9a823a1884ac830bb80083bc5dfb2237025fd8351b72e3c69576f94f83837829f8e03b87d23352cc5f9d4f2a357626514a227c7e2050c50a9953e44356f81f3668b09524813c78a652c281c2468094e0e7bf11e34056c26dcfd28933b2f6e9068681523334c2f8ab2c8b3d08f6521a49a548dc6ce1cc0b47d28b65351cc4ff7722892abaa094424805364bfcd84d135ec3bb64e33aa5bc7934806570f89bef073ac068f50c786d057bec4ead2bb18a13394a02e135e4384fcc4facfbcf111fa6467a39b1cb418fd2f2f5ac86c1eca403e317a076ef2d0f7eaea629e75da33d5071f09542ad6818a5d5e589df380a19405fb42eadadbd95513003757985189478f063e6c7f895bca8b5f7526e0bf7d7b5263613b23dd9be45304bcce4ed2c295d23e83598dc3ae784185b7a01883a699c2f7849481ba55cd5b4826998d7ddf15a54ef2546708b50fb254bbb08bd6f0ebaf4fccba586d74f830ef19b333d2166d0089ddac184c4d719f4c57b14960a9e68e42e8d0d30638577e5c6ff8249cc12df9b404fe7017bf07731434112af016be5862fc338cf2f7b1e38fdb956aa44a8f85c8b9100fc44f88f2a5747f32111c8f027bad26c4a8fdc54d4cbdd43d2f4e0faaa30f161740798968cb884ed9004c7629b0e9767390a356fdc7695eabd38bf99b3676e55e155db07fc0bb23e88eef5e6645258c2afec045fb37ef6c6814805974a0c7eee337f608844cc28d08c1f5bafaf7ba9faed8cc99a22fe932ee3ea9599c7ae5b1742cc0aced1d6ed642fad9ec1dae83b2c3c7f0d95eabbe8fc9c8a00baa994c4de1ef2373c310bad8ca18274fb99f6711477fffccd84eb1cbb0cb5423ea59d4acf5aca512a13e2e6d38434751b70398032c6ae2c7b278d01bcdf0879ec23ed65f0e6d19bf19ea858879cd47e9374b84b9bc39c29e69dd2141aa6345b41475e913fe85ca2048bc5929178ada49facfccc456b8ac1bbdf34d9c54b6adac88299d7b20ad6de3a0403e76e9ff0b8d196476bbbb52c05bb167647a125d8d60dd507671ce7c470f3ef9b636d81384ee4a4274a4cb2bc783983e0a1c871a3be7bc92ce464dcf0f10c66808a5127c8bce069c66684599b676a5030f8934df8d082232acf9f72011c590fbb61e63b8379d581bdd095a678d6898a868cedba9af314b5bcd0e582802a3418f888a69384a3a1330ff00137ccf61f1a7edd67ce460473626ed2b03da79310f94a5b8de7400ed230b35515c2c019a9b0782c99692009ff0c9079c1cb57a36f9924b2e80ec5c77930d37c58a497e0f7fe99c101d33a979b2b2dbd00195afb15a0cb6138094c952f21b966770938e74eeb5d70e6bad7da278e8736f00392865d4fa3d89a5dcb2d5a1c91b7e5efe5075f00735010d21f3b7a14c429097317ef0a29113c50a0b8fc419215c8b60e32c6e8a76e44ee2bf0044d1a03bf5b644bcec04a9dd8057d29afe45571d3641b80406062d6f219f0d9b0e538a10401123692dd251731b74eeda9d45da64a06aadbb0ae9bed802ddb480cc9470e7a52d9ea851d5f4d404b7fdd4812c2a992bba6f73549da9df58a05376a4c3369b4792aa9566318c5d79f9bf2ae1c834c2f121b6ab5f61a5f973b6c4d80ae0e48b0a32be9428150574d0e46c4639acf26c1c68c8b036d49728b4b3cec8738756dd9fd2ccebd8d8cebb38c7ab6d3b0ad17eacf74682b4c9d81795d5940cb5bcc257cc4f0faf544e823414f7b49dd7c61037237a24b6dbd9a6da03c84597f3a663046f6ffeaecbed0ef81a0f0d7ad0b08c8e7508b5a8df14b263ac4709d3abb34fa0a8fa04b26f7e61bb0abf802e63f4715f1eaa926c4101c9dfb4ff33951ab38b8b7c5c89de3b966080b092199de18f64426df736a06d00c7d2c830f38fb0ce2e553d14149cdfdfe95dbe62f401b09135a1dcca2625b664701a915340eb85ac19e45bf725bc46a6d4a3b97bbb9ba80542161b139557ac24718c42c9dc1ca9a0080e918fd9a51fb9e39013257f6df1679ba340dd7d610f7e8a47c9551decab092eb949983b0484e2b54b3c17ffd1cfed5aa50240f6c70a1644e691dcd08337efd9f031b3c76bbcc22afbc2cbcad3c5face1cf6af411cd305966a1e54e52cccf67cc1ec1704569f1b95849ed1470f3a909815755eff3c17f8674758a45d115fc9ff0ceb11f2d3c9fadcf07ba0f3529560971e858336e50196f26467179245ce4b923dec9bcc878307553c7fb0a349a74e00769de3ddecbc63601b734834fabcc7e5f4dfee34c7d3b8894ffe8eef6e4aa0f3f1f74f631a8c5fd8656cc5537dc3b922b32d5072f661fc3ed9895d64f0b2b260172e9387badc4744ad57b61a0dc5a5fea92eddaa2258bbff7958c4a7dc1608b26a80c555dbb12738abd684c12ef562f927d47ae105b8d765bef1d980f82215569179db200585ecae07dd3e8c1071e0099fe9726ec478662d662cb35f0fe46d4dff3ae3ccbcec91ad37dadfdd04e370bde202dfe2d912244fc90676a6836881a6525a2099c291a2c844f9d36407352460cb5ca9f2fc1ebdf9c7f5a823afed047abd8ad55ed048159506fccee9f5fab66d66c66d099d2532b918110ccba2af3e30a952618b0aa48ca0054b13db9936929180559c4b1e7b7175e44dfdadfe45d4f2adf995e143e81339a7ad752dd9bdbab8f0f72af1519f2ca18a04da7cf71c8c2060f2c6312a9e1764c46c85f3e759bf191b22f2f5b2c674bef3b5797839ce8d49ccc27a8ec41aa2a77cbc58f65aa357230272d422c2b13f42130354e879a265ef9ce153da3ee5ab73fd04f39d13acaa092f51a0c18b359bbed61c235312ae80cc81d682d360e2c352afdac4ba0944a4670102d69db5508c8ec85db4f0c27ebffd16dd391773d83f690a5ff1bc36b87fc19bac1712b03a4dcc2e6642ef3863e64f6b8a3ef146fd26d8083600957dcb8f715cb085576e47096f0e0236807de5dc78061297fb2000b6b7687f28a8ca015beece2f39f93b61a56a85a599d1fee4e1008282a74b2dbee8053f6f9262a8f89cc8c56ad31c6f32f93c0b0ca51c063abdb98a2d8dbec337b3a46de55371812411f169bebbcf72c5f359f135091d49c82c9747e1539b1e19c8cffc2fc2ff1faef55f535abd662f114c70e5f063d4a6db2c20b40ab74a06bcb79f505073fb1070d2a596ff554b3198aa86de0a40fba3f6b149812087e3ac558f7813a1e216c77c1670ef20f6475f6eb89715deb616a4d39cc8f9faab23cc5ee7e4d26b65eee41da6f893d1d0b5c979ad6a8ea3a2638a1217396f110fe0251705dec0228c0b7a4e522a8a772b4e1a8bd41193416e39c8beeb75b0e634b190b71160bc3bfd1ac5ca3123454ef8b4237499769e45c068e9e32507c7f9b524f7a8cfb1900c1bf533f27daa17d0ff03284ca3fdbb59e9a0a3bbe4b5aea2cef642fce72d01cad35148b841c4db31f89a7dafd40bb95752b75d917be51fcb2c0979453ab577640ba5f879cfa713b3e9191752e3e6586fe16b5c05cd8d58d7cef90b457733b882fe221352567897de869a1009da789a244e6c7d4fdea83681702d50cb6d6014a4022674b310c99746f213c4f49123fb101e37a65a00121019ec8f739f65a8cf7f41569cf227827dedbcd633ca97c7020ef5aa1a1771d3dbcd016521625bb437bfa094f9e2e5c229f55d87cbda8706aba8e96be55031e48790f6f4af6926cc618098fd95907e5b16bf72f43d2522db5c5811792442cb775891eb9ad7696775c40a3ba55ca3c8100a530f1562cd5673a1c0fb4e619ff7c289ce86b4f8f177639cdbe84232c8365bbe8c20a9c621641ab77f57f87bd77e402aa3548271ca09e49c9fc5ed45271fb8033676b25a28e30100da45d5faa956081fa6d82820a54e5084fe539608c8c830b2f919eb1408cdaf313e8351c1f732bf352f5b173368da5ba37d86604177db9bee41f151e9fe743b9679f0dfdd2fcbb2c37e7afe9539f95fb47bea226c8bdff27b0ba70707846558e3153f1c29f7885e4e1b8dfbfb52666a8beba1250da28bc6c5e2c46a846c68f6b9be0752553a9f8d9d5810b30a204a446f0891d7999074ee05803a8f5c69049d2c6826e019540e984dcf2bb8098fd9a3a94bb361932711c8d7fadadded8ef2f296dab68a7ab05d3b70b48b345b7645a1bfd378a736f974fcabfaaba138d5b3c0e5ddcf36f31fdae23a3ff9f517cf5a977f32404eb70d4095e75ad157a38ea05ffdf0382d35c0eddeb733871486e9b770761e93f9215ab3c00e0f8b0c0ee5b52ec4603885afcc0ed4e07a2b283c1dc5ead9b79d575d3c5a985f76723231ada1501431f5a74cbf6e202701ee1b3d838db6a92277c62e1806788469d0b0663fa9792cc2a64de0600236a579f795fb92397224282ca52108d85025d2a823d48f0cd8b0d935b06ad5feeef1239b1480d960ad3d13f36963d7c10a8c191691870d4c53b2041db83193148d07ab43c88c10b0c7293840934b6f7121f8304accb92e1db71982338a1ed9f928734f933708768cd3b88403163ac0286653287ad06e2ba08f1f3516711c1325b4e78deaa9f019a04991a5f4170673906e71a8fe6be084dc93d6c3ebbfdfd2b494c6e9ecb3d6f357b628ec763b62cbfa17704c2bed5a7f3e0701b7d4621c1beebc4d0ca35ee428e555bda63d88fc2a23efa8a58b6d36f2df4297988b1606be68f5a7cfeda68282c702632682f8ed635b8d7343431b4adc81490670c593ca6566389669af18c0923e93b1a5da9762ff9f9fec0eca2db16a5d5a033b6be231e00f7209c3f3a37d9b93399789847cb1103f3d4be368c26beaaf9c338cc5ee731dd4b0c7cd74f925abb5618e8e96ae3005dcf0e9f49f8d3336739ed914f3b94322c7bf3cb829c9d8cdc5e2546f4ae2b31d82c1c1ce06052311767c500a5e5dd8118381876f37f460cd5f052955bfecd0ca6938a70e07cccf97ca75500f0ae3038c11b077462f0598fbdf4dc5fabdf22af4e61dfc3bd5ce1937cfc04ed85728a7f1cb873f06739f2ca525e835400a86e4b193e4ee520913b9fe3d723ba261152f3031ca45a59bf53f4e98a4966a4721588558c14d22acbfe7ab221183d473fc0cb013f85b5b875f5e370431563f5e7fd1759e4d21d61d21f65d54abb71f7c1afe84680bf19f6b92cf10aa3431c8870b95a3b296f2f6bf1bbb6a02080ae926c20eb11c4951ffe12819ee2b3ec727a367975c8b1bc33c5df208fafb2c94184e3519e5497285d1b003ddf71e193679674ce386f9f2c6d0cc67dd24416fd771d73fa6aad7e574a3b92781f4b37482e2ed7726395c19290989ecfcaf107f2e42d3a23742f1e71b3ce1299cb059f4bcc262dc56723a5f833f513c501e3c96c75ab50871b5c8034ee887c1d14856e94a5f5ad04b12865ff150f32afd4876345ae4e3eb600120323fa8090bfbefc16711025287b33165d4423d63b1d56533f545cdb6cb692b31a6b594cc67ae3ef5977a91405ce0c7f3eff1b98eef47309141426ed03e23aaaff62b598b82407d35e4a9cc4f4d16aecf321d0e50e14bc14d6310f8786b6e59969184535b521c0e4be0c606f5eb77b2ff551d60d07551f688b0d85f76ace6de5b9bcc6f7967a9c6c82a3eebdf26581823389bd7766951ba7fb7b16657e2d0a2cfa832e76e2d8d3abde4ffaad375387e59719b70407aaef776405a3dd3fbedd1517d3dffc6fd8e4bae130667c4981b3d14242747e052f013c258f8c5e8a84377d1f8e72e57632c642d2835c6023f986d325299ae956dda6cb075b28aab1faa7283bd43f466bdf33e178b3ddb599e1459d20ce4cc35f5fb79d1c58679161c2daaadaced36718040531a4f0050cd1e10914cd5bb8aed688fbaf7cc9ebded5dafdf234bbc1d24992ecab2e006d3e85a10a03b8205a979b4f457e41eee113807cba1b06512dfe547913d6152e39670a3764bb0f824bbcbf4e39193cf1a51dc2379b4813e11496fd60800673c2adbafcbad3452586096c92d2d5207225a57c49a59e052d272860de78495b2f3aa768d8f8f986ea6eff67534a97b76bcef010c1db6e654261c8c8a74b63fd03dc9eeef409560613e6c470f4458e362b69712f51bf19d73aa878765d68be79407c6d94291b413a4404dcc08b480431f1df5ad707691fa3e74c2ad90d8ca0a452d817f552fb4c0cb2fba94e55c7a8c323406e2a144739b2dbce315ab928232d89de078cbfe1976b9f5082099bbbded08a2d1a4a73e005dd7de6073fd9436923fb42b16307019a536208b6fd252127f00ab5fefd049d1fdedcee3158a6e6713368c48f9bf84ec317b0b3e3fcc1789cfdcc69e6be098f3b30853f59eb4b8051e612a8662273af0661aa844847b9549452ae87528738ebc88220aae2a909973298084b81eb76b0826b10620b61099d7a8d1fed0b77fce9ac4e0b50aa182e3471419bc1f4609f341f05bd6c42e8b32a27633cf7a8d22aded1c692df183b5b868f657b7a36fcea677976d0312fa102e6c0434981cb034252530a43611bd01e05fb58265990d1342dea2024526d23c721d18dc9f519c9ad2666943568f336fccb0fd3b933c3628cac06108bba1e293b01eb34ccf7b5dd1ce752ef1694acfff7e5cbf1de8d8fc3846bba89fc3f5993559ff92e0617fd6f557ad1f4b0360cf5eab9a4dcc8d322cb4d9036f574affd61dec3b099e3b162aab5caba85b0e4b3a25541610539f6aaa0cd5c1aa4d759272400c746e68983312b2dd66e910e49077a5e96f4125ffb77687bc052aaf79951bb8bb38056a4d4a5a23e83cbeb66e72fba5c373ec832444094b1a7ed214a0819b20638b17d3604fe24567f4872124b683e21713611e34d21d0188aed35d9cc03edc7a1211b008e2346653303b4777fdfddc427e4512c29a79af83e8ab2e60c4302b3433aa67ce18f507f06f80a401dffaacbc2d1aa4a65cbf093a00c3be60624ed2badbcf3f0548db9f3cfd72ce2f5c4e77a85dabb75b8083a70980726f3e5d905c43131bef3f86388555ca7958ff0222ab2ef1cbba45ad4772629a071840bb73b17241f5cee4dfea9df55e3ff19c985e06a58b73d61f932df4603cf14a6078dc675e00ce5cd12b8817dbe11cf6dc44258b4ec714696236cc7988c2ec5f235094a11cceafde8656f43cc6b1b6f6f6a21287b4fae9640b986c44323fa7de1aeedd6ae852a4e2f3685a7a7b6df50cb91d1b2dd21dd12ff6e1df39c4ae01d59ec046325f90d5a5042d66db006b30c78ce166153caf6e151a8c9fb1c0ed55ea37571c46677c4a27ae64898c0ff8660688ebde277e762152e278cfdee0216a1937051010af92e76d438f09f49c3242dc794c945aa7ee9386b9ed8ef82501b9b01204f94073b384306b26616e07a119c8c1ea1a7608e44398177708a87221ae917b4e7b67640c77a045b02b6cd1b226c57f356885538b3e81a11302fd27faf7e4e4c915a3cf9efcf02a2a29cc6e529370e37161f241a4541ebeaf82d729ce66b09dd23de8ce21d082c5273ad3ae0ff5b6aa401daa7ceade41ff9a1bc066db2a849c986d0d063661207a344ec2a5298fd81b9a98d173b4711494ea5e0f3bb28ef82e2696ce3c4de7c1217c165621030e4b45ea97845a4856d8fc183ec15fa774cb4f1dc133b207b5509952521df9e6f1cd92d7f0613cea312e7e76a6be8a2652cfb6516568d95e7b2e33506481bd07aa9e5e05294afd64f3bd1761daa1b9867eaa05aeb245060ec7c46282bb06a3df964e73c8184baf46071273b6acca1c19e172cc71cef5fab04d2585b04171d24bca16a90fb1e80676a781c0624fd9937a265baf226175daa0121df0b69cc52c98dfff60df07453e81b3bc34527276b16ebe7209cf5e91620cd5dbba4ba5b98e060d253b186d0d4c6e4bcf7d20b7f0f4b8bfc1dca3b0c6dc92db99bce7d37bed029f70e75f49f699854ea53aaa0b8d64471d3b52651bfdbfc1acd5c0353b0031a596354c09085fef1387a1ad9366c031d7fdfcdcfa21f00e9f8ba4e4918adf35b84faa129668a1fecb92cd0afe6acfbbe6da01e9a571570a0d5ad32359da120d76f829cf5560e99b4f9b5e4c0e94afd80fa9b3aa6fefcb3df01008d89a30e2a35fc34a0d682c9f06d6ef670de6f420aaa096ac5eba40af1e097c2e8e89eb79b4876e3efdc339b85431c5d131f6dccd2991211d25e2476cffda08716b1784f7c7c7e4dadae4a1d5fc05a0b529d0989d703e17cae136e9ae690d64d14c088b3ed1ddd9323dbde4ef16e14d975eccce4e8bd9829461a342c5c1e8def3026b33ceea5ac3980e4e39896352f3f91b43534f8a16e5214d7bc8ec3961eda477b885df923de051a7836219f75f60e27f5ae255232000128130a2738f89b6ae2f6d815ece4962ed809a071c070c746328a03bb7d9429888884f5daf71c597511b9d5b65cd51c5858f98848dffe84c123c771bc5bd3ce35c6c178d64e66d6f460b8d6926d6ecfc0135258f45421aca4f43688882ea937ecaf91f555e28299f2946f4e13e97808718ec38eb7d6a38f22d9a672af0b286e8ffb7af9bbc9fc0e80f6cc5adc9a0d35d688b2f99788d03af614874ff1d67fec578bad38a134ab905618bb6c3ab7d2b7f3b89ab20a7601d1376ec1014eecd281dc28355358322eb39fb610a6398f83b981f34cd629cacb30f5e319197be2c11802c49b51eded7c9e71fd0ce5e64ea99d57f634e0974eb81127a84712a597b9c291ba663cba7b84758667ce91b0e8c86f3b70b4b3bfd46b63b9f7c90d34c47fe9aa573f4e5a9e027a2fe52f9514413db30f35a1616eaaf6893c7a8e90af83bb7f8d7433f2b32fcb695d3c20e9d5bbcc87c4b574ffde69d5cf3ca4cae3f2d53756cf926c22a6e246f54070745e59d13be7bdbea77651c76758e94848cff74252bc28bc810ca637c54f36a30d7ceb881d87ad022a8016b1f48e9ab6ee699907d47532077774b5229e5cb2485b4645479e102d4b0f23e8cf6134dfe9b191c4341b44dc94a68c70d1622a4b727920a5b1a64faad36ebe1a1f4028cfa7f5254e8f9097e0c27f5b34a8d2d46a4fb5841737885bbc55c77b084f765abab4c34622c0e3c4d91126f8bf894f8b666eade176e45ea5af9b221473ad249cc5eaa1db662b9cf35eb3e2a1b96d537a5c00eb4b2a9d7051ebda96f3ebc5a73d9ffa12bbaaa049b0f3ddc8f4c4f4d764c0f198b7581a8ca16e191643cbebc970fd3d153003722eb83ee19836c23a6f00db7fd68310f904f22851aa048a1ed27f4bc68e5fdd72604d7efdc49ad2257d13f5b0141e4ac365b6fb54417872ce65266e9c3a8f645bca3c6372d43b2753bc65bf65827bb2beed9af1bfe6f0f2956e64817adcd4f317f9701cad02e2c91db1e5f0a8bcd10d39d9713ff52df1092e1e7eb21941a4f64b2ba48844876d7e8800b176f4ad50dff2794b17db4567df76fc07b90dc6ffcf0d78f89b444417e018ee8c0855c1e57174abf08d90e669b7919181ca5451a323c03e51e57ca6883340cea42da3b32e86a7d8af2be56c12651796356bade0763dcc31cdfe7bb4c5dc6fb2ee9b0cf47f1d384bfdb1cecb5da2e6b403b6b9c8300a87b57f9ecb2680ef4208a4416b9508b3c118b01bb48023ba37eb39fa494ed2b2741e7a718c6ffdea6a4e184e7e184d986d1072257f97920771e41e8d2f2c453f33834de35e3ae9c7a3490cd2f48529562c20e00c9e3f5b83088dba594c9bfb80fabf4edd9c53cf4a66b152d51183d1848fd36fb3261279e511e150c0929be895093e2d1d738f9b70b796bcf0d476cea11b8a1ff24984a0c0071682106b4aa5dfc2a022545994113c3c9930f5fa36d433fba6669afda3cc90b4fdd734fc64da1789fe0beb960d89258cfe3899317a8eb30b3cd465dc21a9f032852cbce426fd776648a50a7398eb9de25f330d1f9ccc297675bc4534f938d6e29a2c95d8765531f6c8f88ff884d0967f6ecfca6feb2c05e37d7f054970dfbbd922917cfc69dac46c575249c35430ffb44fa13aa1642a909e27636dc77556e21097cf1cb93e21120a2330544bff8d332d585177e02d1c88b2387855fa0467334c1b7945e23fb5d629f4a0e14581952ac19f8126b33dbfad90471cb6535965a1b63b8d65107fecbac275e04f21b069b1737d8844aab3fc684422d2ebf370839aba31b749037b78d20d37d8812690f9218e24d68d1c8d8bb98af9db68f4450acdd798487a82ef956c69f7f003d477252c614d3fd3c54f8b726b6c207aff864dee6f48907fc8a6f22bd42b677599286961f499970a82a29b712529b6bf7f807f9826df874f0948e0f920053334f95fcc7d77154ed9bc23fc6ea98aea2a95bab24c39144b33ddc9f80deab710b5deb1585196530cac4bb4725951a330ca72a4e661916ed695b6b76532947cb75000137c082af6dbcfe1a96db2c29a914a70d4c9c30a7a6a5ba1653f52950f2134177c55b063bc8129d2c674590bb656ff6e76dcee7d78afb91cd5452358aa1ec92a7b56713fda8184d52070dacf55d7c9b135e349587cb34292fdc14416e28fe8be26eca68a40e51847609d7f1c33c187a59351cf74e42a396b0fd486863813251e8c6add1d2434261e8b85a67ce6beb2d4069570ee6b47fd1ae8b058fd2b640782e1ec16d747c8a5e10914146a9b78d21a5a4de0ffc4f76188b6cb58188e77b5285a8a94ed02521e317e0d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
