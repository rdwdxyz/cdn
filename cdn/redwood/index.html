<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a9ede2c527fec8ebae5f1dc140f87d9eab5f2523e2821a45d8e4857287143ccab7ba60e08f7ed1c3e07ccb93d2744dfe171afabf8860439ad5e9400825c47c469a8fd03890dbd9d278a923dd3bda8a2f65e96916a89d1326ae1bd82b5699f05c5dff6b06ddf0a6215fcbc262589bd9bdc36aed054bd15996d527cc36f487fe34716c6ffb9e466fae90ab5dcf1bb99c3fd5426fdb9390978d688cc479bb7cbb8d90f05b4c4e232891de67117e091d23dbcfe367a7a191369c8e1f314b34f826feb00b65940bbd9f1d2e32f91336eeb3ab88d25f0240c998d0907a4ad6d42b3ed4e086e0633e9c91247c59d39648a74a6edae2fdd77e94764de633a6565526a7d04fa299e85be2d1d4cf727b902db13d24145c6f6a98d35ca003c6e7ec6593bf845b06d9503f24f625e89feaa228bd31dd39b2093903ab6d63759b33194b77ab392d7a9d11ffad970ba828b1e1f083d566b4af312b503ec38fdf92a83a66ac29cf2affc2c729ccff24562b1679b453199f0c4bd23a0bf7a2d25f07d654b6e0d72cb43abc65449325c55e83b1f6f556b5383bf947954da9a0aef33c4d06e1ce7034910d0b3f5e0e3c35adbba4bfbb48d66f1488cfd74f6e5479dad52424fb7efa92f34f50289c11c8f9863a9e68891dae3ec3cfed1ee42dd173c1e60b43b452306d41dca22df7100149cc9b0fc8ce85759084909defeeb6401944d333d9b95fa9e25d31795d2e17126864074c07cb2c39c0ddac2142b6af4a4de8c16ba8ebd4768a497b4fec67eff5ede8001951f07caee5322ff7abad239875e151e0b12c58c3a09af6f186338f566fb4749402ef9be02aa1848be827a138c1d487ffd31bb0ad88ba894081d77c0bad908ccdeeebf98dae3d87823972929b6d9fd0985612123415d9b9dd537d675ab4395f2a722e49a94afaf9453e4e0efc6b1af8193948e3a800fb061daf5e5e54204795599ce85f1314d0b821fa5cfd8aab2600fa9715625d4b3830361268b82b25a9abcb733c6e2aba3e845dc451dc67e4f106f748392688eed17e0539e529111f85c7f7f07128bf12ec8717d3b09b34c1b59f5c302b73fda54efb02caf6e27853007a78460ef78fd3bbb0b6ba6f262497dc725604d6aad33a4ef37f20c4195b96a929310f215e763939e5d05b5bd0fddd3f935b718437c9b79bf6f0351e74168296c3f67447f1a703103f800802a8a7c9b25539ba7e08f1552700b597fb07269c9d658301f7c47c63a71c431326d4748c247770c290a821c1c386e0dc475cd3a783848e67dd31c521a23dd5fa4a786b0abe9b1f09879a2fe1e531f58f738fb4db7f1917654ea9732f0b1105740be466f39dc73a7aa062914912440ea58c06b518415be13cbdcbae26ffccbd602df236aac0f21cc6ff8407a80fbf42c7e3cdd742374576555d58015f290eedc83c98bfe5850cb5193f010645c5bc84199ac85dc9b5f64675460c2ce18d2102672baf2d0a97348c6c98afa08f1a80a51a784fa2cf83518732781c09c8f1fd1d71d89f2872a466001b31a5204b1fdbdfd29ae16daf792f7b268c58728c433f29e1bea3b013e97490742fdab684130af9fd14033885acda03c27aaa678cdf9ccb634d8930707408fcca958c245872ef955d81ae8abefcd2ac6b3511ea393009c80843c5b7ddb8a26965d6e18758831fe14af43ea48645faed4d333e58b080c87e45c9e0f278554f3c65db7b352777f5e1cb6cf9d68bcf8bda734f8c105ccbbb3ea9f2510993b0803c3dc4f5cce88c16b3fe2a884fa8541a43ae547bd02fc56e3f1043620ab9a72c6ec19c2935c8dfc8249d5cef8b080cbfefb7dd44b7586dd798725848f65cbbd2534644b7e0eb00d62a38b9be3504ca8ab310ef210cad74661b7028e04dc8ee577239a306667a902cbdee84e0e530c527ad36c38629bb6b68172f59501f475de35e3b605e11cfe99ba9680d71c54a5c59a55ea7d00c173e7e9eef4e68baf72f6b3fddfe49df4cd7e29c67781712e2a52073b58b4eb8c98953eb36160ea9bd9339c098061f47bd759c81500cdfcddb46c075a52d6bffc93ce51c19a0d4e7938be495c8a052cbdc463e373dd7143b6db41045dd6e252f92c46cd808e6d96ff89b6c24e313957899d3f199ed23708ed30395639e16daf217cf929b4c777d04f45f6e14b63cc2e6453c62172f6beaa4e90142b5475dda5b5aa93556c3da9c68bae8b9d4996897445200be00bed7393613f26b46b7bb0c754c2832e46748c245a58434f1f4c280248f2ad8393a3aacd18d92b1c6e6437ed6f21ad1dbcc3ad5cd771c3213475f0f92325bdbf5de0e402a75ee43f1094e2ff0add7a423db647af841f12b83ef0b62a6c6dca6d326a92abaf23b5467803b99166ddfb6e24530576fd04e019be51d3f4d8cb780b86e4e1d189317193a557b172f1f785dd2165faf9d640d5d38156e3795a1708039c48f09aee9044cf22ff915d669eea62b501913b50715b3e7842824a30d008a75e643c1e135b552b13c0128aa335c57f752a930c4f836906370e1b82104910e8b554f168e2bb6b9c4494eda7c132aefde6d90a1d163f4e292acea99ee513e773fc2d70a814120a70724118b0bc506ad3b7e0a49403bbf14430362cbe21215cde4c46f5877061d341d97efa200f21d44ad5403f80d4608ca0fec43b926f5b3420fe16781971994ff4bed30ab30b1e371a19e6e93a0e5c217d7171ced1d31911325ff5e5c421903aa52b1b4a4adacce6a753213447734ea65db12c6c1b6e72e4988b4388046724e27f2e3d2e439aeee2a7e7202516824a6a48b183adce1cb68f418083dcc286b4dd14525a5ceb0cddde4230a07c42c708899e4b14f68d30e35e902bdb5ae4b2b091b3726c3fbadc98dc03cfa9ed3f5051496838daa87b800e2a387f20d4549434e48d46efc57d9528d0e381d485cd582e944619d26e9853c64d81e54521c58a194f9a8053e982ad37ac4d62adc2b48ca31a1f0abca5329476de2571e9335f379962eef297ab52700ab0efc7081af16ee973c670b64bc5b8d150b48d32ddbab4b4c1bfc03bfd5bf84fdc450860298b8b0084c4e7e9c0ef1ecee59b0abad7c1fc2c46431d7b2e83eb69aa22f399f66626decd0d6c5c4e23cafdf20eca053d31194073aa368e92eaca7f4ea80636cb52adbf39100d893a27bf6fb0e423a27acc197740b0972a786dd697ac3bb0a3fd76ccfbd8616a1bade484ea8b3a448b780e3b8117f24ad2a5634037ece7a747b0b4723c759734113958b7213f40ca94b7fae96468fede25ab1e59fa647c2726891aa3fd4786e65cc020c9d2f40d9f5c71d2039a36b7013b7d73b9bdb0327cb89c3dbbb9e16ad025d691648726edd333cbd10c30769d8a2e32f265bcae28026e5bb32ebca19eda1dda62a81369002f7e1e9764eb98575783e80f2590e5707fdc24573edcdb1631ae75e2b54ba510aef3733173f445d31a41ac30f2cf00a3d20e933d6720192df7536fde9e3a7f2e752a374b4dffefad6d456e7204b7ec9c46ce3aab966e06ce712aab93cf55e5730030758230d7fd4f32bd2d9e6bfd70f971d85617bde42d836556514dafbc39058419b72114c8f6d9d67f1d9e5dffa3a5dcdb3600f73a0084ddf10a89ec37ce24d37c73a4bc5b635ac47e4a03b1aab78b3773885ad3fb8251c53dca692055a63fc3f6e2228979cbc39db9c07c29b279cad9a4528e83d63e529989e14d0b7779dcdd83f9b9078d3a739a53c0ca2376b920966b7b4a445693af87c3ea815c8e5207c7adb864d849cecb1371c366c40f3ff3f250581763d4e024a7765e673b5a35f35614ef49ab12059ff75867efe124bedc2187554237cdbc7ec26d94586ed3bfd45607876676594d64e8a5291878227be2b950a21d21259db5430f2576b0d319e49999433e3ae83d4de16e4f25cd6fd4d18dcf6b5b8e056af8ecf7118cb6d7611a6c5b52eecfe6143676511e1b2cc0f7b60f2d1b58dec698aa97587ba831b64d6eb609846e0bccb18dd8bb9ea9bfd8539505e885f039d92b4a7b76fe6220facb112e74a2fa6eb321dd5fb0816f007d7e6ae775e25db0c235ce6e6ce9bf92e92d94d6a9c959f9a41a1b42b7301af71fb81278932e0d471b2e46b4f0330084601a60f13ecab75b13cea4825f983deb624424ec554c8888b7499c063f8852bc586c31e3c89fd8e8441eec87dbc5ca01abcfd531f41c75285d0b88fe657a3c5d72348b8aa8f1823c7251f38f599cd4aec91c4d2d0374546d976291bb67ae4ac8e963ddfc95b217444b3b11a3381760b96c54ad518c7786d10fcc4247aefad355208cf5d098cad9bcb4c874214d595daa0aac4632605170ba22f42ad6ba889f67922c50ed177e018acc66d250bc6dc35fae946a60ce953cad20acb0cd42cc4182b6115f53c44d24c4f4fb96596479ec04dca302bb061df87c4e5950165514e742df7594a242e611d5d55ee9b1f5e6d65fb84bf91df2abba6257a363f5f6857e7bd654d1e1f93d69f241b16bd705a8f829953cdccb09a030e485dfd421a59f2b946d79eb844a487cca98f003d2b21f54fd7fb74c5eb338cc0a6cf365e8ab98d12b71c83c66b5c195c931b69194e5cb17d58bf159d0365e30d294b4b4014a8367c414fb637487754e1146d6236d9d629ee4ea98eb71af6eba17f6dee95cf6516e3bd2ea4d4a6dbf2011fc5e06d28e13ce94fafcf258111bdc49259cc4231b1b599d21b5bbc10167c9721af5d8730099c074536ac5628828e2ea8b1f164e2e42e5fdeb89fcfcab6b8c34de6976854d9be25f3901dc80e113ed912bcd5323ecb80f529fdcc74d167f84e848e5ad488629ef88b798aab95df0bb0f3ac11f9be2b6ab64742e6460c56e3903615fb8ec863a700a04e9218d71b5101441f75dbdfecd30303b0188d639419dd6562dd6e57761743700a3e94be9762a11a1e526dd5f951297eea6d890f3fa9b40d02e7b8f4e56d97fe93a9567ab01c504c47088c7e20beccd80739e59086b533804e227ababbb87a2ec381d844355711d01f5a05dace9c179959596c59d58f09110b8f767c4911ba01ff439426eb6c431831f907c58cb030b33cd201d0b8ebff3f7b4929d8a035ee7d08be739547bcdcf96f4c6d24d36618acd933f71557b15dfe544325eea05be25bd567087d79539d7fe342d2e7f03ad3bf21c2335b9fedab600d57e59431ff90c53eea8c335ed4c302586f50ef37c597cbd96481cf0a4a534731e61c40a05f4474c0e3ca1c41eb1b916072f80b274e20718c1e530e84a4ba1a2ca2a7ecc5878f33b51ff03c786d390b73338ddd9ad110396e713ba1b2c823ffca1996edf22627da28c6f854a6f28ab34f0900f6f05b248dd92436526c563acf3a477f6182fde0f793e03aa960a188eafe426cb1822319b9291e28ab8701a279542431e8268515c75a246f0faae88ea357adfe2e400940ae760c12b06c11307e4ffb9658007f2e7e1bb8e12b81d058690508faeca17a03ec27671fca4cc7d74f86910d697de21cad816f94fca5f7a2c60997bd67227c5dbe173708b3cff7954d0ab022f9478d72adbf8773a071c46eb1f175362111b64dce3a737bbfe6851f5484e3908df9a606a48318a3dca085115f9a4a6d61070e7f63948f4f4340715dfb86f98f7478861759f7400b51595edabfac6b6d18698f552b24d74247897de804e289340afa6ae769bd826f7b53a0b539aea2b0f9eacd1d817f94ff903395addd7a4314dd27d07e170b6ce6f27c9e304783fcf0915ded1cf5db6395bd7c3863098dc6e1414f692a84876937f81c67ed357e314d4c3f1aa0c526e975ffb849fa1b1fb5e8eea9771e830532c9e5def79d065d70ad93afe8668b73840371a742e4abc3b07f75b9d9fe3076683c425dc25c53c4825de004fa34cd87861b6a5ebf4b651bc17b9bad74be66622b69a0d1992a87d30e120fb526ba091ceba080d32f2ae532b96fd62c4a93d99a7a420d04e2b517f8d9e13bbd07b5f2db7a6996c4d18d5d378204faa73c04aef13b276621f13c35796c044a4b568ac04a4c1a1227e060007aa6797441ae637326a88078bd56518778ac6df7bd66f24adbeb453db6faa1ada15d8a899e58d30c1dc8e8f89080f1d00c323076288c7ac90956a352671af08731b5cc9bf2f1e813bcd809ff5c07d63345925867aa15dc465c02c4746a03db5fcad2b516b8270e28de81e851aad933d36d53e70f3e9cea6128fbd9ebe1e01f2925016fd6fa41510800716cfafe7914caf07b91a5efd63779de833d44953b192b03bc7147144e2b5e4d1b1fc1c486f87052fde25616914444da9928074a8675c4333604416681b19eef3fd70bf6bb693b3abd892c05dfc5250edbcf8684325c98788a916c5bb2151380f740d02ffa81da115d028aac6a9943db7263eb85ab973e581cf2542dd8a23a791d9fb5eb4a47310a8f78e7bc17b95eb17a6b249e60feaf48855fc1717b14c0d2fd6af122b0356dd5bc9466816f85ae9453ab49ccd6c059e5f8a5a05ca274ac0f263aea194fbc47871c664cf4aedbfbda37e3dbc0b7841eb7abad35fd92cf6011708fcfd3ecf629881e454efe07a027b0d62d067aab7e9051fe7c717c213d2180fc3f9bb154e1909aa8f558707c524c32f923011ef0325492e162123ab41beb76659a1eee8f46c36d6c3da8de34442edcb3eddd0bd163c469d56259ee114c0e78a40064604ee2aab0ca969a62d1cb96db15d9bdbc5134967f4baf35da8b3da4af3fe9da45823bc7fd1e6d017fbe06b7141b7172c304de40f53687ac5ebb5e56ceb8c3bd5b2d773082eff595aff9cde7e651c6e228161a7d2a33d2c1daf29d4ddd3d2ee0e1bec205f37e9462fb99fc2a9e95adf6800a7f5e54287494882f67e45a04eb0377c83f6fba7f6c3efa4fffbe894d8dacfa9ed8b96b717fc60019d7e9dbe5332c94fd533a5f0b6af489b0801cbc7c00d29ea7b2d2ca52af9f867472ef82ce57f92bd6dda239a8b242c419cfef658f219eb1eb3e9feb338fef295f620e26d9e210f66b4c8674c46005d704013354adec9173877c598aac1c4a7f1298da726601e21aa9b7ef074e9c4d7ac2372fcd9e0c5f689e456e301c290c31d2b947011f85eb0f267c33355bd1ffce4d5805fd2606379eec3d6b5e9c4b03d96a333a6929395ed690c65f2271a67af78f95d141915b678cc32b7af78644854f8ff6307b4b3430e87d24d27df2058150e8edb1be0be7b90ad813cdcb068ff479d00378093eeda53063e4e300fafbfa0388ba2ae10f1e7cc65b55c6e23a2c486e402afa79e7fcbb1a819e1003acd384076c4f09993f32977a6c30240857393c768499b71ced62ff0a56add291911eb966027436c9fc4088501535b3211f055633e5653eca1ef3e7257ec0e36bbfab39160df42d983c83442c22a56612300c0348301335af8788345683008638d64db06ade2bbb18c70b605f6842939539084e5a1e3b08ab82e3d68bfe4faa2cd5c38b3766088359e39b0adc48a9431e9bf98f6905f6cdae025be056fff91439163eb8ddf1a0dd5ac554aa32dbd1f191226858c3c5f0231d67733830a73a38991188a09729d2e872044b6c4671942bfea0e649c0aa18012f1eafbc25cbcd5fb591fbc749f7f479b71cc78351a25f451549818d8e7361de363f6dc10e1c8e6dbe092beed225992f5e0504d7206f25eddbc990de1df698003783a05be1b91e05e1532571413248d19d5703268ed08af33e83a6af88a78baaf189ce4a20d30e2879fe8e8297354f45b3b685e55434a4a7886902eedf03a9be1c37b19be14b5f716a3415adcc791ed9c37007b8607f883d7580edb0a9eef9bf9a9a217ca2a5d9afc604463fab11a115cf63f452e192f3fcc4ad6e14034f309742335780d428fdeeda94029484d7389edfcd530a136111996f4849e383fc88324228b0486ffb8948855d1b4741c255c6da9da131568fd3048619ff903157d6d9c4bf95292190aaa62b5fa7a1cc5ba9381ace1d93cbdd8456ca1b18ca33579b0b74930d495c25daeab70f4181bf42a87c901c5ccaad2744ef2b2fbb74938205c0ebb02d703710c43c68de51798e7bace7593eb5619f054aa7048de100fc346e9fff231f31d0dde2285a9fcb232f12d2c154fa41ec6e560f77ef0fe04bf2d71277548a75b989a99ef52f218922e8433da3eb0a3e62679e7d3b2032099d26aacb2206cffa697a124254a089e13fbda73b05f69e188ec511c9dea0e4e1738d3569180ad08bb59ea9996498bdd5a1324b4ec7f45ce110b07b5c7f0c87980e1bbe279409d452edd0435cabffade5c7d5b3399d7d4d70da00350907042eecb0ca6dc8ead0a5699f917b3d9e343ba54f4b5a5bd4766b418af5fd76f01afba185883827e7ee6edf698db7c2b6fdcec0a72e0c6a18af44f9a98689ed461a361e56acba92944f46de8a8885aabde403fa0d09dbcda699a1f8c229b2c58e767be7a8cf7054c40a47f1cac75df90b3de0f5ac35241995e9681747dd1856de340334f378cabdfc5929351185c1dae3baf527e2b189f5b5be9d2e8abece834a3247b6444b78c179dc3574d6f1bdd6765a5d73c850852ec837db066d692893161325808ef482584d94bfc8444142b4c7c193f83bfd646d75035d6a4f1b87f2ab1a20b2422e37edff94bd02208cfe7c4b2bf344f5dcefe6aad67db81a8034b0433807163f567e0bba49c7574cda0b3829ca183ff0987aacc3a725d30609cd275b53677bd69be94dd47cd5eb111657462e28aec0edfb0be229042605fa2f3503d8067ce17c97ddaa49e556773d124ddc3964956b56854384d9bd598307741410763b038c463a09f5b8ac48363b3a57b9fba41b9155e69a21789001259a43ff1ded13ba6cc9d43537c721df6daa826e8693d139d0e8a2c79bcdede3c47f1c4394bb46a73cb1bd55887ab9103f2ac496500bbdf41e742433f219da9e3b97f1a5995dbc7c7d1db22fd21eae14fe2ee23897c51c9477b80eeb354a821002c050af9561033da1bb29db30264c907f2b768977df8e62d46d7e215624c5ee445ecf3963c506336b5721a0f0460a4d57455112ec30bb2c3840cef23349d635cd30d6e9507356b25961c0f8961fbfa8b178094c4d467f56018dee279c902ea97fb79ea1d284fc76e1d49569f1c8dd22d976e86b4bbd552fb47301f33e91026800f0d3b0e238d345a07b4e7290715d3bb2ad92d2ce8c679a49ac1ea5f752e61bbbfbd67faf240237987e3059fe021a2123de574cdb8ff69b29db52d09a6a4d601da436d589744b2d273e520e60d316a9fe9e31000cddf11b47a7ddf9b452e085bfa0dc1c2e68e07b59c1864bab77ee246c4ae4172328a8295167cd1e9bae87740cc63ff3af0957493675485d65ff29ee0a11c982aadcde244ba04825a537279337095893fa0dda8e45b41ea8073f378b0046233abb347e381b15cbb3f3ec9258b816d1faa50f72318350ead8b4260ee4ee33959a7ab036c9b9b3076cf79931c5e0c614b3fba5d9d1f9065e884901904687cc28afbfc50476dc395051fbf908895152cde6a7428fb1a268d60a2b6cbf730b688687109c5c77a08864fa79bf81d4a9dd7a9aa660d7ef1803c0361aa886997afece20ed3eb04597af2850833db59f79d7847417e347c7018893d376a0b5ba0a211836d4558d8e29ed161a05c718fa44d07480551482ebd1ee530a2d88fd93df8fd49b898d29868088451fe6c1d1feaa6917d1e6717e2dc5d8d35623b9f424c1a944f0fc588811cd60a0f629bd49624fa779c153f3a489ad970d43edb6bc6d253b6facbd99f201651a7f7e234e33b85bd7b05056ff7d9982584e70f0d7a1207d3687279f79245f3e91c4152340dcfa8a2d91e2706be4c849569d8f5b3ada72d4888c1c48a32c4b671fbb5fc3e6b63a68dff8cb1c29942c05bd74c44727e980651b7908ed7c4f3958a870d1f5c70a38fd566218486d19877670ed3c310aa901f4f56d1835393f8cf4596c5498b0a7efa3a716e16cd43b1ab37df6c3bbeace8d33c9d23a5d6f20748583db867bd2abc14ba475bc10d2c9fb8033f09ce227fe9d7f012a66f5876abdfec36f77b906ce2a05a04abee6141c5be6588f69e595a369b12f405c2a925e5b0a74ceb2aa2e41b65bf0b1a5fd15d70900817d076a2a29dbe937a30888d7167f43887a93b935194af76a52a0ad550b8eae32d1c7f7e58bc1b03f257887ba5b1acda97945e121861235b95f50b4a3983a46fc8197756f0264e1fb09776f352dfb27e506d5438eec29bcc5c37f46f4e993a47362bd13ada1c50e8130bee07433ee501fb828ab03506d79ce1ec87c0dee30cf8077366dc44d67f4fe4ba614d4434a0a7f52d38469f91ddbf2365d9c3aeae86e731fa21cc0fc20b05f9e461cf3a1757a009c03bad7110f3162e95b5198fe332ac62c2407341d111b8f54af429a134516ee2f9ed38cedb16fc830d358eb1b55f8ba06686bbf1970a8caa3cc72d538336c1a90a934a4b38fe47c38098f07ea52eb909a1e46e660771dcd5d5d3878c3ddfd4660378a2ef82010effd9a7e5cb0b74166e1f3113c4ec0a246ca9f08370a9c28a40960aaf24ff00bd1367a6c0e1634b9033e061f3330bb3f29513326ef8fd445049c24a316c7a040a975bdcdae4a8fac0cf811c8715486df5c999672250628d6ad8d491c366292d3c60aa18f48a7409bf790011f3220d29db9b42e2cd51f45fc98ae2cfab6e66f4ed4b67e1cf10aeef578b4bea283ea9cf4dd54b1475839ad9570e855b0ec61b1f1a41df9d8bf9c80bb298d0ed2bedcbf76a517eb6c7c10b3536ee0d6c8013239d4b1a273b28aff830356b15b26189262f7936279cdb238eda3696286a5527b620f6fca4518229536732fa0ce97bbd387c080acef04e432d9e1e747bfe69eaf771f5362f3d79bc9c710dfa804f5f980b40691bdfe15954e3db854bb3c5b01bce3a3986fd7d1fd9fee47c14929d069ea5ff37ec51a3c0498fe70841eadd0e53ea8ab255be569d16703fa9c7c914dc917bab66d2d84d4792803c01b0250ce6eb10dcac446f4d9db698eb6305cda986f7edd451cd8062149de81b62a1b3835167735c569882081d56f515dddf0307561826eb7ef83d42eead1d5422da7ff030981112e02ea0b90ea0936a827e2f83b15ad130c388eb6ca51ee35985b81d2ae8f934d48ee2eacfd9137ae02cebe14e8ac47898f1381b82b74db204700966a69da95032dd470df3782dce4e0c86ab9650075b2ac77c8695ab7a55c901b544c6eeee170e81b1d0159b37898270cc067d48b3aa2ca482bc4f7983f1c7877ffdcedbf49b15a5986c92c7a1178dc82d66919a008eddc3595dd5def0a0ec225029d1e310a80e41c36b8c9f31323fb7fa705ca5b85f04655d876362e1634b6b0fae5cf9875791486dd38c52d5b8e0b55faefc7bc7c228a36eb56dd0000c756c6e55a2c95b6721ac6b21ebaf1570b4830a616b5bbc7672af41b788b07d0dc29ffe301dff438a4488309049b61d1edb46a989b72e213846a8b3c5e482c9237be3f4cd0d7496320b853f66020db88a31c0d0c5e57dc148d33452f22070b17807f0ed0fed22070d50b87be261a520546981850ef262a651304b91635bf8402f049a4b202001e995d1a792764443604cc648bb2879d1975195fe60a96ec4838ebe3b2b9a5e74437bf5fbf16205db8045f3041d725d343f76f61326535688c008d00b33b1751ba87eecb6a376be7d6755eaf8aa5a519b4f02d8a03131de176ece073a6d7b30e526bbe0b5eaf8167dfb14ec7b3b137e5e97b981d002877f0fa3cbb3d3448bf2118f8d1944667b215b678f0dfe02d89bcb318f88d553a488cd843b227c9d5b5ef8d22d07ec225b289b90724df684f2136a1018572c6ffd4e9da9d72425e9e87adba387988f636548eb36ef4a01daec1c1382cba107e192c57199ee238e71131856e3eb436ad6ebd1a79e718df5ebf78c00fb85190a3e61ccd87f1e487840a24a7fda8a6ce82ca33bf564df552770221e218aaaf5efc836c4d5416e858d63df9733e665cf0ff32bdd8ef0d3e65e11b39e090aa964cd3fbed62323d088b5ebf8346d13134f996ed851ad1fb23b680cf965542800c200bbf490b0574b34d08d9afefa02c2b09096599838fa398801d34f0cfd3cee3f0af3d6aa66d50428c4503075059879e61c709ef7694b8abd27fd6c358649927eca9c6a536ba224368974b8650922f246c8e040ea6484f88d2175b36973e01d70c7dba1bc44f76bb3e262d1d767e62305c62199c863337f25167d1acbaf595dbb51f816d4d91708a8cfbe8dae3c1a1b43b5ee67b827e8159e14dcd51874e4a0d5bde654ffcb95ddaac32948a47110553a103d01a87179181640dcf86f3da2d3832d95a60a4ef6d6bd574415d62e0c07c79f650703931f8f25f7e02ab257373c7e6f9eefd42a2a96088cfb1b8a8ba3d1ec1e3ad1eb28972a0deafa5f5a04244599fb5fd5f36efa8f556f9f931f6e99853f31f231103a04b4fd87b7d7e6bfd4ad01d3c0cd4c7f6b3c420f0361c7a54209f56aacdf07e08c07de6d7c17b0282dbd0ad45cb0fe12264bca79d3c829e3b3d666ff4d46aa2590bbc96ea834f480178d7c4beed84bb0118afe4bd45564b644eb64f9c1630a7668ea52eb09e9634196b2abbde738d1db8c8987cb5621d75696c4ae564a9bd46d142309d197d01931ac5446e773ec306b18d40fa1845b7f6f6a8aedf32ce6adbc2051285e3a5853c60450f2b827813997ea4c9cb7a4e2fdf07ce873b3190b393960b155cbefe1454ea7bbe6e37e04e27f1b0b86da2d78f8f267bc79b0d159f42f92d07eb693ea0a173528d169476358b094c598ba7466a4e758ba453bdfc637c13900fa44173c8b1654c7752e8dedb506c2580f7fb07ae6b09cf0773e33b0fc3460f61a64cf77765c6fb1d505127722021188f49e22feac42bd1d9b324f2eeba9a6b6a43a25e57bb95c383b71eefeb92aa7acd6b6c73113191408ddd1dd7689871f51a723e452812eeec948b722aa3b5d6c079b25ce08dce3e5736184b0886844a60885f855247221097a609ecab50f5cf7002a5a375edd570ad1431c275fe47071333772c28d214178112e27c490fe528d8ac4462cc36e82456646d56c44aab645442ea94b1b08ddf0f9bf8b7ba7e94f4970bc9e15f44d0a408d8a11023e3dd0b00b53cd611e0297dfa6c521281018254ee6cb2a0b5566bfc6a0447d2cdc2486b05f7b45aa80f092561203857e5f4b91296ee2fdae080c9191d8f58ffe177148d93cbd7a7402f524f408b49f2a6a1b6f696f1ade87ad90d529450609c931f94cb60c771f938080c0a9b786e40ab9949b01bc4349f1aeb545f3597b397e45638168362c3fedaeb35130bd4f24543ecd259c506e9a390f1849b792392aeae2499448bc331995d5c14694f1d566efabe84cdb8d0357c953e663b74fd44e20e300dd41a5459921de811cf924409ef963582c92a8d09964b673682e329cc49a14625ab48b92d092f5cd1bfecee94d04bdb80d44b286641e8f52e8ca0c10672bb5dbe53b87314fa7da61ff71a2bf5f33f965b2dd168d4cb0c1f9776bb579523c85d4fc745800186161c1e98fd7a0db0d4b929e456647fc7c0e0f4ce559c621c9f44506f1799c60406d7bfd2ebfbfee606ca935a4d88256e817b15160093a5d4b10a93fa57dd0bbe104934caf7c1030b093d4504e5f02ec92675ea7a87cd7ad6fa6676ade56738b9ad2a2cc8517aadd4ebff2f5833577b1799efc38dfe8ab4946a17bc32e4a4550901b6b4f8ad2fd6b3ca433ed4233b8f842d85bf8214b08b2f1f62f30095186cef28f16c1743c497ee09c9c6985b25a9a99450b7efa1322fa593962cc73dd17535192e40758fe61c25145be4fed50dc59e76ce11e5d0f51c16fa8d922a6cfb2db3f8872244f1d38d9229236e16b195fa7a4227642cf63b45721910e890005b363100ccad4c43188c3c82caf84773dfc0d6dac70ed18a69e61b2d0929cc64d0ccbc960dc7ae4aa0d3c7b804906ffcea75957356eb31ccd208cae04da35333f0536751c79f54683def9ef76fdaca81bfd28a301bcc71eb363b44d7efcb560a87ae98bfc00465de4f1a155281c8b63c818d2d8442ee94fc241ce23160bc38fbef6822aa4ed28f0d8921196201a715ff3d1efb74f36387d62f2261cd1d92a002004dd59d498952999227c10fb92e5573de2ed06b32d6b6c7a086c8ccb17883a96a1d564a4ebf73064e820c8eff1441b1fd14e0bca70bdc59fc46fdf1b7c07260391e43d0199bb3684125883fbd84734b525df8b37516d47dcacf769847111d6fc80125eec9b69bbe268242054f0d7cd1e11394e9c340e0e8d83643af91263d4ad6687585e53a8e84db41cdb32078cc01b9b923e31c6fe233b0fc78081c0d4811f2b8d51f2a42101189f5aafdef06b5d40df34b339b79c7321a3b95d9f147dd030d16cbf2bbc78d451138559eb5a72871b57b806ce8fbf5081c6ac1479a4d7ea62683b0ab74b0dd6aa31804258337d369965efb19ac8679f0d7f5250a1d9d389c6793be13f75cbb1b9bca8e80e7e14ec6a66a8b39f8bd81aea1ffdee2d6e744494d60b39b029c1afe79ab2a9bf7992eb26ac633ec6fb2007490bae5f9f35e323d17418e03890d32766a8b481d49523a3df581f831ef77705382ad41fd12801ffea7445178f24312906e069a5180051fc1cac63603ead59a8cbcd7d5355351a71b621ad2039ba6bab7a3715a13e658cd2cc1f49dd5b800c2917a65d8a6e83268951d65bd1e7b7964bef9b6a930a4720193a01d23d36c6656ef683f2e991284f0c2c31ed60d63acb124bcb1d5f7dd5f96e0f510d28d1356f9b8a52364a19138346d1b29ae98f58813d549f9087656c33651a21014cc3ff407001eb20c828c2b6b5df6906222eb54c381b86bb6c8d23585b5882a311c1c24d28ef4e993f19390743e8a7bef323cc4066fabb7b288144cfbc230f7bd8abeedb46ebe15f0afa8e3113ab86911dfa8f375cd1289912596cad156d880c471449ac1f573f4296fbd5f1201aa98ac9b69a1e1ecde586bb82043d1681077b8fc535d533d8f9961a7c8909c58b99fc4e1638f8bdc4792d10a3be31a98eef8b7cc2a9a4056d3fc4958ca46e72eaef125d00a7d16","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
