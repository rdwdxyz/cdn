<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"568f32d4b7aa337fd34ad61cd956647fc5b61db1abe57037dbc98340a80e6eb5f6489d4c0b2c2af73b40853e2bc279b3f82cb31fa372a9ce09697aa88a5d068ec72b7e385b59205636f6523c147ae55b8a28d24ff69e755e4b0335f928ea9a5b19339c0446aeff98f53e03e339a580d5534b082e80d5c734e147fe4f73c784f19b6e7e2e0af0398b6ae0a7ce3ec5f737d693563a738a341e4ec83884e3d0becc056ced1e933d10d81a9607ae73263aa68c1fc52be300828e06888d6a24e9eac08ad22780808274a80a8749a7917864bd7c49a691101c7cfe6f4266585df5136f45af5bba49c4cbe3310301f1ff5da2d8f8946fbdc668847e040bb469d51c6c72af0f3964361a673640bcedd9923bbd198f5d8dbbb7b1bcfb608581cb76380175c7baa0b5d3d3cc9fd8aa8cbfd0d63b9a2f4ca832d07b0d1a7283f4e1046c137e6728a72e0ab42d0b816335dc8e1b89bee15f245a534937ac29cd460d45ab1ccc566cdd95ff2cbc3fea2cc94a7531cca6c19c7c6b9277e3310172844ca066911f8d871c9e1e64be910f34a66ede14ac3a4616b183071d435acb73026daa7b6f1d37d688412fb03648824bfafe8c9fb689dd6a92b518e7d14a98db1506d3a36b3640615478430dc288baa273a1db1c7a7365d5425250ba21cd558d92ac8e9cf11b831767268e05ea36d985dc72e054be278e542e2d573a624585f643b9307f4ca6a7cc26a646bb69893c6238bde9a0d5e221930800a832e72b56667263ae27f0e9e7c4fa6fea029c04ca3f1ba9a8e8919310514e492c909089a2f1553bebee3447b12ff1089abc31424d7066ac960fe7f2682560f9d0889950ea0abe40ff19707a92ba53683669abb25d6c6a238edd5b3b507ffde85fbb7b77837922b0e963af3995e7abc46dffe31d9e251d55e81dd2051aeee0e025710adeef2dba8c1908966502b97c09c9ad121dcd8f21a401c855d1fce0b8828f78aafa1bf7bd3123ce8607d2f106353fa985757fdd1f0fa161b78f5c5e4ca334603bac5c5f5d7a3c355b3a723f90b359dbcda81fd40673feb6b7c687ebc8ea54d7d1b95598af3aa2819763ea1615f1463e0522db12dae928e6ae831e715d0e35b90a2465ac1f0aa9a1c7b963bfcd07a4f434dec3a05b7e451f14115749284cdbcd3f0a4a3d6e10cc1cf388b489b1293416dfbea74130760e66110d014b55dc799882d93594a3417ae136c3e240a16ddec0ecce11319930728b315bbce78ac6736d91e92614bc9a4010c58cac0f2b6770e169001cb0bd5c8252f71f6b7e340176f19e4eb98be387e2a378e3dc7defefe7ad635aef26ea4832318ea42173f089e8b4618961b5ccb7b958a2404ecc2babd9a8141b98b539174f54d3ad0f01037bffc895ec2aaa3b31deb89ea527dff7684fa331e57b47f61e4b7ed860ceb97152fda8489a230bb3568bc7d1f074a62fab57e476e952755d74e6aee5e1fedbce0892c3c41fe03c058cc46ee27c04b79de4633d4372781e7be7daf1a33dcaefabc7d7bdf8515ff429e024f9a510cbef4fa94e4e31bf4eea03611bf6964f9639555167cb30ea7702b3bafe997c294a96ddfe34d8f71a82c02c8d6d90f77da2692f414ae5d1cc9ed1e4bdfe2201a8097d832d2162dc5bd908a4b4106361b94a0a36aa8cdbebc47a3659a76ef0eff41adb9bd7870a4225b775a4f4c0e4c0353cfc2a3df3ee8a8ff862c2226a23ea7288299a0b15f472766c98acc87b024a8c27f9b2742f193c3dc3af274994aa97e417dbf9d207ef0aeae18cf63a9026b4aa32a1195c489dfd072906f987b88e5c33443b9250da7d8fe61132fb865bfd1726f21e2ea411310b014d9524e03e81f7b05cbb334c4507c30c963033a5d891495c82632e7a51778d855709fd819f44660d70ed019408fa55603f9bf12eea9db3cea45333e57d3ad43a1c58c2ec9543cc708908da20e3a9896dcbb30cc0484d55257d7e433fbca4627bfbb64be9040bf145ced17c1aa1228c8065cb3b43e929cfdad78e25ae979e8642b46bc23d67bbf2e1343dae5b84289c01dd92aca588add0983f1e25e41accd6447d59504ce08ce303add73639e745f6c9871db42c1459e0683782ca9056e629b1e2c8b563d180b5242431c3756f8eff39a79e372289fd2f3018e3deed98aaf584269658a0d994ed311f69c027afebc7c9889146f18479c50b2bab14aaad6030567a233e465522e9e3ca68d97567d3d530d85e24ed98de6b85b2ee9cb525af90b5e693a73190ad40f19fd4764e083a36afc37af23c88932802580e94dfab1b6d1f26c6e9a5785f6651557155fb880a8459c67b5ef3ddba96d258b318df4a701f74256bb3e142b8215e198d1339a52f97a5f2a5a1197332cee6abc5d8e8dc1b0a3102444d805c962db17025a48fab81a63addb78bfa1cdc85563a4b120b76f77abf7a41474cbd7d72aa3be369af5be3c96ea0a0de6d7e899a14becc43122e466a1f18b41c711bc8f8c8cc884a6404000b9cd4d4fcc0cce5f51ea9487c69244c16ccaa473e61f0bb9bbae22cf925e7578855dbcc87fb2fe3de38f0d12b4fb3a3f2f4b1f1c524bfe61ee393f9554e479d1f8213915b86a339c11d5844303e2b3e5173d80bd2aa44279bb97743d6919670cde374cc9cdf817d50cbbb02799a6c9000d9598d7eca9ec76791c839282eef01ae41836fa26cb3b25b61933996284cf24cd74aa3a521be9c9cd0bd007eb84c9a5514ed24cef254ed1a4acbe35ae4b24c2a992b633e1922df4c7a94974ae1a94dbf2c6fcf5d43afcf7ea5fc36e15d6bdfe69564151a15db3e2307da4965e1aa976d75bc4e5683899c9409f8b67dd1b4aaa2c7cd83fd025bedee613053e92ef88879d1825ec1c4255a9fc7f986457d77a48d1e6ab362c349fc2ca26c08f6c1f939a44de1a1847703fc0e4fc5d105c2ea8d2087e9afcc31885c6a9050efa210fa150d429f3e77bfcf67a594311add18119adb41b0d18619e5a2d3074bc31619d537378acda5c10a3b4670bb2fe0df7a94a4d6ce0e19239b5bb99913a4d68090cdf25144589e05ada1b2029f421946ff5a480129424fe373307e26acbb9feaac4091d2e93d6fa955e451e4f02995939a6132d56441c907949638a3b36049150e5505555ed9f82c697a7dc6583d3dc2308cf23f2756264b34abb2ca692858552732b8f42d95c86b24fd68ed830197375f182e7cb6f7e6373b7233efa960c98e7eba72f5f18a3853cb7f3f29929712afe65f4977a5529df68f5ef5a8538f4da49c119f83781a08ad266b5e8bd60701eb0b57c1081240b8af1a8ac1c5af0140cc6235a069121fa2f2e513adee4d40595349ed4685e5dc9979643ee69c041d0bdc7673b6e2dc5655ff40fe8761e27bc2058a2c6449118746d2c5e769803240489b6a662bc501fb3b08b80c539ec7c6cb0ad0b5b6dc245f418068b77b859247767ccadc891d2645d7954142f405f8233ea55bf8b136aabf7d10a51e4f075ec91c7ebc9214b8aeaa6a2b75a90be7ded393d4f61da636bd0ca80589db146e38866dfcafbb7a69043ffe2d29cad5010d2171ee56a0a07687e803ecadadbe5b2267219b925071330c83e1ab1181e868a16e83cc4e9768d14b0ff9bfc3cccb818b9f58118d94989b2767f7f94e620237479c7fb26de3c5267bdf27c716ddec4e01e6533f424588308e4ca36ee3a9bd91d75356a61e9402e3484804914ed38b46dfcd5418f06c9ad9c068d44c73a2489b098b480d5dfbc011266322e74dc842d0f7514b01a4c1f04a5db96d8dabb368271ec85061f30aace9a2572b30c22befd962f21adb38d95200000ff3d6ab1aa92f1c8aa183f3ee9d52d11720ec30b72c7381523214a91ebcd63f716342baa9f71725227e86d2bf041627ac9fa9a7c00fe6164fd18f6aa05c0af6ce1c06c1cefa2dcf925b4afd28de5e10997369030400602520677e8284af2e92766f771709bdd642de8de1d19139a861d48280c6a2fc5c843791bcd5ae228d9303e892190cf648a1e4db348687232841418dc30f5f35d2536dfdb97a29f61b2d318226cc2fee164081fc0af814cdafd3086680a1b8f2a080cfa2543dc7f1fc484378753e3277b9814bcb762f22ff126f51867a9816c0b1abd6823bb75757bf22699b1662018d13d3ca655a9155a1d3252956d46511239c95f4bb327ef759e540f702c89465eecd04f9e278411cb8b606fb3ad0062a60aa1a11d7217595195a9209aa9c3d064e43f52b6338b1773d5e5ee6681a3dd35d76559f114ee8345a38c9b95d976e7d16a2c2b8a63c5bbbaf391efec46260d301a88df3653e9f64f1c0a671c4fc8872b04d410687a6cecb1291cf6e4b48db5386a1742995a078d718c18e7dfa632ed8639dbed2ef5b2c3db8649f5f593f9e2e04ca9100c0972aa88b69b2c6296144c7040d1a1fefd18582b24ff58d6faf232e766b844ca4038217dee59afa36a3e2242a436360c87c633cfd39963345eb5537326b5d39ca74838ab22ecebc33b3ddd3f51f40fba2426aa56a5ca721ac477c9101d29ccb3bd000c4837ede54fea017b9aaba6db70c099ff5df4e9bcd30249f2791abca302b7cd159ead6ade1935f782945947ad858c8d82f06787b5696b40e48b8e4cca6bff8977c1a0d896c4a905cd8d1949aa1eca8e859c743dfd4878805a81a1008e0b2358b9b916362c49a5295f45ec8a33b9ea5a0820f2ee5486750dae515356329cab8e8da7f9a3efefce10d40ab3ad1071ae9729e2cefa8f21781e3ca9a4fd332f67823ee7f2241db0b30235d440e9b0cbf55171783924283750841651ee50355f892ffb1fe303aba5a36453c53a47df1415bc61389c89e6350344f9a090f6832bb2f604d86d1592addcedc2788941121c0258912fe569821fe7cd0039130cbd413b1f1ec09fba59a9e403227f103dfed228019a2cf268afe285da6a6a22a64677d76217568334fe4435d490297b2faf99b05de5a1107af180ccc67876fc9a569c56654dee1de986fb35124c01d0b0de6f581b9dfe8a3cb9da4e420c43961b34135d9a9b8cb14da4f0e34b7cb9161a3969720a9d4a432f436a0c78fb954e175f3ba0fc6ea52e27982d3cc15cb032f62fcc828d1e5d5246b815e92fddae894d25e4c9a2a273f77119812f00923ca5573464709c328fb688e5c25293783221b5dc59328364ffb1cb78cba7fec6d5a58d9f8d59ddbe67343e126b4bac8e26c8f5faeaf6c6a0d0f7f221042f7f337b12ba071cf88739b961e6267d63c7d9483b71736a1ad83fedc4df578c61190316c97a4e8c57c833e0d76110f7f96c2103a3ec3edfbc0a72dc6f601f16af74f883ae66d505b9a30763615089b47d1084212c29075a97aae020f1bd983b11aacdd699b4a10e18c9bcfc1ffbc58bec28bf59d73740085f45dbd03a453cb0f364231397dd589f36ea8daa3af0c20968a312a061b4982a146d881b0f34b8cac09f0ae8b1bd51e46bdf8b5d6f5a046f55171a12c87734b160b58aaa18377045af1c8827cfbf09da070c8e3122ddbb67c0a00595c1b955a010bf0bebb8e421ba611cc7e9f35842ad211378add102354c17329f7ebdf3abade75c4d4a0e31367408a55293834d25adf044643e9c134daebdc6c3e9ad5ac9c916e2eefa803b81a089fa0d06468d66a2323d568d4a839077127938a498e765776743669670ff31f4d876ca3ae8b58bbe8cb5944035d540dcf4fb4ef4c9086cb6c930dd745c95e91ce6fb08f83819da920b0b379e6e9c52841e63da18412e6b2543c08bd4a42822293d961a83b7f8f07324e41d9afeaf1284d40ec5ab516f75e3ea75a2054f1bb1522897532876b8fe235c5791016ccbcbe6e5b3a0625f40837127540cd6f91f8affe6e434c04be420a95bfb7dd04dccba50718e10d4ccc125481319298436f6025a33b13fa34e939eb9bf892a018f51794a4fffb9bf514559b47f0af1b74ca097a3010196d80554d9e67d0f90c68aaffe5cc81c2d2741f263554543f0f7887cac21a7ae87e4b6e5c0fc87bab7718bcde439ddd65302155788f5498096e263f2b8b132d04a653b64ff8b03580f005b635c16cb43dcfb7596a55ddd67a8aac293ee44a8808402789d4fc231a2062124aad91d8dbd650184389c6afd86dd9e677cf9c1fc579ca0a284563bfea7e0ecb7018df977e0fd9fb2b172e362314cc7facdd1b4bc118be8af1fe25afbcb2f82b7deeea4a2009363ec5b98831ab473602ddb439374ea71cfbac49ce7b7e9275a6b7f4d57b18d819a77100addc8496d54cdefd3528dd3153eb6183e74bfd4fca171e4b5a7ae48f10c0d374e877f6f33af107e30385ffffd769c5027e938e55d42e30fdee7af2953b69a672c768f139ac5ebc6ea536609a6b369614969712fc1649d4ebfc18e2b501460e9e73249246859c0000210b054726f401a2cc4a61a109920614067665c5b5aa41737985a97011087457ed08cd72a6871aecce93d35c74417209f783fc2fb4ccfea616bfa0acd45a46af33bd3d5b3510cc5ef5441f151199204a2dc2cfd413a0aefb5ddf69645b9a92e600f3b233a518c3e559e9b3faee5dccfad017e94e7de7a1d37e287f1933f97604fe15e111c0ba4aa24264b4ac8d0451032a37a3ec7c62d75a6b4308f168a59e20dbb077fecabec8ca533561ea0fbb0474bd166e8a006c5b1e0caff992249f4aed278833c5319493b2bd6736866d8623d74434eb49146d8ad30d7bd07cb3b966c2024ce9e7d9356e4ad4d25cf8ec4d10a24e53bda5362c3d54ed3b34bf3e28b61db649312a07d2e0cf0519ef79e1cb9c4351e10e6b89cfcc3c29af5fd00d35b8c7cd862eb0236d126818b17b31d47836f830e57737287e5a843ee772a64f324ead754a5e863b1fd396cce73fefb7fb4739ddc36300d82d1e45f6364f20a30cd3d0988f1e7cb3c788454c072af4a7913d670c42958dc74bd13a3c6580a770befd77984e8fa5d93323957452d3da33a76759569f7bf3e3a6ef17c4a4e8639a713cd527855211b177fc112a39ef4c29ac014447f28db1800caf89dfc55e94b27116579a7e5fff107b4386be8397ce6abad426caa519bc921b4e7924ddec5bea3d54f2ae7cbda92d1e18fcbfa16b4adaadf208b73f9ca2997743ba306ce0a3428d7dd6a2fb5f387755d4fe2fd0865ec4df0d9da6817b6893f0f85603eed8e8bbe9a7a1dc68ab67583fc1e09f8f21d8f782c58babff2aa8a3c3f493b1166fe0b38b9e4506b0bb6ca13ae23c1ad21f653b0a66eca69fd8cae75166eb195f0d8bbae41cab218fcd08bc0845177f95e63aa39b6fd4a67eb8a4aec121a3567fc8de46f00bda70fcba8a9ccbb819a67d4ffe187266df5e19f43e65b8116063ff0a1a210ac6ea6cfbff97b6bd3f2f9e2dcd0f9792ef09bf26348b0023efb87450240829caa2972e6215ef5779a6802f62c6358fb71fb3acf96e0c8782793b30b31c46d0f4739223749c5c12c95086a22525aac7df20dfffa59983426ec47f05cd841dca700720a554a19e6d12c569730ef4eb2c9acf0ce5af6bf58b166573367c10ad16f43e5f97647f85e2a59df3c116815c5c779252c7f307f6102ea7d3211e8bf80d7bddf551833426450b836d7f671c75f44d391fb4db0d6852ce59ec1000ec7736fbdf8ce73221ebf86379ad898824d559786d52dee9fc06123949989ebfdb277fb2ee860ba2622061cd7bc8c09eff699cb20f2086d49f2e01f1066b7c1e009cb375967abb6e0e3d092d935cd4b30598494ac97615840be6e3876b54a23e831b4b07c7ae7731eaa4f31b3490765e69259109c9b7d37ddd4c789df228211c2c13859e4cbda7caf30ead6d763d8ab4b1c92306a6cb85626aa7897babcfe9b53d4f6b5451a45673e995bc3afd351ef9e95ffcb61f5d70453997145435a01cea22a8b87eba966c98805a18d68d59946b9e9c6d741a422c4a649cbe686434988ee8e11a26a992b14ae848ebe4766d5a56d12ba18dda7929a25e8af02a7b661ada2306ca11bfba755eb7e3883332bb99eb85592ab2db4ae4e8fba7a918b869b9a7e437a3d5dc474da78ff2227c9f1559348c9658460f51df1184bed92123ed2c7a1130e7b956bdc548cec31c8f78a2251d8a13152961c05a02601323c8e3745434b90db6648c14ea14691de0e47b9e23f5323b9dea1f7c5f5a4f99bebd9e56bd780bf7ae99f4e3115e9f04b41f30fe86828e62c96dde0dd78e6a8907a977c9c2d2f1a3542c85d893e327179716141b10c8a4ec5072d819ed70eb4e9a629c9b4f0fb68b74b6f7449830433f06881ad8ea3ecf672d61dc53f2311b7563078680ceb515ad08406eb71f1c016c019db3d1cd65bb39f844a23260d0d0a075ce8a05cda293a9d86c83aee32c7c93ec004774fd3e6f59c0ef8f8f1a8fdec04ec83b78b39e46ae740c15e086701369b0e2c291c5ed6ad9d127859c7b6e6777fa7db794360f9d70057e4e864a2bbd5b319f9567c744e4da21e3aa0fac4d4434fb84cdea8253944f546a9d46fbea33bbb8dae4cb108fcdc4fde7b25b4c4cdcd2af647e043833f200050da4b6725587c17b9f451d78601a652e5cfdbc195d7fb56e9c8c936a84a9c28493ce8b4d7205e35f85e57416424205c4f3d8080e23b93999cc898659c454c2d24dfa238c472e48667428bad68aab0bafbc72684b202543131ae2103c19fbf0ed9678a87bd9446a05f96687de20296a3e78b565ca020edb62586e1ba0027744c97d0dba40ac00651998d502bb9a74de337d8488e062987230de6ac7e8a2b9d06e84bd1d8990389a9f971f728cf007b5d234d4662321a2ca5555a9ec51a2443fe7fd8bbc562bf17e799edd323f39795269d0cc8c7823ed26e6d4dba815bbef520eeae4917f814c444867be8285c10167a1df3b97c9e4b663c5e056bd2a9c67ac082902c11a44db6c19ebf0838ac17a5809893be91f415ef4f6b18b0cb608f114cac9db4f6a2b14473fa91297345b914e25bece4e66f73e610ba038968328008403c763007196defcb2ac608e2ee44d575b299c737a06f244754f449876dfc74837ee23918b05285effcb252467ccdd0684e4eae9246c0f1aa59b8a6bf6413f976d719dd93356a2b5398ca731b427e10f94d9a061b146da6caf11c91e44767b267d48e009aafa5d71ea17f8582c932f4eed294f77066a5a82708e7c33141c44daf6fa3e348469b01a392c0bef3efbaf8509f3e9c84831a3f77c8b9bf9e0884252c7e82f488f4b9ebb025cc1c33d8a6425f64812acf78d629d2cb77c052a0b1bcace740ed481254047c4ac9f72ae3d7887b9ce775ff4a4c4b179334262d78c4b3a8052faff8a2cabac229f057c6334d1b10cfa51012788cae593ef3207a6b0b4278f1ee46750b6aa9c67ba731965f63fb6e296e48ad3e89755445f83c38860a0c6107524511326a86c82d39a6654e54e30d2175dd0ad1921bed85985a93529102d16f65e1f711655951d3a483ec21bc4ac5b1fb9f2b12af5bd7c5bdb4727d7a393a468663ca3097812528be2bb4e7110a0e1d655da572cc66e9bdbabedb05aede0277e51c1ff8cf788461978e4db4d4b8e40c40619a566e6b97e818c3ccbe40e2899b124ba07467daeee5584d275ce124d2eb3c0c1574f2911ae77931113417f3c674d87296b211ae1624fad105abf7c0343a6617bb2d140bebcfdd256d391d111d0717fbe154532cefe7ccbde12c4d87931d516016f93df0b039e72ce4221c6fe49056bdcf6d4b50d4d65e452135f6135920a9722afccd263ab835fb9608e52e09a3f30d22dc31c60428520289539f2aab3d51ed43d3c4b9d02fec1fbb439a4970bd5c951881223f1dfaa0020ead665d9bf0c3ae9971e7e27fc02767a29617ae05d623331acbee263fd31eec4881e0f995f5c77bec9e61cbc20a582258a34c72d7177b006f3a46f9ddaf154ba54fffe03d84c575650fb2e5c578b849d04ebd18debcffe1a6b9e14edfdba33aaf7fe7b87ccff1276b42eee20eec3acb36c12d828f4cf3f6ae8c20623a87f6d7ff73b82a59076540448de9a844e8f2aeaef767df0409506244da13c6fbac4bc4dc5c602da83aa5bd01ba0f5b28132034587896188fcdabceb6dd708d78eab219f934ebcabbf8671be7b4cc1c3df2a68cb9ad0e6e97a0fa8c1f0234616d72824e66a14b4ddb4c918d23e07a49a7e0ea7c9a28acb01792c984a59633119047ddcd4f0ff744c3690f8f97290a61c06e2d95e74d0e52677d04c1502d104fc24a7f32e7a3663a9048aa70f02adc7be1206b74087178960b1e755b74f331d1b2128d993babe01d836b89ea68ffd45dc871f099e898629d4094fe648d44730726d2607bc0554287846dc637a00bac7ca09a16325e8aa0ba766d2ac685f2798808dc9668377fd62fb22b610de1107d496e82e5baad0a878df521dd7b5d968694c149b8accb35936c2663bd0277d4324bde5ee0984e37cf374bdea190a577d111d4b46bb1c90263a11f675200752a8a2e88e1885fddabb221e3dc83252321e4593f2953e184788c7b203e671464bcbaf86c6cbde92c4ca40c2327fc5d5d762c0ce3ed84bad435ad895b8c1b54cffabccf78990b781e4d3f1f03190cf3b1654c0ce2aa15d10857be85feb653a420de5617e30394c0034277cb7aa5ebde66ca8bfb67c50c5b2964162cd782d8f567e6eafecd871faad0672fd4afd55d630834d0fe96baa9b5b90af9d20d8eba6c0ee5b03bd1cbd1572d33b2df7ecd50fd82fe2408eacb90bc9480805b6dd2f0513428e6408b2995db43327b1ae35d158c222bca55a73a4feba35ec9b651b478ef95453f94b80183beb86662d85f303203d17a6504ce7782784ae7b7e781dd8a071dd2e4bc999b527f39db72d91344f56c21a061ba29e7ec116a3617433285fb81f94ed42451d1e6d8d7149d19f93032990ce42c2a707d7950b62a500e1d0535501782874b34bb7304c590b9aaf5abb848eab33018ae802fec661d114ebe4ceabfbc4422ef84fd525da23b8e7b02491ca9aeb3a62dc8ac6dc45a6d61ea23980b36b45628794a00b5551bb21ddcaa8d4dc5e73bf0b1a1e48396e9c35de0bf357d1b2a6ea67f050bc10f2ff8da8f33744d487d6657861cadfe02b28a77f62240e51d46595f8a9ce0697ab706e1a3224977a2f74c1c802ccd756338f51f8e3820164c47f055caa6c38bacd374faa61e4401ba74f29faef47844d972bdba3d6ae64e6b519ab78155fbb0705fd2d585b864706f6d67243ca629091b32b354d4a2715755fdbe5ec72d07779f221f8f0a3a61107acf04e9cec415d8fe6c35d17a1bb2d1d83f1303227d8f74038a8b5e0424b8706126b6149f1b3b8c9bb03ee9f0c967bbd7ec7bbf190a3d714c076a11de229318a4ab5ddb736975dd1c160558220368b5f88a65d9702e3e024c46d35c9b32e66992900170e2a7a5b8c1e0951c092c7c61db3fe75bf9244a5474a2dfd8fec36b5dc7931e841e74dc14ba990a5160075baf4adb866936bfb159554756711ed41a6a545d75d2576e536ec08079947a8933b9773741974f0ebe29b30fdd6f56f0ebfe958fe00f4480f4a180f6f687388eccaf6656de2873cc8a696565b953b2e14ce6a6982dbc60e67821d02fd61a43a68826bd063f95878c5554e4ff0407d92848eb040535d41aa98b78ed71773d3154d5f5a0b53f95a997832fd9a7d539218d4bd78301aedeb9af853cb29cbf3185e7b1d0c409ee6bb2a7612a90d79b288288b0dbee671d6d87e05cd715043c03f9a45afc2dca5eb72adda70ce230fa9c1ffc3b02e2e0a27fe9958f2aebf9fcb68d4fa610bf8490d6b37f436634da2773f11b5c2a134c31fdd95b53a90abf4962c571df4bbb09da2c12e99b034749e4e3f431c223289a39ff77c61c8523160c460ce6fc071881d4566961077617640bd7ed9b6d88fe7a654cc674def020f5506148669f069d7fb0a63cf9f9a14681e54e7689209188ca73b653c06cabd09acf17def11ab0fd81bc8cca081d1d8a144ab3c02af385b793a906ac11c13e74227e8f11c85b0e909038e7e64bffe59f4c321856c5c524ecee691bdbf23b05175d98632f3be1b7ffadce6e73a2c53b42d495352b3064637069087730d41e6a9ac873480e817ebea7681ac8b9de99715add40dcfbbbdc11d190774a331117837d08cdb1ae4ede3ca6f2c2c10d912e726c6c6e47d200f8a086f1796675f461a9605abb07cc48968169b9a5110ad3eff9b752f89fbff8d3fc32a7131b41ced7ea4bbbb0b97a84baa000160af1b9b94e5b80cfea632177d106f4ad9eb18e9428f173930d95e6be5319e696ce40f14942e7648b5af0ffecc91077f9d5cd3af9a6aca6a3bb94e112ce6638b6f1892b90a9cc18432475ecc53b8b00087def69a607281455faa41dde2225d8f860a0dcb48659715289bd1cf2fc57c4ea0444eeb97c8fdbe4cd69ada62026df36b2402b821485cb74d1a4a05a007e67618cff8805c1d7ea371cc135ffcb8cb6a2e1435f45822bf813bfe2a738d8dff3e687fb4077b262de739aad3d9da27f37374d892b728bd38e63c7a858754665b306df8830b88f523c279d929c6fd7eb4d0e1c70858e428c4dd5e10295f291ec3c6ea2648b3976b2ded226e6d378a0f1a39bc712ed4fef93ee42663c7ca9faed47c134b09db66427ca19a3702ef4e30944d884f0ede9b49fe6bc31e124e37739261015cfe1a7048b840d0e14666a17bb54e6554c6cccdbf6ae35daa40699cfde9516d881b02c44d24ec7c3f59c7e13aecf7156c5e13254765c28c1ee0fd5179abeb988b9a7912028dca1d65acdf8f3afc24ef85a34347093dca623360b5e8921c4e853c52fed6ea8156690859a7b7dcb8858b0fdf099bd6b0fddced57079eaa2cc952ba32ed25fe54824cbf782adb91fb20a2fce49843bab4fda64cd07c0691f4b7eec9c02d5a53d2d3ec67a440989a0701ef0f895f9a62d46d0c123a2002131aea096b7f15a60572db7ba1def8a61a4bf2c4f6e60594e9500a25ae5453c9ed4336e922a6798949da2ed7ad1c262fd3ffca7fd605c9c74bad676228f90e374f40c09b0fadcaf6fc4ab0856489272fb4f1871d89b19996d780178d151d07c0359328b24c7e8e9bab948f922a2b419dccaa4d396607a749a9483198d967a9a107f522cccedae0b40b7e47afd98495087107a50d23c71502dce0a0201ec62f5710a539887b948e58dda443bdbf3176779cb44c0b3488f0d565c7e28d2515013582237e1586fdbc913607c84714eb3d082ec46f5f98d1d2ce8d0ca4a180d72e2a563b9656054ec82c2753346a094d830b63c48b163fbd93a9537b05dafdff1eb6b188f3a8d2a1cd9b0ab95ee967ba5986c6bd24674bfd84bcea652f000de7ca2202d5ab74125d84670f71d64bba7f06a64efc54098f6a41cabb827ad81d23fab96870e9be430769ad75d2d2a0a7bcc9383dae284754549c2544e55c1b4b49746a0539d50233fe16c524aa8b510ba9f0f9398f5682ec57ffeecf66eb61af4550035d60b13661f368f285c76631686dde1bb9b3223aff32b23d081f4c7fef92bfd3795e54feb4cd1663d7a4073c497ec23bc677044c60b68fd457bfa98911cda8af92ddfaa2935a7c4e3ca7474e11981badff4211e26dbe356bb6f37b7dc8238a524232394165d398d03f94d9a864f657df73290ceed6ae6191443eab6e88c383c579733e140a0e52355ab266b5e37d3192f13e34c2c4e742d0d99893ed115423a9ac80e06ee44be8221ba927ae83af91460b96f0a92858b82ca7a08fb048a5934c84496858a279ad9603481e0beb72fbc4d5ed1a34f80caa464ff2d153411f0fc4f9b472799c14e5bf6777267f788187f99c120e4011790736ece35ac1b8c076b5c223ec4cdb13e5b253ad449a33c1c2fc332f24ceab27b08fcd017eccddfe248b5ade6f7f7d294c28aabdf74849a694e400696dedd7052ce3de4ae10a8b07749d4c308df6118edb38f300eb0f36c47d2427eee031222251307879991651842c2d18cedc703bc68e8d66eb6107c6ee5fe0e258d79e4f2eedcc2907991c6bfa77baae2f9c3612fba812c0a545de28a858d3a5a1fbe3654b94b49e3876c2fa29a91853e2813913299b69e753a6741fd4ac8fbd7da2e29e4180bf12691791d3a955c20284f822909e9beb15e8f00413509e4395d6f94791ee6de0fbac1f6cf680701c163f33ddcd2025ab28bccb8c63a258803088c6454df49e379e2e5d6ea92a48a831cd65ce27d4797f076d4cf87d446484c17c2a33afd39d14dd6b4189f1e7209438923b9c96651fb62ee932c53a1ccb6fe3e0136235f47c6658db2bc6bcdf0d672786e7a2d455cce26418e485255842eaa55d7477a1cf326b8e432814e46656239985d6c8676f352692b1ee94f75a2e2a25b42db307f8e81d8ed976f855b6345d205f2bf307f65d4c6949db746fabb8c16bc7b95f55dbb18b6c9eaefc28605808cc68003b22082bc64de0382c3f76408764c2fffa3ad428f31cfd0b8b46f6d9afc838d5b82efae28233b4f1f5f79a00d505d24ef87e8f1b31fb3918bd49bf5d9b1b539be8dfba407964eab2c6fe6a6bd966b8b6a6abf27589d5559d0713b313d5a5f8107d63c9eecaabd57de7fe709bc578ededd578c987ad5163ccce034c6380bff7837ede3faaeb2d08c69c28b2eb9bd3d6380e0f435a05e6cc62342ed35a4cad8a7c3c18bdd1048b80362883b15336306d4238d26f7804dbce250d56db9731de3d6a26c6dc3ea06ab3d66675972025a602ae66d4b18879029cf1f6078686f9df9b51b6c8c6aaea36d794c6ace360d22e69d0abc5146c5cbb135007fdee2fbae2cf5fa92b3ae44352575294cbddd46e20b6e9969890cf80729fb324d052598c71d1f9a06dc2efe6adab4860a9a188a3b0bee7d3678589fd56c35b891bad6c04e92651780ab4b4eeb504b9179baebb76c24c3d565781a220295db7742b24b015bc160f4980cf818e3ebd81fe454c9264165bf23e2bda0c27acdc29e26781923092ee1b76209955601d50040446e37ce34114d787d9fef862f5b2f14b9d987ac04900833906ee04e439827af9d4a0cd91086dc09490d0842732b967f2db33f5bf1b41bdb7ab0b8b8e6861a3e3c25a30c966a58ce4cc4efd9bed820de6eda68a02c1d357c58df45920f92665a1e5557f8c165453f2fcf8a35cf16b61e5a2398cf7c1b89536a54c0bbf1f6f89f893529cf46049649eefcb5cc43e487000a27718dcb6dafd29daf296952ca6b38caaac9f77cd9cceab3b407b16dbb854c90a94def9134a3de1f873943a5798a33c608f5892224eb1b14283fccab946dcbc604d9b47072fb7c8e8f21037258eec799a03e407d39a6c19a5768b3373ae92f12076b26c44b4c2eef888b8538b86e0ea4ee3ac20e9208aea64148af4566c8678954dd0b6d0d542d3d3902886d230ef4d113f3493e01dcb0653a365095c3482617709a3de3762229cceef7749d3e4389a077d5c7d7dcb4d5a1f463de10b93e557b8236a45a12654a2f1d24b3797bce595c27f419c12593a408cbc8629f309df9b3d5a52a34816c3ffada0bda77a48fc93effca0c0ecd8794522e075695a6cbd55c2909795a9ce67b2d228219e4ef038ecd5b2ab0619066910d3240838bb96db1ec775198fdee1d01472ba432aad65b75f619d629cb5a4312e401081b13a4abe4d301749b25a3b28ef79ad6a0e3935fd3656eb5694534efe7a5c6da30d2197e3c97b185c76227a6bb1341d0f43f1e105ee2e74483efaadf09c613eede0d62981e8d3eb59a3a2a18f6c3122f9abe78c36245a241ac85ab5f2c8f3cbf1ef738330cdad1d9fc4e86da793feee06ad9849361b531fdb62f517eaf71d3d815f1f4785881554118355e61e16f50b803724e80a1807de9cbf0560013743ec62a937ef48cf7ce9d4e02e73c9c679795a469cd49e126af3681046747336b9fbe1511aae8550e88392d62c85e43d8be70f0848d3ccf33dd9daa760db380584d38f508d93311ad6650a328cda7f162ad66fb41a0b7f49950a2b3752b69299c13d4aa4f3a0141a46ca41bc22701c2f1e7706c390f1726ef1908fe81c9e7eeba7b5f3389ea20ec2cfe4409a3b26144c59c5f10ec0cb72b6a8851299ac31c7a61c755718006fea1630063d7ea715577b60153eb4bc21e15af025bddd73869cc84f19c7744400a038fcef85e9bea9f58abd2626630a50002b2510b0da4a1f12a488d0cb2614c6b3f02d85ac03f3f906e2e1df4ca59212674b7e3a7ca7f62ee569fd6e39f7882593d3c6f9b53a201fa121608acc5147355580e46c1ea13cf848ed172e294c106101a245f7f42f6f90fc4b7855938f76f991b5f80a33f1e08d1be0494813e434d57d82fd8b3bdf9efc0c8dfd5d582db2023b06f3cf542c01b6700d46f053993d64195e3b6643a3bdd0da346458ae19ac3fc65454cc6c5ca98c0afb9d4c33726271d966a6f511d7dc52d2769410fa1555ae877f5bdd5579cd63674131dd63c18f8f2eee375703eb467977843377200ecc2c08746ab5f997ddde526d8d7228f3dbe4a03c9df9fc905e451e531b06954f077fa94610cb8f9a4898b0f89e1e92142cbf85ad9dcfbe8f2d55f1941dd184c29d1f2da9a8a0794f9194d866053679d3ca61664b033c1e0423c7d7b771f83f9cdd69e161616badfa8c63cef277ea7b50a279257a70d91f8e82a9dafa16089cc8b352da1ce91929ae89448779c7e8ffa481831fd21a4a5ccbd2c691775573193450121bd42f9e0a87da8737e937ad52db72c28f9077dee1e7d261684b5fdfdabfe82f03d51007043f56c1877f031c6fd72b75a3c2348c20adebc9ef9b17d2eebff10c5f317a9cb9d05d9f7bc15192949367ea7bb00a209ccdb25a290ff35ba86fa2dcebc85579001211b5f5cacc0dd69bab87119de1f605ede4baa02814c6be58bf09906ca197fb0d8c7cbee88d739313143258b9ef0e91d64bc551ba8d5a293d7199c4fd680fe9380904d0ac67b549a7b529e7b4ce1214e6c3cfcca0d0ef1d999783071ed39565279f8ca104d0314dde27f87eb04f3c78307d0da7f34e5a8f3cb10fbed6e1654c3c5879fdbf6dfc33b017c9ad767418a6b7c30bb9dccc5be8761df459d0c6d5aaca22d052e662589092a64318f92a82f70982c6b07e7d42aa299c69903cba6a075b30fd00bc215261ccab6a30dc977bb2621e112f890bc09eb5de2c01364f8a6058c423dbea071f596272c25610dbe4c36d308c7c74a4fb0a7832ec20dc45f29557957be71a453302a2cce405e817d8b9d82d418b40e59636efd79f0ae198ceeea3bfe5ee8549cc47add819120123ceb6c686d1b11c5bb749519c4116b3eac11fe0ade2a382ffe401c155f7fa8210855af4505ad3eb2de619599376e0955ce3fc825ef6357b358ef368453892152f0594e8738e92258cd03fe4b697f57e289d3cfb22c8d1ab6d2ae84a69db4cb0280284c83aff927bb6eff5591c64cb5f694dc06cd76554dc65e6dd946061ea4b6587487810d999de9bc95e80a512b96f38c16df0e77ae4991b6a7c0892b57d1b144c4f2be3c14b52618da13705dee7a92f19a54f571d320e309f857aafe35e3c8922fc5d268f2474d22935cbcae62012f29ab872ee75f19410b0afb9781ff6d9374d59ef5915e1867dbad006e768f10ac643d980b0f14bc4a14de0fddd63f19c600128bd18a2f4a265afadf173a2a9519fa7e5f1e842b88a8093e751c212c56de074f0500dbf40cffb5030c9b82305f04ccfaed6e37c4c6e9d09a95ff06ee3ee150b0695e6343a8838f4bb71fbbfa2c531ac1a57295fcc8d453aaadd11e086b5438759d58351a667f2139607e4b8d9a515acfc4a16fd47d99bb87270de9fcd56072f76436a9d5038b673b75da7c4d5f0b68b6226bdde0a41058bb0a3da4029faae3884007dc49b2ede00b79a654ea087036ffdf8a61afbecf8cfd6835f9dc9234884e8ba733446177c2baf52c9c3fa4225d91ea012682c0554e0e53a36d8a4ebfeddbb8c6b9421d8a5672b7f40a5d636a799e6ce72b920c32db51cd9bc2fe72d449b0821b7325eb47ee26c38cc2e9474f3b7ea1d834f296200372d99a9a319","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
