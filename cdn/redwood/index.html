<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d06736f3bdf841b408ca158309e91d7cc3a7183fb39228495b36429adced4477591d9e03077106f1570c0cdb8ac9f95729adef9529cbfea4473372e7d3f8b340e7be4a4c2b2b921080565ad64e16e519253813d608b56a4b4fb989b951720a4f3b2cd3508845b2021f850e9219b5ab8751380b41ed43afa3ec7223328e237d0d5648bb21c679a9554736e7cc4b675cc309af35b4d7fa4d6ab1d8da93f05a472ab5661cd406cc736c71a1f2a87f18fe1281df16ee7f8bcd45797f5f4977d358b2e8d0ca453b5ba5980518944c4e2d0ba001a7b97d52edf913409b944bf8d239a8b634c2d12b3f973fc3e30723593e8b64c0519651d8aa7d761232fcf73e25f46fe73db2541d34fc6caab3e9cd4b0c80277e424030e0594ffb88f1324edeebeeac7088f7931a84a9d41ddb40e0810136be66889175bc11a4d6ff407de37a601e543057deb1704986112ec51f903b79a00e49e953fc51f768cf60df89237d2b6e9795c8ace153788865e260cdd666f0e21b1aec3ecd08bf8a3e4f5bba5efcfa5e59e63be740287efa03aac90e80b7c12ebae0920ba58b426b8b8f935c6eb2415028539843fc4eaa5dbcc403d341b7d7dbcebd9bb4c635f236a40ac7fca33ee52c8668eef600bcb11a948933dd86c6b575e6189c1cb851437067c779d8b7718cd58b03483939ef4c6c1fdcfcf516b1fed9985afc784cf210c34bd9fd2b28e960de049f49eb4fab2a332cfd2282cdc064541e4c3220809f7ccbfe20b8e2766ecf1f2c7f07ac621028681255c311d44059b38c6921a5b7eb961c1a5a7ae4dbf1e35072ad95f85e233ec36aacac0fbd28e3f0dbbdeeef7334829a8a930f794dd802790c886215b94089c7906078ee3dfff7bd58ffd975881b6cace568221259cafa14a3217c44c8608fdf14c6aa5fad8cb17eb618a5796de0d17d67d3f1e193c1a4712b44add7be9b3e6973eb4fcfd89c213451c720d16197b5904414b21cd8a371c9d65caf2f2e10432f58dacf47c0c0ae581debdee60d4fb87f4ea35050d7982dfccf2b5b29c644ed6bfd8691ebc1551dc9c7244f04a39322161bc105209fe55c2136a747d69d06850dda61205de423700846ae0fc704d0be4e4d3afd0d8f894b727a880ab8052274fb76006adf0f6fc0de92f8b13a63318a105880a0598c08bc20b273a6c4d155f32db0335d6e1c9aaf634297e781c70ed41186b6852404ec5c7656203d4855bafcf760b4f0f7f8ff15e76903ccc9b0e12cfc72f0629810629b0eed56f8111ba02ddd94a8e58215d15bc2e7fb03770011c4ebb98a0bf0037108bbc982f510bb197e388861160284dd3efd6911aceba6af9a7754306e59d674bf3864bf115234d84649e4aa126303669e15270dfe0d3ecf38ad6cd044da5b5a86da4037d52d5eb084174f5d981df67806d8be5884ad1c52595c85b232bf3c522aa3b57b3a07b958afb2e3dd49229336973f47218d91e1006944c3742be4cbd7b631e4c4105aa6554364905786e96cf0abf1da119851f44020c6b1939c031fa2f0bcbc866e1c8f6b83c07bfe22edd21ab2c67a0cfbb444aec06e12dee05f575c2733fddc0698472cbe53eeaa92fa8ee5081364727f3f9f3149e9054093bdeb1221e6b72424657209e1624c4e7ff5a7bd651e4029a218e446995ff0911fb6037b27d3cb7d0ff9fa3d0bfc30137ba5d28111d20ca7a757b0b6e24d741e3a77e0190f6378b0d9cede43f17b8bde88527782e3f3de4957b2721a8f6c8906fec76e9da97c638ee01d8b640c7ee4c1492535824df3929d67b48fddef816eaa238adf5fb864719ae18595cc8782ebffd8e19c1dbc9db23ca08c7f6e8b666338121832a77d4bfa187e1b40a4df1995a15ceaf21f5c7c08057d062b72e955f8cdc7bab2f764cabf11b750a8915ecd1065efbabe89668fc43d73e80c03c0f4a7c1e78fbcc0faf26b72b10361fa9a1112198090c8f186e9214eaa0e161b23a5cb1b3f278f690ba61303185cbba7fac1249c43207db8be2c68709fddb42bc5b447d0bc57b13358ae7663d667a6f4f3e61ef2e8e2e3e30023e25ba6257b00e56e67eefcf617087f01beb9e6c36767391fc02b708400530982c20f0557b035e34461ac0e1e4140d1dac442fdc835025af5854f32a22b30690eebddc999b49e1fb373d9b4f45511ef7f0b122c71c5d7409edbd2ef8be71b7ff01a9b0b655a7b7bedde311fc6bcba19785c8631ce14b86fa584eead5d0c58e9e135f0eeb108e01bf8f0a78039d21a13426194c105b2b27f946656c6debc181ffd455f14ea034888fc8bf9502ace04b1355e718e93dfd293e063f31f6552a73cad68546d8c0a92ad1c43976d6a2d019b89b4cfcaaf363fce107f89b2852372c23ad5c606ed529e2cebb705dbcc76816530acd06f16e230d609b7d43b80d32fbe4539f3bc8c6aa7599bff40379e389b1f0e3c5b8ccec635304238e8f94d15f7bfbfeda9a5f767ebd91d39c58dfd70f211c8bb1ba29955161c0b3d25ed1a307ade135ba6087739f94785b08e25466b8fbab60aadaa06b3480335a321f4c1e40c1d2b4d7c2bd6d191651ca628662fc6418641779112b8ed266a979f93c558bbc0e26b88cb13a3e5a67fe90c59956adeba03a7e1dff7c9c22c5cb350254c91768b04fa4e77e60363d385280a58997275e0d93c9d9cec4cd426780548359457f2238d916e4fa589e6d55419c1955252dd3dfd9e81ce1a73f5a323b02aa4723ffba237b794cd05d605783353e1a09dd203319d266db5746f2ea1c3ea254ca6a3d31ea88be18929cc58bb7420495814777120b26914783a337e3d578e70acb5c01fb7d376bb336ced2c21ec093444bee0eeea60a6f899fa04010d5df7bf9732b25a4b1310ff156fa70f9fe1fbdde4a9763e8eb0b398ff48772783a76e0b7e7b39722b32b7b945e08bd0b1abf29bc0d69d75743be3c0c284384c2ea3320e59884ebe4681774039285bdc6cb7da81077b613ecca45d07ef87947c3b77280a50631acd04f5256e65f5f3af594dd88b8114cee735b948d216c4bce9a03dd1b07bb376889cdd92217283a1c4a9e28909fc22011a8fbcf8efb487eeb54aa7d0d089b45dc4b8062d4948b826cb4a783ec6369fed9a13697cb6e7c917c5c7ac4c5f8226c908e44b6fc3fc4e4a922ede35a80abbe3043a80217817c0bf92606890bb49ec33b80e988976b96ba966d7718d83e0bb557007ccc301a0f4b0a53ed6f65d0dffbcda6c9e00cf9d63c50814c281b5023bbba206821193d52ea6c063896a064d98288059085dceac6a02e764fb2351c35be5b34d7009fc5062c64484dfa8172ae730e30593d8b34d942a726c3b6e25974975d1d2073ad0a3c306216102844bd3e8f68f4eb1a55cc2632c8a4bd99827518beb323554de429b899bd5063627d36b972352c4b45379c825ef20ab62f640d151aa1ba2c8faf19e36b3a469abb7bcdb2b5f8dce0b071cecf77a4a69b30dec21aa28210c214e202cfe346f4963b67474d6cef675956d70d8c84ca183e01caca37934a24e0c4005beec4cac0f743b4c6c0a6f5ae64b7be225a483d38cc81b83187d6d4122953df07cf9f771cacd7dbce12a53a84882ae62d2f154f7131289d891715385e4d08d7202f21b62583c6e7230b7a9957bbe744913249745191ca18e0822b4dab1beff36fd5cb11d920df77f644a70744295a4d0932de488c02512a0741ba1cada10cac61fdba09a72b1a12c861ba38f5fa3e5072370824c2b8788b825bc47e5bc10391a407260a33e19ffbee2aa1c2adc1ddb863f500283dd1f3bcdc3cd69462cfa597bae50c175665ee4d6318a1b9ef29c567a6154ab9a96c3718aed2e4d4848b13a956df463581f586ebed79d94e5ad63149910bdff1b638d0b7eebe4481cb670dd798820ccf1b9ef9575537dbe7124afd5f4d21ec753ba415d6b75e7a4602b2eae1d5b73da80a401748cdf564e7e3ac7aa64180e971fbbb6b5e290ad6c317663342de762782a1fdfe2df5b9ea5c9ff86f896c753998e3ddf629035a5381959d4d749739066e67c8b6b63719d7e4ab1879d1484a5d53f0292409a49da38740becb960f74404357ff0328ce3247ab0a2248092adad43e6abc42413db98e88c19c19dda3030f8cb3ce7dc4ca78377708e3c36abc90249c23e4c9438eca7c0a857f6bd142eec0d819b063d2cb4b8a940360602e41c4e77780096acdbdcaf8de27071aa7a09938d84f6426029f2ebdbfe3340c851cd2260d5da729d4cd7e38afab0f53f79e8ee363e093ec7cfa2dbd861e327549ec4d3f2a66f07f3313992ea81fcfc1fac6c623c5a054c3dfa9ea9d90e8a7ea6f916af84d9ab11b0f05221744cf49831826c2ad09ce59b79a272343871e41e9ec85b827cb4dca7c1efa61bef08622d2254f3ab7320fb5247986ba65ea863d9fa2a835bd0d3322c79f5bfb026f993d3a2865388e504310f7082cc4d6f9a1dcffa025fbcfde4cfb05e664d6128c5035798415fca7072409393b254ac3e2d3939a5d9daa7670cdbbd2236f7eb69c72e3cbeba494cf2f603cfd3d84b5133c1fbeaacea7dd03831b4d4f32a3a66b4f326b18ce43942a4ff595e0b1059e50e675c95ff068f7d311c316d19aeb82901cd96db6f3ef244b23b7b0b3ff027eb05dfab609b8486e8322b402f457c1675c6a9a7efd0c7c711d3dd178b6f07f8d8a7144f2a2f60623e5a66f8de4bc3360efc6ad3c4a2c3a32053c2ce55c776ef52548bfebd1293eb7b69b6bfbf8e41fbcba78ac5934ade2d748fc786d9b1ac423104c7e4aaabea35e17ddee4e9edf65d69bbd0b448c665d56ab15770710c695516852bd3d4107239434d63f04c425307977149c04c7db3919b7fb6859c3770a908a5a75b6f9424bd3921288f421837242ebd8d7b9905fdaca595824c3a905201ac160bf2416b44361f04307108270eb80887695b3231120b20743c8ef514edf30fe95a84205461129afb3fd9307f8cd2fc2a5d3937331051a5db13c6a78c6e8076bfe9a7313c20b04c38fce8a4696fe89d771a95479e244755a51cf6faebd148ceef683d27bfb4f98df0f08edaa87dc6b356c3758bd4be9247f7321d556f7c7b6468c03f645cac9f31f136511b0ff95333dcd2d3e4b93ba66cd3edb6e384f9b710d73bccdcbed695f88e8e6eb2015a36201875581c9dce58bb29d398051e06c3a0cd75dce1220250cac3b39c4baf304caa7e59201f3202e78f0221b00fa246366f139461f5986b77093ea779fee23ea06333ecfdea2415b2ff280f0101db6cf8f3d3287cc7d26ce424484d640df4c715f9e532ef22d922779ffd2587fbfd6dccf5a3406d2e84d501a49737ac953b1f4186441e121c3fd89146073b5f69782add4728e168af4ab5ff428dd0729f1163b45d15fa0cd54df97b42e1436d324ac7f85bda3de8523fc6e576d8205d274820a4813030721851481e0f34ffda4bc00a7942d781904a1f375b895a0630635bbec82e002b11df83b898e605c834ccf776c45481134373f4e6152e0264d459ba9048fe80b4ab0df1300ec202dca13f6e2cd157d67d9e037ad73c6b286718f465fd5f5aede979b23a3d0a7aefdb448598dc757e2ae637f2d407fca513925903e53e4d48d82abda5647b9541fe5bdae47cc45b6783128ae8afff00c93ff1a52a54034eac83527dc8719408bf8ab412a19c47e56e8e91b2b64dd76725916c7dd53306bca55b95a0370d023ddfb5d93405c24ad2fecefaaa43f8083936d621d27eb229c8ce98c69c950ee51e1d2a7deea81ee65528b77a9eedab43634f52876c59a83a3be65ce20ee8419aaae1d53085063b3298bb652dfebc4af636764c88778a89fb33d4ab23ef0df00e1b6170b44e4ed40abe0fb7b1191ba157faaaa0f496dd83f7e59a8727c9b3c6a5b3115e666e84673e1808639410d0e162c087bb599d88aa91c712406182e186fdcab4bfd1c3fec9a37f22ca312e97d1b0b55cf2625cd3f0b68994c45abf9173ed4e3c5c7b329354b12a2b36d5eff81ed1ebf2bbdc362a9df7e69d3d8af7250cc141164e4c95387a909af6af631a4967d7727ff7645c8e0ffebca885d927475aed0cb78513957cdc7298366376a89979ec38b6c1fc6cee7f06dac6f04e88a35da404f6b8029d92c75743d34037c5538e603db1c6599a5ce1f8f5b792656582a498d79add369310a762f286097d7b4ab18fbbe823486d2a8d9c93ab617de5b88541ead775ddb8e3473dce601aa4b562adf22de0b308368962cb04c1e74e81cdeb2798e3697079b78926e557efe97429a58751d9a8c2fcc68f7b5d1104f744cd68893f6dc2755eadf3e64c4be4a5ed3185f734e7aabc59e08ca35a14946d9f7de22e19b2938f61d4ea1d7d0bd330dd6e14c7cad1dac1b5152cf54da581432d7bede9709d8060e53332c5cf406052c9aaa1cc1b90af36f03d4aade04baa1f153b4eabad30964f0ef40b173fa88ee04e6043a183e7762b01244b201c2cd93aad94acf8223251437975b47c97d4ec78aaadd8195a72dd3cab318ccbb5376d758b15fe4ecfbacb55452172f803c2ed09e0c94a281234b6106c60bc1517b2c4d708a953d4ac08f5c8d93780c523563a4160dc09c351507e9935fd185d186d5aba81dbb2f3699f1e06f2a6489f5bd1ca49c9030da0e29b03220f456c3ce298d504e77712ade5a50b73dabb19b9641184e93038c10f8fadd9ec1cd520e945c3e0c24e811aebe418751d54d36a562ff1ff6388dd542b283774ec7244f3d9a62ba74714cf7c129ec4c25773a0af284d7695dd0c7c71717232425c149d1a42b7330dd76afae0232533c32a93e345668c825636551814f723b41e46833c0dd083f0f0255141276dd6a012f026aa5978260780b3b57a6a682eb51bffda0cf5b42f596814edd2c1a015d211b15537ce9ff0e070ce65cf56ddcc8d677e631c058378d58bb2d12c225fc9827046f3969a07c66603dcbabd1bf1ae99cc35b8bf3054ec88f36bb6466506ca91c85cf0ba1e57a776511207b72659419e3bf33ebe1c44da0c165be1b296ebe10af965f41212f21c6391f38b729c84c54c8fea6d5c8136538782cb2857820da304701ad12d23d38339302aeb56938be9a7dd7814ea6d2385ab667ffb676fab33501a2975605a7a3e34c1a06d538fa188729d0167f13c9a470e29d5ebc3a722fd507de61e31e84dc4a1168fdb5f36d21fcd9ead0f3bcc29b657ab596071bddfd38e115cd3471b321a39ab5cfe1ef37af3adf53559335f9dbea9a9ba997de44730e3b33a118803d504fe86698ad0205d222f7dac74cf1a2ca117c754b2d255ba57201c4b711122ace9bec654ac560eeb95ff16d4187c08557e2bdbd07138e047ca9f7189edbed5492ee9a8f03cbdec0073b21927f39379ca7af08beec58fa90114e9ad4087abae1b99e7e4d3a0c6d76559d0924fe62f3be1e24537acb9437ac0a0f7367ac5ed1471800d7ce54811f8ecf1de0432479fe7674b5315405d7a1237a940157f232026491990f74a17696ad15eae9b904845043ca498c112165734d542ef44cbd33d7c506642ee07f56b3795f9d1f1970a0b24fa1fe45360284bb591138411fe692e0b98adbefaba83f136d0f7e269c10938345584ac84c1d5a027f8cfa13b18d782fd7dd6006666737f38cb6ace4732ddcf074373e95f473a78b8f98b1090a7efaffe9b947b1d264998d7928bb9ed2d215fe05d1c22f61fa43e2d06342a66c0b7ba4916c52cbd18371b489646da75280e00c1df006dd9c1b41a4613b347f5f860fb13d326fd18472a89c99dcabdd816ee7d4e224b63053388315726465edecca46965e37dc80848e21e14b2dbe62515efe844ae0ca4341cca19f3e2e8afee3f395536588a488a223dcd0f8a2a80900d76d07bab04c0280df51d315fe11147747b80052ab4b9e33123f3816839a52bebb1cf5020b9797424b4570d044fa6165ced58b29358283b6ac6e3dd6f690bb6d787f33b0ac56c63202a3b2e4888234b3148a6bbab326d1abe9a967dbc8a70ab82f434ae33dfdf43e44d91efe454ef9ceadc0223cb0d8d5fae43927628ef0aa9e31e10e33956dccd3ea79b325308d98f19b8af3066cfc361212b15623d7257fa2ae28519d44e29aef154e63ef9ab0bdb84aae0efdc5ed6323b876b64aa88f4a49c5f5bacb456ff0d198d20acc58b63072261d8bbae3f930b009b59759635663b0ce4d1aa112d5054a6a03d5034e64191ef0aa051a0c3cce1c9b66424348d4d08aceb7602eac271a8cf80d32f18988f0c45a05820970fe0e7009f7200ca52c99c0a227208f03cb03d14972903e3192b273b8164a3c4bfa68dd7f4ce1af5f95301e0cfba287af4025774b6e8ef811e1188cc343c7325f7ba270f3b72c7f67c676c4a27521f19c2fe77ee79ed5e371172f08b018e22996b35e9471a38ecf76c361aad16bdcb83276c8080f55fb35e1cafb63a25dd811eb8af9348ed9ac545f484b7c0768d5604f6bee307196a1b092fc1db1fbc4bc3b52fb87a9af2ad2859015d941f752714e2edf00b05919680a6e968afa18f943caa9a704ebc25d649d2fc79c520d284e6619967ab1ba5ea1bcc9cc4f8fe4440d538fb2cbc08493af160f1296deb5e82c14497b54d896c34b36a626d467f72520722393d6d23fb700c5628a159c5cca1a696ca7a039a9c4cfbc1299114e438abbacf0cdd6d28edf744446e18536e48fed35c8dadf32ad9a248b574e17496cc578fe6d49d8c61de74de17d39092802e430a94bafb5d6046b088affe0b70824fa9954c168ceadc81ba6c1eb1483795cd970127191d7e3c4d506793f0d20ea596cf7a5ac56717e370b5c3613e6e1d5963adb843c485340fe5571b5032d3ec676d691fdc79ae618f6e75c2ed1fc3a189aeb1608efec187a7460880a4a757a7a9966deaf8989a677e75a05b0fa35c832c486ca6b124c7f6f77a507622468910d7ea4722ba5e746d049ceaa447762e9eb9fea297ca79bdd4db53417d57758c20ba35c99a80b787acfddd50cbf79f94f559603818aaa8c027481d1d4548cca679960073a543deb8b68b3fcc592b3c7de4303dda8cb8332fa83069958969a1ff9efd80452882a1108295ca93d967c2b10130bc01b0b581a88868b685b2d2a9a986addb19cbd0c424e892f76f0140222274b24b208db9cc1bdb6addba1298cf7d1dc2e5c2c8fa685022f2ccd179e5217a859aad39508e2ac35f8424143218871baf9e2c3de5e908a1461f752111f4d4eb61abe0615c18f69bb4421c84bf5b50de26d3e52e625559fa803572db640d50769634aab35238c77a93f0ec2d27198dcb7285d17c935c759206109374696ddbd46d503f4d8cb24b7759d4e99290fb07633bd089cd0e6f37375a65e71692ae394a3bcdf4e337f3ea1bedf22409f0dd8c4cc1762ddcfd2d3d3dbe8bf2214b888d257a5dc0f996ea410039867d419575bcb28716f9410223ea97ee9050389ffa52f442db081db3af5c831b11ab72a692745b845a57c7bd12ad0cda886c2329249aa7598a627ccd88cc4766b35670bf686f9c3f7fbfc6bf547359903b4e680919be93ad918e8e634c914dda43ae21feefecbbc8e7220cc27ce0fd595362276bba01dd7d20ef97fb8d1b43da61c60487f42b61cc1e95b9c28583e1239db06d472c4586999982f9ecbe1cc908b4106b56b238ea478e888de9b9a80d76037e5dadcf1d34a452a14201a7533ac89ce12d57446be72048bcef6fab1aaca46e6c0eeac872f2cafca4e62942751806ff4b20a1967c5ba31cd99d3bc3aefe8dee0ba707d5ea5d0f99272d63f9aae2a70f34c54c6f17ced389580bb47fe9b72ed8f192a8ead91297c08d130c54eeed23f4f36c411a04e082a35a129681b54e1b92bc65f259e089a23e211076da170f71c927e5af68bdf8ab0fb27a83732174871c7ba89201eca53eec3489c7d4b7ebc380afaf5144ae7a85cab3b37065bd201b9dda426fbaa1ee946def317e61f39fe29c3b8a4865db98a47ea21ac0903c9846232e3024a1a2d72cbb90a6c73c11d369b85b0c03f0052e686259ce300ca97bc0587d8f693c26bc263e9918b79d4ead25653556225aaa76ba0fd862d18091f37501efee2032df9ea94b0ab673604c9089bf678723c316632766bbe71578ea30e7c6ace3f411d7b57b10e1354335a3679ff03d4728b979c50b1740cf11c1f113c1d9927c6c1a404b783ff8d3947d3e47b45a310be6c05a2b30213aab763a5a99be68ae1b1b0ee2e574af2737f9938490a7c28e635ad072930695091a34361150604c75e73bfb772225c670bbc624fddcb9f01320e5cc002c8c74190d12678a71db766ea4792038e5252513b9076e02f69d76c39a4c70dcfe7d2281c2c9c37f338ec5c74a9a49bccb67383d2487e53ad15cd1c1005972e436be808a1324305b25a06e46e74e133892f13af0c45d5782a1e4685b338f64c1fa1b93ee587ef23f8476f2d680ef3c375f595a77a8e74fced0314c98c689beba2287afcc6a3993fa524454f9693b20b3062b1c8539c87405b31f7b12f31d84abff20b9bff9c5a09744f48489be14dc0f491bcf70a7c79bfc1f9a1a07a9bad63d36ff4b6c969e613f8327c4b16fbd3e2cfde651ecc28387ddd6f3d0ab3fd54e9ebd6135cc32f4fb51c218a365e3169c848e09ec6becd82e136e92618a00719131cf93248c17891019a94f56a4c5029ab30492fd1f7622366dff363f4f4defef2d6754c45de5ecdf48bfd3db25d6b9370ee849b960e2f1c3fc6259820c274b9985bf5fc33bab33b35063f63a4e914d4c80a5b94588ab6d3e11d06b3eca42fbeb11e15f47472cac086259e8ba53a4c3fa8f61a43418d9a45f0842b849e2d56e497751cd759a0464d3c541eadc7de93b39673d362a63f1666de02e114ae1631f685a31a4c57769403bc19c0fae10bc86d5658eb966513de5e049d05ce2bb8a47be30a303d17263bb036276e592d2f44dc7c508c23ff54e139e76887be24d60061a26f4c277b2cd30689b141b767e758f3edd694f057c7a115b48527e796bd524ce2042cfb53b7a02fe04bf049f08a07a18acea67fab7a10ee9260d8f127fc2417158ad6b19cdf21cbcde971ec07a9c4b82c61789cb9ba0fbeb60f872aafad3ef899fe027058267fa079a471f1085db31ab95d0648eab85ce6ae85252e675397b78a8577a339ddca1714ffda322ba21a99714f2e4bfd32078e18183b8552d26dad9e2be2ae1c3bedf9ecdd9c6089ddc3a126304bb45fd1d79bf4ba34678a364aae5e3b71fd5ca951f1377315f428ed463ee2b7b400653e2aae6500016672e65150e1b7ce297f91b85cda66413f76016afd478d638aaf3bb4614b7e3e4c51cb376166862e4a5cd778a79bd115774b910307a3d048a34d5d91cebdaacd4f21de053d35031c260987e095aea0697237584e273aadafb2f91f38423fb84c318b9758fb3372544d61ecf398a939b515c601a0c7fd418f98c0a8795da76a176fbc6184d2f6418003e056e2be07950558de0c0b7a8bca57e95fe2a3289a0ce84d0b942d6aec7c08c8d46bd6d7fdba4f46b7d327d3cad70ae89c3ce927dbfd450bad10c81876da4075f0ea8c31f397662831b4329a2165786f6d55e2428f18c28b09c942c3634f6069389b2529bb990fa723e5be58b5a828f9ac443ce6b4db9cc1bd592dbdced3cc8b48259a3f3c57b76903cdda6cdaa88a06889bf782af69fed041e32e70c4ed0beffe99e49af8b01f26a56dcd5fb3f8d3c2b2bc67a4a0dc88d7ebb0f3d4a38818a24dcf8fa6e505f7886d4d5ae02dfdf2bfb4f3e9d2d2460fb40907d9191361db7ffb2f2f16e39d26418245d61b618b336a3af9131014a0c6321dfb0265a778bd23e9875db24bda64225ed50599f7367a45e33372a0b7c0fe915d7c7c964ede97039e9cb962425dee0f805011fef008d7b21b69a344eb233cb15de4fc9944e014a8f40d168874b436507a7eaf278269a7b2223fa002ca829cd388c2dd1b4f878208e6fb34aa0b0aa036727e5b886f5257da531fa8460eaf34e22dd204b735a3187d4207017df360fdfa8afc93e83e5cddcf2d9c842b457d500dfe4304869d798864d430897eef954d84255bb015e6fd22e188588b7a7d49962574abf3b1f0d9f239c585443640bf9c2264a0075196ad7433bfb4b4cac8eaf707367ce89c3335c313cd7b450825625a7a601edd268f7bb3b4f06d06f38ca725c224898daf4b5938d0873042dbccd74dfa713217295eda8d8f79689a83e6b263bf0f1ec1b19564a91221accd93bb326972775581391135b6adb1ee33aef31cca83bf9b32f4f5a76fd7378092ae7c665673d748228bd798c14d3cbc1eefe00d0e8f6ac9b2ebca2ebd34675e2ae02584bb6dd96c2699ac18497a80d726c9dce54ef249382f360a26c321b4cb5afdd109c4bbfa135e7908f3049a234865e94b5d88edf2c9d3c2a0134eaa16337b3f8445fe3d2e2423fffcc15d7cb38bb51ea389cdb1b23b12b372da175f1e6788c7691cafb9279aab5928956bb628376afa399b734603455e6ca742e0f2cb28dd07176211e52a046e22f118cd9af467f8644bc33d52a021f185f1d9a68ca40dc79dce1648f7e81b9486fb922cdfb436ae4e96a6560d935bc4bd759749686f02fc6f1598dde5975124a0cd19ac771b981d1d6103ff37ce5f76ea7ce270bb5b8d59459b4b51b8618f651098dc262496f9d2620ffa2e9819b2f0f7848346d1bca94e3c20ed9c2eea8bc86281a7183610bf59ece17db0873cac7dbd398df2298adb1339f8542428f92e48bab5ed408542f417ce9832bf5955ac31a01aedce99b9de78f9dcc9a54a7bf3714f1fbe02a6186934501c6af0a13f65c525dfb9061ffefe414f8d02f2b0ab563920d115b895463376d51a202efb3d8becbe21ffa91d56e427f92a29cb2f16cb08f934b4a892beba85521230bf824fc385e41c7d573b9bc2c4999d9f46182280a72c5c55414ab301cbf372e8eaea8626143fe731e8fe97cd1bc41c9b0bc7d79e23df3d9210339d3569468d4d8b8347eefd631faa885b0b032f077eb337796ecefcd0186610a5dea97fa4b0f051c55926ca7d3d83b587267033b3839ca10781262fc69af5ca39c401ff30ae6a46f04d1c51d733b91cffbdba2f3332ad612786df70aa36adcdc6311046e60732f316a95740323e67f187f59ade389934f4c361ed873438af7f17cfdddc9520095c73234f173f0362794a1c4e3faa53ca2ddba07d9f279616c351ba62d57ca89ce6e09bf30133ac37a71d0495bda93d9b757dd954b5ecc5415396aca5a5901759fb9f048e1bf54d32cf12a7d0b94ddfac2587f6a3af02610774e46a37c95ee9e639d23d0cf5ae168c7dbe3cb8f0cfe846a5d0b51189d19cdd12f83593f09170b2bd7219ee2c480a2c8a0a374755de28bef0c9780b077bdcf0351508c586b04ebce5531c60c1bc16784583138756edc948600dac4d7d69938891e1f3d89a33f156a2b0fec1d68913926821f2b92b1c6d2047f659c39f693fec3ac46ef2beed0129c255ac00e1e1bd3e8c817f0e2636c19d39ed2ac4bb9613ddf5e4d5747aba729545e3fb46678c11381b0610f1a9b972aed8f6bd1205c993d9dd14b4bc0e8ef51acc392e81c581edd8d659c9b991f79dae40c6ee3688824e4b369b06fd9b2079d858a3e9552cde74646ee84aba4a411767a4ea5aa222be86abd1811aedb55ad6295bc62cab21edb72fe844fec5a2caeba617caeb8264e2560fb163c6494cde1280222d2117bd7a5cc502626e1dac0a7f55727853a4ec4344eb4ecd027a1daea79fadc917fae12fbdd61c53c1106e385f46fdc887341df21fe23acda75036128a893e0f451455b920d7c1822cd552936d0f06ab59578d6a76ba475945ad325b159538f34d84b08b7e1d436f932ccb5178c8c4666c56627963b6b785c22082f4f869dc3ebdfcdc7dba0b654a527c3bfa93f4e6de9f7b21d138cc041729bd2eafc7516c2ffd6ff35beab6f754d21802a9b795d18643dc094b536871d77b4fd64ad27c5882d54ea495b1ea8d6fad8e620492d4cc10a99c7796a839a2a7b2451101be250f76e7b152a8735b49f9b44ad7754caf8eb4b7fc0ac2d23a15a2878bbc17f72345a861b6d804fec8248f3ec93e77911844bb92891804fcb2779ab495a04c1069a99373bbb4f11b272b65feeb051a897646bccb9fb3c31ebd844a947ca8bfda25778b9a91bf7d4221a895de73d068dbe8e393178b15bd96b5d93305b289a48daf55d375f1640260270696c80aeb6119879ca428a401fca3481b7c36e4c102210c214c0edfd65295436fee935172e921129194cf4d7424fe382792265175232038933ce0e41b70214d9d223be50fdfc717badfb8f269a7f5fe7043e7761653e6a59ac2bc68d96874764ddd6eda31d7900a917794b9eb8473e762346cb3add361e6274a436ef1ad690cc1e89b18787971a448d0f60e78cb426ef2521014a18428fd3f1d202af47b8ca50e8c0b3d6de37e5ffcc6010a770735f8394e78aff686c8108759a54dadfb217ccc16b0808ca80da5b9ce042c2ce21322e878663fc97fc1c177ec53608bdd019b1061f85a7efcc1648323bc2202612702e006c2b1d69f890444f6ab7efc129353e26dea5f8d6feb244f9ca24e751dee936dff434da012242304fe8d9e04a681c4caaa14d51f4f9d79b631b738166404b9d4840856f175e20656aa73123a79d665165013642a0f95ef676bf188aa2fea560e80d48a743830ee02e60a5c01a178dd1dee720a4deda7a1ad8fba2524b849b24eb6f46fb2c68b5565a06e57bf6bb5f6728fa3c3cda5bde2eaf44dab07e29ab9ecad994ba90cb0ee5aedf10d7602a1234d6970be8cb5f9243cb66365346c277b7483ae07f1a80dcba8806489c275f48f019eb46aa2179f1c1be32e0d4986c03cb4a097fcfce672cc4e9038fdfe3d25c75a77d0ae67002ef9169704abeba61244454856a2b42d3d4e83d1ae797deff685cde83492c0fb74a1d108691f7ccd3647733ee3c51f2973470b6a0bf781d5704b1725564f5e51bdc0308572215fcccf1cfaeceabe24a31efbca0e6caef85904ea05966b469805931707c49bce088e68738da3c7b0263669d01e60d53e44b16054a24e462391b9b1b22ec0d59daf6115564a45ebbcde9aebdee6e0b9bf25ba1ac8731eb35b5caa369ab6949b19eb538d7e8e7ea3bd99724d8154871809f605b0319a7a179ab34dcad1f6712c75e0ec3f1d4505cefa67422a24cf20c2f62823979c0d07fa786b738787ba6c90141304d148a59c9d69675454b3599392bfbf78686035e3ebd3122b9dd889887ed694410f59332b5393b318e1367800b9760ed2e765120a09e739872f72350f12f0dd9c10f915f52d514884d9f159598365c5430c72b11602ad72d1ca4e16451dfec12caf266804c0953f86e1d1d43d761c7efeb1d2614bddbdd74e68d5218331bd29de001d2425aba6ce148453ba5343dc1c172bff2708f9ad7aca1bc58fefcdea1bab386aa5a8841bbec4baada410cd7f256548723aefd633209cd89728de866939fab0678bada61ba33a749d025bce86645b5b89ff9f35842b37bf7b90a9e9e0565471ab0556ab6045b6b1b42af9b0056d5956c9d3928bd4472f3db3babe4c8eb295282a76b01d1f825e3174564ef7640522bb8cc47f119182c9417ba2994624025b2354f29a24f49e2d2c08c9a0c56440241e510accba781f74f96ef3d6cff27f16db71daaef2f0e5cfb7b47d9a8856eaee52080d46bde4560e61f0d4f37c56be57060b76c972ed4ba831498edd7ee9e3d0de3abb10051238dd0e408f4e475723f1fb61df9b2c6d2cb34f4fb6154634b4de8825d3ab83a3dee76e005824ae5442d60a335dbd2d370e8475837c9f573161418f9cb33d126c767d30865f194457b6a24c4b5cced8e230d539fdd83eb95a247c55db8015c0d24b423c190a4ff8680650c681767ba3edb946a39749b741150307065ae908820dfbe5d811f705c95123bf6493f9d73a49ef5f3b216d641f18c789d6a441a7381e6cde92f9e7ac0592d1ed3f76ebc27d1b9b61f91fa727e4754f0446072dc0d49b14a222627cd40ecae9fd5c12ebbd5261513ff8cc2b9485f965e882ffe272bd6e1dc06b8137e02ccc9d0a0f0061add8c88adf063cb8494f6f3a209bdff0491286e68f5693386891cb91a15644469c8a1db95e3bc0ea94173be2d9a9c3fa194e08e0135da8b20fa8d76bab2bf6c9dfc9ed8783d08b0e4abce7ef26df7bd77a75fbdec66efeadc07b23e37fda991e2f778c1224288aa3193280dd2a4503a9fee0101d4027564dbfe42f18ac75972f99825db58f80de0ffe7533f1061eda69c275d8dab7ebcc0692eab9b9554aeebf779c5acd33e093462ff87d63b490b35b19655349e274d3013c567c11b817a1f7ff3e6cc695c2233222e166953e061412f274d9fee25effd74ebf7ec46a5f5c082ac38551976389c0235b0fb6e17d17807745836757db2db4bcf5273bf15cb5c63ba415b5b58e6a76ceb6fe27780564a71562ac9aea9715aa7b2e6b54321fc984a3d790ff8112823dbb6aaac5b18f2ef39d40a2ee52e9b22804e3e3987380dade3ca9e68d6c69d0d550373d635281a2942b67785850e0256e8d4f181240831cd562fcc15247c9da6ddddcaa25f9e1a5842dfb6f7b5cc4697f1f1ea672f14ed446ec24d3bcaaf22659f77663828222511e23ac885100725a7d05c3254ea17fea0aa431a10b90819d639e59d4a55ecc5759e474fac58bfca38387bd49c915f0d730c23bc0a89585a0c7758fb2939614a50c33c89507a225d613a7fc34aa5e45921740e954e186577ef58e7dd87db8fc0379bbe81db198744d344ab6b96ae9c8b999c602d0a4533734cc1e1aa51aedf5434058d16c5634bda54b213a043a51cb67e46172ce1911e6f069fe9c54d647f7a6e6964396555a4a8504be02f74c0691dc0199649ddda36b405d9a7dd8d358b6631a34336f723d5e4b9a031b9c05947fc770753cf95a94acc20145dc43d0d580102591bbf4cfc7b53f6aa1da5c9fcf324ce9d1cd479c515b7f139e2456705a58b73c01137d49e0a11bd8b6c7febc9ac9c8b3477d7ffc661c15a1f2391f04afc262e277d14734c075ece25844a8bbb4a059658724747fe3bed6aa8badfd2f0da0506ca64fcecfa20627414b2ea8a305d71d26f5012daf36b0cfa0cc52b161bb289c13c79086ec85f4b5adc6b26713a2a1f0be9b354a14e06fe61ab49c18bda0c3a900552a9b376f6e8bef9fc6ea88e518cfb73f72f58cad6447501a9e8f4674c741b5244c4965f026138e687a8c4703c615482cd16850547087718949f188d895aa03e5f9a98f8652c6b0273385819cdaf708b0cadf266953c4fc4b58c29a104db098f913d4e9fba34ec3e8de775cec95188b5f210828c4f41496308995fad26d34062b6947eb2956a6e98677a421b80c26f38114adf8fa26dbbffc7f2e0252f3722cc6ee2a2cc676d2e7524953485d4ddea9a913f3f1770b836687672a4fa43e3343f2c9e12f09af8e9b96a7ea92f86327c588020c8bfcbfd5410853d590de71b8ef17f4c0083abd665fc6f7766a726d4d72e4a6463127130a85bd3c1c36ba13bc0ed6df010d776bedcc70395036c83b26cbe53736aab8194bdef9f40505db54877bb5825ba6ef1560c772c6b5d65ec032be0cebb7c7da90d3fccd0ef6f8094c8b7da86316268525a2f98f421713b916ce6be20a7ef24c4ae5c8ebf237b12de54da24b16ef6a745937609b3a2caf8f00bc16f89edc98d068434e98215105e6628fc14c25c377fc57fbef4bc7db0c835d58c61a66707cb1142a3f134f2b575b5236d6d025d711fcaf75a42254c9f3e4fee531852330e11f6cfb36d53a9149d300e33eeb4f0c9fa026db4ad480ab6d38bb977e8e63381f4c377919269cfdd998ab38f2b31b1d20ec31d37b72d527dfa7e6078ff4f2b3620dca17ce81dfc7f19ab43fed75dffbfa31c60d46cf9d1b4415e353246d628a0e9e8499044dacc791b2d6590b7e4788aab18b7269b35d391084647d0cbdbeed1956163ed4a82e3315b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
