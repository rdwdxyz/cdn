<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"75874bc6a99b0fde81e0f6d414faff544a60c383ce81e1ecf86c330e2ee00c300c208c5139965775368ba91c6f06b92c5d553b1363dac2f32cec3dfa242c2cb101421b610e312f6ff7cc3c62115eed7417208462ffb75f90faa8df150b7d7763b26f2543313f888677ba72b554c80e0741c92817bbc647bb335c55713cf173974040692c03a695dfb6ce9445cfc0d9c00b97bb20e0b8f8bfb1d50487f5e0934e2e686fd676db44ff96f95a2951aab354f05df8744d26c4c1384a3b87ff9f298458b51b49de7900fc87b2917e6c8283e7469a2ec2074b02a750bf28ba9bae74b2b4e2f3714a9970b367b3563435d422cc52551f4c1cc096d0817f5e9e1bf8aafabcfe35a04490f16490c5215aad9011615ed6873d92a2958221ad10dc31ca99362570e59ef2124cab7723491898c02c133253eb4d40eeb3991a4697aeaaf7d094282055a410b2b7015da2945c2b97eb3b71ba44819a464d8c32f91e737456b44eb4aa4fd91d0bb3578b996b5eb468459af4147e13c0135fe99ed7dd431368c74e436ba69ffda879a0030b399ccb87599f2582c5f70b612c75d3acfedbedeaf3236a9353e48c4a4ef785534b4b3458b1dcfceb9e2955caaf2d1f3e373148c02ecf60501939c26600dfbbbfae41960bf568827a6699b973fd03275ae4e01e6cb43e8737a725207aee6a20fbb37f4c58e731e9dcf8df5029e6cda10bc5ed850a445b889a9d945c43126fcbb37c75fe793ec6c91f1deb022a7d6d76f5a407e162d1e7273f42317b2a6da7bd6f3a6c1b629191c6e9b3c405f5cc397a5b52d303adff5e5df6725f00b530575afd0f01846334f61b6775ef958faad8e95c4c314d6e9bead71a517118e6445425718467f5e3a2e93cd7d16d9d15ebdf7d5453deb27c085023610600d8e52e23148e2d39a4e6a91d3da6dded520714d56bb546511eef693d5678b4905944b15be9d877f88002d678f2bedbfc8f4d5648e676076e8de15321389cff069c81a071c923dc526d82c91dda1fbdda2a7d74c90b3a7ce751729365233625951c01791d0d88b1cbf35d57bfede1d628ee66c697b44954c6e6d33e4c89c4a6c633ead31186e61c46dce4d63acfbc48ffe0fe42ab744f3d29c38c9b1b2a710e717a32365e91a5696b9053dea5b8ea5d6e7037ada48451404fb1b21543e374f91693958fb1cba71daa3f2dfd614bd704fa9f9b3855b49b17d17bc6d0cba2b54db42b37694f1e67cdf247a7238dd86d08cad1943b3aa6baa63547a93e74ab4ab09b593049465fc3801d73b73412dabd81dd1fae99020641729dd471d3eb9bbe70e85350e30c1cf465d4f251f5974b0fd53865a19b9a887e4b890cc09c3615228ba1c04a90b83695fae4c21073a3c6c8b4d67a53766a1628178b5d72175442fdf555f6a85a9136ed4c32cde7eb45e1620355848fb138e58f9d011f4c4e32af4afb6f7c780b110c069d79d82cfa4be98bbb768d544e033e41b9fd4706eb5d50ed85e5ef0fbfc93ead8f6e03f883f37f243210e10d0f42f8cc1aa952a04a4ef9e1ea0a7f28c53edb0c71feed7b5b80b8923be12e538258c9eed949222c6abe9fbab19048b51e8cd69d0d2e45c3d5865ea5500b910b7cc375c18103c681b426b1b000e810761c48bb5b579642aa777dea92867aaf17c55e789dfa2d0c0ebe4092a16808a38d001b8df622bb52200d59aea6dafb1b41a0f123a280a162ab81c06676db6f29daca4c18091fd272ee1fb9ab292e7cfa6170595ebe9e1067b5ff31fb13e31305447ad4aa1d2c44d4465ea66e47ce3955b82c7468be63fe53bfd747cf62ff84922c61723d5421f290c9d2230d501091f307543c7f311de757999f0aac17a25c4ab248e95c0e49a8c29a193331036169e58f796a82faf27529c9e916821f7514caf8ad6655e7ebf2a411d9399003f57413c0174a4b57d5c4636f7964d9c2214a867182ec3fc44a65d3e328c6a455bd2798b0cde331185ef5b2e9d0ff500c341ab98ea97314b7f6d28a2d6fc4a268f7c666b5282587b570ebeaa470d99a2b3d47e3f5a6834f7cdd718a7069aadf24dbd73e9949e29f9e36a9a1bad79b66fdd6bdcb0e10ab00109621a7ac631448bb1036d9f6d63e0b5bdf445c7aaae0b3571f1699b213d4cc57d53ec9092549226b286e46021c66a372097585bd8391bcc6b5cb39d212acb400ee96ae026cf783d5295e13a80effeb6451d9b6582f81fa754a13b71371293dd76904507c9de56c9cf356404b46b1bbfb332a776e8cc92331d4ce431ef8de8f7b11b93266d52798ab29dc796bfff08a2a81e61f4d06fb6d97c7e4770d6c0587ce2d2f2c258ea798ca69cb95ea4e23979c67e39dab59800e1bf3c6bcdf4702adb5a75e677c9bb5befbfc2995653184405bc2f7ba8e771539deada45ec961e8c3b1e5b64b069f42f08edc3b8803b4def44e9bdbb46a3e08568dd16afc3bf17bf729fbc0efb368c70b783819bdfc7eb738140b5ffd9f57872562e625d3c76465792fc9d8a6e0f9c00c23f78db088a23f460e36bc0094bef4568b819d89df99cfed584c4e58fdfec87d73260e3e166b9792371961e53cd8f57ce3c6e5bc1d768058a82a5eaaaced5dc0528118f2d6e0fe035475bca088e08134bbae62d6e91369587f375b49280f81157ca7448f163025129cff0e94ee92018a1c6ec26f526c34a380fb54219105126b51dbd52ffa39db983710b54af317f26250de7962cf11e11fb8307cd6c84821139c20e877ea4db1b4d2ca9deea2ad0e4a3c3f5945d7da9e9c56c0b8cbb4209d6ac3019444f1902c06efe625a65a3d36dea68e96f8a9c742ef7ac738f5d359d01eae78cce2a6917302a3032022540cbe712bdf5bdbdcf19911b2db9acf873a3c975860eee858a892d5b124d37b5d0446a70dbbf5d98d4c5f81b4e47bd62e9332060675a2089bf63edf46da1a5b4e9b5f0aea6a8771e0a3bfbeb39765b73f463a18d5a5dc5b01d03ac62d1ba317a695ffb6b7420ba20f5c0011ff275c09013ea619721f0d5adaf5a19983772418f528a2b6c67f7ed891906977227759f01d606e0eb5b649d2760182528f0819b449bfd753f04830f567020feafd7ddd65f87e6c97d0958038e44395c53a748358188a02e7e2624d36ea8a7081219dc1c21b534c69efc8ff3f4bdfe01e01050eee0b214f0d5b8c0c269b40be49990a5fd0f8d7ffddff02d28b42e7c19f6a698be6b87f9b34b17414b0eb0912a75cfbf89a4fccee8fb994f3b6a984512c67493fcd08181023463f937cdec765794b8352c3c296b51c8173da0fe46bed26e01646fe849938d8080efe88ae533430b810e79d29505466e975f20852ffdc19b05ce0c10ba0019eb8d7dcd1c63a8011efc97b53cad29f12962946a9eac599e78ced8ffce4b8a634fda4abeda54da93721867f69ebb886682d928e03a907c8dcd0771564dae526f0ac5bdf29d43b7ababb3ade269d51bdd82c949a9b97e8c1b882cd0be5a535b4f6b417273fd27d48d4a68edcd47df804423f969adc2dafd3117ce91c88a553b8fb15905f6036ea361614199e1c5b80f42f235236f2817e2176532ee7c01e71d9a59b99fec55058daa97f66834fdeb98d06db944d587e76027a6892a7add2c6033e8b33b46fce37018ccf504c21fe908b1e68f0d86127bca39c56186ee9901a2ef59e3d27e0929d7f04f588495ed98631e600c9ccc7a10a4e34c4c182422f0f86659ba1db5af9a9c663c4bcaa85ec6b6bb7d20f5df3e71d99fc6356f5a41d6ca2b92d68293341c025c68035d2a8839615e6169d8d2d21c8c3e8e268ed1b72167d5b51aba4fe7ebb2888f92bb7d47b4f2e2a72de6bf558d6b0fe060333ce186ca28f7b5daeab99e117e42950baebef6ed97466e177bf4d5ce1001af642211d9d428ec31c004f93838338d79bcb51bd35c6b485d324a0b8f277f7f723b5560acec290190eab58923e8566aa0ff56113393c3973d486ad20b6528cda9c6db78f70ec35dba37b783befb8a1e8485e5f735169b080685930de9f9255e516d24b43ff3153fdc9614c260fed2f4850c496b7d6768fa5b65496be0dd1481102397dc33dabb7c2cfe7ffd3ead05399bffcef357d10a9651d42c318518ab46684b8dee2e927f7c8ab776da48f51504180be421437dc9c730433385dbde4301208372b0757792769395275ec042d350d04a55c1690413d1b5f73cb3dada57d8cb9a9c9c184e8ab5773ccc87319649530d562469daaf1359ac18209dc6eb67cbce6ba65b9c703835560ac996d9dbe319104ce45e02ecdfccaaf42a17386913c061a07ce244d9465fe395c98eed1e9017979f994a4e62b301b2a594734ea689e5005cdd8691744356ac029ce5cd88f144dae0c013b17e33602a28143fd15eba43cb4472e6059c7b3fc459a2915297ce79e82d323a41ab88e076d2ccdce512bcdc33b8c3172b81459eede566f0bb165977ff85a0598377324412cbef7359f0387501ea1c5e2a5cfecb02257019ccb21d8ed900aff65bbf252d771301441bd0bfc3724710908e30a906fc6721b4a4da729b5da3e47c78b764e725d6d8a7b26ca727dacecbd0945178f81495a5e5acc78388731d9e8a51a0f58f4e6230c16f999b91173a5e4b712221ddfc31eb263e425f9e0d07a462f0074cbf296ec28f15c40a7cd10fdf3506f24b31f5a51cca182e80da75be03f47c15be09359d3d7d242d30df319d3229d88eb392f8b9ef0d02987e6080f05985c05392eece7bb8a64cc201c48e81876030d5785fbaec63dec79b1b3c3e2012f27dec40155b090354571cacc268ee7159c04dc6f1567e6b23fd460a6030a97f90deeb604534bf5038b98840c7c682557a0f7b1b8f03762fe172bf91af71ab6640b6d06711c926cd8c4e75ae815000385916711e9e875959ab020c41bd3ab3153ebb6bebd479c8ba93f7ee738aef9b8262cf3cc04f79ee5c0aab42223a25821388d76028d07efd65d02d862a0b564a8ed24076ecc159f525d73234fcfc0e2ab15a16d9743897aacebde12bea8cc7c630a20f2c74ecfed3d2d68469301e6d510651be783425b3291b37e4c256f6590f98f050184261e9cae224aa9f170d55573c9ef1b06345069b48ebb6dc7d056289ae11d56989a555490cc55226d2486557cdbb7aa5368d3086336053fc0bcd18dfbdcbd2df8f7914410bb1aa242bbce3adc5bf070a371f63d666c294b48b7bc7531cb041f2ab3e751790425bd8fbe6704a0522945faecfc661874d5a86331713a5fe7fcaf18d65789f6bf1f6091e69041d0cde1e940a0ec4de3dca87cf8489fd67c2eea2d086656bd6d7560ec943aa92aa444555dfd71bb5bdda6632c6cc528c6988129f2a41a2ad01eeaeab496f0dfa8d3e6c93d54ac372de18b656dd0aa64cb7b7b36ba4abea2da34d5fd36be86b4b40f69d4013aacdb5e4c2fc4709bdf4127ea869d1a583defcd22888573182721b84114958f21977105528bdb4d12240c9f684f2263e144e13a991c5dcc971e1045e160f1dd1f8901ff8bdfaf3f9f5e62990d8bc08f2249dcd7d4f0b81add6cfe5580dd43644d9d81cfcb7ac5cc602b9c5a1686e6bcb2f531fd217d03d2d9d6c1e437e1c97e70701ac81b16e947202355cfdf25e2160cf9740adfc98f8cf65c52cb847eba09774efa43d516a5be1a23a59063700d43166eeb844e76167bf6d8314e101c6239a3c381d08fb76ef2abf2ddd8c1b55d42871961ba3530fa3799d35293e7ba9e332ab4556ba6c794e1c6731580cdc4eb71f94852ed3785858fe763af4dca9e8aafce9c367253ddce249bc479bee4377f4310efba7038a17681a3e1320972cb40d676619317e8b933118aae080703e14cbd51cf741fd83b85562377177e5de405607989055804c1a9a7b727fb0cfbac299baa2c39247573fc8207986be4ef0e52d8385671ad60d9d09beef327a3702c4614a0c95c4ea38642921c7927ad4c3d6366313ec56fd9e635cec184681c254ec58b1727074ef325e9a9249578d4858fc7494bcbcc1a492d7232f327f5cddd9a59f798b5aab6b337721c8bd1573d158378f1e1c2cf9bb801e9063350bfcc8d79e6cbb204ac9938c40c2ede635036839ffa65d9801f9f252bf4de8b19386ac680a4dd17cb01d9c5d35c3208d9d5a6490f7f795c0ea0a919597c8decdd02fe87ffd9aef4226015fa42c61eac0fba1c56ffeaa0744df535d41e083450f5b8974e682c52b146393a313e1ea890fbdbe370ec358e51d5790d52470a64374b5b92f4f164bfffcabb7bd32bf05e6e4b06fad61e80e213a9c13a6ae7eb9b3089f4ccd05ab8ed827304defebf2d012738eadb98de5f2fc8160bcef153ced917ace3db19a1519eae990f4e1844620923ccffd46cb1e902d0073a76d5d255190ac9992ce1f10e366d6a07956dcd1b2d04870f6992bf0ce038a98c06c39189458fca911c99387201bc1734471471b2731cc7d85842c4602974f2a2c06a295ab529d43044085816bd6094c849542cedd8d10e6f462ddb5d1d2390a119dbeaba0ba8fec3e5bd6606077f1cdece3751b8f8e5f8640abd06cfd7944dd74b0127fad7855ea3915fbda3d431228e5ac0c986bb05e0612572eb9d7cbcee8bd6311a75a662949b09d7e1fc0aa456375287128842d44e04eb5082232a87dcda24d435af495b48d3a378a142402a2429362b1a15981ffa8afdb6dabb17b2b620347826ba0c9b863d80b71926b00afcddcbd8b70d2f41c42e5c4e0bc358c844cbc022deb52792fc94418dd7fb4b8e404e337d13ded593e8c480ab6ad1c74a3d713d6b6033ffd72a600364dbe220c019d0a7c920d9777afa2d487e63a630af903b83e863f21c25521b9609df54980c169e3a4818bb7bd38f4b3d9ce97646b58f5e673b5dce16cc3ea829081baa7757c401354bb02cb852f023005b27d3640c41284b11a7062a3ac79c367dc1915d2f784a2059aa0b4db33257dec29a8c162b027e1f879a35e565acce859ccaaf1b9128b88c5eb2c6454216e2b992c9f4215f55951f862e5fda569b3ace5a03b870a500c150343e92797db8aa401d83bd01bda9f3a862dc0a1b5e3efbef90bf0c23b73ff3230d7a757af6459da3c7cc307ee66a05ac6ac23a2540cfc473a8dba8cf2e0008917bbba5ba44bef9f98434693bfcb33a1b58b5aceea1d7a1ae4f13ccdf03a6570d88147dec6d88710c53744c5eefb559517d687e45f6942c1bdc3fc01e0448ee2025b0f5d6a0cd792ef66471562452493e25d2c9e9675468a63841dbd4fc7128df99d416e0a6c87992f37007ef4cee3cb62d04eed09902012fd21972a42f411fee5f9ddf8d5ea7bc04d9f3587cee112917c43e0b1042051c79a90908e99ec266f7c7a674ad1a054560c9633cdb69106914f69150718405877e8d000abee85f1abfd72f744b67cb92438b1cff81db94732447a5797a89aba506e7a92e5f1a7a315e3a38d13cb3feff5d16cabbe8b66d8a2c698ef94c2e712fc74b0efec3f177cd75e719a762fca748f85753be745ea6346e7a6f327798b5ddf10a04bbec6711273f22476bc135369b7438fd06400617cdee8acf0d9574a2f5d73218b99a4031e321c85ea29abc5e1e7104c798c235d818cfe21366e40c8c6a2ea405fd27223a7aadd49da04b79d2b875b66ebca824cc52795db15759160bd9c0edf44cc6246c05d65f25921970e6501ca619ee31d0ed05f1c9bc5088546a0b95d4dc422b93ba04357bd485cd4abb5760aa649639ba2a030e5d4746cfb257d2aebf8872ea5b4e7a4654c681ce6e562eb650bee30ad5154a975295c0db440adc9dd29fa21e5030dd22a0f0586db9f209deac95df1eacda7d54298decc32374d2c4a988210b6cde7c04f185107817e5680f6622b6f39df3868aa254f61e3fde8f199e9c73fe533f62b907e00bd9703400b8bbca36b92c81531686299499019b119be58d3f74957ffdfed35db500fb676beda02a87bacfba0773624259f4c0819845838ceb630af5087464f8bc658bfe304401faec2af422e602b9cec6cd2f45a3c519fe442099bcda126a38bdf765bf6e1cab28a3f5d10dd745bc4025d7e8aeda2c86b3817ef64394becd77721531890ef2bec7df3e5efd4be76ea92f9121fa6a820460a3dbfee9011ff60f2a8aedfe3cb61a4bc6eb0a07918617c5888a17cc44aec3bb237d6f96179028eec309daf62549523c578a5bdfe9965f048f9a5f6184f0e2965f9e88341a2165fda6a2a702bee743a80bb2ffce4957e02f71737386506f4f931184f8c2aa3f5dee0c746b17cce7edb4f7529a123a66359bf9d66b026878bcb0ed15c66968e9b35b535086483357792ed166692116a6275dfcad265643b7a5577ac8b91e9cf6ff43fa8e3f2770b8e3e97b0456da437ca71551ddf1368903c4fe023f5697f56bb71ab63adc4dd528157c926c612b7c6ebb2d1017143931f2c0a5d425ea4242f9549dc6c03de368340ddee875cf3f8f8d2e24922fe19259c1b299704b15b481343fafd163db4a60df6b45f0f1bf6447c6ee87b3cbffd6c0e04e78787c251ebd1f11ce32937661462220f77859878ce790b9af19f6c282186009602f724b367f0964ff57c69afc076e5d2503ef946a1a6643918c982ca000d555725a399e33b26c3b8ff0b4131c2b6641db3d70ed5fdb495834ca168fe8a2ff61dda718f8c59e76095189c0d75faabc144f9d0c09abb9c402d2d98304c5790adc27aa368246f5598a2e5777a988309ba3f6780109482006daed236f27b5db0cd54904630b20396d2e58ae2fceed66262f8058fd4dc44868d2a865a6fda56ac59e5abd2e22e50c7d5e9690f38056d36c9375c8b26d0986af3ec87869ebd4f3a1f8af0e3763fc020c8fa7f04f63757dc90961bc6ab01f1c36c0b5ee706bf777f860c37e86b84027fc677ebebf5b159d3938313fe091dab5a251fb12627be916d13020d45af832db51653915389c98bfb26a845c0f6c8531bf022c96b7909001b0dede321e0d0d5bfa0eef8477dd176071f9faa059a3881b79bbf01a5a3dc4d4ba9e0e2d3e5001125543bd3a7d8b6d6d126c4a9fc2c7959ea421d5247e455a99e7ea5649a0b38eb8efad9096f28e8b716b8a0082722fbbdb8cc593d4a4dfa9929f66b74a93b76d548ba8ccd8f8c801c7f3cab5de00be94bc98cf08fed78eadf124077204e5344c7ae5c2025e8a62bff04d38e37d25bac7ef3f2cf3238bb9dbbd73918b6e40641b171bbf328547d3f25d460ba38e180625e64dbd6747ea07e8228257ab6d539b71b702d387f5ed45cc75ab958d311e3c344efc56886ba1ea3aa90f00b60e099a68258da86bf0af524f9a11e94c576edf01f168883988e00484182c97c0ce55fb6d0127ba9fc000910b674f7c0f092cba291054c15fc339a75e1bdbaad86145554fddb844b91735063f0d44e7f45a3095ac29797e70b818326defc88abcee4129f2577af12cfdf155bf1cd54ed9ef1529aac63c6fb440bf12cd952defd8915b5bc8d0ab6696ab836d9a1141bf81d9dcef70f1864b056a75ca5ae6d3ab69d9c630395cbc41f3284883d79b6f926973b17922d61e4bc2ef662eda187dd660ecda1b3a7582adf5893cc8df3af88f665e3b8db81a1688be015b6edbf7365c655f6f2178ae686b9fab73e042d2b9eef73cb76cf3a2242232902ecd4d4b525b8e14c2c2e9d3bdb4b1a0381c31d022c4192b3201792a84ef2872bc5d9f670c012ea0197249bfd71e967670b4effa9ae6dda22f4e794d1dd724babbb4492cdb96a0f037a46b934617974c707094d3708d42de8b7d29f710295c095e275d911d669e2f724ced892549d3816782e7af9ea7228f810dde3fed9a2dc30ebedfa7958de307da75b3b1a8ddf507b62a3290f69cba22211d299cd5b9b2cfd04c86a2af7fab40d300f5078e9872b424c3bf3ee4ae41c2b2719594a6d61dfa674cca5da9590a4f39f51e88966db7d29f5c0dc929caa86ddab7ab1508be85acb4030a1f3c2738104e147738f250a801ed8089a25f75136f8259d857e90de4c173178f1d444b3f925c314925f1a95b3918b02b1274595ba75b6dc21e9657d19660d54700a82988f56e4a1b4c39a2159932a23fb57410e20e0094b60d7b163f2b5f4a5cadd71dd19501ea8731983fb983dbbd53fa2ecf7331a8600171cd905fa3f881ce5f4acb478250e0a3febcffdc68a878433df2821935997042d99fd0a1c8405cbba0bb77e3ff94d86d1b4b35e8a6aa90c0f7e3ce9512fb79175ad8b58d23b85dbbce3d63b74b70cab0f8cc90d220830129f8c8baa9733b7bb7923ef294674a3f907893b16045bdd019393e2322a623c1d71b7d9e36a5aa6cadd26aa7e7b2954ef44cb8a29e2033f3cd49528efde3994fefe62e419c5a1a61db30016f68160ca3cb2dc4bb32de29b4393e5ca7207b7bfb36579e098c2534810ee628c8716ad6ceb7bda84e538db773552497489aa691a3781b78cc69bd250c84edfb870b4ff27d0204648aae40597c6b577a474d169d3bfe9b00c276e15f0113b47e8ca7327c621d19bd4603ad757ab44eeee8c52a9894b389204d05f2906328d4b2e48ccce8a23d674bebdec2438add5d7f4c89897145184cdc83a244b4cb2dd30ac62bcdb0d515fcc6db7c69608c0908c3da1abcdafded7ba1a42313ab6f52466ce3e12bc5cee160ef16a7f8fca232c94243a8c845d5225bebcadc58eac32dc3442aa617ea52d3055cf365346a9540c851834fe9da7e2b8c0e6394e8cf32b915a3aaa346b04fb6f1afbe5e235b963591068aec82259880cd2389aac5fbffbad8656cdb50250dba6a865ac1b83cfd60fa8aefae1aef1b64448a9bb4a3e5572e5425abfd555caf69e7c65822116875d0ee6ae60f5d27dc71974473ac02213fcaaeb967598afd7e4c3bdd537f1d8cb7afd5eb39242810dc96cd0019f5be1186ac446a5fd7d2c7cfec90b5d7a491ccf6b5408c8a836d495bafddf80ee864687c77160390d1dd163297c8659dc7ddcab35e09648d4c96ecd138c2e93a27a891a76d57f8f429fede6bb28429b16668ce1c69759ea1b4ad693d1c729f30766519b0caeef94ebd893ffb1ee2b0758c15adf7ecc86150dbdd2f343d70cd4d7442deb70015ad89dc90b390c817dd1f930fb82ffabad79e26ad93c3f3acf1c986e1a1fca874383ea29765a0b267d9fbae739032a18962d5c0ae722b414f74705b4e70743ebd4f6ed4b28e66e1bf9d0fff902e58170b516b59b66b0f05eb800493171f61101cfbad4e8159a6ff0c3150bec8b39dded4845d7b2c80a2d892c7a51c7eb5ab195642a518fc11ad538ff60c1ab47507d1fbd879a92f8656780689ba04eb153efcd9b6b76531728bada648ef8a372d72515d96f60d4ec4865383303c03b34f8687f3a1496d72e6ab5bf042923a731f1fcd5be0d0ef806201f2333f248c3ee7032601ca2c9a8552c569d8f158ddb90acffe6fc8fc8c7c0bc9614465dab8dbb0cc08af12fb8b58645810c64ae1174e2e0d9731ca9bfe6c65183ad3cc14086ee66d49fb31ae144a45bd878c985bd8106f39fb02199b1b3f9e11b64e6b76cb93c7d4d78df1cfc40dbd0b2112758cb6110d8952ca087899af7ae368bde615c507a5aaf971e6d92cc5a45c1e205609092dd03ea72af8d590b15ecb2a243807555f950b1ce6623201849f36d45646ab05032b3c5df01504b9c216e518000c974d34a3125a7472b5762eae5398e7abee7840c610dad0db3ce23611f2f65d08dd01645383a38bb39886f25a5854ed540c23ea1c79ebadcc7b5a7e19191ed3f70e8d6cf9ecdb93bd03515b0081b0ceb06d8acbc46ee7eddb329a506704159d7cfcc9e136b8333a9b80bb3ddfcb040228554ef7fc869ba6bde688f593f8e21e50d414426b93a2e7256bb05a262de940b276baaf695b964d6776c53f4c475b31660dbd6e1245c0dabc6910987072bac6f045cc4a3cc1a0f1b6cad17e7af98988141d6f97cd19446c1039106eb4bc9eefd3c104bdd2a1051077877b26f4316a0caa1ffcf9d14e6ae23900c31a99fb56fc6171bb1c31a426c1219066f503d4a464c5185c2c3bbf4942ab615dd0e010534bf42b0fe7d88f300879bab86e0c62adb0ab58c66e0b98c06b5975d5ee95090155cd256c6f8a966003f083c14f61597f6af01ed171f9b98d076957558bc34f750b775093c4fc8fc0a3b8523a58d0dca3e4ec80f51f28d9fa4f24394d172c07864b6716b8fcce423500caa17be664f8b058a394a3071a127b3495e68bfe61a07d4855596101f7d6aeed91284bc4b12a1919a16e623ec514690a29056c033b0ddc5c6a2a5a80511e8a1fe5726c5f8d9f24d4fd2b43491ba8534a50e62c986c322afdde110bf34ee3b16faa031a3c22f1b7b097e828d7b42b910c762ac48bce29150a806d9833e0568202caee1852a1b5edfcbf3072ed232b21693893f4f0ea0e56ed1ee6331e84b356709f0b6c80d13300744dcd9e360deaf2509463fbbe269982dbbe3ede2e720aa76ff55c6c4c50113eb86331e010f47efbf13d5bc41ce3be54e667f4c27e60936242aeda35da6191ece616361fc80055ce6a34e522cf352ece308c58ae7468c7b2a98922788b132f6a1bab22ed2c6c77a8659d665a0f6eb65d7a17b6b2f79860dc6e56141de4636faf727333b30fee6d0774fad0d4599582d6db57d6a077686f7b00a738afbf4604590e1de7cb043ceb311e814dff9e54e01a6f148c19981c8aaa62fd6f7cd0f4e9189c677313a48e908f00f412e2f11509ec286175c06558e6d428305852db4d237e588eff0404a319512d63f59f7cda23656bb488838c07be364777ae9a371f957ab6d827251fdd2439ebbe043a632b869e3177084e4ce6df532483c694c89679523d14d3058c58079f2e52f02f289ff99e0eed424670f3d170787baf8774a1697597ca0d93c9452150e401a19fc626e21274a666029985bbc98c4f6cadd7f02ef645355ada5edb2c9ed7f013348157280b463182824dd968a4acd0336dea765ec33ba91ab58ab86a1618fbf9f98ff0cd1a857b9574e4248d0d9fc92a29d895bef553eeefd2f90a2cd9fba4fe8853b1fd13786622e19b49cf4ebed32abaca71a04e61db7013381cfa19d0771b6d0612a553d2c25e08c679cca9a31b0a3ddfbc25153a3c05f5d935bcb137fa6e917b48aab28df5eed8ff2b5de994ddcaf1dfd22a86aa1fec9ce8895ecc0d8a156d0cdf39077376389e13d5587472f1a2f6ff2eb955dbfd8354a66f2f7bf420cdb3dc745a68c0cf8044c593d8a2ab73b06f714f2a1ed5f9b8edb39d16030d6c20650c89e0f03e1020c3ba4653007c70480e3b1f15215901d30b92ec09a9a8047853752d1e1dc6eb3e797b2673c9b3b067d5e51691803360954d7104e357dff4b71a10fad18b47e2635a50152d8aa0424da67afba8601d9a7f52d8a375de6b340013ed2f34c1fe590aacdbe0ee2d104a35cbbbdf7c2f2c16c28453bee13973cd9ba2b0536e116458fdbb2bbeca1d82ff29d95ad7dbcf03163fa805c730fdc0c826ab0e054456b12b6d9a423f78e6cd9e3ad6cb87580b78273469be690a27be17d3533b94d65894e06690963e370295e3d5f795167d30c49049dd34e9c6237bcc04be0872f8dba24c3a75a5e4154bb423c1cb3977ea465db6af3f99813f34b7395fd535de8021abb5fc60bd3c05fe4b7767965137f6c9ec06ec4f2b88e519049e773f6fe03c0c00d96a0343fcd1e0b6658f2f60ffb094b3d16153f94e71b805975c220fd1bf6e3d2b9ffe38b81f24f962a748808aa690791fc3ce458e50daaabfbf1772c92dba7e0ed9e9f7fe5fb8d489cbe3526d271d2bde5d82341463da00ebe37a875dc00a97438341f4ee0c96fc3973332a8b1c149b91c75485b2b4b4b8c27505b05dcd701c6de9ac0a3ad79a20ea01dd1b5e8e22e3dcb8978958a33a1e9129bb2fc597247c9d75ab2c28d212c10ce9a3b5c58f18e3227ccbda4b174b3d520f9dd28eb8986eb6fa03ae44b653fc159e12cc05e694eb6f734ec4884fb2cf2e20d4585f2bdda80b9e6eb6c98cdd24eae92d60b41fbb023ae64309f48a062b158ddf58619242dcd001a5ed5c4ffee660b41c7f3843e0d7e55b6e78fcce5209a76964b6edaedae579c6b63c438f5e64f7d613256a2e7cb078816f52db87af5fb83a601aafa5a25a86721eb65815d7627a2db1b1865e54255c057c374b3c36da7b5c59fb9fdd172e448204f301bf207cdae55048d973b35242ebae0ef6fc1d4c66ecc53ac4deb8d908e6bbad8133264fa1b6d23db4facfed598fbf7a329f661bb7432ef6f480662881d8f4a9abc1957118db655f0190a31b2a03fb6604e2edb902f6d4e400e170272ac167bada739ac11efdc3fb88e607e3ce50fdd9f929070eb19497789c7ab4fb7c199e64d31108f2c3b815a1b48ac7d02e32205d99dc926d2c34dc4bfa5db50a2c2289e5e092ebe80e4e8542542e290872aa233528c88afd36c2e47906a37c11d01ac46f3dea8933e44b9020e7d7181c7f63c10ab8c7c6997b7c51fbd183449cbaeed281c51d786093469bf984c3e43adf42331ab84def3b9969f97915c5ad9ef07eda5da89dd59cca76dd8ece2f1e6333304ad29554b6af51919ba9046e4a1938fe7e36438c1ed54da7e9ea04d660711115dfd7c86316f0d8cbda50aa51e11c4743180eb2b9ee3c9d7da582e054bbb3e564261e4204fca1a50022d2666077675a980a4a8594bba0fe683c7464f2cf76c90a09953623ea8185ab7e5e679df4ae04e95a874256d013d3fb3e34fad3d80028256f6f6097e15f7871fe0301318f9f181ecadf63b014d1ef83cc4d35d8983ff2d02ce39189303615306f13d19b0b38b39f9d98cd98590b41046dd85bdb49912a517e033be778801f42ec952e430a8bea3a229cd4a661366ef96229734010de5132bb12eb8528021ccd73eb7ee61cf11e7578ba565f5c869e0a85420a308e018a58e583c95d08f5a4c8332f7f1ec2aee5854b10b7ac5d2cccb8b91fc939d38b963e11559a23c4532546bee40d1d80dbcc840e3439476dcc8c69f386a899d6136dda0d03ca1eba9d9bfa5f17d9f1c1fb2e0f7ebac7cb5e201ad7385775cb9e8f76570eee2c0529a546f2752cf9c55c6c6e9d68100d5b41265329390c1a7eab8b6e22a61173f786b2136b8da7f8e5edd01c296516619a71090784e191372088fd910c66cb6356a80514be50c6361452daed5e96397e7e48cb39f5a16fa9e79180cbf59041732d4b5774e7c08eb2f1ec614bc24f6ca933359a3b695a050bdebb2fb70783bbb6db8b703d95e1cfd6b7daccbcdeed9f47ed34c1de9e52afdb84beadc73dc19ef6850e9e9076fc99b5a489ceba86126c0fb682a81475bfac0815abc47bed5be91988f8b241c964061087c8c229fb3f3d8041fbd3e140e6defe9cfe266210c2db82abda150fa98b655f9465dd8311e258c77528e6191105118fce45268c4e36cae7dd915bc09b2d625e720a17bc9dd51c7fa5e3bbeb1f1604b59ea60d695f12b1d4ae3646b1a5ed1441cce8fa02b78e8817e1a8073cabe176ae9564863df8738a5e07a6c2225477bd98952f480f383e1339278eedc09a644f97264ccc572d8218799c5af79063bf514d260369ea31ee78ab9a0708eec32422a2552bfeb0c12b49dd13345e3c4b9b55eb6891630b6124b80a21a90592328c8249b4a758d895fcf26168c12fd8eec2ecbf3bd3683e47b6e58733d5f3215c773f5dc30830987e619ae4dd05062ff73a583463fe2af85b2c30a98d6225d4ce0357b44deece53e79b9d9f9c9a1ffbeca19a53ee4f2f689db6d6a2065ffaf068f4f11d53c43c727d5092e1a4bb8564fbc652785c4cf69a361f7173fce46d95d59f5e692ed2698e8a4cef466391db19024dafa1b667b3f05c954673607640ff7ceedec27ab9029abff8485941beab268cb71e356c38d36fd67bf908eba1b04a557cd12868b6d93918417c1f1f51f2a134b96acb0da03acb66369202b8571b1d42cc3fb02064e6fc1a80d7cc909a06a95974fa4cc8e49ab02b6b7801eaf0e04c77a2f0ad821cead10ded96888a62a792227ed4f731480a9efaec6124079daceb5e413ca1a94dd77708119b920b273faf7f7a5b252f8753795e950b5a4ad65e43b1da7aa99ab18332e4dd4fea7ef290edbd50e773ae0201287d3b281579300da6945de5aa7ca63113e7f5db35d0f1c488ba3757ae0d5dd6068bd8e03cfde783b3a19cc947becc7ca0ca87d35593ce46756586c1cc302391df564ad5e6a0ee5cee711ba5bc4a3f6ff5e2013f18eda28cf99b9c0c60e7fffb2faae6e9a94f0623c526d99564c10d1ace8a5a115ffa20227149644d14ed58f0522b00a3392df99576bb161f239a66bc7fb2d9f1addd0106944bfa3721ae28d0a85cc31303765e4b1b1b7279609b564433b57757b968fa9a52a2222cd9b3286f24b4da774d7624c8383b8030c7c5c1a6a5e94fd6a63530a7ba554ad95e385596e12c203609b6c25a5f642c637074b1858a27ae9be9953c580b2405d6f265278840653376295cec862381aeb32026289270d2e034dc95d833d98d0d6fbc8f986f9124cb277470c73ce3b78379cc93d50a2dbf2cb270569465f9f259866745be857341b1d8aa6cc1f19368f572ae63f6794f03dd22f29c1a8e31336e00840f4567bc85c61ac41eefc676cbad3d7b9d8b97ddd86968371f0f4a6658fdf466ef03cb5bd66da100e9b45d782fd7a1538f253098417ae1f08ba3a95725a67cbe4d1dd3774ba1bea7359805cd29254c9e2a76fb6697f230c8ae94cdd8a92535c042eb1c5137b59e7a5bebe720de33e462028f9ec671c2e978a241d2c57304d1ba344afe996f436ec335dc792fd73152f51515951b45fb3e098316448f814f8b224f6bb478e523a76abf6393788258a733e656e859d94e23c1c8768930b36050ad68a018377d4008e0e42ce8fc6b46787f1f66dd2f24a64f1771d38ea4f5757380904917957a26873749c4b042b7b009c140f6e8f4e3ca2d9c8337d7081d5e28a99d316b5f7a177ecd14a2a072bc8fb34da28ca00e0335bb747862d0544eb74404430d089fe1512c0cf57efe0a87de4e3f2c1961437348173ffe172bb78232198614d3a05851cad2f718c534bf268bb420f810b224c7ef7d9ef709def00bd6f1d66709f5642b73efa49f936694682a347cd7b07603285823c2cba61dde48834a4bb802602bd02d7a1aa5dd9b050e6220628f1962ba730b4d1fbf70f3d9351509f1d962eb6587da0f547d596fa78ea675366af7d3e9b6e1fd0e3c0f5f3a73551ab1e16bda4d77cedc2241904bf51051741f3a7afedd7b37a17bcfd35c81b0afb8c28722107974f7a839242029765c21e8e7dfc5a2cb665a61994a979f3997492980ed82f950ea383d1bda050c1b91fd8f3ff59e5039f3eb33e5070c31917b0a812e555c69ab193d3fed089748013bb3af9c2f4567bee675be19bc0dc0ff2c21efa8b9b831f818fea79bbc9d0f9880aae575d2cdc53233c45ba33cbb62879a2732a3c275a783c0f7af564ed2a60f304f4dc91217bed4d03cd489454904ff927f25eb88fefb70b32b93d6b10bca6523b858e975eea0e48b489c868560077c5fd14bd66115bff245c0baa28354add7fbb8190c82d6220be21c0c48f71e01f987e7e6ede1f433f2f57ef8b10450fe7c38544c80e940dfc8ca13225bb059f1e1bdd6a8337dcc971b374f874c0a8831ad34766df866a993924fdde41b1127951de2c642b8cb48d93bfcd991061ee584e96c8e9602992a0cf0a7cd0ffec1e45a631f3c88b7a2370601fcfbc5814e5b0303b7ce5c3af662f9ee010cdb23a7c9161cec330806a66db630a0e0bad165b76e2cd41fcc6507bcec6c9ca54db15f7844aee6cbd886c4cc59627867e7b15868d12e6afd3fc1344c14b1feabc3ff2fbbeb985b2de1b59a013bb64f777bfdfbbc6802c56d5b398dabfc7c7cbfcafb6fa0345ddaa1dad5e6b78e7b3360068cbb4358fa3054465fddc3011c90ddaa5f9b7262107dc64ea17bce650ccf52b22b7965a7fe933b5b1dba183c0fb0234cba266280e75f412ca082188809ab7d4ee2ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
