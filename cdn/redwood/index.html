<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c9c4d7f2e791014b370b1c1fc69eed33a63c19b8b494af483bed9a3d2037000e9eb447b841e99528b52750c92c617434af99b27b5dbea4e491deee95dd7fe08e71f7a63d9cf6c59c8d8356c99f34ffa4e86fa74009a2371c16b60147980ccbfa2c8a7a3d8359ea70694f991109b03bf07d71241ad133e9c6441b6e9021535dfadb21644ed7a6a8103810a4e6020e607362b1a2f4ca4853a37ff5e4c5bfd5725f4f3af80063fde5c15e4874c69cf88c693d9ef91e1e5c6e527e7ce6c6a5ca5ea33a60e416f3930ee54f1839456c003ec8b481538f8a141dc66034f5720b4d8e9a16d756547f45f81b6bf07058a79fe1f05d4dc386078af2cb8beb20ed2cba7c0c5a73bb6c6a61b270b0e12d784053535b2b44382a397c20073fa0bec165c87d20ba9655fcba8d6988de1d2fd7b2d2844b8e72180bedfe0f055aed69dcb07507c14c90ca24bffef2085be01a16bf6e3f8f4d259704595b568d321dac1dcb606f6abda0a50419131acb27c5aeeff79f790014ae19d3d40c29585cba6387a798998ef1f68f1ace6f8bc7095f42179ce91af7cc7bbf368eef5cde614316f0c069432c887e1d44a282cb2e6821e02f255f9087fb800d92a76127f70630567e0121cbf785077f795ad5b1d7a33cea1a4df5b70df55e3bfa7411b02f83241269e0a7c0bed7030fecb4f44e34fc836349d4e847b63204b89ede7d68845887cc049984ef2d35082ed761b31b954f8543e9e6934c4d741ffb7fe54d3a966498674e0e5962d2142c142da993d6dd9a41d15c2c9eb4f199fe5f90bb960e9f8cbd41b49637b993b228da19a3a87f1fa0c33c07b6600fd107cc84ed7fe9558f4978d311691a306333fc303124ede6b98a4ce1bd127b34a53b86927024d5de436b079fa11859f9ae44efe1940c8ca9745f244f737c437f4c0c6eb3e03713ded52126c9f9c528a6ccb784791370b9c9abede2a95b8e8404c1333a0ccbc0dddf1131af540d960ce8339040e4b7eaabeff80a030a653cacd127dbb2cce7c3af9c74b8d7ea1917eea23e9e27fe5f9be491bd6d0318c46a053a8e8e3254c8a56797aab8c08571f295c4e67b5ecca7b5c3a9986582eb02ce9dfda73cbbbba6cc3f36ef5335a8c96d50239a038cb34ed8ed1b7420fba3d52647fc453c1f9432f053e1b0cd3a637ba2d10935a1a515a32ab03364555e760cacc0bbfbed9e7dc79e6376fb638edd1ee48e1d16d4136a7496fbcd8fed1f8ba104cad8f26a8da323c58ca751fb07dc0214662b81ed878af2617e35f738f6cedbae7426167cafa430a0cde8c44e47902f6c1c8bf12de8690ad86d90db8a28861f6ec72997431f4fa1c755d842e5efc806e749418d9306c964b4c323795945e411daaec8c9f35ee35a3e71d91eb9888c9bd34b5f7a632d3d8ecaa464d1ff6950c6a81415ab12508ea45906b44a423c89a5bde6bbe700e9ac057cfb8ef72b29505b854a812a3413be148fd4f82643a73f34e2eeeeb04ade5b704c9d173a43d0056f3b385e64524fa612c9bc064e4d33d1cf3470cbfe34e21b21d781d3332cdb31a3ab47ef0dc09d41489f33434a22d8222c7c4b5468b8539285977a59999b5bf80fcdd22df43b7329e8bdad9da385ba64b0040651f4bb3965a3681bd8163e1ae6d41d4269bf36abf16b158cb07b683329dd448ce27f96998f879d1af8121a45f6d1e519f58c1d4c70e641de9ec66e284e55da3683c41b243d7c5d0c863073438ad6b3792f7982deee6abdb3d55219fe461905b0ea63da23b7507909d56adc7e52250e249bfc40823120cb09402e431daabea35d200724f6805bce7614d464a41d7cf9e3145b7196668a7316f10f79f3af4b972b84cfd0a9bfb2a4f9d865c83890aed0aebb82aa13ac39e9053ae896504e37cd6180dfe49f50cc3bd359f74d9e42f2a1bcca3908072eadf789543ac9fd86b1e9d28907607c7bdecc252c7ae4369da186123cff35f8dddff7b15f3dc79e673a509d4b5f7f68b98f3cd4eea40b799fd76cd311eaa2588a30b5f81b3d7a3c11065f5771067b13729651e8292517379448cda6f19656b9cce9fff578c738e2d5afa0357cfe320e5aa1aaf05b862ddf9f88b8098bbb92ccef1ce61b602e82baf2441917178cab31619855a34c32dca3148e87c56f556c66e683c278f139a8d375d9b0b9d9d4015736521d574d1686fcb9ddff05cec325f08499c9ef12afa980dc75fc6d4e48426aa0ee0fdaf1ed6a7c096d710512eed5f0612a38bb9f0cb962fd485ba11d43053d79972ec8cb6f253a6b33d137ac00040d1360e6395b74d5a0114655523ace69648c8cbe8013a9e2ca8facd415f42761650b0c2ce3ac44b413e0d573f15f7d5df7525006d035062835a111e1a2142d165d214d3c72f69fd014f2e2a5147e9e4230c7a5eb00b8ba430f7c6a6564d870f56ba49e9937427fb0a678a3a46f302af2a9624bfb0595458e9cd4c96126141ccd5f79c15c05cdfd3e614f77db7859f29931b168208c962fc08265ed19a364bb9fee212553e17a3bee1e861f4885611b7d5b263d13606b737e8e13aa3b47475f6098bff11c7fe970490e828f277be662242b795ecf911df1ac21bd9c8d3a1059c18a8336c63980724137502bbc85b6483803ed0150657883aa56bb1906d23c09247963bf5212ac1731960158dad28efc192ffb7a2b4fbd6bcee80968b7ca8395bc470f75f598b890701aa2cde38e274098928a41204aaa4d5745977efcc559187ec292bad39438a900bc5ce97da0afd717c3b11c0ed4eef570fdffef17b84a4abe0b360bab6964a897e7a5ef6d97055ba55a8a605208a1337557afa4db53299295a9b68886045185ca3351a11f22f3e21e19e88215afaa2e8961370f829ccd73bea061e9df1f03e343ce7b429f0b13d7f8ae2dbf6051c3b70470870b306e505cdfe276ec3253621d123a1aee08adf1c30606fe3608c9514e24127d5a7d67532fd751de706bf09c7ce4ad07e56ac49a1091840048aa163eee2643ed7ad05320851a30bf19c0cf88b835f1c9891cf38b301bc3cd51392c32da9eb5bf34b404800b76d56a0d9c4be39136620da5673222a2ee4282ed656ff2f64836b759195a836e1db176002a216005795d04888c7f8914d2f7012661d34601581bcf9e874b235a1a30e4df897e390b47b05af30569726cec3f891e5a65f0d11404d9e7da6e78daaf47dc40805194582d2b129b1ec388c4ad36872f523f06c04bfceca93b88a44ed3cb7cce187b1c3c4524210928d4a1d6989138710be056ca279d7d2db69d7ccb944b50b077dbc8ae129006837c0a359f1420ce55dc0e2880fbdbfa1bd89023b33598afe8413703ffbacc0d12a4ee53a68c96b9453c23b9de36fd3a614ef6770fcfd3382df528c263ebac0c5ec8ca20e9c6c70a70c3400a91d30b69ebe9c6cc226053a827ff635414f5944c8f6f2cbb6a07be9ebbe499a4342a34bd704635bd09061d463c833a65983229545820110f1d74a3a8050a19da93c68c013e91a4ffd14894156d1646c3769ff6c8abffad6aeacb45eb3201e7b1e484a2475ebc7677599acb31bac67a5425b1ab20d711ac5f7368e1e8ec2bee638115f7d35da6ba602b1ba3587b183482b218ddf6456ba15fbdad1932bcb00fa06d99086632a45ca17258b337afa360708dafcdf80387056e2d711f41035519f904da49f6efc1c528c5d69f6222f518504e0766d5b65d5e340986b9be9100d2635e7213b3299319a0cb902de1f748f5bc9340f4f0495065e0b9c00b44bc5518030fd81cf87aced3e3c3b74bbd8a06f3e463f00a5b2822b8525dda5d379277da5fc8cc239cf94e6793b2a37bd2ca7a956b9a9f23ed50801796ec0da720edd71ffcb4b442ed9bf20bfa4f2d843908822531fb1e0715227acac3e89b3858cc24a502dff75144f76eb5a65ee0b06cd1d696ae2a3d824c1735506a721a72355c8a836eefdf040a0ed8d09c4b5d2eadbd4e6ca3dd7ba876a04b70b35c7926328114b783b25ec0553e35341b94212b38ab3b0ebc329cb7835d760714192c0221e410c58bc36a087324cf52647a7bb2e3b5144b972bfc622204e2703d3b33eec666d392d1afbe0aca9d24df119588f18eddecf3f8f6d9d3fd3d2efca1c7c94c3f6aa293247fb40ccb1ccdf2aacae1e4d0bba9f2d63d9c5b6a8f14da80b199ba192fbfc3f52def33cef507242058693e0ba8e2c9349fb9b1b812354ad44871725833d9a0d4bc986d22eb04b68d2ebd0587f96cd0b8f512f5b2f8bcbb994c54cad5f8d8f1728b9f401338f43eeb663e3cb304097d00434fcdce962ba2f2a164366cbbab0ddb47548f8e72a4607eebce05fb4b0fc23aeb72d2609cdf2a33f418174f76633072a2b386053024344cc6021f7a434ed931b25010314371865cd40b6e4c59e9e84a48bebf37efd1fa948487ae6586356346c27becb3ff8d1cf69a51c44b3cbb5b4a7ddb50dec0ca07409f473f2a992891f4bab73baf408cc093fb529f04ac6fe007a6eb1bb300e9a7a5a9b0c5cffe13f7a471c00d35b2823511cae349758cace34bcabfbda28c9df4412b76e1b2af06f82a149f28ea67670fb896bb8ce6b5c1329e7bb9346b78527a367b59c27b998dd200e28ce452ac63c45406c96523afb4e337c68dbeb57eeb5e9feba32a66f8a926f08f0c9fe98dc800777c4be92360aa5dc328dd02f1aea4817df16876096b6da9cbd5a9cb7714754c080cc1eb23f843bdab14144b4c5053705793c0c91788d5741b61723f57e25b1d1d5ba303781475cd13367b01294e6935ea0440bcfa01763bdc3ddcb345ada4351d74c1ce67133984eca422a43061e3cd84ab6cd37ca651d178b0123e0438deaeb6743314525d9f859110a59c70ab90d56ae0b3841988cb54921527b24a40f7bf14694542e04b0ff9bdb87f09963154821b2f96c944493a1447f9fd3ea1df7bac2b5f5afe6b3a53a2d37c7a9e6cb8d513193266934483a1377741d73b5a26367f9cfe9b0ab34f38cbe01a19110ac7f45c2c38a5cde759e305f46df06a25aeaea63c8edcb679b9f393588047836415c9432362112d4e5cbd1590731451afa34f522c9174ea1317552b39324a596c86388001c8ab39a74c8589cf7ead62a94732559321466138047304d59c376c831a6171fb09d1da88ea4f75a6c4b4e3b76edb7683050c7643e5991e38d8038fd93394b367f073c37e4c3b57812855e65363caa257c60c4628bf25bad30f7acb96a7c9637b255f31369704366eaa4b4a41eaf73484fd730ecae436d37e6f6f8c50d4b459c7345cb76b6d8714bc0c9a73d5ad91440a49f13628ad0e13b6ae92894f86c395580affbae4aab4f7f1b557ea541dc98d4df5d46e408cb5431e6fa0a43d3007d36504a7253f8a15a6b2bc51f5ccafc17d5bcc54dea50493fd611ecf51da9db7fd476e68327017011f7f5edec98330df87c84fa048c01e57f5b9af7f9c74737151b805e4c5525001dc64389c8ce7fb877ebf4a47389f37114b4a004d8c594660796f2daabb4294ef7ebed2c90db42692f03069ed5e3b3d886ec85b5d0238210ce865a53313f4386cff7a65b63c567a13bfce4a18b230636cf30bdb71fdaf35e0d907a5cd4d5fbcd66ab817e0086f9a143212bb06ed13034d14890851d68004f0c3b137002cfc08c5bb8df0ae14d6c0a424b0991aed9a62e6ab29a748188fb2a5dc2631fbadbc65a7d8c1450703b318d714388f35cd4a294af06cf6a03f673b0f7ca0ca3eb3d553167c0e0cf7f97a2402593d2b790dd0fdd259452df4fd480041ce27f6fdb9fd96f39f4488fd6c54817d4cae89b7fc28b4bef295f7e1444faadef1600e8d969aaef2873bfb2a10f4c18dcd273b0a3d712752dcae45a9ed0b85c975b964244cea337cd7eb9c382240dc1f6058edf11df011078181a999cca82760851153ad7d87d78ba2c0d1b60230660d3b641b554458d096139d6163f8c03260c450eca389bcc22b9eacb952b04af551b5d7bced2aa1b6e102cf6aa26f9d8de602cff93c4682c5086c2cb3306f2767b8764b3fa6f8920d706e40ea76d3d84eef585082e096e105e45b58392c8d58c91047c4187a5015c4e6241970e81e6dbb48f464d39f61f125548294344e4255ca48e487adbb5bf71c0902495375723d28220b036f32634c0432874449b52e6bac0ef25b4de3e8cf5f6d744899dcb7cf9fb518322521b7630f1cbb5d774ab9d41c551a2f29060e386011cbba6edb99e055874a67f15c414bdd041a3eb359088aa649694623cd2115e2c113e34a9ecccb99d1972eacf5c35be3d790417a6248e518e97b7f12f434a12db39f5e0800e02e69d02d02ebc6ad8fde48308399c1fc536f23c2acc934c237b64b5c93b96985c5293a95b5ce78cef5c84eec2e7d36d3411813a281320cc80b84fcad99dc9c86710b4f7a20d46513862cfb3b60f9c4b6c22add014c144afc250a7187a83744e64c884965249220aac271c2bdeb1ef5da9e3770e6f3e9984309c031a007c43402174211f794ba5d161012259723a163c6614ab3b9c80509956e279efeea870bc6c216b610213e80c17ea3244eeb45885b7261520aab794959ac36cdc66e87f4eb920ba12e7d4acc76d14685fbbacda35444d9ce5144d988580ea654afe401bea7456f4e17687ef64fdd766762e52cc5a396714db20a98a762839a4b713f741114e983d81f56e5bfd3690544686b759c474ec22d2d712986ac407e8b3e3465633ec5a0af9ddcc48f2a082f9e464cd9369befae1f8679d84d36c676934881bf461a6310150be98acdb5a2fd82d2bebbc556d912376a7dd208e3ee7daf2f995ca2f6fd63399438f3bf502c5da688558e3fab2b9d183dbaf0ea278436e8086f4f79bdfe9a001667e5b3c97eedeb61b8ad34ab13276e0c95a90a640c31f0d7f073fe9670080920f1fc9e0baa590a52678c07e69c06f66e71726806b255b104ecfc01ef052d0dbcac96456f01fbc7ebd980edb3fa3040a8f30867f7d806a9a9c9975cd1ae558e35ca4ccd7caa173de690e89100d7d1887e8af75ecf1a5681d142c1fb85f58cd85016188b5dda258e9ba7ac0d8babd75c0806bc388e651ee269251a84fd66a5e7ffee9fa0283ae5819c3eeeeec9cf6a8cb1d6c079f615f8cb84bd85e843bc63d70dcdef4ed77d99d218d38538d9b6d53188d1d2222fbef8194e3051b6ad979daf327f1bebabbeaea842bd3122ac0f9c4cee178f8821a2644295b5e79a9d2588214059adf0bf42fd77f4fd11b43c59f807e98cb458ebe726380e56414aef840e8df050b89d56ee03daf515f19027acf25b60bf62939b6206fadbb41a18fe9212f16a69ef4dcd75dd15818d3b30be9a3bdebe7ca988954e29f92b300dc5b1980785b6a54051a777fc885670ad9b8e808efc4f682e993b3ba2a4604fe8a7c94e8288865d8c720cffe7d817f24b2a3c515f7a907e99f9ae8b8c51df082b94979872b9822ad8b76519539a7788e638dff39bfc52fae51dd7aec4f70571569022f9504eeac8a24ff5b6b81eec7846d7846a840e2e3e754f3448113b2d5a4b7e8aea85183e232ef95b58d0d1b205cd02c1701489f0229ac8c217849b7aa861c44eb846086dd78f374da2440c73442b0d790d2696db835e84c233e1f1d9368bb854310b379ac50d6c994a61780af2fe9be46ab5a7d250254a2ec53849141840cc630a9758729e87999bcc3880378e3c32dd976f69c3c334aabbeff494185cd7d46c0efe7147a725a16833c4bc39ba462605fcbf34a0c8465d2a55e9eeb4958d88358a84460335a442ed5aaa613b91adf858ebd22c019a60483194deaa6cccbd2944a65d46338fab703efd37b42d7fd0a81a68afc519feb5c7df1c37b56252202e8d18102226cb088bae1af724d2913e94cb8a4217c798ce01c9d07c712c338aaa8df0b11657dd0065004c337770288048f4c3de5bd68b1e3023b4d35eb809fe87fdd3761af35b14db93f1e86d8a9d7066b06c08a12c8589cc908f0a8c6f78ed059f311334884c9ceee86fb17b25d0dbe922fb99d68fc24a00e2cb841fe586257a59fd9de608655c7aa295cd7cb740bd18a607d63ff620dcd251dfe301aaf67667237a511d8f02a1accb2d41d2990cfe57e39fb2af0685a29c8a19d3237333a97eaa0df8d7e5d52186b6d4b722d90bd15ad38fbe689b340babaa14644b9f9d3d1702a5f763cf8376f3ddd61187f3c627de6b430d03122bf06f4effb2c17a927083a2817460ecc04ece0bf86c6310ace5781eeeab44441ccc1b7ca1498c430a903c803204a891ade9845952559a05786ecb82dbd093786c85b73627c887524dc2ad2075fc0f1ed7449684d88078139433bc0f72b6d7511dc4197dce9ce659c6e9ef072cd9e107a27056056a90960b454349de07e1c7a15a43230dd887a8162ac7c29f1ddbfc655aed7c303d187f4341ffc4748710d1dd0d77cc569969efb170009c414d43a896be1b206fd76bb0dd1d0800ed958503cc9aec0a86e0ec396f45445ac6a23a7d7e9e3f6efbda11eecc1f6ae8bd9b3e98a09af4ab9aa40d4625cc61982605768bd2c9a5b996f4a3f3b22bc60dbaa1f1ee911c441e72c78d086a304c73be7d051bf7ac4fab24ca04e8f025adb857cc4ba460b559e11c49790b2ae9a0b9bc2cb01a660dc579323e7521201145e87a1052e9f4381c49fd2d3d96af0db55fa6aad67e9c7044480aa63a8676507d08b360382bc999f127803855dc5c1ef851f215ab75bbacd1623d024fbf20760551002a4a888d9892c205183c03c57e0fc2fa1caa3ad99b1315041afc20b9c0045c3aee1bc7abcbdf0e11c84611172a92b85590c5e22d10a1ad8b448f642af5da4df3ddb2153fe74410c9a41263082e019b8fa8282de640d7adcf2a05d647774feed84d25deeb39f75e8653b82c32d6866975841523bd983bdf3d725a443ef08e6754d5c093db5c397e576cd091cc4fd53b24dab1a60091f679415c5d41885b4be7db995403a38bc763b4d33773f782884884e2ac3332acd6d416cb45e8c1245bd54db3125189bd60e8e558dc95e59f71d4c76198547fbf94772e46853ffb092656fabce57c99210e1fd8c375fca66a14a1f32cf95f5ce247ee0cd071d4130b1ad165f9ec45c975bc649b9a1f6c3ab57c4744603da12c7b5ff3e353fdf436091f2a8ebaadd39d881fe3d955706878e606f8eeff6336aacd2c50a555feb4036df7b53a3339cbb3116aa0bebf7ee88fc02a080565dd92fa0f9d40f209535167695e243f04bb9ee23eb5f0e8e3c63d2692e48b424669e564f7dd07b7387a8f56356cc77b148072d1c1f3c6f2c7ad3862d71bc49b79455fb76d2430e560af240ec44dc9e5a035d3ceccab818940c021505d3b75cf6aa00878ab2e6118890177a5dbb9e500a4a57692ae30ac679b55095dcbc5907a2371d4827f7604964ebe189a2b8e8d8495f00317768b25711d8807681b184928bc7b38860555f34732fbcb248a269c100504917d211e769f8ec193ae5489371a7ffa2bde5d83f4784edc2a33208b0262051d266d12104e2f31692faaec709852ca58b74ba17de133562e27dc8efdaf828efeb52a4429dddd1f0a0f120eccdc54f3daa558cda3f98646b11be32ff4e0e79ffea63f9c85313ec25c020a101ec60f425a9daf929591f10deee062721ced16265f5ff3e955dfe2ab8985ea77f0c290ab6466673c4a1ebcb4724891b822c0b39303fd9352c258ddd7a7fadd33d1ae860b596c93cf88dc2c206673b0d9d10160ee2f0895b57f0e03001e6f5d9dbc5c5fe906c970d900387afaa1a8f4482bf620c8612fff2874f453273daf069ac1140c66a7b79c6b0f399806c39765faee89905c4914210ebcd77ec90e757825b6c2fd56e25b8ce25457407f8b199265b5ddbccb45ba175888c12b71c3402dafd7f1a03427791fa6a649f918b81d11eaced66fa44e65b8f16534242f40cef8cc4b0beceaa9529236f1118e6ccd126b6b4ec05a4a3acf0d09ad54d0fc61ef04479906d38a725abaf5a37ffd4ff05773280aa2467a547999d672472a2448d23edbc06f71f7ffa6a7ef2a1a0059cb1e59682d76826892c8633ebacf135efd67c06c1e3f18febaabc4b9f3c014cc7782f7983433d2aa0957205cb499382d0565bf640fae23ad85c8b8eb75baad5ddd6fd3a7258b46453d32d3d4654878dda15e05eb607c7d2114cc212ce2b95662dfcd172de31f9c722d47e100a35e85b9c53663308427be16aa3115c0cad307626e2719bfc36dc55e797ad66c7e6a6e482a369f10f30a3403a093766f308aa759431c8dff863cecebfcdcec26c7a66e704ec68f20c4bf0c36eacc5c2342fe16d4215ccc86745b921a79dc00326069ef6f94e26983b8401375b5f18e35433cf11f176d6b015aa45e7cde8bb82d10ab04385072b2cf97a3ba98bc8b7ab62a1826703448f20cd4513d5dece7f568bb0884ed945e05e7f19543d02b315614f9ac2343d2c926b0c61978e4b96cea6d5aa9ac42f6d4085d293b90388fc2ee704a8f3ed94dbc5370c14a4a0a6a31daaa3a81b1c88f5530aa3fcdf238cd1af8e8b5358ab1d5da584ca9b4aab8eb594e730dcf8c09d468a514ddfd53510b8c77739244ab2829b6f927eaa69a4936ac2a5894cd29ecbb4a4f431ca9bf5727c4fe4d72f43a2f9014a7527430d105f6ef4b6128561db6d3b1894b002a034f7215177183c0c8dd4f830ff74d864750e53e69bf875bc75de45aba896c45bb0836c5dfde762da1faceead4a5677127387ab9259325cf75e7f8f9f4579ec0f520ccd8f92beaaf3c2430667cdda6f3c002e6120af1e62da432549843ced8167544d12b1b7c245e9abe14731e0528f9fd13044711a862a2ebfaccf6cf3554b4bc7ac54633db6b653f87a1e93e151935067e27c65580e8c0cafc673075c1593c4fed550f6d805a5770d9b1cadf6c821829e78113a6734db636ba4e99c69b117ec82421b234f0665bbd1d8daf489432fa6b73358aaf98519deb981e0d906e3535c2f33513e377a4ca7388c803eccecfdfaa8a5a123de4437b9a302bfaa3c5958b53849b2f190d3961e7c9c6caedb8913e366d775d3cd4df90bc9bdb565d450a100f4d90c26161c0efa88a5de0eb396888359168072174b7745eb426a99e0bb44a13aee95f995e7c2a54f4f9acf6a8b8adc1da23406faf72de63f9f1afcd8bf9096facef1e2cad043d12610c3feda46655ee1de1052585a45d933749b15df46909aff57d04cd4528630cfcf45c29d6fca59b880b11c0c66c039a20a2e0c59a3d3476a4e325debd73f4698edff858175fccb1b2260140488c67f5cbf6d831efde31a6931ae8e1582957a9f4af503a249562699aeec0820853c96ef40ef8abd4cf59ab243e837dae85f63da09f4d9b9118ead6ee3ead411148c7366af63a4e5739b2e6154e8e9f7bdcfef143e960b47b3a248aff5db8295e222f505b4c74aa9d7a340552db6b258c41c7941ed32d28c5c7497a65504a481a20947cd2eb48c688ef4b159963a51edcd9bb87e1e541826a836402348109a26a6818b731d41a78d96ff019a161fa8b74047a43696765e7f83dd18f90d4d2c488ae275b508d43c0c505ab16f79fdbf54403614f407c24e661244dcb74fca17ba861799763bfe2883590bee4b36feb912eacc177df26444f0729067cabbced1ecd3207ea98e2162d65c42d2f72196beebe3ba2bcfd091cf7f0dbb89e8306882ee8c6b78cb911978095edb1a83fa51daee4e9b274e6436d69aee61c095cbb35227faa91795a3cbcc108bfd1f14de81faca7bb623a6cb1e21c5db5882a6c2574b94645e36e6eaa75c2692e4e8ef360c7c58f304320e97640e374f0abb6476cfcc1c2a88db9240955442e67e0087628153009374a88848c0fb28a5f4f05ca29d577894e0770dff6bf1af58ba049e1c8e1d29fb5a6abffeb47568dbd46e067d105cdd2c71a5b640b39a42f85a0c0a667892da349ff25b9328e2b91d5a270f3bffed230626eb25a88fd7779c44a0b067704abed4d5c3d623fdf5618559de63b4ab26fbe86d9b88513b5d7ea27cd8e36e5af3cb6a932bacc9cc4156136026620eeb1839e3c3dde98919e67855079ed1e156d338728fb581b3fde6b49e57bd755c54ed9fdf796d33261241426a344a29d960dc0eb99286fe15867f710dc00e1014d7269b00afcccc9894d77b391cddccf03ec9fb2d3d7de17265de74bf1cb4056ded91dcf8af1321ee26fd8686762c14e17b8e4a00e4fec38de20a0f93c9975a3911abd860d9947382fdf4746347e85f5f59d5bf59e08709a9820b99acbab837496bc8e54ab69ad6f7179ce821ca5fc8cd6fe0e9a64ddb709ce79ce7c6d886c0917bca39a0c5539def0a98e8a1237cb110c742a13be64bed06cbd97b75a75e66ca217bb2305832467b7e9ec24f7a5f531702c3fe5776678bc5cd9d8fbfa33dc9174180da290ff0a71760c19cb5940e37be00db303152a3d46b8d737544b7473e916fcf0f697ae692b2502ca4a2b29db3c48de8d8b4e6c37f71baa7d7004d2e094584c46c22a46c662a02912eb3e02519f7b7a0564f547f64687755ece44e7601b4dcf79e1bba5526afb8b6dbbfc60a1540d5ae35e4423e838a16a65f1cf0cdab9ef6ffc21a1b1d8bed2df269dfb7bd39144c699ead7220ac3d71de3531b4e30c207547068f2a2e920e8fe02a285ae87fe60c02bf2828cd3316c37ab9d22857c16d66ea4b998cc72d2838b157e2ba9a13d631479d7608204cfc82ef6ba4611ab061cf35a529fb45f118023be0f7c7061d166ea3c5f4da4ec6ccdea205f55e17e4d9646d9fea0c910978922b9c11f0514983f1e06b003abeed09bfb54381439276e7f29909ef6d715f60b6822c238fc647a4ddf595bdd4b2141c8b9c9403511546b51384d075748ff80b93f5fad911b833336870dcab68994b742bc55d918841b72372debdbb4f0fcea92ebb516817764e942710b4b110e740f4583b8933bea63f028c8c3df89fb9d2131691df862317f9e83d0f7b424c30a3fa862db420162d56913dfba1361f1aca9576499c98e83e2c5629fa1f9c238fe4ab7a35678ae5c71983d51ba87488b5c0342e81d5521bd5e36970acde39fda3188374b9d85779eb4645bd6645215da15e86df4a66c1abe907aec292736c82887ce24b8e24ba358e2f04bbd96736fd0d69a0a1a6b93906d408231c89842e7305b47b419a0127034d4f5443411e6ff939d6f2af63a11ddcb338c7044b008df947ec3c367463c3fa16ef7737c9b410c4b91501a06d60321b31716ca86da5c579e8abfb3c90ef3e01dcad9387b8899624326044fd85f9816b5dcdc0de0b5a56ad79e65a8d861989b49ac9048a774f9c2407a004487327742ecc522869a581b95efb32ce60da9d94eef281ceddd94c46b05afc4d9e1bb5d67d92420ec87adf6797635ea76f025c14585715389a5f1171c8e55b7d4ed9d281b76a5e8f615571e97e774951cd8be82a605dfc2ab15312b0b48b0005c24f4e9f36257b3de20614c4c821275a1b5a4a508f46fa8b6f7f98653da40eafe3b2553e78f803856e1f47270f4055eb15af8b5b1f65067862cf625e0fd21c6ed38151d9a5be93404985b0fa10eac291a9d3098bc673cfdaec921659fde78f3c7a1031b3069cf8dd5378318cf10bb934d9f331791a05a6c985a69b87de67618ea5bb3efffcc062cf7897d18b53f86325e50c3f25afb9ef57152ed5a21b9e56cea72183eb3be4ec050c67f6c722e718ed639dce07265700ba427703237ab7299636b532245d716464bbd8dfa443f688f6bce656f2f26cfdd189303ca03e096ee47a0c86e6e7f5b6ee3ce254f56fde353f6668ccb26dc2c74a5b01a24ffcf2297d0099606ea146343151496ee436d6e20589c15786b89a65ec40dac1d032ce9bdec2d2cf9155559b3eecb79155edda06a9c58475ff3d5dc4e6f4f8417db0252bd428813c7c1a4a2644156e7104d5de7e4d16adbb8cead671cbdf138f042b6829746cb0729002ab56489d0a8662bf36883e0554093537383471e2958166902e0fb741e0b679dba168c0a1d786efbc41455b08771bb421c036c7082945f5617e0063a6752bd2e87c3d4fda2a549afa2b488e7b08adc46adc2e4c6e138f946b328a3cb4d02dd54810cf9a91825f474852b16edf6a848e818cccb42b2fbdfc8abbda40dff46b24fa82ea6eb786cbdb5a3ebb53d7e71f5f3fe2ca00b58bd7293c20692cc48b2cfbf02fd24b983a24bd69a545b543ce4d9b3b0fc763ed3a108360d5798091c209541cd9af7b4ee09faf545b62cfd4c13f5434d9bd50a67634e385bb2555060d3ac9c808b5d2d77c4f399f908a062117b4cb63f4f42fb9e925a449bb278f2b147e164823efe57cd8cafffd5b4d0d2dd43713da80d74122deef79c836550dc11813a167af7c4d796dd01b85b3f196a358c013dfbf1eef5788ccfb825dd6ace7f41ddb6f438e5238df36b8466bed58c5f7924746427610778465031d473c6a1f093124ef2db65666250157242260e29df4a8111a41cdb20028447839598df9593165e58288797b0ba47ffc48fc99f200d318f5f2285bafc460addcc5f717ed526c5a2758d2746a7be388d67699ec8d554a29b5d02c8214846f5c19c3891d20bbb4e638b3291797a70c5bfc8c89fbed1199c79209ea5bfb9c3c3fad987f2a25d8b5dfb7dd81c12a89c2faaba58860994fd1586f16b383f7583150cb87bb7e8f77d8bf0ff3907539ea69b1cbf8a898ef6db67dbf9950a238ae745f729408a3ddd932bc5d8786acdd4bb468c098542e643316c83acb1f89143ab880b8e246fb89792d60d15cb799754c482e76c51d3d6cbe88eb7b5296ec04e822f924ec880beae2b07820b87d0f73aa0ff5d5d4eea92a5eb1c891bfacf075afcb5fb16ca5f21bb21fe12dd12d7251f2c35e94286241192aa56e5b2ffca61d4d10fa9f432530968b82f4977685a8239d3ca096d058cdff00797809a200f23e33bf3ad790a7bb7933a8bd6ff28990d9579847625b1eced069b598ad43eb98e6657e023517c883bff6894777ad68da0265a1526f64f30d525c1e8d7db0ba9b8d7f8ddcd40c69339055c96ca7508413429fb7aac233bb9f5fe7067e6dac3bd932abfe2da9de6042183aea648f64d7586f106365e0bafd89bae15b00a20d21bfc1d4fa2700f7a063726e3e979aa293b3a73fdd986032555db4c64ca4f611863a1daab927272a3434b74533d49fa8f8f5b61365c0357189596b0180fcda01f120e78885513a83ecf4e401fd582611818b019acb49574ce5f8ed7a9efc2a94b58b388bdbb2da68e7701c19372dc3e7122dce7d5e53a8821bb8fd217a0bb6e4ef9dcb05f3caa302f0bccaf609f1168625131be67ba0dcbe1cb8cf3df8330c167cc00a00e7c358da672d0ec2867b7cc8778ce3aa24c722b3bc6d186720e532333ffa6ec9fe8bd017b4eed9327ca3743112a6a0d042190ad201847ca88e2bdc57367b53a4ebd6fe86366d69b78a04e3b6c435fe53d990220ee45091cbe299bd95cbaa6b8c632d7d9ec918aa6b5c162ffccf1f331bb5312852dda2ba68518f4a3f07038802c54968b594660f539c3def31a8e60183a04165e43e8473ab20201ef2a39d7b4d5e5a7d43c1f7ceb5ef8ce4fb82c5fbeda2df44f956c3f7cdc3a633e39cadca7414e7d13e6c39fd01007fe8ae1585f01852991c5a8da37b66d03bab98a2227c83003e01d9e56e298ea7bdb3f713d18d13c35683c7bfef915c73559030ad98908f126a152aac5bc481f243af1dd3227725d1c98067872b955ad3ae7fd09ef5c7b4216d6436322df60157f1083bd888a63d485ccaaf41c65b1c61aae43b4c60cfc9adeb140285f67d3fcf56878842f6765bc39e5d1ac2e0d5104b6059fef52bbd053e700980364eae942066c13c1da9580dde681d4f7fcc92d5c00b8d48488f3c49be4e9d03e173036d4bbbaa6062eabcc31371818eb73daa715e9c46e24417706341e1f87bab9bed14394d08c5639dbbc46c4b20f36683c1a31ea46f7fba9b7ca46c8deedc9aa5a93ca87d7e3c8358dcf8351e77442209f97fae484b5d70843c4fdf1f4a1ee2d72479b39868e6c989307ef634077535edf421b49abed8f0f932fcdad3bef1ed7aee00c7bd43e9eb944163abbe7f3f2b353ef637acceda91c07c101ceb6dd30e4a9bc7a21f2dc20886e28751e33603536216bb0d7cfb5b65363794470607fd29a7f9f5efd7ca9329b03914676df216c0b462d19c5f1dc386aee84e3a2296d97eb4f6316ca93035c6222adf52613e3d6c5ed121ad7c1e0efcfeaf35f41cd7867bdc014970516a222024882a6b7e4390a4c58068569ccda4363d711ec44543d5e281df38d75f5c6d7616e593b54b73fece0c14775d5eaee9780a0ac90e73e719c65e639a215dd3c2dba663bacaa6e6797c843613de3436a5e8b37fd99d0cf95d6b665bdb8ae265110ccffa6b3d3ff5ee0ec8c455483ad889ad241825c5fcc06af464ec59da39a7fc955c3be54c2204675b05292db8e3cf3362fbec7e742b85909ff67bfd6541d1ce3c8540f71e24de72ae0c3e1d3061c7b6fe7108c258968bf9545b2623eb0b33431f87ee65efa49e6e60c559cd3bd1a9c5d0f8e24c44d41884cc4fbc54b5036ba07a46cf6a7439cd8bf6b55a7c61027a6e76d6f270679569a94954b674a291e33ef31d243df09fd18b58d686d1f0317ff0134d3528ef4bad8f6d5ad8604b5d3bde195f967d5d35ec19a15203a74b76eaace6d19fe79c3d884abd589dc67ecb7c40d78867d8450da0181cf8bfef1b7a63195a4ab2b5b30cc599ca98a86ea793a98f8f2c6cc69d1372dce82d9d45d56602a3881ccbda38c09ea714d45cab67f02a34f0f7dc1619eeb8c19f91b118a65bb76a83a2cf2e62dd3bbd1fc18bf270f7c3b6bb7d1b23144eed19587c712d05c26252de1db669f88a8b3de13d4017c7ad6a5927cb8598cff1a538c777dca4280aa521dbf0cf65489da4f5a6ac045dfcc9dd5e24d829e51c7b098f27b5aa364c36c57f83772a62d29e948429efd330478dedbc6543b9e12cc3f4890ac4b5b713cfcb8ee8c259cfda9bc6b63536df3efe737914fea4a17904abd13b120521c4049d6b85f4101996104e315aef1cc054f4fbbba3ab8054a71dc6911aed4101ac492213743496d9aa91dc74ccb98ab044164f530d983714916fd8df92ba1aa1c1fdc9ed6e37f14760e3299f5f8aa181b59166d048b51c77caf944d810bda69f519a4ccf05df11de5cdfcaef625600630f1fcd02c40da2588fef1b40d30ebaeeca4223c069f770b9c2b325495dbc887dc959d839300289e23cc2068f7c47b1c7348e64f05579fba2f5b230d8dc0b08322195179114d73248976d9d9712d98f06e904c60bafa6f6d280dae9601674e8a577bbab38f1799d5c1f03e34c6a731343f6c42dbd0b0bf8d7e93b8997f14fc7652840537617e65bf865ed40c81d8e0854f0876549a74135486b99fb0a4919003d325f4b1266e0935d6201e5e8e7b1557678a4e6f4382721bb71943f05301a667ea82a7756fb8ef6632acc6b7c32e6a63963a7c51f314e62a449d033365ec7fe91648e3be94a9017dcefed522a4edef509e1fa2c3d26c2a527382d542c88a21c40ebbb13b56f5a25c8b4823b439f681b5dcc83625a11822382e9673f0b62cb19c30acb7d3644e8089315a6a36ff97e9f3b6193cc27679a565338d45cfb000210566f92f8ee45ec3a731fdd3e3555648a6287394148f2dea351d132dcb2a17ab0891baee5b9d6e49a4986083fc6ac441fa45c5b0c84c587f70ccf660fb1425442e7b58195d0ed29bda22e9671d31cfeda31ac876a70ed19a22cf7735470161c58b3f692089e8d390183cb29b3faf563b52825e475c951b76117b7a120c3e16818bf522c7551d0b2679072c40638efcbb69d9f96aef05c08c02171a3916e9f4148a0e0701d73f32ddc0367037181fcca092dbe2138896f0298f8c4fb7cfd23d43cfab44fcc4d765df9cd5fe81651898d5938d563747bfe6083b78cca36b7e619c4c75f8006724168d975ad78c2934704e9e9eb717f6ec26f279f7802ef34","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
