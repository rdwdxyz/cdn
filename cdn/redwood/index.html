<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"806936a6ae1983c30dd660ff2d5f1494644e4bdcc55800a337c966422c192efa0becc3545a6c19f7b1e05f373081e969c885c7b6232aa3516b1d19542041d8e1e43d0e881d034023a50ae03508e664ad82cc6df4cf094dda9bdb94c408b1ac56a2a58df7a7a02175c991262d93a92dd6bf821eeb1a1d301a4c31675255da9614a022b6e0bca422751f5e0318f7d9452d9a0aacddd4c663a5ecea13a36b0184a83af960f0eb4ed0976546be094db399817da925099bf2fdaeedea36f690ced7188208856c44e28500a1dfb9dd210f70949caa650c8f181276576fae32d035e78146ddd216b36fe39ebc5cc8aff794e7c18a635526b6f0cc218f1a413d0cbbdab85ad3f0c350db4daf2d4df4499c5fbdb44657c47cbcebf90d4460bfb8733819a7925a898ac82d04d4973287d1fb3dfce429657c7cb5b10dd2044c657b0353a93b3479119c6a5b95a97f9800b1039fb7c0574e750ce197a879f7c50e5f4e9196f9570b8dd2e14b44829dd0349bb8d3e9c6e6c6751bff038e418166c118844e06345411bef024cb9c007342171abfab82d84930e790d8d5cc464ac1bc16629ec904903276f4c397da82c138356db20b9a4ccc2412c33fe5e6dc4a9583b6908d0c83e5d42891eb832519569eb2e66ca98306cd15edde18e4475ef983040439979a040a6b2d079b5831753a6cff87ef2893c449342d828bc28351444892c468be568475923d7217305e64cb30d22e662d70acb86231dbb69333880171b0a0f611a994a73e8ce996a933847f88f60c5343973e5387bca7b2dd92ed4fefde4a1f8b2e036155fef04f6defb6683c02c6fdc0fe514a713f7cf29d07940dae9f184c5a44fd8ccab949d058bcf8ab51ce69e734c40c264248793ff83c6c44385d05f4c6b80c857dbe950f678ef9aa9cd79696cbd13f2b5511f4b94403603a522516ce69bd881461024f62bb67a28b3112acf0a0ead20c68799f02f9f91341af0ef77708c049fafc92168778ba19bbd1c0e51accd58ce19da58411d5d2be38a71db23f80f62a70ccafd8157b6ddc76d9b041758a2b908d208052cd50dc5effd8741a0cec0a5d59bfec340c1744cb01a3b56edc5f066498b92aea79dcbf662f2f9b8693b3e6a5cccf4d25fd76a3026f729b87a5a74b5eb8ca03f7b5583df4b00c4156d784487d2f16de8baad97c7de5b95184fd766da55f4965d92c7e40cc8c113e5c083e61c23261356d5e1a98149e20388c63cff598099be18d1afb3ab17ef3619e0875c5539c94e956c451dde4549e800c2a88c103485f0c92df3bade013d73bc0c2689dc5f5135fd16e6d58d5438634d4a98cb7cfdfbab111d4fe98ec5e6f33396d822c318e8590093adf67d88492e8b4de56800e2f68a6e2d536151052c2f8ea11f4dc521d8b96749282780392a021f036fd6b6ac53f4f805c73c3c3979c2aec9faeecd0bd49b815d6b95fbab4597d03b8505d632f8bf782fc7c574bc3abaca7f8c3b15df4b2b5ca446c7c0f7137e58bf6c8782a4ec8bf6b640c8e5dee75269655226b78137d1c282720d3e2deb520d7dee9c73d5b76090df1accc644a5c7878a8e2c69eb79c6c07be85596495b895852363b6a4a6d44fa5365c56c23a80c4a3e61cfe87be16284d63c2407b36145f057213256cd17c7b8a108698b1a17846349c808a33bd493b76de3c242e67f41323fbd7af26303364ebcd9b8ebe281bb18718f3ba6e209cfac1e673916a2f1b540995f47105e8f88a59c62bad2f1993eccf42a3a6d673f0dbc8027c094feb8e9131072e3bac892164e8fffc2e4eed7b4d53ae0db9f505026043e32265b763f8fce1279c0d9d2d544f2ea9b50fb183778ff1f0e0747abc15eb5a357f7e9f7ccb14c618e929e44e0380a6bb80cf27e528494fa1748281e593fc3a44fc1d586314bcca159c6bc547ddae519f973bf3ef46440b747015c25bff8c29af2856231315cbd9cdd2159eb43f29ec429a1d65ffc4c197e52d0bba52fba573d087bb363ca80624c4afaa2be7002e3f52152d8ad1102c8629195fbba2c83d8ee10e34f7738e36e985c2c6a836f11b6d8658e9ac4a36618311b67255ddadb98ff3611b71631efc6c3ff9d8d7e5bcf3c3c325bc52d4db1d7d63ee5dba6b657093bc9115021fd1cb455439cfe9bce80f83c347b0a96213a6ba2015e15dbe23c53d69af1b7fa355e0e26a3eea92a76eb1a443fe48fb601a9051d6231da5f721ca51b4ede3c6fcc97d24003498487b2f0de0be83d987d1f2b415ad1f2417734e1683e91628f34a85d00cc39994a9c558ee56c54ef9f4fa3ac0f2e796e5a9e0c7af43e3918f7215841b0a21ad6e03c9d7f4f859c6c7662b438b10b8d0ad471bcb74aecfd908cd468cc7ce5d7b70207495fed3f4e229e7c918fb0bc23b66ecc729e44072701554213664bf486f192b470d6f4f7edd0b6fe3744032d5da864eaf98775de778ca92f3ba4e1796a044ee6839fd04c7056b860ee88e4895f46be0e49c657fed36324cfda3268bb61bb911efebe42dd2361a78ce5d7c4e0c85389ad8ad308aaf55e2f4b6d09c61bd2ec78e49adfa8e204811154be3760fb5b8034d15ea93b9dbf1f4d46908d376aa77964794fe0677f5d666297f463bf64bb22e2f7cb9a0a6b098731f4fad8308c3692fef78c9f5e595f78a27a98c7a97e59887e2a7666e88dfb7535fd8dcd3dc0db374f0c152754e92ba5e73b7d9c746bc079b762ad711c90a9da3ba54a7e0a775343c68ef5b43393fc64ffa2c43945207e166b8654050631758c53d38d9fd39c8c08ed50990eed0ed1248be6fa698544e54c5391117178346d5cdba6be2b02950988f3cc208f44c176cb52b91bc34e488a73e31dd6dc34b4e1baaffec8e9185bd60f829ccde4c86553d052a4882d7bbab5be32975936173de9b382fda3657ac5c4f3621861134c6c319c65daa9cf6c9a408a1dc5e2e1c27502a35a8e41d8d2d9d56c71223318b0e104fb6abb2cb3929311cdc80aa6fccef2c47c8fd3a2c2b29683653358a6c48bc877b334d758aff1fd4f781d70a55fd52c497b28d25ac654342de5a2169193213f0044a2d6380f917dc48395c93558eb3dc85f5e32b71cbfb1c6273417643977060b693d131a7cae1cef90a9ea7339708f8eaaddd38cf0fdc93f6d3f61c169695d4b882c6af74922391c433152542dbff4787190f966f0b428ec06676efcc9fb91d754608fd610e50acc97b398aadaca1aff0ff3965f6843c5c56f04814d27e1da89fdb88f989c6dd8f0c8be5018ea9a3dcad594f7f6df76cdda651bd4c64a6853060955197b9b9e2839142f783fccff84992ed7e1adfd0f6468c103aa876e872153b974e815f4441fda68e48123d76ca09fb61e2f49d10b80ec56c0ccf6d4c1a83d1516d20ae1ec1ed38e5fe1e13e04bc059718eff2e569e3588d6847d03f94d2537ad6e957a88854739f1b482e865d85ae18c1dad3ae33f71768fe0478295b722455f7ae8acefc9c7f6c3105f7dcd0f77fe8dcc551f18643b0e5f692871144120cb1ed3cb7a37b1e173a931119b44a53df06fb129db941b6226d7d4a6f00371f038bd09e0df9e45806e61958ddd1bc2ec71f54e5cd308669867dff041120cf839358c3fb8afe31814bd20c5e6496ecadf091af3812f463c2ac6f4d2434c181bb62cab4bc7b246b4ffeccc4b26567338664c8ae2fef1d224edea82f9869c26c1b8b4c5e74129d59bb3d7bfe79a8f322e4a3db9beb8e5257a5426a32e90f51117903ae8b2e76b3c80faed85b4e13d06680082614248e00627b5616fd891752ec8fbfa1b79bde3826b4833801e70790b65a3ed39d6251cedfe5d1babe9a98f7aacb0d3eec7d3ca9a1c0a2cebc9a4e2b39151d99734b0d1a268c6a29acfa0999a23ea55ce0b4dc614741f4cda68a2281ad95333d180a51edc04fb7c0edd211ae0c2acf540be4a903fe52adcf53fa744e50eb71628f378ce198067fd2488f2f29f1ca4cac16a3127da93bf878845ecb6c645eea6f140d1fc6ecb56c9b7f3a8af1609f09f96b1f4afabcaeb279097f318588631823f2372ca6cb6692b5417911ce163afaa099c5e27591970cc4592cce12336660eaf5bbf52394196baf8d33bb9ad8202f7645e2bf5362c705207044b49f8aa9d4f02306658c2dbbb8cf10b6d511f94c5d8c9452701c46fd12c996dc74e814bf65240f9a95f19a97ad327be64c0935d40705bba0bfcdb511cef9e31045874bc0bf92f7c8c02fc7227a318eaaebee0841000d71b20c2c21babec298e70efcc97bfb2f2e70fe855c11aeede4732688be144336d652c47dcbadbbb27316001f20d1ac5ff4a4a6390d2d2a824366a9f22359b96a991304a5a91cf2e10ed1a0f2c2c7b4dd7423c88e4cab8db5297ebcb91c9927b89d3d4b336657d00e2063563b36372e922cef193bfdd18b8d24291ae7df1a7997a10c9b12b9575e510ab6d97e033b51a8d299e62b0ca387dd77f5819e60d8c6d01642f90093545d61c72468ff11f6ab581a55ef6e0d1c7fdb024bb9b777995ba99cec02af609eaf34bf35c89041d27b7591843949f5f805b770efce597b4186eeaacee99c6ab0d0a449b2b9ca5d5030fd146c8bc09cc435de26dbac0ab6b6cbc1d7affa6fb8ba61f4736baf12ae735ab192670c2d5f23b274e4836e03a52c00abc66ad14f29d29139881971199f751e9b86b3cc31c4c169a5cfe837cd8144019e0889cd1eefe813fcd9ef9ff8fb684f4196200adadb2f001e1b4c0f76a1d9f86d58bbaaf34aa9206fc956075729959c4d4b28cf2274b81059f91703536a7d5f7b3581e0c3f6f367e0d3e70d658ff7d526f03b61452b9cde1054d36ab437aad469db674cad9ee3e82df4be906390e39767f299d38117260d5f7324a16937e68ee2c20cd5edcf28600a7f31b8ceb92540d724da41a80f9739c46f621eb52c44aad234a3929337db222d1ca3c92ac1acd94d1c346a08c04ea6a6c42b5ba3768950230dede4dfb1b7de41ed15ad574e48298d9c6eeeb59e10d2c20ddee7bbaa525e2128fc25a685d2b2ef812f2c005cfcb3ba9d20c1111a3f3fc7847c439c9f5a0b37df875cf0fe6bc50f8065e32f35c777c289c38e21107691f4a476710cb73ada7b6b9f8fbdcd81d573289ec99b7232239ca6ea8c75fb2b1f4a2d83bad3daa166d70b3a0a7a8eecab4942dc97bd5ed20a7f750f9be01774fbcbd7b78c137887d3567398056d7ca0adcc11d0a03d07b137dfaf370424baee7fa2da4cdd1f9b7e315add841e100eea690059581dc34bb4fdad374b06979ebb8fbd84dbebf8bf176ce28c9f6cd4ae012a9b3918205f3dd8d099c42fc466d4415179d9e4dda692a59eefbd69f175699f6f4a22c507ed17f9e19e5b7bc5b806f300db783aa5bf57c125a3eadde90d0204c1a17f119c3f30ffecb60c977307e419ea2a3a8b802ebf808d4061bc7233f3440cd6abfa71059525c8845255b416eb6410ae204e8b7613465b1a2d0b114cbed21d9d963ed24d94701c440d46a9727f9fe44afeab39b16f2b542151a799e62271f724e049d824338609ce584f8456be6e47d4ffa596f3a55d05a3fb14fc5c3caec1646dd416e333a4335f5e9a285c00b3d38402803885d6fad590831b20c02bdbde429c6659e305836eb8157f9ba5e7462f619442c691b72c74f1548fbc653620b68f6614f78c726c08c853387f8022c926a0c22e11c020ea91747f916898daf799e4d723d11ff0734af46557e118a4451ca8ccb526cb8db2cddf37491c94f5ba2ab1bc9553ac80400c74e29007d6db666fff37d8d7e03911a8a40456cab0fead87f77748dc141f9cbfe711307b1bec668067719bf32065c1cc0956b638461af0cc70ac75e4fb32bd452fcf4bb67b1fd6c0a0c845f8d772d21867067f08d58bbb2ee4892f8938a8af4777bbcf6ca0cd5d721aad8fefcd7359e6a67cc126b9a0fed27b7cc17e8ebbcbd82f20d0372528a44003aa28efcea3bdc5343249d24f0da5e39ef0090f81cdc720a53408e513186c3cfbe2c57c9ac66a297f774144ecba65d4fff5cb8d07a9a52fb94eb910db15e36e304f5c48cf3117f2cda5bfba57325dd2f521fe53d3d2428afe79b9a1b6356230e6dce1e7ff48840e712ea0cf4ca35e9fee6b34823749352e22662040a588f6afd6cf7b7115d4082e0e2524211438702ae39ca82686cab7df2619cd3ba917ba57ff4c42113a89eb1f18a9d814c956f2c0fe5c9e349fc4f19a20ba27c9d8bb683d40e448ccdec831ff1f8ad6a4dbebc76ad82b4a6371f19b9347a159472a8aa50be3d62569061f35c4d16f50b2475d9901684c7e5f12c94f373c851fa9fcc8edda0950edf4e0103ea8b794dc625e22cd91e9893a5b69b06357b41620c24c4c7eb0f0bfceede7097f51c1342111c0ff24bd856457a1593f5d8bafb5538fcb1bddd40f79a0c5b8ebc26ff43d8ec1559a439103712e002b102e4a393a8ddf70b1be7e99ec3985282dbc6d01300b5f59ca3635b6709747738ebab32dbe2de24d9f07b8e4cb18439d0eee6d8a31ae7c6e369342276ac53051f7200b2cce214a8f846d76c976261c51c4f5a67ffb55fc1f2b31797d45cea6e6dcc5979e293aab999d3cc19e419480001202b4d56404902cad3f1c93dc7e08604fffa92c3a6f479387fb28dae9d83c78ec142d3c1fbd32865b0ab5972e51301c672110af76c339e1d7701cdc6b9a1a4b02ccadf4005ec9cdd9a018daade4282b519a2d728d9e1e20719f45ab7d3d852d3d8de4cd92ce0788d6d0b6298c8abd2b7635c3475846cc71fcd430591c379578d9c6ef1b2dd676db28117a62626e3863191feb742709204cbe916557d8937a7b6ec65489a41c820a0e346788010395590f7def7009101ff3fc321dab63677452f3436b459469967d5c590bf51ca7c94e33429ad3fe572aabe474f8b8ae7f6b7bb6375ed780f9a6ad49f31721ce230b9c0ed64adedf97f584292bca15b15649d6d6b84c5a42916685f83ed4c0ff28c211756c2086cfdd887769d099c3aa61e5024e2fe768e9cb6335b00a92e845ddcde719a6fc8d48d2a6af0b5c76efcf1b9b29a1ff7ba3010e886cfcc4c23f7a4c37abe5f75f4500032fb58e427b934c5d934d121fcba64d11893bfee13b96d410f7f71bc256407bc7812eb7e27c1f86e30694588b78a6e170ee776d70879907a31099da468a1eebb4c450e0f0ec82406ed0d73916e6ef0985c7df7a5c0f021b9be03f8afc2c8244aadca7b76bdbf9019ed6725a089afab14dddb4c304f73e13dcb4da4e0296ae0a378d55ddc4f6371a55ecb6c7b333a55d31f52bc8e4605be390db7a66e30899e1e40801302f4ee550380022ada8fb4ba97115897805de56ba1f2ae8ef5dc20e95b1cca9ed18dba1466d4fe0c6c2fcd0eceeb974013103f98151cf00d0deec43ec5741ee897a22b6d733de3474adf5cb0728cc627088d1e9c27cb549a9e1603e46bc85ace1ef9f13c83f8c8cb74275dc1931ecfb5254d3cfc2fde3e365c87e71dcb777468f34b3748412d6ac5fc8447ea4d815ac4461f1c239bd5a03089b14783dff9070bd25410eb129fc27a1d8a34b6f00d0edaf97e190500e9aac97fa628d42634a5b8e08623dcecf8120ca4750291261876703b5b644f11bbd535e937ff1615a82fb932bf536c6529bb2d586bbabe44f8fa25ed7708a6db030d015a9c8d2b17a3871fea36b8ef1170f2d62f2a8901d6c8ccf60cd880bc0f9f2cfa62136656a28dda8deef322afe8d8fa6d5db59753d3c5b4c45c71e9af8d5bb687a22a78d688c66f60c7646e34990c50baff695c6f0fb547df010fae9fc63da5bd9a4e6213761a40d35907b7e98bcc8b3aef4612d401da0e746504d84d93cc7be5e26a73927ec839ac80a139884990a3f856a2bcaf14c6707d32416396a416d1588025218151e43e6f4d4ab33d6972fb9ef92832182a94f9ef64f4e4ac2f392a1ab293309343040e7ae1b19835012af206bfd93c34efbfd86a0dcf3a14f052160bc97b0ad71d9913f2b4adfedd96b5349cfc70da5e687aa69b571736a668a8a47f36186ea64773f57f1e49d66237abd28f6bf9495dbbdd425ff6bbd27a9da9a3ea2989d35282183de55552d2bc6669369ad1f8c4baa687873ddc418cbe58a28067f9e38f1a98e3754aef815ea7d14b439aeeb51207c082394987cc3a25fd4944f7ec00cabe1c77f40228159060354c2e713b28832642bbde6ed82b189fbd2c22cb828081d35babafde05e2d6d3e6cd04e2302b8a00730709ac4e16a7540a86b8c6c3d01db86964941353dbf0e7d59d75492f126b13c5ee732ca4c10713f81e7c8a834eca17f6daaa3fbcaa1e722bf4bd2df9f4b44ff4f4d6a9c6fa039a2ad377c188e6111c3f5192619ec0ac08f5d4d09401d78c1d3d20f3ad82b9a93ffb12dca21fb31f82bbd772b431b17d5721faf627b52ba0eb7018b0f304b87054143557d494729072fc657c96946ca736e42622df45066ce7823ab7f0b160fa32c9e9210863b9e0f78ded8a8b1f16edb1fa74ebe574d7987a79d8da242239b65b3ec21e9a0612d4226d99856f24799fd1e73dcddcd9141fd13cc279b4d711ab8288d55acdf93e19a7ef52ea73fcadd116c44776315d09e651e22e7127e650cdb6d2251eb01d50c3091beb146c6ed1c01f7f543e137d61ac4c116c32102c6a8951e000b33820d2f241e06b91a2c2b2b9b055daa3f98a34100e87b9455d758ac51f6f2f1945c6c1ceb56465592b731355f6b45dd90f2694ca6b500f78adb14eb2534ba0a588b4d73ec5813f6d453b3dba4204937542e5d499dbe8a623eeb29a085859405b91e8ddd58b690a6b49268e9aff87dcbf3345a272a3520b5cc868185649849efb30f5ae22eb830674b242587391965a69e94f49615f227efa3943db6f15dae124151b25d2357bcd87380e7a53e5edd25f525fe23d73af9b32e1037207a537e192532c7ef1ae4703da25364bc1ed21203de0821f1ded6efb92f316e3331429cab76cbb0ccbbf7c2243f5f176f144774808e6ce989cdbdff3597d2a16d3232320a35cf931bedba11392842a90d40b64b43d523a2a7832f78c5528679c72c7323bfccf6c5e42a75a4261f48109324300eae3540ba8c282a3b5208ce5f86e6fe87de25d9c9bed727d5081be55d8282a0078e334437a1a1f6df06dd50beec270e9d70ff74951dd80d952b3173e55a9ccf13708da1bbdec0c2abb3f9a45a35ebc9e7f9dc63ab06ae8357a97521418828331e8d4cce2205030021bd56ece39c5d121241bce8f1bd00022f9b9483d10505117b89c1aa535909692f953b57a34530138a0fb1dbc1a289e1dcda409df6dc91bdb9b7efe08c86c1a2f2914207726bc0dbad8a111c18e03fef4318307eaeac1cd223e4627cf179d88902c20cb4c16356ae577baf54831e69ebd975dbb844e6322540e3b37612f2a08b8dc6ba4e36efac08a85ab90dbadb843ef6ce750dab912d30d4789dc86796c3dc7ac4edcf5b237eb413d5612efcedaa37d6e69774356b98aec64f0b5f8bf80faf32b398aced07cb33b2c05fe8d7a1c3f96f07dfe1ede897b84b53ce291608dde8501552a6790d2182fc56f3d7fd22e3026712567a25e2b13e312492e0c3c497056c0003762e3d288632dfecc35690b9c038988f129ee08c5409c3553a96709e8beb924095a1c98617d66857b66b351844417529ab0f1f08178c76d94332928861c98018732a6d488b8142d64d1be05c858089283b8ab5a6537cefc1103373e276b3e8b4e53d81ee870536898f94922bb119c116bdfcadfb787a4266bc81d3c97c887056b496160821be7be8a584d00f8c7c444557e3310611dea632c280d543b183ab47d10392a03af080a328bed166651cf0351dce4503691c0dcc6e41689a81dea75ec0c7ff6796b5be28a299f61dd298a0d2aa2bf9cdcdfcf84b4d5a2c52329369dd26457da9b7bdb613f146ff20abff73bcf4b6c19bd2697af2ba779359bc63a6667f3cedee74092542086eb08e52652f483c6b01dc2a0935dd78222e2d1332ff4560f36af121e38b9362fa30c2f1867d87afb74f36b61ced67070184e97ae44b1396255274a39df95fc485b5454d44f1856311bee97b12dc0376f95992f6dc6674601f721e59df2aee1b179f666525e087bafa5a7b443d012a02b85606b845d68c92b0f4a30a93dee084852c5f59309081dc633630db603dd451d27138cae651182c07275da9446a8bad3e627b00bd1ca46305e821761018953333dd5ae6829aff136d030d1d16bfd852bf02cdc6a519b938de4f19892463129433592d363db6c87d7043f30043ab368963e363fdf85808acbef2be0356c122da5c6f655a14dd96d531acef1f4701c274d28fc83344d4b3f72e04a7e5177f5dc91efb01fe469aa063e534dcd72d09b8531316019347c958e7182d38ef3f3ca09e6e5ec6e86ae9f5eba36068090d4e4581d996792661ce55c75e61dd26b33c5fba310fd6bb9fd3583fd1848e2195b3a3f46c29a0ba229b14065a1c6fd3ff392665664b82d8ae1c79b7f1146ba3d348af365b9ac9847a2658ee5a8f905e194bc7a2ffc5a1d0bd0b8bd8b98c4186cf5079d52d22d4e43ff5802a985b5502d0ea87b72955e7064ead70080a46726336644f52e1e21aabc1e378e3f46745c6b3df422af7b0289d2a75422a75c953eaed4e09f1f3dde2c3a550e6a47ad4fd56bcc175f2e08320409b3f4d55c4bf9347891edc5085941252564d10a645a93f6510ddcb70a68fd36ed0f0472bf0560f54f9746863bbf29f6e95d19d5af3217a875786b53fdbafd3548c33da3d69f87f256578169d8395e456e201ae725c2d787782298cd0aa92bda4ccb646d562e18eda8252b3f8f984510cff2ab85299d6de7afe25b27992388cf9ea290a0051a95666a2bf42be7e0aeabc6e58025c710a31ff00d6aec61c753d17872c4a9804f61676beeabd3951bbd39c0e4017cfb9b28a7341ca95380c39856c5f1c02f9926cadda222a3cd70a1ea5bb549191a55d1cfb076a436db3865c051c8216fcac021a1afd132511102a7e36bf710c5bb7825f3e825ef087f9fa264cbe78cbbecd811bb7f0606df9378f75ac08752c7c69a54f1be22b730a3b3bd57154c0467ddaba16ea902cafd5bc0fd892c7985ff4d817075cfb82d5b3c974f577f177513f8ad88ab31d72eea88cdb485509329d885cd52f34187c387c3471ef737c37e1d300120aa2e3aed532ed3e28749ef0a746a67d8be9f88c2d496d8317b2a3958594c085a07fb94f7c86ba3144f323ac5c49e171c198051e047d81af7dce0a72e62cfef68e23cee5753017007d007c32ebe7ccd531da9a08e76b6579a9635dde76fa4e712029847a9fefe2b679f70c77af852cbd412903d270648e2ef37ffb010e5654f1c5e8986a58816bfdf87ac98a6a4debe868e4850ab32e1c8080683486dd4dbd94921618fe5ce2db92e336578a3fa0a0ebe0e4fddc927a8935862ebdaea34961cc372f9332268f07c9c78d095d74d2b3954546708d62ad3650a28f164706db8dd03e97ee0ddb3f2f8d3de5d922161189478aa5787de2c5e89d75cdb683d01fe597f0b4276a1303a3b88d6e6e06a0f7501223b889d4e9cffb966ec61ee3e0aad3bdcd5c652388a3b48b7e4e65ab6c1eb041842d5d8451ac684461d53aca0a2eddd997edd067ad64af2ca4d24b1c78b31940b144af40c80a840cdde8df1e1a85c2712261f91914fe0d1163c5f64fe2e055214c916780afd032da9c1c871412bdcebf1626315902818ddcfd2e02afe61aab173e4926aef6c1a3cc7f066176dcd3dc7947ffbcea5a34170dc7f9cbf638e64755abed36bd850641948e67c86b4ce423bddd52ac5caef29cf53acbbb042f778109a60f4c6e3544b25012646b7f16c288220e4e511cb4588de14a129ab726b6b1f9937e6d08e2a29f2a5448c296be47f84d5180b0a3d8ab0926fcac8f2d69ce7d6e3289cc6a7c10eced1094d80cc99110c41a7814e0b77b98a6a25d3d39ce78d5dd94e120fd6da8567e63d5a1b36efc5ed0344ca5a117ae481a77daa17c1ee669b890db8f88fff691ae8e79933a371f0170311ca58ef45ce41a14d73cb6ff9ec2007e6a361455f8b04c4aeae3cb3ce715873c5e7da01d0a8d0e5bfc52810d467fe72634c41575bf99ede85572722af2471f9a8976a44ee181fa125f279f332072d17ab1702807c5040cd7e48d52e7d0d8530d9d22c4fb3dc5fc2a009d264e1707e4b9ebea6b25a093777a87a8343e8632f12fa876c34f2d5a65f112daedff48a6e498f0f1f98ddaae1edc1fcc2916aa99bc735f4b4fb8167c126e352d10f735e3c474d5b3d5b665bc5f970db95599a857684e60a0768991869d24ad30742058457aefe9d8fa16a02a9345b2a4c7e71114175f435494c26d4b81dd0bbace2ef02df6291da55bb48d0bbadd6178774ea996dd1cce8bb760b74d1fdf2a026dea141cc0ae6e149b004c2220200a24bef657f4bfbd192c6ebcb9a0894929beb686bf56ffce86d256c6a8445e94e16bdb753a044d380c7b8a5627c2e56a1b56bc010d9cbf0d401bc5cc734248752e92ac4a4ccdeb89095909716ee34b3575e2422223b7e33a958eb1ea4d518260dad9ed5a00aa6dc8729e773dca9e293241ebd2af7f7781668fa326df1691675a9907971aa6a65ab90b593c551ddf4a048e86486bcd34530ffba1ec91363540a719ffa6ff52b82faef243c9d73f123a8c33ef1f5069d572eaab40a61f9d8eb89f29eab624fa46ec79f46009d3a900ef90a60fa968abece8bc06f0110586aa08ff812f9c35d5232cdeba3d40404a9681d971372ae78ed7bf96fdc6bc325b17602c4d54b126831ece0bbd11342152f6e701166ff6cd8dcc1601baaf7330770beb15507519321cd7859c1dc0a6a1c03b4efb7f658a4d2de06be51ec8bdf13571adc5d5db5e00bae39a0ae77a00647a921d7052e4d379625684630ffb4e88d44199e471a9b84870927d306a012119709567bacd98b0ddbd4bba6edc7d1e8af3bc0be67c069f04a7a319df693bf6cd61b5197a2056e8e6790778f76dea5b1c3fd60767194a730d55ebe4598e3c13584acc9760bd04c3f6157853065d2d748644684e612612196ac3278ce1956f9b1b5859bbd712c5a0e058ea55c0c909a4992c361e1674c23bc9755165a746b96409fabce1a9140a26aad9f7849bd39983e8f90d4146dd7c0c9c256bf75cdb732c4c43cd167e1ea647b15f1f7339fab162f0c48a7ec908be443c45a5368056c382192c89a2c2a1d606848fe2bf3ad8c8bbc4d931246411dbfde320401e75403373908e565c594fe8103daec888aac5f2d798d4adbe01400c60dd2d65834698555f6313b9ac1e4912ab7a874c1dfe12ba253899a4766f195d463f2e8f5806da32b2e5b84a513507aaffbc33de193ebe80c4020720de0c28c5c637d7d4dbc482f1857730788569c3b49c454687b06c13e2b848867b4489f169cba53250e8779230a89e5c53a8436794ad4facb5c4d86fe429652f40a537adb568d836c70f1d5ac746d1a69a9451254c5791c4f349a2bfe0d05ec85ce0350055f44caba07598e0aab0d77f0b72abadb57a55590249664c0df47f85602004ab511f82cacf6e75471f59043b4b5668f5dbbb3936485aa6017a2fbf343408d6ee7e7c5455209632831d196d7e206b5809fa4be494eb27b604b36ae89e86bbdedd0c08a3f5165d8d979329a3473b031d679e75ccbbe8478cecb581e4587e21ee7a572208e34062ae18175f66dd41962a116c2f54ad66ae3cf4335a58fb6096f9e23f5fc8b52dfde9df00e5c9dc88adefe0aa931c70f437cca04b23cd43d1d08f59671ea35c2e925ee2ad97271d1a5eae16f0e19dfcef267e27e6eeb3f01f7a6922981f636a6c65031f3d82ea5243ec13255f994686383a1349b5581b1d23100e394413a10a31678f4d676fcbdcfb8aa662f24190c1e3a0fdd59060b142cf23fdffbbbd33bd83ba728c54feb387097616a28fb23bca745d34bf267e9b6558c0b5f6bdffc5c47729f336be47a39277106476c488e3137a7eea621b3822e4c4d8d2997132b81ad4cdba1ade9ba8e0e27fa3c4fac1cb779b19259b280817f9f25346b3c958ba4cee174e7d52ba8ee2ced640c6da76bbe09c42469472b305ed0899ed3997b320cfc9dc27ca1a09917ae548702478ee061ca928892d5c5f27c677267715c8d782811cedd0a13d052ffa16fad3f31cdcc9fa3fd5f570fd0e138c7d4c6d13e12f2c98f9e8b1c3a52535fe68811311d48a259f24167fa671a525e550f744ff020e50de9974ded874dc180e9c9bc9848811620e244c9365ad02b4265f6e0d41cc120a43361fce3a59c7a81799beefda5c7339c70c275102d35f299c1323348377af50835cf954393a5f1c2bd05870f50cbefb97fd3f8a8470e134dbc94a02e2ab27cb23c5de73c4833f80fd73cbd171ec8eb6c5ff9ca82e9723a286448e6b39bb38e520865ba86b2c1a89a7938b55de232df65f6687368835eae796501d62764ce6e84a6c4b9f870aca9163de8c499adac0ce29f42e4e674cc6881d95ca7ae0360c30f18d0408bf2e54b55faebf81c24d3d562906ae255531a6f0682f7a660ab1bb6d18de7932b6c75e11cd6e5e93255726537193b665f2f4e177f0c97eed4f395f98b4cceeefb02701738543f947f62fb532a262528fa14d78755a39830f393cce73811335b59ee4d77710cffe0e74e823e25412e4c3596faedbaa1077d9cbca63dff9131feb92f1cead62a19e87b2e7c4e19295e56f1183285b6241b7e6ffc14c43c499c0931a15ccf207475743e0982073b51b5fcc7f207c1052df5c24a079b7bc6afed482ec0766024603a371d76c79ad5ac2579ee40c194b1d9370115edefa60a30578bf65c6f77190de591327c4813d61d8ddccd6a49821706cf703548fc1c134f66a78758f948724b39bbc4da1ea3622247160dfc05029217c36f7ac9765a454486820030c2a4272f237063058a135480e0fdf2afd8ce146a228537dbb032b0a172246350ed80820271104afabff28c02ef907e6cf9cbd21ee40fce7dcddf47b0723e387682c4ab2e39ab2f3a2dc1afbdc24153f2900604c37a9c8556b5e5a23ee99630bb66b26bf535f399ac98cd8db6dec3543837","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
