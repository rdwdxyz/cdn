<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c3fa089a88d6662dc1bbb24dd8a050b608b0d26e241e25c396c3910457f186aea341c928e3aa238c5b867812019e14ef498df0af7249e43abb8722f80fc941fd3f8ef1a7cbe77d9931e1eb8ee8b44f5b99b98139c21e0cf0ff8349a369153e159176d125a55bfeb136a1555b1a0a5b0a7a2fcb2d7e85f5057e1f5be958f1c7ad1a11e5a6820f6c9376465c4c67de5659fe8efd227cd6fd9172a978334a2fcca75a2ba08ac6a2b3c63a4cd65e89baaa70206fbdae89024fc63deb5655cf764adaa25729db7bed5f245e5571894a184c6d974a188669cd757319c319ad8dcf434a861c8d128a35f3dd81ba63c74b02027b4f448ec2fc5c7a1dcd721873f7ac4ed7383d10f904244e1bdcf6343dd11bc6be6063e67bb5074576496c0eb999d98cbfbaf5a3d3ad7c8e727aa8b20b211e602cbbd0c904b292f4ffa044dd8175eba27918ef3e9048c963bd91ed11ca4176508ad5821646f381a0d823fe4b33731840eee94f0dd145a18dfe4afd1ae2c27f77008224a505fc752e14c0fdd64a6357cc99fd888f8054e95aa23bcc1f8f7fdaab214813f8799b8a12934964f4fdc25f10faf40fa3e961e0c0a83299dad20c7841c1cdf2cc120a4c32593897842bc0459395f63b4a2c825b3145e9415ff9fa7ae9581979cb835c24fd04886d90b2d59207dee53cc95dd6ced3063d6403b4c9881e33c0b5639b9908878fb63ebb372b39bc3b4d88e072e2fe5b81e7bfd270add6499c6c81e193a9fb28e628dea89620d1cb2742d640cd0f757924cdecebc3bf9f41c80b87c4bba20b44105d4ecd299a48b5a3ca9b68953876a2ffefe32f60a8bf6dca8e08f0c85109c587599d376651a7e717725822b36b9d7473fe4e8d18f1152248139b3759040c4d90a5c85574411899864270c4aa3f73d4e5d70abed780259d51fbb42ed235874fc004a717db480938f3d0f97329c7a84f4a54a47a760f6a8c16e109dd222c3d4c7a938455705f5ebc86c0f6122f5c32d570b3e2d30578c3b3c7b11ed3cff296de9e0543e0937bc3ada3101b36be3ddb3e7a00da852c999255c13e4d06aedc4cfa441af6317a3bde5ec58c369a8943c2976d34f7b1955807dbdc347253425501773ceaa58a9a82b0bb4e1114707c4fb3b760d67992ad9cd6748637a8ef079b6f9a4d9ee2758fadd2dacfb6a2eeed2a3cd823a165b12a79c0623d447f1e92bf8b0154659984d70a8166fa8c7021013b78d25f9f0da259fef38e1ef1645d4e2a64af4e78003ecf1f351494ac74b8bade7e623ec76d9b3fa1f816c730296d7a1444e6ea5424e8c9b8062fdd98e5b83aa1660139b86be607fa86adfe3116a907a3bad8026192a49b14d9c08dade715c03b5f76d69b9570b17f58dcce37fa2b4d2bd573e72bd90ae69a94e2be18145cdb513365df7d3cd668cc3a77eb3ce802f1494fa65ff38de50acce83ea7addca92123f1d7a82f338b3650eda391e12ac4cbbabe148e026af8b30b9c08c24b204aa1025b2515cea4fa72f3babe5642b2852d17b2adebd21ba489bad87639d3c60eb2149ee7c002c3af6ea85074f828283004edfe5800dbff384161ad719702e0f98309c6669ccea9158eba71fc161acebde55f1dcdbaa6d5b860ca09dbb1f456785f8a9d7e305086cca4e46f60e0d9fda81a52b40c984909554d8b3c50d7e68c4b1ce170a452c2c390f83c781c1ec1edcd75e844936d164dc4b0a717e2c9819c5771102fdb0c8393a45d8de2595d6091a07523e0a1702c4c7d82d67a17e20a16236ba3af9cd9599e422c5937e71124bf910f6fdc1dcb4805eaed93b3219c6fb5f5804c4cc5b1f3c4b600d1287a8f7f56c8ba183c3747f1b1efdccb0f182bf5218ae32cbd8f3ad715846cb305884b647dcbf474e81ecf7af332e08702e7586946cf1726216155c1d1b2bea4c212b276779df48a5f1f397dbf662b3274138da0c60527a8e3c8c51dd787692558d26c96e33f27241cb9d9b5d7491dcc4ccad393a270b2b36d1c38bfcf4f0bb0f138d470b9adf4a9da7dafbc645f6079722a19d699912bc868226cd2d337246810bbab3af5703755973ee08a3cb0e0a621c81be2cf73e2824c0d07986056a0716548cd24c674eeb6fe19d1d73e3fdfc915e505ee76baa32490f6807044a691cfb9b488724226a161e6766a209249278bbae4f87746a6725e5417208e08783b9955613cdf8f266d29002900b3fbf0ee6b7a7c28baadba62b7415763d95a9e25efb4da025b833cce8e895ee505c1db89d5135f1d0a9c0154741ae15fc81e4783027953c7aa68f68e9a7a3626d1fcb19d8cd917bc3448d575e15d232432fa8f5cb9702bdb2e15fc712e800efb3e5ebfe5652b5989c45d7d50a57ba780c3f2aa6b051c65a289b7a7ba51dc9103db375a7bb0702e7596c59058fb8be1edfc2a04df478bd1a966cf368acfef1ff618eef979c9c16bdd03abd7e105d5dd2fbf281ad32504a4333f29a5e3965e4035dacadbc03b30dd7c503e812e538e4e71f69fa6dbd7340fef87b20b0e19f506a8833d2098dce132e9f2e6bca4f848d899dd939af740471662f678fea8d3d712dc68b9af300b0112f89bd3d878af6cf46b665153237df1d675876f98a55635b0ef2851bad2541b06824287a4a9ace4ab414b8385cb25361aa868acc3d0bd929cc36a1beccefb50600b29e0bd01fb8c28995b16bcb90f7d0077983f635c4f711fe702ba064eb529aefe60b96f3e446be5217d3814a8083ff0f545fcdcc9df135274f9ba000d5a5d3627f663a10652152ee2b28bf76e086baf5d54f77d997567c9c434fdca84d8542f847ab8c1ca56796bcdecb15e740ffa3347d9d889be4fcef595ddd2d483268473fbf9c320d72696b741d50cfa96592c817bea634778ec039ad8fa258db58e1a407824d6a3015f8c990926b1d8ab15eb27481c1fd18720d9bf2ebcc8b1aca8f7c775860d9b7ef8da043bd020e8ba042120652fb1497195eb2f946b0f0bb221bfd33800463623ed29ee039260a60339f57b83d848ad3accff5d3c2c9a27e39b2e6a17b94435ebb1a16d3ce78b62ebff135d6702d95ae062ca5aa8ab610e614a505cce15c462b4edde1cdb778724187647d42ac6d2e9ff396e2f18285b28e15dc77bc64f78d8ac07af3befc79eb52158287a557c05e2190fd3f60c2ef621811452adb11f61c2d2cd982275d4567c5480de01f34e03ae6cd488d2628e7553f478ee136af1f7687d1a6ba1f78b07b88afde92883a6aa0dd9e65cd4c6376cecae3251405a4c23755ef03c3a2d056001ae54f0229570a034c87e210b449d6fc159bbbb28fad02bb7da17b2b187fb2e603bc3bc19abe464734a0756c15f2ee4709a4e0db90a385533e44ca9a16414d72120c78df16c64bfce6a946c95aea233da77116edecd29bc5761e2336a2f812a67fed8dd34d4a37f47b99940d08a301ed3d981929db0df5214f6934c1b1805e5d0ca140bc27a8c3b07ba5a48700f07d275405813cb849d9eda0973da9f04b724993d536ea11dd7227c3bf95847629174ac7ca7b17a6cd80481147623eba14d962020b0d8372acc0d27cb2d4d48768c0686bcd9add8ef63df134156c0b2d8aea66af19af71a5fb83b9054ed29066b5e4eeee1b7c3f931922763a0b0f484fb13eb5080a62513888cc547a02a5da54c706608e581e6a414d13dfd1449010b2af9fa6975428292c414b17c4cca57ff446f4dfaa8681ef69df257ada23bf229ddd7b38ba7fd8206ec0e0545cc7b0f49da31bb5a5c278c97281c0d0c93b948efe9db67d5d6ca74a18653700e863163f0dcb4ef14d6116594c9abdb6a6e5783d5c8095f7cc5c2ebc7c1a072d6135c8d98dea93001b00b217b93962a33c73a4398f514480afc8d446b7c10355e3c6955d95a5a5111aad7986595d6dcc4b91d8135b1a93a1447094ba7026a94b3bf5180f81050545b15b6383ff13502cb6e8a33f297e130b315482fccc6a9bf0f4e2c590554da1aee041d81d4358e7cd86590b3e8be9fda6b06c7dba69b04e9e98c0b0a8dc0f28ef32da468cdccddcbf1cd693b162ca88975eb753cfd6e3fb276ce4d1d86cbf0dcf7f8ddc04295af757cd313886b2b70fe6a2996454aee8f0785701e0f23d6a8fc938b8407e9b066b259861e184ed9ab81ca2294c0abe6507ffa298c4328d697236de2c16932ed5a3952e878efc03a51e474720e77ff6084a130634e70bb9408fb77783cffb1c62090516c3e6c2cd7784819695eb62fc9e3805b8b909ddae57b5f7bdb44b54cd1d26a5df3a6e666c26592c2c92aa3c491683ac249240cd09e1b7bd03d6b1740a9ad6c862eb74dd60f9d563e37234b5b1a6f6c6c446052c1e24a4d59fbab52843311d5a037406bef95450fb01ee17d7c9360012061062d6aa8a12943f8dd43788467efdcef8e3dde963c7896105a53feb4a3e3fe90fcbeef93155ac6007480b6268f468bca911096ae0549d1da8ff99221f69aaf9b435ea9aad58fce6d4f26cf21075efa8c7046259b11e2a12a542460cebd078b66e7fd7f58b692831b861e4d7a273161f5b507015ddbc55ac2781a2ecf378b6a312b91876622b797099e8a4b6b218721c56429956fecaa6d23c15fe5bc5724ce34315045870a5dede79cd5fda390d347dc644e5230b3587863bcc9fdb997ce508f2496c06927738c694dda9f5f9a52e1974709211a071f5913b4b54f9f0951d73b978867c4e4ba59faafca9aee497685a684586360c9cbe4784ebe676e90cefcc2804d860791ba2b502acc6a8d1d094fe28f164b5b3d77ffad4d1cf11c3211059ca499677fd4b604b6ad43ca1e935fa67ea987e9241355ab4816180f0f23a18b7f2510591c239afeb893778e4d292e9579020d0e71b7ebbbc30558196a81ac301c489525c61c03ea1c0f1d72554ea306469891c0b07b668911145a34edf91f0fb6b4971587467f9aa436f28e2681bb2a9ee9c34f0a36b0f1e034b1997d3b26293e9c8d415a68e3eaaa417bc65efb21ddc39f0ed34a3c6b3accb91f7962ad9d802918c2390c4605272a7e5ea8dee73ee17c2ed0f5f8b7048d5db91ad0810ed9c90776bbf02a904895e572d8b1513d277897e40f4c204c18eb427817e895ba48d6311c1cc7b6cba81a16a96ababc0405b835e658b36428fd7a5c3fd6aecc889c5c94821cdac7cfab95dee6f9317beb66f0aafb788414e7babc465b2c54d6ee3af93fa9d64bc00428c3b0d637ea3c22138a1cb19c1b572e1c0cfcba8062a7b2bad0349a1ce465d8300fd645b3d2e3eaef686d5d20035eca9b8d1dc61d2d32417995d48bc705959855cc27849820ccc3ef1361b132f160a662157dd62ee602536bf89ec8bbdc6e96e07fd87227e3184c2ed9e0fb4bd0886c37559494bfe6c85cbbd657d723407a551eeed70336b8c921a1923ffe74f6c38f9c443e7571e9ffc41a5fd2d431bf773466f010a4cddbcb1d1456d3862d87aa672ceb8a5f4b9cb62071a7686f6c93f9aa5bf0e1fc3efe2bb40c388e8c4720e3a2210e3915dd1ab2a1e88b275d0293cc21d34f65f2fb196fc6a91bffa746a1f58c03d8ac52ed0edf680edab448f054684f5f35794d207f48e935fa70200374c9eefd36f66053b137ef2280ccdbb5ade46f7b847d3ede18bba73a8735b923c694b2cea24b175fded4bc683f05c5286f1dfcdf203fa6428f10292ffc96a0ff85bca054bb3f8b4b2bceff8f9ace2bd226083d51953ec6c42f814f2ce3b9703659bf3e25b8b9654825550670d1dec000bc9e1cfe79e697a79dc073d500c39ae6ab7d40a2523f1bdd10880f7a1434c63b7cc4c34770f703090088deb41eee39438f55b4c3e27b2b23abaa68cb31e018c7d62b538804880acad16211296fe111b346142f407213416e127553dcef9ea0999cc391790be540682cbcf2cad4cf116a6938fa0aaf41f3e78e9c762f42639fcfeda1c066a64dcf84162c9167c91450da146e44cdfe3c5cb0959dd88c6354e5a02b849da7dfa71747622184bbd27196771ca16afe4d46b6e28b390fe162cba250add73915e52478a0614231fde10ecdede4d4950618051fa082c0863e97d2fee3dcefb3e300130a0df405418df1de61f397bb0943560324a3d27cb32031102c3f6c08dad63ac4dce92f8ed8cee9844fc7b2cb32da79a1854f7b883bc401ffbc40077e3870ef3a76ffdee429e9ce1ef79bc8369af9a64b1b9c5edbf48a9ac2fcb7a1bfa1911407717c633e680f2c881b8047ece00ae6c81ab34ab20858d2e7800195377d03f181c8c14569b9bf486cbcb14785c57967c400ffa1cd96213f8806edb82dbd7355c09318ed5e02c8a0e5cda199fc7478830ca9b110e0deb58ac1d285efe8af6cae90fcc4aae66c5c18b5201d381a15f5bedc6a7928b9b3e64e5e013a8111e9419efec0a6aa95211e1f2156512d23670a2ecd55371f33b71f66e3067753c381de5e25b213177dd059f5f712ab8ad5c44bce2c230bc6898b06833cb8d95671ab811139a3fbf62f8cb84131757ae61e0546701d396436e1303405a5f291694254c0a4f870ec023f7e7182b880e47e41dc10ca896abd429dd72f52e695f7236d0cf886747298baf7ded7af5874e7811ea6e4f79722722a0ce88300d60d2340a2a2d0eb1116814809a978f43a5e0e31d36111357c9258db00be546ab89d25cb14c2c054e3352322a77beb4dc6c446a8c4b78ce3653ed9d7647d8b3cc924a0a8fe6a9384e0c7de524f28b10eca75e016409bbe0564e03f27f0167a3c284956272d30f996954d8926689380dd0e37d96d03387466beb6572310d1e1afa4ea41d4c19503812a5a12c595aeaa85f97a094052c7b38a1cf0f3c8736e3f8728154170bf210b12d075f46a252aaeb7978e77de5b375dcc8b7bc4c552837249aac7107b139f3b216a4f5089002ac52b8684487d0688914943e5ca04796f93025d0c940e4c9419bf279fa78fc532a904628c7f4bd36c22901c0d8d357bf9c10ab82f76afe4aa385ed7b8cc05eb040197cbb86328adf2437f74e864583fe323fc5b98eea2ee740eef8d724db7cc279a293a6d46d257e890e8854e01052b942033d0ac1cc43558b8e9c3d475e82cb6e336a9800f4946c3dc1a4749ff881036b9ecf0eb8f16fc56ff6e98fe035e4e41c1b0f34e3f3989830d6127a1cb6eaa5c2dd1f382d49197a285a2aae7c1083486f7fb66dace83dccc71f049307df9b3ce50c5d1d7beb708bc872b49a670d9c2c68c86bba605596e1731a9f901887e48cd11493cbfb8a128cd448149c3fff3e0fd484da0db8756b33f0759936611c14ea23f38d1b820ce267c67f2b742e3e5f251d4b58da5eb667373881b5263cd0cadfef9d015fd951e5566feab9ece5ce235781477e023d078f6cac6e37fa61dc642dff54c00cc8dde3af1ce81d80f4f42f7c9d94fa824bb747024fc2ee823c52cf03e53a3268bce9a0a965fc209f344489d40995074e0d250b2b7844be5845ab06c8fc2535b67857be31cf0d42bf0a7f7db6e996f741521aa35265180936aa99f7338c5dc5b3a0dcfce0c7088fe8d0aa44eac86748d5c17bfd7294cb987783baf3d4a54700101036dba6a979c1d70c31be19a9c5588b18d5e780e7839ceda27c13b2cc985d5038711fd986b229badb274438f6a2accb10f847d5530772ebcc3ed7466d8865e1abac6e551fc268c7bd8546e132a5fafebffe822326ff99299c7aed3c3169abe03b82d43cb2fd1b1325ac7a82c2d924923ae93b8200e5b2a20660144db42cc3eeba976f48577508df9cfcdcfbb00c4d3a0d5d0618ca8f300413f863d81a764f37950722e2a68e81ca4448b30a208d4881495b50229b666fdea4493676a9fe7c3a0f981402ea4ae087a89d8c2499d71026062db3b821650cbb258123de9603aeee18f8e717af06c2d584377a48abab6b6e175715fcef0cb11c6788226f51917d2ae82b08a0839c342017d0b88d96515b6abde581d6b18ba2fa6bfe54a124ba67542305bfd79d54c3a93632c423f9d636ef97d004ea39697043cf10aa36d8c9d3c72d6159eb4d0301a5cfbf4a23939a425d0613e8672990bd97b449d65117b8062ff7aaf3c5a738e2dd850bf3a4521a28604e9e2f45dafe8ddcfbc51a985b470139e143a7b385b48b57363a3d0847106d96bf4cc17b7aac6c5743a879a499f2cd1d1b34652507f3d547f3352c267acd54b2252225701d51986fa7f1707a748efc3c4cca4eac0eef7de1d67434e20c609c6f320973e9fee8e29594e738d66e634665cc03f6b549ad4d615ef7abd8c9e77ef9c293e570c6c6c64cf3f80655203e0eca276930de10c371058713bbb5b94b30927070d7528d75b42ab3697fc47d9c81831e948c766a8bfed28ecd66f6da89099b9e005cbea867ab8e237cc72f7d233cfc4c26a333a8ba35b150e1e1be8ad17a22f205f676d541849c47f0fc9ebdd1678dc1cf220fce84bcb842b9f08923ae33b589e3a51ceabdc9d81ce30a6cdda15d79deb3809395368883ac8b9cbef2cf5d7d01771c9a33b1a4f2c67f57c76bfe650aa8cdc0bf4ffc636b6a21cb22adc05a6536f03eacab2cd127424cc83a2057d9bafdfc0743fe4b9a88e53ad03af63dd94e24a27a558f417e76457c2a025778968947f51c4150107c423fb5cf1c9be7d3543d019f881eccc7b0bda981e2f15143d5393c96abfa48dc75c8a6e7cb8f39e5bcb6c4fa39cc9517c9476de632003ca0bcc58c4e4423a8f9ad5ceb9d3b1f0458340feff77269e7232b520d881c543636d5b77604136ba92fd035ffda6e70e6f1a459cef75d7423e18c37d7d5e6898265eb6949a6cfd837410dcf9c6d7b57d00feb49210e92c9f2a4fbaa3091a3edf2a2e9fd49d9aad746a09180ed8a12c5431b1d9cf09f1bf4dbf83863e94f94d019df007cb984e4f1ca98f3cf7a5c19d08c8a6e51ba11fac2f4936d81171ead817c6b52bbfb79e667b9ba0963d328ab34a11c51ac67c17f749cf5d418cb0092da43dc66b7ab859a2dd41294b6c503019cfe00ba8cab04c1de8b8c66f91f6c0ac13af63e4dbc19cd4031498ea4519f055a272a32da4faedbbd2beff8f20e18e7645bf8b0707fa64bdc200b17ab982337931f2f8503067ecccb4d53a79b3a21a030497bad1d0b190a6e13058cac98a3d59993f03d60e6880cace248031fc2df9393c1b9e57c3b6f1a32dc71664db7525efa348f0f527fb01782b8c45ccbf24dc9a4463889deea87ed05bf46f70010bdc3157f282b46654d1bfd64e235a8688209742cc0dcecdf7110edd3a6b744f1221e5d9dd0508caf66fb9bf2cb4ce94b2aed16b122451cce76d8d72534622cb0b3773a31aed25f9beea76ce7dab9dd8bc1b43cd24232383c40ff5842cce02db24b50a2d37d35456eb40fa2669bbbf1ea6c492dd4c9181c5433831a773d449284dc9bf2d520529a052eea0cd68bbd9a1adee8142c5dd90d36340b3dd340235222d11c7c6bc70304cf609856ea6a704464aa11d6367ef46f7143c3b8c1580d560c331665feb7941280c5ae5f8c74dfb54395e200caf793580ba895ce837e9ea913965a0f23d164348552ef5ab45a3a2d364f18a10bacd712f6ece03b82b994f4d683ed84f8ddbb9f48628deb4cac48bc94c41d2ea5f35f0274e42667de67aa254a0631a70f3a05701d233641edb6d639dbaab32020f93320a4590fded18882d707ffefaec08efdf7125444e71c1f41556b305410e9a5f45964cab7c345a11f6c2e401a0eb9ddc7faedc5e00924fb66b5f0fdefafca5cae1b90f0c554cc90caff9d73535d6b6bcce4203c787ba5bdd43a25ebbc1046d37a6bcb8cf5c4fdf88bc3d7d49ad4092a8ab1e781b76767d46f6e12755924adc362dcfa8150a02c263dc90cfb2682aa17f4107c3c59d1362eb186ff8855f47f6aa84326001363d22588963fb69dfc4da38b2433e4d4c9521df071766d91a4c1e885abffeea942900f44f75a146b955df1e8200a8bd4c444c887bb8fef383955b89c0535a0fd8dee212d227da71eccd92b075f3c3f9e046ba195151d1fbd3e2215b02107a5cf7372c1478c177d0aca18daea527cd8f77003b3ab2243fac2bff4ec9a4f074081ac15512a37bf0c6b16d55fd61900765fb4dff7ce8d6fa1f372ac736f74e254b844afffce988cbcc01c9db33ec71040056be3e2fda3d9860f8019aa234cf21ca1ff21b8a1c83be7eab7c449751db3e9ac66e3552187903942bb61c3fc679a6c9ede2a848c2c0839315b8f9d358be134341f0f5530929d83dfdcbcfe20f003b9d52dd4cf2016621b8b93bc3a8f456f5d770fe22f3451808c7b31ca819da825228e4609324554cdb7033ceabb81582d2187e5b2bd69f2bcb917246b67213df698fb35369f7c858e43ad0aefb29fbc22a597a726163f053c2476f1752c56018dcbbb5141432e524742b07af044b2d8e486c6e2e293bde6542ed0eeacb1b12a3191f923010a00091a5128a27359340fc33db55aeaa3070017d215de218b50a187d7aea806fcd3228de311dc16b63442b8253bf5310f4ac33bd48d4c466d72137f9d68980bb5823a3df5ec7e95eab9693c37e787fee31af0a5628da7d7e765e010ac75abe4ab4ca040ba308657c14345da8624c1119b0d0aba39630f9e9fffd169cccb0c43ceab0ebf2dc6670ebc4e69a790f351992fd84c883ca883760d2e576bbaae0d3e62eb763755f7975b7f71f7787a92a3deed230050256041b10c50dcd249b40ac4c2761214e72c9d73281e76ac72722964a21e737ce51581b5d5aba4b8a5a14deaddf4b23eb56ce0846fe99bbf8ccda0a79a88bdb5cae03a0fcd39892229df38be2bedbbc2f2ec91e72fb8f72825eba2e947ff540eb9c60cb1c1b48468545d38dbcd0088ba10b996dcc00ab22d8fc2f6225d4c0875f01298333300ebfe7e4a68e88f5358ce10a1702b55cd63cf9af1d380baf3f1cc5228ea4e74a0044fc6c8c8564ca34b307d9ace4cbe98358977e3ff6789857a48216ff2b4af9ae9042165383d09b433119209284e4495107018821879e330e8ffaa20ed997f81a730b5147c95f81b02bb03a02310b58a86ac61d8478f43c4cc5007e83f6474faf24cc3cbb97efcb6891108421375604a795478650961dfc1738c2f6646325e646bb40a708589169da393441adca9e90c55a14e73321754e478931bee2a62d0b1a778473077be29eedca33d270fa854f4489c08adf45a8f2ce137e5ce3f9e2774b360fa440d5ba091bf86736be450e68c77495c7596325d5a131304981463b5c1bc11d795ac448e9832c89394c09b6a88976f523d04f1ce00dc708f9451b3fdcbdefea3e028a8629cbc58f9e7ff6a2f516ad24f7a46e4396679ebeae1e57e043ed75d24bd00777a813c70ae3abb7c481a2772282c6f34570424ae328d02bfa9e5082fb0b76d571bfd3874e3c61e8e09e44a41aab13e520ad1087fe35ada58759d2047659bf262e2cfa4265cb99a18bfa5999316223b12b885934e927f5cc2d3d93ef87e75948c29f7fdae2e43fa0d66664e64c251c622adf1eead8366fc2080162cd0523e5a27bf076792c7d8704834e3478238470640e7a68c22c8a7c51016e6b542f62a701cb94fe6bda281b05b23158a4b16de2445e868571b823815fa5c7e42364fe81dcd48d055b4105c444d47370cc40344650af33c4240ec413adc814b885732b25e29ade055c8f3a1afde35ff063dbfde95213d56c3a1aabfb3fb4877ee4904a34911a541a3928053a7309bc0137fac41bea20623750a5affb74bbc83c21f3949dd3095173e7092d5f5811276492e1352662832ed3d16224ccf3d7e5f992673d6412230103f83ee9a16c83bc87eb758498003765c7f61ae7c398b94cdf431825b96f381225dfcb082c09f3fc1c693684b86479c1d2e6f5fc7f2a081826114eecce108b19b8a0507d20def21295dd5d98546d87c0460e073c5c389d182b07c726765cf16520396c7df4cc46ef7fcf288d974503be6ccce453cbf30f7f8993995098afcc56f4a626152962e6e05aa9e5a9c82eca9dbc19c3b75b5c403157ac56ff609486c13f4d36715c1b06f87bf106e7883d40f393ef2396fb8a7ba53d1366d12f279df35ef2d27492e64f7996c417959a56e8eb20a1963ab11d270ab09419ce2b07ecadbbeb60089921df07f0bcbba6259cde9a8592fc8dd9abc769090ae0acccf6fbfd75a40e0a7ea228291db0c23d160b0e8f157686ce373071362ab898a9db04dcb677ed29d5f2f4978bd47d41aa8f0147f96f72633075b4d586dbd4841b09c6b796aefe8168b419416d2006a9d1571ded5e4090efd10e99276f7966637c654cb0253554722f025a733befa6224cb35891f5bede97dd0ed48ae4edb92f05f8a39d1641559585ba1042fecbe59e260e7ab5dd15ead3dc138c96fe04bc4c7f5374784f3e0ee5e9744586bde8293d7d1e1414afd99119fbdac47200f7299c965520682d1e64861e587ec9f1dc2c286816742042112ccc954e74ee867dcb4b685910ada1a512cfa60b33b0ee9a7eb81adaedf751180d54766b76cc07ca0ac3b80c400fc2647023774cfb0f96f286600468a42f643711453400ad0ccab0d4a0dbd25fdaed3325612007e0ad0478cfc174d96b7f2fefbe02c2006fa6709150296da8a98a0889a66e7cd8d6f5e50e99498bc6a141b150496f10d3059be38d0ae20fd19d7b14aba5709c0b76ec23d1fad160954e18ed09e19114c016481caaeb704439890cae1db2ea02a8a7f1bdf918718671fd41ebb3aea1fe7f91dd820f77ae54c708e8b402fc6f695511c0a4284c883cec50fba59a69857374ea478ec0ca9201f620493530220482e3e434768f4a23953cf955d72b2296a93066c55c556bf158587add8905ad2ba56c13c0a7691071222b15aabae095de573376c42ebe7be99771c6a0d407b42ea62e036a19144ff17c2be11d1d50305c124049e0f1433dacbf477ed4dc371cb793ba4236232fd61db85c100b3b2d7e02a1eba9d0618601370b4d76d99ab4f90d59c190c546dc88f0d03bf27eb1ea8796958c27d3345df271e18c0381b0eab5f6c0539774c676627119a13f15b43a6df5f2f671678cebfa77b76f9442aceb9065ff8f9decd9e74b55864e225286a2c4eba544a91fc5a2b78bfa2db02c8857eaae579cb97af69d4ea0646f90c4fe333b29fdea00b938e9eaeee247e55ba3bebc1588bdb003b0f76351d5cc3ea196283ed0fd188a7cf09c968eedd7b3de4fc34bb503d58c94eb336c364eeda34fff5b6a17b2452b5d762d77c1aaa867d360956f23af947307cf99ed8eb55b28765650fdad80770a9fb7ff7486f3fcfe74c29342faec1cd6602e9491b0997cb2c90201c4b2731797934d5a65bb7042cc2363392c9ab70f8ea810c042dfaabd51eac916f20d3f037928757c90227c4ac6d0f0b2c996e77f950987d4d32434949b2775bba77d278e155ff1dc73668df55b339f0efd61f3b58dc569d3b726aaa34d3f3ceb6dec4dd6488c0370251ef6158f82f0dbf9b1fc6b2b32b61fc0ff94289752823ec92ab965f3c8b4ba41cad9eec5800f95374ec3b51b97c3be92739517d6a6cbb240f0352e12f130d2660366a800bcf07045810ffa4736a414e259165ca95ac2692ea4c450c648207dff4dc7b54d3d411221179ce23563106f5609152167fa8c8901d27ca83dbea8ee145be251186490bbf583e7b8e11c9a49920fd497b9ae7c1cdbbcb71dc40f93a879951e874cec76777dc03197e383ed7bc5549d868633ebcf4df46897de4703ceca4352c5f91e121d9ce0efa3085ce0aa58cba824b2de6a6180675d4f8afb94c06948eafbc2cc5a28c2be400b1e9416758dd60c689635de187d3e6c72b9c20ccecb0cc66a772535de07c67b82649c971aea7d97bc7723798942ab48c74cca866c64b5e076ffb97241f6a48dd57e3778d9d83de75cfe8c895e28e8003eb5ad4881a54824ace36a9ab6b92f0fd0d5c602908630f5c1f3cc9f856f615d8e9dbfe09fe24427fd4c683cfc629f7c657a1709e3db8790845c0426e1b00f3c339559904af00d3ccda5e2960d96685f146f3a6c04b6e0746793d56353a8ec9238ec14af8ca6aac47bb46faf9f30e446e985bb873e2bbfb34563060f24250cf5c189653509dd2ccdb43ef34a8188938142d938aac3d505d069bcdbc2927d207b3f3a743c8c06383668787000718a51dddcd198aa47c71278c0c74994988d57f69731d7e5560a22026e675e20109e87b54851b289cbe26cf66ce51b8cd579b138f839e9a756f176de9505a3fb21baef2392f051d4a116720bd808e6e040fe64165e606420ea90d0465d9f980082766609cdaf4255331b71145da14f9fa0eb5e07eb1088997178ba5c46125be0b3c739acfb4c51b2b98c991278af8c1234046bf1da19663e1058e8c74280528caed539de7d1e56c0222f69e3bc20f81f7e94fddde0d79146c66d752f9fb3eed25afddf687178f6d8a2045c9af76c559678d6a98c307e87fa3f03134d5a19ab33e4d6c5eec230fcf8b05fb8f69c7b88e355767b92e1bc38c57ec80e4a27430e9cfdaa3222d2ca129b0f2e239256ea23e9a229d197045ac729730a756237ddc0092efc3aa3d3d9340563e368d7b4e33ab155376b23571f14185dc595e819cb3bf0eb853ab2133807c62293c7ebaccbc1a940fa660315b98c32dfbe061f03f6ca7626bd5e8c9ee2cbafdc3a0d75f77978ced2ea995f21995191e5634f5ae94130a1c7bbe2909e508dcd9ef3eafe25d93d8aec57a81e04b806044b01acfd81aa591e1df03591641dac4bf881a958e593a0be09141b38caeeaea8f46209d12c6e8b3bfd0adf9ff260d0f9be6e56467596e8f5fee4fb8dd3f7e7a6ba53755b6bb071de64d28315e6262927b018e8585d755eda585d2a9fe518547def7a9612a227a239bff8762e7fc2502cbffb42e2ed32d39164bb31440684e18e6192fd585681c59bec91cb9ebd9b55d8f0c20e5807d63fd62866f47e284215f53ead063e772f9e05f4e67918cfaf55a775e58df8c9f7459d8700a3552b3ea94bb536d922fff6b01a034f67faaff711d358ef385fcc9b3108996f77c8518ff1a68d95c324c98ae8ebf9751cef8aad15621b4ab69563d407922c28f0fed57058775f1bf28523bd42be749264e2b56c40bdbbb281dc256d5470360fe04746b66a23ccdc34f6f33038f01577a928bb6a6ad7de07a6d8c8e02ead5322837f34e910a022fa6f08f6ac9c9c216001c7be369003e2c65ccff322986e30ee2cc9e1b4062965fa8dd883318b415ad9bda7c6f59aa18a36ec75d0b90496df0621ac2b064d57dfee4c01c52a6fffea2b1205987c2a240197932fa6be46c1ee7e0c86d0ea8ad47531e36cd302336826a71a98a0f00bdbfee0d69c211af0d346ad998ab024ce976655dce328e9c9059a10a198eb9faa52c2d705f6e0a9c59119f770ce2fcfb94fe34f00ffddf989f32f3661a97f046abd12e4e0c86d159db4c9e9197062f5c6ba6dfed817ace5991a37b88c31308968e1e693a03215934dbd02b10e7e01af9d311fa83530d16cb6d007f364c839a4a410a0257b46b6bb1ec7d9cd31b51725a5317b44bd8b2bc453a53258ea782d6b979a6305063c0492380a4ac2cc95f41af7e3e8db1dea18abb1e8a841a7ca6e09e4584c634288f1385577fd5693207037642fc11b0c0db2a9d41515ec68db722acb85da7d682fd3564b5d946a65542ba90c95f27c286c210d07bab66b71bd7a977548280bda38b614a278b52dbcda499edcba8eaefb6adfc47aa79c194876151a00522381733a89e400059afa4b0793b2981e5c57be324562d4a766e3c395795ac08afa05b79f976c536f9bd7e3439410860871695ec4d61de3b6191b48d07974e975e113f538a63379befb101e1e1a2141cd2713a6a429bccb9f7f0c40ab7ecb7eccac92bc620bb432dcdb6e07738859fd9ed30e594212e98aa440642643e5789c0f4c5dd2f4716e6982b466e7518327928016bb46a09e6a2c60d98695b5c3e9ca7a8f899376f67a70d55614bc38263f5404401e6432dffd6dfdc7f0a3339f6278944ecc63a7d4c1eb7fa3eff2c2d176aaa5b88a3c14807a9b38b4aaa3a5c123e6831a5d7bc8f7b0021525754dea07eb4982b508b46eec2771ca20e57688392fc676e9c5be0ecc8250b446914fb56a61c75023e5e8cd8880f38e38675347c6993d2ca6ef23daf46acc77115699c9f5b7959e4d922cb69a6021a4457b1f2ed9800838c66d69a67b6ad225ad71feb9953c2364b6ed0f24844163c36c77045d41ee193cc5b61bc7dd94fa0a6fc3cae60f44d60152dcf28514a15f0bb8ec1037a0f3ec4adda94794d52dbbc56b9bed2ec3c710a08d163926fc1d99580ad3d0f3d527c9bc05af905ed0c832a123087aeb9467293ac28ad8cece6b59b719d8d7f2983e8523ce574417a193714004d542eac32c33821119e96209fec77f69191c46a59eb01f3ce15d775798b18e3ee3b9e118e2df4040771c23fd522f0c71140fa69c086fa22ee8c63cf0aa06cdb69e60cb8d5c0525f103aa2cdbd522fdc174208af7511b1892bc1208350d7dd27301bb8136b784133b6296645ce43ac2305221ca78c6790adada7aebe9bdfc185cd0e6258088586fa0bbfa6a75f50ac0f4d250fe4dde680a47f0ea21b95dd51f9e39f1616caefb050aa713e6f19cca9f5ee7515b60aa49fdb7a462e855016f4ef29907b8bfd304a781f4cddcc4f775c7d7de356096bf1c7a19c7164b2f97896ccb978aa6319b7ce3102704e0c3e718e93c0f99f654fb10d4977975f1fd17774eb3a2fa2a24f569a646de6513ffc5b7984b9e07dbff7db8473e0fa9f6a5c80bc5b1b5290b207e98dc61daeb107661d28e128959e3121c16a455d39832a4f86f4a59b3efbb69e07a98d761e05ce802aab51ac9cffcd43eb611a9cb31d5bc6872f3740eef16bdc5173888c153dde149d6664f9d7d6f1f24f8e368c3d6d818ed153f240a8bfc3013e884ac0ae8fdb425574764579f0fd87470d355ae35af267432aa84eb83ae4b2e6d3724567839190f27fe1684ec57514b07bdfea0e89763be09bd98995ce5940b14df45ff80d3dc5ad316b77c2ae43794dce47af78233cb0ef08bf21efb5e0451d20c8cb3ac02dce01777f62291cdeb946de3e3bfc67e7545eefcec9f016db48aa734c9a52db8acce89f589175714b20b078124a420c1d5b1db51fd56dc63fc32f8c4364be3fcf0610d637d96d91a4e699763dd1f7d14384fae4068c06c00c94cfaf4e961591ef75f15bbcf060a55bda2d11bd89df5f32997284250711748e89b13f92e72a78dc4bf6ef6b6c03d3cb2efe864594dc852175230e1d3fa43cbe609a23267a9e06fd209d38591ef1affecda49b23e31b103e3743da60743692322af656bf44d02b36a0f340ab5df80c399499bced49763bc414d846f4bb54417304f735df0b8c8de49fa9b2bc095abc6f40e8ec92b092c323975e46d3497d980bb7cc13be89895de16f4937e065ec73cb4bd6fd5d1b6336e4e715a84d23959d6282c50c9a114a00c6d7854af9c86844623aace06ad581efa0f80ab397610d5ff91350e4eb74efc346671c0e5cdc385dbc3a1ae95bf3d52217b19096e2726c97d84f607760c700a0c4fecb7e3fc23e7d7af309f724c1b213556d3cf979bf733fd79c4be34133d7e001844ba619838c7a98fea7c21fd27db8cfa0f7e062f1f6fde53f92fea7e5fb6ee2663ca8e5a8edece395bd92d48f659a6089e1189ed79275e62de753ed9bda6b77341e57a9460e905858c33db1ee5efcf5ae5b838a4988a3fb767cd08ed059352914d445490b4ffff5d17f018e1f164dcf7d2183ce20e941c197d5690ca8bb54072da310bbe9d974cb7ab8f6dad7d277dc7a93ff46139b691f21c1fc3505f4540d165e7eabdd4bc217c4957c048a1958246bc19ca65244508e1df296e0c02dc51a663d87ce2c2eb1c2df354ee6aef371df891cf165762a7ddfa0105d52082ae6c0613ebf76e95b54fd7223d84a0bdcab8bcc2101f07675fc44a1ba6d560fb24debe5a595afb4c6a172602bedb83b344994b5778ee81fc6901b795e59236e13ef8ada53791d1ca133","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
