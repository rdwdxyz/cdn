<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1e0d02c69b710c8ef4ec7a2bbe1da7906501d23442965090e46d039d3dcf9102d1f7e34f0bd4b8856df6b80e2996d063f90d43851e46c13b15025a0e73ffc4a37447d8dcfdb889c040c94106c4ef7df9e6d3af213a690a82fab4f9a995799df35658702124d7fd319d0d6730664ee185d1b0971bb17e2e03ebedcdca386859ea2b373094039e74f1f3994f5a6e04646e5a8dd89082db90e7c79a321e4fd2ca8dbfc83c01c2d0f6586a19eb9b7dc7418e4dad962bdb06bbb61287d8f668d8589386282b96db8e2558e552a8007711f6950c8f3aebe3dff7bca6502a09f788e812e0cd7ce7b6f6e44462520a216829a8b46f9ebd66b7499b89f4409b39e8f419180142aa34c32cdd76708e99ea8552c72aa573e249bdb90dc83d5858a0e2b1c917e8a0759c72ca6bf2527f767c748f896cb73332d495c9bf149dd976107de933a25f12c89a57e7754607c6f960ab95e53cf956703eec415370b55811495f1337482710fce6e3db18a503e477829c5405d5c4f1f59a36f75975f4346a4478ad537090e06ddc0883f384106b66eafbc10062fe41aa8972e633db011e337df2181fd193af01a5bd66cacaef0641c012624851327a14e77a8690e697ec551136925beb3d47316cf9faa81da76bf9f9facee9f3284e83f200d5b8f82044dedfacf7cbb2dd06edd6b2b2a2b640752d8dff452eb2ed8d17506e9322b6bc3cda03b20b484200e2516506d5c8e4af38a767f15c4dc045e875700c22f24e6c81904418d10c199dca3ebdc8e481a258cf7d65743b47af3e12176e62a981062165575509454a47014ac9e988c665b77bcf6b88142e5240660e4a62b8a4758b927d585f5767cf895906d70282a80722719294b0158584aa400a1fff90b734d816bf0df9dcd2ee7968c2cb1d5b9b5cb9443b920fa2f086dd63091bfc80ca4459ae485a325b9d75967a593e678c8ab23bd21845968f2fe63bd23af0eab3a54938828857400d0a3f9ae02b7e9cbabfe9b0d3ae37ebf2a9c2212088504fa4708a02b010d755306ce02a630805025c2fb5147f0c3e04f5756729856659ef096b8d6bf5bbe28072d50b283f49fd610b7a7d8b4db0321320e5525b1bdae50dbb6233a733473cc8eab0bf8cdb2bc682f81e8ad4c171576b7d92c1072dc074467813e090d6cc8eea4ca3430dae251205eaee73d10bcb2812087d66728d6d69f2005bf48808f5def478b7af5944183c377fa13517a9888a8b0eca95c50a7f241076788faca4ee1c5d197f7f5a737a674f0ec7ec093414b975423786a5c2d69eb1646a6d406c646a6ae1c0ca1942482596e6de2cc336d1a2ba8cfd169ed6bdfc1dd511ff9f4f15c32a793be9ba5d41c5f28be216ac0e685a5d78a8e5800ff864a61b007b5b44b8977f9f01217d41975c56c3ac22a774378051f1274bde999a289b546d44529efb0c4e1c89a7cf03a1709df355c6e3962e1993310900a94c9a30300bd3bd79871ee1c27a33f4af8f0d4b955b9abc9c843abcde5cab510b0922b07a75f489dbb24bb6161dd0e0a75646e6a0cee5b34e9551637ea5eb2a70f205ab34f8489586abe22339da6de1ae6a3fb5cd68c1c3bdb21af2a9f9c2de6323d020050057122ad54e02eddbdaf698b9396a61d6e99cfcb11c108ffd2aa887b042f7cf989efb7f9632fe386f9be42b4f0196f17428d917fce68c9ca564da23c8da7b9dff559caacd71abb57f8abb993bc0df451405447170669650550a0eeeba1b310ac79802a78f957cc51aba51527e1c40cdfe57cee1ea3e6da1f2b99391675a0469a02f95f4bb67563dcf96e42a2d4d0a0a69a6601e5475925fd5220685d0e30497559984b5a7da24cbd5dc2f624ea4bf11c43eb13b5c6b1fdb5a13ff0d376d912fb8fccce522fdf643cabe340a06c519e05bfc2be18ba56dbba43ff6d75ccf59ac06df99988ed69e8b387d6da360929afc28971e76474616ffc28693aae62d39e69dcfe34c877b57825ee526e5829a2c7648c479ad133824efaf704d37693957ada66fcbed2ac5fefba0bb3689be44deab54da6ae4d0a1cacddec83a9a37e5666413bb1d247d77047b326d6d209351340ecd922133b35628e257b30cf86df03aa9698160da03bbd33d005d6aec24e78746e2090dcd3eeae90c9db49981ad95898cd0eb23bfce2fb3544d5c3a93a412f629e9adee11db96ebf4613d48ab14cb7fa453d898b90f1020d1820e6d30a60d2f1c8fb413a036c93370c27963070502feefe318842a37e36b478f34b60a2748c29d81a41bb4152024309832e6328aa17915a77a112540ee2a661a0cbe43a6e687b51e38c3a673a8084805e1f370f061cf4cfebbe37c46d89aa47413e9d3b584f9669f16416801478ba31405ff0b15697d6e99a8d44de06634685611f61b091c0d32a67af6ebac3134050587b72e2657d6dd30fe3ff5815690d6108b85f4bff4a67c719f6e82d346d7dc58ecccab06889bc9fb05355e8fe366a0367ec6fc675d3d98ae83becc4a9a2ce5cbdff8456a4f195e7bd4aaabd8a0d18c7b0d965d4cd4cce9b95c0068e4f0b407f5af4586212b00af10c13453aaffa29053eb124675aeb1bcd82025eeb7e6a906513caf8fff7879c0a328cc8e478f4c81ed7a197fbbfaebc108a5c72c2c2391f3488644f579f72a63da03a0ee423912cf5248c157ecb8c14e4a3b29b3c99800da651aa0077ce244ad149473e4654a64158bfabd5424a59ffc8ed0800063a0c495fb9673d47d59ed1a269bc0c32959524e43070e003bdc52538f95f1ced2cc78fec84a6cf6a62729029aa80b90e140236e3aed84947c8f5e7b89bf5c12b6f9837176ceb5e8403ad1216f770e0212518393e838b18cece9b8a59514ba7087c1a95891cc9273ae16d9a7cde6218461aa6e054b9333be8bf975f7abdede3fee39072a015a5ac8a45ae273153d84b47fd3c4dce5c461de05270a37cbae97bfcfb8faee10e1ef8b763c692c8324548c604cf7b2cc4eec4b6752348abbf1ccafb9aa86264fe526e5a3a2cf340093ce94dc86e2baf2246ffbc63ff7db768d3a7b03f6cc4b054d819da4f50fe255af6d3b9ce89b01227e1996300a190a5f4203a7813f34f85728ceaeaee68edc781755a130b6c91b7620683b714bd9b59c8db42f0748ca34556c1a936924f428409fff721beb34d1c43095e42b171d357841493ce5944819f1d0b515efc26db6a8caa2782f50e2cd121d0ef76f936ad0b473bb53ae245addd910ef82453a1ef51304c8750ebd14846609630cfe4a3f3dfa04bb1fa8cd9dafddb223050b3147f7b6bf7e4258495ea1c1c34628dd2b9a56a226f4a85916a1f1cc2736ba5a67ba9348b5f4b007659dcfe5c24974f68287621639b247fd9d39fc6a9c972f5783951ac47d2dac0c9ae30e59d97ab847f33695dcc3c5d59a05b9d5ce4fb491b4c71f1c0fa910ebcbdc1644dc04ca56b7baf43d8ecb1007d6a8fba0a77e33d2a8bc01b7a99961f5c69c73d2740751e2470c58ed14c9bf9cae117f91075155bd081ed3e3bc1a447f7dc39dc40ed35edae0e6adeafbb4d7f70362847fdc448d8b5ccf11f110a253ed8a3fc3eaade11a59213988767c16ddb240f46fbeb6f3e1f9b96ad24dcc4776f99242570e2d714160e3c1814e213b769b6c1bf8b9ca1e565106580c2bd9dfd5f178c4ed5babc579bd2c5fd39d5746b7eb3376b31d8e8c062be1cd1cf36979eb2a8028d11a83e7fd7e7afd8f9d6b1050cd8528a38b6dc6cd5628685109dda134e2d8950a02b478dcdf2a63df0270680e00c65cba7270ba138249ccd6ddcb3360ab34d58d582d9183be2a5ce37b6a914dbc890a3020463e7d883d24c843ddb2d84595c48fdf6b52dd3aba736d450d2e60fe4333f442772dd21af62da33c84304f36945a4ce8b53db9e04891255510785802325b8ffa6be92b7da94109c48186499f4bd2909d29d8938462f66ef85d2ff6bf12e6e85f45c6f37452b2b98ab38b9e79fef33226f3b32dd949fbd13782385207d492bf1180d80a6e319dc476c20696eb18cb468b932eee2465383c22452aa349d29d63a503addb1cccb67876754432ca89784b85471cab08c543110d911c07e9b802a46fefab8f6b17bc5ec9fc6af7ff17e3cc17aae1900bc4bd6ae1a93225e1afd0e57623d258de652b9c6641e255a456622208cbe40d8e62ae1b814dd3aa624a97a4e392bae0939f74b7046dd5fdf4f6e9467334e743f5e2b0f50e125a4619eeb398d1bbee76310c31d7614a88293cf8856a06f7641faaeb7411cd27f733573923b8bcdd43501265fa6ce067ba806b3feba41f5f61d1e24465dfd6185f6c9df685bb5900c84a3be6f34ecbb4b31ae015035d15e34af391866e2da56b83b320d1bbf8596fa158fc7747b47736bc9df87d85022869b076e2c7a924dc54464ae4210a655dda99bd6cd16cca4cfa4f8794a11f56ed9c38d0316923e7c7be7f5b3842b2a7a37a2139bdde2c7e89660af5277e401cf52a5fb1de5539e9d328545e15d9be57229dfdef93db7cd9f9bdeda383545a782a43a7c34f3231487783a417ac00e2ba280f88b29d80361ada50a1604d39f07cd6111d9144c6cc7952122be23e5ba05790cf5837135ac08795852018d999f0a5d32c7823afd9fdaeb7b229c0d427821702859d9d36648c29384ca6a4cac7ac7e8420f68cefabb859df2200537e2832b8c181dce1bb759bcd09204daea067680159a557e23b9b86191ecf8706a4ec62ccc4cd6d16224319fd84a9d75f605f76962846de2227b5b478421171830d8e139aabf9b961981f31ce9ac9ce89cb1cd2f88d414a1d7936f9044b02e87d98e1828eedbd5af34cefdd49432d4c0b1d27920b15abc8c4da763ecbbce3ceb2fa17d549c2ebe749399f0a662cf41e5113b1eabec57d2929fe17bc3709961fb796b371ad0bb9e0513ef4fe4664f44f56af1af2d16c77c47af3c6d6807a77fb7b2e4ec8c23a686c453cbf1e45099b95ae26d2d8af11b473b5f754d952d9ff517b434df77c16ffa4e9e122cf47bbd986d8c53f80eabc626628c5a6d661537534db1a8042251a3cb3bc75d211e80a49fcf23d22490c125021714cad1b42a2e6925721830f257e6daae4e0d9e26b75a29b8b95900f03bf693b77d86d169947452b9e766e237dd86094b1b82abe7e18ba81b55f9dfe4c093183a697da3f2b2b223efbedaa813c883591bce19c2253d21b87a7b15080153fff9ef86bff882f5fac5bfb01455deabb3441bb96551ea359b998865c7ef42e0891de1ba0ab755d5da36031dae24ed0708365a56f0fe290a1727016566707c553d4b5f475af36099065c3f2234befbe5457eba09cd4db336232602cf343e502d604c16ac4f7db2a252d755e89154478b8af177914c43d02e6842ce14b6a4b6736cf8a8a8e49367db7c4aa126cb1c9206f3093e8bb290c5d2e35ec6c5601037b6ac4b2cae2494758d9bf32e928f976b358ccf1591fee862f9ec4df1d66fa644be5ac285e0585d4312b2a3f13585890bd48f7e1d4933ac992ee894815197188afb82e0b8f597745f94759fb7a84955410b166985aa8b3e9d3d3c8fe68fdaf09cfbdbacfdcc8f550e3d62e20b853a693d1f075317a7c91e4ce5c5c7222967ea26574c18324d1455b4afeeb7ccebdfc905638c9dd29a2eb13704dc256d9be0165a359c88e752ffd445a2e01ed3139f306f60ccdfdaf4c24fd3c0a81c6d8cc0486199c71a1dead87449eb4cca3f351950ff74805db69e335fa4c29cf8f101ece91e0fae304ca8e5be959d9c5ba99dde425ec9d5196718da6b786ea57c556f70efd2364ccd81b4f875abc078ef3b543717a6cfc63bbf8612c16aafd0a61d324d4f1019a480494644e0f4ed518f9c4997a07fb423ba92933a62da308b791d1f6e3ce17891b8dab18a12f5499ce462c7e694a4ed367c6b4ea1fc79aae4ab5cb857ad168628561d2d38dc003e99b17267f009fcdc4343ed94505667eb4c9917d765e17a07b9b0749ad5b4b981129d30026acbaa94f3113f941b25442ec8960c944beb7bdf9c9fc2f1a1a7cd3eec046c056d81fbb190d3638082a5d166d95abe48559bd10db3b75de8dfb73f930e3aa343cd3b5030620eee13cdbad74741e0bbf266cf794239d7ee7118cb87a77bfa6f319ba5cad2de21fd15e91a2022585af06f28ef8a5d47f302b98d6c998a16711ed4d5de0adf74f9c1dbad4f7a899dd7e46c0a6dd47bd4992faeeab7ffddf5ef648656bb7aa3fe8fb6d4d72664cb60a4ca9c8849d43ea8e5cde8a4cc318e7fde0fa10e9b2988482773bc0736034a3828fe83ccead5b6dbc99b04fb8e2558f2288faadf7b76ae1c8d955555503c54bf6c666de92e705307b80635b77a886b1f092c015a950fb88a572998304d4555c376797e8e017e3013b09968bedfb3581cc08331951e39f4d85d8e38eac7071ba5b980e91afb463717eba0404e56c612201e897152edfd6120007fb0f6dc3536f272b0245a0420a6f6958a513bb8007bb6ee7f29c2480516ecdb0cb8268590d006852236a012a8f66deed8afa126c952fb9ebd9cb5d3d4aa5c1fec187029a3e7518558d326b9552986b98e9c3daa8299123f01d0ab5e6bfb9c9301f083960c3907553d0ded1f8265ee3a380fed027c8ea9f13c1e56a0b4ae9bdc3d007b075d78d4ec8dc093827ae70b42cf3a68d1ff3ad7e42fef4f009ea72449e9163f6634e39284cdab8cd7779abbb5618d4c1ba8c02546dfa6ec8fb53834e86131e312da3843ce972c9147cc0661fbc397a066ed1aee9472e14026131f6f3bea77f386f2333b9f4a252584e3ff534a74431b42de6573170e67014e994a58839d442b0090008182e327dc5c393b3213d8140e78d07b4aee8e5fa7b4111e08b4a1f2b1a1837d1ddf13e93881131e47b2df3c40564c081baead47baf93a7c6f3d956526e46802544d832283b6135e8948cc06c9a3bbc72a42fecf6ea63151eac386d26b57d8ea57f4b1d5f689674ccf31e710f3b255f07b329a022a87e6571bd42e10b5706aeb04bdd8c6ee76ba11048e38216636f72f06b81b164df8534320802d58fab46a9bd33d1bb75a3bc9bb346b977b4fae72588b5ef2e993b9cf989ddb0b81303283f8d0b19a169bbcf0c9b45bbfbc4f88c1a04201adf76078dff1a186b1d9372cc0bc63a004d8b647c8672efdf2404af862c652a1b640c4f4e24344f179ac4003024ecb495c57b51a92772869e7c4333c52d9ad61942fcf02f93a511621afda27e9e488ea47341e762701d7c7c428136dd825469fea3511fca75198620494a968229c1bdbc585133088f8c9004f7717eeb0eaee885eab7684f9b8e5cee879caf01af6efbfeaf92ab4e1599ec34a7a6639122fd8d7b0545aa2d72aec4b809a6ac8515fd0955f0fa2c30e8d7169834211e90caf24cafb54f8acd6fd6a1d60230748d2501008a1342a9ba41a5fa695d90b5162395a35616c4732609fe40f8d050c846ff6da15b61eba063b7cb9fa8e0f50655316283e26fe930de5445fd30a18bf3efff4e53a570fc732703a737432399849fd9c5eca24ba886e1aa825ebe010d72375e2e5edaed4ec669ec2374d201e8e018376286b606dc62f888b00394560136837e84c6c43d9d62de9f2e1bc857142f9a78835de5090fe05d1f7ab12153850919d9e18fc6bf8e7734f040b7e6e009dd433cc2108ec33e628ef3122d4488a8b8fe2944ab8dbb6420319b86385b989f664a92fb4fd895e73e3abfc28afabe55e4b152c0b4342accefb7a9f0a93b2a382ee187855c6200c1720a47619620634ae8a2027b372d22c5cc7939b09db1fc831e2369709dac80246d8de1cf6d7a2f35a8a6ffb3e964a2d1026660e393c11a11377f8e5d1c89817a8a900ce9a0b593c61fe506026f09536a39c37751206be441a305bad77a1a6814d688a5c10d13bfba56d6c756285e4ff00a8e04cd7bd37610715458de3fc1dc518a22739581416ac4d04ad005ccc5e9fe6fad37704702e451b3a2a9f41ab8d928bfb3d27633afb6392620648bb5ee973974f2f5170e6df6bec3eb4355cd69ed28b444613ebcd5511991f59cf5dc14dc01313a7140ce4e642497ccde432a79ce11ef1ae2b9f94e1685d953c832dcd0c15a818808dfc934bc310b054f7ee41c9547c144624f2b3f64f08f47f90a61b25f8cdcf78a66aea26be0000d8f70e0adad7f5c4f7e290a2772dfd685da5c37b0e5f90455a1ce3b0b562451d9f8b2b86f5fb3ba2d759178c306ad05e04e9a07167b1924f4b7b0a8cd03b8debf1caf36616db6a5ce2e2b97a7b72fdc5f87fa897432676bc6b3211e59afa4d403efb0fd3243a58b0e4442c51e81d2da62fd0e37049f8d1d78b2688439dbe0d69beecfa907401bb5932107bc6c9a541c1babea1182b531a125260b8814c3fc8f3ad8f0852fb1ee63ac2c9140a6763920f3249d7dc116909f239025f688e17de056b3e27a88aaeb1b631b07377090a4d9e98f3f07a3d1f1a961bdffbab8979d156b605a4aa8ceab62caa48775671b4a148ee38ba3335172e4e5001ab5fffa62f3bcf89e4b19f2e66e6efee7dfcd36613a1a1bfd30f7325b6d0dd268bdf4f776388ad7cb8ed8e9cb5f6acb39e7994019d3b214be4a8f86e134ded0a4b7709e7ba5bff32d8d8444a497e505b7b505065c3639c56d7ce8a5cbc7d1d6794f3c19fb6873e3126fc35f2f2ad7054b86bd6867a00df94fb4e8a67b80ae51a828a48a8c2b580b2634e4a7891c83f44bdea09a065605764a029ac20150042e36310b684d5c9853dc333ac1f81d6168793d9089ec21396e573ccfe0456e00ed55800491eafb673e0ab0be7a3eab4f47a817e5cc0157a9b4237819d9118a91f0798d05009abaaea32f9f6086088af3d12f8791c158d88ffb201a937b930df82b5fe0340fdf324438a6a350517b24a4f2d1b81f9eebb4e9ed3795c851e77b4f87638df1ad6fa3fb142d6cd5472938e5d09d202a07c5c5f84df9676228de08ac5ba369eb869b5a281e524eccffe526bf0a0669a7ef7a51b95e8e839c94f45a7fce86d6aa50cc96e9dc0990a3595f1fe43f86e7f90d7884f4f6bd375242c24ef4d43ff5e36162fd2d648e476322f89ef40f97db0e0d1e5fd04cbe5f89814d0d327db41eb79916c3a0500af1a0efebfd828a318daf12cd8477f32bb43ea178d8a45967686aefbe1b560ba909398eb74105583261bc0687f264ec008382bd01a6035585eb28adda702c9e03091ebc46abb0fd5896379bbe705c6dd8a161eeea13467d983ed7cac1974f287d17b40ed1f8efbc733cc3f52df0e0651ae39a5473e0c62358acb89f87b4bd83e33b47152b45c130c151dac65d389ac905eca80153483b1c4353e6caf0680a0f655cd300705943a0e8376fed1cb85fb0a4da2f41337bcf9e449de5684cb556111f9fd29e9be6a9db09cc1ee0bc7d3f80b6288080541f524d59420eb9d6520b6e6798203826c8e53de539738c51328cc476c546e78efac353c9c4fcbd2043a3959a80b2dfc78b3a1972c1ca8b9525e17dcfdceb136598942d949455a73fb28ed14e8fe8f570e2f287a7c0330316b0d87f22793d06f20686e0c3c16244f17211097e0cefb66b898e6d87d9808e714ddad21b9cb7d8e1cd055afc38e302fff73dc05c193476abc0ff49971306c2d07f38a0a53e630abf17d527a7ce463e6e64f7755a88dcc9aeb2483e30c0383de84de092074725849f61c97223096f76e6f4231c998caf4457b2e9d867675a483ccdff9ad67ac002cac3c3878c157de3e5a59cc90a469b383bf9624a07d5ea771acd5c57d3c0b0af2d5f83494ca3317711ab5b3b3f84f6dfda29cb74a583985a047f5b5cb229ef435cadc107d2249ffbea3ce566ede3bfca36c100a8db1b5bec2bf0cad16572970dd8fa8bf49ccce07315af317c60c7c3f9747905dffd7b2994745a5cb789f722f59ebb45ad4ce1e8767119b06e57f8f386cdf09715a074d388f3bb9acce058f492c28bb7465b100ecf4a6e04062d5734734f18794ef34890df670d0805ed38e7d1e60db2d9f9ddf84643f2d0f8d84f3f24ba48b057ed42af08c5bc57734a09f960789e1f83acd107ec531cf64c68f87bc0a7109d99d0d5be93befc69842f05b0bda82a92107b198cefccf712aa1c6f9d709b109909e3e1c201eeeb346301e1f0df55e9a5643d2561815f2ef37f10a80ae0cc0462e910667f8fe8d7c82c1e7f9c1f1f7151440fd18f5965a54e6d82bd59719cbcddc476f29b217979bdcdaa4bab31f3d4e234fe8c0bd4f63d7f8e83a2b80fa929ba5f95fdafaa1c7473227cdf5acff62dc54acb49f5b0d0fe2076bf7c8780f4c2dfbaf081fc8a9085391a6fc577618532772b38375c574aaf9af03c9b5d92d44e6e691fdbc1abe0b6e86a31e66b8a921c72e594c5f4c0fb23043253c83d7c187be5909284f2581091b79951cb6bd09a4f956f8635709fef3ec5deb91db570d17d19e401288e44d49e7be5dd2fdd1de4e01c9692ae96149394492c3cd4e6ed550348ab9330453d3a83d45d12de52bee2320543f59f97024cabdc09f01391c71a45d648992d0b816f883e9294f703ec9cd76ec82029356837cc8dec12872fa15692cc634ec0e94c16d92103756fc9e457154a5acc6c10a65443de1162a16dfec5be16dde9125c315ddbc916dfa6920e45171dec722534f503699c3627eb79466c8e6ea3627fb78c2d31d75ba282b6b4a811f880c8a78d9e42443dd16e62237da9bf0e874324dd8742057ba5daab7db5edb7b0d287792b2b6412ae2bdcf3df141cc2d13f7455f09330c89d06e78691edca9651b74f8c508fb5d1b1138e234a9e6266ec99b7ae09245e35929b150828c50614676ac76ecc2f365c36aca325f146284e3c031e791f109b889ee27c54ab0bdaa609af4179729449e481bd6e5221b06ad98a85a85f4b483031826a4ee19307e8425d5941f2b3a77ee91ebf3f05efe890dd76f0268855f47676068fe065fc81aaed47887286cbc17fe63ffd807b998236a2dec5e9b4921b2f48d7943df12462afba9777c56acc7c8946a72a88c9cfb6c86c016b04292705d0fd8e0b36cc775fdd163fc9f7293a4ea306acfeb4e26d29fd295e10f219a0e4b47ceb947d7b14b6c259e1e6374734b929ca46dfd2dc34a76f26bf1b1a4af408a0a7703a398fc853bbf6b53d4fa623f409eb67570fb0ada492d1fd844549fea4222199027a13e9665b016f0e3022c14f1c53c0bb045a29f8ba614fa477225be18660839544b0d0327c6b30056a58202eb9666c1624310ead891922a3b028b06c2e813e42fd5cfc1107aca51e7e6cad6838c8afe491ea7ed6e1d2f8e1a5172d5b92deaa143aba8b5c217990c201c148ffa0f5190a8301800eb27dccbeb97e77f024c0711e73d23eed3c84a25f07995451d0de9b6a3ae6d790582e431902b534d413abae5761101567ac574ab2550aa6819251531403b5af864629db335f9f3bd355f2a6fca1e27297c90abbe8bffb19f1a21985d3a01d92cac7d6e1e89983f5bd5210c1dc48c13271e7ebea4319ae0cd1c1574208640ace82172850d62327c37e68db9d240016ad05c2b0904e626bc185f6bda0cba3c2cc1c289da5458439dd293e61a87b71beb1aef8120141d7da84a37fa201b62bd61f63ed2d5cf9fdd47a09532857c7776073edad457eecd663ea6f1435cd55a1f57531732dca52da61b8f54ed77de8a388bdf9dedd1282964492599889ac0dcf9c47ceb1e7217f3eb2d7c960bd5d50e8bf0936b5d30de1bebb6674536939aa0ebb1d7bf92e1c31ac61c0c680a9cd4109cd04c00c263a0957d7b594aaf1e249b2c1bcee9bfa1076722f2f5b6987f90e2ae58d695bb23f5bc3c9e3f6fad8e08ad8740c43de30fc90218e0049279ed38fe14cef2219081861ef1a42707ac9a8a113ef134088d35da461add30acedee84d9c17634adb35f76f375a7eeca662cbcf493287c1f45124e9a89d25abe00d53b9ab8737232dcb56324a5bef94c6bdbbfd7abb7b07fedefaa32f72e8f7e236436d1d83563d2a729bc2e4c21bcfea71b4fcb614cc4b7f522796667fda919897018f0b72be478318917d8a6d585c727d99e0e350147e9399cefcf33751812121eee089a1aeb83ca741c108b1b13086e58a8f05151fff04946408926aba456cab19c8c57c4dcbd0e4437ef4a92a8d123d39e5937e8f15853e4941e3407d4f3fda357d124c6b56466712cc41ba1139de711a0cb05b73bfadbc578f6f4dc263b1890eeb326a4266b6f30b7e65641a48323c3a28daae65305d2961b28030d7660da2f82d70f1c367337a1b5fc6b1a602cb4d5194b435bcfc7a62c3042fa894c7e0b78093abeb4ea9bb74c41702fabcb8e4ce4189e42940968ea118231f1116218188dbe4fd805599277f4bd7dde7d081239ab4d1e64c4abdfc687b7a62d5904d45d142cb9e6cb3d00ece2f2d7eb25bde013450ee5f31d4222bb2cd47dbdee391502189d7a9ffb32bd1f68e4e9ad334078938c062cec11dac0f1523c47fe07202f297926d03850e6535115ff43bdd88d969ee26ddb6d0c83a8018285c23001805ad78b33931d3e542faa8d667503037b759b68e549489697f8a77bb6770ec4d950855ecbf68e8e13fa09bbf8c861737b42dd48f16b8c739f3fbd0db28c03ea158db3973c1d86a9795ce7f515cc4aa7940e8e5342bc2f9e473982785ea004aa253392e27b864dc82ef5d077f44467cf0740419c56b177b8b52cca33fc568d9cfdb7b114859595f6854bca18a360417473dc7d4d419220ab88aa676c218aeb1ea15b83965e5430ff2960e96abf9608377da8512c30af789b609fd62a46e8b65c79f3ac8855c527514f185a89c9c8432cbb630a0e3727d44ced673e08a1283a6ab0102a8efd1750a21ded1d9946d59bdd5ed7f3747e89973d61cb3293c9d47ccd7fd65c6d0ee3b435bb9a4a0d065341c19784775c1ad6a2a2b86d6d5a6c4c43ed734916792dcaf33a78211b3493978036f89583097a5032ca69e6a97615c3e771a3f032c57a0555c7f67d89f4c3e3d2c452447ba6a7e55084744ceca8f8f3fe6d318cb4267a4f6f9ca3cbe13359dba4e25c800ccd18dcfd56892a6fd50205e666c647fc93e4337369ddfe59402b844437ca13c82a006ee6707ed3aabc5f7de91851b5f5b14ca68e4cf648d02bce1bd412e78d05350570eca0063913f1b92c805009307d76eecf38e9c5564642c0ef67d88aa4bb7a4a747782042ad251a168bf813613b0cf97c22702764338ae9783071f09346e9ca9e2d69157d112d5257eebd6aca2c48c0a5de7debfc1c1458e8470a0ccfa5cb2d11f1bce97a886a2b8f15034604362af7f9dee64455af9af9f904a34b897ecbf08ca823bfcaa30bee1294f9f178bf7722c2132b6347777106e6dec57a26547ec208aeacbc9fdccd716fbe171426b290a415372a50c5edfb674ae40111ba75d27eaf0a0f104cc6db34a249652a5eaa7dbf87a6d6379f17c79dfaaec73bb71ec3ec1c8c3bf37f6a02f21aad9ccb0bdfd2ee3543722dadda1cb64a7e46b52ab97af696b666be6176ea14147e7302d7081af79821809e4f3502ba9e2b41066a2f1e4ec004ea304cb56ac3df460448f3fb1e08ea069f721dd7ee4a1e2a98c7c89f5eca67d340963b62d6c528ca37d575c97e51d3a2ddc16f10abf083c1fc009ea3e7bfba7b5038dfb1db287dfab83e09e7b5a5effe20c57d037798b68075bb0b74a8e015de9c207f0a737d929e06c8c61d31a001bc65518d6469cc9089bea07612c822355b68003e097727fa7025bfec3d5eaf3c01e8b05c991e25620c55928bd3b7c760b99827efed42851e6735f1810e4e720d621a3b403f85d7169569471219ac55f062e11307fe122bf1b869ad180b9af8a4eb9e34b624fb46bfb05b6243389d4a117f08013cca1832a7f20fdde868e12eb0d140d80511573ebc8f441845fd333cee9b3d3531b95d53b683d65d5522e7333f857458483bafc86b7310108f66e2b270fcc0d56ff2be2bdf8bc643caf8be7c150fc228ec47b980e35f708a31089e5ee67cd8103bcec85a84bae3eda50054c4ddd25b5585bc3edfe7ac78a2afd4fd183d9a7420a6eca1785a9faa4b77f06f4a8358901e2ec4b1bf8b59176319c7031265560378c2f9751e71267842978e329cd3a16b66bdb1a2ee9f68b4651f252425b9143c77214ad860e8e9661b44278ab6f0b05c1ffd96c3b6e1e10378463337b1b9f7176e4ded47a7a31178eb1144aa86cbd46874202fda8675a2a094ba8b33d0d52310c59e8e1928c94c5b03e604f2bb3c33c837ba0e48b68393b7ad087f5b7c9ac87873ac5f1b07ceeccc1b75f9c0edb7a0c1fb7125cbfdc1f06072115b38f7932bdb6d6c9fe45deba802b454962716eeab1ea808d3294c7fd368a6a62474dd133e16af551c784b749afa0c5dc53a807653b95d04efe112b50a6a1195fdc9defa8efd154d4978b4a5b6de2b0a433b82c12c80d1e9fc498a0548cd32b3164133a1f08d3773d76c7695944456e4e3577485c19001b29046f5cfb4d9805d6dbac53bacd9e8cab1f366b5486e9b21c6ff46c2e3fbd0eb0c6be70b9635e068212645e7016fa194b1b3b23ac8f11e7cf4c4d12d1ba4d57055ed6d815d51b7626e0328974b77a4678e862b98224a82fc2ad016fa5f544f91f9df510c872b9d7f81d6970e3b8f224d57440df041bc5cf0e4afe39b20c0601b8401fbd3383457c9a6a6e5cecceaafe4ac54a6ab07501ae1c1a4ebcb2dbfa398beccb5f88f86833d5f4ad7a1e01c0a78a03acd50f06da216a466bdf40c69d94f7fd886f4fbfda42f27bf241972bb4c1dbf0b5d29f5c7de6ae0608634b48e41805ef097de666a768d1dcf3d80774e34451d484f6ccfc91a9cbc49280f1b45a39b6094f33b5eed7740ebfe09b57c6422b5e477cf66a34be6ec6ce1a5d0cea9712f20be72c06b0de616dc72d4ac0b55bbdc65cb736d8e34136a628c4fedeb4bbb752e559cf3662788efed1ce8c44867aece05462b2a79cde8a7fed48d4a5761b9345b42555e91a79e7a882287191064d67cca97d8b71a13be4c82f7065213cc7c9a955310d9fc37e44b2f4cf1ebb4277802136bbb4697838e922b552e7c542f375c7a039ab8c43a61881b088e9f056e5b5717f30dbadeae59254c40dd3dd5f169c2e21707b02d5d28cc48931426bc0dc73b96ee2ebb953b2af83a231f656e03eaafbd7b7a61130c764b4eecd5ef4c5e0e2983bc032dbef657473c5a2f18ca4108bf6b71039e7ec39a7e256b09fc29cfbb5a770b83be5a7f0a6b3cf57ac0b7992d4d675cfa8a2fff255726b57cee954c4b4e9d9368a3e6dea2f306700e065d64613c93a7286684190afea619162b261727865f28b02f7ca46f12c8603d552231952e447d0b0164dd895f165d8c9b5a812d49b0ac93bc78006383aae312ea38a49175b8c64137089b0085ca3c5d46a487002c2a7fb2540396814fe0e54a896f415fd1c5e6b88e4fa5fca83c5343631fce48c987df656d5a3e9d2e746f9ff166fa8676e79562f7380346f6b0df9a6a3c4c4c2bfd82e99137f6df5516269993e6a13cea5e9b0732f8b9922945e1ec2350fa048cbd37299f9afd625fafaee48402a5bc01adacfade27861254c669a06335d2dbb688f7a04ea049126e20f528b88bde5e363225384831aa3d8557e6b3b6d141e7b564c59b89b5d1ef570f8de54ec3fed8fd39507aaf018848373656abec67b5772179db3100af81f50d95101c7a4fa870a77d89cd1971522c98016ec940f00419d6c120d12f1f0902e2ba5573f06739a3447c04f47dda382b43521136027219483c25b8f7b38db29638829e78c0e1268f95264f5209c874fcf4d592f2d51a23c67c34415a0e68942c065ed8993c94e284d54b16d83c35f9a9a0acb9ef88a4d769f57e26a46896a17074a25adde703995acca374c10fb528511791fb0c8862dda1beaf7d1d3d45b0a175441a8b736532d2be0c98a5625566aa65d28adf9079909f5289ea6ccb3826350154388caa66adf3278084f1285ac28605a42a8197936177165e98eceb6fa5695d7fa9fcec4eccc20158ba24a073eaf669af266c297fd1d8f6ca6c74fce8e642b78fd923c2dd674c31971ca0baa1d229ec29ed3da421a5aec3703c49ef00ce7305143f6c364700b1b2136c8df0d1b2f25884639c498bf3ab8519c1bcdca2823ef6acd548c5377e61a43c9f1578a6169c6232d8c80d4c0adc8d7c1b9fb837021e6c7eeeaee43fab60c6d9cb0fdd3dffbe1edc24a4efb489ebfaca4bc518fd8bf9e2ce8aff244199628135d261a45ca01d829c97cf50dd89f5cff32a044866ea539d94a8f592d68fd3e8fe55bdd8959f724da1f39c0e6d96214f8cc2817be4b84d7d6dcd33759e4748d0b9a717e0488fb755a0ebccb005b33b9189d350b04d8751c03d975275fa0da5f0836ac656e3405b47af2e537b598355a822cb4ae4fdb3cea59939cf1004968f79e9b9d0043576a661a126b4f4707055fc4d97ff211c97edbaa788fce17477980dfb9e4b577f64662d678296f2452db21e063e2c3084dc2719ba270a27992368b0fdd6cfa62530fa180b14b03e3c20579fb418c70f0cb93855779fc545d17606f37b950ac6587882e53ad87324a7d8e20c0996e6e404bc5e87d3435972d89f9276617463f5b6c6b2d5e77aafa677a7f3d4d08d81a3fac9f273f8e66cc34553ddee0d8ba98014bab66d2338c47ab0267d7249fa1aa888bf4224ca34f1294c394ba8b951deeb9ec8db075ee004afc33550f7070e0dfb8abf86f9aab396eaab39e272ab9bdbd85f78306ac9145aae65c56a85324c11fcbc3041cd1d9b1d57939ecacaca1ad27178a6562082d1404ef7596863f5fe3b91b766e184c1b4cb3c4d07aba4738436ee729827cfeee9d689447d05c5d8a8b7085f809fffefb1d739b41c2c1c082b0e12ed490a7d870144a846aada3a7b5901644eeca5405026708965570e06ebf11484d11ccf8f5295a9738c332a3593fc76a2f8269de83658400841c2dcf17f94534d0cfad5caebf76ae2e7086c7cce6f24e3ffa45d8865a36b887be347a0bdade4705400a112d80dc10badf9f85321d48b2b8298687525e705cd6c67ad8026e2fda30465d5704d9d95b8d996312e3f6539c3b58738d27684b6d15f80de79d1304884ede75c05cabdc9821f3f85c065ad7ddf02d0c24ced05bd3f838c4c263353780fd68b9e9cf336bfd95052908836d0a6075859a953824ea85fb2904368de6f5638f89cce9eb82d7462fd3662b1ea4a476e9cdf8d0024cc97eabc0036ec84ed6f4a0fdf2b568945928bb1903269db34fb06b94ea842f5dfd7bc228d8075ec9919417a6bf3ab77fde76928927687b070ee5d95ec7caee0e198c66ba390ee14a6512ac0e1a4ad9522f276714be6d387786b14f209d86e554f156e323fcf6207efbcc2c33d7631dbda691ff2082a627dad12239ef812a4a171d848c309779d91e1147a060a03dd6da960fdfb8c290066b7d53f35726f78a918c91646e07b03d682edf063096f34fc57d220c0958b82b1fd7e6dcce153fcb8707812bfa16719bdcf14dcc26e0fbdb2d57292823c63adff3d0debbac9f2ba887f8042eb76f275742f9961b8c90c1fe588c61bcb7d5b0bd34e742ebf1a8712aa54c730ef5a1707cb37e5b3e0c6cc044d541c8ff36ccfd82262591da30327262ca41ea8c6d2c372e4da0fb173cc030f03716a93dec59216ca53bbcd51d3452301c8714c9a87cac5e0b1d980f2ed9b11f99cb1a2a48a3d59b94eaa5f4c32fd9b680a0677e5038243989c16145c6737520ed62320308c529e65f55fc91beb7fdf34d24a57a233022925e8004424f6c8c2bfda51496208391cfa5f37562fc74e8357b9a229b0b8acec781aaaf12703a90d72f0ad39aef3cbac59295b0382e6ab6ea98dabcd05f02c72679f65251ca390b9d936e1cc71d1adb322db4c32317ba7a35a4412cf54c464910ca790612a1bab9bc6f5570f31102b48858f3071c0875b9ad0c6a6cbd29b3d7fe64ef38506d18fecd4d7c9be4f3bf6726b87db1e3057961638d87ea29a3e3b3089db43b15b00505001","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
