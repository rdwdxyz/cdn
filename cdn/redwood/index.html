<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7298d3d986eee809aff0fd6e43e06dd4ecbdca7f9415272f909fabd4356d052e1684f00f7b05e8bd1429ca6eece653c2cf57461c132f6fcec2daf3ec76b1be730ba973b86928f8b1c162fd19473f78fd279d5ff38875868d87f01ace14b905fcdf43bfa8d6885f63bc97b4b5d86f2ddc1b3f63a6784002bf9f552483cf0e5037372f500c36f68f3a32a26aefedf460ae2d71a77ca8e3ccc6942663e81eb4da8cebc4c5df46c1bb6326a07413457da83bc09f9754130718220f83ac4561f93ed342a6818733ddc4b82bb32321fae24fbd2c59920dd90d6b79c76f33c04b6448a7d1c9d210d260015f34ee3da3197afa80e9e0b1cdacbebec9f09897eec1f341926fa836b0c0dfec8ffbb99199a043c955d7eb14991e163f18b6bec70bba46d6c23ddb2422a9e15b42bc9444cd0755351032c08e4e3972fa06f57e05c7d5e4168fe3ce2e1aba9ca6f13996e094e184027aca316204f76429a91e373e3feba733433ae68d6be46e496741dded963ec82da80879bbb15c5d86844368491aa8871276a53d1c6706f34009ca0afeb54784e1a5897375469480ed1c1679a32d7827e88b6ab3dc7dd8614171d37089f639414e76a1a966fba40a26b1bb5d9d9907d186f84fbbd602a64d8eb1fcd97557ae5b62e885e7dc6684f2e959a35b532a56ca0dfa222e51350b37be5ec1eacf00331e33295a6a0bdc1abd944c8f7d2a3ffc6d62982952fbea28b85d115fd50914bfe0d55f430e271a72b470a4784b4257410a8b44acf88cf41d2a0f82c4503e17471c311655a9d3d0a07ae9742ec6d0f0bd62cc265c87d5c495b97948a0df60deb83fb3733d32e9947b4f447beaa93752d598d5195fc95b9786ea3e871f7ab90ae434eef04ea99a7652f0e278f89add6cb71d558d2e689f8940772a5b5039e86cc71bb717a1edaf8dca7ec29d950107ba1b5e55a177fcab63d8e65a4088a637d2146d7aa87c25ed6dcade7c612cdded501b54eec72afd21c05da19cd0f9d4bc3c61d8f324bd1fe4013ea9527a9adfb9a272cfb7ca9112405b08c370f932ab383e992151d9b295aabcad8d410ec90e659d451d34d845a7bae4ddbbbbd186365ad8df7c51148cc7ab07e04e405fb5fb7a7fe4b7100c39c9d91dd68af3b7bd34293eaa8300c80f1501eb6216120ceb76faa52d529a40fd4305852051930deb6c300d8d695964ca2c7804682092252d1e0a181b117a1bdd0e4a358ca16094b75b2cc3a629ec7d2715bdeb1d44de35448369c47236e5fcca8ed5adf2fa2a96d606473b792f62ebd4e3026af9b72704e7bcc2bd1eb9b67a053f4aee897337901d34a680916f10b97e2829eb1620182944adb09bcedd368c6f48223075ca650d29cc89355d79ea39593b6a9fb452780ab6a6d7c8e47280975c3d8b19f22a9b02d5566a5a10bc0ab237fbc7d59adef9cdbfb510d007c6ef24df2c8ee0f97d3d27a254944f52a8f45106bb9820e460753b76fe9e4008073c1a995843d97493190a1615f4adfec56a239f566d66a4cee77dd9fc9f8efa1e89939f876ad6cbee0ab8e4348d4377b8e956d29564cb6128d959391e6a532f92045c25a27feb4b32602a98b17caad1737583b5ffd4e1fa94d34ea5a5609295193406f250c87912676b10c9d022e3b9ba88f7744fa69fa64d0d83f8f5be44d778bb736a40c3de73edd0c1ce7be0669af70da77f98d7800f7e38d710efe643e836b8b14e15a53f61e69fe8059589f51f5916db50d8dce43ecde4eac5a0d93e6138aca9a5b955fea76abf2d46338eb12cd18515d9493637d04bc88a1a267ea8b5dacb4703f8019f08500adf71295d94b3c388d8227e68f2127a0f69c24ee0cdbeb296cd6cc629d5e9abf190b188fc9209461c2532e7448f107caa6354e645f9f0f2dd5f41d5714cb5dd6b0fe3360f79b5639d611c231740bc81ad0d6b77bca2ebdcf3608f162e1295089949323cd7934a47d32ade4c252fbfda3c56de6e5f3fb746804eab0c9f91bdfa30c9245a4883a40592455e0f47c3e9fdbc3c8aa23f58511bd6650b705ad69a4470c33954c70c67e85fbb54c5705b605479e68235ce434d71cc1b1c2f19108f74ff48517b4932bcd85e9b2cabe9a6138cc69d4b6962a55b9e66d3478fcd011e230e1c80e7edbf9f18294aee1c3df352fe6641b6c66f62910b008f795746e52e52dca9e8119eda1e150968464efedf8254a8d50e7005d647987a7d1ee90b094cc7d5fe045006de7e45e092d61f8f0179389401445d8b1b8c567a170f23990a2e943f08c7b77320219846e5ec8c050baa4cb19c972b989c48c3469d456e660b088e79d0188ad31b4634fe11d52e54897e91517ae2c582ba00a3d06c943b062cd8f0f4ecba40e6fd2915a6cfc856472bc2c989493b7f71aa1fa94c12512812b2388de332e60d5bfaee8eb6893a4642fc93c4ec31e97ec2bbf971a9857b84646c352ba4d0a8299816ef5df1dc07f22ff015fc1c9769dbc730dc2d21ecb035adfbf428b1cb28038bdc6e3d8ebb772b31b5753caa335164f407a41d5adf607285a0b180ec0a395ad9581c0b62f9584e227c457dc0cafd154c04531304362c3f23a22621921071393c533a10b969514c3e3aa5091e2616a4602952c32883bc2242c337c4e81d79bd68ef0195f492571f6fcb14b49a760a990b5d4a8c72501b23865cd767ac14ba9f1c3c265c70efab8ebd16c0d08795784bd7587d31d7adc3c454d64a82213c306e520741f7ad97fd5e056d5e7834c39c15a8fecd19c66e6b9d48bf480c51020a58194ced627dfdace3872448cd8ef3c5ae864c01be2ff6702bcd3869b5401c704cec9d9adb8e4c1129a644b2642f274eb3fb1c7739867a0821215cc6ff04b1ce87bd9095b43df21aecd5c48028aa5103808a927b8a09dd3c4d99d54e810b0e2292517ade94ea21842510805d5c043d17fd46a2def43812d90aec1caa32c0870edaf8669c3819d843496c99b667f4fd0382099840a2d468ad7726e83fc79f777fc2170a3ea5db19a7c0b747b83e2fb542880a144fd2f785dab82651848e4e5fa2b6cbad0716900f8fd44df92305d5058d1ec3af2c6ccfa71a2ebf6d5b8d1d83044a17b76511908ab243b6016e3325994b40124e9de5112410798f58f49e81de15ea1da7266908ffe4457e3bf7bb75664ae4bbb5410a6ac6c0ded5e2cc546433e075a2b29483cecfe3335a4110dc1e365dc5933820651549b6a45dcfaf260dde836bcbdc8fc72f1489be46f6e173595d6b51dc74a8c7bc7922067cacdbce6c141aa67f3dd76185234202f968a1ec662b0093ca25267d3000b836d02fcd8207b7d146e4b30287b3b33108b26a137b1f6bb78b2bc556aed13d6f8fa6db798ebd14e7d5cef6c678a6e3e7f96813709e5cfe8038cec8194d65bccb583864afc5cf582fb5abd359e717e574f34f0cc2a5a47edd293a082ece86c2b83d4bf7eb86986929c94d75e2bd5747e58cd0ba25381eaf553ff5c753cb9d2d64cc075a7ed57281117d9aab99428ddced0157d334966d51bb797e0109f0b91f28b0a794949ef7652d768395c06fff7f06163c4bf7333fa5f67fc929fa78a31af27aa4c39fbda41f49054b66664bffa70f716ed5327615e32f6f3021a8f56b4afe965be7d7072f94379547c08f0ec99b89521915476f417066b02312ee12d026fc5baf29957183c51e04b3cd3cb11a425b4e55706d65dcc3c795b0aeea1fcaeb13eccb9a0c783b3623ec2f81ad1845fb4e441d00a5f975019c60f42fd0500ce1ebb63a71e518e87354b2c45320504be1ce188506024d86662c069729b2ad96c8d74af1583d00e4eec48ac0a0f68d120ff22522e6e9f4d6a065115d1b6e1ec4adbdffbcb9970a2d15e03f48511f0a7053c230eca507557c192dcb99b87420a760b913f274f533980f905aaaa75fd33e8dbafa44f9d2fb09f334afc77911e333b6325f91263b62a73cb4af0a86cd2dac25ca9bd365d1c2c365d89122aa8426101139a08d6717bbb99a85a7d5a8f5fc1def94014ad2f507ada68a90e2a4bbb739339ac44e198440a3dd3ca1ad5a87c07323e59bc22a4b42dd41490247ebb878d94e59f07796740be0e5e3c22e800f8b0ae71d2c900833dfc3391c314450319b9c74645ffa184d4ecce36eb77e7c4cccb3af7c76070319f352e8eabedd9d9bffcb833356274d023a856244114d331403a89074d220bf41b0cb1c6bc6c81fcbd38a28e6bc024f8195fa4762766ff1bc56091476b751ad15ee82271938d0d5057685c407b88d90e0f9aba501add06084469a304fe8327f7533db1c8db3ecb0c35ee7fad259a25876112b8b9f36162e62143470467313ad9e191e5cb2627fe2d4aadcad595ded375dee32a8f8f665cf7ad04d3db120c9d999e059975e8313160a42d03f2becaf9594f14ccd66558d9ddffeb313b9a47d3e7ea875a776f5a8e83c678fd11dae76ab829c5a53cf51873d0f5f2111480b46767b2df32ab5cce72a07c5789e377b26f78b1330e092195b19d6ac9f7f2c3cf76cfe751bde76108f6686bae996fbaf6538430162c9db4b9239c1f3848b06d759ac971febe78d12ae41717dfef0b617f8eaa77891e927e06c115b15a3d4a2c215194bae69d1f07e28571b7b67905f02fab748133fce63bf5b683816d7f156fc6fefd9862651a466b0393f39660200f38441268be76fd27257d7ec5e76bef5f028ef50d939a856be7561456ce94e15387a81e7152f7e2919cd8ba8d1112659728df1a101a85b424c8345a2cf2f4fc643408aaa96b3e66c3d64c12b663608c2df7e282c77449772efb0f79658bf27ca31b9abb8787c20c35b4c1805d0ee9db6df6fabd3e8df4eb8c2b92cf57976b501d57e8404cbf8e66b2e1e090f1d48d41de742b1520df6eb4983775c56e0a29f8ad5d3882507731057a36546c7c934a779fcf48d57fb0bd9195437ceb6331b6232969fc41528a76f7049e90205c5ded13fc721d1719773ed584c8cef4c220346a4363d9186cf1be72d6470179e9341dfe770723c408ee68796fc1c837527420faeebbf3fc4a80a5064bd6a3658796e0d8a015ccbcc5e648eee9161eba6f7b17864afa7402599711b5e12a4221cfae809d54e9ae0f37b63b74193a77102f928c47d8e07f5be527864d4c69bb9e35dfa63a7c80ef17182c687bafce95008eae6f0cbd45c3e708fe85eb703f29056f0339e7c29552ec7d98a7a6142f083e8846ae17d1242af3c18d22e20507483c4aca528a91c2bace4674c0df68afb818a968023fbf330fc3582266263961830f4087af81263ab47cea15ab26e377f40c2542e55f3430058e7d8e2c1b397e805425d127d53fb33a03da2599aff28bb3875ddbaea4951180cbbe812b21eb9116877310db4bbdaf1860ba036b034723b184779108278b0a2439a1d41e95008486ab8fc3cbd8bc3c54a69a1fcfb1aa06df09a510c6aadd0ec7ed92a4c903189e361911e4b279ca5f67065d2afedee59d23b10213748f638c3427087db8197b2ab1d21f5ea859be30476e1893bbf50ca7cface9f786bb0f97e1c9031f38527947d1186218d185fa530c6e9dd06256d770d96ee4a90d21bfc865831165195170f3406736a706813f95ecb8ba8fcc9fbd60dc3507c0f85bfd5de5f61a40834404cb04237765b6d4e94b32f30f2664a3078d6f9bb38ea393906c54d85472ac0692615f1004e620e0f6c40aeda66611fa8cb8431cf4acf9cacae2e02fecde42d4e88f8821dd9555c2cabc1206fc2da747ff9d5be271057d92e5ea4816bd87a085fa8d80c5223794a1c1c75dd873f8ae43ce08534d8845de4b8f5defd894c9dddf7527c24840fff187b0ab09af5c72bfe6876c2d095edaa506f73343ee8ab2462388eb4be4770b3d8b5049f3cf87b57b4c119e74333bf859d112c7ede1b82f0f3d588f3566d0c5ac692c236d36f21d9b41bac3f0997a020586b231f3935564c6b453652eb1f73790f9718e70769b8df23bd0982976495eb96bc293e3537752c0c3425b81dcd6f41c6d6f4dba668abbfc43194ab68dbc097feaa2f000001b87cd982ad3112078e0eb63579dfdf35732abcfc5251011aff0733d190b8c93178dd480379f596d776109560791166d11a2068068fe0370ed0cc36d2a6533a1b81dad75dd2e4b0278517b5bff812f860f0779c1589d29857669705d839f4a7336ffb32925b04f0d5c8dd60ee21201f02280dc5e652e1d9b5c40f1945939b5595320783bf839adc8d9ad4a871935442d8680024de2dabee0f24f9169b8658e194426b66185856cad235d1561b04f58ee1104a86e3473fda1b87ab8f96e376dc8e3d5047122a197d73892efb9f1d727caa9a994e0d28271f5c503fbe4fc4257855d9bf4cdb228115e84e1b90bf9e57be9136dfa61bc0c672ae92ec81c6c006e9d3456c22ff740174c4b412ed46aaf9136e5d4ea0542a3120fb65249e2e6cf6a93acda18cc082ba1f86771aa3901b329eaa1d7005c67981f2dd57723757c4f4e769777466f92124bf33504d4a8067c62a28a94f5edcbfa95a2c04c35e5aeb1855b5664419d08bf2f1b43d39547e45fe140824a1e955878d1793262e62d9336d63a0dff054b82cf943ab1e56d42f683cca0d8621a5d8c2268e06ca73f8e988ee7b13ba12d9351d9f1a322bb2e846c96cbfc8a3fdf317f45ead54958ac5a6be5f325582c31631346280e971ec3beb9ce4e2642426e722aa42b066356f4f49dc892be9c0c9a3847f686f3b9ec107594c4fdeeec73d749a1de6a5fe8a8e2197b2cd70b02b00f826e77cdcf84ab6efdffd4134d6bc9dbf131177a314ad1f86ab15e0d2443df158b847c8c3bb843052840697e2a8722bdcec504044949eb3dfcfb7e0821c7da62990046d8b90e3b178e7fbd09321d925e6f6b591aa180310dab885afc00c5b41f7abc684f9ee3c347f4f31d8aad3f970caca9e8e76e194b649bed45ee8e875692073d6b615a72605c87151ce0a988cc9d7aab93f00ec54613069ab424b3e46fc800e7c6b7756e6272cd4fdc7616abd72e7836806c2626e3927d860db9c24e84381d6a48fc42646be46a1a94206b155b5dd82c3e7830ac16efdf39ad42591eafc5345d134fcbe7fe0a32a73244a6cd2d9d25eb55364a7a349860b56b354853216955f7036a65450573a6659997598be488999b933310b8e02d87dfffbe3a4d8de8bd9dcaf8d158f28cd8ad0d075353884476ccb4aa3657066509e05751501ad9e7bc779465325e0241449eab8322a2565175049162641b422500a410831891d1cfe28a91566e4bc913d5700c2ab89c9817f7103f2a81f38f649fa76890b129c72315332bdd009927c9536594b9741f65228593aa8936ee8d889066737d02740fba77d7e33f0a11bb357f793ee1d968db9c0a2eab7bf3113ace0f4eae4fd80b1471a0c10a29039d7b98a8a1f8c635cb0e5e85254b2a0962c0f97e6c4e3a3490d0d295ded8a8f3342b06d3e178e8e6f19400e43ebb21c2bb686a1c0406ef47ca32e3071151dd1128542f4793228dc1ec9d125d41fc0daaf58082e949bb735386f574b8d5ea445ab0b1ea7eda3b7506477caf113a54587892f8e2431b24b73383c287e1fe3a1248378fff8af82bac0af454ae1b810bb677e2f31027566cbf1baa8f4bf2733e2c6ccf72a0dcd8b305c4d7980b4213dad648159552d869c637d2b7c1d88b9907e6980743dc945c34e0acc5713224c6d821d75c1fa8e8252789c6e0bd6948926007b18f74767b816144e0ec1820247c8dbfe3dc876e41d66252cdad90f9a50d2e6ec778ff8a0777198f5bf46d27d6907e9070f00016b820d09dc51a040975ab84cb19e121428597fcca5b572727b10c5e041f6478638c50a2b61f8be39b9509a9250377be957817f76dd6e01bdccef4f0770a8bcbe2c2a1139fdef72a55ddb5b125cd21b88623ee9da6feae4cdce9fa41b5da5d73dfd7068ac2e872a34a1c6670c12ff2a26ee2a80cbfef70a1dcae1609323e3d20a664f8e7b479c9d0e221763a4561daae74fa5ac046e61574e944e2a20f083bf41cc1371ca2843db573208328b9c449e69354b9693e7b4ba2e783f1dde5ee030196b742c0327a7b47a61983b87cd89e790321abb38d6791cf1cda964821d79c02e52a16e9d20a2706604118cbc783cc15d240ce80e95b7a1ea72566c679163c22701536ab6c04ad4de400ae1d5bcd7960be350703e260b11a70e14d0044e975247263904805d503cb951945ccfffc176951a4637f7ba1f0616c6a996beb101cb029a66be77f2a3e32e508fefd8b15d168f37b67b3843ee8ab84c4788c283ac7215582c30836daada2f7ed93380c042e256b286146c428f644e2d6162cfd0ae97b0261c53365638d0d0846579820e4bb7350f82f535e966e2d8f700e86355a2eee9daa568bb936ab650418b3ef309d65868a2173201bbcde31d4e3512755a9d9bc3131dd3834b9a71bc8940e3a6ea04d657c42ef4ad364138ce29cfecc664c4607698d6dfb356b31c61fdc677150d0fe8fed972a8483203318e58ba6ccdfce4786d6c212106679f4fd2f84228cd272c894eb00dcfae8194e68ffe23bd2d92cd83f61195edf50c1a3d2c879937f7e68d8b79502afb33d270c265243e4dcdf5c4d35823df8799fcc5cc7ba055fe903c68bedb791c15a23c2cc3cb07b6bee0d635e1a1c28d3efe0f5b4966e775b152ff929b95689c922bda9257e026157ac9e1bb7fa35a46fdd706ba7f23c5976a2298bc91b9a36b6d678fe0b48246102c0ca4af9ef03b6703cd298e9875103e1d64cddd21376f129f82b3da746f78a75501d51ffad1c91fc8834084b889111b3ca0bb2449d621744cbfddc326e1caf5b7a483a713cddce4ba61abd451e9da1cf51bff2c6c43e6a0737c6fc32b3a87036001406fb7104d9c9f1f424e35a141054400699bba56ceb824cfbc9cc3163ed0f93e4a42d1bd61e4e9dd2e66e2d14c250ed9ed908b9b29e983b24724f9518bf5805e659e30e3e83416a6f1b7d80851b5345b926bd8147cfd0db3b3c0ef65c988121d6b631b0f5a167e7fc3ddde486748e776dacec9dcdcd884c2626a2ad803e2f89ba6b380b5668bc93e8ca3fa21d4eef2d1d60e9041ae637e23222fd7fee22d91e5d4957c95534ba330aee2b447d12aebc5466a5e827a3500e406beb1459ff05764cc691aa876ecca8cb0d99bdca8fa95218766f0ea781df5889229fbd31d544f2d40b92e6fa4dbd6de50eb79f36ca826a7994c3e44022ae77550a5bb9e6d9bc6b45ed6b3f610188aeb9120b00999edb7e16a6102ca01398ed89fff061df566a0067c85641aa2d7168917c3e95bde4db2372932fd071d807d80e7be394d31cdebbb21559d2d9e19889c4572a5fc05d72f68cda14b89a327788ed1896a6dbec1c476a63505ea17a49287324cf6399231b4788b13b5d7709b662c25e3e0613007ce5081ae8692e51abf96b536622131c37dd763f3daae70ab72b8473322c0f8c179e0f45c19880bff4ca26ee834af4cf5d0d312b2bab246f3cc05ddcbcb3704493cd45d529294098174aba19f508054f69f310e407d7a1de1000c5670ba382113018f6882ee9d556f08562384f8e3a294cdb88ad90d7053c3585973c6a0969a67ac84c94e0fa4b06a444a2e8ff4dbb780fde24a920b79afcfd5047050a29e8c7c44bb3adfc6df3b8c951a15cfcdcfd8fa053c0cee4d580af41ed06c5bc9731b4a9d342ccf415bec7d060cdd317966e28451ce094e934e94afc6fb8fd71efdb3da676e1c343ff5dac9dc666bab8b56459d18a864dbb67ac837977813223196e40e1a274691ad0d989f6b9b1d8db69a70d7e1532710bfc94b0e957d9afcac5ffa21abbd936e924608aac22965aa45eed9a38a05795e7edf764cdef1e16259463c93d827afcb0470cd84f93bfdfdb54bc07d083bf9858336e6607e1938fb46ada67d2f0d2036c6a6178c52168f8e9e470836a3e93f4cf64077161699ea1ae30e983347ea5283c079fed9ef66560cb9bb57b41d56b54450729b9e2b5ebad1bdfeb951b5644a279ef1fa51bd483652082e5e9345f87e0745d055d86c10478f3e8f081d41c9476cb8214dc60fa57c94ba11b493c169852624c94a026ed6f3eafbd5c1a3efaee58af055aef484bf7802f523ff2a5aa328f05cb3da2e0e67fc67ab34bb7f428932299cf977045bf532831acfcfec23d613961b7b52a1e9660ad7aefcf6ea08063f5a5c10acc2c0f00dccdf1c0c77ee1ca4091f0b27a154787ff72dec415195b3350f7ab3c23f9a9a2ea79c97d252a7a7720224edc5f72b653d2d4355884a39a00beaddcc272ba4bcd2aa1bee687cacd71bdaa391d4de96a05801b5fb07ba4fe2448453f9f3bb3806f9067992921984b0eab09bc7dc3846ad1017b45ad759af48f61357de9940ed3440d3dc96a1fd393600fcbeb46ff3da4c80678819c00ea788b48398a64842c441295979e99b0a82bb3fd40b4f2f0af9fb5aff73c71a8cecbcf78c73699b01527e591ead6772b8491c6435e3c13880e47035141516b25aea4bf28a5657808f567aca23b279248e06b67d9b0f3fc0cd69e4296f2ab0f31e07bb7068f6e45c41e2d384e53e03e64ec112fd7532e8d0d793f9cda591ca4ad560fb54b0187f6185667201f6cfec62918264de77c40c25d109fa9615b772a83453ed9ee708e3216f0e390cb68f433d5daaace8b3193ae86b4dcf9d2609ecf6761689fba894cbf71751197f4fbeaedfd5d73cdab0e966cdb0ac66e2c2b98550f023b6fb3fd5e5c9188d61e4c00d8733ba3bb6b0d2578c8c67dd6772584a6638ca63a96b77f32d5efa4ec646fd402734da9d247443ce1bdf44953d3faed5b8452e35b3f9f96268acc84d14d8e2eb71c180ae1a61b98132844be439abfba0ea28255bca1e5d469681b3b4c740095bb5efe88491356911abc804728ffe13a3b8d999063b493a07bd140175a29db4712a436efcb183de0c8159df8e531bfe740810ac5f18f267e222ea2e1302715d93b745714dc6ad86518dada923ef413811778766a148b406f064b5ea46fc947a56f7c69ac20845502ffbb2bfb57b1aa0065850b374c5e9ee0eee81167573089648b5704ee81703588e8e8bf385aaf1557327d9ff7a415dfb36d8377c4d57618549f8b447c2d6625ef5f9290ca8c42d6a1a443d1983e580902bddc58aa18dbb5596c871781b30ca3450aaf4e9b56f090b9ccb8eda105766673984aa0618258d8db2c5767f02d2ad1c2be567c40c6a18ea964277d61cfda9da724b75a6bfe1b1200975b6fd5ae596d6e9298dad4ebb9642f22134a5009577ce97c9a392d77285e94cb39a73344756442f04d89f6ca8aa5151c76a819600bc6998c3757dab6d738d425b8a276d1f543047b380b038cbf04ed281b20371a95e274b5b700dbff993b9774e256e39701dad93c8ab40955b7ddcb786c5d0b2ce78d57872a6b9f88030228d9cd8f62511b3e4519ee7d3f78e22ac485eea0a34125921db173748b875f54f0dd3cc2e4b3a6ceba64ec597c181547b87cf48c1b6a37e879dcb2d61580f5cfbb85ce8302229c70a74048195e11b52aefbf422f09a28cc6e811af464dca63331da259d98abcab0715174784ff2473cee26c0b3130b344215a81379ea69ca48803d335cbaeeff6dbc1dfde6565d338646cdb9699219178fa9459b5776bb30e19c88e10001c5d73e414731259ed7e81944a1c930db844e7806736677bc57a384909562f2d3aeed257b44ca750bd59e72a7dc0ad66f6060020222f4ae6f9e1fcfbc856d31d212a0f351bf6b6684bba0ca90b4fd713571e0d0cc2dd916f2c767c4399a504e85d53ef8827d06cbf7ff7aa2e6eee9b2140c31c8feb93e4fd494adfc74a16320a8de663e9d50de610de9cd277cce8661e0caffd37e8054aaef96906bf73e5baf3c9122274e34df68ab24c882fbe4f1da22f6a3a644e5a4edb3f6425eb0cd7a61e8f5bbc185ca9fc16321c09c3a5207a64b73ff5470940ba49d96bd6797ccc80070075eb77a0e032b479310b670fb50b16c99fefd21f8058f94dffc3b40de5ee092fa2e322e7e4dd318a6ffe1dd0cac5cc5dcff4b6d552cbf6d910a6a6b2bda675c9f1f5067ebb367d458403b20df44a0426fc724ee171fcc008e3d133842cd3ee957b3798b461f72b06717b468aeee0de0fc613fc946d64d56fbc52eee16a478a755309cfc872bad7d557716ed4bb97bcb61ca02a67e737a0e7ca361041013321d7d5ed175c2d93b3692a7bda0ca85833454d46957579ca7dc36934b9b0ead53684a998b1b354b76571578c00504394596bd8e569e35f4df8e57164d0603b2ad95975411fea45f195c825ed501aca14f43b4b3b78badeaae936dd3388f4af7c97266f690cc8d1cc06042075804f976fdad5dd8173962109b65f5cda07488661705f0ef0bcab05851f9780e8f2c3b9bd73d3355062a66d2a90ae489842c191644e21b440a6404d32abdbf8521e682f88b60033103fa607994053765f586807bf821f0c356307c36450abc81b1f63329a2bb38796b2411734bb297fd5f521d37cd0cf0dba569c37d7d474fa711844072c13ff695cdf9d0692ae5f4d93acd19d8d9f4cea6890367ad5e9b8b8ab1985fe66d5664e79891cdffccd5b098ddf7176474a265659f908e39f96dbf1f015f301fd45434363d5a9b20f9efded59f447ddf3f32bbe19b6dcfa6e5250cf5a42f6fd6d29921d696e45db0f4460cbdd8778c33c13e9b924ac0c1980ab703639073d43f9e8398f79e9de5eb0ba860933f80851d3d1742c821ba3ba140ccf83297c6e8b843003ee0ecf19bff7adc35ee919eb86079bcecb3bb4cf2e68c5bf994311dd67afdc122288be6ae635d7fbfc348cd7d7b50fd69b2a1502eab1cfb7f58359938a2d658f43fde7b09ecfaa6ab023a9b987c29b07c4e67e8fbe8d09b03670a3e30475621bd014941cc7d4e86aee25952c71d9cb24e1eb4ec4a9789bea5f7e18484a90df0ea35df0b95d8a089a0f5aa723e4bb6e770c3f7397d3e8f955b0bc1cf701d475467e82541ccb6970dc75bb4bf9f0484a3b4d345a2fcf6c52fa594bd4daa0a35f3cbca143ab4daf5cb1c83bb8d551448bc4c3daf19c9f5a11fb126094323081b31b7c4d3b3896e8acc0e95754c53edb60354cb3ad11294fcbd369f9e82017d9cf59070b81e8e3683ae1871ad6ae2cc2a107157213314c8595532a259dae8d4fdc45fb8758c696843edd0440d5c7f9d4f5a65926afdd2affd9ca76dfd8d7848ae33b515b2c7a2d883ed67a49ebb6c90c74db42e9874ed7e61d6f631c14a8a3657c86ae01014cdf5906663b8fa309e5395cbd03a25f9b009da4b61fdbbc28f561b4bc037226c69f71d8735984e41b0e8effca161afbe7ffdedef13df9709ef61c0fc14cdc5dd5b0a159a867ee49aac18481efaa779ccc0b9104796fa51d05a8ec5506c8e5cf643c5b3b1a5c6e085368a2e35020da409a0471ad81868c32d0d6c604bd0ec11358fe4ab13f1c10b334dcaeb775b98990ae2447838f439481f0838190ceb673441156c2638bb4343c426f1016a77b476637df5c26cad4f3b091d41011d6f2f4ec0a13dadbd83dfbd303dc7bab59a576c7fbee6c6854c1b01887600087552dba226b34590e941f485804bdeb7e1b7d083f8f5481a70d36f4a6587a5f61dd266f5203846aafe232ca99607043acfec6d95bee8ee116e122860d650b310c6fa222b86b9837ca08dc96c3f5569616323ce107e7d8aebe5dfeab147a46f5bdcc829bcd1766a461146d0d46be26b7480333b1d154b4f1ad001114d8a39bee0190abffd51fb25c6ba4a515a9520ee28323fec1279c0c16bdaa61ecac9b665342dd4cf6bf01a9ab1425280a87a3bdb5a9ce64300b052f4180eaa968350bb6ea7d06c972904a82e5d04b7aad2f71134050b343e474c56c6ca6c7df55ed536b07ed5db94dba2366f346fdef3e3b49de35422f560b00241b8de75380c81df0892e1095b728f3e9df0ab3a1f4d087ae29f3ae994354f17678a9b7314e166e447ed9f8b6e4cd9802f7ec5648d7475a815ecd77f07f09d55ed1bf0e8e1b6b4f9994c3b61b0049aab79ea3288a8a3d26087b3e8cf2cbe60791eca2c49b82806cc1fd5525402a5e81ac8ac17ffc432992c85c49ec938678b825059469b34a74f3551aaf2bcce78dcce13392de9c68753ae63aaa3f98d02d7e2df4d6365e839543d009b2bb82fc60f8cdce7102e38ee374ee49809b250dc9b011bd60ab78db8781a79664b92061a76e77a7193f1f3c7ea3b79b6dcc0d05298424f87336b098acd3ec228989a23df43bf256de8a4cf8233ad728a2795aaca782aabf9ae6595ed47ddebd240224ff8a543e9c4fc66c8e3f73c7311c325f60c916e5a0e7dc73337c04d85888bed43b3fbaf512af012e654b88bce1a14fb9331b079d7699398fefc543b18005b67c91c8f550dc360c33369ecbcfceb0cd3f3b1a6515d3284730ca9368b09a2b2c79f27270328c82e2ad34e516fda199ff01824b2b10d518c91c61b316ff309c19a15efea3dff2561167bc76d8efb9d0079c92d90d60a730d3cb77b6209d7adc012f0a973a96096bfbea5543d3b24b52f6acc1ee1a7b86cc5121c0def610e848840813e46c6a1173eb88dda185dd470033e8d23f9ee26eb0c6d4692f974aa6db3c22f60dfcab1eabf1d15b4db49843eb912bcf50942fe65cf8146a8f6c54d1d16bc0633573db97b53654e14bab8695593e1a16d29a6d99b1acb3d43be6208f33bb57bca6c89f9a2abce4015d8978353a189bcea53851cdc32fb588f077826ebf7eb1d73359569d387d40f21d8ab7b78aa6790f5d16ba4524fb11affd3a9705fa2129e25e8749145aa917814ab2158a7060819087e2617ddc0ac8ca6f83740c90aff3c646c37a4f951f16e5d7966f3e8386a9408aaaabc732923f122f058bae5d2d8dbd71bae24ffd26925e6d84f3c89bba7c928a6bdbf0bad4909103d1fc24cd5f9f13e9c3ac9b9fdb14cfafd033afaf3914120d097e6fb3ec394ee59f01aab9f21f222f0aab58fd1bac1a5340bb45f52c34cae33889120871d794b1af8c0519bf4b1f2ddd923ad36f5e3bc707f82c268a165ffdd608877b7efd528185a5359b8467fac8ab1d4aa07231d34b9cf079272ebf830416f75b0037dfbe11b3ef0c32afae02afa3afbffa0787c66c43f37f79b32f4630c6f17d0f2de5859715f2f48aabc88749d2cc9fa9a5bc410b6269938849ca9b26027d480b40910311b30081299eaa3775e98e79b6f284093ee76d4d0ea202af9e05bfa942a43e332002aa78a39d1b6eac5db6fbe3e4f714fbe80aa06e716c92efbdf467bd86e515916ccfb88b87d61f97f5d380fe87b272a5d104662e3d51becb26a26a71562a0ef74074add01e8e93b43e42b6244c70f592f33301289153ac6d9598b50b62c5e9c2c8f205d9041469b21722a93d1cde9c5a1f042359fa469ec199da6fefb711815d745f50331096fe10778d30d87c21dd8ac5acf2fb10fa5737d2e2dc33fe8832fe8cc674296e51b75062f6149dbbf4e2da8fa304a2713a9484ffdcaaae6ef44048441010d05fa3fc3bb397d491782e0726e4a84aa9550ecdade72ec0dc84a65717de6fcd39961bb542d9dc93ade24f08512ce5dd30dbf841df56c56909298d040f9bd48bbd5782066c31269ae95c9b199b8a8f3150932ae8f65e6805fe2e535a543900f5559da2a8a971f609aaa8e1116dbd192f7af18a647ef3594475003eeb42a5f75bd0fb19299c26ebf59d7b05e7ff4e9feacb91e4a085471c9e1975db5e6d4245056d54b1740911b7fda76ec4e8ffdd25ed584ea87042e5f9ab48636703121199a0430b8cd5fca0fcf15bd2a2fd0f501f85d320b111ba9d935e315d86237e0613c6ef208a3212ab7fa2704beb087b5ee3890d342fc7df6c05a82bb06e46f9052504e62a6a45702569004a7c9b2393e3a1b40225d9ebff4471eddef72513ccbda8228d368c206fd4d64b919c1a41a86e5a94aa2def58a98283f3cfb3f0332e63120c368e59e6374e74fca886ed5c501acf3556a79e24011b9e58ae2be143ffbce891b3303fd60b5b23fc5f64c098fd61188e9b3676e09c96dcd5bc63594b64a00ee6f38b7c4d7863b34e4ec2d6d94ad0209b76a5deb2764d8e5b83edb069fbe70b019ed039b0ef3153fb29bbfd09d5fb393228c4bd51bf12f824d27756bd090effdf315b9f52a3f2646c9651c6bb978b9c8be99ca38578f8b538ab06706dfef02cd518d791d89e65aaa2c5cdedf3dd026fc5df7a6f1ff0b7e9152174b9526562a3a88b7d5bd7724d627df867672bba6576ac34a7127a06334cb1fbcd8c1d0ef177d9e0c623f0221d7f3b7662c07f7228ee984ea6f0b4c9242611fd40583f9d34f1907688e7c0023d2e61d147584387bd5d795b9d74ce2c9b8cd572285dbd2e5ad77ab0f563f3eb0bfcbb8a2d86e8fb623bb2a1d67c4ca4b42fc5db2a85fddb0610f8919ffb1e4da9b51ebb03cc969a264efc9fc05a9ceb837068c8106fb1596a7e7a06fdee029dae3a86125c7610a93cc61d3bf317d49e128c329301cbdb66030739fe120c076af45d890c14db1cd47c28c8a7e1fbd040f7a74c190ce81c2fdc9b114466f7b92507229d53eb554f4c70e3746213ff6a9a282329f1ed49f280dc30676212e87e883a84e9e68e39b7c884953ec9ec282af48f4e16735ec2074c002343f569bd31b5fcf08b4acf022962d1c120093d9b2feff70628ef6138d2f344b068868957aed8ea3634608ae370a89e4342ba6ff5f583872d132af082dd8962050c76c9307f728f2532f5010780dd226206c88cec4bf7ee3437f1d97216fa4e4d0fbbf43f01c6f3fd6b38481b97b17ce1a882e24e0861eadb060cf6c48655d0380860d78deb936122d14b8dea75e8177f18f3becad879bf75ffca8735707adf202b3f9937b7573ab97d27df1745089210857036796c2d4a260b77e6c4719bde9977814e99739a8ed77886c62b54b17d2f8157324ada6c041f504f7c5f9d359d56ae523721545caeddeb79ea54e39366f4bbdb2c763f872eef67ce036074abd9607cdcbe88a0b8cbaec98811a90d0b7688716254a664571e3c3962b26da8fb01b80941b21d092333b3729bdcdb30da0e2de6b15b4ee3482e8ea2d93e3f0e2732bc143a9fdebe3886c5bc50243f154bf8af48e98f753d6dbeedd189836bc8706d7b56a06a7cac789992ecb159b19f220f9bc96f0729adacc59515a31f5d2b498029fa4e3ca7fda025a43976428bc0108aa7e6fd91db170cbba7757c17fd82e7e4d44d24726bc8f8f7269f76f10a44442f3c05723130103421b2a477d607a3cf415da7de030242f99357ef1295cf718f59f1960d54d113936d0e0d534332ae03c39aa2e7f5aae132d6c39549da283d45961e83139383a4af80a839372d7b96ac86dbcdbe99d92d69e4d5d4f70de327d2380f395f20bb475c8f6df4686ba45c2f6d3f17861201e9ef447e84db6c61c46445e6afdd01f493f7277583101ff09e0ed3060f9684aa1891c172b47a78d7c0e4c5a9473b26b711318be6d873b1645c1d52e01f6a7ff6d7d6f31b7db2e42e7648ec86d4e0d630e9fd867ec3becf5601aada4df8993926adecd6b89e03f33c972be49f2d5bf98bb7a872ae4ca26594457d8fc4edd46a3fd8e87eb3c3c93f5c34d9bde8b100a9a69b523b0671d607dd7ccb7c78f32e7f0b6055ecb0ca6b995ed8b2c1f548c092f53148eb00b51c20d4826c22c5342b023708daf488093fb5295a7a0f6a2f808fb4c6dff6f0c9077d7fff3855522503e4fc3e311cbce645be9e438fd467c0e33b20c5a7840ad552b77126240b481fbe762b9d1a830886e666ec5247e5263e1b24780a8055768e906ccce0d1ba2ed70220f8d8a70a59e1dd346e1bb9a7f14fcf392f2c72d8791b232e04831235e112b4f980ff57e6af3d1036f7580d54973d4426bbb7415b45863d8a36614155c4cc9b64be53aee6d32bc9c77926c0976d619d99e4cd83afe7642427e9d63df525a508fa7e7f7e71dcb929e3a53a6e9dce087f9a0008bc5096624f2b048dd6f0cbb1a2638350ae8383c36a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
