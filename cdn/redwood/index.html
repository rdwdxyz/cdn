<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"76ef5e2bc018d943e911bd4de3b408cf78a3f488ded522f869a0ba9b13e77319fa4db21625d9794b30cfa7fe8638d88d17b902859f4312fc52f3f0e6e3de1df955fd1300af17112865900a726a42bb389bacf96641a7bba231278f3f1e8514c9a4734bf05f13d8f3eb3dc21769c192f5b4093ced46d1b6c1a9aff96325181cbd5acaa25cfd2d662bc8bfc328d67f1655c6056aefe2df9acd25075e1b5bc2725f9915b7dc5e4b20dc603421bf33efd3a8faaaefe866d49c25b00f0b8ea1a58050910789bb398a70a195a94be00f1dc40c363db52967d6a3c9c08481389b8dedb4bb66af0f8853ff7affb408fb687aa4d64258310ad5c8fe0d272fdae6c6659372a29b05a397d44d5c344ce78bfb5740dd32ff3b2447129fd48b68980733859999a570f895f0bc9f67e1b9c8fb0a6e49ffb1aae5d77ed975501c0f5e57a947ca218546c5a9b45181c933afb3ee006d87cc7e1193fa6c8b884b71346778da54c3412821f67484feda3fefceeef7b569496576399ac6d12009aa42245c66e0f59fc4b0eadf972afb6cbed5154ce3c037c87d7f45bace7ffeb0a12122105fabe82ac1f2ea4634ed098755c943f4b2597b8447a19f03cbdcc56526a3c6c6be93bfb889ea29374f3e43be15a1372e7cc383ba68e8ffc8891c6426ca2323f228b6f45e0cf83453f484316759faaf7aef22eeba6a19ce4333d38f2e66fde5d075b6157e31e6c8fd1ba286358b2fc0f4c870245ede82c06ed117a3fee1ad2b508b1a68ef83b4cb5c1c8f73feb8c3b6e32228a134005bb25c79292fcdfd8baba7005afd14560dec56575647d598489d3f16eddbc57206efed867c69eb67d3cf4d496f868c39b65c375b69e687788c06a5fc61f8aea5ec35660584d37ffd6c30ebacbf5ba4cd2a11f6f03ffb1c18025b869ed00f31efba25843c6f3f206fd5ae84d16de8577cb9aa070a25297f131cc703d026c70793ffe707fb2afe1d8ac313762a13907667c2c27bea696ce15e82374104c1c05038424d1d2578fb0029937dd9b60da047c022a139383193ded419115a2a8d04f1d7a0ec5bc4bf4d2f2ad27f5534f967d90b3822740fa1ae2b0f16b9f8bbc08f6c09a4bbcbdc4486476e2a7738ea9b4ca47eb3047ad8b9d926bcce1f724b9606a2540bdd16acfea06f79aa8a44b4fe0b9bdc8787f4a2c9fd9d9c62472c7ac77a5c6f2abcc2044980dceb4f8a89fa605d0bbfc6a5d31cc590823d1584a2fc1d8a3b1889410240bf5bf5512eb1345b04b27ee7f03ec4b9d32e02abfce1b54dfc35b94ee7882830be49e06ba3dfa9660aa7282639af927b40b6795bfefb8d5a2d12d348178b917ec6da057bbd77b262c89c74415756f594be36f91def942bc91153ca7bd4df3d1719a98a2d001a11125184d9d27aca3b6f8299bc3c22ea04b96ba0cb06310cd95836c72f0a9e4733106ff18480a4591776d00082f68ca3239ca5cee9a0162e840829c1cba8d55471189a62aa2df732e1e455e20a33a2a8657b3c8d8e5e0be10cedaf2379fb20ec8ffa1f25feb52a2530ee5b393377e68bc2a0124068cb988b16dfaf2ea962a882076afb61e9dd94d26b2cb599ce73f7a86d6d1151fda427199f3846dc631b8211000e146ce56cb9c8a58580cfe2f451d82255e9207b466a4a721930855bab1b7dc2f071def4461c9d72d316894dc36682acdfc5d9d039b70170c067de86554359533306e7ecdb1e68c12cc446ea68a70a4be2628509a475b42446bf8f9185d86f83c564a102b508b42cfe311df0b753c7f19dc2d9d834e629f83038cd6471d3ba4d9375f1023813da32e91eaaa7085cfc0581c14f8727f8999ab5a9f3873e11c1b15d2febabbcfc19e563eb14900f3d51e292dac8d1ac7554ab76aff16677f524fe7e13c6647905f6f829f84a282633cfb5c3ea5e14a1cc087090c5e8957c15ebd46d1a5566b136cb2f4df36191a5889b0844f3f8082fc47c8151dfb8015b6def14070e7716fc6454358e149c2ca947db04b3d7734c2bcab4f9d8e512db2634036d6de453d0b87b4c18dd5692fc779f28c9e592f32a6ef6e717119df4b2c357493772300cfde4c59cf2003c9435dd9abeb0a59da1919d3210f577ea30528373444ebba62d1dcee2fe829be99b5f4beb79cbf592eb33b734c22443e7a6930055e9c5bda9cf6facecb93751e1ec13f1911ba427e66ef08a037a37c78413b0b6b995ce9bdde2246d76b270b8d2aa13bcf3b6befbe26e2a904cee9823d9f0e61ca22b27556e05be46b9042e01b2976761c6c886a5c791ea3b673820abdf2ace624e9aadbc9856ea92cde2209720d283c3f19b9fe382476f80477186fb09c5f6ee615f70dab0cb227b1ca049cb435995a9d46e6b82d476ea698d14b887f147a38bfae86217121fd3dfea61089fc20ecf40f8c03f3d0db262c46e7473e396e678fb5c32f75cc88cd32b1454d40ca83501adb3beca680218de7c0a30d822b85a9c2e94446bddaf85ac1e54b709f7d7925d0fd44f6e44b7e86fd6a1d518b946af7b22acc078720351eb32b0c8d22de697309eec71430546fd7d85395b0adbbd6c207e415fa6f33b4798a9968680f881dfca2ee759528dcb232eb555c2e6f65e1297ee9e84894c2f7e6a0efdafb0af1c96c5708b03f84fc3c490a7aa84b3a04cfea572dff469994912325e92ab9ba2b0d112d9081cde83cb45f26dae53219d456cb58c0b4f6de21bcc08e2bc4047f572db2193e9f96d39d6f1afe7501f497982e662cfd425f8b43a8d30669a097fbf2b8299c997f7c8c3c10be7ffc3cd3cff1cb5e5632c35064e05d379cb229672816c9bee3dc57aef03ec38845a2de9bb39d473f41300b49da7ba23a74c8eb0c7fcaa27fb103c6bbe36c4d29a0e31b9fee338ab9ef244ddd88ab617273fac1fe47907ad87ccf64a7db8562a503c5c1279008de9f4f8d7dc1a0f87f174eba222c2cd8041168a27bc0e4d4bf6f864a3786fb93d35394217c258577a134c35d4ab4eb143b618c5e89afbd2b425f6f52c0e689b179214aa2563b841ab5a02751d372521a4274e233c5a143c24fbac843418dfa19335dd4b3497afe6f3d90c245bd4af413d3b5b7f354e18c6f70d6113f8c2302e768e62de19937bae6d96d489b20e968248595172f9f0e37abc51c896ef6295be18665a35b6adf103cde8032fb8459b4053b33b739b91b3f2904c3ee9a02900949205d8b6f767f79e6e39baa3be4f220856273b5f4cc61dc10bba2a554b611e8b4884492dd18657091eab4aa743a94c165b8ebd747cf3238bce4e47c2883f6d6da098efd36469a8e518a8261dbd14efd9d94c9cb59eca2a6ae26f6a402bc2de7a32f2678650a6f16ad84d6aca6bf4fa9d736322a2869172d21ebe61d649fb805217656df5d106f3593da9e9a1b503c89fe380430f1afb7b51aa7710ee1627cc73a8d59696070328ff88857284ea721bdda8d66056958945a580a06ef85a2db7c2ea4d72416cfc562b937cb9cc45e767b6e07324a7d75ec2414ca1fe086a632d16dcd39130506b1ddb285c7ebb9b90d1fdeaf5cc9a7744281223539353a6d5afddd102479ccdcd070abe7366e68e4bf1a1c8a27653873317a7018633de744d273330a773615622a5ece78881b5f96c5f9371c5e190cd8a30c8692b9c16342c7ab38beaf42930763175bf5120444440b10ac53fbb51814ea726b448c22ea52467d29683725517f37ba3289754a8ef7494143064a62737edc9c330b4b91fd82a3acb08d52a9c6db30b8df39e96956969f902788fc0d4fc3f789c84f68990944a95d03a59861fcc5e27f4a9f3c385626682fec917cf2861fcd58e20a58a7be973dadecc6532c878d0d6e157510193d7d4e4b4c804ab62830d1c714e5d383f2df31ad3357711c17a1480aea1afc96aa9290f3dd62b872647e64443b01f301c4e9590e1262561a51c443437c7926dce5b4c790c52bcca2758bfe74dcc63253e3ff3158a3942665aee87ddfa3d43a51d5a0ab143e1899e88ee32d52bef20b1935b2768595ffa8aea59acc8f2eff3ddbab0b923f2f6dae6b7ecd1a6c99fe7ef6ee52dae8d8d733fe50452ed5b418a51c5bd11c29a46dbb3d71d04fa4627039563cd226447c99533bbb6dca8b54ae7f21584cd441be9ed568f8bb59d09dde62022ed3b828db29d3cc8242540d0b7094f56cc45ff1b0ab884acb1ef5b998a2ede183031a63060017f43fb7cff2c0650ae720615a84437b0dfd49e6a3e1a7522c2f5a07b181a85d12456509a073458daa555ed240d31e412c0d4fea8e10121a440284ad58e6279478263704b372f8b0950f9759ec9974599849909671f92d091ceb2eac846b78670bb931e0ad577c9d0e91d0f2f9a1679b6f55d27ea77011b5ae2999f4e9e1461c0774f18d34b0859d0da9b545e975e74b1e0897c68b0e991e16b0f3d176cb694d8a5f7768fcc759a310a8b9fcaca80725a9558b8dd3f26009bbdc717336135a8b8764416101169e4c9d0e459d4b4c3c8c9a589427f4575d389ef48076189af4f860fe3e6905b8ef8e9e422f099070467eaf5a9810efeeb2b9b0aeea0090b6debe828d2830423ebe28b557c03451d9e7c1445e29ccdcb6353d11d78826c05e4c9a6c5772a34782688f43352f1cbe936045979c9e252e237993e6f3ca6cf23b0fd2b4ba8b48e622612e89d4d3ed5fd9c2b99937fdd2025cd5a51442216c90131c24348b06a6acb05f6d3787c254a0e8ea3c9f0754e7ddff22113a2763b7f2aed7f072d586595d0d00eeb0b6f67c43f3d60937d4e477357642c8c84f94f477fedcbd462dbae2f5b5b7d40e79d56849c119d34aab94b0b332d0a430a9b8df9d2e868d28ec7f3f90e10be5f0ecd713175b5f80cac11daab4c28955b7d4154730326decb8389b72d2828ffc26b9273243cfa15a410c14ce197c1cea02e8c5343232582103be35afb1679d4511b4e11f0d0e21f1fc36fb0fdb4a7961427becdc067ea5635e8f0330c62eec14b8eb9132a178b7e2036aa312d23cf417b8c50e729ae97a4b404f45917faea52e185395df50c43ddf928d46bec3b4672f32f9039666f088da787254ab8635edfe03c17aa14f6b0a08d6c60ee4f6f293768a693a532eddc98c77171d1af22a1b21699208c4b148a4fee78d129a8aea46014eb678f5953091c4750ddb330df03b377391674fedfeff45a7f2d32e5a7545ef3870abb0fc4965c480c0743d09cc95a709d1694f5542548bb9c9c25c8b9a2d5a028d085883630ce4585a54a22e51f66453cb3ebad3f78eaed050299b6f99f415f410e7323977895fae148158ef1709d55f7c6478a60d9a460bf1f81c3fecbc05020e1ff7bd3b35f33b8b7a434b599055b93ecb222b8df1ff9471fdd46d126c32d99a6b0a90b323edc6947507b71f014ec86b37af9f10a8c78532bed137f248c45212318f40e0f0f6531b83d7f604b773681764df3c19959efcad15caea608743282d7faa2d3a13d795debc54fb9b4afcd83656945dc83e9ba4e52dc01abf938467ea2159b0da66bf5774524cff191a1d2ab2f99836cc23b69e3e87e247613ca67afcc62355cea666ca344d47244d073736826b5be8cb9f7596bc96b28df4384d4c9636b24e9e4a176709889bea0a888de12358dfb304eb5dfa7420854ab4d4cb459bf5e1f8aa0fd186a99d1b87c4fcf3ccf33f8ac8631ad3885cdc7150d66985fa763a2ddd742328587b4ad1393aa037c07b405283e3cf7ceb729f0ce8368af9fd3ad7f76625cb616e8327bcdaf405c913d916bf0f7dca7790a71abf4745a13596b46e8534cc44b64fcaf650e74247b470bb06d2797bf7546e077535cf6b71b2c0e0a34bcdcf8167f8dcb0780d78561b534a690db9b5b7537b027ed4f41dadb23665381d63baebdfc38c0ea8bdf5c2955e92e020a34bac4a4ba330e290d30285044fee201f485628c1cb82fb10344722e0a5ed15400968ed61869c8ee28c848ba540595fdb890a4d13edc4a3017a7da579b5357e7ded96adb3ced028d580af25cd44d695d7c307ff972b5f51f76e7592642febebf36fc636f62f5457337a13b79abc5229d73cb2aa7c347936673c7bb3fbfcdf2829fc820d8e890cac7290da96e4e06e87c6297d4fcce578bd863d2f758f290cb209212f9e709cc7295c98ec4580112b85382d712802a3786ee3f7acad6ef97093ee7bd2eb64ba79ad9ee0132537cb86a1bee5e9ede430c947a7f1104fde4d109c447605cb23126a702052d930ca7d9e920a4a5b13bf932d0017615abdcee66178a84ef53f3e3ac439ca27efb8e51f516ae13bbf1daf31256718f032da342a9f71e8ef77458f9345d5c568c4b9b7caabbb17254d527b1bd2a75870316da654552749401c4af5a1ef77f53878a05d081991c9a5ad00b193c6d3816086ab9a06b68d36e60db533f6062e4cd0545ed0ba762a47d2451ec88b41b44b03726ff07f446f3d365b978ad0abfcb994ba32a665b351a1065cb55955308c62de2967a620910d1ee0a4e0bca9c4c6bcf086ce99be8c70a3f9bc11889825fad667cd2aeb193255dbcc86d65496e1199db8241692713bf4869139909410493ff2289e69a94e25af1a0a99fe693322a84501b5faf02ec2e659a13ba727cc1f9dcde81efd75c66b3ef400488303e3702e20f60ed23038fbd7b1b0bc283c2950c3e031e637e5d438513373b761882a6cc19c6f8001413149445031684299cbf7742a0e33bddd07c049f5b079c820ece0135dce11bbf999d40bb31ce8b9e1d7de434282e5a181b0e13823439ec22c1ddf62996b8a57dc1718c4789cdc4b00d3098f49c6452c84ab69c26afad6e65e56203abb2616aa2d97d30f35f6440e3b95368f9ef0280e685684993b5989f89492a42517065b6da101461a7af3cdb3b548a01f928eee762b63f164ff8ec56eb1262f21292746bb14ebe44e4e23fbe6ab761a027ca625024e9884515a4e7a2121df004e31fb26062655b224d4c3b559752d903c137a7c7981763ce090719cf0bc0b3103cd9010b6d01bd08d449ac97a79a959a914c98a8506082f0e0c71d8bb292e160fe2bf49859e9b396457c8ac3b59fdb9614b011bc4f40ce855346f5701e2fb52cfd1e16cb0b3aea906e14cdb3b8229666f091bbef3b6f4a97e2ea7812fe36f6c4738d09d18eb36fc55ffa8409097a9048a3a4980a640f924e721a7e5a7ad66dbc6981378e4e3a2fe41922058d98009b31606b781dd6b0f700d2778b1321a9497916890fe77b1e16c34708dcd1c969301b902a803d24a3228087be4b0bfd78ac3acbdf95a2f9975cac915d0503efe72a352e79b207e0eca3a1ffc0a58dd6557778a5c5febc6cfa43c76f283f02c340bd1007082e98ca062406b0829b0acb569b4c985dfcf5bacb6f1f27e6eea6525ba818c6605f33a6d40450933c44676189cf1f2bd0238637723ea16121b3e6f23519306cc1fc614a1121523d7d3d9a73adc4e42666d903927fcf97abe55031afeeeb23cb3bf0f8ab932d77e571be67d67924295d4c0eb5435548a19053530cdbe14c2c63218fb8a7ef3786bedf59471e0495534184d90fe6ab4c9ef8d8bc777367067c442a04ab29a7d83c5d223b12e86f74811c693e5fd5bcd883365718351c2b7eaa422330cfab4b535d8e35c7bb2ce6402bb51a4c2d630b79f56739f22a0e6e67f34a66f26eed9d1fcf9c516acef3ddcc7cb57c18e7e1c000cd02193f54d1d77667509f81dd4bff9a2ec24a3ba195375774c7d3e6007c28d11f7fd05d03941d07d555f93722f4afb6df6a166f110d706e8f878303a99e98b95924d2be28d2a5ea1a18ed9f7f2c92b428a41596e0aa81f3d6db2a10f03acf8559182cf10b19b21bb1eccfd88fd5d8a3bd44b654016e43c063d707a59601aee1f1cfea65f67fa0668769f932a5ceb0558c1467cbbd375052dca067e63b26bd0b87baa8424562f48b20eac35393351a773a149d2305d46802b50b3d779bd404c2c44cd56bd163731ff3cd1b2523a468abf5231425fbd0bf664d96a9ee51063e19f027bc782f4ed21846f8aa4a2bf9c7bd705c03162c626d24a903b7f90d5f39c64fb455a5b79e449c4765eb88a937d40cedab8374f120c91f967cecb381a9c9885ee6ede09c375c36649b93bf73ee259613dc8920bf02cb0b0889eb77e4781b3869f85ed7200644614abe1fbefa252dc3b88924ea868b76beab0b4b479632e1b8c8155a82bfd80d3e425fd1739e5b3765360e42db2a87a558c6843d82a51020c3a4c445600168e6515702bcf8e098ff0799d437049abda3d0ecf2d1e3aaa555f85e359217edeb991c16a5f6f6dbfa67d1c44233ed671d9add1b817d566ec9ed2be6bc3b391d2e2b3c51e58befe6ab0d04a01cffe66041cf9b0a02efc4e596ca06f0631121a9f87dab4802148f350296c075bb43f05dabe350ce627c15920e58cecb45fba64cd92227dc357e56e434a2f6cfb257fb170cd831280667acab20169f8b7050f1000a0d9084a2223400c41b494e1298614769847c6ab6d1ea9625257a638dccec36aa7594facf087993574c6e36395a7f4582027b7065283c98cc7445375d475b2a9e870f220bf2a1b03aca3e1beada42071dcaefa1df5cc0cee9098161e376a88224ec73e101a54fa88f292c32ee04c852181240965216171eeb1720b648c51093c69ea2a8ca9ac50b87431a0ddf4489e78271f6a9e477fd5cedf8dda5065a4e5651f8bfee07265cd9bc1203642a90e02eeacbb87bf7715f9010902d9fdc3a0ec0bcd4a8949dcebce0b2484f2ad26bd92f060b9affaf84a5568beddb64f843d8e50c0ad19fe1776a3cc19f3757c4b30b21d41f5877a2321dce911d90ae7d894f4075b0da38c2808ca1da6144ea0fd056bca09337998198e7e825168a585e423280060c6ac2de10655be7b78ceb1ebe456f5fd8b1743f35c9843406c7e01d33470d2d048091b97f4294500e3abf75aca348d21a218b421f6ce911c9e590798cc8573f49d99402b051acb040b15806b43f04c0e32b6be421f6518d47fb9106c45938cc5621897bc59743ac8e1af7130edb1bb0d70549a6523f42f82200135272277cc53b4cf9517eea465098bfbcbd065a1898f032e4a5010cd5578d7537e9a452f01d61b8dacd6d342d960b9fe598992e2776dfac0619304af9dfe4154cfc667572d886a2dfcd364b861e46e60ab7d8ac72dfd6e2f12e922e318af2e79c406b3ae185e067ae3bf79a2246f9210fd094f1985963f21b71cb159318a6dbcbacfb3fdf807c93d6e302de4ec00814d627978000f426f66b78a765daacec0bb6605a1c295272ee1f00184d5ceefa4bb0022266d00de2b629bf194709eadb2680d96c918389caaea68042ffbdc82afea81e2608b4cb478fd079467b715e83be19fbb6dc8ee374f3cd3a60dbf4bf570b3ac0aa57b236e7154881f23bb1047262674a6db257cd6c36c5223392a79a4aff44ef41483be30426512985e021bfaa2a40c0acc70881d929c6f055a0054fb859dc73b2d0f3334af967c947c08e3f1d6885545602216e1d6ab6046d986e2642d4ec93d3cc43ce1b049d1d672e6529d92cd615a1371edf30ace0d8d9805dbbf1eb54f803807cd56b744e8d253cace4b9f6c65d6317f2151f2b4cb23d20d5125e88dfece1e5bd47c36e2a734c37dfac0d13d59966ff9213e6a1e5753c6bbb4dc684927c8aaf4446384b4b867e2b7b0326d78ef7f7fe0be8182bec3e67af77b9a20937f0040a5c3e3f2c7cbb30a0da74d71a1834459c66cf374e431de875ddcf8a116719727869a9690ff996d887a68b7bcf475532313b2f2a0471b4a21e2a7b313f8d9b9bee83aef4516a2ddf71711ab9d48459f9dcda99ffa2fbd85ccd42f73556b9f3ce768d68c0ea6a4ec01df67215f4c1e5849f5ead551ff8243cbb631f010714be76f590b083a03393666f6a2dd2ad31233d4ea0ecfd9ce802e589d7689feca00dcda575be65d3b939059a8fa745af601cc63a426c4bf340784dada0fbd5d7091b30ea06eddec1857654c7192e489fb5d608a39e74ee1244f240516b9c2a94e13fc45ce6e4c8cad025e13bbae774fc8ec1b96d2ff6db63d962b9d71a4772d5d63cfb781b61112b912ae81dfda540de3f1760f6b786a30029c6b87a014a2f73f77971bab205b869c0849d142dc8a89cb1e68c346bb9e27f24b30a56947fb283635b6f3802063f463eb19c5fbbab5afacfe94294d6c749d72c087ca631569e92333499b1177b9af63c614f27a0069a707471f9b8157fa1b2a33d186ae5e1b47a6130aa95b330b2615db0edfd2d5a6eb0a0b9f92214c78187a2626bc50831c26784ba8cdb5015a6a0e45769a8ad68f6176115c04addf838f31d403d3d37d87d5b8351bdebdf309f37fb884ce16db5242a130f671d589500fb1bb4e4c8e20d231ccbab56f3b16df2139925b773b5c498b965fb9a49ce93e680e16a09f055d45f3fb7d9cb4dcb76f4a0c5cde199c0823c0d10342771f5a9d018c7d96e957b821b1da5e681cbebbce512e002a045354cb1f9750366ed952eb2dd0ceace75f515b7a31df277efaac35ce894da029f464256f0f00276227fee4974f4c906181eb20bc4ae8d054dc8ae7124c2f4f024da3f30067e1c191367791b7a2f6670517d8e424f9bf4e6676e7a43b4715df21a4a1ce33d94511dce9dc2e74e3efc6a5e4644b0a0ad9fec0ab36a5cad5d277c70a4745dd3ef8876abb05951d88fcbf3dfd888f5672dbba4ae2d574e0ac1ff0ce27a1bc4cdfde9b0de7e47aad289e5900673c1e0285e1ab4b714fa1ce57537b1b6ca5d0037cbf803057f8719234cc402ae9532f1433e52a7eeec0a93887a6d2065c0c5ca30c48add36906b2f89d457d722934fde28777134e7ead64b41fb494c32437ea848640dab2624e9136609588a440e0e66b009fa29494d3a679ccfa8d84de62b8fd07d62ea2bc68609c34c7354bc647cacc7d73cc6f9b58ee1d2039fa02b27c519efc239913050a26304644db004be7019887635a59795368be8adca11e230e84922b3e93ccae8e00d4dd018250f25e8afa01f5e65f2c26cbe8a2890fbcc9e696b2f4c4c8ebd0c7e15fec867ff6379b665d32ca6b6f37ff634052d834f397bb584f491a3d48545e48c447c060a54769e88c41aa14968a211779c3db6f6710b696fd9ecf6d3d270319b585e6f339bda8ef04fcd7bc70db1d1cd70c636f5758cec3813bb5eef8b968278f2a0d16886ef162a03afb2a8eb062edd01501e6e1d72c6dc5844f2cc84c46a03a89f9745c1939f761b9cf294bc2d210b94bd5a06f2e68b3ad466cafd378bb306d5a240ff979f44b680b46eadf0ab94c2bef9997333dce9c3a15bf191c95685bd11d1afe4c91965af676d30720a2da43f433cf8afea40d828d95e9f3da71846ae8c081dd522c820507b553241ab7d543942a44366b1769f8b86235644d0875de9c97c5c496bbffe3cbac687c7a397a2c4ee5a5c9d42c764e97c7c8c45846cf2de8ad5397b3129c0ba919d39e0e99570875c178c06a4feec61fa3a92d88dd90837d624adfce1900782d6a6af06ae31a5c6cd3458bff8c3670f1fd5971b061ea1531b528c25e43956110403790f8c73ad0a7a025856d30bd7154504b0b498f028442d3bb24fe9c7dc5165b03412f05580d3ffea8bd23c802c96ff35611179e14269150e091d935438222720a46546bfb28ad37c448c649685b2bbc85e5bdb4e869181b9fa807a2bdf9078d90ce4c22efb4262b841570301e01db24f90fd9bb9a7042ab9e4409936d858ac52bccb6b68fda33980ca1af66d2e5991b9d083b97c13c8f3abff719686ff72885e9ab637720cadba505a3abcedef7967a2b450dbfaa88a391ef97e6f2baab3b7eb57f36f2a84f163e2581f8c6ae58ca7270a1e1855e266192cda3a1caa31ad2762f8b552d92f7c4b9f04a0f00b3a65215e3eb44e64e11d565c4915fe54191a35ad671fbea77198d6adeb3149cd2a348b1fe52dd9f3df0ecabd744cb89c8c40e09b7f6768712527e055ef53a32b9ec71e35d8ae4699ba400acfa57210a596a84e1913f041b41dc39f7dd38dab084198899f6d81b6e162932a43b902c432717b742ec078c720ff6c1fecc5ae7adb938425eb23cc69ed62d42db86a6c2be643a54481957787cb2c2bf99ba005d9b531880aa28ea006b2b99b4a3a94489bea7d434ed4fc68421c80adf2efa9191fabd8c9d0ee5424b690062cecccc38c6766247d10f06d87c83ff1d5e2583dcc0e52bba9d9f9110f2909db808c44ed3c1d861ef298377e45d8aa35e6461c3d4c82670cbf09d02d5128e094dd532f1a74ea855e15babb6c1b3827e3ceeed4d7507c7330c996302cd54008e241b9637b7bbee772db76e728aa3546f7ecfa0721ddc30e21c4674c3b5819afdb53f71887d494d9e3c6b33148a083a2384e4d4f0b84ab2859af5c5a38b15d9be3997e29440ef40e89cc7a4355188095c86c98187735a8f45e034ebcbd8171f8b185a0738da20d7e3513281c04014dab23f73e5513240617ba97f1e152ff3e471855c37c78bbb403b7e30523c698a6258a54f4009ec34bb6e079011ed4a49d89656418b00efba43e7b03b25e8e31cffc8f518f5a8551c8eb26944caaf5f2010f26afded1a65abc8c2a307d1cc16fc9abbf722cfc050c2ae1a72194ad42a2447a52cfcf66a982c2e76c52aa3c01e7f22af0451a069ce3d21cb3284dbd9f49f7d625eb974bf7eb67a0236f2b98606796c26f5b2a688593a9129ddcf0a927f27adb96f7414179a6913ac68fb7ae941900b195b1fd45d2c97ea3ec6fbf52c4f1e2ea6314a5a4ee55f443df625e4a994b86fd66bd47bbfe492b7baaa3bcf0a347dbbd9d70a99cc1faa82f8819ea35d70a5491ac29629204ff5b7b9d294beb70284dccf81d04bacd9a0be0f39cc101d5523b0b24e1be504a1a93175a6ae0e22f8fe3f45096eabe9dcf0b115c5c07fa7d854c884dafe09d67a9128b3733f3a6bf6e8afa0b3aecafc8dfd20949b105980323baeb39ebaebb01f1f3e372377930e93176c7bdafde8d6e2745f218647072dd4f5fa85c404bbb8d72884908fcf645f14a5304974d7b28824fdd334151f26a0fcc77b9aabc8a2bd6e3abf7ffca6b0737e0c1be8ccb1dbc53252dcdb5de0d2613270aab348005a1aacedcc8dd09d4e93e4a502802eac42126270d6ff4cac053100d41067c6bd280798230f6cafa6bf3b68ea37785070f0578aa7e1e202150740602dd6ab441e1aac5c9d983cddd02f7b8832777eb084a216322dbe04a5f9458fb9b753a2f1b47cbf6bad59c81fab9cbf108b468bc516caa5ceed3d8a711af5af8100ea96c9a41be54a38b1d0504e5e9fecb3f2873448b593aad66e6f8de616a49b58be575ce0f71861355237bcf98cdb18a07d4fe593ce3e8bef6e8a83c74e93c8a030a7ebfb0f12f89e97a8f75df604c2e8a4a024d0a76810a00acb6b912483ec65627711483eda3577507a21690116201ebd38dc2d0901c06ddaa4e5ad5e5a54dfd8f129f161f714e1219f88f309f09fb37098d8838b133a89263bd7d147e8bc0a5d9bdd2efe2a66aaab00de587de3148996084285f82a8415a37831d3e72660cc84ddaec54627502a7cca514917ba97f704544542d13bd776bb176b206b3d08e0f837b96d64fdde534563dc716e0cf9de88294f15583fa5ac4f778030473b2d7e06911af5135a208af2292f2fbc13713dbe6646502f2fcab7229b2f0cbbfd75105d28b2899f7f41cffb65675c8f3a6d603026ecb45b6550271e589342f3e8a8e2f900b99368a7fd315942cd3e456dd96332d74ab18aeb5bea7e6c8d2e5c1f59301dcb5d566d92883d566d73ec16b6a782aafa21cfba77e3695728853445c2b7cac7023c2a00c650986d611c1e616475febb9de8dc377c7fac9f8e8f51f20152a6f9e761008b576c7665a7c0d8aea39a0062058c13cf936ad64365771bbda4cf281ee69d2498413a45c87cba6367014cf05b6aa4ed890f9b4512054663bb680459e9b440afa1ce21ef4a622a24ca922e21800e2013caa7d139b18e46df11738390976e3482dac8a518d8ef039527a5f81e160e87b1db26d36c01816fcedae42afa806fdfccd8917b80dd517785199b8d3eee144863c1c530fe3e94e7fbd157618e471881c4812a6f49c2aca592a49359f676c3c8f5ea3a82ed3354babe8582b5e73e4ba37b4dd0c2209e5c3d06d95a5e65c52e742a4fb231115a1452202be4aaacfe4c19468ae1bb75f4dc6c246fd3884fe8f9936c707c8bbb9c7f9fd526ae55e32083c8e35ed06eacc113de480f93eb263843d4c324e9937d8c1205d4bf8d17fd9193d3db6535ab97191478642eefd5f1daa8edaf233e773d2b08c2b88dab5152e59a47a98a54c7ef847da9afad60c2a48df4c3049fb7901ce5716886a0a1e006e097caec2e07049000158d909f38132df746aa06c72bf4d1c371f7879c528d8c624ad953e0fe627a1e618c58e0184c1ba21dc8fa5d77fe204ec5f3c66762c314917ea831dd7ded36337b837d63f513e781a303bfad7dc501b9d2b6dac9975ba6cdf9406cede4594dce83d62f0ce18b4d17a3e191526dbc5230d3c7853871ce7dc338a52e725231ef5d527d28d96f3044e9a29188ef1165db901fb9241b01243dcf68efa51b78e363fb7f3539050b8d9d8ac87344db666c7c5b61858bf252fcaf6348a073120e37f068ef97267620bf28412c3d966c110106d0e13a26d3e77356ef91c698700bed0da672116cab50ea87f4b216e75d51a292ba32902efc6601396e72f9df9d749ac8ecdaa74cb19fb7730c7b681ce7a0624a6e0aceb7023d7d0af0a86332fb8ea5b1b197ffeef7567b7b21d94cf6223c86610b6eb0b7e5b00be9890d7001b8bb9d5254267021e99af2aa1728285e783ebd6afd7df937eafb97d24f76c262a1986a016d03e652e3c3f4774da5549452194d2b739242c6ba4a7c50ab86885c203086f42e6e7be54a4731b516883b748e34e19a2af7367397bc7f3b98bba29f00346a9f4288a696e91d65a01b8b72b74492de498eeb3227ad8032568ec9f80fd8eb4e92067d6a2b8de3f699b4fe3d53e50b7d407d3d0c1d2e9098623a8e2ba22fbf2f93b6409ad4a9371052705f38a94656edd51e98347e473a964de3f58325f334dc521c2c7eea55a46f336f923dd61e6821b6a09db6ea6ca79ea664361f91c9b2f197c61274d0e0237e91428bdafe17e70ace7a714afcdf524703ee65845f0e8d6337146196803520a8bc9c70016b475e0fcb8e225d54cb9d13f8aa5cfc9e48ec598d79ad0f27c26936e6d6bb7b12fae2cbc9640c02246b1e5089bbd2bd640852522a9abd2669a44ad0f38e1191261aa0256cdbbd3828aafb4be0e4d158c534de0b404f1f6fd9b923ad763afc233d4d9eebc4e9bc041c394fb361f8df17ae0994a69efe33e37f73cdc831c8ebd865ecda588110c75619982f23b640bedefa302d479b0131e189b6ae6d44a76b8454005bb8897087919d2cd87912766271030d672b91674ba5d2bb17f8498ff06e493cd692af1de6606b61065900be59a45c452e9a522cda080a17a45c54d629b103b56556610ee7d950934b1ea3ef706b844b03fe59a1383247890a66d73fd9caf8ca9a5ebe3e2bf1ff5288dbcc975280d7e7650cdabf666fb0251d1b68dffa746be1c21b52791e93e55307ee3b68ca399aded1dc2e97dc330a94d531663e142bc489ea804141028a708ec7c3f3707a9a8e32f31aa04aedec4a90123ce7dcacf37609934b911a519284a8120d33cf5ff9b4e9c3c3aaf80e46672ad55cb859b208fb96a7614fe94eb613c90f1be52a117f849e0477745281632f6ea9a490450e87da816af9e39ca403dcc90d49d0c0a647e58d6327be2a5130cf7c863124c4c5d95437139e07b9080b540f135d13b429255eead70de5d579e97bf8efae1ee82dd651cc75206cb7c8669f949c910ccf588772c084be397c7769d0624d2205f7835ee6bdd410f048f27751e62b69d72ecd99af5e325340a6bc6e115ca484aaa40ad03217d5381e5ad7054407e9a78036232e1871d99e65b52f3439c72d6532a0fc9c8937c7dd090f8232d2b0bdc7b09f337e84b306be7bb10ba554d1d6de6f043e6dc0f329ca384e54ec6d19199424870d10e45660316b41d7003ccf226975e1578acb32dbda78cf32146c2772b866c7898531b89568bb8c6a8440bc0a695ed38620c8952f3498863ac674b8b780f74f1b2d07fdc13f7785ba177835cba497cc0efdbddeddb2a686389d84876dce2be72f660fc038ec2fe3385ec492daa6e7b3bce43c75f7390ec4adf1105af8d5598a4fa9478a0f94dd4fd2e5fc2c955b6fe8e6a9cf14286805784a1c3caeb82d28727b86c9c00e33ce0e024febe6af8ba2be79ba1ae7910a4296ba4ed647cd61a7ef8aeaebc7e9af170ca2700e94d175e9af610d0d03379332f85b0aeb503546c24c3c05426f22eab8400a97387b9ee90cd7a7051f9fd85e0880cf334718da746519bd07c47b3b199e7ed4a9c1730de54aba8557ed9115b45a1c4938c66bedb4272934cad35ead5e3712b86590310dbc39e4075503b399c68abca15feb7812394e7f0ce3d82bfad3e5ae717fed96d8b8ce084d65cf86e95ccf39848688ed8b807206b0d1d654cdfcd09d49b31faa38b41015be9f1b9d5be9d4cc19fbbe9ca89509c2716ef5ec1b247dc27b8e775e5a9b75bb7d7329bb2f295d183e1c494fd4379f722c22bb2dd9cb7e3d38f08f86b1331129a9f3a29c9ddd903ba6bec474c288a2a777d1dbe7645418e89f174e8558728f16a74edf3398d85f08a47f552117044e1091babc6eb1941993d7fc1e22482cb8cd2f41af2eb9fb4e72444796ee7539e12c0010491c0a927b22e5eec5123ce81e192cdfac09b175d871b50ad1781486a5da29af40d9a1963564e44cf842bdf501f8ea1aca1ea9c233871067f80dde5d8ecb42f407702bbc808c074317ea866e6ab3dc669e77ff7d6313bb15a3b10359fbfceee220eee2540f25b2b58b9c324ba54d37718606253168921edfb3c7601103807f95d468a863323cefba70f0836eb861c20698e436f274e4b33d2694b13ed3e9be6acff3be4d36b8bdf9d29687aeac22ebd6d67c5c84126a438e496e2b46b86fbb6792537eab2a1a62078136f90318225e76a5b437d885bde9ed7f25d83215f8ad2fe7bce0198887bfdf737be42c1368e3ae97be76afe6db62c0510cb5e691ea720fce72ab7053cc3895a0cf4c22191a9dd27b8bd8ce7a602b37f3832a1bc38711cb8cd0f2db3dfbc78260ce14bc1c586fc6c64d23abe8f4b39e71c9ee852bd6124a2b601bb575ef5bfd5a1f4a5310ee81edb89914a43929b9e9fb3eccbfa4b8c753445dfc5c0e00d52369c85e47aa37438a31290fc3f346dbb9396adac9bfa61f03188a425f44a8c4d96834c64f2acdbc29a2d8b041e93f9a734fa55c01bacb4bc3fa1051a67a54608e2e309569d683e8a140e501c73ec56da4172bc85dd64fbd9688033a92e8fe26bb0e371e387be79382cc4b4d1f3c0f66dca9f89adb9f93f52d25a018be17b9d1e8d361370ec52b26ae33e3155a47367720933fd196c98d6b7e218ed219e5b8bfc71b253abcba2af2b8c7f2a28685804111ec2fe3b488bf78dba7533c5ea6ce07e19c9eba3653752494acfa2b2b4b03fe5ba3411fca7c8f6fc9161938dbc33cacb3a129e11fc8c43e3b32eb09f18057e5fa26e2f8aaaef390f569f4e98ab5db699fd1e45d81cce679c69e4c64580583ca98298ae0762d03f9b4a2eac3c265bc6a0c305b67a9082fbeaab39ef5a528bcbff09ff20bed0c31a171f9f1ec6c0c6ef46a32edc014d1d183bd67105158fb99f9d9030113c57945742c4db535b1da6dd32694aa514147d2f94db88603df4da791557aac0fbe1e8ea247ad99ac1a2a4b0e6a05473669f166e1fee7eb4f1381a183ac311bc4e0520590f3ef35f94cd8a8350d6beb43be1d870bbbad2e89d6734e67ea74a848045c1e510e7bf07583d0ba2e90cd6aa73c7881357bc5e1fe10347d69ebfde60af9a21ee554d6a4f827bc83bc09fb1c7d268ba6891c731ecb14b13ebcafacb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
