<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"87b7c78cb4aed8f24dff369ee1ebb2fd810e83eb7903d698e71c8f5c6a2f7eb61fc6daec05504f3bb5bed57b72f45049d4ee6544e672f2231e35b27f4bfeb9e949b2e24c35c281fa201a2072d478d194afbc4e4dc079855afc0b7110ae92d619c81fc1c092a9aceeaf9016c1d3ea2f3beab3bf7dea7f48e613a6d614bec1ec4d6cad27a0bcf1163fc43847b1cd56927f02f90c92157fc303b4bc95badf3b8ebe44c6ec2ddffa23add0a3f90c2284c9014e1242180a9e8e443f301449d5200e1421777d637c4697bae8826eb656d740c7e727da7a95750483578e6d3f85cb63481cd0491661be1e8fe154c0d6ab820bb47049011758e3f45f9223d4128bc2e1f7634eb4296ad4897736e1e814e30b8f1752b66b0ea0c6bf66695450911f011823904504e95e3b49d96529b75e70a9f33a8f614801ab9ff3c78cc6bcb5c5b74efbfb0deca73668f10bc391ce99f34165c377c89574435096ec2e0817aeb2afda5900dcba40712226f7a9e929d64df119374ab136390fdce1c00b63bbfce051895bad50bf5d7425648dbf6e3d4b3117e7d2e215a50a3127d33b04fea2bbff37d68ea3ad92edd77d9d13353e1436e269a0f780e613bfb59bcabbfa1099d8dbf01c747b365ce1d944614bca6a177f92262978a446848095eb6fb875793d666957c27173de35237c6f42868c55c110094689ea95bf3f07b79d2363237494623f9e71e3a3bdbd45f27b34ffe708fd108e7af1271a9e60cc070598ce47c6b569b5ba506ee5a29bb5119ec8a103e7b3c780d864ac297c5324600ed0d80cb757881210c70afa27c6018752394bfbd4ec455e1c0116a4dfbf0c763b31cda88b7d76692a598c919510364e7eadd6731f89597364ad8ff6ff567bf7044084b91b3b800e6bbff7dc3a9a3e10f1821064df7be305c2d8465af99e04c0cfd59679d220d5108375ba0306e5333a6aa2d0e8822e05b0792211d4edf463791ef5c5106823383e6f58804388c86e7b7de7104fdc2135a3c6822c464fad3cafbc76f17031ebd6ed6afefbaf1892dcbdd011e9b8e84d8eaaa115f5ec35fcaced8097dfc300e7e0e08df66523409ae8794bc4f5a6713c3fcc8c750a7f7d41aad1ea310cf5169d7db9091d14cc45694a6aa435fea4d46c6a47af0bbadbf690c2f3998d7c3ab8376f04168919ea806fd341ec184f357d158a0a384520f2c72b7a301a85c69ff574e514645bd1ee993df4ea6db0cfdcccf72824b63afd9390cc5ea7b4d9af332026feafdd8e9bff58b4a397f0a67fb4b5b8d425c873c3b1e2aee132da421588ecc6b8226c7a67666e5a9319df0bebad0e48d4cc8610e94df7d8657113ff31687d1d080f232c9ce0d95d521fd3e462bcacdd2bdbd47ef3c54a2ce2b8d6cdb2fc0a4fc9963250794280a3e535445debb4086c17cc0abb13903cb4aceebb723da1257678d1dc72484d56b5280a706c7fabda3e2670a3ba70d5c1dabdf36415acc0ce196576a072f29e74452af600f44c282913fbfd315ccea3f509636fbb03a23a61bb9a9e044d6786ffb1410d830f7fac779ba8008bae9e6a3823589080f39f7a0737341ae2b17522edaa76e2124a2b8432b88ab2ca5ef9a352ef81bdcfcdd98e67bca8123e16b377625462d3246b006d7146ef33f6c5e93121ac4c49f9bdf50a9637a822e653b1c56cd1b394915ff73d4bd7e649d033c75ca86b77d996c5a23ccff79420b25bbc0da26bf1c6573f952bd634b1b6d38fff5238bb6aa295271410a1d07f6f00cad261c11035a8bf714bf877ebf6752792bcf37f25472d747df1f1fb33f9db67ea734c3023fd50717f7a6fa29e72985a77b43d4ccf55f3813a50f1fcea8d1b7fbe614d615a32f426661a196aa2af51e5e7a74b34a25a7f7dda332045bca679e40540c83d7f0f0e3fccb049d21b880d90ef75d19002b272b7cd0dd07b7c3463cb83ca81492c17a0b367e64ab74aa9e293c628898479a959cd3943a10dae675b476bc7efdc4d75433acde96381aee5fa3942b7d8be910018b48f46e73de0b1342c3738b3ffc73d2e290dda3dcc0aac87fbf4474a5808ab626d83b212100c36964254305db82627bf8f743ae9ba15b388c35a1dca3f63d19860bd28ff2a369e8e222b20c0b5301113ff91390fa4d293ab5d21e15613e5c797d2636528b892fabe64601aa964a708259e128abc39d1a308b6abdfd541135f2a4b28103f816260466c6aef78a1889e671e24b7781ab2dd65dd79b19d93a9bd5bd3ff3c67e2a72c1a6f6e3da8a8aa8306f4b0db8a1ebae7b3f8917e912ffebc5fec69d7248116b89902d548cd02b7f128ba4fdb5b6f60e9ff7974d623ccc2aeb6f9b0e8cbc9a65da9caa056e5ee09b8ee36767847e0d7ece507bf8d4a5a98470f1e2a214f392397f157d3e84a0b72d523cf5cfe16784a3cfd1c11a5d2834d041d83b5ae31565cb2642890a0b45cb29fe39fbb5607535276d895dd359ce8e01f24532e574ce5fd01ed7b6c6b89d5ccc9f09057312c0f6f7666455e0173b6fc5aa85d83af4b7b023427c791ae8d0b32e1eb59651bd05f5471acd5cbac3efdb6adb0838e1c35f430944abb3a6bbc9214a6d920091f33a5fa397d489b2afbb68d553ef671318c8a0da8d9697441a7000551347a20bc949fc9895d9d64b5b365264857b25688596af618fde37bf3571efc22b1bfd1c9b083a22281834415a95d8b16b6d5079e202f2fe53f0a0131680a3e78ae01fc978ce6dbe1652b7bd9adcc2ab5e7edee94bd0ef0f6c51e2913d3d0d42b1e0d56f40e891789fbcb4c64aac4b663f7e8617283cd3d58846a6f6b13eee8a9e22a311c78b81d009a353c330dbc175454fdd6ff3d84cabd8829d174d2bff321823d75c25f928eb5da9f32454130db6bdc759bd2af8c5ec45ac6a49fa0f14f37d8658cbe3ba41ef5158b63d305691c55cc642add03d74787993bad8ef226cb673a209fac0b15e4eead949b2b116356c27908f3f4b5eb36a5fb9616f0cedae6784340e47e5bc975d39c766c7976d1b807f6ddde72a3dc89fe834d8d4c6870d1c97efaa45ea83780e15cd025ad20af294f02862c0629f135cf3527329d013ed3765470ad339be45bd2b81434930b9c5b35b836a3be0d0b2a8bc11e87bca0797987b49917989abbf148c35f01e26cac362457e3e25f9a778e595768d43519fc2978a67c2ac5e2c51433a65af6279a4cf88aeec288d92e2b825d2e201f611c604a2d4fb7b5a4c8827403b299561bc3a335325d78b248f1f190ec386904911cde701c4c2dea933dfca5763a737abb5d964f18747e32d2fc0cb89450a6e49a81c1917b335dacac0780a3054c3bc70b2b79ee930c80dfdd545c15ef4107bf86d667e44936c8c0b64eb81f1f1d54c6ef023c12166d3d7a2dec1d55d38434b0edd9ff438580351171a52f8beaf8f294f24957f2504c53b7008c7dd84c1aa5eaa0c6f20d049d73910f564cb261f9635bdbad1727be35424418940fecbc4bd8aede1a15d79adcdbbc3f1e310014c2be4893862542250d6fdb2505483a8ec6b6ab37ed6d8cdf4d6684047f8bbbd5cc3c66d6f10a46d7ca8a1094a56a4fba1d85f1249089c4efb07d4ed0c2de6e53f439f66f13e4b57e5cf82832617afb58c8d4bd8a707da00e26faca963e277148112fa1fc5d6857a994ba9de3a4f32d7d5642aa0202ceb0139b82b76c904dbf03dc6ecc08bbcc02dc5a00db71f2d9304c9fb13e7c08a1e2a0f91e285ac400de8ef4eed47856f6a463fa5bca97972f2dc340bf41187d72dfe2a8ee53dab18be2b9440f6941fbee78d626c070b8510b45a2baed9536b3372a1dc937e574afee8d21f4a2dafaf6cf8206cbb8585776ff0e80b1b567c91420427e214a506299af4c3608aafbe6b0cbd51aeaa7c643bf0fc2c999154118198d966a30f7ad87bfa647ab98178dcd2d00934a27d6637ba22dba0a4f19b204c148939478c95f4552085b806dfc51e66530e9df126cdce0e2a3c39927aa82fa19b84a6fddc8af6c5bcd54feec3e50775035b200d0e59358889eef2df2e64997e25025d92dd0b715241f418f92877958b2cd25895dd246858da436dd54663a80ca97d3936a1850f4c3fe000114e4402fb1e6f7456a99be29b76e2ce68fcff6c54f54cd5a09762b5caafe6efbaefafdadcfb4d630eafed7b695a73a081ab6a9a1f7d988ebc73c923aeb8cbaf6fd738ca8f5d7dc1baf47b52c41068502e223bf7dfd034969060f2ffda75bf9f9ff800e318ceba452af557fcdc27117ea9f737d20f59c524374cae4becabf15ceae2868483b0b5d99db18b3c4297500d5daa39becf23d5e7d922f817b250cd30b0ece90d993227fb87dcad8cc6bd4062043ae6c9803e6526daf0d35e81aca73060afdd55dec5c79b0b6e818ab62c5cd87ff6714c59a042bcdb219c5cac4e1ce73eac5709ac12b30a29dcee83e3aa2a105df489fd3b4d1379e79a3a272229699b7dcc961d040fe1f3c9af7f94140214c11a526bfc05955746e7ba765301420e73eabfb9c813f31c6f53ee8289eac701cfb7df5c1e3570b8c9459307bba40d60cf6d354f4291d1970cfc4cb330690b78d0bf356d37151e201bc1620d631dffe87cd87aae8a150152a5f9c836d9325f20b9a55f96d384fccb73567b7aac91d3d3c22933228f4b24f0f0c8bb172d0c10838a34f412e43cb3e36c568c5f0a258cb6ab2b3052834ff7f21c73ef3857d457c45ba5d92514b68592cc1e27875f2b5990553377169064934ff803480e387098af34c3d91c8780d4d9a31a42ce7b3b5ea8c812deb7f7a9990fe05a9b24279ba88334bd20a347c1abbfd521e31f50265356cd20a8942801bd094f4d9a895a751e48083c08e4d499b5be16ffb7c6118537223d783c3807f19bbd16344ee561dbcf44e13d46ef552485e756df4e0865feb1f0c7b0f17216880d7feca38f0c0bff3d65d796497a0bdd6ba4ee4502cc7ea9b5148e063b56968cc781331252d989e28b66ff529a2e88d29661da7702bf6ea6af1bb06d1a8531708256a1dfdbba9009150637b3e76e6072d5bf5bd385512746c0b4bab7a23850df7b5281160133a8663fb4a2a07acfe50fd2f857a67996775e4649e1da8c82ce1ad6f7b36bf8fffeff5d97c6dab18da512a79bb713ce0279297180e44bfe23ad5065a3da17ca5a39e91353268717ffec6867c8ba7af2747bd974bc262eb0d77017aeb6a7575cd6cf8597bc18f10fb90a7dcea1b4d7b00010a5807558437228c8d43c5e4d6a46c6ab65177816d22b50a9fbbe81f195609af724595d9ac1dc62432d19a21d8de871000c1689acca6da76d76be5d68116f10e7ddaebcc5579d98268d1efabbb2a9741430dd6cfa519d98879c7f46ac39c4900f6163dfe5934e586ad5701faea4553479783a458ecf999dde792d8e8c9ab9627657fdf4a617546d64860ee94b8d4af03a31cab3dc325120a185db13e0329d4d33cfe53a18353cb998a94bcabe56df9689b81799caf6b854a0610741cdf6dea701c6a76de4e6f1587dd2db3e36f8ef86e56e6f5586e9b3012391939daa5531e258e061529a88101c524237a5db49fa3de6b245e78dba3a4616b69dfc27d26196df57c8731d6acc04211ca2471aaa0eb1d2329f811726134aac3760eae86a80a44c5f6504559ca11f9a48349e2431bba79326bc1d4b2107028b4a1910b29980f797ef61ad22486f18624ffdfb183094b251467d0382d477caff78155aba2db8707bff59f2d18be0e37806100478b2a22a67a9ffc3cec574ca90d1948e3589e441d3e89e57b94be7eb6f90b228ab46f8935c555ecb2a0fc3ac1189d5d4347a66c03433807863b20b716500cb88e67db33c81abf59f5c1c8aa6440fcc3f3a8dcbfc909a001cf1ccca9ec360ff5daf0f5ae1d648adb649252768fea9ac412e4a5a47b2a3a879339ea58f0dac491bab5835613502b0b20813e1c979d2f61cc8b0d7c01012ff76db25106c1cfb98de8b4d2d1d9575848e6f629d75be3b58f038bfdb8e0c8d9389c43d6ab250b2f505b85ef28f9e9ad6fb531bc585cd736c3b4a4253a89f98e4dd518f830dc3d1e538a69e6192d351d716c25f726aa161fad1d7b3546d03042e383b7a02fbaa201fdd008eeb151752e2bcf15ebab98fe0cf47154b2fcdb32400f1e0e2bdd1be54a6342bbbc5ae8ff06b4b9dbaa0c9f88ce738f29242167306f10c263a6f2a39c74533de8862b51edbd23224d4142fd32e1e0ce26e25ff87fba7592d2697cad3cd2cdb59607183d0a2b30e384e9e4e5f6571bbbe0547fbadd1900f13c721d6c7788773bdf8caca80b0bf8218b798b5f90ebb03e91a7bad1cc05465bafb0fd7540814680e8b6115c5ee1afb45d53c2555632b3fb8803f0705a4cce28f29b70e9144635aedb9ed52507112bbd6aafc655f0daab35a35a45f3d888213d708eaea4db0cf320c2aa3eb9ae8acf413f6b2e6a8b06a5aa97de657dc1daaeb6b37a7c689e7ce5b38dfa72adf57a1defe3007db75aa09cfefff7e07c58853949fd4d6519e6cade6f8b36bdc971725fd6891e4fabd4f465f9e73fb0b0e8866efc858f3691f085fe3f2e60de1d56858a6666cc47e50749a5e507f88415ed0b2234e43ca6effbe5f8b46c8a33b56390caf93d72154907bd96640857c1f8fff46d6ff8f8ee84669982dbbd185a08e20f45296ffa0ae2a861143c505f404a003ab8ec0e9fdac97acfd48019401e6abc4a98143ba65a80528ef2cb1849ca3dcf246b4622bb014aafa634970ba57f0bd99211ec46ebd9b702bc96669efc0e0cb8848fb967d7998a26bdea37670124176a2590fb855cf21ea57c26a7ed259943c2354faaa9678c834d2431fda219368c8a333e48855db508e944590a7e6acc72e242ec8f4e118e7f4c21be61697dbd80baf98115ec65aa53da1e3d0ca6572a88e0924deecbf53edf50e8180f9cb63827b63d95d74cb42553a75858c8b78f557ed9f797c7d84a822bcb6b35a1a002919ff1d952384699e8846ca73c8cf82cf19c1c9058bc2258f585c233bd4df246263c9254c52fca7602c6feec8a526ef350d3b9f79d026c9dadbc7f609be71a674e213dd68b2ec30af11f59aac568293958d57dbeab26ca1ef82338d73ca9753a03c5a33e0fd4c1b2d8f958eccd1bbb914861c3024abcba2945ebdb5a8b3de1f261cae7354ea46484fcff5417f928d7d5aa825d2dc4ca12d3679bed150b272fec214f5aea30b3e2847c19bd964cd6d459947ab8f529e94605afe886034ae1c2d9cce3896130242e3d3a9eae71992706785421e25bf850e64924426026414aadc15d0a7dbb1cc6d0a976fb61f7aa689023f7a470a8c379f23d21bb7303edc97771bcbdf6eeaf63718e12d78b87c7e68d34c605553320ae0a7128827030889ca418d941b2db64d328900196eabe24f64221f36e86387d8a2a48c77e8d920d68edd27c8b3338da9f2b2facfe8a68ded2f0064693b6db4799e158d76aa62d4e156a035e6bb84e4acdd55107c51e4d03317ab33ef985784cc402e4a38afc7c27d6b75e8676dd9b16401c25f55b8767ff2d39a5bfbbc0dcab93c7332a6f8cd0d6031de9a240e441778e52a4dd74405d850cf09bbe602c0044e4518b75d21fdb325bd0c9e9d26b28bf27d984644f3105d70e50edc6cef44707c5d62ff93918bdce7eebc6edd7df43cdcae8f948aa0b0199a53037e4f770d4e4b90bf0dd79d5beb0fc664de85380e0ac2a97b55d349d9147a2890265ff8c8879798d1af05e4b5bd7a6d1e1787e8d37865653c50442d92c4b4514f814bede71c6db2f4639173c3eac17ec0c5a38375a794a871c98223a1dccff7e8b5e5b7802cef0029306b989bb4786adcf829237a8f07b55b22277f0e5e318a8de36ec6b69638d9d8d26a0d1cb1e7bc984ac945eb1d3add10bc2f8cd53719b94fe6524a51d95c2047f8d4571210fe8dd7e5f75854c293f38144d7075ccdda65404311078aa390ee46a25ad823d93b04640c19abfc106e3e2743de64d22dfa303b6c5e823ff58ae53a7502495d2fae8cdf9f0b18eeba55df3c7960900dd8f2a95908841129a2fb15eb9b812c5c78a3a845c0c8a0f249669984f0b14c2beb31ef080596c3d36f07bf1b701c661040c7be0b633261b2af04b3da420fb0493a18dd14a9dcb329d45ebc94c5346fb36e5c9e302d9fe9c8113c48c2c5111a7fbe0a7ab21e867cc34cb23745389e20c83cd19a257eb17f3628cdb092f0a5b371552a8744ac600e4f897d72931a001d78c1b90ef512e56ef4ccab14b0adecb910d1bf326d61b34a89674db8b3dead0cdd5ae8997d3153cb06bce56ce10b5976ff30dc1c0d3be193a8907617e1dce83603295ad92597bd640faf3d2f8e5f646d486deaac0a04dbcc783ff0b609d578d1721513d6a55508e0a1f5bfe11c39ec53edaa68fb583867e33dead6abe3e1ec2a709ab57cc62c66357bc8fd1a1dfbb9275bcb7dddcf0199c505a7388e0a7d347cf827e55ec05055e7cb2e0cfb3e1cec23c3a0cdb5cb063f4781419e535b6eb3c1653c24d444babe2a94594d24eca454510e4b4e0222bbfd1e6032e250cd95f194437bfa20aaf534e3e6535a88a4f85dd814c7037196f1f3f55b92234924a39bee26f3fc15bfdaca062ea83194a25d76ab52a23626bba2d94602c4794aa3f438c8fb05d7a69721578ee460b3c06c428d8c8d2cc7687553daac54a1dbb9d62b1fc283a17ddd7a5e7fa47b4dc1e3417d69d06c582ccb4e6cb122deedc9b72ca7211f58d85cac7755fdf0086dea083bcce107e05ce59f603186e07ad45d2513bf6cfbe3518748ef636dde9e8d2f2bf592b6bdd57b2a6c93a06bf698b4e2fbe3314ec0c5fc22df170e14b8e601dbfecc6295df4f3228f64ef0bdfa0dab7f904df72b1378e50000fc1c56571d20ed853033125808095292c1d02c7c1b96dd2cdd826de2e135a536540cb120bfd32da3dd02ba7adb61e16c3b061cf54b08d613a8b503654e88e106d3f01133d4b06b96107f360edb6da1a0ff1d875d6d670de7268f72396de1a1e638edc8da855827c5284c13d2052fe17d83a3f043b5ebd3069e640d76edb5b9744abbf2c9d5ef8f3dd8559b8acbdfde6aa47da0a475e862e105628fde0644a549221951ee97d6be76dbe58d66be511ee111ffd53019d5f93c05a6832cf3d3be69cd9280c5f1530cd8571ffc1e70ac76bfbfc6f4d61dd82e1c5e0d1fad8a3249b162132796886b999c6e124a46ebc0d48cd69ed97442fa11220a7d5cd734d7165973902c73c4d9834994805ac1d13113403c417e50ca999136674ecafde95d255bb3311b8a1c1dcf8874b1614debab2cf32d077920afe43d5772ba578d6ba4292a03a6b16eb7cf4c5c5dea337c4d126971c0e1a22d1b320070f2c42ca3aa1722dbcf777f7dbe8a557d7a8bef8183c0b0e6fa1bee64be0a1c7b7892a8298b814229accb7213a9c4c79e4de6d17c6a16dfebf0774ac58289f961db57dc7280db6eeef9f9e86ed626dc08c42c3c801e8b8198e34442e0e5f941967071fd92ea23c6182e2eb5751d004bf15de8dbdd96eb177b1f918ff498ab9246133f17383cf5161245caacf1eb0c3c4793e93dcd571ac5988d4988affbae6fb68eb1838fa1432c811b4b11914d503b4a66faf972752d90de02067093efc919c570117727927005b63d83449faa334e872e1aee2e99a3e58ef1372e5a5f5691c186a607384b5a6e96a4b4173c73fc984cf21452de0a22aecf965b7e8baa4fff96face5301bedc19f5fd00ca1f471c84d65a56df06a506cd303af4a72fd239299c7fdb461a9945b62e2c65ad3bd267c2b2e7fb1def6d10b948259ae03e6858b5003004874e1d8b928f06a1c062e22b97e041e256c8ac753095f48680abedb6b611dbbaa7114387444c2f33057fae3e60ef3e1728313e5796c1292e94672308ad4c3f6e8b2f2537a67f5ebff742939fa362a089b7f662d3e46ee01e8fe922ef58b47058157d5b828323f50c8e8195d511df33eb04939667f0640d3c341005cb258995a57614992695916602238f5994ebd936f915bb7df7421c95ebc799bdec07f0ee0fa9e082859cfee5b619baf61bc9636d63e6c4d03add05c6dae87d5f65a84a0b9e3ad0ba115ce3b5c6a4a60edfb5c041f530eedd76eb0fd829417f692d081eacd22ebc99f98cdb9ca1311a1b0dd701d07b57fa8cedf6c5aed5afdd2f843e471619260d08dfab61442b9327708759e9a7326cae3fe08f84c10666f1daeca3ff6b98551cb9285d4fb80b8ce77d7c5aa4f2ce7f2187a7c1165c280e07426e683f208f527ad78b5dba5e890e11b25c6de5ba1b8db03dc1fc489bff42922ab6495d9ac4d0d645354f15cedb37076b8f76f96924d5c83db6001ca9088fa0b2c25a3c8483c86b2885dbcf27e27ed6667bcab22267bb4c799355aeba456abeb0e82c7dca1a1f51ff427ad8fe59e68c81d9aeb07f904e951666428497cb4224c592c66d573512094ec4295aeca51237935bf417b0e4e633ecd423c8efae115be0b8b423458c39628d92faf41889c4087a8ec6d2dcdfe4305dbb66b64d414824c8e67f31e9fbcff96b8a942ee974c4ec536bce095fd9266137945694c1683c409ae45e212da2c3755befc5f8c91d5d3febbdec10387bc5939532dd052c37db13c912876b37b3f869f0d76f68c8f3a9ffdf5ad6ec10d87399bb42621196844a2c1a0bb2afcd83422cbf0be4494429b3579bb6d91ae2de8f228162b9298e2cc5799399e1a830fe0025f006e9c2a9c2842bf2fe7aa5f155b672186615980c4a24ba15b127dbc714569741f776d6df0def3afa619d0a3ad47fd8a98a36ee859e8a3e35285488748ba4cc4ea54f6a307879e60d6d429cc56c3400eb0b20e0de64de28811590ebc6f3b0b781a86d645e663bea3382cfdd2830e1b0abeee777cae915479aab391528efccf67cf05f8a79aaeb6e12799df79907607063819ad06409e3df155385fbb01aed5fbc41f93d19e8ba4316af09b538d195e9b1c07b67ae39117252503c45d8c07d3713c0865d6cf2d95ce2685b6235ca28e1a406688310f949dcd79f8b89563e3b4f6b9d033f6c0ffcb7fdbcb2a7c8b64331902be3f15e006ba62a0ebfaa36d67766a4e0602c7d84219702701c3aa5a15c8d135809ea8779ff544f445c05ed27401374e3a44e7aeae25dbb9f416585c484be80c6937bb7d673fcf70e6bd9d3534bb97334f38aa4adfb4ba754941cd3bf400c9c33a799e44129fc9d344f7a254a095f457fea0651939992d6e60fc8647e3898d7d11098fd163297555105c08bdc91255325f6486271e763ddf507c26b3067ab73c4038207d5505f8f28c95bcc8aa71902422038701662b09831a82ce0aa43e8d81cce420b3a79d436f308cb90a33b4c7f7a0538aae4805473dde2b0dd861b52bb297af62d7422ffc1119cc521b7344295fb2d36401519f7030dd38deb7fcffc8143b3a1641194ee35d4598975ff510bdecb19b14359e0b3abbfd41519682d3dc7664c24eb715a4faba932ed5de03718f750f4b657b72f950eb12134cb8408c5ef0b5778639370a4ae3004dbfdce1a8ba3cbeb79f95262a6fcc17b394b7163cc964acffacdb4c3d787a2d59509d1b1c73e6482d0ee2220f10da4c551aa5454d87f61ff21ef775dcd7c652d4ba5d447e142aed491d5a85f30fecb6bed259e5f773ef8d4e355704e034e1e006be7ce98b2dcd19e8c7101881ee04abc7bacf667b6ecc37b77f9898dbfa968627da9437279fbc4231a745b21ceec9e8e50d9afa678259f706daaed0669d6715c12cdfaf71d56be8e655d3adbb0e32e823cfff0bf3c5eb08642ecc8dd951f086fb894d919965df20a3bfb992a3d0ae0f316d060cd6ec478df551cc46498915705cb147688de485608d465e7b2a891a251019e33dd9d0e334711cfeb097c4bd111882115716691575de15274929b35464a36e4347e67a26076215ad7e19fd32b92053a715930d52476a6d1604eecde8f4ca218c5348e106059c4be3d9fbae660f163d4f911141fe2d925bd7b9d2e62f20b6703e415b28baad6fe8a65ee86d58414c3d54e6381629911c386300f3651c153935dc1c58dff17af2b9249ab32da201d0f21a171ba9112316ad1059ab36c860a03abce8865a2d0106b65128de967c2716a184de353c7f9e0b6bbc4ee353e055b43a822cc83dfa4afe5593b3ab281affb574c48e0f895850c222842f7fdb963e1ceb9248e3ce75f70864646ad4618668b5330486699a2f9f3c8ee26853e307704e440da92fd0aa5f927fdbc80ed4baad4635edeecf2b05b242ea1c297357de3cfd3d1c456db17b5d7f9b5197474010e140768fd80c5de93cf1bac9a0144effb202d25042ed34479ea529048b3333c33fc053191f26b081514c7b2f467429666cb48d33a70869fccb3d211e093ee8d323d8c9d368b02dc825f426d89602c052d8f613a1df298ff2ca643287a39c2ff9189938834ba9f14e767448f777b39c899f74d46df1ddb64b0e7f24002337732611819c6e094e745fe09681e5b8437666461aed555e2a6df442eed098f8b2ab80af0f3d372d31c4b32ec5ea6eca4b87ca0f05888489f67c7498f456486a0ca6c6f3678f39c806ef3c0dbf9e2ce9ff6d483e046911e7243023c29650d4a35d57a26f502c282a9fdc7068a9edb3a23512a592ed1a75c816d98b7319be45acd4ad7642923816fe4a77a731d8e1cf4a7380e7a7bee8a48e50517f954cfd2262b4163e4a877d66bdbbe9e2f8ca4717a89c5ff03eb1459f71e0dae035c3e02a9331db426db397eaf323b01ff266a4ebc4f6216e560f4f3340b0a824ab7bed865277c98624d02db5e7f1d735c73a926cc2c53a0462276dd469628a493dc65860b64e700e7183240786e831b3c3d8605e8679e5ebeae893193b1edd903ebc602fe586ab2b94abfdfbc80f70ab87e4c69511e53e6a2ac9c26d0318fa85c86ef4e6bd0bf47e90f9c1b8c617039dfbe7768e16f0c2053521181c05ab49b6121bf3023b6cbdc8fb0a154003bbb6537db0e61fdece0c02ef6d4e4081c4b44ca1fa886a42874d52477f8a898272a05671710a230753911ae5d3f8fdf8d25e6a07fcad013be7f1c01d15d964e30c0285a2981e43abe65db9bc46c81da463b252a61e8a0193b1c7801e7043ddbe7fc918a7d2ba695443ffe71e151fd56a8b701f0adf53ce2fc4dd523c7bcc58d641d3129909e7a2f3ea28ccdc9b651b92fc5be366ccec97e87b292dd196bcd181234d2f2af38c83374c6e937fa6f14f3b18a265bc3c052441c9ecb8027f1c3b4147440ac21ee364b11af284b95956b492a123a91d7cc71fc038f345d0591ac657c59935c0f941cfae4cbf74d39ee50a461b32e8fc635f724068dc62696cf9c5cec73548ef7e5b8ebb8c44fc4351f457d5e59c21960b71b39cc8511c1114e302e890ec6f044679dbd2d6d2b24b8eb2c036ef009b7204f66ff5bc4459bf6198d0a6cdbbe07066630536b0890c84e35305451ba53e52652650f8b7d5e6911cdb7ce72bf72ed36cb7971d2facb19a7db7eda11b622b20f3d992133d27a8172e81a0c1c538b063191c71246a564d8cf65c746d80b63eee58385b46f5b2e29fed3f2c26e01dd1bb7ab6d991a74d9f7afea1452867922ec3ac4c241acb00476c67012ca8b431bc324714dcdcd3be2b0ec848c159d91a14f071d850d3ec901aece3710379805170285090af9398ea5313e15f7b64489d9078ef60fe30bb2af25ff17d606efd09bc2f2adffcf783e1f068b8b3a11880a732a48f5d4701b4ae445818130373ed4d824e23fe345d4c41ffe1bbd74a173922ee94d4b099d9e4d7e2dba1568366e1c6ac72362b522ec928733986d57151d9146118e9f68210a2d4b87f9967ba16bd57c2bde137b0657dca1b48c14f701054d674c9f5a4f67256132dad53df46ee9bca1c1e5a3b38d01247be073b36a3b29c708f3b51b2d5ac21353947d715740ee26901811237ba06b090b62622f9ea0ff0e1f3d05236fd3b538133951c8aa951943c382d43fdadcd20b67ddd8d3e656022390e9b1a868cda2ebc765b215d89c3b1182c9b6d1ba43380bf53faf2ee87480565f16c59be158a1187c627879e16d9bfee11757ab0d8515641351199bf2850751290d8d162c3d8a62b62e930f690c460232a8578df92047d5720cbff223069769c795e8bdb2424d280e9faebd8fcd6b333ecadea4ebd48f9564e594fecda3564e901036ba37c4ea5cbcd85ee3b1012be4d446486324ff4be9b01f8bf8c1862c67641edb59570b3361f0e2741c9d73eb2a6a4f76d085277b3683637ac9362e0a8e8bc3553ab80168d707ac7be7b925e0b4c372e2d862fd51f70f3e1dac31a4b6b54aaaa5c0dc821f9fe16c745b7eae59a6b8f9495764475d983f6ecb73fd0ea2e8e96947b22e57892362f589532c324c9bd732e0cdf88c0ae8ec02086efa4182d4ee9e7c3489ebaa71e9e2ccab8fc881e2414f7f3fd30a747b26cd2f2917f280281e5ee9a0685d8b72014a9247db12bb3d2481ea723c7cf9d73b44f9f5a6bd6ec4d3a42f409f6a5572e5ccb2474ac66db891c727dbb6a44e805936c6ddc71a0eca0f294c96614186c1eb7fea41c424152bffa6d8271e6992ab78a60278fdc1e1986abf5aeb1864435a1bfcf350629837ceffed16c4b56d90a32b434d60d7bbcc6e39fc2e60e741323a49956e70f50a84cb7abf91789c4033e5a0b735ac39d8519b7a651469e6f3f03ae776fd556c55cd6e7861903a86dcdf60eb235e2526663b2da911e68a0ee17e507516dd493ef20e928b30a260cc37904ab77f9223a104b0f93055b9b322b938bad0be02fe0af9eda18c471186923bf205d9ffbc00777cc17c8c7762e2d96b1739db76a85887e1961737a7adf90085826abf359d5dab818905a94f3b3a74048ed450ca4b4f8ec4efe9ac704ee8ede5b1c8b7170c7d0b0cd18fa2b2fb43172acb62c2e890a60c74ee54196a412a1f51986a0ee76a67d9b0c8bc58d348745be198eea3305bf04041ba1176c7572bb38469e52e8486d22f5fe776707814c87326b21a7126047fbc9f64a66dbda7025483439576cb5bd5c89cfca5a149e8e6ec05b9201c8b19ff70658b71e33d2d0fcbfd9f700dafab9705cdf8d1215131125dc2a7b337d9ba78fe042fe33","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
