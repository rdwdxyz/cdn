<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"986bedb27848b06714a2314e4d37255261e0b49ac3a63c9a7571be65399f0f1c14742467a9e1654d8f187c88a478144c2542c29b6a257988fdd43e8c3ec7bd34376f16f1f4122c0fbdadaf2228474d750d98620e39c5e4d4880e4cd0545cda5a3c960e36a415649fc337663b3dbf1601ef9b60985f402a70a291d84aebff5d56a0b167ab9605907a5cd9d232650b857faf954e0c526a9c78bef309c0d7fdf5006b9ad9758bb75f1aea2ec20b02dbfbd7df6c868973d41b23223bdd831d2e71a20979077f7aee512ae683f0c8febe454854663363535e865a2e49fc395c22892c2446085bd38db4f1479b42881f8ce15e18eb0007763c4ea3a53b91023bb3fc8fc502cd1b6761c333a2fc509934d2192d93f5656efbfa10b83007bf1e73995ad9efc672a65ada7e979bb8ad3761f64c58ca9f1cfa61b5268ef684d86d44171421523b6a922b928474236080d223ba67c2206c83a54155cb01a94048f9787ddce41dd190ccd71462b2eb21529a4a6be2d78a893d25525b860f88a2ccfff50a9d13847ba30915e4470b10676163b268fc8ccf8ab1f7512459977d906db56c009db3616f76f3f0b095ecbc203d9621bf50b71b1ce3ecefbbf10cd58f5bd66cb2ac2142036fe944793e09befa814f2de0a0b4ee172613781a5de821ae2d679a10700ea17cfe75818f93fabb60d44fd9a30ffb9299f5236a9dea320ade0d4c305b56a59d300cf4aea629b6ff8fd2e029e08e76a0788d4e4a6fc5db1bfcf4f71546dc5891c3b5606b53978cac141c58310bc8adc9e589bd1910f42b218493ffb5f7f52b851e53f1862bccfac4135f43ae48600fb8b311e514390009567b43ff2890c9a0b776560773302ca5b30b792d3edbe83088c6d4e8d0d984664d46d4f0fb06273806925a977e275b6aefa6306925bff948fa6489b05c3597b4cfacec447b1ea1241f19719cd4c426f0fbfca216c14c89484246e33ddf047a9dce6e9241a348710f848e765ee6057fb57d71b19d65ad92c438a23f0fcbc9ab4408423e4c37a466762c620884acc28c7e91ba3ebe20ddee532c6b144b0942a29c8b613221345409bebde5e39f3ee8819a0dd3ef2089ec73ac9b23723d7e264cff4dd94ebd44a615556d1601549a5af8ca3c97d1a8e9b6c92194a96ba78243b18e162c35cc594a78b3642410c5867c3a62f31ce0de6ae6be0ef70cefb5dcc08f8285cdbe7b18a22b75981174efcde6c5317e104d7e2100e124d98e49c8cb9db6fc89e4705743c9326d5a3e5d879232d99bc6d020194ee0a0c8cf067437c42228af059203bf7b063419a9bbb7747e7ae6bc14b30f5553e1101cddb4ca18e003d875d9fc31663d15fbf91092a68383eabb49e281ddc85ee6f81736d3ad0229ea08269846c6267ef8f05f57f9e660c2f3cdf79838b7d84a482b06be43c44ca58b0648cab8f1774ab9e62454dff8ed15b1bee27e8ac5d511481d45e3cdb74d364158d340b40b0e7ec4e59b1f3ab1929a71c341e3f0625452fc824ea2a0893358a4a0333d49a0c14feabb3321c7412287013bd72a3c670bb8ca2daa5f8044e071705e5cf0af6f7eb89d6b255e2ca3e950806731e7a150b8c0aca560eb83cb9fc6b0828296bd0699a084569280af36a8666416733617634846f50c0e840ce4812a0af286e61c10e10493a6a23ae72cc2ac115e0dca31e43a60a04822cfdf1592c43756d452557860046d7e64b721ae2174baef8efafc3cd0988d6a9e31fcd09882c5b3292bd2d9d0b657168ade70c83bc766429ba9c3cdb58253cf270706d903d28b589ef370708c2ad043adaaa91f06fe92d0387cee31e4518d0b17cc0c9eddb228ebaacb0eacf7dcc1b521e3dbf342d91e681a004a1f75febfafc9fddd7707473017714307988e616cf3552696be033cc9f556d66367e295c4724bd49c7b3722035c9d2a835515072e7a4f884d031e351c7e7522dc440194afac7cbc65b5142ee4b91df69315a6e5ee37fd6d30204b2e952bdeba75d5f292b8f05d688d9d0c321bcff36ca32b5120b10199482796af815f84ffab125c6008a4015fc8abbb6ada84b8854c5aaf63e37993973b7ba82789a366c04c314c6d4ec6defa635c2e2f0f74c7f7c746bd82b1710c2c63b920a079f115f165edfde980053b1436cfeac9c17b1a7035cd28bfaef36e7e440d779d77425cb8b42a1b233525ea3fc926dae24e104202867aec4654cec3f60db39ccbdf1b7b7988ad54cc364109851644e06bf267ae039a27da2d65ebfe1ab47d9739ed082c99bd010a0a781dee1593aed8592053210b03393664f068d1131e525dc20f068811d22963877c3bc82203d235290c4766629bda28bdd79ab61bd2d2b423f71726e8c08f441a3f7b9dcb45c781324c0233b015dbe2ffc8a9de2b7653266770f72d2033a214a9fa33de888034796cb71624aa093a3aa45f734f68ad54510de77138485cf3d55f847b725f51949f8a00c17e9c9635fe4a99b03faea94f5820e0d8b5e66a592ce9892ad6565adb772adb453b9051636f1277b2f2f2332b72e4daec59767958bc2cf12f00e2a45eec96ed03c0f1256aa1f6e626108b8c4628893df4e1c6d038b99216a1e6676f809879e94b5c1a68d28e789fe7eba4c3625daba245e0bd74d5dfd47b44e5a2f502cc01da31b82179c92b2563fbcab691faab671c2b430a65ad8fdbf788224223e4cbd8ca53b6ba489484162742f4306c3bba79d152007b0f086a2c4d2bd840ea0920c249f0e007f73b91429e8c1826058de958b44404014136b015b1e8e1592bee55e3399d4178b4cfddaa0196f679f3fa0d7e00f4f1e2e1d6fab99683b3fc7a3556602c9f9a136bff81d20d289aa015238fc8f173f623ed5532277214e4e4cc3b53e8e3993a79da3d7ec595d6ce7467eb754725477b622d9231a86880f3368ed470a19d3c8dc47e6e89fa9425955016179a5acfc822a1ea69aa7e7663f247820b841493c40761a49dabac1abad483c68c040757c4bb84169b45b86f7b3fa8c0ab1997dd00653566970d2dffe303b7619f0148d8cbd8fd606142b2f4f6b21e6368e9f13175fed2a89671bad20597ce5c5b7e230105688fd3d2f0b13976c2b0b6e073bdfd25e248517e440abd051a72e9ed43e6379466002a05b509952ef449cafc101eb03a50980058d5cb1de124a556103798379b299b9496726d4431224d16b6e978d84edb82a0d10f216f0767d10dff81df12c1b392fdb73122174d028ca12779f195d715ba86d245f4d2dbeef17fd1b2ac79895b343012c2c0f4682d7cb33526f5b6334f616e1999e3a5d8a566f19e8c7a2453cd88ccca05f8ac6a5763026267d991b83b2a434388bf97978eff4982ac1b1292c10b0459681346be5c8b7eeeb5029e258ebecd2e01b8420ce1e96ed011ae29dcc4a757d0a7169397fa479f2319505ee805e22265ff7f09425eddb39e30fe52d88a816dfc8a3e4b5feae032bfec7d73f0bc61ff7583bccde266f58603cb59b5ad4897c5378ab10361bdf24a7edf8bb9b0934a945cb91d0e51390d73048444228b1827aa12864b221020613173a426321c1bbfdd246c4c52eada2db4b49212f0bca8a9c07cf30ae06d89436101cc201dbe54f4a0d9dd61634270f091ca62028fd7e97a45e0e72e8ab50a729314fed3ddeb1337649ca6aeb3436f03f4f2399eafb34eb50876e88d7fb042c26681b249c04fb1ff0caddf41a6464cd707c8f417ef50c33c956abf2993a47ead514f3a304f7a0dd00c05b8703025398c504791b5d22b0f62c2a19d9f8a1d6e0af4d754d34e977bd731021a7d7c86a13244e8fe80d2000167adfd4bd7f3d4c41db93f5522512a26c1b6dc8be96732456484d825806f2e0359466da17d12a3013e1459f601a0adfddf38db77d8f1c16bb01fb0ede4715c5576527ecdc3227806ca4edc5573d41e5bdc53eb4125bcd6d60e95d9acb9fd2a36b1fa7432cc7734093c94c7a764859bb8d2ec474d20ca60b92a199b908ddfea6d6524a5f31e14ad17a23383a08362d58feaddbbcabb2189fbcd77f7af01bf9ccf03258bdc45a33bd8ab5f4ce40226ae28c94993bff9d8e1f396c145d522ab5faeb68810e1fd9bad754e4a6e643b78e36428ca0623cbdc3a6fd290022c485f3f483f902a1528b8686ddd0207d80b97dbe2a1bb0a927054fc69f9db17bf03ffe063a3b72e92bcc04dbc7f6c1b3c4cd4fd3b3c3376da19960c11cf058c57159d3b4d85645b487278772704163382f2ae68f01dd1dc8153b4b91532f0969d8ec5082ba9bb34d9e9fcfb9ee8e0153cdacc679316b93beb294e7207593e775f0f3d9dc7e55783b57113a107fe4cccb03296f8b2193c091ff54c4e1955ac87680ec168c7279aa059cdaa3ef9afe9343090b37450dd77111d45c9c8cf75d9953f7e6247a9fb77193623051c725bb378c3a2f793d6a4f6e67bc8f54020c10656dd49da5b0fef0b8562ac14da06d2508db9e6ab6535d1a600bd699b0b055601bf3cd176181b264db2a93d9aa6768dfdd8b0d88b29386adc4735b2bce199cdec73fcd8f2edd2503c554c1a4a54adbc60090b9e56db02f09299348a8013e1b4811e52c5fac2dfe471f537e78060d6e8905ea63043212b6e1a396f494dfa31da7c9f7083a568bc8271c4d512a389a31c482c9f2d9e0172674ac9557677fa14904790b33d296d19c5681bc618d5c5d66d83f5e627f5a46d4b81496fd7a57fefc6d68b0455fb2d9ba47083438ac445a6d1a7ef23dce1c657bc3b7c0cc4ea3534d370cb6c93b90c50b4b0c4acdb9049e790efca9cd1934257338b85ee36b013508917ee5c12185501898dc3035372ffea3c89580d4a262cee287d46ce5c4f7200570c46fed166d6e220a20b17314e21e94383cd1ca1555ef39a5c889536f9be7c0db975b21f3efb78940963923a2164af102b63139e1b923b3c0fce32e2ba82af846b94753e85718596a50b077b37eb50748b8b85054b60e7d2b053f652e5767d9fe103a525e27ab03b16f6423a1a60b9fa077211fe2954fbe04f53cb37481075b9a8118a7734c9a3c4f61d49acad06640fa76ba0e17375644044f5be4d44f69ae2e4021f1984d4cff0218e1764deb1a3644178a3ca27b05bca2204893ea2784510d91e5bddf02ea6ebb19007dd9ca9c8817412195cca4e259fd78a30bca13b1a01c94564b70238ff6c7c09a889a5e8ad675d8738c5e5d9e75415bfbac51651843057d407e8aa95ad68314d79c97f7c8739b0c418cf1d08ff10b0bd648988fbf38845acdd5c5bf11eb413f05f2ee57f8329e2f30245cbb114607ab75262fa47c77233c8d875f921c133512218f7f58ff165f0215ea077ece86f483f7cfcc96488aedb6d15668b858b10922bb10abb7314c0851f6ddb8d708fe4609ae6e70b0870b51a7e2d528ed41990f84c862476f1fe34ae11701ceea7237e02d50a5df7b081be8a9e2f90bfc9b1cd4e583c7e96b9b8d7b77775c72fcc385dc36ae431c2c752ba30ab6da683c0690e168b569b7c32ed51343c2b33ff26cd7e3d0a1c482b0b719ec6869a5ed1c6f79d41d466e03083b4ee7fb2d7773e03d00d9727382cc910f49f08066e06494d275aff954bf3d7c60950651096bb560357fa9f9a95f3804d037f03fce0593fe85f9a2b7346bc0810ed0dcd2a5e0a31a40e566ad55f23ab2a7681a005a8dfc6b3904b7e68ff0f9b2c6cd99cb2aca3bcc9e0df5c0eb45e8a32e60b6f63deebf36b0313419ca0d6e8a32440387c00d928d4f15c6410f68ee01bdf7107ee01e45b94d5f0202f15912867518f029ae315cdcdfedb4c3fb06e194e0d48a419c1d9b35aaf5c4d45aa5e9c29801be12ef2b895cc3f85ca3739838171303d873d1391323b1aa4a1f70b95147fa5f89188b9b350f60017f950573c64701a3280ce06966ced4d5ed99bdb6dc071a56605b03e67c79441b2cf75200c508ae5608d4b8c9987a2b1f0344d7ecc4c705544c7e837f0793a33ad6abf673d39d1b6c623e645f886fa0c669061b6470e2e7fd7ee38c73936b28c2bee4bdbe91954b28a92474342f11d238bf3e8171b556ade0e5c46e0ef22020e137b42b6927e36c1126e9cb73b218be364ece567a8cbb7e18afc5c38c1dcc5943333c06a7a6da68f9c60c48cc4a60c4423b85d181a8e7f51ac198b765d866e424df0996448fa6b1c6148ad469e81a017d32f21076e82ade1e4870ce9e53232724a2a861a89d333eee1e418d65580f34f9ee5caed83cb63eb4bd2803d58db826368916712ba6171e8ad8d3ff06e78e5b11f945cc2b14662aea9475456f20cd84ed386847052a31007208c3fd47a1716921ad3c3f96a518e08bbbe941afcf4345ca0105035b0cd51f1296dc0d557f25893c64594726cb5e7d4125fc52a57487e83145c38894ee7e675bb2db39de821b760fb98ae0c5bf8092779fa9973c5565a0bbf3ce942b4c518f080eeb3a4a02dbd8945639c2f46f8dbd05c26ef901cd81a12a4bb82896d579511e589d9ba911982e1027bbc6c0c2d7b904fed2c77303cd817c4483645d1ec5c4bfcce7479155a7421bdf556a4995f25c898c71a62b3593f6d52f9a6675798e0bc9eb7532ea3e407de7fe9a6b69ba3760c60b804d9d23b8565b6ba8f8f0294fcf29cbf5dd755adcd569799f28fbd67e4aefe684489fb4c2e2117ec14e21ada62115720618d36dfad6189254625c7c1a8d2de95ded6ad233aefc44d05a52c225b384b5bfd4419c08215f361993423b499ee770985694b18ab5e0ac0730bf5ff7f8b53fc3755ceb7e6f2ece0313d9b1b907766093f8f4baf5e90722d1dacf25efac1dfaa49c5010d37f0f807f2d1da1a66c9dc6fec903d5204be3310a9f339fba92d73861c6a36892a61fc8871549359c971f47fa6863386967ae0873b31803e3632da74ec6a9605634e20e67e3dbf1cf718f2ce6c681f218842ab0ba146507c9b0a56dc0d60e53e60c1ede67999e91a5dcd195603288a2d047f2532ae6746671e2a491443ccc4442c2a1414d0ba0509455ea3fe52304bd8be6e8084680a38d34757478b80b60fa61d3ec0ee9702886250bf10634497f1821f2dcb57af901fe0cedf82d13b584e0dc351606721f1960dd8ee8342f8595056696ec0c8e633c5ee3ffe96dfd88f4b7925860339890b3473111873cbfa11294b95b6991fe8bdf0b948aeff8b8312be88dd6c91bc595a4cde3d4b684aa21d4267ece34601988d7ca50787ae1e05e25d9ac182d12fb0b7216436f2c6bd47aa4a9ab03d96e640661efef4f2746d3f2b964298ec7351eb787e97a788a5381ba08875960141feda8d3c9db63ba321fd9ffb7d7dbd416bd1212060fb623aae4746408c04a96f422fc1b89330e4a00defb99c4834a8eea6bdf7f6fb6e7af511a6574bbdb2a2acbf181949812f4720387aec0634813cbc492e930a7e63ffb7731267365640aaf2511f04ce71cc9e4cc5c2f435f22645b9212eec6969abc092ba364ebac88a9dff854be0aae58cd20151e5fe9a470698781c6fe86ccb56bd94f3d8a0215ef0f279be8e2d5e984eae1b2b8ba89771b188a429c8a7b23d472faeb7b5802b20896f21f2e93ef08e3eb071e32e35ede7a549e1a3eee8cd66ccb0ad4741e15a12b5dbb551146801aa31146766c2583ef2d36701db7ef55306cb834e07573fc0b878b436c3f2f1618b38bd2ec81d7a9bb54befed8008644e1cc90da2a1b8d47737b172047a743c215b412df5483e408335e2ae5d9224085de1c10ff24986c263b0f2b0e8328d29116a6db6d6896964d9889d566e599d43cf09645773f9cfe625b85f1746c72f86e53528b4d9ecdd0c610a16c8c5b2daaca7b46ed00b98f67b149056febe8ce9f2d5f39a8e7451dedf45d15bf82cb87ced1e0e4dd4557dbd8d878bb572382654968eeea8be0b77baab78261874ad3166c47c54ca9db246d26e5c7e27865f4c0cce7f58affdc07d5d8eb928bd4cf7fd661308ce24b7a77624484b7374f9304b5acb2f85baec5ef6a3d555e80beba4608618467127527b398f6d8171b7485fd28f0a47ea2dd76b05fa15f3e86b86887786d5e925e878480f720b2e8a015e54ddbb51ffc97bbe6ae96b7e3465327b4ae48b76806e5a022877d91279efd0cc04dea1c2577656439c086df37f3081b4fddc895ab9c023bd262e3d07970b1dfb8e19acf81f2ea1102824a0b24f0f85bb94e594bf1fba7428fe67a08c6328999e52918edf4161dd09c25f2204f2137eedec8adf028e3d302ddab7b45040c395f4c243e228dbb83c039fff04a7633cbc3e5c11045e0729e24d7408ee0c399149baf36ddfad44cfb2fd5156e3eed41225731c2f6e6410fd754c1c9ece570ed24deed198a5727b2aa26f43e294a2552637e29cf288ee8b57406783564a49b35354c44955b58dbb69fb7326c7c909155961a8cdb409a5610755b8eddf9e636fd5fef8c7de2a0f9cd5d1764832f078d94bca91026f39e6ff2a1b36563cf4aa2619c8a9765eb869044f7ad85d8ff0c577ee6d4f28dc285dc20957b50b1d221d6627e50f82f977a95c869e247600647d94fd91fd6b45a7082cb1ec596ca4d2826d08ff65c78bc50ac209d0b3cfb447347b4131c3c2bd6e5de87f303c4d84b64b3695b0741daa6c0fa2dd1caa8f80d25524140c7383be514af42aea0f156f780feeb0a1712b24155d559e1eb2a1bce96de2b9190c50d12d1ac438aef3aaeffdfc07585b0a0f57fa8ece58c44c5188b8c3ba5a431127fdece0abd7b12d7744f9bbe67687f03f63c73eee2f8f91e853269c25d0c7af4b95f996c3500a6519adf6fc21dca23fd07704a607b3aef345e81154df67003353426f6426861c5edc2dc92d7c6399b2cf6c0e5e16e3d6048ea99e2649d81efe554b6a702c6f1e6caf22f1f24491c9daad9891b12027a9ede1397a6b0c6aa4740afc3bfe9d929d2d0a1e2f1406ca546ee99fc611727084c9a20ea7c43a2cf93d00c5b6fb3e9fa05b23abb483dd7dad9850567ed80878a8e07004a261eb1e3a8fe3011d001a1b10a2848addb680e7b921ee2a789352b68cd8c21a83d2fa96af0284fe9bbe8f161a3785d5badc5a3d293b49613ea04ee41c685f92b6b88524fd371b8650ca531bfc96d010e9ad28e04624a8b94ac4d67f87ea7d2eb30e7e4c4c98ffbab56ac9e94b08f3688f3903d35d11467874beed8934f36453d224939cd3e61cefb3f5e91144fbf188605ca5edba12f09b5ec748628018030cb1aba39b2ad2222bd01417b97acafe5f8b34b6886bddf3540426f7814c3a6edb06f9589fa465e20d405984d84ffeb1988947f05876e3761c5ef8c5d75e63dd670292e33d0e97629d24d1d5ff11f206beff490d820bf0ec0e28b9c1ea27643eda34d0106821fa72701a5801591c94d328a30419c8f415f9cd067b50d3c1fbb311192fa25e5cea8b9e98cb131499ee98ee537dd89bde27434256464fe111e779db1e9d77da6b17e315cef4ab47f847bd9bba0561090a3141a0e2c847faa8ed261155f90b0218b5561299c1d72acb12e4bd69afeb03a9783a0e98f691964469dae3ffbfe1dfdfee1510a7e5dbc40c120ed611c6c213cbd4671e276afbf5ef241efa95f06b2159d31156b17a0318b4dcd3312d7c53f6e75c80b55832fd38f76df3397ad1d0837db7f7ee0db51b83d8673f3537d3fc66c78bfe0622fe5f677f88d23fee1eb9adcd290e5a228707a81d57be02035012c226e8ed035d092c77c0666c6bfb7a59a04af17fb6b15db3dfd75f6767002bf7fc2e76fc5d039947a5917e330e3468d9840d3d43c56adebb1fe7cf9f651d8fc3b660ec7d538c9e84eea25620460e564bf3ddb7a3c08bd4ec13637adac9fc5ca296bb96ff96b7e09c7574e7ba419f157daf1d0fac31876e6b7d5a73faece479504e01aa6e68fd77e187d03f3db1c960a7b82ef0fb06d28025ebb4f11f76036046994606ac3e2b5dd16991d8a694fbd9b47922e814f2d43a471b2ef0864dc93a10372fcafcdceadc30320d255415489a3654cbf44eb399759cab8bfdbe3ceb9bffbf26f4a133e038de7b08baf94ceeb699ca583c59d6b440d29f567ec2f5fa94d3e1184b59538deb4b0a41a42b5a92acf2d10933d68921d9a0f11c9a3e08da98061239ab6d26791adc62a6fc0e7227cf34d285ab9dad4fbea4f3964d6106a8651362c3337c786477ff986a92cef2655fe65a16142d3e3be668cf2ff5d118ee008631da2713aa8f17a6f74fcc04302cdc8bab811972ab05c0f0148c525e109bbf6740de3e7c8ff58ca6bff02d7ba8b2c1d9ca84d89c04d32cc2d3cab9abe0cbdf2763f95a8e09cf5724af37c8421235eaee93c328eb9a81eaccb7bd2267df80105caa7d6d53beee3595dcb09c458d41099f0ed8c86966f6032230bd94ff8248cf60db1b1940103ed5e9556ec206f04412b1b5391a9ac4c493fba86813c812e986fa3544f5544f35cbbe1625618c2c8c19d5b4e12ae501e342c7293b4d03aafa9181910b8fe05082a75dc5d21b43b02b44133b6bf10d86770c583a04d1b848e0ecf2bbc06e82b412183f85e141c4f14dec611bb76a8f0d24e587c3e3f923a437160442c50471414474bd789d716f578554f4a4575b1166c6731a2275e60d2a09fe3cf14f0c2e854637a96ea764b000691ebd06b10f72d938c20ef8152077ed4636f2d9317a199f551c7f425de3d23e455096bda54ed20a2cb576e81ed8a064641e2fbac994dbb332cd6c7f8b68d89cbfcc358755005a51eafcb44b67a693d5df97d80aef95ebcc4f199279461881863389a80ca78eeeb1fdff2b68bd0bc5d8d23ae8494c5779086aa134a38ff1a81f8d7d91a29ae35dd4b5841bfc1dd6932fb94c6b9539fd26999cf2e5a8fce50eb63765cb59cbada11db8d84f63a47d282c9a3989940a49e68d4a158358daddfcea0ce721e76c03f71ef1a4d221cc511fadc574feb769f16aa69489028d4e24888fc108e888a0d4c9b613b67bfe09d729fd1e41e15e9d3bdeff84c339f1a1ba3627f1d134ecf99230a04c604e52fed7143772cbee03a294823200373e55e5b485464555133bd9b9307b9a8418844d82336d19db38d840bf46ce414d20f508afe47894911b614edc73022214c151c12346f4be375c7ce4b04e82f159c205476215ebee13ddfd6ab3f215fd2daf6b1022a0191ee9c281e77eabfb03eaea5d957712c255c3313a121ad2c47e1d35f25b26903304611005f227773baf362ad050c8f0c5b7ac69e0b71a24a2cc126c76245a60f685f64a1437c2f321742ae8ee908f273e4bb5512551ca24e69821ef13c3c6bfbd03954add15e5e4caf0e62d4cd8542cb69d71a549a2f24254253ddf665f0eb9ded873de52f703600afce15ff8cf29ee5f22f78a9f96d34b838135db835b474938a907f04bf8818f9d689298777a659ab6d592d72d30efe9aa0b66ad45f6a6db06ccdbed39cac4f12a47dbadc9aa3478378b7b772fd0c8a8c357acab480495e1e214a60cfef63fdd2397c367e11b14e1dff90da4cdc1ebf754710bdd798079b27419115bd72c011b31e0264b0c52fcd7956d12f4282b49c1accc75cde9970d2afc69a3ef277005544eb621dca95343e23a77e761d1118042fd158e709c2ace6d87bd77cac5babcdf80df2484c16e1bf38f7b9a36b02509f034c57c95fe627727e6cfc2b0d3ec0ed55c4b12862ae400d22fa7354465ebea30db4a23e2cab50cfad13bb11308f2eeda4a7b9d061ef8ae5a10597c0447ac7257cbc2d87fc404309cadf3d1f8505fa55a66a1fd64a55962ae6598fce6cc7cb63d25e1d730a023ac8c5ef6276a87fa026458fb21d20ca5a8fb56c3c5074ac4f787159e9fce44eb38547e9f53d2b77a6c9956f56fd87353ee322e4dab49f6687886e62472432b423970f8d618588e99b68266abd68b8816b46ec462996a70c2d5f17f3fcf692232b66a9d8f9f4fd2f252d8e8d5e7e0e722578ad86c3650a07eaa1f77f8d5bf4e695fc69ef514c9cea950f1aa351e7577e03f358125c8afd12fd5e81743250a0367f19ea0eafe0f36a114126c4ef44c3ea6a1a14fdfc7698025bb54a442b0245b35ab4d203c651a99b33b77be486d8472a3fc4e185e67d2f5ae33299bb2e16b906a783f9ea0e4566371a42dd3de4ec4651745d49254dbecfc5c4dd94108bfbd4de9ade5ccd8acc7e77c0ce3656617ef0c0504decfa101dbd844f181eac631553816063a37a379df0f2962cb09ee08e9c6cc7cf26176d88244eea8efa6ce3fb4295799d7594dbc64faf25c052446add4224583b53e1cb5d4ca225b538f7eab5db0a95bd2e587b1514bf54a66868fb4fe27e87ceed000416ca476fa0d5665aa2216a2d666a3afee0474a38079ce8118a8980a86b5845968fec5cfe459028523c61f65a0aa958d39010ff9c0c3e66bc5ec57a275b5d751ed9a5e99d2084b8739ae4d5066bbee3fca6f995f09e371b7cb41847754c1ba9d2e116ce5e3f801be051c8dac1c583425d1adc42bbe96539430477694ac2c6ab1c8facb9dcabfd0536efd0abd74d5c637f26577bdb390ba9bbc80334a108cc74014e2e1eebdf86acbf6c08b8d0bccec7e9e49c6c11faa48bbe45ae0f37f2b03020512bad58baaf1a0fe3b492bdff7c02705b32732167adec726964fd0a2b0ef4fe02dc533ef8e3f3a3ad38d9207c2fc8f9e3429710667a26a0c376c3e77f41191b72a7e354350f798bfd642090dc62648d2fc87f8fa18b7b45832c8f952207b3c8b511c39651cb500d7e9424f0ed9d6355ad604fc05e8f660cd0c166f27d3e791648d1a1facd274fadf1173e0b804e0c8709c74d31cb665046b3168ba24d115a8e841dd0abcb9bc1ddcec90afe539c26fa2a1615cb83eb1568cfd577b3fa75a39a08b611e30f4e24c33622d7d7c3199e29ce66747cfa6e88cfe81645900a2f4080a080de4207f32b8e590c1f0f2ec6370b14635574e7a19fd660c811cd3509743f2fa68ba500b28e684889ebf927086ee54fd26f10b3c4a56dfa68dee86ed4a6b18f3e6b0477f9e1a900ad8c103395eaf9218e6c7bf90cc022b7bbe9d9c779b70b2c6139150ff753c52330f7d6477f513957f265a3e3b28c8e5d049ff1a78ac43004d6831bcfa4e08e9e9e135c9e928ceaa0880913ad7a7722b1f4200f40da1daf8c939f343f04c0791468b4423102178039b9231b12baed784f081ccb590d958084a08b5bb3e8c282c43122fa9bb343f4bbfd4b6dfb0aad0c3b5c3329b526026e22537f7456289d2c634cb121ececc5a3affc0b6305b3a4be517cd12383f60fe0d09a2249d005d1569d7edd33fc921bac2369518faea21a4736b94a3a58e0860709fe801c67f5d9fbed0434d13f0884dde3906167a7b195f5ba2aa8e23134a8accef62ec77cf5c96d0c842b2bd41c69ebf62a0229f31117d4b8dd4a3199465d23bfe244f2bd29f34834012dd2ee3ccb154125b6065bf548c6c37abe392b4b80035d9a231159fcd2dddb91ada8da8fb246ea812fbcc3a5cb2922b41b88156f13d5ad117a49a27be82bd9eb5c76151ab9222b9bad0f26b5a005098a1f9e0474046eed8659cb7cc5c55e1787e89301f489d42847fd52e996317b3b554323243bfb0ec34a57832db60d7831c8148f8abe4a5275d70ffae88680e9dca37d53e4ae5ed3027d30ba4ecf74a34615e0bd0c134d92ec3e098e9578418e3007d5fd643c4d1065739b0806c52376734f5e63097644749de14f9e59b6bbbbd302014da609ca3f966c07289b99bb004850c81874ee6b025a53546aaf8352fd695b5c2b272d38509cd1bfd3ca2273eecad6b23b9b83984d924ed6be318d428b938cceed651e0e3fd575642d7a06ce98a1b1f1331c1c7053eff0a117a9c655ff5c17dbafeed486299c6bcfa67142bdee1810557382b08fbdcd547d3cc7ddc087b2fbbafd20065d782c0907083ec4310b634c0fc1f9f2a513e6599afe3bf194d35dee54c8a2badb6999e66c157da117494360846b43df979e4e497d392ab841f47a903a66e0cb81c9e34f5bb3ea3d2564150a0d494290e5ab54184e988d8e25adf972ba99e5d437b804db18cb355c221cc8a5eb5d72c94e125203e09f8ed6f381287d2ccf66d08aa4b01b4fca3e31ed631450ee7c4bfcf94a1d0a830620ed2bfa22e79c2c2b4673af5d185098ab9df7483898b5f3c32b875a7d8c1da3417b068cd35c5d43e3aed9b3b1b25927d8926e68e10a73079f46c73bfd1c8ecb647514d7d5fde47ec7ac86be86aa0f605a3351d3aed01a0b6923750cb0b41b7b733ebfdff277acde98cf048c6c2d39a1988dc0c0bdbf5deb95f67e7985540247f27549ca50b9f7c4e80b6e4178d5d25ceda744d4a87c9195d8e5500b05fc92be76d57ff6287fb7bc41d347a3f558b8193f866605426e5eaf64c87844f0ec78d976f5de0cfb85e0d2655d83a75d50cd78ff251a0ce7ac862df52c1e160396f8b2748c016fce7c56d0e2015be1c75c92acd85e249e4c4de187162d3dcde81c8c5f834223f31f75cc618981a4fdc87d98db4e956f89c92752765483b0f21d3fad996d45b7b822e5333c8660e9a066fa7d5203234fcdc93614a37dffb6005679ae97bea144aed3a7fae4ec420fb8587faaa91c030cf80a13e370125ff24234c1237d1c1a123d6095df91d36d48aab2edf214b7e5f4494b876b56793d51ca7964622b897a087fc74381304ca6871ba919ccc0c277982d1a912d76dcc46c77d08f7d0abe5237c53c8cd9a4c5b7ad84c1ae6d9f920850d580ccd98ded255b7744c3f8f3a0a2ebfe2b00a76d11a65f75c1e5db4f8ee2ee21a835e65f48fa2bc0349360186c3f7dfc717f8ba5011647b220eda5d0e90d90058d6f7e697968aa6c95cb0ce98703cf63816b52af12d831d82244a61ed6c1e9c742fb7d767bc2f1e4be1bde128d4f4948c94a15adfd77b1755c78ae2d0e28ffb3c9a9f4e828860ff18b7194f024652c19b9f94bd076a3bbdf48f0a539cd41c6ce043720d3aad2c3032b479b289698c248b54202c390837c38329442a18d734fe2008a915eb6721507011096e848e8fb924ddd2b7088bb3160a7e70b4074e42aabb43b13cb40765382c7ec2508c4218a92e1f43af560f4122971ed2d8aabf426b363113375ce01bfbe98989fa56df391f2596d9ea7cf4eb4f0804eb48bd4a4c2c4ed0e15f18cbfc2ba345c38084692695e71dfbe9a544f5139ab3641d02423f23e80e6f1df535abf4e0583acf58ffdae5566f33b32397b61ff632a949e236a6ec28a17484c3033d03266047f3b459cc341173623cd0f093eec7503ffcbe00c96f1eddacb5a651775ce2f648fd8b165e36bcaad5a1ffff8801f565403ec87bf09676956f9b0083aab8c509c9d2bb3135f022d46d0a21b465c4069b9f9bf40799f694709b0a08da0f1a1da07db92af2aa6b87349c09e79e30474f2c7056b3689e0b92ca8bd9f1f596c35ecc78233b40cdb8b0416c5d87f869beb02f486c0a1b861a0bde17f6b8ba19b6e055db81699ffcf54ca4e8126c9aa9c533e228b138f34e9484088e1d5e0edf4c29ff3085b742b3485c798fd160125072c52a304aee35d5e6d429aa4ae365051c71c61d46ab690b4bf33d222816a5579623616673a3128e9fb1948486997e857d45886f598dc2b0aae9c4a8c33419d7052d4f6f02da0c5e3ac839eb1e2130838d4ad51fdda755ec4c0fb040efdb4d36cedc8860217c851b167842a1f003e2a7f70bb895c0edd3dfd7911ff001b9a37b9eec63e7a82313b3f0014f0c9bee5052486ff28a16c0b28ffbf2b568b9b6223314cfaaa0c228caf42190e5161c977859663897101f880aa638ef35a7dfc25c295edd20eb3a4b8973f867716d88dca064b53f62d01fb2fd20be8658d999cad1168fad28c3b7602a972ddc25dbdc326105171da80b449832f99f511dc3ff3af7291bb8420b9e99fb071f1b0d42fa4616b2730998ab1a201d2230c905d53e9b62ced02f988f26a110a05722fa5141ae7a0abee3d2e2a1bf90b05bfbcc5f53d19371358f76a9ebc4b8c8a8e479e0e8dd1668ca977523f43ce96c73fdb9967f4a00da8c52c19f24460b8d2e7a8822c415e038c2d2ac8c7f16407e080ecbfd12615b5b9a1243faeecadf538b9ae733e55ef02c95799b5dde0036e6613a5c5f3e660d5255fcb4a4c8019922c5c85919143098e97d702e9097569d447f549d5d4b582f688ca387a74cfee3798855d1974da87866538fe03218341facfe878b1357c4e9ca5ae90ade5179145ca45d99d18d7649a411a196d66a284dabb688c6381302b36dacc890b600813d2a49164bebed7053660399696b1b149f25dda9db26d5d32ab7e27de130b857a1a94835e42ae630f7e59f04658677907b767c5d1184bd4a7c118819ca71d7037fcb87984126aaa10804dacc41bfee68ce07a8125f4e5ba77580de1e2de4741ab4f638bc7f4e9517c4414417793eddedb7940f8072020ca6cba77f7b64c6fd3ec3708a41de51acf4f46496c6d796a6c60fd4b53ab598d53074be38a751fd4477bef1c9676014cb10ea3a7e67c34fe3eb76ef4e4edb5e3be102da3b59c9a5a8729d6dde98f6c8c27f562da7aeeb429c6594165ca445c5cf1356361e7de866661c3160eceaac8809df8bb67038f45c3dabf3fdabf852de332b8de035305f27aa194169ffe7849eac48863c3472cd016fc047416df0af34db3ae71942992abcb38e1b3805a4b50516f8d8c4b3609cde58d39635f7abab27c4b76525fb8dc303b8ae5942c73e6770d552819be20f82c2812eaf4c3ad4723edd2982798b89bef863aece60b5fe7e9cf74d6f60dadb25f7572d17c4ef9ca412a80d7c34958971054792bdc639c1a1829e5afd361554a93909636cc878f2c22913dbd65bafb9226f8dca919d9fc09e7cc939dbf568fa51b11bde05541e4b26ed5f3c6d6b1685aed467ff6e647c3fe561e775fecbd3ee1360827ca0e42cd94ba10778b9db7d2b9b15af8941e2bbda54cbcc5fa1ad719801e3ea2917d579f5c200e4bb36cbefbc57f92f03bce68ab87774592cd6dc251a44390269618231f7f75513dcee728ea01a57ae31260a08152a437755119305d12ae0b8c482557b70cdb3ab87fab733172dfb29a605d3b3ff2f3eeb9d905186d7241a2b96b4dc49b4699f544563c6731aec741ac211cd368371f61805dcbce93d57ed125c8f4429d7844a1368a14810ce3cdfb36480676d3ad02881e4cb999d4695659f0fd6a9491803909236835482f1511a975a0cf59bcbe23602ed4549e8a9084f11c7dde8b48db97f1126f302b28659628840b7b459b4acb07feff9f92c2cb721cad7edd46689f4f728d4559c5545117b7cd48402460b09b167ba562625d9f41f73431f46ef8d5657c89ed19e4039e694b164e96d7dcd12161f04cdd17b52f971e917b94e6fc334b0b85d4cf074b219d52e30b77b4f1ac54574853bb64b12030ad0990033a7d4552b29286a012b66e94c0744f8f24b1171f30e3cabc3f923d41b6998edda7ef95a937f790e50011f083f1810dec00db32e5e1a33f75d42a4729c328a848d30609e05770736fa71473722f6e9f99d0b091f248a875270d2b7e96b7209eb0211e600779f2e150e950ca98113d2541ba2b483fa146a10f899b8d42138959496ebee0a28e5643d0a7871582076d76f842af46281493304045bf6b8a7de812afa5d6efbd507d91d35e107816302cb761175fe0477008b3017b290768759d2555fd3b0cd8b05c57772a6c189a05ed8a145898a62fed78166a059ccd3cfbf01503793b96745ff59692beedeb998385f37322abd09c5ee6f8d8f211eea27dd804ea4cd3ba2329517f5255d29f14fd993652f3ef6716118819240788ef486436b0aca2f3032184a1b6f5d31b09e26747f778c671e9e2b5302df2431ec80d8596f80ea791f9c2a38493a80c17f71be288eafcdfbbd7cf56b0423d049fea44a493b86b8c7768b3bca90836b661721bd257362f502094cf25d19ebb2be879d3f602bc57e4b84cc112a261a786db13837f415f226bf253dcf35353f474055d9bec130db9c489d82fabd44b2871d9993ec23321e32ae356a87a4200b3fd4a8b67221d387c2b9849433c07283","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
