<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5250c4f94fe3f691af82d48ea639fe954ddc3d9d5c44239a0395d81ffffd853eb968db485dbbc2f003515d42c3a738d264bf057b892cfb4519d4c3a36003e3a9abe9033834737a1ca51e06fc0586dd472f0bad38483356c43b302990fe25c45fbf1e6743812b19c4deb5a9df9550ea3b0420e9d258bec3e9ec0b93aeab62ff5ad08d49e21082376ba634faa703d6684bf5e627866f9707b44b20570287fa5ba9ee06483fea43f48e9d5a88c434948b14953dafc72c412c29d37c3f863241c69628ae3364ce5cceac7a0c3c3cff66bf0a2862456b0270c59c2602ff95e0a8061212dda0da5471abed86b6c50b3fbdc583f1ee935dfc05411e4ea199cc816d43e4e876a71db6896c67c203283ddcc43e52975b0e6b38211cffc52467bdc3e24eb9abd3c952d6f6c8a4975d02c7cbd4aa00eed6efeab42278cc303e28cfd373d6bf213a6399424f7e93709bfb57517f5018c2d0414be3e423633dc988a9ae5e28d5f9a90d771f2d4d8793b106f9ac7c34cc0484a2ff159174b54b7383437ee44b18e71a3e91d925741e555a5b1de6d6d7c63f49569725b6d7d592fe9cb4f7ca8bc6bd34374bf86797eb340cd60dd04aa0a07a56e1d27aa58f4624a253d14e17b9fe8f8d9e517eaeffcf7cd796aa2e9c04b551555124dd995f4dd7db361f5b06982b38708af94c121ef797d03f7cbd1cc82635b7234611eadd57234dc53ace6782ccac4c92a2cac4d70cb4902fdd243b0850bf618ff2e8f32d128b87ac24f2c1dedeedabdb7001ac37b1d537daad6f89f4df0d8d726249f7339baa2d1ec958de96f76bae757c7e8b9b40e5fd46b059b9686165ebe4aaa600494325089bc407a497cfd9544d2ffc51806ca4a362dc547b11853ba4f6b2252a2f43d2ffd3e6912265032ea8f95bf11d74c9def09cd8c36b4d2b890ab80b053032cd9384dbf2d18f6062a53bdda36a0cf53937ac2f148edc43a69e5a49effb7fbc49501d97f09fdbd9f2a9254fcb13da4507f63c9740593b8aee0ad09d3ada3b36928d334dca3a516dcc68cf8e7739f3f22a245ad183080373431ffa91c7702271041d6c72337e582d7e5452f0e4800163706270f40e5d44a4b4f7af5375a9faa7db642d152b49cb94dc338f76661a9cea05ba5ce6a868f12892be6088ff77370b45dcd6231af70e379610413e36c3825b067b91ead8cb950aedc62f908d48ba662644f0a3981541225380cbefc1ca1edf7b7bc5c84e3619b80b5114b98ea68fcfbcadc11cc37f5abef0869ffd97716e1d963928c3c80b3be0ddd7cc07fcc45cf3742ad7be58cddd432d89f1a88b91a23782ae331f31293b57d35a57d8af8cc739eb86c9f9425d7b1f2b4b7e782306da1413c972fbbf89003c30b2b450abddb7e654e6ecb23ac66457fa84ac7d6c8d413f2b9f6bdcbae7b267a91ff94815be27c409a7274f863ec59bac311f4e84ade68946c902dacaff9d6b340368ce669d5bc76bb69d640669f51ae18fe8b2034652f780aa89fc7827f2035858c67632f55a90ec2d288eff8fc5b79865fbf25e25ee851cda24491bf668d2fc7aa4e9d9320573ed8b8747c9091922d970f13c96146d674a16fbe087ffcc6a4a0df2e52f61267412fde5fab302d974b8bc079693bbf5c4dd30d67cbe385f16142454d86d80c7f92187ff1bb5ef7ad8aab040997f74b2181ef0b7d1f888e2b998c28118d13f8b3c7bf01acb87a98dd9e2bf8ef7b851b5da48ba31283731eca926161561392f2582886f126e0f83a32d8d992fe7d13e2361beeb2c87a617703b9ff6f6d098d31004cb6e7c4a228115c6925b7fec231ac887fd5c534c8fe2cb38201ed0d09cd7af58d79401cce0db63f3864862bdd788e2a1a218f50ab316f292e81034e4a77b2a7efe4c19efa49b8db55e307cc202dde92f862e1d8ec7c38455fd74576854bd71ffed93499ea645919368793630da37ff36ea34838d50834e0ce94c1001d0e2af92f99082760f0059f5de59a9ec970a2b6d502d963eaa880d9f2d3a8990027c97cf968da13c0e4a84ccff8e7922c6ed7bf4d9b150d6f24cc8916c788089165324e8a39b09be0110db372b7dea92bdf64e208da8b3fb7499fcc96a345e747f3113c88955b853a44def2832a58d199654b3962e0042c199fe1ae261a3f7c67c49308209f0e0b47e574fbd7293b50dbca42b862b0b477ed483bc27b23eca8d145438785c036502ddab7d867a8e2606b872f4f10c6309e3cea55843b1b40883f516338b3ffa962eb2f9792319204e282915fa13f547e2fc5e35bcd42142e76cfac50924744a1021767d7140e7e8302c08510d0b43d38431a447ba323f0c57dd90cf9c60564c8f6681a943aae7d000fcfed3c87a2764627989c918b834b64bb30e05afa7e3905511260d41c63a9d400691af4e02059637af05f130e9d4cab6cd3f2aefe7a46daa3b3339ba842f3be44ba2ef0917d304840949e66ebe4cd12bb390d6ebf313d0cb1b5adc70e11cfd7939dbe15e3e1926dba47e6fcda1158b57c17ceda46186959eabdc971d1a889f9e5f463ba310e35bd4d94eff4a2a53f04ae125b538ef4b9449810d310b00c04e0e916928c30a5c1e4288c73b2ba481fdf7bc2343c3a6e0a0b31a825e260191804d7f06b11d1185da9b4c330b6019c83f4cc841b91661998339af572e8b73128e65c93226d14634b7e87255cb27d90b5767d69ac1aa0bc6d613d288c8f2f979c14ffa3442ee7c4dae89227fbfbcd36e2ff30a6419a3a1f22e272705051fe1e45e6d51887bbdda5a387f7d7ec04d4d4975468fe02f1a434f81d1aa0c2e117fb51c0f551500e97b347ca4c01880d8f71d7c73f602fafae67fc6431754c81a4854f32a99f09c5b190903b5f7db26c85a2a8af5cdd3b8c9a55c62db35c7af1016c04c3c938508d91f17f80e85e4ca29a212633ed735566e73390a6eafe667694b1f27523364ced87b8a59887bd0863dd480637eb5fb433c8569452811feaef09a0780eeb0a98911bf855d0e6bbd46c4964ece5873fd72c5b03420f93e1797b02978f077146869163ffe7f58297a325e6a87ee4eeeeca61980567a7db813a58935192802e45695db172f0d7d9eed81afdcc9593e248751d4d5db9da981b829718f33dba5c44ec2b532bd6d7ce2e8ab34bec0a8128cb2ed6a0c0872c72adfe6914bf9cb1147e0e0512bcdea7e584e0f4b176e35dc662f87e728abce9ec54743adc053f807e1cd54a4e5c7c98cb1b329538483e2f93066c1954297529d65cac9f1c693a40163401e1ff7049ec243e3bb1e566f923a4150b2fa5c5b72bbefa047dbb83e18859e4f989f062c0e9112f3a5a5a8fd7b44508b1af72d1d4e6d4b5e7cd4f713a8b16c1367468d1d5f776ffaba3e5e9ec0332f7bf176080eb5931922b8af121e7a52401d768f122a6d7d2b9158f1afee0076de7da9b9709ca61e913c2f796d313d78b697ad39aeac6ef9ddaa95ca36982c3275155a98945f98e32f69f738747b14cebe38153ccdbf424558cc8c4215b0452ca6b3730910221b473d4d3feafa9746b21c083eb3cc5b81a635d04e60cdfb78007ca4fc039edc491a98e88cda597e66134d5edabdab23cfa1102e41ae40e135aa21325ff6399e4e866e52b90a08860b7a2ea0f29a57a9bb64c632aad4fb9e5fc252a0d92d816828ccbcb00cb060fa22ca0acffa7ab614461216aad6f76f057f3b947c8ab5c5c668f406ebc6ada9c5bd2836cad7941b548b40e3d2fcc43b4fb924b20ed29936cddae4f23980981be1e66110a0cc1e49ce1321d8f5aed3c20387a238e17d3ff3f6265b7f1584461252c044c622904861fd10c191d34cc227230ffd75c11b269a6a4f4c621452e1cf86b2b48f4675bc19742cbd91d9d5ecebcb8189473b370acd70e0507fc5e7d08ad9b8cf42f96eb73698d4dc1aee3334173964c0f875081147a0cd475236a42c9bd7dc04a1c5d13fdd62d36109278c9002f254b5700182c7c8412488ca911a5ead6e9965f8bf72beae54b0c2fdd848d41212007060a8862bb478092357548ec25f8766f7f6b4aeaab0f1b9181bc6ec0d7be806e998e708d6c450280d78822c83f93793d74295a9dd0392eb821a710bb2d73e0d4286c121220a51e8a6f684ef22e0c70874e5eaa871c048a68e3763ac3bcfa446dced791d836edf4fdf44a161a10db11af28dab3facb962efd52a54a7b2524d9fd6e2841e042b44a8726013a8795059c6debce467b8796350af79183360fc1bd42e7f83bb0068eead6b3c2a17ecccbbdc5df6247e9df456f708ad28c7956d0bb4737e9e028ace040a53cf6a602bfd6b7ca35ca8075a9e853a19f816ac96b35d541b9f21b2270b1ed8fe9ead8f301dc50de31299f1042a20ee0a3d9a4d57eaf037e795fb3dc4780191ae8ecbe727e1fd836bcdbad141427dc4c7e7b755414aace1388ad67dbbe0918f9f3bb744c92080207dbf9ce7c7752f59c906cf418a633f0d9b1add626182a3cbeedf806d7a32ade788af3619004e9f8378289fb7efc4ca41211e5619f941dfd61b4302bead0a27e504a40daa227c8fd76ba7ff50cdd864f1520248940fb48500f0b97b2f8527b7961e07d4949ee242159a78c834603ac43b48544538ea352f2742e56eeb736daa3789b4c8034863d7d9445d8c63b83ceb0385e641590e5e5126c751086ee3f10816bf9eb3cc83cefdad264f64131faf6952e0386a1c6388e14f5a25d1269d6e5512c9ff0222c75da43875fc1923eaf85964114fe5363257e8f98cee2fcb8081d7c63ff4b532546db6f233989a579b5a290a9901fbd208e6635084cf96543be6e69bbcb623f253d7cf93c4873c07ff8d43f1e75746d22f06f32746c1f4eadeebe8f2c4e3569f45e8969b3996e54114db30cb51bffe8df6afa6864e78cd7d9c391b84dcc532ab74d21f309401cec0b86b87023cac35603c09138a47246ea87a986c047a6eaed760ca1ab9134380a409a3a11b4687fd073ea051e6b7586ef777025433002a52b99cb6c749102aba5663f1e71a916d7df179983fb3133b91017fd2a0daf29e3b10d3f10914d77ec019444073521ff44d168ecca7a7e0b65a619b3b308247caac221426aeeafde7e771360f616b058fa687e941551b551f447dcc62d0adae0d4c1ffe3ccf4627505e7497ec296479ba67fd7260891be28f9069116bf2cd5bb8f9d895a33ec7ed92411312b61d3e9700f974556a1f3c1c63ce2eb45b8e142b31eb87b72459a28a4ad488a62dde6943e572ac365a34a4987b5ed70acb111f4df58d3dab7fad09e57a85955548c0b6c8153c75c31361630e86257bf59d9e8e78f02735d1c8268cad42de4ddcbaa083bcc1dfef4b01c13974eb2021039e6f59d74de740dddc6a6c188a27e5111039383e276010ca6347e6d5702ddd1d27019baaf9fbfcb94764c0597a74dfbe0e8268398f1e30ec89b8eae76e926aa37bd24a7a94c15c200274cac7d37387b267610a8de1110ee64a576eb015a1064d2c65be69897bd562aafb8e47c8feb1fb3d0cacae1c4d4e5718bec5d4da38f7cede41985383dc7b9572bb16b68fc27eb61811739b9ba0e0148bdb1790da7e56495ffc46ca9e8f86b31a91084d4d07abed108ecec2dc7633a732bf5060412e9b26a5a6d64f7465a1689e253dd5e4fb356e4f5ee94e2461aa8729419fe6f90ae6924e4cded278f066e894d0f2ee6617cc2f52128df0e0fd4f800b32ddf12e5dfd2e8b637df14084acd5e7dc9e0bb1d3cda748040521bed44672bcccae9c0f48802c11e230f2b391b1fd3b93c17c0c3cafa69e62445da4b8be59fc5b817455e736852fd8c31466577ac8e6845a286050da85f0148d1e7246f356fb1d912ccd68a21461603db830cb5f32b06dd2e023a35f45e14f93685bf07ab85dd334c00d2fc9aecffb1fbfd8e5995948388addbcf847c81befe99ae1fc178df837611d8c7fd1dd7c154c1c4b87c90b6d9dc1d512d10234ee2bf96f077dbcb6098eba1d622725b4f3ec1bbd9b5dde646820f16c6b5ca180ccc0768f4fa1819760c41d224706075f5a015b5af0a35a605c08c0dc5989b969c08e483139fafc7dc6877ad0afc63dabe0f6175290c75fddd626d5464dd25c95f77e451f16fcb405d3fa2f195a42eaa201e4b99cbb1dd2127c8ec3e641c6234a39267678e8a9f7a941b8a652ff1f38e86e23dd014fd1dea51765b7c56aa1ba4812d14c372b3daf0a877778ee017f15971c9bf8b9bc1f5cf074f72378ebaa7021853a91e10d3b0b4da18bcb1e36b829fe1d5868dd5d1a7237d4469d947d61b2b953e871763d0030c9fb436a32fe8f7f5e8ba4bf5f317a2038dfdc62152d6d173eec7657c3e45b9e7242f5967a37381e85caa6f97e1bf1f406ab9d66076bb51e3e477ba741828f12ec67f73180adfcfd1561afe0c03fd70fa2059661ba9c8f08c571ec9bd1bc6083d04a4e1792990c95e9b49d0104b2ab4a33140518980fc2b7bdd3614439bf0cd2550b93cd96cc1a16e6bd524a1d21a97511caafbf52319d758b73bf912828a86bf41bc85cddcd967ffb0ddf4b6d333b91befdb586e2808a514512a808033737ceae5881c907bbe97f306519eb374f8b29d7a824253c560575b104eb751ac5c569647739a29a991edee3ece429845052843bc020d622593807fc6fd4561a7a6f78d502f3497eeb3f77f6682bed68225a766b0ebc8fd23032de968c1dcd233f3609f1f8ae2acc5ec1231560faa00bcc385b12636178836ae442ee482fbcd1a2208c337d41572fcb1a406d7faa20263fd759e351eb391a930a7d5f1c98cf68d21b2317cf1c62ca49d924314712d102a5ce40f4837bb247647e1ce7239a8d22eb421ff114a4269ab9fa3404867613259fe068191ef25c0fecfe84120719fabc547a27a8ee50d653df3cada866b473a19f5fdf77974c3b9894adb60f1526c3a3b8f19f50480f702e74ac6e1adc6d91677ea6cce36c2816748c48aa50a31a0bfaaf0b722a3aa7a9c3e380f694d4a1e872b2dd13dc16125df45bf85b38f31d12d68dd2c88bc590c0e35858a144a945a1eb82c999ca9891a76ac746188f45c912a502dd6f052c2d9014414c46dae850847cd4d26f3f0260f26619c4274092d6da2fe7fbe502b335df8f080b69bb9cb68823b1185b3f74b2e4668c2ae890d484aa324500c524bfc59e977939489fbdf47f5e5e1e45fd5e8468d5ea63b728a45a10195579cf51271ec3c13156d5ad8fdf4a0a86b2e7e7c4dd53efebcd85ad96d64b32395995bacab7527125c898a3ba0e25875ab9136f703f8557b6f32b672d165632670d42dc95d44326dfd5a708f7067681827a11c003097d5a8766326d72e54097ae79e67c0e072d5c9ad3fbd586d45c7520b1a36076d99b69c6cb7988da7b06a8d7ce1cf3e0f91286ca3e2d8ebee97dbd7a0639dce14015629f407d40aaa5a0af385649b5a9b08b28d24e151d0486912e02481d12398c745a7d1436977ecde96aa6b6469e8e74b825477ffecd9b7e61f4cb8fde1351528abbf1e7b6e37c3985efcf2665cdfe2cf26686eb723f625340ff51d0d3aca95ae5f8625750f2fd40f32bacee3507286ddcc62619c7341ee0d7da9a7a1d86694c7b46644ce1a2d2230e6eb02aa74d07b32de0862d2efb9ac98a7bbffe330e57b75adad21665b5d6ae5a59957e57d09d47a72328459e61a019892d64f5054875fee86b2277b691312fac81310ab286e85787ee2741fe9c374399c216c3399aa7e8002425530e6cabebfdf331992daceebbd48dd8bf8e155978e6e122da2c9f9455fbd260f5597d07a8ca67090246609d445fa4f97c09ba11eec80b941dc8219204a082b6271aa40d4819928c85e5d09074d3e2329270bbbbd172b18900ff70ddeee835b151df33f34ae3fbc97ea59e22dc556618b9faeac0e9ce6e9028f86f3d6ba8b80f1bedc7b5c86618fc347eee584d6fe28ea2b65b9173a3c35281704994ce4d81c6fa5d3a180cf72eeb56527afc5aae1d41117e7cf2521e639e173c020ebb8dd09531360e7df8f225e4b0a45e2841927006cfa71bdfddb33d1b54384fe99c6049b9df8190d384fd636bddaa8342f767f1ed3d5d907d396bc9a821090501904146b870615021153af1dab2b8c875c999690b4fad27411c7cc49b9e60cff8f43073d6b6e68c127beff9a0ed67841135b70fd961515e5fee929c2d6e28ce808bc249742f112443594f04513e5fab1235b6f5b1d4ec94e2710955433c26b792d5090fedf5db3e9a2bf423ab25498f2c6b9e268149bd9e67d9782c35758873c7401463f519cdcfb80f0b6bb90b74d36a2bcfa65f08d11ffd1620a1ebdc6c45e8b8a63203b126778a25d636b105ef2031838fe59bc0303baaa67752d190a354f2adc59e1c96f47d5c3cce5aacf68a549378c1cee22b63494ffb0d7ececbefc7afe0ae698117eb49c33be9a01728b46764a7c6dc5b57bc329e0cf06e80e258429503b6ef9409e43937f5f772000b9f17585219ceac0d19478ab8f904e14366ef7af2799b80904f13a038bd4c451fd087b88a23dd26afaa75f042ab18560cfd0c1c0ca631f590baea2ace63d2d795cbc84b9f1d9c1452eb08e33572d1694a46849e771ab6fa0507b61168fe6dc8319917a8cda0c39499b822fa682518422460849a4367280039eb8ef298768b2bed7592feca65516c664d9cc1414eccd8e263fb51329a431bfebc92da72728595d783cd5fdd2c21bc469c513b776f50f13f5f7a5dd08dd2346863228894a0211873f01ed08db91dcb313ab928bfb9bc786ebb90de2f1775bfcf5206177ab2ab521f63c028a0ae6f828578ee9811e05c413693edef5c7103242e0b405329a115a01ecae09cf3a745e9767759dd023648930644d483c89371e32e2eb1b2fbf957ad86bff80163f9451c071b94e1b9e94bdf4197a8b535be7bd2482964dccfee93e0728da80180c12641d3a34f72d699464f12a8e96ecac7d9f69b8a30f241bddda6364a5e988104f2ea43d92ca3bbad129f11cb1b541f5b46d6efb550230632a20c650f30f3cb43a8b7e46cfb17348a2fd6616aa2b09ff81272b14615d5f52a50e9d41c5ac2ee85e3b6427e0cbb7ed583c70b54ab1a21544cc23011822dac8f796d7ebec56a22962c37a7f975779c3d6c337415e15ecccf11f901574a4cc8692d3666e04f622f3a0da04165efe7ae89c64b32125407735f3e3c1727f32f414e2aa97c7d5c1ceee4420d521da7f577c4d1205cf396dbd8777cafbf02fc11ad23ecab00c2c5c34b17aa573ebda53474bf06a7ae39312cab53faed904c1c0fa2cbe17c6c9307fff0459e9a70f23c25ad58fee8fd34752a8dcccb0f9ffba379a999e53969a4ec9ba032241f94989d48d3573014237e48a0bd22b2db6c50f5268e869acc87d6f9f4219454abbc2ac8dcd5a4fd7662f3041f53f8a151fd318f9aa809ca6da6456b705f98360d2ad89b49e55991e0459c7202d84e26e5db80e98aeddde1ec9ec0c0b6e0f9bd3149355d73f56af9be90ad665d7b1eb82b3d9b7fa77af2a34357c0ba00daeaee38bacdc3cd37e62572ef5c3c0001666026819fe282ff61846a0af97213c0307ee4c751933ff9c0e820cd1a54b421cdc23cc66093183d6c569cf952a1e86c9beda25afa9b4d4f4edc3cb5041077d54a659034b623b9be2553bfed52994a6cdd5105ae5004dedd5710d9d728e2740f30f74b6f3fd16369f083d91cf187274c7fb62dbce702ee41b97dfae6e8b3b96359f559f82b505e7ecdc5cd3ef1e860cc73549c657d56ef5767768a564f1871df3fa92c978888d44a03fc16e260555ab52279cbfcfaee67c5ab44eb0c61bc5976e4b9eea19052459afc2cc221534e094bcf31995d9d30a45f5c583f06b6cb50ca92b976449a3545533cb46a9da94f17fe78b7b4e25d6eb545cb6e54508cb7d1828ca3baa95b3db482c25345f7e77571b823439b842f83f2dc139011d2dbcefdf7090f21095c65386140c519cf755bc0b9ad77252885b871f477e8a24a6b869493e2601d3dbd1bf362ca3fdd84b603d53cf2fed4e13c6f961ab87fdbf61afaf20656841c02f942d41694388b3d43997e25dd064522fb120598694bcc1ffc6341e2acb989710eff65cfab79e748c8972ffe3e4ea042191025f3d020f7dc8e8bd06219e5f4f905f4d4b4fac12f988131cedf6121b74a52c1fa94d1894aee37d42e137346254d9ce8289e439b5dcc13aba0f556bdbd09ebd77be94c00d6afeb689fc3c036de07c33142cb304f7471c7e6aeba51c493432757e8ee9b720ba576f62a53fd477c92985909a7ff2eb56a053b6d75a173c72c06cd715ecd9bd0053463b36daa413a6d7e0e4e90c703a1ded44f28cff1002f6ea67819a967b0abc57f1282db1180e7ad45b88fd5a50609efd782ce785fe20426340e7c5417da0784f2794ec9e4c85369258c46bee61eafccd6200ef63431419fcd9308fab90620069a21ad7c1383fbe3f0895ff4962362f6fe30b5bae5aba5d802cc60fb97d2c1e084abc846cfe2a2959880e905194cc9193e751ae3cf7f75da5500fbaae4b3fb4cef29a117e7428c064a707d509f80e2e20cb92eea57fa52a0e6d062a0b63694bd095433f3ecca5579f510eb8808236aefbd6af8f38be2032062ab5172eab9a3ff5f80a49605eb339fa655bf4c46be98ddae9d2ec32f2311772a8b62296deaf87cda2153534928a26bfd6c765e01b395264b79fb8f6ab3555b1097a2fa21d7a25401b50e5e699b89cc6e0c67d739f215ab7308a54dd997843f67fba450cb0364c095bca0046dc83ab42352d69cfcbcc0098b323f7ff1869f288bc63db42d6f055c589cc8e8922657c0505412397880624c27c8822e65f0397b6cec4ec7b060086604977e01f74c5f395b955d208cadd88d50b46d23f737f12313722c2c3ae47d2ff75d0c1d376a48c6ae219c3bd1a0403587ad18547a43a55a76c6d7fc1e38835df726327099a4742a2f45522f563ebf604bc9c3accd5ffadb48e07b5a098018c69daf389d9b17fa071f3ce93447faffed63e9615f7963e7d87b9e8f333f223e23e6c8ed0275e456f910908cf232400e97902c798fad463ab8370dcb561102b4f1f76646f62ac0e454c569739021bc4243466f259b960e54b28b842ee1cbc7f25bcd0fb4fdd6d5d4f4c216283b403ce3c1670f03abdd9d5ac8a38b60ef3a309a83731cd4c54fb735157cc9733ffc186880e857492f2488ecacdc8872a4d4095130736474e81b1657c7d0435c0068746d644dd5c55f5b2984931dd5d6246859bf152534d15b2c8f02a79c7de21bc2e922133aa1734285cb4ed4b39efa040badb81db6603e0b80b23ee0ec936159beda41fd772e51582c0d5a828edb6f5e55afc7d93ec641efa26d0e13f7868dc63c2b0bc9946bfeec1194f9ee1f8bffb13a9f0918cf9e1b551dad47344e1f1c6a996d9c8a892a8e8c4ea08fd63cd0052e23d58310c410931c5ce3abe87af413912ed0f17e8e3a8ac6a94fb11765e142d6281ca19d103de859ac190e69ba7807050dfb10940d9a446146c3852ced3a60d6815c3438df03dc9bbe5ae82d22abeae6ff5b51b8c470c523f3e31ae7cb26d882efbe935599a5be6c7aaaa7dd749547695f3ee585c73ed9f583fbc8d729d944f51bb82bd91a81805f91a2c362ff96317506b85351b4d0e6c16a3e46db03420074b2d5943517e3304e4f7a1aca103dc5fb31b8190628b5cca315f9d1c5cfe8edffea1f611281e24e540131b20ad0360303ad3cef681d140b58d0b91baf5538d10545679df23f83f3be6a3f3f59f159e0b289b0003f5a67f940dafbfae21f7fa073fc12356ea8b550b3bdc062a29a94fbdfdade272387f51597a62624a7fd8326f3616ddd768207dbaf01eb9b2d5e0cbf447a702e062689b26b7ba60442bf0c6ea5e7ca8bfd00b580ef1d6234845431339ccfd5232454af8ca3f915916cc6dd780e55e4454feefcf6ff32df42a51b073d691ed814f533830df57a1357154f18d9f17d0e5ec7061d487d045a2adfd503e4c65018f8bf151fd86c741d9cb82f0b799035a3339cd1f789257afb2fdeffa799d545342a77e0589fb083eaa740d8d02a2009e74507116a785886b57ffb3c9dbfd76a9263962958704919e2dc457942c74de64c463c672b575627caffa60ae429ad01209ea75b2e9093bf15668dd5f88ca6857b296c1b41d7a919e728b84cc856a7a16838cffc7b6ace0e7b3f6c4dcc8cb5393178cd05978c1531b9589d9561f61150cbebdd2215e1e85e3378e01e0c0c9b3560b72c013cd8645274a304726161883ce83e8b1a3d74e84628a8797ae6880d15827c0954365d343a21ac2d3b86dd6d56803f20ec1b1bc5b40de13dd6885634e330dc1e8473e81b0d6416421cc184afc5b803d625fe0738f2953af0bf5212fec998f61e2a4210cd6e9c0d1f74c66dab82e7fa8909bcbe0d29c4cf819ceed92e4a99f8e412cc11ece31e1e54efda97aa262915e3d6070021c50b7481c29ed4f14f9b829dcc2504ac394a91e83aed6aa0052e1c9d11fb5a270823e99992395623f20fc33b8717572d1207dcc83a2266fa764b62c2c9ccea190d13893cb64aebf942590677afeb9e7bf10832dab74ac2f1e6e28cbc46e83172c1b9b238ae99448b9cfd04afb75deeadfc50776bba7da4058204604705a84ea898082c2d98c4d4131627f95dfa2ee33dcc6b7ac5af13872a9b3be4a472cad20d9779c4b4c36c2d384e7f63e48a6964212a62f7afb39ee842cadd6392ace3376b3d8bd0ae295a9d93c91204cbad68f8cf0a7ed54b8e84fb82dd6fb0bae1d595e1c91dd769412568deffa553e2e4770207a08237f7aa2848846962240819dfe261b5eec8bc332b98682fc1339324f6b4972153b3780607aa60241186a2a70680a2c8e04dbcd082092d2f33d332ccbfc5f682806f2b3c8cccd3f6a6cccd250662921e30fc905dad8632753bde77f916f5fca04c5320d55ca0732f98745c2ff2125997a18575db624f002e7a53efb306005775a285f6132bf91d3b0254f37f618eda45b02265e835c0b75cca1612ad72aa5f82e52a88806cdf6f1fec67314586d37ae90fd28a91e7da7dc92cfc35ba160b9fde15d26b954f6227f27e0c37cd004fe4e00006c53011ddbf1ba32e9df22a92cc3c93766f09d43d750522713fc007aea53be646fe47e66cc71b555c5c2843460b7a120734f351281e833e1565ac9a4cc0e9ce1d1e331ddfa50c2c470f703f584dce8f070336a70f85bfd51bc9b947927b027a22f9c398247f94f719a62fd445e095ea09f1aa0c87714e503266929a18d90b7bddc57d38ee9a9eeeccd3f6b8ccfc12a527816360e347777facd84c927c6682948da10609d8537a7a68c39ecfc6abdd2e2d482de7179e49d73f422780d8dd4500d3f614282b554457ee44184c862a06d1bb80f8fa57d564fba576a6f647589d11b833383170aba7a7c068fb038e140bed43cd14e638187941eec8e1643ddff6a77ab7de1e902ba9224c8f32e8d35304c7c228ea3eceed32d381c00c69228dccd39061ae2c2b8707f80c0f7635de6d2d372a49499064c9ca068bdc18b023043f582eb21fa9c1b4ef79f67f1d55f8b601cad933c8bc077f89fa37bf757e99683a0b2862e0f36329e560a380b30018addbe711d1531386f0efff738f918e0b09a29c1af3edaa8520e9e80b1329fb0b889e5dc840eb164314b52cd410c2d8ad63181fbdc96ce9ca0d185f9f119c0e87313259c75590fd42ae4aa450a0c56acebff052f9add8349e9acfb42fac4d38d4a467f465f8484e04546c812e250a6dbaa8768783d70b76e61ef311c751ef16de4aebb228e6774c0fecdde162a1b1abfcfa402617a6363259a77c063d5c7fbc19c8cc73e0b20226e565e31aff96f37c3d7f81cace88e8cadfa4bfa1289b1a6c5f960198388180f6bd5fd9df1d3882e41e723acd125d2d67b01faef26e974ea7343382d1f596a84927e93c4122acf40affe549012cfeb1d81776424ffc681d69c6ba89295ea8859021287e8f1191c91fbbb79a43a4307f2bfc34cffb2b44ba590c6663fd499ce9b85d5d03d7caa7f0356f862bdc4da10e3e3546fcf03fe5ad23bb8562fe9fe908d999eb488eefa3794a720c4d86ecf95e985de59a80f57df1342b4afeffcd05acb859a967cdc5b2509a2f0b7562ecc96971214ee0f185d4bb158ca863a00904edf866ec732cdf13f2b51c3baf8fd59843b649e6699d21b12b9eac75a30ff8a7d445511dfb19173b3084c196a4c30b763c19caa0018ed4b5f2d883a43d00771b382049b246fdeba8ab23de1b852d109752eaf0e5ccbbd59bd6b27d2b31ffc0875636e4153d360bc048fb1883e46cf4f8dab4dbe8e5082d663e0024e7a4f547b8614065a16d77c2ddf4c128137bd3ff02772995929464535b4ac776e75872289c74e44cc67dd0ba556a397e900703d4ef84a7bcf1763916a68a66fa9c9a716662f55e9115325107d0ecf7da0cad003286bba86d5075e80121047408e4f6adff6b5f3db92354e6fc3c3118ec7318c6e199be8c3b1a9ee44dcf096abdd175e2fa8f61cbb022cd0704de6155023becd9d70258b05f781d9562335cbd5159af1b89fd477a6a0d82327427233b732fbae15fa846fa8ed1fb34da3427efcaa5036aa0f162830462fc5ff332a1cb5cb44b750b87fc81eaef45faa3f95612536c98e93a3748ff6d58ba28fcc2098a4ffc51f5811faa45578be3e5dc2d0a9230085485af8314dbbd046e000ce0269f88cab6c3b7b7c1d2d839ddb786d011b985611f00a94cf74349b6ab3ca036fd303cd53f23796ab5a4db4f255ce0b559746a4266aace9954901c373c669b96e7bba0d63dd95716195d3b02fb149b11f1ba5c5c674a8ecef02020e59a86912c551253a2e803be1fa4d8380fde84922b1a7ea5566c5c8e505a93544c0dc1922045c7ea71d26652a840b6b47f263874ed63d183a8944d3f7369659dfb61da382d3039526daa5baa7bdc272915f9934773024af3af1e44bcca23b24c268da3e6661f4f0b28512b0e4c024ca31e60259a970c15a6c7d34d681ef5e67206cb497d5ed4ae2a8b6acfb90b8dc0bb3b93d6f772d8a8e12795831a9904453a7d07ed621bd91722ae7b699aecc4c2129cd37c33355dab8ec5fdd0239c2cc0d87e2377a926c291c53fc1aaa556ed37117e0383a145cda086f972bf8b299873367bc956996ecff69281b8fa5df90781398b650384b96bcdeb7717c40d74ced231a6fb3da3bb2ae02e4cf76fdcc4e886f33fb44136dc1ac76aaab02d89feeb3b085f4782c3d4b29a77f4e4a987e2d4de351675944b68338353b3feacf5f1266507a67f88b37109fcc2f77ee041c4c6e39ac5a8fda8e0b5280f986d95163bee87d0ed63f503ccaf17192de2515d6ba37684198d6af2f1a9c5ec12145866911d6efc7ceac76ef40733c9c22b23b2892fcd5a833d9623ff1ea814bb43f21540ff8bb867044c902fdd204efc26a4694a4c1a394e4945ecc35b9509067102cb625f4d7d47a3025d8433b827048665d62c34c1203e9fc6ed189e7d6bd596c7fa4440670027a982a1de6ff34520d4c5fc746f37be81eaebe0c5cbcbfb5ab99b1b45cab70416935d2b6fbe84dcabb996d8b37a1acbe18437e3a7f11e0ded5bdaec44fde3d70c5383bdaa530dd92fdecd75c1687a031078f631e0a0e9e2722c4f3a1e3b6fc47ed81036e2e7b9808723fb38a584deb31ad3579b16539854b6a8a3746497b41c0dbb8bfc779c52d32ca9708cf8f9a58123974f7037a933bb15783cbc73177139c40fb1a219be44481326d4db2a34b2a0f7267000fbd196d53851fb7f43652c78f2f2fa1deb95718cf92dbe27893a1071d4295559e08c18def2fea258e193106f2aa93ca8aa31969d705cb2a113732aae66b1eb3b6114c460b1f4b0582c45b95f6b01f816e2d673b9f5b453e043c39cc592a527c3f850d19964e079b18fe3cd981c8a1526221ababeae5fed511b62e8f5428becac5f9930fd3621a94addaa649cd83f644b06b807d04c16ac97c6162f25a6296ba8e2fd6e00d17804c504346497531ba20d6562b71e9402bda29a3688cefafca2afd4045c5905014dc1913419c8f573c949d66cd7a5e955cb328e99952770fb58d26c4e89b9d715e2dea7001fd5904f427f43de0fd4b14e34da5dd4d16b4cc821b6281b6fb11d65a036aedda3cb010fe1be79cee7bc4cb2a10c0b1e56031a00b9b6ee7595b6fdd3af9102acf77ef1bce81ee09f4c52a972a75d761c22edadc4161d672d21d466ed24771370a8726659e41ee643405ba939542dd566706b7f7a703bf0e92d3ad65db23c5c74bf2cb5cbbbdab0e883c105fec68d07c0243f3ecf9fe1d6bbf4111553c37810c98755016f2cfede8e3da6fd02d182b0d0743580f4f9e78c9018a6615df79f307b37e6f9170c85308cc94d22b828932b85d783b3045fb1210b1aaff363495045da6cdbd7eb828ae71236d636b40ec2906ad4ea83425dfcacffc7265bebfe746ce1d81fbc2b7eead1c7ed5270880b9c677ffbdeab2805a888232364c63c541d66a869146790ff8b5c6bb6e934f11090a0be4570c5bf467d9a066b78f1f0841677ba229f282c64d40f4d7cc7c83ce8503f38de9611d470e064bc284983daf3dce1a1256b1c1d6b164fe70e9e13f346d4014a26f9e7e48d0952cda3b113bd35f205cf673cc412567c5e721ff804b047d040a640e41233a212218f6022faa1c434ab0b55126eca6f59a2c4c1ad658b23761e3c5a6cefebea63b08861ec1130bb88b605e79c86bc0edb88ee3f2d6f2585d6a5ebecc6e906e6449679568920e15e2d4ac6d42b3a54211c0b79bd0d6e881ba17877d8f26df8b6fabc4afdde6dd38d359428a144540633a14e4412509a137ea76e74431fcc3e92cd096ee153b03b6d45fed92885d7c605313b728c607fb5a66a82fd342d4d27e5168e55c4ac5880e31cb1ed95a6d0bde6b31796ef3f7a3780a7c5549eb12d8676720e3ab3264fb0ffff9f465f29ed65600cfcb855a84256bffe26135435956d8e20719d811961815b27ff6df016298956c79165805c291f20d3d1d4183c1be65c4af780489817307abadbc0bcd2dd311fb58a62ba256ef9c1ab8334e2db6e657188cb7fb6a008098fd39cb781fef3c926397bd9d6f3faac2068fafad80721c824ff7fa922a2928e9cbd6e5801c634c033f50b4214706fe9ec35bcf9a4db43c9c2ffe710dc1963de9d3d121d632f2f2d67899668c1ab7d834bb45b1f32fbaeaeb0f07a9accd06a6def7a26402ff5474ef262f0b72bb774cd69cb289e8de9dbc8bbe9283087772ad44057202a78574240f679c0fa103489bfd27b8f1f0a55fbcb17adddb13997a4f410f0ac3e83093634e5f0f2d68323210d1ab3949d58b21a3ce75bc8fcede2ac3dfdbd99bf1a425dfe7217831f62833129e90666150ac0e54037159f0cc9c856ea152639a331c44042851c8e31119c150359502cbf53b8fe873bb2a3ea95757af9d4e6cb2b695a336dc6056db1b164774ed1caeae41d200351627335cbba950b7048d516a952a563737716ad38270ccc36eb6b4e9e387013aa44dc742a8c9b3a5a9772751c04e48e9592ee85ef9de584f8704c5c66854864fa54c230f81fd7560d01ef8f6aee452052aff5c2556241ced21bc97a507c263ed9afd65ee2475fa296848649ff8c4b38b10c9e265fc3fe29c9d58a9619bbceffc95a8cf893fc4d243a88cf94443df907661a103b6d31187539878f7ba70571d958344db068d63b20a33a53dfe2a962779615444c2994764de7a3fbb223f1e35fbd806358cae6d7f8d105caaffa182cdc67b711360a6953a805adc254939c803a288dec47bf266429322cdc96f8eb07e028e18de8ab535279c79c6703123580fe9bf74120377a0c33848d27df3cf5709f9394ce939f151ed4c42553a2b9ebb1115906fa331f5d02c4f9c87e0a517639f1d57d629883cce4a6321a6c4c4fe581094959457e210cf046c685cc53fa3c305d7dbab6bcbfc0f06364bfc21391bfad766f71912dff39659b764b8dd49052caa06a54212217b31857513cdd3295cb5012","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
