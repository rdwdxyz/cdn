<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2fe6420629841530952959a00263337639450e3dcaf49e474488bebbb0ba04b1be3e47e9b3f70fe21a9741fea68f2bb618888b720d882c6ff9ff308811fb32737769d60d720f07b05890d6f84e7b9bc5ba2d6fc406821d1a32a864104eceb00346d371430b5025216fcabfaffb1f0f9b5616e2ed3a175625e93bf75760f38aae4ed9921ef2d43beba5bf9213ea42222380dc4b4ed3ac14df699ff38dd61a83e25e95c418f570cc059ba1e04469c8a8a2384338f06fa16dd731fa11577fcc6b47e35c819b5789c48eaab8f1fa0c2fcc8f3cecf476d0eca19f7b75c322a992a81585bebe8ce0e4aae64234820cd46282dfb2ab2da893df66c79176a197a95bcaf8b3d3714c060b2b3187e83a1082e631363a7e00ccf7de7988e0b7f467ea4c690f952f58204426171e36bdce164864c17b8cf8b39eaa0c2d838e9663a9fb78593b6b4be20457ec4f28e516d6d88423f22e40dbe4d910360e69d72e5dd77c332b4c45339b28a27166cca4ce178ed5f3dbe3eff883cbdcc405f33f4358ab8af3317df0791d2d02d95a0f1c095df98424e87c32c31a06b8d96664e04dfb6cf5ba083a9ed3139d54fbadf94ffdc8efa8aaa2c54230aed21ef2cd3550a3a08d69027abc0862141a41ab99703b218e4f337ea1dd393d94cd2130bbf9abab98d5980275183ea097cef0e015a71698c8601b21ffb5c9f44583e6620f8dcfa4dbf58f8062e8208af8783b0f2de220e4cb3588ffd433497cf31a3b9c12b913631828e81a88cefa0e99447ba7cc566e55be8eb534f337e20519d64d6fcfe795bdba0b9940f67f4499052f41ba97c26265c571b8886398ce1f3bc89ea215a1ea732dcb5a9bcfc0f6bc50ae4a86911721b748743525e4d48a0f771c0a008e8295e7c94aadfb60c7025dd02f2d0ed85f54fe9240e80127d7d5b4aafec58e59c3a1235c43a1ce37390d9850da1f96567ec91a7cc1ce50f0a23f51b02845716854bc600e155c72db0c4e5d3b6cc74379d7c20fe9be95ff6f3cd3d763f8d0b46145ac323a87c9858333e448431b784f841a961d2b0d27f32205b7c7dd7baa7c5e7df3112a0ea5aaf88215983e7c88cfacba8daa0a4a87ca406aa2a972e523e6fd006f21fa2d1a1129945b3874e7d558aa2053f0ecb4f51dd2632004ee8e8140ab75250d9eed67cd71e35a9330a5cd86a6587973a079f065c7b28693049e8cb1a5b342166d236f82eeb3d85a2590e30b166703d03db32b5fd9956462cf5104bba4ef8b2dc2a4ac015dbfc67a59f33c9ac2b58587bf3a302e228036d713f399056ff63cd82c4aa473b4e21e11b67f5b114b181d0c6aca1764b12d65fa4145ca83a266dbbdf2d1702b397c71d9727c96f53b19a1cfd6ffda56d74ab07cd717cd845f54ef9d930bbd418a3d27598c0cacd1cee574246dd89333cc8dc530ddb57748373dc10adfc9ce850a997033a954add8afbbefd7bfd424b8044c8b62f760151fd37e66d59f7ffce2263af907d1e5884cf9c6cd064d18a1a7c06f3b8fb380f7e481c87f5e6377c01bdf66389e9410ac335a2d0808a6e2f4910a48cb0edf1a6f25291cd974e1a0b5eab477a1d3bb1b5f5346aebf751b6c68aa3ef55ccb38a72be87419800b64643b4506008c7161513c79944bb3310f4989d773bb23a0d0b982e0b60903443197fb7e13b59ef54292658bb10e03cc5404f2241add25a30ae8e067cf69662b397ef27f9ae3b2dc313408e1d396002df88a2e205d3f33241cf242a9f0b99f9ccdac0ba5fd11fc9512eb13eb9837764aab53ef79010da98759ae90209fefa00d186be7694b9c57d8cfcc0ceba215ee77655b2b2683f6d890134317a7d5ec6048b4db7d4eef101ebb95cff8b05a2bee467d80dc63b49aa3b7e17c6bd02ef37d0b244f4d66a1622c6d2413604d818d76bb5be59fe0b8ed1d29a70c9532de681e81ddcb4f8879650fb9e9f2a84f33359406b5b1e71439ff15464488f8654990f458907d9021e5f3dfcb9c746c8d722ed3e6523e2575216e54248d19371a02b5d6b4f20bbe6dc5a3c64c49ad3474d8e4452346e1f75186c78acf88364b7f6ce1259844e022eafa1de6ed81ba361d291175618cac57ccd74d2a65f41925b889f6434b966fd650a94409905d134badb6e30d5f2d2e205ef6aa8dc80bfaa0f371cfc64701f10cc5575a01cdf5a2127787cc43e8e68d63e6d8dd7443528f1a5b016cf690121ebe78e4f624b4ad17ec5d8046661696fa3a7f2cce6d6dae82ba5171add9b427fe674d41517d0702fc53ed7e7e2cd3aebbd77a8aa33f31611007386e9255cbec64905e644fa6ae2b01f94b273dd70eee547c28dff7c2183e60db955fb2e986b05ddcb886a0efe928feea307157ee74a8c5e4ba6923e4277335f0ea2f0e14a38c30fd2a40f37152e84487a8950f6592638bda355c87440523b16f7ecf4d3f2b9e474240eac92f623fbb38ec935a071e452432820a803c7bcf53dbf42f49fdea33e192093778415817c1ef6bdfda6f252d13609d7fdf69d162d0adf6fd6f775421657831684d1b250d8038fa655eb20e89e35b9f9ae0d45f49eaba57a6893ebf599bad56b39fbd85a3f971a6886a30da6886fde497d5c98259d00ccecae62c92bfe8280bbb8f6c741cd900568d9a2f5f639a8a5b477cb4401da6f802a3d69b2426d5a3ccfeb8f618f8bc17ea0f051d3ff928c259d90f81a49218ac39b77b8f0c3e85b3abb4c025e65e2c6631f7c439c23515807909f958abe320e6a1fa34d71d1e17990c0e217ade1b5d6272ec8a12ee2467bb1371af9100b8832b673f3585f550a5b518294fb3faad5a521a160b58f7e3e483f8a189ce6683d006e4240be723e8335e1165a9bc87635defe3d4704685dfecfe2c8cca10e3c67325d3f51e8228ab2aaef39a7d75607f01b0b7a282474fe375614f7c99a6a8664a66c847e92c76833f39bbffed172f9b5a461415ec8418fc5bf9bbc79ea51927e601825723b4eb6da511cb3bd15c0cf88a99e75bb2d7dc8e8ab616c09e01523ae31fca84acdfbe06e0f5a96647b799a6376cdbb3117a96cea5de65a1c1006c0c107492a3ce8146d79690e973ca7ec34d65f8ed492b29bf3f56b86a4cf312cf9add8584f467d2a4efff84191d9dca6eea34df73fec5a196ee67e6ade3621970e5e5e43d7777fe206f98f9377b2095886471925a1beebfad1205b776d931912294f85b6a70e73f23ab144499129c95ebb68199dbd681d904cbaeabcaced903e3cd77928eb438985debe308f7d35dfd1e6b9bdc755060a9101ecd6e9ec6126e6e5c4317822138abfe38843039c8d0594d797d937204b93eb8849ecd9bf4d69f7d6dd58f4f69e31602ddbced7b89c4da6838f5942c077afd9a82f3eca6c390213fffcd6a118a189ace4ab1a886349a02533d1f83cf2aa8ab68ec30c07dff78e0ee1132f285a059f91007d368e87037a0274a8b77f56705bc71857d4c8ac5c7ef3cd194d44aaffbb66b3d9f9bf3a30c82e133db065186aebb585c8f66f4b8c499ad7d4c1f4db9521d8a9387c2ce39e5b54c4b419d23e17975271ad2ad4942db3a8a1cf2ccdf11c6c971304bd781e515e16561913eece9a43fdf7ddefc4ff3c1b9e6942f94fc2cc37ca31fb6b0c6bee4a797c321e4c1196adaad84f6edfff2d396ac9525ce7185302c0a02210c74f7575a64b0fc80d634ab839eea848218886c37c525ece79c7c6406d7c3e3d976f411ea88c5535c198a4747e54597c069e0d53eb9bed1ce3f38262485ffbe5277452ba348ddd6ab5ac0c3168a3814905e0c3dc712915b11935bafe47da960706c07e2519b6445b6df043f1007daffbe90b70e23c48e6a391d4246f375fb93837757267f00ff7ab19f9d227e12cd22ea4f5d678f4bff243dde0f6898d587df4faaeb015ade36c7941da67fc9fdab726828031a4e82147608bb77ea84f61f21bbfc526b585459dab4664cddfc4d2066cfa97f0f3cc88e4a5a9c0082483b2ccde48adf6477cd7af20decf6884b65126cbbcd2d35f3a8ff7993b987c5c2f425a545df1675c9fd41d1f8a7ac58a32261848f5a661c99a28f76d8e2e24d96b6baa6c4ad4933bc3e715c9b2e76231dc4b28dab5adb2b3c73b46b009202d98c6e911c542cb17f2a32e9b83466d4c2e7e8ea943afc3adbb211cfb904d84dbab3142da19cd3b06f178f87a20c4f78e3736a52411b51677b67732a6360fde752c6f8dc4959405e9522edf7cf9a0a780d95f68ee240c296be8bf1583c9eef923bd4f3c38d4b0625c8f3b2744e53366abe3ea68d776d9670afe5f141a9e02cd85799f76025881ee1355b1e8217bf4eb71ad18d18d1e404c8fcd2e353c7d535decf271a91ad3d4d782a65920750a2f05633c3689b604eb070de9273669ae48cb04fe785a01036ca4accfc6707e8ff0cc22293a4e0877d967e4d02e7f93141cbb86d9df17305125688c5d5f86ed86a71dfd4f2cc7d007571f8203854737acb8e2b3bcb61fdf0390fcded444b42a13e4b01245281a3f38aecef9ff5ff6d3bb950a48572ca5a18c599f7dadd30e1527e71ce5306c19cecc5dae1488d9a3694bf67ad49fc8d4d49d5b71ba4eb1be0962fd7966873c7517ef9a709e774f0eae84b903226df44df7c8c0666fd1604e507b9e587b4c330615ed934e9d5bd7faa221a2b68d65757734c56b2538ea84b4ede8fc8cee2fb4001c47fb036661c0f5b0ff004ccae6e08978748bbb53534c1f8e0ace26da9a78f75ffafd9e2a2b84f8790c9e424897f044dbb546bc0e78a9ac7deb0a4679775a364ab455d2641dcad0ce7a5b0df8eff07de29e2924b189bf1efff1f3c867974047d83751e2c4de52919b6e05f4927edc34239ad7f6e34156102a32249b7f8eb0869a40a5cb4cbbb06f14865a947d86550ed2230e5e742abf0e6cdc13bd09ecfe7c73338f550283bf1a3027129d584a7f480c093598525ad138f6c4bb6169694957fe6bc7e5fecd99809dbfaf40942bec4071b8576cd2fdff5f98ad224799401c39ea57d2f8d1e638f8d85aea2fda0806b22319d3e32a04fc8bdf2ab1fb9079dc15156410d345e358c7f944d259973e350a564e44ef89e689d70cb2418cbc3cfad02dbb38b434afaa4f2d6d624578cf9e832ecc4c3ea32f54f6c37c857a979121b7cd8f3b99cd9f3f74b4de09ee87a3d975f5946fb3a063deed23de3e15eccf7340bbd21a2f3130410d20084d3205a447e820b58284e4290971c6d89588786e4454542e8d46989e400ad9e9fd180386b5eb092b2e938f53f2a3ea5ec6f82aebaa75aa6ff4353a7cddadbb2cdf3e31c2984ad4a07c6143bc4493ad068a8124512cfba83040ad9673ed554769fb1fe7afcde62a2a4858585733d1418c8fa3ef19d9c28018ca012fbc5cb061a9be1311b36258f87002d9185c5a5916c27e3d8e9c960b6937a0d924a9d7b4e32423d7b4dc0837a3efacbcb5ae56d74cf6321b38711843091fcc75086dcb5321a03a70d8a9e5703cc110430820bb4977e19290174c3c59c1ddffe1acef7d88426e08a0ab75fd9027658fa8b1bebee6b032bc7449b39548f07b27ddd40656a05c97f332d0800ab8401fda35314b01761011c6c068fb51cbde7e53b4980db9e4ace114cf68f39195cd7161b6b3060a5e5a443ebd93f796a30602cdfa53c3665421875ac13cd6385f98ddebc2801697f02376d7cc97afbdf0e8b77ca568453dc06e29000c3f7df6b014368fe8f241ccc4cef3366d88f46d410cd797281e034933141701b5d5545c912d58dc001c433661fc3fea9928f08b7266e635f95a413c3ccdada4d46e96f687cf4242602f5f39e4d82a46872f7ecce606abb586efa26fad3b285739fbf509c125651a68be54a04653864401e39325c13e35b312cf162adaa36bd7182aab3655971fe37e0369121799317b62c178d0b79fadccaaab99b546bc5fec3723bb7a2fc2c1196c490baf6ca362f593e0c1f7010d243143ed1b24b48da92ea484eb6324c2ee375b11cb28165a43aeb2db4825b86e04615229d3077a140d64687a2d801233d34ff774399197c50860714702fe12d663476e9357ec7fbcb57ad5010f7cff0c21d448fac48ff45c0214152bcfdcc157688030b9d1194c521c76c56e3e4842d2053e0ae45582fcb654af89d6e900e7f33ace79c3745f4a919d5d45c4d96ae629d7be8827daab9a95d2baf3967bdc2e0d152d1c7c686c05ec6d0caac2dfa2fc1b190be44eda54fbd17eff7c2ce44532864049e2a34b7b5737509265516c8fc4132d88377c9f59f29a3d90b870524b820ed04096339819d9bbd5a4347971c09de1ad81804d48d5fa5fee9e1699d5b168ec48ecd436f6415c65f5986859ef913b408a762fed4b854e5b088a01d946ded6dc2ef21c975ec3c873b99b58fb6cf22a1cbf7152bff560d30c687d13a7756c030aabef964be87abeb44caa03dcd5fe9bcbdc52d3f0dbc5c5f25a3589c716943b42c9394f2752a125df36d1e83d54296b4d2d03838e4f92c2ec191a614b4cc40857eb733d773722f9b49a13bac80786a56ab389a7106d1f69253c102ed4d479bea56c7def851b7b5607a28299ccc1efc9792e65ea9321b5525db45a825f36e8d7243ff31fbb6ddae9de8ba4f2ad87f1ee784ecfb68ee9af28401ce05a7946a12ce1161b2cd4917c3e92a9c3724ddb51239797a6a573ef69a0121fa47723ecd26d45265f965d29b6bd688a9283e5b853ed136cec3e47a5c1a48b00ee7cca7fbb694030a0e7c19dd3affd550f17c571eab6a65f5a922b827361976585ba798ce2e3928303ed19407dfb62ccd390e2aa53faad11c093d835b7fd83fff669069676c87f9d6a2795b15a9dd751cda8999af73206ab12cfc2f5c1e13af74c1bb851972d5c2c1b31bd1ed2a8ba20bd4d25a9504e3bc4589025c79aa5e141e1e0b881844f3559b7107b514f171557cab88587a270a00faecc7cbbcb81cd73a6ac7af86841b53f5aeca939a8d3fcb7666932b7a42e527d383e488f7a18afb478f232b7b882cc52ba180c9d973ff6235acdae97a72853422f2e974a7aeceb2b81a9b51098aa1c8e974ef287b55365a69d5f4f8ed53a1ae8c9e5e09120227d8e2bebfb64ee6fa7d319d717237900d6685cb7ed9f97947c0fbaf81b027f66ed02e145c56b0c77d90702d0b1911a0c68465322ad14a9ebf0fd9954ee9537db6dcc08be6dd5a76e95a6dc0ad8d9209ccac40540bb89e0eca8e1e0f237157ccde318ed3d3f461eef5c857e33f4e50458614afe369ecbf167c89111335151228fc66ed6f63a158e97f3998203ae6a73bbe96fecc21080af2c5ff38837cf6ddd2d238c456571d115376d31ef6c4a76cc81864c5f5749777ab91bc0b35fde88679c683b67adff0c5d74e043cbe76c710446180510f164a834fe971a8fb336ec8ae405e164b9b2edccc48a1109e7efbe0cc25ad02549f4894b148c3f4c78b2fd4515793442e33aa284337ee5eca0cf8d28e1941c91b8e970aab710e6cbfaa214f69116f18f913bb1c05a671467fa39a59475bc7ffd0f02d0b998ad3774f4ae8e7043e7e3dabe991374add2efd4a5ad0c1fdb635316a63afd081e10626dcc18c8716be9953a317a7e79d71a3526b9b3172d9ab2fed1b082e2ea4a0bfba0d22f76d13b04e57f9c6c6ffd5ef61b55b5d7559e6b91d48480d728d681898b4ea46c88cf3b5df3d3d9d6353f7224928ae6358f329775d9e1496005a98c722fea2765bf53527d68ffb497fb1baf1425bf5df00f6dc1d057620618e4131b6dc75173687953b7af59a335e281dd415c31a634ce2763804141cb21b62e3e848e01d381c2d145f75c11d1db283937147e4ec7fe90aa16017517ec70be6ead8d2032f0528f9a75d57220abf439f5491b5a950df067c07043b8f4921a3e539ad92e11c9b48feb230c35d24bf2399206998fe887b5d77f60374096161914fd5c72de28f1be119506810b6ba2786150f6a3359853ba8f455a20ac0f2c3f90f6c450d4343e85bb5f031f5dea7a04f8c301de519bf1637a2c16009c74436a74b3bbfd7d4e7acf0024db894bbdaa4acc17e6ab93b74b81ef8388c6d9578fdb71c5efe4b0402c54a7a22e0062e1919dd848edf00ce7db21c3dda801faabb9356da0b9db4b82e60e34ca3a6f6cb92565262a6213f4bcdf1a68cf79a360d30114230acd7ec43b84650c162e6ebb4a9ca711eece50c8b58511fd9daa6f905028ee2d5c678026af5424cc6c691aa5271fc1caf0c337ccda60db9126d88e37962a29db7e18fd7538103c6522f8117100eb4d4fa2ab805b58d0cf9d3654f460f2e74d7f42874b0faee303f760a020551034d052e35d982acf41a662fc672e93e347c1c934c0ae47914bec6943975058e2760226e2a05d0d3aabbc96c4ec9498182b28bafc509084c45f3b3a4f261d2ae41a9ea7d592e6953072b1a3e23dcaca8af68301f84d25caf342dfd0c3dbb2d28212878177205be192bed5137c71292782517f3f93471bfd8c2954228b5b97482f685a0c604e4e47e7920a8735645428f54ee1df932b205229847b5201a0a756b660538137837e634c81c6d4cae8301d48f600b860a6a2d075ac5e576ba6e7ae2271d54b9a352885d141a4274925ad5d792b16af327494c957f7a775675a9c44550e502a16eb65e76571847ef2ebfb3fe49e465afd5a74d991f38f9a1d69e65d11a45b65f7398b132ddc237549e52841cd7a337cf4bc8932d2ddbb9c92978835313fed7c0f9febba37c1198a75c3bc048fbc7e17c5274f9598e108d17eb886d63910b0ca22ca09f78e0cabc33f9f5aa75a7b51dd8c8766341a10bef980c42f02971ace4a973505241332971db1ad1811c0a99f782ec83aad2055efa06fbfca64817507264e709704cd672c401dd5ebe7fd49b2f4967a19c72aa9351b07d228afe8e6cdcc1919d824f484eab14639b8a04512f33f7d0d9654a73d24e29ac11a9735f62cd0cb1128e6d634157a18722d8fa396be2db2ee4763c4453eccae3eacb7c88d70f546fc5f9d246c3f919cb11e7a8f2681b7fdbe8d7c42b3875675f108deb13532e5b291e875dbdd3fff7ff53c1bfd01436eee5d0fb968f2af253349def0b67c62ea7cbf59697ac8f3be1e90878af324397b367ed99093c1778ce280fdbad433e0f1adcb966b983b2e3446f20230e89aca95db76228f9384b03f8562f3e0fd92b55224472ab1e99ad312bbbc03981e407c2bd500a53b3292ed2b3fdd1d946e37a1838f93842ad0b71ad6d2e4ad994e17737f153bf9e7a87ca3aa8112814e839033e6c28ade1051a739fe0fc8759063b05bb901bb83d6378dd35f04a53595509d61f5e8c085754dd0f98ed5f5412d5842ea7400b87a0d2c8d7cfa6723a7b1f8c1ed57fe3b340fe1940d6ef0150e4ceb49ec3530152519732f74a43b8f1689c48b5cf98beb0dde2e4e1d2394c8e14870caa5efe32377a1f5e6e62340a04fa09964eb23212435795aed94b867aec3bddeb16c5f5f21ec793102ab45e8b7cd2acd111af754cc256a867cfa4252977467540ff092f5f0c2bb3c6054357a0c559bf69a18af03a1a27a8595cd59c1fce5247bccab4f66b95543b0bce7a44abe0db3f4eff95006e2347ab0c5758c1f215327b33c3e9e29b76da974f858a3f8ad44c21a3e7c1940054b9d475d5b3ef318d25a1f69bdb90e389d6511732bdac55f34cd71f7f5c46178f1fa31866080f16c69fb7a06f20db774cef7dd20b7f7aacf15de27e4a832e08b28687d3dfeb71e1d39c5dcc0511b78ad4bf2455f2e4d5e906d20757f52301652fc9737eff83f2732d21fe4927233fd7a335f7607ace54c9005b91744ce7de0fd7d295fa8f60a7294f4563fff73ad285251f5b9b8e624a09de13b4f169bd4355ba1ef3782204ff3960558c9016b442c8ec57a852bf2136f8d66c8a65114879761c34533b19895a5b57b1bc4751482e19667394e0c0a530b8cc1041803f70d2ae29186be75f07f40c5493d1e9b5a66b25b0f46daf7deec9680e259a49a7709d1934cb88e168712bd17bd7c2eb82c5cc407b4ca3ef96a982293692ad75254054b57ffa1f10ca46cdc6dd52c7f19c2d6d7841b3a8fe926561ed230533b0b1182ddc3a5ce7abe59b1562b78fbefd2c036ebcab17359128db6bc1fd3d013e513c52b461e8d7e0604b4b620caa360d7791a752262c77843ce30748912ec436cc64cd25246a041003822af243298fb89845676bd8dc8efd7e70eda5b257fe44b3ebb30c90368649c1293d083854cc4bfa99286e45cf785b3361c86166cffd17b6f38fdb08b008baba200b9862954c949e064f2d83e66ac0bb1082ca9a6e788429db130e7bef561f4eef79f00e59698ae5c7e3c73c0aacb8a3c69c9b4f28c3dc456fb9d2452e253534b5e5fd214cde78fa988ee0e7c548ddcc1d51c0253cfafe0d38d3d47c4c98ee51b4c069eabec457bbd30ca2ec452e05ab5b34794252c61d235083b0b48482ea2e7c9ad6ada5f3298d9a21061ee083397559fecb89efd515229e2e331a5e3f0f03595c6a145d22faf30bdf45295e7bf7176909d162471623d4c3bedf6ce967e9ed7fdf74d3ae90377a91f94149ca529f10e8dec302fae9dad54f5751f222cf110384b9a8ca346a8f9d9fe79dad2991cc1fab593b312a427907827e5422cfe7af53fbf2c3c35f93a51a93104f26b03012b0452e2c86e500cf235538edbd20a11a42901b5123aeadb506c04cb0f1bce81df7089a264a6b7af4a9c2c05ead9fd00474a831d4f5a2494d804f8e7b697e74aa4b419108765c42fdc7b4b25cebef865f5686f0fb0451b78ca527ffccc8b16c02f6a0d1d6c1c9a2fdc002299025a19fc651d1864e22db9f7276fabdcc4b3760eef7a103b0db7d4d4b8f08361e4fc8537dd250c47385bb46bce9963219eb253ff2d09f44a229f4d105de878b44ad6f721fc907f00f8731ffbc5b11c25fee21428b7ca29a7baa17b9e8bdacaa239af1de2ca3986062a77438443cd6bf61cdf460180a01d6357330acb59b4e0ba901a2800d2e730b0bb9cdde4875c7fcf11ab7e64f2c569fc6490e7dabd699853bce367c5d5ed991c495704bceff3a93210252bf44617705c467962e4aeefff710a093c038185e0e602a04ae35fc2c076b8799a6b50852916d32097a07ed639555abd7cf20715c94aaf430511a0fc430e799db9f32e971871f81612933b9d50614f1f79dec0f35c6702dcd442d63131d07f367574f28da143b9bbe2a13ba26cb98587964c135c08006caa16dd88d2c893d7139e26daede2df4f72ffd545fbef58fa363daa746e538da5562b2de4e14c40be558a185617b4907411c2c71cddf9a76c2235888144c8d046f572dc1d93b26914a9aa30e67ca41b9dba81689d3f15205f4f7de9abeb72fd122255aa4de13598b3d1d8d0c6cca6b15589294421521c337800d26677be7639b0c22d9e83c481b8773afe9036a52c78d5c85bc76a47a2f82a74ceccff738d9866df2c49b5323cecfbbf19748ac2e6d58cdeb99640087b8b842be5e41630ab44d0c6d56bd8bad85831d0199b9c7c5bfaf46281aeb662e5c4ac072a02d380d720526dec33a8c9f9ca372f8fbcfb4012aee0a6d3de9ba523cb934d8275fe93f9c5a503da5bcd089c3d74712ff24227c31c2175cd4b3d71128df1d2259e6ecac2c096cc6aa4040c5428ccec1caf8ed191743e4363f557dc3c25d090c424466c87ae7d032ca340ef061db73345188ab3b7387281a6a59a2cc46859292edeb8dc3cc9f611d3719f64032fe2318f6000724cb81099c62130d66df7ed8ab8fb975d88ecbd876bc577211b1b94cd655d38b20a981ce338ff24f74c45e4a80b9e22ae635b76cd62f3bab31af49567f5141f51a9298d653d0d2fc15bc556e70d2d98d2a641f5539aa2ebc6063a05ff62a9273f2572d1bde23ac098e3ed1afcf8d08ee40bef45032aab3b9f4854faa454f176316d3f04d17c66c85f31bf135b1d0a21b8482b2950c8d4a1110530295af3cbfb2b3ee071a95e5426dc485aea591ff2407442874c8ce966f4b024f45ab74888fbb9d4bb8608bdb7657474c4bbb166b85d476c1e2bdf3f0b33e9d7249ad500960f83c18290ab9d593cc82b97554080574168fdcaa8627472344f809e61f129651093fe3e5c193a2bec5eaa8700759d26642d3f61a18866c9457e2f97801b58d3652857da572dba4860ed5fa260884ef720799bad111634cdf9c0b16c4878d07683bc967480ad6f42215bb31cef250c58be9c256ccae0de5fc2c72b8f6749f362c37dc3e7050e10da322a799a9e7038f5f03406b37f9e17a480795fa73b76a0f0473e16014b11d384d0994baf1f23884323706223ee7d3071b245a2690edcf448924ac46ebc6c9818c86ecb0b46f94d060f996c97de54fbf2885315187294925ac260f003149242c96eea1feb227422d52f2c8d58cc607ae82b02dc88ba44a781d9efffb48dd232c9f2145cf31a8891c4d6aa9cda0804fa1ea8f757910a7e99141dfb227b085b9af72ee02b7e8b0cbe2e597e1a72ad3739727055d512f2a6036dd1969c64099da8e56d2dc38a103a5c07cfeedc10e82b261c1503233b38ff302d655c38b48a40aa8c5fc37a9ba87d3cb2fd9d7c344e8ca58efc9922b54a0a61907c86611212848cd2e5edc2731088c1e6fa752c562e398e78d6c95ecd57004ac6b86d2d6ea445d7130118f6dea025ab4efa1d80e32b8aeb4c1742c5444a758f5e43fde383b8cb617fd602824032b7f3516e17f6b9947d8bf94eed0564faf9a2925f839ad03d0e2bb2204d471040159ad3216e7acda4b298db14115baffe917d3bc0ea2a8ab0cd625aa7236ee003ef49695dc2ab26c6a756640a5a7ba790661a8dfcabe765600f972b946ff2a133cb5280e42a4089f19a74cd5a713489ec2e48d4cb1f56844db1849045ef66a3ec1d7442fb729dd7869021a861e923dd1ed1659e61ccaf9b2f042621453a4464c7418284469dd434023b5b913bdf83f7250ea72b830eedfaae858a05bf1b079994ff062451bf542f8034086761aa7b741e40f553dd0a2d682aa45433d2c8939017edcba907fed879047e29fd749e65339e945881e16694e247903223ce2ce9232951bed8bfde23835d72e3a40efcf8ecaab8cd592e45e8e5c11ced44a23c66abab6c6ebbf5f717e32d2c7b94860c740f2a9ddb893afa6f693c111776ace3fdc1c385647e481d03eb5541b08d0a4e68eaa7e4a27f5be3bf24a9e5c67e80d4f1264ddd904ca9ebe27b1b1610f3a8a3f6c31968abab3c707ec6e2c984b618a95e7b561173af53f2b6ffcf5d6341afc243bc357dd539780df40d491591ede5babe464c302d654502213f6f172da2b30363aea7008384d1f92ccb4dc7b5a7cfbd78a7ed091844121df1dff161b71ca3bf8869e1051325fd03717ad329d662063167bfb23ede2b16098f99c0e79f22b001ca2cbb647e6baac47f69041302d5b2233242eca5aafb9d9e1c20deba5cadaf55d9b8e714957213f794c3c3c09b093282ad2480e9070540e329a44764f0f4ef21095defea49a70cb18e5e4acdda09def67d7895f33a8b6ca0b7e23b60d2037d8e3b71f603f3e9e35754883daf618d13d5c553594c59e024a1d1858eec715456005f65f698a7878b2061c9efb34cdb76c4a4504eb57f49205b5ceab228503725d1e2884522c7ffe614d2590dd30d04ada09543f19027c53481e25da8aec2e0e800e9f1f6092b08b8c05f94b686c7b63cca9a992cc47a04b0bbddcf13c4ff7262e64177381ce3b243d6730358a9f5f004bab68c569b32e89f83168eeb18c8b26cd19683027f208962f76c27e766180b22dc46af2c608700865b572e11890b2f0e7c7a6e3deb4c1f4151b6fbccffb6ea269b9c3eebd4edf63fc93fc57716e12c5ddf8ae1b90aaa1361af8fd2cb8e6858b1c49530fe1dcb7cc18742b07c91cd7ff2e92c7e232c83c8f0d7fdc728d1d057f7c150cecadab8df8b1670d473a73fd5a9403d77282dfb688a4993578d51e0972736e521ff76d642540464ee4f3b4cc27e344ce67e8fc3f8e9312e3ade8f152799be752062e6876e6d2afbe053cd783e5ac81d85a231b26ddc09382464f1d0dfbbed141d9b862351338601bd155a810ffe5e7d9ccfc7e4398713c592c5578f90516490e97e1956268eb43ddcb5d1834d8f760b806ff2229dfa2357cf72e2a41c8ddbf0e671bbbe8bc8bb962eaa4f9ce2c7692fc80e992cc8f39cd479cba3bd2a9e633382d566041c4206d368935d1011fd712052bd7fce0175fc3ae1534e771770730cb9ba5265287f289cc3216c502e9fe5a1920c48dc734e185fc259c69f8fdc3ed8039f8129dfbf38bdf616843ba04062f8e0e125399415b196550dbe5d6e17ef23ff64db4218bdd617ce28ab3c5bf19d20239ac464f7118b0560c5c7f044ea7f74cb433761a8afd1a3305970443f0c211aecc3b21a206394e14086ecb27bbd6e16a13cbffc4373f9b04e62ceda8497b8d091e5ba9fdd5c030760380f8f3d0008e6cfdc1340a2767131edce6d30101a1739691980734fe03231dfacc225143366d9d6c83c2e5754d82a18f97a6dbce8bf62ecc0c45eb88b38c348177b922790af190470458c1094563f7d4f93ca551b5ca9451b9711b90e3d12c6a60ed6b10c584f68791501bc94ed480db4739b22c297b7898ae3146682a981ac25b11813883e8b6ad052ddc2258770ffe6749f69714996b59f4b0e7960ae649d9a4a8dbcccced4e3e7154ad3f72c97bd1ba57cb8cc10aba538ea38ed5766e2775d8df981e804d7acfd89ad26df4b7e6bd40e650756db22a7feaa6500a27548e6e9d9d34e38bcbc4a5a8510208dd6b545e6ce2f8c0c48c57d20f7398770a3b9ffd822ea13eb4262777b9c83c67c2d52c87ff73f0340a7b9294face538725a2d59f1cafde40633810f669aa7696de750551f74bc82d56e7343d133069212734b65d47dd037d5a53295bef8f7f83a0fef78215ec956b7e528a894d1db2c9a83ba0a0a4fe34612d87ec430866c94ec6024b68247677612727180d63d8f5d9d2458ada03e3271a84460fefb90ccd76d29daaba7108d15068a6bd43525bf88691d8f1fc0e3d4089b99a0dbd17c7de17556ea12ce508450927ba23cab3b894a62ea593f1034f86248d675fd38ae9f91f717ec6db3c02c543ab295bdc0d1aa1cfa5e122d5db5a4390075e7ee3704c69f714bbd154a422054afc4a5b23aedfcdc593ca2262114da119c428ae635e95155ad6c3b03eb47b65a82a0c9f402ed6d5aa468695cc187d9f7788e04c7387739ffe178be0ce7340e0a20f541c2da8606117c64da9ee77cb61205f2c9ac97f77244175cea1c6f742fdab40e4a5aeb9ab690fb5960b380bb9f29058fcff1802032b19bb57673a389eb176a8afd9ceef5f4de4987d61efe4d1edd93319ae527ef3115a96774ae946addf69a4c197398661ff55943fa5cb577226657cb53c38d4f05037230e3643e89205406d5f3dbd3aa28def9c508d84dd40c7462b80aa810ab9163b0c8cb878840dcc54fc07ff24f0bb3e015a424bcb742381c9702126aa29bd3eb484a2f8744a956d17c62f99abbc6e4386958b292bc76a200c5a6a7b0d062d2025ba4c327ea22f59836e309514df496783371d11b93657d730a26629e56c5364c2c87654f2652ca6490be7b69f23eeef1011f0f0b1dd401027a6bf90cc1ddc391d477924b93ac86af3ba4cf1cfe1aeac113e78e5707839d936f452dd40c44f32de958b85c4224d749f01675ed69e17efedd7abff013b48655e1206b558120c75cad542fdf486d0237f18f91737dc48be9324bb8ac0e6058495af4a6f2764dcea2a21f35ea5f02cfd5f084d141216d70176d016176858627cc4c2fe664bcb88cd731b9cfe7a81c5e6a6eedada9d23c090316c73aa3ec221cf79bcc55e831b4d255f2c1f3da753d7f7aca86e43b6851841e9330d6c20cc1beafddea2f22b9632172b8afa18cf381b548fc67bdcd380d94168ae4fe1d8b8a0f61d24526472b7ca61038fdcfc1da6a156f237c2ac5673bd722c8a116813e9100ada772086efec519f27209e1cf2eb1ac8a5a683baa3ac8b73482cd14e392fdbf3db6b131afb875cb06d11272bf28ff394f284a418f6e44cf85070b01a1307248bd1762eaaf7460df664e278d636bdc46827e453aa8c993346310838d41f17c8bd726ea31ce148865b08e290b069c3559d786e8febab20c824e78d3e650551d2854399a395b90233b8704269d2293474ca42c495793f3db9a71744af41fd7da0e474b760220fef39f9462503751bdf25ab1712967803fc0ae26b838fd15e9793e11b5ebe642a24e51aa5a0764530816d655cd3cfd6b6f4a7034c45e5bb2f9c979379b192348d20dc7fda3f5f5acb6cd479b0e3393a685fdc1e6c82df497fe2ceecc9cb170845f58e68b7e39d63f1e1d49f5155203210aed59aa6a630a835187832f691bb09a440d6221eff7366d225a19ec57c112bee00ce1af84b538d3024ad01ab3dbd95d0d43f9db4b1b74d52e072398e36893b14c41ef66d68f072868abe38818d999b566b177495588c2cddb3aec7cf228ee3d337e351a4267e568c323c6f8d8b1c8ccc5ca809b1f6291ea064abc70ffa1a2c2933cf79b3d744300e3b0e62c6e1c7db467fd80f4182110d60838e7e8a0a535779fddf1bfd853f3a9ab0e2c4cfff001e1e14ad343141ff709cfd4e00e86f29ccb20db9495a21fe4d25cb84ed6be2bec41abb1dec24fd1a334ebc60ee68efef7a755ebcaa0af5ece74dbeb8106cc837d58a0d106c72d7ac9ae87a38913e239ea0de1bfafce0f6dd1d1593cc8cafe577daf0cbdcb50036bd61e0234732ac9b4409af2f96a74e46fcfa576241e4258ecc08e63092d0b33eeee599aea7f365639f89faf6eb799695d826a2a045b2cf3c2c2374e77d51767a6491140680e81ed79b01df24e298bdb614f9b631ebf49b653f001a0cc97e1a16637a1896c20bd51a2707a830463c3ad90b9ed2dd56210b8043ed212f574d0661d61279692e4d8fe76e21125ca31d2bf961681284cd37f7afe86e19a9e8d4fd46f840e4b7be0cbe493a56ac8a15fcc607e7f99a62f003da83994f8fb7724b867a2ad28a48f7a3947c71172c5936b40c09e7f3af5db482408e5426c4f98b13d93fe191ed3e27f05dcc8651b8887ebf6e71c0386f4eaf72143687e5a60975a7e1774b1e7af1f8b87ac22361b2b3bfcf945322eea9f4a77c0aa4fc1766c25221cb3074be17f42215ab6fe3c69207ee28aec66619d00ae47b2d74e255870192b8ef09a48f3b61d621b694beb47fd69eb40ae2106b424b788c1c06eefff3610d5eb57971164ec29243b0bd870dc459ba0df4405ff134042f9742c951d08c749cc52413dd7e110a68fbab10dd2a5d4de83d62317ef9a15b639f333bec695d28f5d109d3b07cef0becf77a8ad41910c983a8eaa81423285bf8efa52ade2c3787516b088416c1379120b07e45d84c06071b65fddb9fc0ea99d851e2fec56a8b7641dc79ae8b00239af17db150c6f1b8a51cb08aec5d574b32394ff7afacd787825c78ee44bc96679b890d0979931b78602ae5a8efbd0ee282fe210f60a439dcc7c1f7ba34f1f5e5f83a51f0c2e18b8cf1f28fb32369a4876a5dd530b714f632e6a9655bcb670bb8d4d8bc5b7cdd9c80f8015d77fd3732065e1a498357b18ead8e85f6d1f0df45504a8b8450fd3b274954b8f03039e51e26c8f05713b7585c850e26b11d8ddc9c7cf79c3ce42d4f75ac994449f62503ca6c694b7bb478707a0e4f3d34b4ec2f25fdb5ad3c87d0568fcd9a79063375120aaaf33939b76850d2d79bd9fb76d3dfcc26af84be6d676a399a13444169124ae809d6908af5e6ecfda39acfcfd65c7ae3f3f1c6dd221c4f7380069db68f9096d3da67c878597aae65d8a7fe3a851673b6f5f553dd8c32b8f4b64aeca187ac82d778d58872a8a1b406844d8ec9ac8a92589484267e54556cc0e2644aa5a7d62c133ae92fbda33d4db677c58e6b596cef018cea2152339a5052db986c52a7342f1ac73ce3bd5288b4de37a8fc5ede4a4e3ef88dab879024ec1cb1f947f3b9bfd417","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
