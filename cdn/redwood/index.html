<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b44bc1b87566e10dfd4a61aab0f92f3d3fd2ba5e2a7a769000eb319380812dfd8609313d063e45ce2b3bbcff2d72d7363d24bc5bbae9ee9219e912f19938d6756ebe1dfd4ddac0fb7a87bca09744ff074804783acca182418912b8e9ee7171342419ec0f8ada5aa60d9746ee924d0f14bf66175be18e84810b3c80518340e6fd622d7aeb029b28069d8a0d19c7230196af18a9ae77675b81cf7a56e7fc2c434d0e3c3adaaea37d9438a0f332b3646dc39bf213447e835f4d7c7b0ea2c1a1244cb759c6ba65a65323096bd9fbfe9bff864be55526e0c552da089d6df92abd1d407822a75f7596458d6c070a253baa181341f98e9085a5700107efe332ec6c2e948c9470fee852d28edd8713472918fd5cc752cf7f7240b2832aeba15c03f11fb355ee69e99e04dfdcbaae56a8288fbcdc2f78c065acd53ab9c8f05074db3968641a4772051474bdb9210d491f12ce7ae7dfb1b773afab0e441b5764c9baaa8796a0d38cb284a33af80eb9f9ef170d27242c2f370a9a978fee19aa659ab2615066292c60e32d550a015ae2998088db984f0efbb925fe7c9d210ba279e610cbe59805f2b9008e24b15ba64c1f64059de6d659cdcc28c2033849201f117fb0181c1f98bea6f925b396a78f9d59fdab528ad52a4bb8464f84c79bbc006d1be5fb08220bc3ec9638c2e3d45988a588a999280c72278017d6e4ca7943fcddf292ede0af819bb109a15253729e35af759d140e26ab8caf42f884beb56ad2892378e8e5caa51990b14b103230aa918e71fa0ae760d8f751c9dfbc66056155f550f00583dc33d58c8a6ad2deed8c097df3d6ba3c0b84e222b6f91a4d1dc4186d4c7bb6821d405dc77b9a4e129f545cf252fce92ad709355739c963a3b58501225912012a3cfed55f5147f11b632903df209001e3ee9245b37cf808c538084ffbbd457af7ac43fe0110311b880abe9b18b78a619c1978abcd442ef8e441481d6cb3a2dcf977782867b79466c6389c9d78607f539b932256cd67d8c53214e31c603958515191d87e9dc145f58d84e546ce34fe62463c5800243716852ef7190e41c6daa7f94025ca486757f978dfcbec8de092841dbba9a9817b6b2111ea6a28f109e4c8299e8a186a83a77da3dcf578d0168c31223a43089d0cab71051206c63e6f230250900b9e3c5c4b96cf64e276ba85f8aa1e34fc27a3cb61f353ffc2baeddc26238ee6bc6a22e324aa8da7ee259cabfe32cfac0b426b26d7915c7ced06b0ba1119402e35132c4567a1bc41036f5e870b5230c649a8ab0cad8313422818aeca7137893be74f2e5e78986561f5539eac8100a99c35c586d4e2efa61e20b9ac662b7a38342a99c373e462ba10b90ded95f9b0bd6b6cb24e693a340717cad0b58bcf322bb549d39229e31d63d58592cbd260a24fab924670ece17003bd37a31d3a8d72b7b7e7abc40bd7246221321c36a556da2b11302eb84e3bb53bdb7701c3e072e5ae36cb2154b005eca2e7b55927a500950186750effa6501cc5263729a0ca22fb62dd1a00bc5f2e848cafd84f55ff771a9655a95f53e7eff11477030f96a259316f4e7ac6c069e490cd27374ec437bcefd921b8cb41f927963fbfc78c1846dd242fd29a3c2deb3637acf072784c82f359dc95e57dc9f23b80684c8aa6d5ab332fc854448d692a7c0c2a70deae781277ace28aa2fdd451fc28a58a1e7df1d78732f5c8acbad1c8a0ff1e649f093cf9cbf09c3aa0ff63be1978ac751b7a0658e57f3ecec30c20c2d7d64fd26b0a5d244d7425977f2e0944da857dd11ac95812379bde882a4b2bca4029b9efcb2104e9c4b89f5401f38fb451cc663e7622a89779492575d196f9b597e1286ca40b2647c073b0cca742df9d072b0a3d6b39bb9225a71fc4cc309a9e87f75019951397023b392229faca80aa6c0aa3e728a291e4a46b2595bc3a7004ffabbfe5bc2e70e943328ab1154f59f7b6633adc07a69963c7b0cdb7bfd77c6c1150b522ee80964cc7954aae0be73852612e2ece387237ae02cfd0ee3f432d759e54d6fafcb3b57142c065174c35fc9b4c65e6fc8416e5eab8e5f226930f2f1cd4622248d15691bc84e63e8d75ff3bd6a013bf30ac969765d7fa47b6d9a34c360599cbbd2761436d49deb8922a905e0bdac8972c11e196e3b80a49469537dad50313c75befd3f37c26ded49fee54e144f28cf5a7b5fd8322731b4c601810e20f9e6e33ca6b06c20163981ab839a5f02137d5c9147a7b5b7619f698f6ad4b1d18987974a1630980fbc381f013c704a5beb2d3502cd67cc29b778e1a5d14582eadccd86b9ff3f24aeee615ecd308f063022a48a30fdff1af2e2a93c98428302c75673984dc987606752faf09dd91667ef4d8f0c8a8abd1e1eed2d43379cace2b42ec992f56174a682a4245f3642748e52ca3e0909dfe927bbd1d96d40eab912dab069294e9b572bedf1b9e9aa1e284da54ff947e595cd86dcadc3be003f2ef63025148e6b6e430e38610ca7a438af4b2b573267571770e7e3dd418382bc45531ba267658d03e239860d3dd41c649baabb2eaab4d7e71e53015e390b0b94e167137a6ba9b0af1d04c4ed67cac7f194e49c0740e04f1b463e15de56144644c549933e62912ef1a04b8acd79cd2828f84dfcec5fd6df1774a472bdffee8cad8c346f295b3a10b62a58fee28d5bfd27eb6f5d00aaa24386e3aa4b459e4cacbf0900ddb55430d9fc818b7d0f94b518b86c74e495d33e021245c3839290dbd64995c0f4e53d3a40fdcc2e5670dc7074c7740b31db69724736de9930b0c92a678f5f318703b094a8401ec529a3fc46e300187b9dda649399212a2b51dfc7a8a70f2d3a1567cfbd7962bcf122eee89afd617e933bb945716f1277a6b4929f6f4047ab80ff489c9ce0b792eefd7a79dde027f747fb4eecf3ea419c7348e54cf7af927d9e26f65ebca07dcd32a50cedbc3d3ce0222ff7b7197a4efcd9993bf3c0578e8f16a072423740ef1fd996756bfbd940c2b7ce7a42e2f0eccc98d151a26c415c2c2d604af22ed30d050be543569b80e674b7088304c3149334b061679ccc386b07b4414f9ec03b9fbe6e333ab5c9d194217724e304672cc3e92388ace56018bbc51a06a88037ebaa9aaa81311b4f235d559862f8a3b59b31741d0675c11206e39a16ea25a7f54f901b1fb2a3f5ddd41ed5a73567a24f238f1e8c00d594ff3177af4c443b7b868f3b153a9168fa8b300b99475197b31258a7582e26c1ed3cf1973e16c8944aba0a031149afb5e37b6ba83937306de4557d93966e1d1511ad0a5862ad9e7895af9caa9b6ada2033328248d0a80795aa20de462f6e5b43f005ff2127e34a971ebdd7f80f0adc260e9b66c9232897cd2a45c62123ece1100e45be9835bbc65ba72c6302a332e2dbc3ba1f13c0d7020f5a8fd40cc6549d535b72e0ad054e0aaa1f826fac0e1a2c9b71ea5d19ee0c6f68a5e42b6a3c3892b380d6e204c96b6c9c2856a8f420efa61d6ccbcb89933c8434c6aa37c8a71058f44ed7edb33213393f88f80d9dd712653884dbabce18381cc6992113d22a01c6c46cc259e40798ace9711e8742c9aa0f9c5be7bcc16cef1501ba7b0ee2ef6185e080c99a93a679e5c9d61107c5f33c6a4f74968968901511ec659519e1669542c8b90f6ad294ce108bf45577159632c7db7e470558555fdd2e1a04ef6397fa2379714c4c5cc2ec4564bedf71fa3c3b692fc4f06ec352667a8bbce73ca7773814580054f60a2c0d55575436ca9a040a472e939619a398370429e6693e8582669b1040befb61925e53d842626abc927d6c2373e0456d40b17902a921fba0e4c2bf9d18c179b942a7234af0bdebb29b1c8af07f19fe08729551791880ba66243327ce198287a0bb94483f5699cc70b8f218ae9d29dc549d28f3e73e60ab0fb1500d8420e958bdf2ab3d814797ff0028fbdb544369ed1f7cb742e0019ccce4a8d28811aca2263815d02dda0e8fbf67d897c94d65e4f1fdce0142413186696108663c9f62de423d5895dba6eaf917663fd4b6fde625cd635f4a61211291d5a5dad21089cb7996baf00c690ba2d602db0623a6500c2d1f4a1c830e6c52513a37d2a1ec2179168243e3744190f70e7ab4638f3de14f9ac6c1f0f8c2a7711330bff0f41b93e288cfb67ff78a2dc148ab7a700135a7e0e41ac9b5e8f99deb7cd647a9d730ffbaf22e9395b6b9924d23e039d0e2c03ee3ae49f9361c5a89a65e3664163da2c737d8de8af6acc1491211f1e16225356d44649e8604cac0bc4fcc9c7553bf5eb294b74f1c3634bfc3381dcf6c1528bee1a1b67b2a22918d4c724ecbad161243c81598a54450b3942f3654067201ff0a94aaf2351dce0b30a3f480756e00f519612e7eeab255dfef8d97038788c647e9b66e27ce63d02f0c9b8facb1b1d041b5ce4859fcde12b2e9964facb60daa42597a9f9b278317d5482d91a8f36f9729dc302d450393ae05a3503b44c9f907305d70f0cbcc44587bbec0c5ce649749f2c88f79d21cced1200badee6ce6fc61c6ca05113312fc3985512beb69cf7e27976a10874a08e135df98ded5459bfb0e8a2801d29d2e680429fa43119bd32fa1e6ccc0c6adb5350c15840a5dd70bb6ebb11bffc7d7e1944fa0eba562b67c28b4d95ab9164fc5f7487b5281e16655c0afb38949a5db13325d54d514fab56203323889cc40f5049c5658d1f8f1dc087adf2920523efe9bff263154861cd1ff84731c1379ad11ff3efa405f0db100fcce163141ed43fb313d41090901a4721f6fb55b596acb608b3533c589d30534521ff951a9b155d7507cb2f482d0d926b7bf173735cab0bda85d1dfb754722c8b8f536b60d4b0274153f58f3b2d65c09d6db3ed552931ec37243fbf019846c89d45d27c08bc1e34f9496d1d1366e7d8a745e76846bdb9207bec816f29b187b4ebaf32f53a7262a6752a802e73d5fb279bf23034c0b80dbec4cde89e0e2ac01900e8850e6dfc0495a45491183f618bd95131f0c9a03845b5acd75b17fbc4f573dcee064f63c1cedee16b9473f7b05d97653c89069150c1b8c1dc38570f9eb4b84d73de5b1f3a3d8e2919a068305bce25996902b45b12f2a7ac267e3cf914b8055bf51911939d893718578b095084060bb173bb7a7c95d77757c3b282290d09771225922dbd14a6c9c46e2a3bc9902bb67730c842b84026375caab7328ff3e05214a4ccfbc9ca638cd8f74886a41d9e09d34ef1814330da70c33a4b463f597280356d3a043e5d06ecfee1c31537fbe91101173c916e6044395b990f97b88e170bf752cccbd28f31f9e2d1639188de928674be9c1352a330e8d3bdc9545088efe0d51525d694e82eb3ac338fcdc7ff59252a0bd7212729673d54e56b2c4a3b6432528fb1fcee3dc4985db9b8d05a3fe479cdd518a83abdf8bcc500f663683909d4c03f79e8ab53f85a4914b055c9a81935f4869aabdac4836d0353f20324fb85a6e6406e1e912c8ec0f0ebbf317ae390ad011a00b2d587adb5730ce35a0e9b46a0269217f6cb587c323ca9a04efdda7fe5e36f1fe50b3b8861c9d118cc999151fbeb32f1595b7db517f577ad71e631eb15aab9b3442aded86ce6f4d3a4ac5846d1ed677c23bdf409f708577c2dc09fa91ee7f85c2cc03ca6d25d7777bf4373058c0e7bb867ffa910846bfc038c4924716ada593882ddc311c7a7fb71dcc3ad51d91793a7c992315847b1729701dd1eadc5a0c349a875a7d66d18a7959f666f89bec9e57caafd54b8fdd722c0806d65642c5bfa6f61695c463a04cec263138de1515c13b91840f2d33da8b2bc5af4ac5e505012af2ae7e6bd7e059a48b1c7151bc3200ee56bbfde13ec302cb12712087f449b23522274b8f50b3d55d2dd87c703e6f3c8b7fd0ce0d864229f8bba564fd558671f64e68f384d7b64e14279520a9bb6d7d31c9c8f99904af0f0d927d322a00a84153ee61fae6249d8ae7142c0a7617223d3cc57b274502653a43776548371a41ef23e8887ee350ced33df0a3b3431094a88888d8e887d2d4389722a691b0683ea7a893d3abfbbbb15a71579dd197d5dcf03f5ccac1853408986a7831a1301194cc58173106532aa8f483be3d12909ecb4181207a3261c979daf5fd46ba33ec23eeabd0a4ef28644b6132984e5cebdc9cd227182ac6485b78eca16072ccd80763b0af44b7ca2e02347f6bf15d0542e0e9918a674585d1573a0147603d914f72b9ff12f7de85b5335b07a51687a73ebce4b9416b0e4bc273aae746385a7d4c9b005478feaccb9508ff8a3ed53493511cb1e2dda25bb720b9eec27d612e8f0d4097aee93052490a4f966d3551146a0e9a883a05f3755522a2f8cd2f880e44dc07e8c4c4ad560e0d98f3bb0d33c2276077af613a6a036d7fb8a071151a6f844e90e2cbdf46f4559491daa942f4f929b5d5c000a34aa7b1dc526d031fa078e355b868ce2bed0ab63024498b7c9273f263253f1aaa793da45b8a86d50e3bc3f025ef0db669af77529783b5199e9e901b11390724fd8e4bd1be0fa8d4de46066ca078b3805fdd66a60d7f8feca593409acaedca4c09f68630a425ce71e4ec92017981ce4ba534d8ff80e3960f265fe092d913701a5f2420710293b8d4af32abec5a0e5617a543b3168b459e11f9f9e3ccb42e82e4967cd6845e9e3217850567ccc70d4693ca883ecfd243e69921c67bcd7d69df534db484b0fd2ac7261909ae7ee43232242628cec6598dd6d1cce68bd4decd87c0e8fad7217d3f82bc164827969c7b68745288b4b6072c6f5696220e791a552c20021836be153053fb034d08ba499b199cc09a996c27476c980d83b5184e576405571a6698f994530622a011dc9d05af5cddfffc7896525d7f49addad2bc6351b94617c996335593e333d79953faae1b56f99c0c4e23cbd1c5329c1f823167228751adc7b67b2b159d9a8c89da17b5e6cfe19d992bb9e07415f91ea3d87c28d62f172230567c75fd5eb0aeccc30d50fcfb4439da414e0d0b9d308b4fb37823d0d2be196dcc2d03b254498fed9586421898b4239a4caa5bf6ec90cbb0057e2f48251cf80fe7dbb5fdbe4232c6f5c42775e43cabc92b551c31d3cdeb9af7b1c45630acacc92744f7ef3cedea82fd104eec3bcff3d58d893ab1113e633d2833336911b8d61b6b51b061937efda3afb5a8c8006491c5b9fc5a55c2229300020864acecf49e231cfc88502ffd46c4005750e1c6656a2a3b75acbd660887472181ce9f8640778704df9130ccf02816562943d4fbdc127cdef6dbbb53a9105ece17988b2b3e804dc26362db059f53459f18ea8a1708d3f8c884a7055c58c9bdb93108933f6d195ac7003522ee618e8070b7da6e793d2da26bd560fae372e91ee56901ee4d1f8d197b44243f5f037c768102f2d3ffd499cca79f0ddc76773c4a54f2f2a421c4250600ed217f02758753a1238c4c49359e7a4e7c958fee96ac7137b553cd8b6b0188ec4899f459f99316cf3cd77fedc7b0f18ba1dd1f33aa25a1c61f308e91b24bab692eeb696454fec8eac12d085591d8f97ca2253cc8278e611cb5c1731fc1d425e86d9e2413d61cf2239ea065791737617db4ce2d24c54c48d7712eb59c4c99371fb9b44d404e163722120f52f3af97130215126633c2c6d0cda49f32bd565cd1027e006a283ddbc82a40231b2f04d29104a8ce5f5a0b89b9681040a2fb401e72f687ea3f1cd5551b7ec1e582c9b94ce2f1e2ffa82831278b5bfec321074fedaa710cbe4e3e4418db019eb3ecd096c2e374da68d64c2f8da4bd072474267f55dafebc929b88d58d88525d8f4ddcaf477c1bfcf345bbec17a5d167e882fde9c939a2a4535297049669db33295545c62a9d9e05f5837bf306208c3f5c2f769c8a8520163afe9527c2ad1c094f5ed8e7a2fd1fd69d355836658b4e1ce14a31cf142c8d9f7f74586e5adadcb1b08f6fc48cd2ae2c9092c1c8e6241def5e08a5af1d43e640674a4a6ff9874960404485d7fa17e684c4103e9d314b36bba3cd36a50e71ab430ab71339fc6bc8595d47e6dc8961ed79d169eb56f40f26778a7a006f88d074ca57727d300bd2dda1de9b6d4846190a77c44feacb279aa89d4685def7c8b9ad7d6ca8057080d72d4def15f3f01d8a3bfef6642a4ed745da6d2285f844ccada3223180e504b28e693db2db52b096929e311da757bc5777447477481d3c98594606306d28375e80f1db9f87cc3e317e059178857163b17e40a8d711f4b7411314637231031fb6461c3f85303ae6a5f3bac86e7ee9145b7d62755e6962008b525ccda0d39b1ef4126a5bf87d6c82e25d00d5c6ab754de1edd5659b63705453650ed6edd7a57a75cf73ae857c4436690413f22c5371f1e3b689ef170ba14eee97c7f743ba0a88812812bc4d40f478220153fecfde8db4c84475746d60a9f3330cb19b4ed28b4e4ea7fd8afd727bf2af479cf6a3a1a4c54acd450739070ea5c12cd054c5de7b43dfbedfb44fe101dfbe9aed86a8bb5df35e020affc3b59dd6c93d5b454fce24405eddb179edd5d8754caf0c10c2a4f83ec05dfafa5e810fa523ae6e6236ab04cd67305286fd3cb354b4efd6ff243f3082cd1b90a65fb7f5c54e5aef0584edd8a1caf587707f102cdfcc2a629218115781e06d4380db60e183d9a4e0584cfdf013659d6915ce801ce11e880589af7865b6e90151a1b4189d97821f3f7d54d724a2ebd053f8256356c2f12d1e373226490c17bdf20eb072172cfbe4248f1c3384e3edad5aef50483c013e0b93fdac5a34b7fc30cf1ae8a22408be975d005bab4a4771dcd0b2e62ff7d8cbf8c906434b1db3d7f3a49f56db0d9772ac69ac934f12a6b6130c839287825c89dcc6cca2a54a2b30de22c60ff4834ccfe611eb3a404c945e525c7cfad7c8e876b8bd6016449fd0d53e024450d377c66d1bff86b7039aad0174eb3340cd17dc13d6bb304628cbcbc333be89977202ebb7e4ced51af414c6d5c955796f514ff54b7d36077e33fc27ab7b57881c04b3365f2668e1738ffb61a9196f7911a27e6d43152340c273ed23e3ae25e21a6912de60b7e6a6257bbee842cb72a0eab483fbe8bcaea11d37f516bc41238888603e9f94bd12ae0eec40a762583a08945a6d190afea729c83dbcfaa5b26c2ecd2434ace94177b5b01e88e182a74c18b0534b6baf699e7f730ae54799c5fca2bc381ab9713cf62f78d62a05b81466a47a4fe7ba74104c50cf7fb2911d86d881fb63923f5bf79397117d4c58c5b8000707af946853b9f318bb0740aab13edff523997b8127e52e191041072aa934812cb71bb552b0fb33cc1208a0840e91f4768e7048d0a762eee4b650647bd1b0089c713887c4251ca11e3aebfcd4cd5e089ef865bc6a50758deb8ff3a6f2ae8fe6469f5658a0e1efba8b96791248898ebc47b8ccc991688b3e07d827eb11abbe860fcce76bfe258848c9bc554cec9515ebb349945350d2a663e2e9bd0ba39876cb9ca9decd1b11727c28b6844f6190ade31c9013dee5995f2add012cd6c4df9ad24ebaa8d265368448cb726e29fce6f50fbe9fc55b83fdf0d949bf71b9383fdde7502f0c13cf4ae5c5d0ac492193ec9bd8523a66abc55af02a2a4add46d1c35e3dc69fa6aa09f580b874da5c8b5f1743f1aa6087dc12eb3cf77c7d5c859bcabb1bb6d1d0b5a891f99646b2fba24fad56b6e32ca19d175cfdc665fb5a995c828960554dd4c71be59641029fc532c367d1db33c3b7cfb7ed895296a97e5e248069fb05cdb7908ff7e1e6adfe314ea55562f82dec4e5ecda0e8f60ba7125e430b07eb3f8873cb2f4330840438c31c2ac12948d3ace97b44f0cfabeaf81e7cf2563da36aedf09b32deaaf983981219e341248e2121e77364b64645cc778f05ece46d2ee4732a4aeb7d42d32f39e095fb94f18c26714a97b8fe0754dba71f9c4b5f0a62c9827e916df57bd8a10ba68300f7ff1e3432056281e373a5778a4e30d406c632a94c6589ea0708643d239770ffbb789a544a01227347f198e97794328d5b0efc81ceb53b6d659c2f3ba158b9be1a5b1a0b524c26f6b4c00abf332136a8e20308be399e821369de42da5085f41c4a2d1fae860a1b5ec1a653ea4a720dab696a474d6f0c5a0ffdd30c0622cbfe14b03ab82de15fc778cb858c5e3dfaab237edeb46ff1ba9fd117b8ced99e7d5ea854feea68b1ed3d792b1db99a1a33cc6b1a50d3eb0065da20f1f242d8af90d1dd70434273ab6019984b38f696da2c9131dd1e6b4e211cf5c6a1cd1cc32826483ca56b61026d37a8ce289d258e721c75105ab6971c786aa3f356d3d606c6ef36835fc05d96f72e90904c76e2478d4c997b8d9dd217d323494d5b39a4f38795a5eab48da8a074fb8341863f4f7e2cf094614318782f0e8d572bb03d620ee9a513271800ebc22cf7205cbc5e150a6d3b0cba023cdaf32db58b0c27bfb40f5b57ecaf2a871f87071637bffb13bea0ef65a6da7b3016fb721a40be2e447d361c338749824056044c3670e724c80e1a1a2bacca494549c5be66b5371946bf1d5e1c92f1686311bd51897613fa754a689233685fc3bca7b6344fe94b417feaa9171b7eb55c09c8c71f157757c99abf8a72495f2eff041e0cb0157fdc46a7f7f23d9be94bd931cd3d4c1e7c108da8a9111eac10251a411998ed1364563098f2486500a0ebde1e9e644b25aefd4e53a046c0fe22a644b086494b8920af61556fe45d5aff8d23499e4bf0025525ab5dccc0ffd85e02b2cd2e228d94624831b47b95da3f22da082fa2a023f15b7592296f8c0d329f2cc32f988f60e7384b0d7a5ab042a485ea67574dbbd1b21911dc38e27c55654f7e03746654d6302200f6f774ce032585521c3b9c1eae7db0e4fed6f84bd58fa5c4485f50298572778f8db47493eb7d02a7cb8e106fa420523d8c48bc3b765b164b948f5ea87f570b351930f80f849ba710b86f146ef75296aba59ba3ea219b1cd52356ced2fe1a98becf56d751e1540203e956ad0e1ff9c634767984159929e662aace89757229b6289dc21bd8f11e25b7fc5ca467e44e7d7e3f28a5f97178fe6bc503bdbbb58e794c6033e563c402cccc9e517c01f873480309af3897c14a89ed5983460aa679796ffc89307989088b67ae8ee015375e8147ca2392486b71760e22105433bd38b2bbf5a0f56cae514ae7b1f089e96e945c8e2f93ef03486f6b42548abc902af43ee2aa8e98e1adffda7bb367d52db06cee725edbe61f509c5f881d97f307cf1732f7c90c5920e53818c7dea7140ac05602fe34ca29afc5c951faada201c87cf229e52f199aaeec939d8b2b5ccd1ab06469aadc62da4d91716a5025cd82fe62eb0c696314db506f413b5f874f418b1b27a47bce9127458918a4194a502da9a91e836dcbb1976834a473c2fa67fe424219ccaa3502e4bcf79e94f87c1d11d69a221f76c70e0e43b87421e0e36a4565eacb540c906f21ab89b744a4a6ba16a07ea4b6b9cc523ad17f5c5edb1f85618bd68bc6de4f072ec8d77e1f6478eea2910304350aaff4c49857e57a0c69ce542e76564fddf258807cd6e6d56b266173923f8047a3f0ffb4688afc4443f4807f387a23fb186150ad8a3ccaa2e58591c0d49e341bb402d1e9c1fff80cc7e22fbf818c13b9aac35d0f06ebb07f355a08ad92e9ff146935013860e4592b365d36d4c941137814649fd50034e7a341599cacf9c8372a0167dc53cce3db620e2eeec94db4852f14ebcc09f63287d3539587e0f85ed6fbb06625ea385a818904061daab4c908f0b2331b80756f5e0276384200cf9d3935f1bc2ecb77438489429823220dd939db04972852594bfc060f57b040896d87becda9c7d6261db96a8520b8ba075fe4109273c16295ce539524e19b9e7efac52134d04ef294073458034798dc1391ce452e7c83e3e354992be7e5c7429e0aed3276a6a17a33166737b5e3921b592714daf2e316390bfcb03b9691964586ee51ba78ba33097215ea07568db7963b4372304ae87f2a13b0ed0f6db0a13641cbce09a8d408d45b7f6fc9bbdb7bad81e598ca857a9bde7acb2f17daf30ade989d09e8a2214dfdd0abddfe9f81689be49f5f2ac2a6781e8df7ce1d1ff4ae317622d51f303eef1e5003fc4b6def481c3f0d8372fca8a9a2a86a6441bfc847565fef3897c42701fec9ec2f3e0ab9871253b0910ccd04da4cae9ab592a78c9ce30d889bddc2f03552b0fbe9bcd1942ecadcf2ff6534f35fc3b243df056355999248056d13e1bda943a1203bcbebd220c45098bb2937a5a391609e9b12148f5802b328c4678f7aaeae93d1fea2722af7ddf8facc093b6df607a3b117b777fe8534412106d3d6c7fe931db115be4e70729845ff9488abdce860395de867a6479d231e5347b5c45d0bce1808ff3d566bf067652990910687287536ea7a3ab542a8b89859edd90fe82bf987b42d3eb364b9f321016513394ee489f1155870cdd9a1bb56a886309ba28d56bdd477789635f790e11e3ce1455932e2a369ff1268272fe99f9e27b9d5fb9ae9a171a9859363864b56fcce7155128823eb3763b643585b0f61964a4ed314407109d2e4e730202be3895741cd318e1a64a7a18f59b6c27cbe1466bf7e889b3176097751e9f4376c17d406815547d8a2fd23ca41193e72e3f70bb205e8db16d0acf09dcd76c062ab8fbc09ea336a12af5100b74d3df2997e1a1aa04d1dba22a5ee8813ddcd8e8bb1a810af1e40d7f7adf341ff890b7d91693d7410635531c7f0c247c150569e37284cde9317f8cd465bbeeaa0f54ff2abe54436616fb7806c276c6b6b8fb235c0aa1e29abe2d21900a52fc767a04a430fcd800bcbed6eee991ca305cb993956e8529e744fec87225a7070eadbe51d2f97eec5bc8f07f0b8974fc42951553fad9903fb1d66c11446b6e191a3e346ec8effa52451bf3d3f93f5d74227978fd4d97a3aabcef0129eb102a6fffee5b2f6ee664df55a6c7248643bfc2585c0eb9af4434a59788dc9275f41414ae6091da370f3daa51e92c114741739f26d65f966c12ad17ef163ca9f668d84c78b2d65811d7e000caa1a02ac686b375d48abfb9a88ac5575df50d54637c30fc95ed981407420ecf13204ca62475f08dc1f6998b12294ffc8ed787713f036840bb187631e6bd4de68889ba50708596e103894f884c5e534162a17e516dd9aff0ae7d213ba425e4bea932ad329d63413013b3644b399b24215791e1befb4bc6dee01206663c3a3d0ae4572c8dafadc228676c0522970f15f2b78e6feac450d268bdd3f9ccb5a1e87350f84151462057e76b558a91bf835c9f828435566f53a5ae804059e40cba7ee2f0a064b11b74545f8269df4fb1db643c8bc660758544765c88f787a77aea8cc6ae6e0f53c677f8da822605c0214b6dcff29e1f9b2373445965f7909d91d45feec432a4c8d321e7f26833a594ccb3722ac3342aa9943d439188f7624e08c45783c0fe32238fdcf8ed441c070c19682b01145575ef3ac40a407fedef1d1393022de836049f753a2093ed167e308fa56e785d838cbd348ad80843799ccc70dbd3459e69288ee8756ad0e5f0ae3d6cc06bf66d2cd1311cc60ba0de8b2c2a7b72aa7e0e6ceaad7625a105100447a1869bd83e57037750917426eb963e4ee45675b3872a14f5761bb31d9689bc750afac6235f380860832604796dab651a92321f5cbab20e95526abc787b208ea5776d45f9fee500dcc052c2d00920582e52e60a23a4c0ba6ed920f959b385418e2aa631b8905d0cbf48589eb54cd941c43b4ff19b8e97b362718858710bc966137f9af45a30eaf6d99c4da3f1ef44d7545b6311049fff19d2dd505080244bc91c09d7ad492f788a0779b9e971ff4bc8bd29d7eba94b524ff24f90fea620def8f391811c975a5858cc304a8c047e78adc149f64865a313b57600e447cc61233a8e5b674a325a889eec49e30051e4dd3340d92699b3ff7e1342d282a0716093a7a5b97bb59ed93f6860d6b9e7c10899524f3fdc2d55cb515144a58b29a71e6432138c7bb3484addeda8fde3d2f4c326d3b8168eb6ce65f7a9d9713c2ac04230a0e478d3c28813e9d38286fbd2f35de28867600267af03c9f0b23469ddab08a6eba502a8f2534f10c8489246b607e555a28fb7ba4e638b8ceeacd8908808b6ca525bd0d15b41c66abb651e8d338b9966e3219a15dabfd58610bf639086ed988e31159acced0e63f2d23df4c6c30cb83f109127c44d817a8120f22b3b8de407c89179b2e764c7f4f0f6f5ad7882a7156f419071f306d6a9ed44dd63b2d273b74623fb85b42f6240647a9374d9d5578800c739538b28ce2c74539b7a9c10b89db40c2b84b69c50bab904e040580fde92225dbf5e51618135d630839239281adf039df51c5f2c0a40f249495c0cab3b99f549eff8e6e0078c8fc295ddeb87298342dea2a303521f89e164c61be6c7318c723053a5f68cc2b1bb93a4484777e3d74908193aa0b5c0d18a7b9beab23cff0421ab45612a510c0c604993fc6e3508265007a53e87ea3bb7dc343d2654eee2fa260b5cbcd72f18914dba8ffbf27a88fb0a0ab88a2ef33f0493445a6a8780af264e902691f4c67b30b7da5d051f0aba960574822eca68d84d047a3a8e739ac85740636234f1e3d1d8ba35f6772c5b6e7a747bd432eca070b513129a9baf9792947c66b9fe86000363ab7ab6a3eb41d4f56333d1ccadf9f1609dde8b9cde1b90ed2182d1862d874facb0f199dd4437913d9b93ebd21b48ffcd20baf94c5568460109776c5e18d0d9c690b70236e6ade042e0052a7e33c88b5d1c3e412fc1ef37ad2c70c24175531c0a5fef8e486c99acab79c0351eea1ceb00ea544238c11f6c06e24427e209be15ffbe92cfe8fd20b92afbebdf811956be20f417d14feb786bd0e6ac55b8eb3df37f6dfd5099c39b01fb044e38a6ae62deedd164d4376f86c66ba97127afe6ecef88bf335053798a24d030f496c2f21352efe78dba86e9c9c8e19d0d97b3360bd42346398291f0c73e926118df00857e4df19ef1c6e5c6a6c1fb33f24760706f4eac95e57c9253aed1cb25dd23fb228c93b38dec760be85fc3acbc0ee2c1a54fe306f9553959b07b70c468cb77c3d5a16137f23fa8afb829cd997b30cb0927a534b682d6e8b943602a34f87c0c111824d50f5f75081a2039b574c89e299b373501cb507a8a51d88b2fc992b11b9fb19cb733cda3413a687ab3f9d91e93425f97a92945d92472de8bd06a5cd26282cb21990423997630740ce9a02af6be4740c88d0cf43f2edb8709937335cf00baf4ce3cddf0178c4edfde1173ab315f2f908ff3283248dc626880de184186fc7ed91702286d2a5f9f25ebce56aa05fb624601914802c879b7a282934b2bae3e24a0b93e69fd18216a4c28a69d4b01e4acab94e579fa5c2d2bb35d48bcfe275c38122bcfc86a7535655371f98329c1af8c63cc5bb8168671647e4f5aa51398b9e0765994a0d30e169ea756110b9e89533166d96f5217155120b41d03d537a318fb8aa7a8342689826d32eaa48af87408abfb4ac4a8200942d34497dab25ae0360b632bde3d9c5524baf8a1b1ad20af682aafdd6710832dbb89ab01553b517e34d4198b1cf208eb7ee6e2d273a319c1c1a7e39a8bba2a916173f33e1ceb96917abf38a57da80ed36124aab7eebff09324fecf1d924f33c85d2bb62e4b8044198997d6ee9e1376b26ea1b1ea62b744ff594eba08ce32439efbef6b6810fffb606a5782390917bb8121d589498df6f5c3ff80b245e644f859d57e32d36e456cc5fa13d8fe56846fb9865052509df63c9bdc7e49fdede7e27b43927d1e4ddf07ec1f730b6472d51db9212bfb9f214650105771cc081a004e28cf6988a98ff2f72a40b18007f096ec844714c95d2a4adea1ffa46c6fe40fa1776f4e204669e65cf106fde930f85a45784ba9a65314a8d46944013996048786b7077122539362e95ab10645b549290f0199302f1b515a06abc7df58ae5534ed0e9289c29a463dfab0965d6000af25abb170dedffe114a19b75d752f720a880c7925edbafef3bcfb68cde22a86389cdef85661734dd89292bf19990ab6863cfcac166369284afbb28719e75a596c08784fb0215811a45103171c587bfbaff0b8e145fd076d537363da4fe43b38a2220cc93d217dae17ce56fced683e7549f105505ed2a581b81a158c81d34fb492d21fbbaf0e54d419d6943e1bb982ac5b5ddf28e6023ba25c35fc3d16c95d58011102a6631b90e8f35739fc6b0c9bef79227ae77369c46810c70f21d445f263640e4076acadcfd0fdaa55fe3a1078b094b92e4a5dc711d2aa2292ba2acc47a52fad83b0325e3afa91fce5a6b0e7e55fea662e95485f82850312f734dcc00bfcd924c6c2906569e21171658cf0d442de18f1c37975e38a4f2f1b18fa7bb9dc8ccbbfd276b8589a804fca3c28bc5670d18eabc7fae5400a98d45e1f8f1736f1a570759a02af41a4994cfd28e83be7395769c2c0bcb3cf7bea8bd1d6d0086874b1ca6e0ea6819a9ec6b40b07be9478acb475172c426bd99eef64a06b85bd759a32c810538c4785acc5da30613dc83e1f20e0ad2bec8c06f528971f3f2cef11381ca69fabcec7925b79a240de08ae2e1a3a75a91a5d580bb432abe0735ede2baaca83860379f07528fd07553a86838e0fd4bbfec4af480670961a05eacba781d5b6b7210607ca2598337356dc1a1a0befd325767d150e810c3c654719320fcb6782dd19310fb3806c47ffdae5578cf70b0b2145cb7b2a9609a0f45c3da012badc5b5fecc385ed1236b03799177f110811155f452456588302a8a35ef251aaf1a6856e049892df19213002d1ea85c99bbf9830d8dfeffaefd3209fcdfca272fcf13343c19372e2524e0aae73b7807082596478b2da70f500d1ea8fa606a0964f07846d61d9483f9f71d0e311d0841293434bac32f90bef2893f1b713f6fbedc6e64bd62e9100a08198ee089dd339df0834ab537441c4fa3e06bd21e26ab172eff785c33f482c4c303083438d25f2b747196893aa70783aca9224bd52fb9e475ebadab9558b54859172c6d12697a9fd735220eebf4979342c44195ea36aba30dc5f7d514d1a8b86f7cf1cc43fb9f7b288f2eb3a785e3c9971437b4de1e617deaca86965496b27ef251d2992b23f3e6033344062507f940f7cba74d4af035e0e93e3852bd06f81bd2b760217bdd5538e33d9e5167e57b77b75486597258ec538bfb68179c4b8c83fb9ac50e5614ae011dd7c27af97fe666d6fc72d2a69bcf6565549ba77bd11ff906b492c3f6ca9df6c1aeb6ab3c086c0b0639c10f21d39df075c3687fb89e4a7bb463e2bff0e3ba21b0a0133a4f0771827a93c8ab7aa889d5c3b0904fb89943bd0ce36f490f11bb0351157426fc287a3c5b622edee0fa3d240c96e2f436178fe0cd6fa2db8143f91f26456aa97da62cdab276099a18bcea36ee2890e7ffde1945f4e46b5b0711e00c8e3913b2cb5a81732e3ce08e4489796900e6fce8dac6239f9aa46545aababc29ce3fe9c9b8fdf392a13196ccf55156666a8113cbeb04223e1229ec8111ce412feeb3342002b7f32142455d5bb8a07220485187fc10e3d9a69d74189c32017598059e3bf0cc70f6ee516fe6e5420bb17676fdb3b75f45fab8dc2459a584f57469fad81729d0f445101f089980bd0ca934c1cb79e7d78876bc7f4c03d200f0bc7512db0569f3d9e900b6aa2434ae97f3602f31cbba51b6efb92b7d3f6fd638c944a63fd862ff8fb26274f9505be51ba81cbb44c6cd873f57a73862b934ff2df759410c301d5df3d28eb1d3fae984132f3c0bb8239876e925cfad8c4022600bd027c7db5c167de00edf4b1e04fbb240fe0e8f828eba2470d638e43525db2b66c28052960795a083ca952cc58d0fdf1cf368049f120419ee4d3edd6b22f41b7cde34cf62b16a809f0ac943da361a8d231c2f7817b9089e1e0bfb329b684a9926de34e871ac7333cbd6a0d389531da37f1b8f197a7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
