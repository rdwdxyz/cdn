<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"729825bafc63f7b2881a28f4882cfa7eb73b58266e3495ef9e9f1dd8d0f85b8fe5800ad250e249c8a2fb450dd7baa16c29b844588f5df6274db38d8d9ae616e5b7cf335aa6576bf555740b7ecca2c745f399e24337fcf2ff5e5071623afffb76ddf88abf802034bf156c7280b1c2a8f6ebd9d24fb485fb9ef4a8b438a51177cb7b1bb54888b023f8d83102acd19f31626f7814e01b832959871d247e6437cc35fa9f03faf347944bb0ad9f6d22baf38ab301f0271959d859c331f0012277d93ec81b1867c2729c7c4da0e9f9b4e9eb33c2ce8184be3b2283c0eb1f9b01d1de87cb907ea9bf1dc8123b42821cb02c4e12cdfabdd916e7fd4eec958a3b76bac38957d9f2e894dafa6489be7cfc84fceaf2bc472227237a9e6c4d54e44b3dee862744850f4a776a520ce43edb6a7e6e794c389fe64ba773d995c7f1a6de39cf8cab59e50e69640dcba372817f5fb1730f31d2c15829524bc5846077fedbb1cc0eed850a6877014bf48f649eaf7525ca0cf44443a01725136f886c55048047a71613c9bce60ba6dd5a840cce54826cab1170316c9b7d25a3da01b7d2f28e958fb9a9685b895b5b440e6e72565868449b7534d8d4d9492bbb8afdb980052db9cf6d90da70eae931839d6dcecfc455d382b0a0c728cadc85aaaffeb4b4f56cadef05743e5ffb5327be53ebf8ed8d535640f9176dab8b291ea6d37eb67ff3a1e470009a26e8e565e127a0f78008c830fb68e90e310f53d722f8b8aed3051188d3be67382086fbde822a1d400d03f07327c8b4cc1b0599838a2b590222cf7773ba07160d6d4dc1edc52ed5592f9ff04e7fa59a3fcb7e49bda5bc2ca48738cba441e5b8782dbde698ae36b58046f83eb37577e37185123ce2c7abc9ef5edf00bbf5f1cc3e21e3c404c40b5a7ef2328647829ec48e48691c0c7264f84c24e5fe437c8b2231f389672d8c7f16bccc639bfaaf1c69fc76d0b0c975ec8c9eff7350b696e67ff41539de0fa8e21a12f061078685a07dc4d8620b4542f19a64ac6b88e29fc3d1f9ae9a63bf4bddae5aa61a62dfdb95711b4d21326ae6489942b3b28a6c1b0f5bccef9474d91f151481861de362c9d8ed97bc6693a15f56a7ee9d99fcc048da9ebed70d9482548aa89bca7968fd831c3b26206e3212f4dd755371450779f9d85975f0c0d9e78e70dd9d3abd19c571cb16edd3128359b6f570a3946801e778e15072620629feeea07cd1889a661c1c945a779f5fb72b6229b3c109deca2534cc0a563346750dd82d0881a660e53371cd86091f4b9b955cc7f0853baf6786f4f5e3cf082a9981a87929056098fb683f47287052ed46a02e8c5290d0fdecf45ab8a6595cb762fc8af50756452ae71677daeaddaa8a382b621f2b7c96e0817fd53f593b2c02e71364306d9aac80040bf18387bc67b95ad76005bb10fad9cd6e7ab69cff4778c60d0bb3b616a8c51b0b0f27365a42132b8a2f832b2de4dfa7e42d6fd6326dfebe7cecc4268d72d37b49b63c2870264971d718a6d1ed27060f8f317e95bd619530a9d2eb69c14352f1e17f5e2eb4443d5c30655107943be0c20f8480116437e31529032d88b1ed76ba6e7557cbdf6e6212e9d150d4df6be187250653356bc72b306ed2a056ce92a58a2938159352f5616d0d228db3b7af5313b8ab8f94274677c7e54e606d61e5ca24382caf76f41b16f70d47a2f71b49a21773e4defa8d07a848b6d3cd0888e13b527b5fe2e7653945ee9d80a8692668f5f9d0b595c2ea9410d774679927c9f9ec7b74bd21ee727bb3de6c795a4f0fe311101ce80219976bb77950fe8b23887e096424ddf5e2c74de59a4fbe50b11d23c8111515b8968573dcdf2c10173369fafcb9902356bce3d5d317c12d387ccb4c964ed7d09767b4d9d622728e36f7f3ec6013e1a83affa2d2e565bb93fba8e39e95b90543eb627dd3912e28b38d1dbb4de03e95c459f8cdfc3528dd33f535e5f6feeebedb92996d84c7a6b9c777a98207a6724a702fc1151c7e06470c8b6ab659248ee0c21f8bea16cf86396827a190c5e78a30afd5c9edb784ec3edef21ffce145591db1db0c330f4cdf088a111909ad0c294521779764e8dc18554d4ec7cb4912959a062d4a4924b46cc9250cbf49c8191d0a43ca9e36d14cb1264ec959acb3a472831f00ab5fc8fafdeb4a222bb0f07a10714d6fecd013bd72292b292de526533185c691f62c0ccf6e09638edf99ea268e72bd2f95c9a1650f864d9fd4aa9913f0369d97cb5aef85edb68f34acfd936de182558707bb4502230d217698324fe1ca76db041466379f8eb5d84bbc24e252e878552e30961f13444f141ef75c02b5652c331f4b7a6776e1a020cb5c9d7595fccf1d3ed1a930b1ad46f02c04c8b5ae1467db6dc15c1ad56f2a5623da0ca6050c55617e7d7f4d810582cd047ebd4794bc4e931ec9ca315e3782c5556a703449e708f77810605c3e77c90f775b711f005eb9f4f7c6041ef24fe1ad3ebe96c15664ba02b0394c83e878e7ff4f89afaeab435bdf1ff01c69f1d94b053d9b5ea300fad29893301edfc06fb46778aeaea8954c585ffd034b55b810923719e10014de6d75cc3bfeb55e1688df9c670fb86614a6cf2efd23e7dfbbcf45d1b43c480c27ea9e966efefd1c038112f4f15e16345a418f6772cc530f07d4bd8ad82da6258f867c32dab05f4b343a01f5359cb468a51b02c817d74e309e3f3b0006ddab1c3e539494e1afeac094d64ff688736b608c6110033de0c984daaa6f08fb09ea743b04db23b069c321207dc251eab26203832585bc0a17863e8952a503088202f0020b1943b200c416ad6ff0827301d3f21be431879a824253a49926aabb61055fb01e8504395ce823ab07f17ffef953e18286138014512f80a2c4aceba8fcce2321456126bf62bd806de7160fb876e563848e219c1d380cef100d61efdf4c466ca73cca9e7c65d840475964665a9e2cd88c7a2a0cfd70ddf69fa30c48953f407e52500ee0779eb162ae9f33201a423f0cf3368d37b2accb83dfe8cfb9d45d126497343959858198a2112b0e2e493bcca3e03bcf02c17a736f086b6faf78d64a82fc36ab4d098ee4918cd782d92632adde1e3fe857315db344a44458aa0006c5cadb9b25dc19766f37543e7d1dfbec32da812f7e3d5c03e20972dbad34aca4665096a391c69b99a06591fcdf0ff7b24b0496b3fe43c0da0c6638ada2cb2978ad07142622ddb6b608532bf11972cd3650b7720d5fafb93b4ade5d8f8005e09c9fe87a0d9211ffaab30330f41c82ab0c4c3f748c26fd5a52b9189bb1f8ecc29b0ae49360b0fa197a24ba9e10c5ef4206c8cd2e8ff1127c33a6405ef387fa44693124e32da45fd63f496ac049662c260ee01378607c763a0b1154ebebc2b14978f7c9ff75ddc4d8e5ae9c9032a3341b0ccca2c23dcb65b81a6263972ccaf14e992b009b496fafcc1bc0a14144b604a97c3a4815a0bc1b167f61d8ecd71abbb8d60b5b22b470cdea0e75637565f6a49954eb1c5233dc1d9a9ed8a10fd03863c2ce5424933bf49372142556129bf4d460d010a72f5dc7f2552f66ea85088589f64d5aca9a91b2efa2c65913dfac2e362337d33da364ba487a593e0fb9a33ceb28193f01ce06c53576758d95e5c1d2da3ed8b71478d86d9ca0ec70a0e59aa477d42b213859adca6d2e7ef7d68cde2112a9da5968c43d9d28ef9dff25d1abb02e75ec9d56a268449084e15e0fbf558359391f614ed849d9f88214c1ab6853d965a9932f7de779b67480e59b04a1c984605e1436bd3f8cb820f74f7359fd100d01df86208ac535358836043d0cf4387a9fa2fd0a169d54431b41e0d5620ca52b5e30019c04685fcbee05f92bb116d5a87501f959914c2e2b590eed7b3ed2a34ba4aa1a6c2bab2976c4af444d6a0e56f4ed87a0a1775ac971b04ee26c302ffa1726490a7f8206eed03eefeffad9c307e5d9ac4fd63bdc9ab6c6f715826ea40d2ee7c8024050d71b99ce28500d4c2f8d0260c6f1e5bf6b11a4555106130572adada96a916d362f3b6293588609f1a2d3c6e0ce99fa6c62221b513ce682e4fe960a577ba4a5ff9e634941b700ba389bdad0dad626bdfd370a76d83fe296529b2fb3556d3b10cb86be9c66532933835d24ce8b892fba4e323cff0d675b013787b06a9eda67c542f9877289973b6ed6456bbb418c99e9bd3fa50fb31d67bd7afbd905a433c4ef1572badbec11fb6159cc9a1089fa80bd19ecfdce374e92193b81b51bd6b1e59a7f885efe56b641fefdaffc04689474301faf492c9f0bd5dd760775148c2fabe7bbc8b92fb2966f279ab049aae56436df47713f9280d6bcc5e64bdb29bc5b00f922dcd32bae7b21af37f9c13e521e62c313db5ed66343b48dca972732b833fd988ef16d8aacd295f73144b23b4ada7eb7c0dd570fdc7aeb9fed2ff07cb54fd5ca2a5b5d6b5a6e17079c3ed196f65818c1d303cff3d61e41c9bb297d4f7cc1ce2fd7ddd1081920809c0de624e1ec78c5a6ff5cb4c227481d6ad4fb4d493c6c37999576adff4fb4b0cc96f68d0ef99601266c6815b5224dc668b2631e5cf57d28b47d42876a8e128ceefa0a9712503c5caf295bfd16a48e98025483a46e1d2da91dc7b83badaf1370f16cf0265195d5cfaa5196c2c4d98669f66104f1cf4440e54f3e49aee9a82a80e8934497200366d3d793c6c0526bc2956bf959099aeb1c311c8e1b2b40a07603e0eac23e49358c8059d2e1433969267d886a258f2c76eaf75cc34ae39115858712d4ee600e47460bde45e830b772739184d7d58fac3203653b416fa1566d27b335061b1455c73d1e5ce97b6a10579f21a03ce5eac2fcfe0ae599cadc16143060433718fa9f7c4d5488b042b61aec31a6151de87f53ef60c71da186b17669cb9f676eff360b7f2091f1ed0f598d72e5b525f4630bea7e9c4ced66697de32d137f6394c3e4c520d24e3848800d20f4fe1584e27a6fc3071f9180f3530689277653fe1fa162996e06a269522824bcc0bf5e8335daf3d7786b58ae1fe71aa5c95123ee5ab469fb10207886e7594a20eac02ace03e8078c775ab7ea75cfa21d99041e2ba689a44b9a5b8652fb67adebe3c972d46f8443207f95426f79817783b55b136c695d25b601e9ac66d268a26d84640ea4bc60cc6b0a927c2f932c77a8b9428754388d0bd65c124f1159dd038dc239862f28b5961868342ec6c84ef8cbc0dcaaf7abd351263f3cd6479db008ae200429d6291ac054b5fd8fb83f9d22635105611537876cbff5b8e9e20dc85c31f4c3b2265ff7090364420feed637f61fadee6f6af6a14d57bc0553d923f29aceb160734c7d8726bcd87b438433f2ce5edcba46bb15805f7027c83d4966c2aedcd7326f05b9f6454caf72957190919a1b19fd7ef0f5dfbf5da8a2b4c30e3ec49f99028057bf6e536114aa147e0f584c090ee8b6cca34bdbcd55a6337f0c3e869c380c22f2d93cf7cbab612159860ceabf7fc15481db9e7307110ae830c6e6c6a3beb213fdc43e1453ad81c83351310adb51a69aed5fe9b66b7beb7b351ede2c59e417750d32fdc972c1740953acbac5c3c4a963f597002274dbd14a734009ad0ff580824d777d63afab2f4ac1b90e6d31440c9173e97a110d7cb365a5289b6eb6aa70beb0bf5b11b120cbfe4f211f79c422d929a8cc1bffc4d881d17b26ff5d0fef5b89035f61964606fc35e5448425a8c9eeeaf03a47cfb0a864084bb63e77f4ad0431d0850e9be738165667ea82682bdef6ffd1e26b662c1a17ec2d95ec42e0311a04c69bdb83580b78ee6a41931780d5589b98253060eb429f8db2141de697fd6757a72d864057198206c67b17caf046452c2f5beaf63499174ce88a0511cb5f386d50ba213c4d39b049d8ffb23f4443cb6a27cc24151650b26d95915627a0aab5b8c9e4149e7872826411c0af19150a5dfe6ae9a84fb903d5d1d89b9361cff1b36e5bba4a7b351301408d0f2352a9532d36b8a21b3982c577e894da427f71198ffcac8d437853d1ecb1c634a7d5b8aafa62cda9c0e7ca71d52593b09c35895412dab49822346a9ce767cb30ab3e52ed8a43dfb81ae1f8245b95d7e02690963a12427805486576a42006f3da4e565d8f2c699f1c968af32a923dcd0688ae3dbbcb558b579822ebbdc5ad875b13bd52f5c733599479af72b5a4af3acea3f43fc504f3099e670914a27d3f965d2a263fa17b249c4e742d7f33e80f1fc99b543f0c64084f01fcfa2382088264c6e333f4ea14a43ea4e7a2095eadcafc0db5463a67afe9f7aa258b4bad0b6c10e0f4c8f648260d72c13ea41a8ad56a510fb0be0026be80882d073eff7691bf3bfe0c574738449021d06a93199d7e35116149f32c450a71f7ffdd33da736270904adc5fdecb69e2dd60565921af41e1223bfa8a3fed90493027f0143df99aaa390d22a2d5f9811fa937ab469a91b611da6622addc71beaa0c8ee66bcfe5e3baef541a22a0bd673b0acc97c4dc642f179c431eea079da187ef231ef3242c70610394744e0772bd3867c52c529e0817af7b864e87d6ba924744bfc25a34da006a6a312e6a6c29d144c2e77a7728986dc6610b7a6556dae2ee0938c12f04ca6c8fbf9b3c4ba791c0ab68785f95525d2fd2e5ff123b3e7b6545ae9ca85da8f66900dadd36c79955f50933f2c47614b5a9682c6744f169755335670c160a84c514ae20119782526993540f80e31a9a9b0e32db05dcf321a14dd1d624a971f691abdf6a98f0c62caf101f07c7cb094a42b13ddcc014c2bc5b3556a93644003a570e1eb824e15a5394d8cb9282664674935dc92367f2b6548ed1c9cedd9ad65376e3cd62c8637bb295c1be443b60fec55b58e2f54e5fb773a8fddd38819927fa58f6623b317f9597be13e292192f6fcdc6c1367b05dc214e0357f74520d35dc8e20d8278c3afc371b8fafe154e4fff3fbb01c15e55f8fbd142e27488c96d3001505ce7ccfa15b5876636d626e499a0d2b936ae9d60a821be0cbe52738820538365c4c8a479f408c07aa1863d7cfed2a000a5d6a50945d6fb34fafc5effa2ae6e6f3439e4cd087a33fd373835cf9e7e95ba4f39828b5a347f76b3b4c16163edeac6aa1654bd83e6a8cc430b5386d71f3516e04c9a7cee56976981cdd534da2b4d302924f0045483341e1aa9862fff066c1ac6b04b71c728a868beb68dbf48c47da7d819f6346f4a028aad968aabe8488559f75344471d96ea4f8139cd3f8224fc91b6797109d6d8d3708854f13b2821510b709259cd892f62495391047c77fd8ad773d16729c56cd3d52ccb42d253a40da030403c940c83ccd3212853f787588576d495f76ee056278343881f5796fc65b86298cd507faef58e7a275613bd31d26579840abbb4a403d4b699a7a40ea42f5f17c9bbfaaaa2e08684367737566d5caab5c8e2e774ad83d2cebc5338609a51edf9bfc6399ff4e96ee43805a7f46b85eb8a7b51b55bc93d0c29bac57fc08fc0876eeb256b9d601d6539a451db5aae6a281859a6206ac7577b4d460d3d51ab9b1a014b08296109425d3daa5c95afefa4d3f4ac01a6ec0c19dc4280177749ae06fb3c2d00981de9f711d3aa90ed907e88708af57122c1c708a0f6106d7ef710b76f696d7a9b9f57e0b5fb4b48cbf1fb7dd6a2d35ea0d4a6000efe37113a000bed6900dd96176d21972998283370ac42c780138d31e353a20b84299cde91eecb42b4a116c577089994393906238be82912fc3c989eddade97d79c9ca404f8b3e2bad9fde825c534dff39237d40222683a23bd6594e964e227d45f6c39f3d8ed665cc10a23c06f5db38d27d2c6a37797a5632182fc9f334684e8b364ccfeee7f4c28a2c06d39a1cfafbaf54b4838e1b73de90fabdfab9a26fd3e51d1c1e5d741e0f2f433d331c45e8146e807937070c88b6129c77b95e13e0aa3b04b88a0e571a8b2d8659480e4ae87874848e68c9a26b932423e4a583f142f97058ab50709d6c8b100c7bcb754c03d4270a8641f441525086232b0ad8a127e80596849dc80564414b15b94e64de37907c25dac054660e78edfd19541a62fb3ebfd56f3fbc3822806e411d155c942f2cd0c9ef2706007a8324b882ee77b5347c6047edca727c6f36381702fb2846d095c62ef1dc482ebc72eee35d7a4c52d29b0985872866a31278d0588d45e1c9c537dad139ccdf927412991762c404fd15926955766e659f9f00b42fa9a4f279583b4393157fef87aa268eeaad0cacc7dadeb2f0301289fb48e8ca7e3429d916147704a90f58b212d9141e6d1274a0ce28b15cb980b0cf48f7d0c03d856238202106d715d1cff68fc8da14a23f61335b0803d7016cc76d7c44fb1fc6fd856ce4627fbf3c44f377b7cc5bc10cc16ee0846831894f9b1c49b05a7c1dc8b35abcd7f138d0569a7ca588bd6da6704c80e4a95314707d72de70154bb06b9ce0b289f3fad2a800d5a270073f163dc7c719ff33d8ef72ca6cc99996b16fe056ac74539de70db2a24f1202df4d409197c924644cd1b557f906b02b20170d999ff1c035d86b391aae3a93c0d1ae08d44d6b85bb23c8ab69ed8b93eb22413ca5d1e67a8010a5e3a285cb30c2ec483fe3dee60842fa120e7974480ee3028f25352a2a7eb3c949be82e5a235cd0ea39c75cfc96c44d41821238be1625c68af4020817f05ec30505a8ca1ac82e8ecd005e6bb149f3b91acdc59426d257168f542cc040cb01d64d73d3e191eb59e0b23729627d63c1a185ab05cadaca82f714f9acef6ac9fe89ed55815cf36e6602e182de85b027ee71af69df1f895b7f311108c4d2b5a8363618b2905d4e17b53f3d3c3253c0e624a7f3f7e80e86461dd397489b5b09d4bc8190c0ffedefedbdd953ef32b75acb3a8fd7c7195fc69ea3c0b7eec87b1fe80970363ec46a49e61362a74b98ffee7e39d70586fe4ffabc9f2f627d72dd6b236d87e1b56df1dfce49060a5ec60a194acf4f419d9fa7da3394e45cd9ec3ac317bf395e302496aa1828971a053d6a4e73fe3c2e40a897716826493aad7a9f9970f4046f50bb95d09ccaa5ce1af9cc3881783d53ab57d4206833fed8848f95e076eba8adeb8e930360aab671f292ca90101647106e26fc887511bd4c4a4dccade7c2167aa002f2dd9365d70c29c80a2f771dce7a94b90446bbb0f677338dfacddc5d9827877da609bdf7e469e6e375d35060f4c7d014fcc74673c6d0cfd2bbfdf7fbd5dc17a009ac68efa6517159ecd81a210c79da171e97ffeb0718ddc13292aaf35e0ba5a44f7ae5e92222b459cd20903c2528715462871afd6376b20c7ce5b0ec1bfe7598dca1bed8654668b5fa82f6954677e8aaa08f4e08d9939196031dde5f5702884504f7114b53b730250308c7c9782d5ccc1799306c8146ccbbbd6eb65b46f01da3399b23dbd8c5ba7f2dfa48398a902d085567782de2b070e7afced4a977903d50d13a8d532d52a9bd9a97c7c9646b67ddda217af990824c0e9962203132dc2c9c77ad15d3c6310659dd5c9e0f86d9de2ed8660502629bfe692b6041d1b40e38e11df5f68061b6e7d32afb148f83ea448f5a1123ad4602a72a41a43d88840c097120f58023814362799acfedf30623a6f66838a5936df6dcf1fd5f0008e7003389edd74b01e04d6ff72847d5d254cbc0d0d6d738ea39f597161cc24b8336d3113bc139f763b8242379f27915cd85d416dbe026ddf5c6b013864f57ec19daad11a46af7f41346ef4a356e5d7e0eab4db5e730369545923cc7c2cd151c24ce45047f37b27317ed6e4025f7080ae3f775e10512c02ecd9fc4503fb9c8c3f587d3933561e4b95e4816058c147c7ed7b892a514edb9bb74e77f0a5a5e9d15ae89b2974166d49cba2d6ea8960bb2f252bf41bd4c314dab6ad5179be462b2e1ef1d9dc0437eb8f6bd7d9a5ece004a686e6ebd3a81d738a51cbb6252045393f6eef383c428d1b72030111bdcc5993826c7245fbf52f97a04cf84173104de4cae6189bbcdc965e3d63934f7e74d07a5f9c6e437607ce77a4d33b0eca60a8f5577443a611a2db3b066f81bd1eb37ac0e8d3a931d3cb609b7d5f514b5f784995a8177664ae142392c3363d62f1db49285f0a077dd2a6d762506b28ddaec5a03eb74afc9c65bacac68001e6e89cfe0557f34e1fecce0c237dad026711dcc29dffaa0d40eea5dbe9966544ca0851cfe221c7057d73e0299ed9dc1da0072f7c197a733ba95dedbb16c4b5605e453509fd5ea90679c714afe5adc11447bfbd28e75613cd6dce6d77228e6a6dbcea0aed2979829a487dfcd9a2a32911324d8788b9b25a3f9a5533caf625c3febde1b6254b48432c4c43c86874afee0662dfc7076f5348c2b4af1f6d06ea0fff2befddc47bb162650537ea96330a61ae758a2f14bf935aaf38e034f25eb92f832c48c55cbf9540763f0ba2d5fcaa7022dfcdeee4e1e97c0d4864a97a28dd8d36d54d45c907c4095efa114668f4048e686eedfa1f32f5485c8b51a1eb06c26196018e2fd1ea518f26a699b45cb06b42bc3c8b6e922d22eb603c60eb0c8847ff642debc00c7e07275189ce0674fab9b406a06906eb0daec1fa8599730efdcd4aa5b539a415290e251268222bfff011b1fdf120d4978380304b7509bba9d8c197c24de8aec54cc7bffa2b662417b85c614717211a0ee0ce6ef872bd6f6d7eb53d0bbf292a900765010d9384f533322950b25ebd76a23bbab3c2046ff82450913584bbd22cb669b0f20723a935f2e8b62664e190ed80d17c9af0678542f718e004cb38f87a7b329d9e5a19631e02711b0ecd3886f15bf33b0e075039e54d481b1c5b81107c539cf7a233582cc2f5cb13b31edd539df1830273b67735fd7330d6bfb673071b7c3ee9e18b40e372d33c1293eccd2d672ff6cdbf91f5f2c5d4bd516de7e73a5879589470a60d02db29da0088ff99f19753436e45bb52065b2c8e21908164f2b5f20ea0839b9e26f65878b538557b2f6584a80d90872865466a0483e8056c8f858c8b0a9927681910e39972540295d4b9fde70ea3d8eee74b487fdc9e6be698770c84f8cc9350509c72d60b76b800fb6052a9936d16eaecf1274433c5e1589a9490c5a0fd389281c8e0a13a3e7a6e659d406279144b414e67aa5b117e06496e5145bac9d0cb0d4cfd49d66115b62831865d38ccf7b0d8a978704764da4960cea2ce7d28ab80c58db2107ee42b383506b83f49499036bebf313c527df6fdbe28fa78b17770e99a745388aed570a022cd9132986340c4a2c924ecb07065ad983dc9dd3c101a0072c9b1026fc5c7654f99e890697a9cdc0f1638a9e131013144175ec63b4dded50f85854679353b7d090df1fdd5100044d93059ac51604a9cb5c016dcd93101af358276aec29e397fe50f873a6c96f0f043027224979c7f42aab8450029d13e1f8beefafaa06668de4d80b18ba976fc03179c5ea5e3ef92775ba00ac12481090ac970273436228ddc700b53c16bc1981b46f88e79bb5fa7051f0da100c987b6ef8115855fd57bbf7e91c3937120ebc6abf46494fe218804ab374a1d71bffdb1b315ae013a3501857481a7d02e7c32f094387f7af8c254cdc6f0d5d80f6e611426eb49c6e5c9d01f3e2ffd4185e585f5f376d62bf181757497d292b58f1c12cf8785ed98945ab0f4832a87917e0d5391db137df0c007a583e95a9afaf32beeec4b654cef6167e00adfc5a75304b2def233eece640f703fcf4a1ed73c00093b91d82280b9ae56e8633d308567c723ef37aaacb00f4090794371164a160682c6ed0e4fad21517e8e142afdd15ad24c542e6ce87752abc71507e002e309051660662f9288b717233518fcde2076fbdeba193ed03302d8b098a2466579bf759ed2768198755ea400de4bad4fdd34bbe66bed72105c0f08b525ab586c61a5ca9b1c0a3a56fa9ba6e475827dd73476bb631ee322ea628fd80735796d150c3827d5acb18cdceb9d775c8bc32269e96390d83bbf51a3d5376351b16469744bf9d89f9092a6bd655b4dc2a16f5957fde179c1d59e643ead01848188eb428139b2eefe67004b259cd14301b80f67e9c681ab41e21eb7d70248e67043d65212ae16629292e932b4a90beecbde7f9b3eb41e947d3bf2cddf4ee65b2fdd4bcf68d8cf8edc25e7aac618a2657824239025fc9772dda52cd3ec387b7540d499ee802818294f2eda3cb1abcc954b1c54b5e367c8c10773f8bc0393439c452d6be8f61997c8188f6851a4f85de166338417da2044f89ec74f8bf214d359d0809043fe8c18b132905d83d492dd0e5d9eb8fda12d830da286efb8648147f0dabbd69fb187ec4a7197d3b3c6515c67f7bb9ad1c7d7238b649312610310310ecfac0b927496c7d744d0bcbd9036d61da3e49341f3d59925f569998df57577e602eab3de475ef371a1bce80f8a3405ae512501dcb9cc97a83e94574e500cae6618281fe81c68ad62d299457934248e35eb8648d509e23ca10be20bc0a838c5e613632741e76ccf3c9da191563d3fd3cc70b964e9312384aba0f1a360cbbf66ed23fd9574d2cbc9622b197bd017ed1504b80b23d3cddb333d46e465c81f42e6dbf9ef9693cacf9865a8e685ea130906709de4dfc971da4421e7a3fe8ed39244b60e8189161eb9c2da17e46e84a7f8d40277212fe9b987e35fb3dcb3eccce78d15f3bcf5ebecaaea915c56f79016285e94df05a975c5b1718acea7bdfd54630a8a18d332478c3af2fdb9b0bf05e22054c57d342999612726282e03fa86951a7b2e1e502f417e2e9d10e5aa1fefe186a5a822423ec1d2292c25ae33204de9f5624af3674f3d33090b41dac7ec4fbbc29244dd57bb510cb19d8f6894fed0f37b82b3abed13b1aca6eada7c7d365c564954831d9c2b87ce44d5ba1a993d95fab68d0e3a6f6360550a289418f815dfb512721fdebbeb3e72ea1cf1be9feb273245cffe1938994a260230967be4a79c75ec60d93e7b464a5641a54a8b4aba835e7ad3ebf18b2dcbc695c60857dfb735ab2fcb6dad1daa090740df0c0453675fdbd1c658eb6470967952397eeaef0e0f7ae3c6725a570919407820559ec2afd49d8fcf29110168de0e4a26757a842925b45d4ee29615ed66da957e2664e0fdefc0b70e555c391497d5c92aa448da3b6c553fc8904c41c48e8336102d2303e783e147408c74b80ba135260814b179ab2847b9e59ddbc7eaea8bddc531953a7036fa8dd862238862dceddbc0c9e79b99ba2735827742abaffdce25d495c041c234d3a7ecaa1c07f9766bc5c86482f3fb99090baf59b412ff4bc8ce499826bc491f79419d65f15564f2343133b278744beadba99fd953ae282ef8110bbed18436539e06cd5e255c7dfb7d5dc8267e8fb862fda37d43f958c144d55ca4a4f8c9da8ac146097bef7434e8f947e78ea681b4452150749d6bc4074acc860b449f8cd47ec46db8a796cbb315761e94e901311c64590fa4a39433d2086c140470a3f4d04e69624b4c6b7980744b42f69747f006d766c74bd710af964b68536f29ec3606c18750356cff674864cdb7d77b40fb13058fd7a3d8f578fd3c9d2c71222354b97a44b9af8f72b3a3f9da467657730fa71ef1ffd2e8c6ff7d1449fdb12a2573b751ad151fd642580a258a2866d8ced4fddf9a131ff5f13b19a0edd9922a1855151ea8b6cfb785dfe61122a2cf636d182358d75b28dce0b9f1805ea45eecbf25d699ecf2c79fad870bff7d83c2b8e63e468ebb6f04f3224a8052d35f2b578fc1258779b584147d9d68d619e6ecc058f1a13d1cd4db994614bcf183c1e8309500cf4ed5bb800082c01a1c374104c1d837168e041b60a18311a099dea3856baed16604023829161e712492b7b7bc01750a705ab5bc7a063780a27b73432009cf62a2a986e0faab6608dc61926e098daf51486272e222dbd86041d26dcfe8d45f45aaab4beeebbe1f1220255b34c0a3c2b226eb6fb84ce55c8463da0a96846e25ffd5abab2191a66fd193c8f6a512ba6d82dc20444281cdc498bdf15143cf9e1d90b75f6afd416155466f7c4785984fbeaa30c2f8cb449b602588dde698b8bada5e06ba0d6d4fe01341e46bf7d8fbd88a1681fb50cf7ef4372c603fba450780884cbf7f386948bb1ecf46edceb9b0db5854c46a1ae0110b234ea950142366b555c509b5400a0ced2b84d1feb33580a2b721fddbe9db171cf8c005acfcdffff00f8cd8edb307b414ce2b646ae5bc6683ec371504b77d2b75203a32b72aed648b9b7c3f409174d7b2f4692d85bb4aa542b35a7a41c514e79b8d10a9170f03283975782a2cca06e7db06dd94479ae1f571644fdc06fef9479ae24bf8ef1e509e68a16e8c46b8b42198bfaa499f1666d855e9877967052bcb3cc16f9b9eb2e1ae18f5a34ff48d46fa2ce7968c0f4610119d636a1ab8e516e52244414920fb87f45facc91af2f111197b79ff6a6a77a58347e3472d21c63f1d374af41bd6db6e7d07c86e9cca7983a821d0ee599987c02242c2c43999d899f72ea987a4584cb0b4ebfc598e7f15ca91bd20d23b16d76688f1eebe32d5ee4d0e7d3c4f280628a174aed8fe78bec3c9ff871381eca7b684497ad96c01d7361cf97ee847cd2316a7496e40fc081cb0432083d4b9e753b25a19dd008c59825b9274288efb17f3db208b2a26073cf2585533ea3c6b619b0a6d14ac9fd258e4dbfeeb13ddf1f780b91c3e068c280184865a8c61008a95a1363ceda67923ff44042e5d4a147862bfffece5081822eea37257614bfd38f55484980e59080b9caf3825943de37f2078a525165aea0775b3e7e440cdb7e0ed09440fe7ef18667a1da014976fc0cb198a3587e70616ad8c97fe4b28db2d7a13654539813bbc4737eedbaa7f5500f5bf54c65011dd0774eee53f277b31d3a8e3d15de5769594f768ca27a052cc94e781d75133931feb27b87ad2642fa81c8dec1857f731d3e1651e6a17617d0f473e67a0daa90e1c48ef19bda8c5eeb89e7419c4bde4d4bbab59539ba63b1276959ab089ab8308b1680ddf2cf818ea4aea310c7838824950756c7e93f6feaa5a11a43e713d07c9376dcf9f5f02d53211d94a6b4fe07cf1dc2ffd45017b8f57e936367d51c646734b908216626c06f4448514703aba93476932e3ff0b6ed2317b9e528e367a7bfb6024d1211f44caf44df5282c8438a56add9529d92225d5c0f726f577ac4051ad3f1ffc25d4c0026a17dbb069b6e31798525bcd597b0a526d29d30c14d3904fc3866a11a99b3d1c2318ea3cf03e4a88b5bd88bdf064f264c117fe6ae757fbfec86f367b9ce54c9c2810b7366091121b68a2828ca793bfbbf4cc20f2f07f2d08b60cfa4e10cca1b51d89658c0e35a71e5566a831e63ab4556443b0fd3e03879f3a076ad48c6b12ea3cb3ab29a8f829a51da8e982a4c38ac2a27feae8ce251d79cfd8a05ff4e3761030f64f9d371d94b9e0c9f86fc82dd2e3d15b4e8a261a68c4edeb3f503c02f3f24782bdbe2d660b9da27d8fd940f63bf4f8423b191cb1649ba5504373da98fa319d1272f7bfa04edaa5340af3e5a27b80d0368fc88d917c49eb59f4bf71cf0e0013f2aa22cf4dc0166c2f433d37b58431f7f453633ccf41f8bf1603ae810726b692ab4fcfbd411773d102cd065a918c8ed804856cfa58a003c6f3692d9f8dad3010489c8d94e02faca2e97c32cfc327bb392cb58b558673177d520125759b0141dda96848d089dc5435f04ab513809133002a2c35a6ef5a76111a35a35289e498e2a807f6abaf16e96779b11a9d162089f487836ebadc349a74fd586f81918084e82c12535ea696dc6655d5286fa3f6c5bd5ea54f40d337c3b9c39fe8cbdffa8ed9843368ef2f5e27f807efd1a6edbdb1b373887addb8a1265521a6f41a3bd9c9048c0cc250debaa8b99a5d6e97b11695bb16b5806cb6be10b5fb05ce863954df426d53ee336e75d929c5ab863e60dcb9e98304297d206ae58e275c28348608cbd5c4ab627b99e3b769fd45c9dfdc6c0f8418c3f1d68928b0a7b76f4520be1ac8edb6774176a29a38aa91427f6e9d654ca5a43b41e0a357059b790f509fae48cb1d38f424e8836851b97485f8801541db8788e67869a8dacecad733217f33ea459cda181ddcc851238449d6c2702a856ab77c4bfeb2f2bafe1d9456861f4864661db370e6e53f535ba7247ebc660015db03018ad5d7c1a8716f9230d5e00a44b6e713c03b1ca99dc5cdf53588c69465f7b5b2166ee8f55b2f67efa663d917cf2734d2de3edd6fd88a39d5ae128cd26cfb64663d8bbac85833e63e4f02f7151d3ce04735a01e666a3e0af3ee450ab0a150b31aec32d366ad25954c942e71972c4922024cbcc887438a7673a5d2230066d833199fc80baa1f58795433d454ae5cbb0930f2617a4390d9103d2504c716c65df8cb67e63d8fcef04ae6c749fc637c38a587e55f0561d687514eebec3b527622592db49625abf2e8021f7198f8a4f08cf83648aa66a07f1cd060752741e7b3c76509dc310eb085f0bee58f8402790a7480bc67a876b64d1d2134bbb909b23a62c59cdab0f1880d93f62ae204e43c88af108832c6d4d75054432db97dd46920530ae7b534881919dff52a7dfa9ddee27834b3a469bb2e43e3d82934cbaf3d894762b15c06b98712b1d5419c0fe8e03e8eaaa36be5332e0dbb5fa6bc73d394958a354b4636a56c052dbffde459aa05b9fa5848443560e5f4e1a6c69f4b5a878561833a28506f2d32c4c282a023ca68be1a52f554b40ddeca89b93aa130798e370d2d1cbcb50a04ae856dce9c0106cb23879a3a5a6e77e610042cc1037ddc1f39b8a6461035cb2b0f740fcec500e603596a692fb2293a0547712ada974da0f611c76cc36b67da23b2677bafcdd54300072001f3648200bbb28c32ed4d6908ce800e7fd1a9c6b2625334489f95d5e91eddaa0e4c8262c1153e9512660c006394e8430d41907a357eb1532f536c3e917ef98bc4b47bd3676be3eb07c00ca2a99924a99d23143acc0b37c7b32ec3028bceb12508624ebfdb86ed7570c18961c7a2cc43ca1c82064c15fa76d75986ee0dd174f78e23d606655ce9f82f39f96b17cd650fc3c1685bd8296fb3675e50ab286960a07adc64240a4cb8c197716875ed97b064ab0615214e8591738cedb9ea2ef6ca01a2bc9685578f8750e127811c9e8be4d2ab283b33bb11e250300b7e9016822f9c90a9bc4d501e0b3656048f70095398f9b096a6559c3501f0acafbaafe3481421fba4a8ddd40bf6c6a9561346df70f83b54227d3eecedb2bcb7cd845350aae06afa8e659c34ff1a7a058498e1bc524dcf3995bbdf7219f01ec7dc5832e8056b63d2aad563615febfed0ebacef4b16f95eb27a1971855f3dd18c0adc34bac0c14ca221b31e7132248e3f00ca33ce1e359861bdb6ae551df5ab3edcdc43ac2fe218b01d4aa925cc105ad285efafb3c71a827d5842794b09a297b663c0f8f27dc853b71e155c9d5d732f36421f12f6968758569696f4c03013263cb1b852e8fde0bd7a59b2c7b8cbb8b5b7cdb2878afd16abc20963211e68f4a95eaa11391149ef95553c373d0ecef74efddb41a53302e3d278da4d3d3e5d19149ec95023265336b99f6fc0ae941c46822339bacd160ced429f8aabd72444bb6a6829a014944a31e2c9ad1dd7ed0fa8ef69420310a6bfb8cd31c38e2044c41152f4a4db0c476c4e40464c0599c202a367c35d81b2a5baea772106abfc3db2a360389702b3841c479f4b6937b6a556f556dffca35f010d58455a9a7047597dd1efc283e131f04d8867ed99b7394acbc028b401690b64d243a5426b74e62baca4b98659caf4511229c63f546817c54c8c6714cfb2c425fc208d53ead7df2161a79c6878d546e0599d3075eb9569832bae21e7167fddd630df7f4d0185097ede296057931b73d3fc45283c631fccad1d268be3da9a265abeb1159b84240d1b32d169d69605b3ecc46d724d7058c44e65cbca78ec979e5cf49489ff30da8cd36247ed35eb54ba8f7e831318392b6d3512","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
