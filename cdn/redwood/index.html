<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef152fda9aed749b4915e5f2d19064aa664e7b134f1513f7145d8d5b241ec643148009b4ac2a9475c0a41b4e6a10ddacdf09fe00559bb45774374206befb974912d22b34b83d38ffec01ea8d974acd6319aede1e2af421073227bad61658bcb24cdc3c1189d81a465e2d4301e9c9805156adbfe58cc783d954fde1c6e1b1abf31ea370556e75eb709ec5c5370e3e487b4959f7cbed6bdf7c56c7bea1c9434150dd4ae515d2de83389336302707557b3a8b524f7bd193c4fdfe007e7ac3a7f8a89a20d8ce6cc44b8e601eba70f36e03246c7d7f8dfdec0d81fa4abfa6c373f551b6db1dc3530b7be4304f845fc0cc3342608e0c1e3409d564eba84647d2a227327d99d5bfe8ccc6f1c3a784dea3b68233751eebcb0c128ed066733fdbca5f1a12da5d3d47156e8b0d4220b5a410a8787dedc021fa03428dc4436b51559cd4faf865df1f1fa8214146a324fb0b03dfe705c2cf201ceac353fa9bdd9da3ae52f586329e67092e5dafacdf2ab7d589a673c90f40d5a5b8b61795816a07962320f339db94ec00ce3f15668c34724937b378a3ebb2c8737e9dcfb36e115998df07262e02aeb15edc9c734c7b5c419087161a23bf61ac206b4081207dc1781f1e272a862cf0dc03218c72b494eb8b2945e0524a476e5d122d3f4ec3f797e258e7bcc7c2545ca848079fca3f6041f8009e140a00f9c3a62de8d2b0403dffd539c2b3ac5af9e2795c01c7b5d3d6928ce60f5a41796a44a92c5cca2d358c4ef9ac03bded1dc013a437c6b2e787d89d4a124e6df60ac6d80827519964780cbd569755022ee20da54194f6646a2e7e637ce0136abdb3f9e217ac7f9050b7aa45607586e09631dcbacaaa8e945f70765f4f57281b1270e54d6e444170f2af61c95712b94ba23ddce995cfc07c2f3905b52b7ca01f31d963ce23b8fe60d97d6dc52593dc8abb01a0f6cbc242245b4ff53a062ddac9ddca2fecb49e1375c6ecf3b932af19c91957c5a1a51b0d14c71bdcf78f884cfa9bf780d506d9967ed574461aa6f3dcbdd0c0e62ff71e6112fd4611645c032742b4ac37b9a8c67500010adbab1950927ce4266b5a07becefd66c063284a565567df78c51d24563da1cc216a82bf04ad4f1722aac60ba727c82b0f2148168fbd034d5b10697be1c68d324b98c9baae7bc075d44c14715ca057881c9817057ca5ea77b0155b40e19c4eab7057ba05a26fdf2c145cf946918dceb0289eb96d3a797d8a07b305f1474156af5815f0d0098deb11136813dbf54bb54f9a1a452eedb81e29e05fd542d70767176dd643d415b4bbe0c8bc25b54e453c73a3de62cc8897c2222148badd9cf56c822984cc6587765557a3ab604fe276583ead44635f3a6159cf7533ba65cbfd4d49427596e70b90a5c94d60ab4d7e1b5b496c0215f6cf8306e607e957fb5bfad4614f20242e0f6a052518afff3f570357e33b81654d78a3803d3b97149ae7a4c22d8be0e64b0a59fe2d6b549d1a872322f5f8a1f42cba148144ecbf4f26cf4b2cb26e6f37a9afad808e5bdd91013a2028c13b887bc758a9654727dfd023ed9251a8a832a75c77cc3efdc61291b99a3f40e887aa7312cc0bffe9d7ad8b9520b9e001e4b75de508dddb35a37fbb7189b5ef16474b26affc5d9db24e3eefee44478ceebe56557d3d694b8f686f0423738ad1f9a056614dfe7578d195416601c81f861093e684da61627164c9c2a378957ee2d415336cbce81e514be816b521c62c64610e57d8d618ed5336f57518bf388a1b007a5033f4e214ccf65c6891b04fb0f1cf52d01666556cdb290ebe4ffa531fde99f150446a070891e6680ca3c8f5ef37be1cfffd3b0ab461c56bfc723e68225ab738e5cbeab11c38f5ce75d0ab5a9c4031d304875cc5c4f8813574d3b48e2b8f98361050c0eb2792e539ed969ba0f2999ed3aaf4c4bab7aaf0ab2c85f9b9b53ec6449db89713bc199d8d6fcae95589f0d5e1bac2a9df5af64215974f683fc49e8de5cb87cecf64fe24b67ea80b01ab276e0d99c67bb5181c27ea58ce01d0097fe22c868d3b01655df95f87a06274023323dd3e3b7419f73cf596bdfe8bec6ac7f75034d81db4e1ccd84d915bd44aa93d2baab34319dc6d912b8202e3108453657bbb9031191f89958a821960ce4a9e7ae41a36db6dadcf139922e2dcde9a5ccd6e148bdc416ecc355442047bc6cad0e5ffe98e0ad0db2108ec434687bc76a427d8421f4780c98635041af8c9338cdd8f1dfca2f07e549cf9aa8ed8aefe44d0cf270e1e039feca5ccc02a926d1dbd8479832283c6063b74d9e1b2df4e6da5010b34ba4ca4e381f0294af37289bd5580d37c795726499ff4b67822ffdad97571d40b6cd6c59276ab94b60fe53ea84cf5c69c5d05a507b2e69ea86cbb9dd3f1dbfe66a7798954c31a670a99846f7a48d4945baf3dabb2e03e8ce7a8c1f98a9200fa69c4735768022da55b3d9e2134000f9a18892bfbb897310e19b54f658a95f9171473ae67635813dbf358d69e8584c35026a5c66d2f9889312b59b351c00dc827ba1293702573bb2065101892eb50d41d7e099f381f4440128eb19669be2c25224217e8993db9556e45745bf3f85d1d6a16b64e678fcf7c989b4cd3271c70ec4f72051788fecc9b69a7eddaae417654e3195393393bebf4c63bf74416dc66a1f8d5af8901a6222deb5bdba01d20de76510e2caa13a3bd7085ada54498350e647a053b630817013ee95a85ada6ba3fc093be77af07f0bf9f5a7691b3b2d35c8ee176dc66dfb000ae27cc82e5a1aadf7bf135c6bf38941ab7fe9cbf4bc451a2adbfad345682fa283967a534c28f606517dc98708c6c817e89f8c3d290373212f50dcdb4bd6074a9fc0c83c4e13b3111283648ff3eae867e319bb139fc2aaa733debd0601b356f0f0a704a4015f4e9c59dd3af8bf06b1580dd90c6b752157cc2f816905f61d20f6ed143be1cd1ba3b12502d5f20446b252bd84c9f9f1fc5c5e0a17ad5d2e4c5264ddb49e69093dcad77216a065299f84ba353fa5d8deb1f0164217f60337b0c8a7b7e69277abc4eabbdf76a438e6a2374f81d209d74e6455b1e85001c6ac233e605a0fe61150e51cef668dfbc2973067e6814317bbe39b28559b59ce16399036f9bff3d9146b6264f6e1ae4ba6ce6fae5791ec1a25d1da3135b13782feffa4e12d8337e344a7fd315edb14366e016f34fe21d04ee348bbb1c6702f9bf1d184fe57ca48f48bcba1e2fc345840239ed253846412284fb343a571addd00d738fb9dd5aeb7ef77a5692517b9b41f3e71d314bda2ac2ac022c682bf99ed04cac4ec3eb63e9980e893d13fafc7745bd4f7ec6f43b5c15983b2084ac8fa86caf193a4a2bc3a541b771fee7f7c3ee15980fbb1f813c4611d678cc3fce7eb37728876e5c0f60828d98364582bca4f1bc60df5d45760a503c8dcb2009c7d4e7a8811870cdf0c75f75d4ce203e297adc192dedeaa808a2b72ef7703e31251a9b18e4d17d2fe14124c9e41ea66207c708fb178c4316d33b88bc2e4d9f5976348f78ca0c2b7792e60ea7aca9975a3d52b14577874dfe29ceb9e5b068f858a40da262888ace451947c66a10976e79c278a42e81492b06e7c11d8932ec5104cca500ae81a9c93a2a46433c3ebf42a4968534c48ae74a6a4431dce95f6c0036131511ff56ea4e57943dba61a55018cfb57e0e68f06df1b48c15b5dcc1ca148375104d81c0a98602b26e72cacf77ab65b73baef1cae3c53cae1ea667bf4924530033ed9527e6a0f1df70da08d4b51ede916f8507563ea5866f69a8d203d7742e4ec7a7c502d48ddd49ec638b16457b21e105d05555684e7ccacd7cd4e43cb262c5da9a430f26081d1c8bf70392f7ecd2381d68481eabf56fc2bd9df98bd797b27c7bca20993d137d89fabb0fde17a183033a023a313e10bc10e2784c7c320007d4e57cb7e47ea487aa35218f0da98b7c09815d6a97481604aa8f3f23b054af598c4646a380db15d0d71862b2c352920835044e3343f617cff97f87fa0484a171f5e6c94db9aed0dc989154a065b00f3e1321dac6112f4dd7ac229881f91793cec294e533eebabaf73b62fb4b5ce036980cba76c1d9eeb2ad30c0222023517aa845b3cacb4c0d0e56019cd9df8fda957a689067535213929118c2149f02b8d71c89c0b11e31f2bcb7a065484ec7c790136b80c721f4833a9fdb67438d7e050e6e438bde21b8c705a24409a10fe69321f4f234dca45e76e791b6c89a54384642ff293f51ce912f41abf88a3755e06b0fca3cd2ee39bf0624be123933578cb0a52aa5346123a3b3402ae454054126c0fbd638b4349dd523c8af139a07caf56eef4ca7ac4e9a27a2adff063788b438e6bb3bf7a912bf6fa09d091971d83cbdcedda631a91e1119d2a30775e9d9e1a39f2e3c91559208a2001b580600d5aae7ac83bd3fe83a05a37bc3793028cb75e682adf55c2801e375fd87bb5147df86b41b29b049b652c2abca5318c7246c9adbb6b03e7d46f60dbfd1c798133776890df1efb22ddada89c19042a4e0f75cd840c6b5cd94cb0fa561ab0ce0b7f502622ac9b82a832eb28d78c8ea1a3d449c4fe4882358b39340de615779cd577e61f8a7164794c20fefeb3ec27ef26e7aeef41f2d863f0e28ddeca559b37792fd1143d814820385972a6d9f70c974e7544eb1f2df1622d6a5c6c353ccabc03d0adafdaf422f7c539ba7b8fedc96ef579c4517252ce0cf6bb8e8155f6375a81a2bb761efb6cfdcc5358c7a08610528bb0a8fdb6680df1863b36da638c046fb65e5ee4c02d6da828d9ef6f14ef7f623c18b1fe0a3c68ecbfaf8425cafa42c1b1389af006f7d453c705d071592e73b76e0e451b90d74368f0d26b686daca0a2b3c04f7c5e9839319f26417fd97da6692ce2c98cbac60fdd074e3b5051c3281f664a600192a3de2045e9b738de6fef22efe3bdd191edcc2788536cfdcddfff1604f8a614c8ed6e4b41d97339e979b42c8eb803b7eea7ed9d76fac0168af046460c1497a7584f09ea04c23a7ca046adbadbd20bda5c0c8c5ec112c5d0707bd84a7f0bc4830b4e1424f43e51dd841fefc1ca6eab159b79a67727edc66660eeaefffb00d966ff1bcaaf7534e1a7729dbca6b48ef39510cad9169c895264e9991afdabb68cb40b48ce16ca482c6d3f5a84e0fbfb18c3d7fc2518d554c032653bb935ac097bf4c2dde44814ff495d4160580b5fd44954c114d9e73b701d2323331ed75f0f44d691691ec346b6f6697368dc7066bc6e677a949af25f4d068ab6d11bca5946ad2f971b5aeaba30e0817025073b0726e6acc6d0d16030b7cf982a3e285ba2b73f6307446793927829404c00d6ca0778d39c67b272c9c7550d6eccc2879e09c481287bfa7457a7e990f7bcce34d36e0fd610aef6eb26d69f3d56a94c6fbe2a238deef1e8d3c4cf39f25a1b239210f57569ce5a989694754cc87a5e2914fa35deb5355c2b2359eafd4f96ff3d0ad9d3afb98943225b403f5b075f1f34197e695f425e3a9840a8ae52526ed86c7a00839e9a0bb42c31ce719660b86a90228b39d6eaa5fd1c573fbb6fef3ae19436097d45f613577b8094ff6ca9c5ba12da20cac8b90ecc70c7ccd681307ee6ccc54b811bfb9f97437591d2e79235e07b946044131630bd3a69a52dc67c21d50b36257485ec4b0688f70655278572731dbb703be856e9c2d4f0d9d7cd9866c6e13e27cd616f2e35013907e479a2f424fddeff27cee08ce3577d937e387680a407e7c7769d89ad4cf82b4e47aaa22a0e62da4963a91fde12eb2ccdbd919f3f0f3e0f5d7bde1d244815c037a0f2ebd82953eecddfc720ce42bc9fc972e94c59f7e102fd5d4543771eb4031cd412a8e5e46911e6f7083461ca71abea4a866258d07cbf858bf304da94b31f3b5c3e848afae62d74ff6e507b40484b86d731c2b4859f0da3b238678298f505ae7c82aee7979db993ed2f9f0d3a3ade0d310341ee33524146d8b1d4ce49ed436c142831365877b3d433c961a27a9f2f38cb850758a3c978cd07a46f486998f951e9c63ea035fad35c7d8010b133636eb56fca1f6a99857a9d068127eacf2fcde02ac37fb33fc5b1e6e03a1de007dc24c71fee7ef4c1d5479c2e7495058e83bb007c97c1de47d82e23ea53ec27cec64e7eedbf0dd4b11978ddfbbc80f4b8f5249957c235dd80e2fc7d5e4c5c358b39174d2d17a0e722df5a3d04c4ca31aa2b628f0989ad64b589be24d94ea4b38a036b035dec37b32ba5099d502695df956639c4199b48ec8b8e76553ef94ef62dd56e8a7cd44ae180be7e9913ca09a795f249ca068f0edd5628de0b4fb25cba7d5094ef19ad5428b97616df7be640221699ab160f2d954914c1620e87e2b0e67c3d3448af3e949e44af72ca64c70c5aba5e5589745d439a97aac3c807bc28cad6bad96f4a2586c8dc881ee82a31166c7f1a24d83f419b5cf0176e4d74e8669fc8213553ee2a71508628870379be21d0cabd41d61e7644dd04a3a66d643d4ffefdae3f5c71b16f3b7a556bfb981fba541ac0641abf43a89497ae3d3289b7e4c02fb124f7232d8c27d303287b2b735dece7072d5c38de8f8925123e2c7496008f2b00e20444ce29ecf6bf512bc3067a2c6aea41045ed39656659e1aed61558a42e19533adf16df57d4832b6487e5d562c822192a62cc756ba3c30b7c8f706a3c66954ea1ef2fb4c172651ca645e8621ae973234f1ba1c20c2e8e2361c8bd9a55a2b8c966184af248055ffb55168fcd2df9d176555bb1dee0cb165ff771fbaea1df152fe2ab40785e4375758ade4625168ab920cfce56ad63dd115366f8e645f1a7aa63244645be8cc1fb9a3d0500e3fd87062bb545b145f22a5f903cc0063bc128b3c6f55d8a4e6ba4c843fa483158754782af98542ef4f313346f4d08c0c958bdb375a9f54bdddf58129db6bbc504494ef1d4d527aa57b09c399b6fc6cf48ae8aa20b99c46df511cbd90af76209bef273dd506acd468d9b2b8a154b638d8813360b08e581a4e656aeaae3bcb9b9bf084a87430449a3f10a47cbd37090d8cd941a4c5c74f61a5c8d765b8e9fd938af325fb548be6ccdd6e82f945000bed514e816232dfc131a36b1704d0a13527747b8c86fe9034d505e2a4348fad606e91a6af16737a02070f3a9dbdab88185dfe429d001dd07d46f6325432747d8e1359609bb777eab05c301f3609b20d86085201f1228daa1687e4b96a2948fc8f500d0d6bd1f6e14a8c73619d2ef8303b13f9d19846ac5e124cc81ff4c7aef8c513aed9ed68e4b529bf4366037ec16a28df82f220c650d1a4646abc7f2b6b857be6531c014ce9e8be563ac63eae473c541108b11af29c88de2ba214544ff0c7df42bfe5838c6b6880027b13ff49b919607cab62ef3e0d5eede22f084697ddd7143439c110aeed5e0fbce00fdef1807cefd341951f98c612c463c1999413a495308c5be57e0f4754e484f9badec7374300165efc06c423231e21dfa0df6ab1e884570887933bb94615cd4c998234d4d3d82e78a004103b87a2a45bbfa5de0255e4bd9c5f9948cb8e39897e647c2a3457796ec54333c8a88de581eadb018b7dd5d3216070995dd68d54b203a3d57831e72d86c1a8bf0e685903fb12b2045f7d5a57acf8dfeadc79fa6dec7520b7a4d9a7102510230de3e1524c7774b8b7146293b940487103ac903808d6fdf3b38268efa2bd60ac267b22ddf4e1b7917c94adee2e47e879d15b7ab6d17be0964bf04c4838e3a7b4d0881213dd2984330998a65d66c715dace5b20d472b3fc8a1dddbf748febc0278690072ac9881bf97758a8e1693bb9816cd210c8764353cad51477e8fc97c634699c0c61f809f539433670143a17f207dcf2996073ee85bd70f9935a338492bea0cb2f60dfbca96b0c62fceb6b4872f1701429679bd4a958641888bcdb1497dc4c865eeeddceeb0dbe0865e0f78ccf1c3eba569c705f18e971ced801cf7d39573be90f401e5a0d05873392deffc237dbb450f5d374e2fa8fd30ee81da934fb4ea17f12027fb13a6a50b69edbdda772d7c79ad89540780d323e569690a9e86d75d19c0d948d6ac8c61f43a1b97cec7d85d91a6522755bd6de0362ebbcb9e0ba16ba3c876c328910c509018c369ebaeefd3adee81cc263cee8cf29144fb9c9b320ee1229275960ef44157e3f67c2cbd828cb15f15067f99ddea0cf7c4193292316b16fc8c1b9cf6eb07bd95bd5a51a8d9c93453c92f9dc63caea1fd9952ca9ba1611da542269202a404dfe0625f2fa9668e74e315887142c0af76e11fbcd2e76af81e7d5d395a8ae5d904cbeb4342d1e8c712d95f4ad5a335c5465a4b353d144de7cf9376a4c0f3bf4daea16b65cb59363c4630b9516730b4134334fafc278170b94bb06162d4acbe117c97a47fc26bffa331f2d448201122d4ce33fdfa64cea752ed1f92e4862f085fb5cd5af7f118981f714f0a137ef623ef6f41117f14b4eb99cb13bd179c771cfac041348ec0f4a58e7c35e17c7c184264a11621ac9dc19868400ca7d4c94c86ba3df03fd5392f7d0401e98700175783afcf13e95983c7b5ff25e3d02d0bdbacf460501655cb3b56e3e6980c55b949728c284332d621540a7a2a9a7d31d3d61a14c04aaf775cd1d1f36d23860f93d5ad062124c784b5dc8f191ee32e1702ad825c7d1a67425dfbee07415c68a7602659ee5a5acd36585aa9a3a661e4b082143ed586d78be5099d509a002d932dbb714c1a8b0b0d29238e5be5eaefeb925bba20a16aec0eb4596a22c066bbb84e2193e93fdab12fd331eadda0637af33dfd975e8dacd9f3837ce17e84613d92eb1c1c80268a05b536729bb131a1e7e8c94a7220a473188c937ef457a37eff5e9a9e2dfa08189975cd6e3c63d913b5ea0bdbdbd73876c430e5e43a3c4af00ea5502896607b357d7a0b6af68f31a2ba41318735b87ffb7648ba6a6ac32ec79f2ceb6b24e0d3a59d4ac4c69026088113225ec35ee0ada40e18a170adaa33ec27042dbb704661ccb187a581c00f21e0c1edf4cc6512936f94e359a5af2b3f37dbf958d99b896832068c9f42c6433f4fff4b174a7dd8b0eee31a31d0520b6d92194fa50a23d9ca044f2ae2eb5768d2ee3f8713d30ff1b403666298be2f54442c7d08c1c350b639ec6d0eebcc9ec4dd9c04c118f0f761d610ef243bdbf6ef1be87505b5fe6a9c1bb374587edb96d1c5bd1805df03fdd01aab60ce7b34b8cd1cfa4aa4ccbce9c8b301e6850f777cb7ce8e5b2dc4f46ffe4e65e19b4177c8eb43b03db67b10dd38958d1433be3d0aeac73728fadcfa0915bc6335ea897ef52c9b1650a9b1d21f39ea0af7326dae4f287a3306f5e2636fc0260cd68fd5bc2a00aefd73e9327e67af53e62fe846324f50acf931310faa886bf9854ab91fbb4ad687ebbb31c78b9bceca218248b989f48929502a67eedf23ae4b88410f8d2fc70c7def9c81bee33e2d23ef70201c3896f4e67d4768307525f3177cf3ff651d723392b3de21f9ab375f3ba2b559c1ee54a8dc18be4d1f4b81b426af4bea342614c97b2c82ae1fc1e076fb061aa114d3ed7d7be09643f54dc43bf77a81a615be05e14d387e478765f1817a4020e177f35ea63b0b583a22eddd4568e71f616802e6dead2cb0eafbb0cc97f539cd0f6ae701fa10511c97384c5b49f784c4536b984da9e3564c74d09c8d11cecdce5dbc1012d5ef3087474c3538c2cf2526a494273285ad1b6995372468641950930180ee94cc31de3b3de5d46401bcd1be64b8a02b1e91c27ca961467b8760aadec167a80ceebb8ce055bdc1f85719f9643f7cac08a0458500c7151db8246365deca7b9d1ae89ebe87777a6cae7cc293fb91fdb3166cfc4371a676f0a86ed6aff00a9baf034d9fa3b48778f109a72d0f0b8401aa80167b004b9b801fd77e575a29a1c76f28d50950b0bbdc85355f5d767f4a1d62f92d95364e5aeeab07246af2468219af07265adecffcc2479bf03eede411361395015b50ef896dff72ac0c1afd5808ff52a03b5d489b2448db7f80e204380c9462ef68631730041bae819a31abca8ad7aa7efcb9b714714a8295941566b8f0f1aa1fe15625433c9a96dbfe34bc2a690cdae13b0f1b7c73865f6997f0378cf842c3e8e20fc3641a7d377dac79f6af91990eb14af9e2462044ec3e7ce7a1fd10cfe81055f96faaf52fc07905816707744f04d507cc992ff676af9011bb0f418ee9aa269e476c7aba560262f4b4a375ce68f43956180ce21eb0117b3e0e14d7f987e53d8bd06e533ca0fbd07c736d25d783edf9e762ba354f2ad3d7da36fa31c1b4f82f4da3011392e03027a27c692c55f4c55de5c59967e7b5dc1afd8b2faa4a1384a72a76b7aa5d7708903a842fbcd933498a2d079dd76a58f2db56fa3cd4fa1d90bc237f4f5098cd506f78f1d1976a7fd333ff8101afa72261af71e5172278a64c1fa5592f12914749e66c20aa692ac8db66a9c1ca1a94acfc54595a9e66abe6d96927ee74ad13adee9da766a483ef0d21741350f466d3fcbb9b40bceb39b445ce26c5c3b53cfd3109aa9f52ddfb1b803b54b10ac5e1e075a37a3096e0b4f6fbde03b2e6909c309fdfb42abb60574a2c5f10452bab37f610996861f8ab6c62227de21b129888a3062ee189556b185b8dd9d908b3e783b7cb670742dcdc6e1f2c81a1d2b2bc978ae1259671573e222c3b17db415281999ad18e839069a986cf94725fef343cc8ae3126ed4b002c614f56e0a50fbbc417827ee086b74b3ab41d6d88e28b374d11173d4436e3e75cc1a0d698c95aa2cdf723477d76e42d9fcdec0c13ee8abb5633fe3ad00240876828563c7a083b4c7303f3cf0df896e6946a32305da4d67709066a2e00387e9f469ef820038bd5d11f78fd9665cfff9f5ded4f4394c74e18b4cadbb3a453f2f1f4ddbc418ce79210845a71cf7af96d4056dd63681377c50f3fefdc353ed6779645e636f7371e3b49f8ee713d958620bd7139647476ecc08dfc0fccc8d2b2247287cfe568de12f70ae7eed935ef869e1d4b5dd7a7d5b50d09517b4adea1950db5d0d043b9d7288e856e7fa886dd36146ffbc7bfd9a00cbfa387ceffd2afe0ee2f26dda8284e7e3f7a3c8c5cbbcc3577f90a1f7862022fd032a4e306eae0a4feba72081c495369d0f4882fbfcd39168a5693e0a120a0242888ebbaa4a2198d17876bdc74c27354756d00967c414fbcca17d5b215263c9be876391f072b7089d95d0fb89e24a4d7070198c1523ad1da933b51c139b8fee4926717a507e5a83f49750980d7935c6c512bfb57f794613241d0fd3babc63fc990eacb44b1f02e3d73baa2454f17682221995829ac4ae907afdf8cc1a9fd04c3ab7db2300b767b52096643873efd63b0ee6ce4e19b61a5c24a2facfdab41f6c60e4765dfbd28d1b7aa14704905ce8599775f94ff061c85e5fbd54a9034b4e8b02af680a8df34fc914f41b976cc898f65742260f58ee9ce22a47a26107f2ae55a297d7a6fc1b0292b641da7e57db789ef4426ea17c032726c606ce150321b540e84ef17ddb899cbd9d38c76e9f321964ed3b4174843656e257c567c319dc3016859911421169a4bb28f1ac10f1c535a1d778a827ff0a5beb92c781e7fd35f1cb365066745999f0c0576453821d971f146638ad3c9711682e16af1cccdaa1f285c7d4979d18523ddff6d405b814e784672cf4666bb2f14ce5178258bb6593cf763086699734ff964d76cce5ea59d946e3c058f076df15196d6bda802dabfb3d1a0c32f77ba755a6900b677472acaf7cbc561e103b0e9ef0e1972c469a95372ae87a955c632047380ae68aff0015ee4c4ae36352b47be56f01c7240116945b1b6584c8d244f6696c0c9c0428503030f600b38bb38187468429fc24c1682b69383fa2663a1a445262b5e62f1edc393520dd11f43dfab904411e5d3b823440d6686c05df2168405112ab9e0cc8dcb88c62ea0bf5bc0659e9766ed338fc6b76b6f3b3d4771b7b8988225e3752e84d7dd62fd693e456bb96368419f80c047d5cdbef6548cf30b68e40a9a2d194d31c2f89cc29142f5e5a104f481901a4785a5a00cb275d0a53908fc9d1cd7daf269468b50e53339a7c96e04f127b0036bcc4f67623d2f36bbe02bba5f30b7201a28fe353da2e5fba1548fc2f0dca66d76ee41bb9e1ff5d382e732839a5b0a00ad7e05adb5b43f07ad096f3c1e06752c8d50c5f0543aacbbb0c56de5a4a88cb2c5025671be771ebc1e3732c928c506dc4b416f863ffcefd3ea8790b3f1f2d0397c29fba4d78c1054c6269c22c914b37ff8aa03e9d18c1d88872fcdd49839c43c652b34a65febff9131c05d57492665912cdaa8fe3d3552e05978b6a7aaadb7a460ceb193cc87069d6c2da9bc6a70136da06f0d25182d29bf8d54bac6b729d88088f0b4eab9314e5fe8be94b6f744effb1923a0f71f5fa2080ac1c648d03c58c5af74c18cb0488b2ab16abd238d0c7927313cda107327433e198258ccb844030593e91aacca663b414465878793eaa8273741ff26c7b968e50c0c81d34e294dec2123779f6c83ce787706ea4957dc6fd1a869c82e36099efcf3625ac10ad8420e2c85ed1586a3ed6826f35f834ccd5579dd4122fd4399bf61fe073105ea5600994cbd3e4c387188bc9336aa04c1255de310873f87fc8609da1304e442690ccc205aff4bf241db068d08fca00653b7c7be1fa7bbb69b941d575811d05871ce5c7f539250ec5871ba8e3352755c8bdadc55e5c75914eef0496b31f6cbb1aa9a35d3070f7e98b584016611b91e199d01ba0135b466fd2ffe2c46241db2071e7295eb2694f602ffa9b57476a31691461c702eba750c2af8951c0d3171b92dd1cfbc2dc8618a3e12d1617241e74a13afcd1ccb31ea4170e6e258dd242d9de3fc17add0b804b4d17b0a0968328b0a19a52cf81b24ab91010fc3be2430818c59646182335a4570c02f88a3277ebaac6ce7b08b46101357115af05ab3bb170724919922ad0692a4f5adf99cf29c362deb51ab576505c6aa7d256af988e875989f73565997b3ebe8817e2dccac989cfba8d7cddcee318e48a6d9fab9fd1b149a07248114b19804dfda1c0993ca65e30889884abff80519ffe4476e9e95c1638a348a81dce3869f046cf359fb9835127312ccf29c98807397c04e41f38a2468741c4685ae0fa5061683f4568bb380d9007d64a352678c4a73930fce2d17cf620bbfe55218ad29aa7c91e8910b5b69d13a997e9c1c0532ffc1103916e4f6d1324f98fc93982fef7cc56b2fb8612891795c644a4d2f06e1d72f50a7d1c918cf8119e376e12e0e0024e5fbb7b99b22aa8c38c4c851263406f7e88d3bc074a7a5331b9cd328fb5502b5dfd9a3bd88d65c6addb1e8a48c679eade93bd4cdb21f2e5ab884017b06ac1166c42141c318acb77a5de534212b57de0a822a33e65850b94a6737c2302c26ec074f58a5d029d2e2fc807a00ecfcca1f5380cd46d2956a558e5be134d0d185831a50f51d30a7f2151b0248a0ff6a3c65683c57329fa7fcc1e7330db03d01a466c1e2f54f00f369eae9f93ebb78b93ebe9e894d8aab20f3922e88428a5797008a6291d94495767ec3c2a33d17cc63650fd3f5462c422c3ed43917326107f97a13d54206c53f40e0bc80c420502c2840ac750f5755bad66a61a4f628d43bb81ead0604be155a072f900baca43ea3452eadddc558204d3aaffdd361cc30722f10ec6bb1dff65c5ec41a372036d91965543fc5e25f9edb032fe941631ada795f2cdd84a0dd6accd70067ad5930cc0be68f113d385dd0726fb176f28aacd1a47396bbe68875ec0d75763e59303b64925cf690bc097587bcba2f68ef8678a8c98459f4d3611c19143adb39285279a3bdf0edb1b2879fbbdc51047894ba74c3026eeeb9320d722624f2e56a1b15884a783e0dd21234aa2739440ca3f85a6767b0b0aa299671d975776aa062f682544cdd6ce41ff98b7888e0ae7c3b045b9281e86f5ae4feead06ea63544a5594f9bd2a35c4bfa52635d1ff115d071011b79cf1a883c51a19e4d37d8a678c0ae126e7f08b2971f0f47b7567c622e7ce2a03c9eb0ab075bb7e7635e11259fd9fe94600b3905343006814c4225e4f478665c771a98c9a64aaa3b15d685e87ab0a7da6b09bd7e471cb8408d0172bce4b48a1423a293def1ce70caa95117622e56c8e6cfe1de54eccc3df2c08983d25af9d8c5574bca995b0f407c726a63fbd12f76ac83fdea6f88960583850023e86c22b632a11e962589727cf21381220028fc0afc11a944bdfdf53c7a2880b5e2de8c5b14fda212046a8cea9cd070f06c5562485cc68240f2d4603eb701bcaa0f0a28a4ea95376c852989f6a8f3f5a7c0f74d60b29d52e0cbbf1ad8f4e0365e8f1cbf69048c316ed054113654d45d3d332e2423bb16d9d458e0a92a18b089f09b3dbced376eb8720a4f5779329cad2ece03741a34e7b69af0eceb696cd737f4b0e1e2186361f869f4cf4ef1a53e559e6140db35223a45da5c9cedf779c5cbb625efa95af1b55c7e6e6574d4580af0c0a83862f2e8d521a194fc416feab7640f04383c66e20436b0b94a252e6d6c744aaf6d53237bfa9eed4489194f0f43825ff16939976fefe59b1077a2e0043edc9d01dde1121fd611448ec0c6aeb30445382df133d2e93e85dc8db8690c345b51afbb549c681f82adae8cf13ecc3f6da40f228353fbb7157741fc2b476eac3861c3d6b97a777d6be2fd630d0d608a36fccd16f78b8ec52fe3fc1b4d5624282e27cf23c0aec5f1f73cd37cd2db9c8452b5f92fefd4b5a4536f4b054acb81a87d27b38677f293b7f7bbb3a724c2930ad7abca6c8b931de264d1502a695df2159141f7df566aae59439ef08fb2cdae8133e31abe9e7a38442d6d140554883ccc9a198144256246b98c234025e464d1e4567fc56d134c30da1f46a6beb7cabb44c96b5e9830809b50680af9aeeef8c052aa665d282c0316454d6cc872cb8380934dd6003ca0fb878292a07c4634df13d8cec629b93d5b548817c2fe4512e14e6036fb79c0f74f4a1561f1630ae2934d9c4c2f10a3a359d90cbaccf09305c9cac72918e972a03a56b53c54d091a326f00b04caae125d40e8b2ded0bd453907e2f69e4cb4e2d2711658f6a7a979ca30cdb9f968b1d2d14917473759d9bdb0dc43c2816527409a0dbd6c0e44328faa1b3cf500c682f4703f25c81824825a2f49b838e406cd6115368588a5b831f74dc9e74376cd96b824a46f4105450550cde11ad67419bdd9da0eff5a579e40c687cc9ab66afc32a3b3785e9136e47b9ea0d47b0a9a87c70aec0d18a5ee3837425447154ae757f8a4e1bffad5bfc8e08e8ba522ec1fb2b22b4170b10547f7d2591652b9f4d806f7f820741412daf6f11fbe356ed91ea5354f5f0dcc6226cb036f3424b1595231ddd5341f72b6856fe0408f7aa25e2355ec2a076743b42913eed85d4ed52ec56bc113612730e230117debb65e1e117e3de387503ee3cdccca559d219b5ffdf6acc0a9acf0f0e5c9d2635dc32026b658802066a3a6de02dff32e7e757c620181d6e04c38c08199a4b399f5d40a1f368c878b3dc1273515148b6718488f81203811ec9f2eb0771a9d14d43ae84efcae6d3e72822d2739243931f6a75c23a7b2e66ca2e1128fdf73a139fff49a37f0a9ee225a89d7386225bd13b96772b1d3d62fee3de77942762f9d80bbce75a651663f05cd7ea1d2ecc1e5b317c05bdca37950054104ad64232849348ec294350d1f99847c1ed42c116327289e2cca0398876af395d02dd3bc264c706842102df78695e655db3028111c2450f56a771f94ee801706f5d1ffb946a290699147475377c5d2edef4544daf1b94e78441c423bbd887bdad30ce8ba678f08e81918ebf290c00ee7f159660d8619455377a86b381b89fb565b69a99345868136983ea201620dd4697f0c80d9f75e3c810a66cd74d194bcafc7beadb4352bc173c6b9d3b47bec8cc84fa04dc4f845a704e7e814a4739f61e595c86e7e017a20d70e955950f46419d7909400df9a24aecd806b2df9610481695836751f5c61b89191e9f36857d1ef63b32cb3f54fcfe79b9c33f77488558762229bcf58a5e299622d0b96a7f293212bb33cf4592be45b9d4cdea86d069fafca05b5775172cb69890482246c022b09720f0d2a78e848ea217e3a40c239fac257a9688e534859300975c8a013d50a2bc966e1c479c236e3ff75c5265fa0b05412bf97a2ec5012b9a95d2395dc698066e8613b27663a53011e6650dedc5a59f33fefcdabc5cb1204fa9cef8e7902bcf51a08aa13872c67285136573d28428b5bb8b0f2f9603343572de7da4da4edf0790b2d11556cc00ca076332c69a5d0110bb0846af86a2b655294bcba98eb86c967eb31bf604a86a27ebbdec4aac44e31614c2fd21d7b3bbb1639e3e563280a2ba89e63c18bc873bb191df5ec9112f83ab310d9c2c30615c16baf7088dcdd515daf92e8ebc3cfe766f86fcf5adb57f762ab83ea0bf86e12f244d281c00136fbb852c4bc8075b4e0c3d5cb96c0e05eb8590f107e7a911925ee1005975c67dd58d3b4b986a46ebdc4a7739dadfbff7739e7ca6ab6e4b71d80ff19cc8fadc3c835fbf9d6198acd596897708a6938f9f608fe0ec16a34b07c4b0d6e52010368311ebd745e986b603b01af7afba7926218e0da144bb810ccb029075f3ca6c7f4befbaccada85871aeedfa81f1182c2ec370b8605a137a6cd477872600203bf115b1f7846e3b9739d67302edc33157f857600a68176e95f08afc791422521793d62f97ba4d4c25d924046dcb1097d23e94779ec1ab12a96b1ef37cf69b25717fd301e0b19b689cbbed1a8cf3cdf6e719772eda51070b980202b080dd41eec821ab90c7614c44f86e061593504c15ee112cbf56e790d99706aa9407c49eb0d4dc9e5478d58e2c0727bc138839e1714e12895e487055d92d4753db94bc851a2a52bb0d001e4b3a4205b7529223850e6d77a825f0c370a5dbc3eda77e5a2c1ce9fb4f1359e66d08498fbc35f1fabc8fef18db6c667b710e2dd301610eaf48c89dd3dbf617191c58ddd9acc9e0f91533a3565a4f02b49a6c2ae1bdd22d290ab70024cc64b23ae70f1444fa1fc0aa2b65a23c1088b2d31c7fbc0f4b6e35f9cc71b1a83dbe0d3112620335ca7b6349f1c956808820c05f2ae78d683da0492352358e4fc705123d542cc1000d3b7178e40af4ab9ccbc2a381d84dfa48819bb305126b7c3c5e8b9b15e2f7237c9094bb30ee146fd46750cb7efc8fc92c6ce95639af361ddaca832b0250341bbd667472f648bd4ba3bdabe141ade90f491bfe10695cbc2c4b34dbecef8915011c9a9259972b2d732bc97bd0f9f961746a61c2b519202188a6bc23bd78e9d62269b66d1141a4d1643d6d0eee2b37cdddd788bdf49e472cfe888a0d48ce92f34a25d60e3c0bdae2d89d5628892ed0211ef371b1ad08ee238f04de35eb3179b1896b80578f36580c4c1abe8775a1c39903f5e13701dfa20c9e4e726867db472ae005a29ac0f33fb9370fe62bfaa95dc161faf26026b181efae599225169dbbbad383654eb28a7bce9a1d881534be0754fc2295c1e52ae060f935b15de6d7cbc28f3b20db9e4b3e4de180dd8b2bcc22842bf5c28fe8c04f4b13bae4232b753c5b9c56514cd6ea90ff27b05e7339a84e6e89e1f0e74c50f315130e23c3bb2630f788609568c4615859c81fc3ca5c082407239d6df8b563625c8c8c6388aa784c39c453fc830c0950b69bc845d19a37614690b1e4e2043d71e9a5b8dc00263e9cc6904073fd3420f1a020d3fa25821f7399cd36f1d6ebcba0f07e0705ffb06b6e5cb2ca283a2128274bbf7eed72a5a9ce8346d3d26a5db13f5499ae78ae24d84ab5481286c2a35441685263d5d32b3c756a12977791d2f237f1fa84c3decdcc5923c5c1160b2a29494c1043a625cac27c954022345d36b88c05e214366c4d69dd08b5625b1d56afa2d240c8595330b0e56ed34c8d3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
