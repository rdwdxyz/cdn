<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"62027ed0a315dd8b01e1394169d6a406a834b3af028fbcd27545df16a96561716a5ca69da41fcc7dc7ad0005ad63e51ce03a36422867127f6aab86684c806e3f224201fd6606a462be2ec43a76d6eb17b597ac8ffe75258d0ac9de138eb9a43e3216ebe8de301ed881dc0089f1e4b7c2e64473db4a978494fd0ee445745ca34646da6ececce585f06e99a2f3d2d660ceeb5795e27f764f94f983f71a3fccb5b921fbc4337b967157cf5f6bb9a46ff56e26e641f04faa3bd37c021f958727822e469d15e40e5e2354509b17547f2fe621c40ae89eadde31aaaa20be4e880487867ce5b231ce90f18999379f2f02916008dec04ccdf6a903f6d137f231ed5b336df94107d94b41b1dc54f6ef24326e7b7aa654beab1e562c3cca0ab851bb23ad59be0d7e55c889574b2a3e11c03a876cf85335f414ee8f88e18b485daeda9cb8332b4f7dc0ee9adf491a544e7872b63acf98aafea5eb359daeb99ef32297775f19b51b8a6f28086bed5f412ffedfb2925ff56300dc05d2dea4c4379f69612dd7f3b7caf43ab428688935fe872c963e3252598f2a6446b6db2700b6cfc53428eb3503b9e1a07be85288c371609f61a27d0e1ab3c069d64c885adec9470e855dbcd1c86817e875df2399710178453db5abec029099a83ed1fa2f0ff56a85915885920b25840a8f1fa2b4136e598d6d6f09b7f0231ef9533913927134f9b2578b1c3d6dec0a2bd53d55494741baa780daed5a3782779b47cbad920e9f7eb20aa4b49070b71e909cee9ae266d1aa61f66df261a9e7f4f6a9d6c2ce656f586a3a3181dd79bd6e96b2d378c800e7dd0a3c2b7a58ed509d7ab81b86968e9b0f3087da9c100aca1c783d0b778fc2a60043894f9eb7e86d2e69fa983964757942bda8084af30fdf735bc33bb461b12fa2d7a52a319ad8bdc94d72b7ce62a68516830b8d9f22770d2e272477c2373fa06ee7b10a7771de783e6e5a41f3a8ddf849aac1fdab810469437785eb7d81945b567fa82e03bc3c0013148d5dbb77e38dcde95ac732e03bc7a106ebb1915c3881c323d0c2f1eea6b542be9c66b9e9545d2a4aaf367d150021e647830a0f923e9d88a83e567025bcf2cd0f31b7f108f23163a9f4932524c783c928515c50c75aef965d53765b194cb572b70fa870236fe44c488eba86f3349c7950106a0975a5c440d862cb99ebf1f9210aa7a23600a810cf5f086419e9663754a8b45c6f3fc1e5a0a19fdd1e78a2d85f3768dcb116a9a24efc48bdc5edf7d79697e5430dd82b695cbaf284dcd4dbddb7cf8f4c7f96f9f9653d0d1faf85c3a675024a6a27c5015d4cbd7d63025de046b4595abad0f581dc8adcc6970621a3b3b0ac48232295ab7bf0ae99bed9f4376f5bef0374f6f9d4237e6fd0268d96c67db56cdbd6f068d206452f4bd149d52dbc86ad66cd66ae17484235e64666370d52cac398ad1507910c727da72bc213d0d2ac9c17e25fe452eeeccc23e042f141ff78d502e5da87573fba7df43e3614a4a393284a9c5093da58a668dfe8cec157167788a8895462523f4a44dee4737d17b85fa541c81df5646f063ecb5859d6703eacc1d4d8f77bf015b8dabba7334fa125905de4d0356d860de3e0002f7ce251543fd47ddcbd19aa7ed313c1c6cc1d0a5efea4826fd9f5583564aca7677c46e3162941c4f2fccf1bac0af4d6de8701b4bae7dc46e970912e59cc2bb8eb4324e1ef3c9e514c4c841a3df7e437ff34bc92984eaaee85401afc808fa44256185a0832e2ff2a8b5b84d53cc83899df9b3fa3a6c4b80f0a8b9006192b7231ce21e8c9b4052f81b2ba16376ae73423f1e084702411bb4b4f7b1dc3472ceb7829a1e10abc7d9cfb8f4b228f2f7a48bf6442f738b9277ea135da8f430fd2b3f1fbb1a299b38a988e34a1d633c390162fb6823f117f7d64f2e7a940d4d3e5e19820b9c76262ac8c74e4fad5ef761922b736430452ef1241c97e507a795cb29fc40ad20a1c1afa1eb5be2f3d44bd4625e764bd3617804b5ffbae7fa34b5035fc565d858c3ea256b9907cd233dc76dc6c1b2ec8a8d86382881a535a0f43a9260b2944b13e414c2c1443f0e98d0824cf7d5b2cbf2d54c152f0702317767c984fddd5413d6f02c3149c2cd8d0a89c8193a3342ff227478f801a5ebb075039b892c3e8580dcc62fe818ddc1f338ec708695fb34ef6cda82d7daf7a46afcad953496f33b1868a39f1525a1a1e92e0e6d7e0f1f13a4347c1c48b33e5a7efae83a79263d6b58ad3d3718a2acff1b79bfe9b7559e5d99069b0e3e71c83c92ae3ee2805ddebe7201c0f8deb03efa57d6699a4e052e89c0b0e7e0c1ed7ff2656f7dea451fe31731b5d84cd1fbca6d23b641b5f7f06cf52c9c2b77e1d63975534d54dee1da8633cdae5a50453dca494d59020c00bb2ab146e142e320bf81203949dc618b91c57e062ae8f874ba2650c83a96905da27eba1712e0eafaa6e518dcc6a66190db18eaa1f1c6481aef395f9f037fb132a863281896e0e7b67af2338c58c881e68a2fca6cc366186c83b731e1f22bf92ed2d786d39842aa61ce8f1eccbf122ea1e1d8330d72fa588c81f11fcb51fa08529e4e883d9891db83d3e655731d088359d5fe749062c5da5d5e8469920c27e72953ed008e9f79cd66c975298f24638c342a5beb22764aa0d6bed3f631ace6b0b32591439153b37f1770a290be5fc4ecd2d6cc25c1242ddd111ee8ce08ff7bb50ced03bd0bc61ede5091cc2a9dc64531c00844e82eccd2311a5ab0f76bb922de79e4fc5eb0bb258d41db3d5fedb980004c2bb45f504b362df674ebaff7603499f4199e6f82becdd6173737bece035f1e57376d13803652b83261f9566b3352216626cf058f89cd815b526f93abdea5ec64eba70a98cadd7edac6b8cfe3564535adc5533de8356043b05db8b3ada4503634a789a5f00d94f06465dfdec53c55f2212a2dbce4bfabb4793162ee914df0778bc8b295f4304f11fc3bd1f8ef9ad4396813fde04df93607d1e4ba91fd105daa36c1236fdc581d9e8bd69fa7d0445b7589f1a374a17176338e0c15a43267dc32a75fc10c88b50e84dfb0978a89252aecdaf9a3fe957cf38f172be0741d7cd86a54eaf31395ea32cc065a86a7fa7c08b48977d4b387bf79e55847d806c070a92b47ab87c4b08b23a6b12b71641e9fc037e4fbd77c137d83bf505903cd931a9dbe72b7f4ff891458f038bdc6c9214dabd9ce5dea21cc08e3b2bc2ca80b6dadace8adb3eaacf19044b53ab18cbf46162c64aab7bf3e81684fa44f525dae87c042971a6efd1e517000b1c97e7d30b0bdccbf1ae2b36a50940930156d200d6d538125002b06f4e7459ba9baa1dabf195f8ba485594956bb03a01f96bf1a8e96fec1f21c0b03c7f792f8e75e0370dbee18400cdb38253d003b065c62b031eb89cfedcf789901873a4c3b021bdcfb70c97332c327f8ee521db2ba2261517c1c0984e3aac461c8fbafab36b16e051fff1c291fb291534a19d5abc516bc14e70d6167b31f7b81bb7bf5458a9142f03b12feef7c618a18efb5b59fcec7d477fa494dcc28ccc00f6ef96f890e2b6d36a4dc943975441bee1eacfd3d4d0a343e070a8743f18fd686a4070a5879b8d35ef1d24a22f4418d605830d7ee2b327ee1f690c374b9a7f1b88cb7425f25af9ee3799218ede008c6f417a887955ad596b64594873a2249e3ea80840f588fb05e6005a641245716d2cd7303673967a18238371e648ec5d37ea6ccd76d5b402327bc504c81e3db31664f7bd44cb58cd8b5981fb26e9f704070b037af72ff2e710fef02540fb880683b7c26fa789883500b991f201a88dd88dd4c2b7eaff1bca738635193bb87f861f98d4c29e9411f0084ef4ad7f09757491ed6b13c2ca384f169cdab75dd61d5c4036d8d7e834363a166f2c7546f83c21a210577e7652ee55b045abee05301d8414f8ca886583a50347d3c2403406d584e9c7bcd31ce133455930e93a67a310edfc6dd50adf52dc24f324fdb77496c3c8afa4e73a157fee82b98a2c1a71e2f188cc856dbf74c9b33993c3b47ec3f225a9b434cd737d375f6eff55fd2cf5061b84bb8acf583fdbe2355c57d67772f10e4a220323d8bebdb0251542cc0240be9dea4b75aa74527d90bd8e5e575f72e75112ef7898d963a143b8a308f51311e8d104e2575dded7a28b86a0d6239f7a113c3a101f03b2b36ca0bf8a950ccebc563e576a2e66360de801faca19934c1538b56fb0311d2c93746b6fa5ba2467d95e24d4ea1cf48d8d4b3dbdc3f5be75ba625c3d9fbffc1987b645b0cc4cfbb7d34b143ed22f3805131e2c40542a03af13a863624df097a999100a5555dc48f65b8fa2e8dd6536a2cf02e20dc4a6ef81c54bbbef70cebba493d9267f10b51353ce245bc5ff80c9c85270cb786a5de33b61613af7a341519060c8143b3c92e6e24ec1bb29299c51c78dea8fb9cc2a04cfa5b6990d8f379ad1453073948a24e9da6e0d5863737ec2c1e749ff54c0a6878608c33d556cee59976501759029cd368539b85c5ea0dfe0d05f710b859abd3e66da9fcba6800e193c2c988aefc8777c6d139ff0d322ea2bd200fa2d5acd33ee2b4a3ed3c725ef15e42d53e29911c04adcb3e4cac80baedf082d61051e7d5813e0cc7bc62c4163149f99ff21143c7a7e5c70ee849820aea385ed865bcc1623a7da14280858f9ff92befd0014dc64328f642528d5dfedabac6544a425ff29fa59a7eebae0d43dd04ae0ce99ac8927829d66bc7ea44963aa641d0abfe3348f2da9c4064cf283a618cf88977686f24c3216abf76727970da1d58a57c3af94440850b6932a3ca0be85c4eed9cf3fcf89788c99f2a94d34033597f01f54b1bab9a2b6b5eabd756febc6a4a9b7b268d526101fb7801c3eb9b5082f47b9287385be685fc0359f4bbf6ba6ce188e68f847af4bcfdeb5abb3e04744dabb0b8635fbabb6ba2eca6dcad512b0c61fc6fadd136cf4ace6fb62f00e08fe272e1199e0237abf4cf5385f5d261cec68356ebfba2ea9c839c3d8e323127cd34c8e6b1ffc9c0f0c6e7c32cc6187189522e18ff872108a7834f62e578a0237fae96c1d86de57927890969d84030a98de35a1106854b7982c585c15db91977b7d7251675d4d41f755659adf3551468e5fedf5acb9357aad67c7cfff0a7de8fd6989158d86c49ab5404974ac9def299baf35ca0837b1245a0779366037747ecc7fd11a8309538bdf62e26eba26a0b2e24f0c114de8e785801c9fc86ad5c5e81941b1060e529af9a0dd18cfb065431b34a5bbf16667fe2ddcbd061ade898eb8c1e7c8c834cdc53aacb8484ff0953c7930a4c2d9d8ac99610e72d6fd45da820804b518f7dc9b629a106f5bacd4852199fc537d6303ddd0bea353c36ecee308383d39c1247c7b26bee721f20495b6ea42773eadfd1f5142b2c0c35d940e50868fefac5cf7991ea93e282611c9c547d057a09276d1c7dcd0d09f352b66e842c19ef2a928ef596949899140e07422436567ab58ed6cdc175a9d23233d672545411408f9a6339a60f3ca9ab4cb76de6965bef8655ef72cb1ea2b7fbf80eb0c9c318be2c0a8dd7919b79b0fd8970abf7f9451f1c566a7b60fdb6da645170c6d2ea929a44b7378aa2fd32f40424e3b953cea4efe1b7fb0e8fa6c676018f84009244fd4dcbc2075b00d1c07e4b0e3032c8083a48934c7a321aeb5f73638654f9d9e22c3589ca08ead4906393df9aa108ff6a3870c80001bbeac2ac5c9df7f6a3773158d72c90785887949fbc7c1982cff2c07ccab7b1ee322606e77f20dff3ca41022fbb905b67c95841732edb0387e78483108062a244f314b4a458018c9179d4c23b672cb663360544da2a485551b29fa2ddd153aa3493d75d3d7df2b937d0a8ad4a14745e8e85456e677cdc201077afb04c1a4bbf8023b6f76e3075ba7eb09ca82abc08ddbfa9a269229cd6789aea86c1f0107da4270ecb043d8d721f8d506b8386f7babe7f48c327a22c480f56493e471105e833c50e2425b4eee3d214f4bbd94669c55a00fe255e83e2c0a7f97250ebd0ab6759d0bd638e1f6fe897a8cc626ee40e3a344534cc884c5efa21637da383e31fdc7a662a8e1877e744c820e100e6bcafbcd013ae87b994f87c62104d8d9893df39f3b37bde60d2bf359f69f5432778286fcf5353a2c39453b4dd7754d6c72e33b870119c65ec6f539a82f6b16ac3533e774ddd7b0455af8fe4609533790bc6772555542fa9001cd5ef886625637da21dd6d072b9e938b1fe3d5fcc23d3864898337edfe101184b5a55c4b9ba317a7abbbfd095d43d3b5c314cb01dc68dce7503d9c4033180d302b1f3845fdde5ff616d25f34f9fdfb0581aa3a88b7a15d1615258af73f2b0bd97d3891dd5c5b322428366e220cd7e26fca5e16fea23d6862bef0b5b2187e1afe1736a0d14350dfeef8e6b2848246a2b8dc450ce8ebf01c0138d7f3a8392ae8e40fdb930d2257683fb0df197191931727eb30c8ee0a4c6954993f4a26ac60235ccf819f17c9ae779da911cd35046746588337fea38093b178e33fb1393f29ae7d91e235a6446dcd14d49d6198a1f148525b34b09cf89cfa7bd3240c77252a155684606c389e9aca682da084ffc0c65102d34b9485e3c7a6fda35df4abac3a4776f9a33fc1b5ae37fad35e3cc4aac5234b5fa58b6005b36f2381566339e208d37f95767fcb0af10d2cb6c50a16f22386af8540647f13f6fbf4be6193c75a90bf3ce5cf8963bcb73f98a50560e7eaa8280365f29e748b0d62954cb414f7e4a5861b9f982ff02bb83077bcffc88880286054fbbc604a91587909453603ca61ed4b41226402f7f391617fba1fa2c42562fdb36a3e0323f1dc98db1dc1a806643040060a0c67035e7f0d45a1f0a5543b1a041ba6d7c0393f0d91ec761f7a03e0ae21d47ca71e6ce3527c47534b4c8625618a292287bee0b37fd4025aa3b062126abba2c5336c193bcf3f9f6f42be8b11b9ada0071da3202e39acd46732eb932ddc63ba8caa1d7f3265fdb47b5397992a2a16bdb6d9e5af34675ecd8a3705eda475d31879d85b93b43454a60d8305448b1417696646450032a6d79df9e3ae8e1e096547eafb8e2f6ee107fb591e85042a38793e977455d28b13158f41052c1096fd9311a979c0f5c1263fc395aec32a4f68ecfc3f9c02f8560b3d06c6a33d10dea75d2e7824c4d63016d69d01ccbbab612410a9e15332e640b89a4813440d74701e583e05f9a681eb14a8de39d863be2fbd4ce3dd26efba35f3a0b8f2505c1267b7f01b83182bf0ec90c8a23210c2884fdeff9b741eef845fe9e57616067ff5c69830991d4ca86d1c29fcbbf0ca26f4b70f34daa123da9878fa6e72e1a1f4f3dba17acb1991acf6103cffbb834f18a7b7bdbb7a39f4310d432e10a1a6fa01d8d4c98362e1c34e17dbed4775409f5ff563d6204cedab7877793181a052eab7a6a97ece1f82d1a7a8d696a75c7322d8e35433b3382e51291bcb7e07aa00eb70db764231fde893840461848fe1e4601c859bb11bf6d92b9b85eec2bd4ab93f7dc0a2247a57340ed7446e6a334a2a067d4a4a3cb4571325f7fffee818bfc4b2ed66e66f5d03eb35991c710db2ada5e8eef87ce44f679b6a70f8c7eefed140f0e6ad618aba9e7cbab3f1dda25dbed87125f66ab45a79b5926dc206f0c0da98448bc3d9105e5932fa3a18141ed166801757f4622c0c2d0791c7bb4016a9c18698a9c398c7bbf5d7a56fa7d6ec6cc5f52a561a0a394fea73325d5075a9e52834fc1d5055aa184db1673a503fea86eea0f047535eaab166b5d270b62314ecc317e7d18b68ccd3b3c38a14ce8192425813df29d95430d92acde5d28d08cc3893f943778c9e59b2fe1f41ec1925475a0391d9e6bcd0cc87d22e5c3639cef232ea37f1c0e266ef1957efd38baf524cf4274ad28e7035a62b79c83a577192a7b306e30436a5cec06ba73672138767a35e50cf256cbe856b35d7807280ad2daec48d6710c8d9716158f2e8a14c65eeb9b9a73718dc033d717ae6004882f8863d57107ff9a958a30d8ba560efcfd880cead00109754201319c6af3d90e61675a77e87039466ea96dac1dd76f3749c24dcdcba7817feb2c9e932902825b002c866bae74edfc14c85dff93dad0e841a7b43cab8ce12845eacf405309b073d345230f21dc0a2b4f7a5c03a09243242297c6d61b789cc5c8b681128ffd99cd3dad419c88fb60befa18d35242efe3479ee59ad1a69202f64bd67f2885b3966d496cf5b279b72bea8cffa6a5acb8d3c68fed73f938b253e972315bdabffc8e6ba4456f9eb0bae6ef802ec203843acfdd48b10f94613929b8b00c7d615f6f9a9e8eec92bd5cc7bc1f078cef95c6b6073345525cc739758b009327d773c505a49b80b0764f642b9ced85bd447d8130148e13d56af166676e8338c6af83402316f6d2a95395d495110d4e3f4be04f0a569943d65534530ce2964adc67fa63057084c8d7bf28be3153d3094846258bae9a1582f30d0745e63d9d2d936aba83faa3f3bb61deafda999b74087763311c3b8f6f3b86bf7494098a3ff7150fc2af2c1831914b1720b589a56cded3aa363ad25eb4e6164727f7362fbbb264108a005d871b1bc4ada23c4f8a7f7d17e2ce56eb810384c8e7479d272e8fd28710f799b356ba02d8ae38be2c0d1aaa06b625287e51e640b9a1fe94e4384fccd5fc7428dc8cd1274bc7e9f324a6f3899f418a5988dc0908752c9ff04fe1c950ef7562b1b0301a99e2a6871eec620407802367bc6701919eb7bbc1298ce7005c95fe807509b84503de32e12bcf47a8384b786633732af53742485e0ca361c4925d3fd64ce988866bc40e491a0caa12948c3700ed10bf2edda604f9510e509f5c8a03051ebe4b3f861f6ad16c4760bacaf3a0d5749f40400f476a1fe12b67add9409107e92ef1389beb48fb77f091e4bb529b7130a9bfa719a4931ef29c1f6de6925d2433d4e64b164012cc38a5cef242d2376de4e731bccfd225018ab9edbb3d9b208b2ebbbee73822a3181f8b5bc005efe0e93d11c6a5b2ea09cd00de69810a2c96f463aea07306ad755939b8cb89b82fe9b5eb887521b45d5fdc4f85b22725849232a4e761d35b04e9f8a611883bfe0a9fb3c0aef026bcdceb7ffc6707734547b0c30168694300f16768c5212d8d6e0cb58422d93f1e5b77541e32131046831ba90492d1e10dde9fe36e97b67552fd69209df0853db7e1750b0cc3d24c21b98253c649bb9160c8795acf29b8ec6e1608c3d16f5359abafec2c8660eed86eb3d82288a51690cc26dbac96c8e655e6ed80c5cf5d64b6f191fc469340233039beb977d67577e661996c95cb3a7b5b54de248d04e848304d155ae686ab7f5281789a8328d5924518d8d0bffce2ae7fd76b31145ed28e2d87cd8e0800357c1b718b45676db39a60c9736e5bfd4143a2ed182286b13ead83a37da980c8e09d5871ea7e9248565946ee3f5fb94ce2b2d3f932c3f18818c43850e66ab05fba8037bb4943511bb4b8e7369abecf81ca06375ed7f8940cefdde625077e658f44d752e286abe020dad3853a8a6ed1f808642b46ed63e52071a4c8db8207e48c1f3cf90b08d0a4fa293396ed8034cb47e580f30b3d6f49271c27885387934289a5209990ed3dbac6d69137ef3f83b29e1528a7fffd80d61d6b9d07c398f236dd0efb0b521a32a83066bf16703b8c041e172d321f41e3f925cb4a620414fc71a60918f922f6d1ba484958046159398f203ad4b040b4ed6e54c2fa77c747c789b3e64d01550259b908e19b83761cb16e34c2540654f2cc058c16f3ede0066348e7c3c3b1b8687d4c0cda65f439a485f2fa5e912d3f8fbf2e8e98ce8a69cf7e4eb73d501621a1dc7b9866dda78400dfbee31deaddb5f22b5f46a25ab8339ef276c3b21ad3775c6942830b5435a03b1f3fdc8f416fc5daa5ec3ee505ae9aa55f0f66e2b6247c4c12f15d94938e079794e5637219e396aa23bb70f3e0145561ead4390dde1974a72cc8eb2e32b92c1664d707a1533102fc325d7d940690ec2271ea446493aba8e837eb08b1f19d5565f0eb4573142a0e5b7bb7ff2a2b9fc25abfbb6be73a6f59efde2abd55f7c037157cf60dc239270ee5eb3af682be4e67e41b92c45423721af1b902a8e8501771a7eb272c33bdf987c360efe943cd372e9c899d0240e3d28313679d0984f87671a39ff960146f6a092651fcea54d8fae097e422bf6cd1c9751ab8efb04c57bfc50453e6a12e7558571404213872e9574bcead1d0f0cb1e7ed3c8bae3d6e93f67010f3376d9bd413d4979e4a388c9c459932c846a6fbcab0a8724f895039a455ab660344db64144392c516b37ba012762c71a3e0ad7b1878a6fbdeeb19f32484c8e763e13ae5779c0f0cbaae55ede4f5304d4a8a1b63479b8cb4e574b7949c7f4e32dcfdde3701faaeeef9b3843f59e9f7b009603df77640b689d17783a3757805fbd5897dcaef2157dde562311468f0ee434d26938d0ca5ca6c5931eaf2615f380166a11153ea172ac1f1f4d4365ac7a59202b453406c66fdc15cb93b2225989a8674128cdd9460d623b8a699300e480e3000687049031c42dcec7a82981fbc8825687656c698451f16180e5fde0bfd539129bc6aa508e08ee69277b38f498f942d3afd8a7127624813a827213baf55bb0f3c0c27f7eb02fa12728c6ca941ad9600c112863f62b9837c05d01ef4cdccb58e107b4243c84fe6f0fa3cca712fd5c9a4a8b55e721e9e8bd3716f106a02bcfc9ee069efd75ca02a1b06ef45aa99eb5fb2f46452cfd440450427ba66651ce5538a0ae77b565dd72675360e489d34f25da4f798ff8008a4c0e13585837fe8b8844e296866d475c8af9d32a054d0fabb02c8e38676c1d45a9fc202b0b3fc59cd3fe379398cca548d9e7efb3356ddd69e9bba34330935bd974991c15fc06a5b1762edf15b12aee7715bab4b1e2ff5900036d273d70b26a88acca2499a84c4caa0b39538df3ec1f9837c91e8d2acbd863fc4d69bbc1a77de2d91177537a698623b71eecf8c498032c18723f7bd8950fb4c8df7c589078673fbc064d64d2cfcde3ed6400a007bc340bffa898a5183c69dca01c02d303e2061cfca5672f203c83df27cb75b625fd8e7a61b6cfd4d9a442a11fc2e8a01f41899f3e7a0947c130127bde500ce13aa18dcde49617fb1c9a0305ae81d9318f3c60d5d7dbdfe2d336a182000ea866a98a92301a41c3c2a59eb845e5cdfc70c3732026c6d5e1b485aaccab01625c68b69261ebbca2eebc85b3516714c956f75adb1f2347ed991745d662d71fc622adeca10433bbdf10d0dbac9c8d9cd985076359428e26fa9633169d61dd2e90d5e11d6428849fc8ae8eaa9203280eed6edad21b577b079bcb579cc0637208df3fb89f63f2dfaca64dcfbc0928e5533c862603b4586055110eea97420a02db19fab2d2d9e108d81b6bf25ef9ba5832126c0f0f4f55f58890625dc1dbfa68623ae6183310f980c2bbf81b5866b5670561bfd574edd24310a6963550ff0298f530bb29dd5a1218b7f7d5e352b4d5d8ab0b036aaad8d90730d968aee47131a9176c0c1420098fe75d71f97425ff4f082e5ba522857b5640d95e1bdf337032b06811ebc7051228035863f6f89382c004191d6fc7ead7ce6ea7ebb3c317c17d55781c6e83918bb6be695b929b958d9e7a2d3e7d7244f2f3a6b451cf67965d6511981e8248f873213e76f8e72319f3cda13deb25f8cef89d9efb8d64ddd89f4f2e73902aa1ba45c17d5f8d218b54efd205aca039ecbe17a6f18a55cf516567ce3f8247a69ee9c38d2292492ea490c92e16c831f607f1d8e65c377bda002cc9cc5876dcce32220d2761f46289fba6981f2362bbe53332748c3e202dbfbbd4f751e1016f850744f10b9ef5a0d4b457a07df6e3adc87a3d8726cff984f545c3cdf5999688bd87940dbf6d8890380111b279adf8f5443b44387e9f2a5338ec838b543a79298c20bed4f302a0e64c7f293b3e9cf85c6e4305c1ac01af9d13dfc925cb837eeaf7d7322e65b9fce5e535a8ded878dfa1f2c98de2e650e862d0000e0d72328e065e5043d8b0ebd2c36a5f10c8599675beb9afd6f414a00675c5982740bad0f5e81e51b7ac05063349a556eabcd47bbe1d69f9d084e551453aada3c454136e2f91f85a74ee1b4740769b365e2293536386f310f90dfdcc1029376ea441c9c9163360fa083b868e35a9aede7f271540b69089fee7f3bab3d344658bfaf061707d0ffb1918b38407d23e7a84faf5f8ec4356e41e5f8e34f3fbf70fb779b016767e26391e3284da1720d6bfdd893d71731b4f866a49d738446b9aa914a3cebac799eff93b0a1ae249b9bf4012b8976a64f5fdceea7574817146e216dec7f6c4a8c702cb663fb140a580b8e3fcb0d44bf28680df263d2a9b53fcebc46f8e039f80d0e67854d0cd162c7dd2f9f38a09c9c8d826846a4f06fc1bb6676531acb8c75444df26439bd1173f7c3669829be2a3d81370ac855a80c1a919d0d3f107e1d2c7f6ec3ec83ff70b984a7014ed38968810bf9222a994abc235cdaf2a1035d8dbc49d544dab2bd3e9be8213f491814055023f453a54389e54a346edba49f6b720adcf0f76bb137f6bca2931ce71da996e5008c354994b1a43c97036eb3c547699897d2125a2c215257a5d8a0c2ff01d79fe9b7b6569d29ad76bc8203db51ebca59a895f1fc175a5e78351a08963cb84c40becef7d5bbfbc8a34091d5e8019303f220cee6c4e7d577ec12d2cb1d836b2a2c4cccd54131c511202df4f7b2e22736e90319261e673b6bf206f101517f3e16d99ee6bf3394d9f37bee2caf080a6572defc773f79b72c8ac24cbc2bfeb54dc47c72c24dc8dcd7f2d6fe17b91da64953f69bb2914264eec02736cecd77e1098b6b5f1cfc9863f3ae4ca7f8e3560ebd4274c3eedd015fedefa5a849e651e7ca4e4e595ba98474716f4e4b26cf584f1dc34ebafdc9d464e08818f1615e7127f29298dfe66502bfabc2ff5221daafc4bd04e107fa4abccb4a0683afe1e4516e332464ec708d598e505c00df1b41133bb27e1df436e45e414726f389bd692112a55529c9782bceb025eee981262bb6d21de6c37d5b89795aa0959daf1e814bab732f145dc56d75727632213aad37ebbb35b02a9b5f5523ef2c0f7387db4b12d1fe8614b947ef856d2d67bbcac577c754bb85776b215b2d452b81b9bfca06889d3f6cbf89c4894c2c4926a3738d0ac942dae6b4b3692ca3aa0305f0ed3411605e5f5030be0cce29381b0dc92165419e91993f5d482bfc777a1ea56ae5e0dbe7d53e2b7496f8001a952077cca500d18cc731fcfe2ab45df59e6c70fe85345ac000c17b60f81e31aa7aab19644f9db5284cdfb876a3decbb1b7c67ea125e174369863e3fe277a77a991174c3e28e09f7fa096a10b017b822b7b611ae41d64a2856a9ec2c3a30d042fe546fea9aea305432415e6bd1fa60544b637354ec9b29721b13d9e4a12d7e37037068470f3eb9710efa7f8aa1d5587171696c7b3213a6d122a436842ebdaa1956e62710f51587ad6adaa3f28eba28f19e989465726cd6e4f30fcbdb8b5af83fa17fd66be4e6a5c8c1e5bfd8442fc6589251b04c28c7275d1ed86baf2c27551e66a05b8598cb1d448e87daf6481d1591e61926dbe237b4a61fbec67f17bd0172208803605fcb76bf3fb10f4700ffb64bdc34195631561f263ceda9a159bec066ec5344e05a7030b3b5deac0f518f68a2d1574b74bcf76a200d4b67702b960d749473a95d16ec3aca981b3c0baa8305de6d314c9533205c2a270815f51d35c75ba9b9684c898cea8d799beba4a2339e6506f18bd8b86acc9ea584700762ecb2adbcbce0c1d9d38979ee6132a50da81c366abc98873eaa8b1ab957c07676ea04532b50a3cdc365379c46950ec81b71ff47884ffa3219c067073362a4ba7d2dfba72f7ebb9ef0e97f0329e67d0f1fbe802403c6cb68b097d97cbc72d060a46d6be72dcbc7fc5381e1f03a16d4e8241995b0de998add555ef32faa0cbe236759e63c29c80e00f82568b240921490b285330e8901f4e73615c31b19f91e7c365984d9f63d7eaa61f0762c1b4ff570317acf448aab149ad027f41839f5fb5a682130e339e7377ff2aced1091de3459c7eafd3f99a9e9a2ab00ab12619afe5960737d609f68b8c018f7e932c8aa6064ebdf75ef8d4f61b59ff136ec671fa9b984f048e86d0d5e2d10a34ed5997d25e36f3ff0d7bd1e4144c9610b642a041fa0571cd1a0cee75670ac608bf1e988a51f0e370f0ec9a87d85fa4b8e089eb90426ac205f9ef41144fa465b999f4d6f32eca58c9bae1921fb3334fe9b0b791f0e0a729896d2dac3643f40c5f13f85d0f4b6f51dc97b50472fe428b8518f6d83e5a17b2bde6aabab36c8c8d703a7339796139764904eb6603e974ade18792a4eb21550633cb7eb02cfcfca6ee8519df06e7ea9d14ffd250245df6787f057e27410856e16eb2a856a32603b22e995cb9424282aa78bcb2af7297a7a0a3013272011e0eb257d88f5a014cea140a1dc1fc2a4db21430853b7eb50a9153e3d9489f7620f5b4b2bbecf7e6142a5efe582ceb00d491f95d60e81d8e5ec762db88749faa3e72ce0de7f368876f6f6a14828273256b2e4d6dbe7f836375ee83968c316dcb6da215ea5d9061d02f0826f96a50c752b5e08feedb0619ef4f2714e556e487af47f593ca94b9569bfac16c4b7e3c1872d62ba43c17a2f262723eca2e07fd2edf154328cde8114fcfa41d6b4bfa89dbfb87bef4e6f6a34ad7c404c3e4f29fa173b537f1789a45168523ee04728a372b0b53a6cf2cc6e09bc09a9e53b32256525248e24a1a12c017e07a1c967346cea013dac155e35839a6dca3682af40dc4e4ef3924f6daa229ed8fdf321a55e3ee836f53fa423db3a82ef54a065264b292c8513a303e20e4f1ff3a2782c80033b414a5aaea76893d54be034b6854eb2f6bfbbd51e7256d51d45533e7f83fc11ba08d03dd780a5fa2c6853525e67aa555b22950e7d388ebc40e87c27a88aa3546b407ecb1b37a6e0dc46e9df1d642f3a07ff82a3078bd0d2a04d182f171321dfce9a2e8c05a277fc5b13d72f2f02acd09af337e27488a165d4a48ef0480d89cb9be6739ece77ead038064d2b147bd11700883ceea6eb0b56f789fc2c53037e3191b1acc60bce1ae6402044d19a0bdbd1091ae0823092c1becfd95145ac561b20def997df19365d10013d9b26cb3c47dc053afeda1b0dee5739a0f292defdbdd11c7046582c9ee1e38befc40be81378fa9759853960d246da2b7de9c029bad44e759268f2be5eb1bdf686e45f6792de12ea73398dda54f77dfae827326ca0c2600d670d670a1cee5693631de6bafed6ccf1c0269f84da7e95311033d35a899d2f7405b4af9964ba42427d3ae4e0ab7397c33e28d8e8a1dbf2e319e49ba2c9fa9570b5c3364769d64b9f0a7b67c42513b131be1f29bd51b0685beaca63fef920ddff979ae6ca52f58a59435bf130cc72526da7c1f66bed7f8131a175951020e4ecd10bd90c4b469c360007c2b2506c5093ed323504aff6d00348b37f29c672c7486bb582ebcbbc901d271002c0d1972cbe5c514f6176e8da933452e48e2f9939f38eb9a09fa21287897d289666c846d59aa99ef95a72d9b36ebf6ec162e9d801207ed07deb9771f5092434bc79011a8c254cf9052a45a33518537c5a11e86240b53b42d7d4bab90c34f137a456c7a90880ae1a6e04f4f9e935821d8e80be336b5c2f53e4f0bcc8ac57df864ae99156f402ddb5eb50f1f8e869071e7bfc3da980620177672d3feb3a00b853c0189e171ca79955c6cd7983605f778f9692542f51635a25473a43f0b33a14574061c332fba9d32548c2dd01b530b7941883c85aaa5986a9b0c07ebdc2e7956d3d54cfa54bf7c7987f84a13248432db7c7bb37ad2381238b2dbfad4530e874c384cec002a92009689ca436a2d062104d36b09b3184feac4870c21f86e262ae3cc668f0b2a457868ec0c8061d67f640691a10dec9c5268036ad2c5391f921f317f0a5c390213115aae1782a80ed12539eca4fa69c38eb4989318d7a0da2fe6e24e4ffa9ac3d7b2730b9921216d2bd8aaeed9110966758aa3daa9409e1b48d3e2fa6d8aedcfd79faff95ea7d714bb7922b2e8b250dc3ba8fe40a3c24284d19173762147c63175b77f59888ad3e3f5190d7bf633e946638b47e95080c230b129852c7cb11a13464d5f4ceb6d8006184a98d191b25b9890b00106ac366a184adf205842396e85561028f3ce9d1e2bef706f0475ce6ce39b9252d78fbeb2a8605ea82528115cf184c7c47c3c101e01216951971e1c38b9b08dfd1e5897d2c3bf5040bef529e429a964031aa27f195872bb6d279d70dcdfe19f0f8e503b63e46ca41179df1ce053ae94cd6ee80a875f5461d6d7e2f2c0afcb3cfdfec3283b22dd8c424a5435799514ba723636e2cbce8c260bbe1db198c08ec0e742e1107661cbcb825d0ceebcd50d0d85d384f4591aeaf79da3c4c32042c5c68a7226a0c4b43959e23d86fe101d1a63a25f87c4cdd8addaef837d76d0c9f0d70294042698b61559d5c91b1fa58131dffd43bc47c7d22b7fc40afb57607e0a59746b16e2600209b7445941aba05ec7363a05d78a86437a392001e11139f06a5bb1ee76c842bd8bb19f08acd52d15871fdbd4775bc0f4c0a32b0718d377029b2b62c72328df0040412e587d175a495b80b91e05c89db07ddaea7d8573d801bacc2fa16032f6dbd2f95adb5435e3a7df9ced31dce5e5c5ea7ab48171268ba6b9bc5606262cbf43f5f44e10043538475513a3bf618e1ad76018d89223c25311e5bfd5f2d78d2b7280967fb6683dc641dce4f0381f4063d6d3c9a2442d21f51f6657d95101cbb28e2a382658cc3b4c5c7b8ee1b375aa724fb724c65eb57a6a56cc11561da7715ca2b8b952424676ba1bc9984c586eb74c5b7e2a3202407798a4089db8f0b204fdb5fdb1aee71b9a06c99fe04c804fa16329d11649259dd2aa6cd95f90d2abdab72ac6227556ec634cce89188deb84b35ceb7d4ba5321ec9a73dd9462b6a64187d3074b8b7364bc4bac5436f04c68a78648515669a655e572ee344e270bb8f26aeaa866970b1fda04aa02dcb426a0b3effd7c6cd91802f14944a09624b9e39dc634b285ad0ac05765e4ea53552ec4f5e16076db539e24a6836ad914343a3d5348ae032c6595b04bf9855dc73cebe3ae31b3c0bfac57b2b2dc12730f3d0475c7e814ef89e92a1d5b23123771754259731a2ee1bcfc2c320679a7c89e13da1daa306dda755206e0f2167355a2323a30eb67f32ae7386ad7df6ec616d79c49943e7289ba59924aaf39df10c336f0305c64956141aaf1d34e1363a8e5b5659c0dd52307529d7b9ae421d3d0292ce29fd27d83100167a595581d472f01c688ce5e4b8c6217b889ea72df1dfac8e11d10093fd9273c700e401f0ab1f6ecfada44691d6bef86de2dfdf2365711ed0eae22c09278a31af31bd736a9fc349cb8487d7126bc34fbba60c2321f1f186c934ed8c02eef3c8eb70ddbfba1dff718acc16ed0c0f5de1a0628995365fd7cbe9e4880968ab540addd1b466bc7a734292fafc52e473d9de28a5f6e1022834535822b3f1df9a3cba6f10f7b31864d68228139915f690da8034daee54676f0b653817683772ea00c2f1f401c839e8bbdec264a615b1b0d3bbd4d1976b741cb47cf3bdc386eb7d0a48af6a710d388b231a689dc598916b799b34433168c50240c4bef9dc4c962cdb1f0bcc9aa76f12d41c6ff378556fca1c4024747de755dacc2a9b211020d5136f85873c75b21217f273d1d218f89f085c24f5f716b3a5495349bed1df9c505cd05b22f169125fd80c6355045d8971d98532958ab4dc8726137401d693aba0e6d9648772701f2e4c28d7be96a5a983cdcf0183303f5fde29aa2897a2ec3896c0fd74e50bbb66055bfc578a22b349fcb9e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
