<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"45bcda2d9fac455110f486b56e35195eb299222afbd7057ce6aa1459a13c46fb7d7c372460920b66330768980906fa241f616d008b274516691abf288aef4134e12febf4deba5775f9ae9550acbcccd1abbcba34217ec0f1e456820662c723c0ddccb11e42541c4b4e7a727f0dbb4aab9e7dd7c57f87835e9011f3e5902bfa7577c3008c339fe3efc8d83da99fd5f5493b9c2e175c874eaec7cc6881b7d97c0ca4702a2a1504093316ef3f473f4ec02569465e87d5b06c5062a17d19b0f0652ad0328783364c465776ae8981d759c786877bcfc4ae7bb07cbb1c89d4497d2a69ce1cc19a3e2961d6d2476213c7d6cf779353aae37831ae21ccd6d7a0cf10c062aeeda834bf504a130e8ea2df9c5f9a283743e27f1488d74d7e77f39e14245b10d6ce90b702ffc882d1d183edfdc6b0e1057e9f255c4a50a4631c3acff0418ba03c17562aa588bbf5495c3c80bccf2bd90d430e39ec060bc576a7537235ff9bc5704cda45f14b3f6ec1ae9e5a932eec3203560666d89846e1070e903feb5cb0c29515e5b7ac27030a8ca9e1e23dae98a3341258c2e1af774dbb92bb7775287c517d1e4cbe90594958d0e7165020efb666922c16fb9102f82e4ef28f62919abd53c990ebc1583780d054a5c6c67200e0b846cff596afc0ec7d2304734a8ebc4d0b683e8f08f83784b6c57933cf82ddf044e8e012ecd7cea2876cc52b33dccd5b3c784f65998624480c5464451886b6e94d00ecdc611e43e32bea14b62faaafdee1cd783ca1e2853d02cfa0423e0325eb751792de15fe5165970923f1b3a93e9bf25a447c988f00e0f4ad5f28026c789376ad794d7034b5cbbe2b600fb1877813d68b7fe021773ca87967804eb11998501033cc4eeec8e00a08aad7ac704fef26bdb8368c18e0d0053cc813df5f41dfc184acc151e210059c80e1578ce7abc8938c209b2c42cda2e9b2334b26c07c637bc9d8ca1973942d715aaf8590eaf7799f7ee4b3e0f0ab00e9679d2555fb2e69b075c7011a33b126c27f8409c82736cb6dd70b9b2f160e86b96a238a5b9f9d791011fe64a10679630b3734864173a15fb20838a47893f761a1c7882ce008d0aa37ce8eaf08a817e04bb5fb7f23d419e5157daa78587be9891f87089ea82aa9972e743ef1da5cc67077fef89ca9e8cc3e2dc89217617d744b1e543d7083b8295f596287aab9575be3a719fd4948d6ead164a83d3da221f1678a16be1a2f7719188709f5a11ace04cbcf3499259a130e0c74d6856d1cd0b30fd375d802c2698142af9ac978d3418fa8ab6c5c68dffb5fedf07e65d5d419f0857fa902d0e5c69ea1a61c786980f8dcb2569529df693725729b0b61ad59912c57187d707bf06c3425adc28486af471637cd82f64deb40c73e9e148e17b2bcf2f4b2d981fc496789c2c62cb09372ac9680b172685c4e1849003eb167dc0f28cd64101b53d50ab184fd28c543a2f38a2dcb6a78a3888c257a77d768a1f8e68b6401964160748a1aceda6fddd3475ce33dfa84642feafb86827be3932ce6155fce2bdeb8ef358afbcdaefbbf0eb0f750828048414ad0e7bfe4fb4db16c70a8471175d653e3da42a4cd9e5e154a49373de0339ec67e239a610054120b8874a4ff16440ecac7fbc2e8b7394a3c9e08f6d6fb808108171ab79a9902173e46d10c5bf5633d0fc8f363d9b3c9bc38cde7df36eff0026dda0833ee3fc6ca91c616ec5738fb47079099d05ad0cbdce65992e1daa1f25cb75b8e5d1c95e0b33a72f566a133a7046d0a888eea64d4f35ff03492f17f409ad8f06053a36cc636c60147b02927e79409a43251cd1907626b07856e689d8207fdf3668b6c14e22b2ac66a118e1823cf6b7bde479146cf114e90f54bc6fe5c9b9b2743987c3e0b74ac582c11455c2eeb1614055f66eda06e41f426988483d1704c7851047ad2984f14fda174108c58f24d6f6331c89f5b04d90cc01c85187b9d8f74a3d617f78d1dd823dd105604f94aed4275c0e8787b26081277373338b5d69edb40fc2cd54542e5c2f71422ad84838167c26f1d97849e6fb48af1524e4144a4c76f6cc99f7ebf378e7ca1dcaaf137132e86dbf97df832bfea04ca5c58061699e04915a253d635ba0989318ceb1fe1c2e2559788c2269f79144d8eb03a5d59a686451c00774fa6ff5ebec7617f71cfd6b3b475f39e502dc1164f23266f288efde052dcfa864b07ee9a0581f94b72f6f04b4e041a6abe65129feb4a36c5ecc1e15a834fd70beb577a185558c49a6dae27530f642e5127fea1a6f7cd964893417bcf8d3db3b85c6d16c2c5ae0c5b0bc8d58b86dc9b2a7e8c5edc36c2a00ef5e528f5ad3ee762695332eee89fdb4457e54099e546de3d73ed00a0e12e124c5b687da1cf03a9b5f2f9a038dd6729492dc478a0e7ba5fc611f978197c15549246b92a4ea112b9d56893e6d29ae4ecf2eac2680a2f9f602e13e0ca648b8ffb98b6f3f965960d255d9cc6522de1bbae01ceca0d6ae3d713efeaa82e13a301d2da209eb7cd00c85dfa3328abdb4ef144f572fd631fde9962e733f7e7cbde09f208d06be6fe6efd80aad5bb60e31185a50bff97de46c60b2bdf584eb37e37aba1e77f1c1ec14eb70681a021f89c839dbd039a6cc2f0221e31d07ba4b57270f092c27fd3aecf672100d56269a1db9f252e4d429967c6f649a8d32a167fce8da44ac51c30bbcdd7113d87d8fde99ae18964fe4ce3a7d21c0c69b33c9af58ec9c105d33d51a402ce8886985a4816213f9f5d9799402649a236f535af80752bcb099ba1c20c5260810b20d7c4d40813728bff408aa6c75b307e18a26d00732e5b8b9170a307a6fe8b9c69f74f622813fb5f90e4dcc2bd99a6e490172d2447ae5d3080ba65004a614a30f956d5d7f26a29c5ce5569241b1727999d156cdda7a06479081e34f9bb11dbdb7ff65f199a3c7ec83c6d3622fdfbc5a26627d2cd03513cfa1d694d1c08f8784eb297cf9cc6abc4519626491756e2f68814836a487b13004731d26395ae03d59ffd42134b0f8d823e09438f8c07edacde188af1da2bf95d77ab2e67cbf2aba4a440ec03f35447ebca855aee8cf8f69ed26a667b9b74803967d4d9d29a97e65926cc77a1d96bb1dc9818d01d82b1fabf69ec053fc6a5ff05f0fdb29d506ee2468159e77708af042a6ce423cdc3ca3110496928fb971f11f3d386a955ead23957bd1f60311c539421939b87f84943090717644cea96245ccb780d1246f40f6fd2ff27290352119da8ada4b826bb36071d5411d1d97ce2727de88641255d84d1d239868f4d9f63389f9690a520dcde3b763adceece0c0e4a432e2b8ed9a042462e1d3576c68622c78194b7f8268268fca88730cc7c7ab0393ed6df01322fb463c6558b3b45297abc5bc581466b33a04d028e077bb7751a31295a00c494998f97b60549cb0f4da42f748d8e26da6e1e3b94cbdf48b8965e9b54e945dee9f9c1416fbfdfa84217eaae351136804f2676dae83207339c630c18d189713bcb50692a7af87006bcf50d0b0339f70f1439b16faef0c86c53f899583d3ed7defa733334ee55e7001819a8058672348eb1e9a3a469b94c386ca88e60052a5b84e05fca45bda554a6c9679c357e36f81868d256012f41e43f8258e40359d44c4a6adb1156bb58e37557d22f38550b1adfe3482b5c9ea59b73afd44935d30bf201b02d2b8d260dda92de7da1a6bab1f8572020410dadad092f7ba01da55871d810646357bd0a09690da5106dd2ffd158ad5ec6ddf7ef69115b8686650bed9f4cb7229428cd40a7cc02406daac420117b8412b552f508d912c255dc3c1243787bc7829d2c6cb1efb618e236d043f1a75bd73eb684b011837777c6eabb8eea9e72adb33ab7ac05722580425370944ce475b20eed1978c40b6e09df3a5af6964cfc6d86376994b171e45b938a110a9860490cf41ea16195e36790f4104feb4bcce9ae1cea5fc8b31095d3af6a72974648935fcad654364f25499a7e8b57ba4087928fe613ed8d245230a49f6fe4d315ec5c853502e972e7fe92581548b663f90959b3c1c27a079341973e20cba6f567163a6637af0939386740f74209e8297bd72cc338c967913bb45c7e2890a518da30b250886dde082c23baaa9d89f57124b473c9ee1a5447eb0a2ca4dbdffda28a3b92a9cf4928e44e07c4fc5fa07945f589f99ac1943b3e1bfa9c78b10dd15e0bcec9340eacd864f1a69df94f087e377ab27191061d15e050f308679597f345ebee9dc0f0ee03ba862bdce22176a10a29fb2ba1edb21de56b43ce9ac38c554aa8bd3c9747afb7cb1cc12597e5998bbb5c81738b38f3302661ac8698703ded4d43020b3aa59e9a310c48f54c6c95b408ad8a50f1aadfb65fe526557aa6028f947f879d75de440e472469fad7ea6d3af2594caff84755d04a0327f3aab6d6e1d510c395535bf5dd8518ad02f7f8952f4a24e924e5c7db00a91417dbcf8e19bff2d916ade547b9a03f2f86febb0a2c6557b66d2e892118b80c8ee11d2616cf708679d4653c2f1305f4cfc5b09c875a988fa4a6be01de2cd4d8af254226810567286f017d86bf1435e1eac44f677bd8fcdef75abd400dd5fd11dcefaf683d9c4eab2a02cc46c36ffb8d805be6ed696e3fcb7933f9155d23e0f34bcd65abf68a1c5c501c424032792873b073557160553c4edec1d53c0689180ef2217aee45d427dc8b097334702a558d999cb92eb344b28be0c1f9095bdf9a129864b201ee9d840c5bff7a467d617cf50a21c761d07fad5469324bb8440500c8a86c570fdb5a2a92674d360970e3e226d5bb1941baebf33eaa7376582e1f03a73de2f5d1a568271e028eda5f9432e0783d8178184261e17adbfc5ee0789a3af4b4be9aedda3a2a3c8f8252c657f772958e0268349473955cdc69bd4176f1576277c01252517f3a26667873e2f9c9faf9186c836d03db1ea1e68fcca8bb89840f093aa09dac7684997822dd1551ca060796ccef3084d15152ef5721925278ad3598c14756cc14c6aeb5d35659157f0dbf2b761cefa5d2af3f875cafe4282409b10b8c78d36ec65101584995b1970fb7eb77986383f14661174f9916b4c262a0014bd520fb87428e37fc4f6e60a16e4f02d947f5c83c6538c4055ad629bc6ceb740747dd20f21ecf48a5a7f58a8498e71ce706d74792dd6e8521e2a9943d1402cc6df35add520f236443d084152399ebe32ab45176ad77ae50803f1b413be6a19c5175fbf2bb879095733fab1418abdb6546bbe63b5ffae0b1669f96ea4fc90e5603109652e421c37eec796cbd7415b9d398a611329067a5576d42e36d3cb4b20c428cb5925af770f46187676dbfdb7df66e5483a019207eb913d838855d1dd3418bf6226c10639d587f5bcb9b34e4175be979e2a93b74d097714a7009f26c8e857575c7a5172d68f881d51feac7e1662020cad1c930a36a464aac14f7d1014c0a1bdb03a353de9b3c3b4f28b63f594e56dda8c9156e42858d6c6e301620eff8dd03d0ba05901f0188353117c952ad32ada68bf8aabd15c1a81fcf179e3252bc319f33aa0968e82e7f4478ae2e4bd07a1bd3052bf311c13bcdb6a48c8f118376fc95fd7d2346020915db8015b2262ea2d2e899acda6ec307b63ca28a4b016e73a6c3fda1e0fa9678b286ce33925a37feefebb556e527f15b600a75d97dcac1a2e716cb5cc954a46ad9c775a2396727c7da5fa87165b18582d3bbe4c1983e54143515af7424933ef4c8adb190a6a876441405ec0ad51dcdd6a81799f85d9fe0da1f128f297998556e68182fc5672c78bd4136e3c38db91e98ac84002c2a02eb937faf3637ad87fed69fc18dcaffda39eebef99d68c13cb97248bfcdd3196d397ac5b8c41e2c1ffb993ab91bd1eba49f5261c9c836041f4237f59b7448369542fca9f54b4a1fa7ea430c453dc499c79e24a59260e696aa321fe933c79aad9504bc36d85af94a116b41457226d4931a2006c9c553f8080266851e94b2a65216efbad598d35d3b918521bd90a48f8cbbbf38a01579a7ad72f6428f7c3847f1b5b93667d4b53864c83f285dd9087a51a95ff12b26adfa4ff8b60cc6ef21643539cc692cb7d3fb02b6052fa9663b90871a8382755a15125125dea3a517ff4d82bbbc5864bce3fc83d15d91fdef24ac35ff7dec61ff4d865b27e07721e41847d150d3363cc0fbd0689c5645edc298b0073c9bec8de1ab54ec3380a7e732f7d65f1a616139790571ee747062cdf4aab115cfe758611d8aba39c15dadd6a3af7745e17f697aef5f82d088f07b2186a726fac9b7a57e71e8b91453537b0d8d9e901bbf5f922544207535962cd007d7a2874aa4c97fd47560ba867c34542f66b70ea73582296956fde7543895ba062e208320099b138fe09113722f005e9bb232b0eaa59f53b807779a2a86bd7152550ceed328e03b60dee542da4825ab2340f403d8037dda8165bfe8c261b733f325041e3800180b7f366dab5829d5a360444793b9fab27569f1ae43b51a6a48ee54cfd0fec28eea84cfb0af279dd12761cf9163468ccf7772e9d42097cefa23095894e4ec683df343e103ddc86b2affc39bac256165e156bc249627baa545b2c2853ad054a7576416b56fd4d0fa7269bce2f5d29594a3c1ecfbe0e20b3d050b05d98ee493992c972dfa98618f238aa6165f37b9fb2dd2a5cbf8d6108c06c429c3554a0962c84381a367669bce4d94dc4629c682e5b88b02c6a74b092a2c23bda80a686f351057394a6808cae72ebe5a257bc87a6f469be8acebf5b3e44d70b94a41eb4d016651872a7b7b1411ce419f32aa916749b84e84177c9c562390bf9aa6f5908f8524dac4eb5de8cd91af934ccd44c570a8beba89922ae3379dcab736d81982f4b410c0782dc76d9ee3d8d7d95eecc1051f74136ced560cc6c3fb33bd5fa0678bbc3f0685f7c5d266c0720c25607f8aac0fb71c1e0d041b9f12933330e815dabd67c58ce7b0db2262e0c52df79123ce478835f03b438991b0fd27bd516dad37dcd0299a858869a7040fc4a656c64be8e2dbaefda700dc59fc554d9327d9620a20ad5a0ea370cf1b6cdea9c63c3d0df20ba0def17ef29b2c915539b5035d95948f3a384c508703326407c10ff17cc7426d005e7c83dc633c0723dee77327ace6fb89751d2a817a677525f1ee57782f8669865aec3bdc3f24e7733df57fbf8ef7a9157b88696a9a84c13a2c73d03ee66646ead738c04e63f31c4e28a33c4abf1d4d4f78c104dc3455bb695c5ccdc59e3beb37f29fccede1ff97c8269567b4b553bc3ca27f21e60343262ea44fb748f826ebc5012a31d145160a35a11395fa02db7ef0082bec4bbac7a6e231543c1e5589ffd15e46ecdc51a45c26f0f7b905ca7cf3fdfdb50e5cf00813da3f4a2984099a31821ec61aaa30d0a54ba4827e0c7b2217de05419d5a07a07bc39fe804e6582fc751ef6e0fe4ff5217f8dfd0f4e635b25186e94e6eb1296c6ad06424d866dc2b55aed42158c8fe116d409c9ee1b4b2c0edd531c8036c468840618b92a32b9d53dd83bd5dac29cfcf054aef0d79882554085d71058c8e8d45bab458dcf217c7c832d550119b62c5e5443dce1a48d17c9d3618a9cdddba5b778df0a21cb074ef14f85e629485ca63e612c494e072fc8b0b50aa081c8e7b9b2ad4756e6ff8ec16cf45e265686310702e75f70a2a50d77c710d4227eb6856ec729f1e6120bc767ad45300975db0eacad89082560454c3a77a057af3cec790a48a523a56d9db01b487a637b17a46ee41bc5e6bde84778495c0d64f3327e6575f7dbbb677dd96ce8b28ab5a8a9be65cd5de2b75124d72652eb5b34c8dc7dc9349e41d0444e21edec44ab35c999908df56c37cb895e47abfd43cb137ad1eb923e3902dce587b2f26617997b084aaac7b9a461f983455e7d562811394df6f9c6b98fb9cc162464f4159089567ea0c839c6d1ace7e7871d037110cd18888144b4b405b7f7960b955e9de62a90f23f40b7ab0ffdefa767feaf4d93879413eb2fb480e629094a0fd28600de932033d5a68383fc80230cd2c5c76f9b548fc8efc211a64c3ee32e5026c266771dea624531e6ce15358cacd0812ce6c0d9fb5b459d6271c494faf46a80f85662affe9c0ea018afd3bc9359bc016fbe47806a8bfea254bfd1dcd45f52c21802cf48dff435cf2fc30d37b3ef4dfbfd1b1e0317b582dfeb6fd3c25fb4aba1e046ae10d5109d9369a6e34852b8eb35fa5e415990b6d52fd0a6c0bd8ce0e7e3eb4929b573c59515e50c16296caa8a96f5dfaeca19922e9159c1a97663df774c7c76bf3e7273b7e4c6706a9ef5bb4d67ae45048aaee66adacbb67f36e9ad0af043c04b1c484d43f227197993ccc1a7e3666acb703f4ffd4d28fd00102f7d7f96367890188627ed3349cd96d41d6432a513fb469aa2bc80ee48501dcdf8c0e7a9d9efb83072b5175cc7ed2186101a0afe746135936624601ab682741cecd086d7648bc92f885d74143eb58bb757ab5937461b5ca7acea4c22ac3771ae57fd973d2b4cb676a6bb7259ba6c58f3f1acba305062edf28abcf058c4d86a2385dbe3f8153305860820ec18261c3de483da392a04ad0ac2d57f766c5fdb4a8f4d3c145c3cb1d6e0a2ba60a38dac82ca3ef2ea18598314a10331db62920de22102a011af5e2ef563ece6011c29d707d49788bf5684021024d3c9e3c02fe0c8158b3a53c68cab98832649bddfc4d611a43ae3561321b725275fdc7a7f43d50f8b57eeff34e39afc21de1d87ed71e1750337db442b75f3040901d5e0804e762eef079d04e5c524cbc4dac49b370839429d060a90f07d0da2b8869c1cc98b875047105e18ac510c837de17f6f491be5e66e8ecc6221200cf6ae8e690f9b2a12e9c7d43cf7fca434ec934ee5db1b5e8905294093084350f389bf1538ec75f88c1bca132ddea343a942ca77967da1d052bff70c15536c7d472855e93ccb8380642f0a1ee878a92d36d287194b74e8453498715fe76743c9ef7d947bc062f8756cc9bf90b59308784051e1a6377c744f79d541886d045d247341b0872966773e5f63902d9f7dc796c969e2b131a84c001ac738ff663437c94c0ae04de5391eded46598d4654601b1f989dbf568aa8e52b3a88a6cd52ef82f150112b1fab434e0103970cbee76d5c8d4ed8ed270094cfca65e3b3ba0ec4b68b1472d71c554187c0bc979c37401130c5f2979b18f623a23989542974924a5c29fb39b2a4ba4aa7485432348acffc85257fcbc11f2e3435b6d0733014c1f02ef4ac08f0ecf6d52f04a979ee1c8c2cf4f6aed1e0accf2aeae3a7b3f85538f58f6d601e974a0fbb84033ba1108d503a94ba38436204ddb5077586070553babe0f2730e3418b67e0a79db37161b52b1aef23c1cc9611b125cf049a6d9621b50aeda8697b726d885163d164d43ed1e4d2d4301a43d3dade322a6ac96ec717fddf6f7357cfac901681aa7b91e75c4556c6daabf8c6b188037bd129c8616cb0c93aa1bf1bb94f7ddf3157673ae23e69a0f9e8c932a10de3fc6a21e67bb96c12dca0b6a9007c702c44a7b0582b81f2396bd866524dbcf51dc835baf72c91f33bf6dc698873193b8ac7982e6f93d279f42c934d2505569124b8dd86e7c501fbae2b17f2c7d3596237eb076a6655844f8641f9f32699bc7ee5d18a5f673cddb38ca8d4dcbf9a7dfd3416e19ab0a943eaf0f32c81af74b2853ab16eb0f88d65b414fb99894008fa4eceef68f4d0554b8c22e843f035595a9ab2ddaf29f0296ce1841f70a93870683563bedf84b7e1f5ae2348509262c60605b0112afdc8d37bf3f80f80488eea0ea472319d13429fdb40e865f8c731e18ede0d5a4d209c88a7f1b34c6201a95c8e403c85853af0d4c8b51d5a083c060f638160146d2db1696a32beb1bbf0c832e0dba8425feeae68f49b8e261a29f887026257a7162aa385ac84e6f2dbcd42848f913f1043324f06eb19733d826f0d4e2e91432d2c541d60cb64ffe1fd8938f9f3235f9d3f22ac75ecbb40029dc0a3f98af82f58e0ab62f00d64227b6286222d8d5c6f48889aa72e2f5eaca395a79a58ad7962470e7e935b6cad307750d457f4b82a3238fa4068ea8b397ee2b920f5d0c823f17a978c7e8ce799d5230942a3bb40c5176cc44e928ce367cccbe279609359fab82241058b5c9cdf7f6a1d67e4a4524280d21cd3a76c19e3a5fcac765765c1bec15f653430ac38d6657c5ad528664be8b4295a955cec93ed941cc47f852cd4c82397458d4b8805013a979a0421a20217460e17e02a28f8a30a069f7798f85aedbeef331405042432910d3548a385ca0ef1f3e396815c7560aba2afcb2b8edb6cd4e959313b7472a7bbd04de0c0342a93f878f45b2fb28f8957510acd2670710705d5f0258265411804271bc7faaa2e0f39e90078fe260d3bbab9afb1e7b88b8f11d4d0c1b5a8491c3d467e867fbd3b441bc3bb40f9ed66ec6bebc09971877f02a0849e1c1ab044b7dce604bbe0aee8df4772f2ad56edf8ddb0bb0db7416b55c3a5bb177a1550ae5c1a64896257dba8fc01f788fb1e3b08db0b268837874efb327a2e9ca0ea4c330af38bb014667612efe12e116e748fdb65425604caecc0aac8efdd68d8ecee348f603ef5ae2977b70f41741b2e6ae1709146586db34890e451acc1baa7f90007d48d242298a36e3bb2e61b0555c03c9ad51a7a63a947a4ea1dd5602451fe87370320e69d05bbfb1f85bea1b198b26a59e92c91037652406dc5c60359d0d129ad2cbc2b846be72337359771bc7274e2854e629bd600e7086ef749c693333c716dd7af1372d8e719ce9e3c67df63c8f3e99be9489b1bc715d21c5a7e04492ebc35303e4e154544e862ca3efb3eb9354bf2bbfd4afee5c5852602cdd84138d334cbed17a680a8e3c9ed9906fbf40318323be97dbc78ce737359d09b9c0d5e12e69d4597309b7bf4c8ebc7a16309d05236641f92549e6c77c2a1c06fcc071f8347a524e4ceef1a657bfd799bb0afc931d6fba81a36e63e360aab9408914b5fce7aafb316a992a94f5986310242ce6aa33716da34e3000bbb48405fd48896d0ea86c4420d0c590c32cd60d4122f291ceb782309df9800ada10dca59f155374d728a028e8a03aa0ccdcc034d189f487e53b01bc7c6fb06dfca65c707db788b0844598aa69cda0e62f9dcfb4b87acc8f7561d371bb060a4befbbfd1d73d0ac38ad8f932a871491ce144201a9e09513d25a472366e56f289e10740164ee48195edc352f4041acc85b3483a8b819c7d76cab6c46a07f1543a7475a3917809ae372a56e7627bd79331fe73df25151044a8216c386c5187c7f4c3ecb0f9095d057c4958d327ba099e056bb18631d03e27302cc6c4bfe2db484db09ed7b7ee089f44bf93c9da3e29e177ae07d2be13ddd6627c6643285d0a0a21b5bcf1bdc5aafa20993e40f0e548835d22057e4d7006116113d366e3f092a0348742dcbffeefd9f21ba68f56e07468f3490ad9b600c490a7c2f579c8de4c606bdec0ef3e81f868f4cfa8e42b020d36ab7ecf7b7aa3964ab99e835e52bf9748634d46b665c736fb1b7bed7a56fffd4266fbacfc40062b021f084540131b178fa81526d6439c697248104613ad35257b21fd2035e10dd330a31ebec8bda8d925aa700ea8665e3be9423253da92676e04a90e23a0bc0e4ed897465f4fde74bb9dcd3407ff3c0c952794cb4b43f8e3843d208f0b8a69dc12cdc84a15e5f036120e33ed4bc74d39335fb518a41f08210ce9c6f5be7396555b63bcfe1584d95531f53e497e8eaeaafe1f515ba682a93a176e3b30f1caace2b47827b1bcb62eccefd2bb62460cbbc6c33436ecf8a898b85ccaadfea9f4f99c5f3e645fb08013c59e987e3302e88d5263a5299d633152e3abfa3095e05f9d4437f769f70a6dc5dd36bc2eb011de25f04551d8d2d7047dccaac0940c0660374856aee62caa005936026ee433d096344c200a39a5bcc87b59686893a2fddfb8a7d44a48615e8399ab9b782cbf531d765c6d4d644d31bfd06466d463898bd76173b6754ba221e0a1452fdaf97ec9ad0415c1a98d8aebd27d0f965fce387c2787f8f17256ed120864d755f7785acbe1561669cbc37dde8962269d70a59ea794a423cd24680daa3029251480c67670376404e860f022d8aebf11ac3dbad62ab254ad990c0e103f685ba5757ab26d44a52ba521e4f2825c9f37522ac93d9d043618df4354b74dd4ae048456446bd2ed64d2e15a6a0f65416f527613565fe0263d8b178032ab84e002d64b32a7907cd3ea7714ec66e42e53f613bc9ff90dc22c7ded8e9d924798031a3b653d0b579ba06629cd3a288b0f77eb1788921ca2f6eb28c425e17335ffbb5e7e6690f68277a5b941e994f59428eb90d1b177c597fb639391c5b590eef169eb786ca06ebf01fd32a573a37a9fe11610bd31a38f9493f4e794488f4eca2dd009142c599b93892a6e9b7f8525916f866e13147506e0f9a1c8e73adaa422727569dda663ca8f5699d2c2fcdd6a4573319369a62c4dd768a282becd414b7f495a76e4c1e7bfc06ab19ca340b04ae24269154a4fdbedfc9ad7de4d38e77da4a308af94353be679f5e231ea61f8f945556b58b011ffc4884682baa947b5849b5a4555cdb4fb75456adf0b53e1f8874289b844818c5ecd1d9c0836079b7b24a4e882b52249c03cc5bd0f407e3dde1c673d99656072f40a4833237f6fe85430568c3bfc8f99954ea213f167925c8499671b6e6036bf36a089b4df61279169c3d0d2e215190b3a67bda2303fa30620c86af9a16cbed79556770aa2b6299b8ea3eab0c20f7f1c2a4c4fba290877b8584bc9972d4a56a4e30c21dbf2d213153d8564f70cff04e8f7db38c96126f6ec5b1129a515fcf9673b9fb53fd468ee9f899d787deb121c18b7d47f8293dfe01a3bfc00d336b91ab0fad6b45311082e08f14a364ee6264772402ec7c7a76fdc31527be589b59b9ae076259e755b232fde6319ebf3a018c1e5eb6b20c03331dd2c50d1e86ba5b4c3ea47192ab4a60293082fd2e56ae302eb9eb47b4d9f5c3fe2f54bbc2c3c12af74f3b9060d4e1c97344caa6a25acda0aa5a933b2bfa1ac26ff022e285ff0827d3ea36c5b79b89698387269478c8ea513e6ba9bdbbe1656eb757ea1a60d4be029c3e680a3733715a12f444cf325ae1206955757b76b926c4f7da8f74170d4f95833d04591c17bf8220765e64e9e8405ae6d3219e7650cddb2c99ea357fd5f3b0cb8a8cd041c604b568cbcdd5bd9773507fabd86ebf9d7034cabebb61203fbaa1dbcf94c5d88ed461d3c4f45a0d9d7b14eed5aaa8ade575aeb9ba44a9a6d3f5aef56ca6a34c503da16951a3e330a7223727e6652aacbf72eb01f34acee3346995a3c5615b7c3ca202d2358b8235eacb5f43e27ceb725f39669183ef507076199c21759438157a196688291f235a0988227f6fb51df860604bac03e8ef6e9c35de3c0a1416f4384c53239ff6ca1de5f0430055a837189975c9664c65df33e1c02e635f45986c2492e8cfe3ab79f07493798953f9dd36fd11283a83ba0c0a82c178152dbdea6653e215bf6f70be18536f87e1b1ad774f893bf3ccddec7990a0807613e2a783278b9872fadd5ce700e6472dd5b18cc2e9764fe6d54978e7872505ef5b410a548eb9d095396be440580ed84f4c76a5b9469e77259e6b23ac672f285ad438fcb85f301b49ff523bac40e01c32b01a5d1c072657539c087336d6f109ecf0e8b05ed571917acc44267ed49debb46c7f6deb36160a6b3270869cb855dec6378e4f3defd7b0c6ef2a8305a6036c35ea8e621d1bbc58b9a7cf754da5dbb7cc76c7135d787f638191de1849aa74eab8d2d0fc0be41365478c135f6628fb03b2e87271c08340965af63d118061324217d9294c28de5c1b4e32aa567e242bc89f182c4178dc88cb77013463d05c5b06eb7a63886a0195d03938176f66a8392e97fde5886d61635c789fabe3bc8c293c7496eabb230d669d04eba70f237e49107d7b07048e20e6b371afdaffd1f69f7c09420783d29c2be6ef354386dd38beafbc67e005aa5e85a9ded67df6c9590c214a7cec85ad26338e72f79080687c580e4cb23be53ab3e94ed4ca37896697fdc21a3c48652a3452afb10c2ea02ac21a1cee81477296b847e6f4922d6d5cddb582c7cc91b7d28ad7b6f54aa91e650ee793691dbc23b00f2da5574046a755fc7546db66cede2936e57317d9a95b3db6b7be8721145596855f5d132cfdf9829c11a82956973b64f6898b550b5bd016ee992b53dc3e497856bc40379682a29a8c383a231038fbf4f3d582e282c0e937f4b3ea427cbfee64bea22680587426d097fa58271b796e6f0dc0009fa6f418a8cb7be9231dd21185884a625f1150fc0c99c327cc3ff9dd1b23f4336b61cdc90d93bc042a7ac701d23628b304cb53ff22be64db9dc22c370f0ed724a7625a92c329018d011468678b1b3e8b4f97c2a2ae77a8b4502aaf27bde12a2eec2405fd9a4bcab95038723fa914ff21a07582c7589584105edc9655838fbba9389469c3ca8fc16c2efaf3f142a12fd3281f148452c70aa4e1793f3b2c36adab3cf73cce7bbffae0d2fc8feaf68daf4f149f1b3a070ef41edc1ee37d5849c20563d213160ee054dfd274859b37366c9f4ccb26d63e140118fa33f2e85825fc6ebcba821833c5abb13195952e3a6c25dc2bd88031cf9448970a36f56f81d264367b105b849ce3ded77039acfa109ed48c168ee9592bb6c07ee72b4946dec5a5c737ca61e7f4e39d53418256b8abe0fb7aff1b4f0ac48823f95c10007c919cf3bbad1a57ff64655e7323c7b4400ad305ef8f41777d6d6d8c7d97d1ef35e01040cf3a0ba3805780aaeaf5f08a41ea31df9bb092fff7334d9d6683fd4c45e28b9f7687d694c889e0a1a2aa5e84ec7673eb4ac0b667f10c12bfdeead4ff4a95ffdf5be1c78bb40b74863eb6821fc0c46c870b5ecce2370769f3f3b1483b15005a577ba5c761555799872b7107f36461b9b1df5ef6dcf150d6df40d72d3c49a1ad72909278371e919932f668671273568d27a3e54eb70623f059bb62c501735760cc2a14665a72f1269dbfa57f8698de51dc319c8bc965db3b332a4cef2f1c7e1258fa1b229a352c80df7138d5a12a418562a14c26c9284cc81e6c4fac1936cacc6d138d37d57face624a1dc20c84ab0791b00589bd6f1fe9267fdf90f3e51cf5dd089c772d875189f75c89c1d5e296bd929c1432177c98d490fd5ca776cd5a33e66df50c436acb62966e636ef5237c38131c14cf60b4d48077ad5fbc8d8dd94d776c7623f0cd4bfc97947f564843781c0891365f2a9c26a281427eb51dcee49554475f1c4cc6fe21479a3b7bd091e54945f40458183dfd4e0060db88525e3f4bdcaa63ddc18bdd8d3bd22e4024a1a417ae23ebef6e81e9c16b8dfd91ac0916aa2cebbb6ec1f1577420bb577148b505d183d761d96cf746411877e79246be1c299b3da061768ad993219f46ac098a27a27a9070fb1e579cdbcadc4466f4307a2d872b37ef600c2711e04a4d2f0e1891827923aad41e5e6a9d13d6f9a8f115be1019e2a9c682613adfa0069ce7c06720984e16a3797c897d5221e114f80b61afa527ea4a8487957478aaa4d7a4351820e4ec204374d03afc329d55c3472023cb76ef046bde8a37fdf586576a9fb458aaeffaeb42571ea2f46ebce6eba32c741ab535b35119e6027c45dd964d070c337a5d4b6b1b9d52f8d9040bd52659269cdd6352e1e95087f49024824479e1e7610bc4ba9df4544439ed82e32a3ea67500ff9a1bf35e6547200fe5eb5db39d4414a425385d1168b1361bc6aa92d0ba3762b2a29c6370fec26894e5c450fbe7143d20babe4f0c3c2150207f74c0030d3d871e92123891abe1cfdd2270bd5290ec3a33f1de0262fdba422ac3bc7838ea5318e8108f64dbcb16b0670acb8b58f3a7c650346a0883340911da28bb994d039689a5ffc882977212526cdce2432ea84c3fa7253273d6448a0e9f5d8587b48edd6e607ad860a9b43abb7139870917ca252b1ed378102694abdea015fb0a9c3f347502fb7f3531e578db0803cdffd433a8c63498c415ba6970fa48bfb7b620e9bbcfdd00f8082f801ed58d7e791ace0d7d3ca9008c522e12f98cbc5298b22c683880a839c637236ce9f763fd485f52073857524d45cf02d16beed02302c7a7d0efe2d409d069b9a98a3087e688cb4e3f5383a9a61829780a5a5acf2fdb992556e30ac382d930fbe730bf440b620e65527797f8a8113c076f20b6769bf6e7336d8cf06985fd9da58b5dba8dcfb463cdbcc9bab611b4b3a8946f4cd0c0533fa01e0dbbfacca5100d4d785581834c3638b7cbe07dcb1637f066b5ff945a0254cd9445bb9edf8b956f1a63ec8cc729c905a488fdd289134a21f21c42a1eddae4eaf599366401d804126fc2eaea120b7432de13a4459c03c2c9167e5bfd23118aa2a682ace5d4c4589eeef0ace5e4fb985c23a99c3d8acbaaf36f48384455742e0caedda2cf00f6e818b34ade4b0524c5386b203ba9692ac72874d0afcadb766a4af8aa4268f10aa9bd31a09f653cc3f8abdd6d85fc01969f6b3c89142fd9c2b1990aeb9b510e36f96802454e6bce9e356a51a7247340b86c556a2f3d59b876999e82335d38b0755982cf00b83b57f6b4af7e106ef1727f8ae4e57c4a74ec459ecc3203514b13fb58613c977a50a71394a75c84a07af54f677bfb635d7f33595ab43b8691c4deb9fb5ed65df5fb9e3bddfe839c382a2e73374780e3aa9fdcceb0a11d796c6cb7d23167290e03ed39aef7f26026b4ea169067d2fa0b576fc14fc6181dd0466c633f52ed329b160ea0d33bd0e52f9265d97f849924269fc00c0e0aa2f0394a788bf222f6c497e07d406f5cb12429976386a30ad8e21debc6d1848c171de8765e6b1f89dd67577ffe22c4cd7cd7c414eb4825fe2e277333bd82053c641e2e951c758bdf7d1a38656f721d35188d419beb1e32372766776bdcc9809201146f4b2a8c36a66ac754bd0a5ad81b00b5ec4a34a89a39945c4c5648fbfdacba7b55a8d8b34cade1bec1f60e2d6c877f69ff88751c30c8244234292802be864ce1f450cf975e5185b67915c0c4741ce17b72440b24b81d2ab91ed3caf637f89c9ff31c76672d95b54d3e4aab4d2cfd25984994b9c5ce7e08f376cd4b8ca90cb779ff247e4387443ce08cc8650037b0d219cdee770d2f57e641ede2b262e444af1043daec82312f4c5c0d19de92d597fa6b4b9b3b2a0035571ad53195a03b9c0e339751e32862dd4bbc3a40d2aa3ec510d1e27f1a34e692b97e76c35c92336da816ce7e38539ae182bb11052f02cef13fe949ca5c81012605a44972a95880798d399163c77d448f7c872e17d7a5c0e80aee39f59fbdd2d9b6f336f2f85b95e2233b9dd66cb6ae5f039621f0b7dee4552a8e22cae2778045a6562a59862be73577ea5c4a6ec4d4414c44a09d58ecf68f8d085c9cf24dcc6dad590d5da12f3fa5a8fbdcfbf5623afddaabbd6c9b3ac6989869bbf12f59ad8df2374d42c63b9fa3eb1968111b2148b3bdca2789192dcccd40c16db5d4cf63ed56d2b0c2efcf45c6031638a78e8ae477ef66397e842ca0cdf78364e168177b4eccfb9b64de10d7d387aeef0c1f224d55579f2880dabb5e1792a77f0c8727c466d4d7bc431300d1efc00729dfd11e7c4aa9998b97a8e8fbfd7c1a0f74a6b5a370b6405a6c31f136335d0c7316d86d652022b9f2852314ea66b654db39dd43d18e53610fdfcf2b6475715738ebea591adfd5b59e75d396b52e44f6a91a3d921f3d19318123c21c298b4fc5491aad727bc042152e4338dd37e51ca3df431fe50ab0ba49382ed55d831b7fcc8507d857bc1140ef2f98247072883c8ae287d74d5829e6f2897efc81217eb348546dfda6dc9147dbe78dff4b9821bcf2934eb3332d0b8fe8c6ba231abb23c6e92fed43e9598a4eed7b200d5589c0e8821a93a6812055","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
