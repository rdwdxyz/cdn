<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4a41a17c117cf3ef1942eb389ff10929072925abcd1de9ea211ef3c437a397ce47bab8d53325e8225fc4f3e2266eab77976d2f50a67b9debcb885da776b37b28bc8740e5101ec48ff8626447a3b0946dafb2005692e5274eeea358bdc080e22e59b7fac4e40b2b368326a25900fee38eea8c638caf173e337c52ebf37052f52c509a35ae7a6c3200ee95d381a9cf72c465df3029867808c42facbece0821a0f9cb4c99b87d2ea1c44f7b5702023287055ade411394d26c05c49c945d9d4c26ce362042c6879198e5ad1e0e0ba3b69ba80704e168336b3eed4d599c08b3f256a533d524765370a642ef347d28f96047116e234ce811fd22ed76868a1c3c32882c5bc663b78a6dc0fe1f5ded63a29438cf031bd3fe44e34c003f7b384870e7ac51cf1b316a3262292bb748f3b247ad7422fb4eeaa00d0851bb0f2236ab88a0e421faa2affde51ea30eb1bc70331f435f614e568def09711f22937f0b13a8fc96dca0a200bd83eab4b3ff17d636596d183aa639fa2edd515c6b64fdaa2edbdafb385ed106c9ec769ba0ae7714e8b3ca935a8af8b1e33c893d6abb65dfb10c567e16e5fe4b321903abe0105977169f75399952d7f7d595feb70ccdc210dc3f21a854a9bdd7f3c76093fa7221ebff79d0b503b673743b13a8dd8324f02240fb4702d3a055f3e6ee24305ef41054a9bd6c83d1dc77f139850fccf5e014edc70c2275c736e379205105979bb683370f8644f7fed4aacd48ea38cf2821ed3160e33ba756a6a6b43421388cf27ee7ed0044f5ac4cd8f53ef146fdf22801a63449c6ee310d3bfee564796e6c6599387bc79a631b4dfe285ba4c02617ebeb998f05a040359e7204defedccb9fc1f01f034660d689b9fe8b0e8e00ecdfb816aa4a6ae59723c98a06c15cdf4f7b1701e165df5043aea0f7d5f1732e354c78145dbc4da55ee7a11e9c23ca0d957cca1b6b37e995d10cd4200e6d7f4ca4d98f2b6d5459e656ec78f6fce1cc37305da5488ca9703c4a189f5ac0639dbac28a26a5fc58a1ee3d3c1a6cd483fffe9006b6b3cd215b94d12cb9aa46bcabb23651fe9c48c9f9c5d6e47068e47ff31d79201e9335c5667c719ffb7d499101ae406b63815da3385a9b7010402918a5ed102bfd62e5d299cc86783834a137009b6bbc085d5ee2bb26b7d2d14c5cb3ef1f0257ad29aa1771afad38775233861d36f155cd849acfb496dc93cfcc5f540b469a7fc6bae5fb4f4f5198de100e7d2854acd0982357a8d035ef36d6141edc1820305519e819c1cb372be7610846862df1b90b2c0f6b69ca7abd62ad206a25c4b483cffec789f5298c56f0fb019ceedc20840d4c8c5c4509d19239d2b98fecdfe17703afd099aacaef01e60dfec512da59e3ecd64f63eb8052cdf90760ea264acae0adb437d0c4b624c1071b626022727112249457d7bef5ff3fce9e08e2d9082005173e9e168bdc0e64ab6aac78515ad977dfa5c7c6373c01142de5b0b99aebd6d217f0b26b84b8de25362ab9c5ffe1ee92a064959125df13a4c9c36d44ce38cb0fd1ad0a3346c60f910e554f92ed9102361770f67502d1742ff1bef3b8fa706fd176bf334b58dc96b8ef0bbad7aa393ae143e46ff4a7edef639e752f9633a801ab37587f6d867036028e00608c9327c8ce0fa0c3456d584a3afa6f7ac629ef574e34b58aa05ff866db75e7d611da482d507835332b228843839dce64630ec41fc89c7794298534436d9a384b2acaa27ba41f1045d8e6de8979f5e27c0ee2e826686dbd05f68aa750ecbc6b03f041a5b7bea88c1e54580e5317758d51eeefac90ef268babe232abf9612720b33889f02e94d30fba205e9b99872d6e2dd74df3672d9956d219cbe539c257411e4520170a182031a1abed40b44424386b1749dda5846fc981f1ca5e872444b9c750059a7a33a4c1fb8a2c07f7aaa563e1019e253cdbd7f1167a0288d4f1b87765206f409faa7982f64e1c50752722dd70f8f08dcaf9b23bd7241fd5adac9424d45e33ee556abb32eeb9a7a7086ffeab73711725ae3658e5a4a46263e4bebe0d84f832a3a8bcf84dc09244d5599230da5ea3597345e8815e3fa59a177f59a4f13d398be8b9b07cb1082acd24466e18f1ca7025062fdac039783be606210a60c83b529e2a918928d8cbaa4c1f4fd689f14eaa2710bc53c63fd0da003cb53d976eae80242f0b6c65f0d7a160d9c4beec4fea4378415ab2cc2325e5773c05a044aa38c0e5e7dd27a2d61413906d4d660a83e82721a2148c235eb71f10597f62a01cb041d5779eca5ec9b9386e6015edcfb9abfa504e9ed75f976d8d30e92a1573126a9cebfcb5d11f417b70d7e01e36b76ae1472c0a520238781fcaca5ab552b0614d110c39a0f46089776f6f5f103ce8101afe17f15a119cbb4d7ea28a7df0710cd7331098e324314511d7a914f21aba3e5007a33b731a3c19f57405e1b7d542c962a910174a9b3f0baf5279581030bb75eb4d834e2ea11dbc222a05321d53018e7ca317b643aa5f20c2b5c861d4911a5934d625f4ccd6b46a19f9493794dee5ccfcf3e6d88865fddcb45ceda70bdf9fa60508ce47e2d1b846b5d674daf70c702a816d89512d3efed72866b3febbcdfba3c515091111449abe7ceb491a07a798920c90ad8332446d91c042e016fbaa1f075c5f18cbb5a6008fe4c2f93f3234b7b36d42c9cf69187b94c527d1125b5289d641988f2b9702fdd57138b23ccc77b89777dfc2bae6507310e61ccb8ca5c8d80946df3ab23ab2ef85373850d663a5cfba7b4257d44357b32e958e6aea6d16f5d2936759e8556a1f83ed4fa2145b0bf125d1d8c32f36759ee617fff6fa099c58901b9d03ea4ae56dbdbaa7e79190987feb454949ffd07e31237889838ef8f83b8564160094d5c0af078088431ab96861f60cb4b8892ca3eadf3ff090c96ccbd2fee69eae837ec4257d9c0b1f3b7588b11b4aa7005ba06d6f628953316b6ed6579ec2a6bc1699911c02c185d7b06d264d14e80c1b3a72321a7398a47d036e4a9897a7fd642984c322ed4f27954eb9e842f4aec868bbc284e7c2c149881182c2c185c844edc1fb8e94ca679b8aacccd48effdd860b5350555bf3a2a39b5d5cc4f8e6004909904823f64747de77f45eeda3ebdf9688d4bef639668d368ed07b9386d7ba1c8cf5e77383932db8c9679935605f67e79f31660fb68bf4b0ef92f09e0ab9b490cd8454aaf196978c212efa7b9517bd2c2e1ebf3fa0d5d471694f824683557ed3e8dc03993166232ef9d341c76b003aef980ac17968d1d91ca68f3b6b06a239b79d76246db191dc7a9c0c0b5fe3b1264ada1e6aff8a8893f8de7b17253887f81858f4ae282baafbcde811389135e503062656bc8e6348292818f7fb0ebd0a62aa3b3d9d716d06418f04b5509863ac96e8aa22934761d81411d9262f3922715fb5de2d75ad5bc2972c41aa489c523a399d84d63177099487a90f3b1d47ad7198b9b4e8838344173fa4dbc41cfa9a9e6548483853e1d11ee6393fb15f6cf815423514a51fa635f1c8bd53bea9bb4c78cf56ed7e464912567ab86b385f87216a38b2498f9a609c557b9715b21ae41866381a85a59404c0d5e8e3f5e90d4b7cb93526efdd1c0496c1ae35c146315b02efd02e2d9b00ab9ee3edc121825a0e13c36fa79b79ac1a864935dc8d7f51040a8fd82b770278fdfd650660c83033399c1f0ca3a4010ccbec0bc902d897bf42f93b6c57502d12244aa8beaeeb66eeade643bcb207d55f916dcce1b2a1c7105e8bf94e26f43fb01feccd67fc39bf60730db24f287fd62ed55a73adc0cfde82f667d7d7de256adb0956e7b72cac9beb4124d85f83300872204cd3c7207d0c3a35eaa3eb6b5affd556567c405832e1014483d13024347e127d92853759a47f1e5f2d4de6b72a2d5e64b433b81f9a08a0a983be0c90b4a0ded55954a1f2e588e6694a6392bc2b85c70c365f3e16d96b7e4471cc20cecbd34acbb8b69c130fefe1f0ec339eaf4a96d34cc61da588fe908d4ee9d3d3030171b72c60ef3a7a84b54bbbe0a27491e67d347970133c0f06c122c13486962bbed5f902a6873fbb44dc5812741c695bf7c9a65b8974e77077656ce96c3c9d4e9d28355712e60c8e0bbf2f9aa78b0edc94ac5d5371511a5ef0582800fb7e83277b90189072bb5f4801cadb90fe8f2fbcaa44b924dfcf3c508c78a496842c20e7125dcbc8b15657d8dc5da330c72e042ad287f6ea3c756b98888639b79d9abf2538b728b069e635e6fe737830348de45eefd6c3c93b321523b1adf2d55a42f0074e540ece9318c04633e9498a8bf909d53641ddc40d0f2d477bd473d140a5efc2871cf91ce5efad20efe051052efc58930506f55685dfbc4b78675ffae05ab032a6c429ec81d9dded911affd2341a6560a5157c660095dc730c69711489219e0e910461ac88d7e0cd846c630d918e09f597a36d4e7803d64b39c18b1664a8dbaa95469d7cbac7238304340bbf201f623f9449fa6847ef607334528aa9fd55cf54f5dcec3bc38a50146935449424b59871b0c47018441fa5f9676a80e0275f55b8cc297aac484eb6958d8d71430dc4c02cb8c16d1d6217cb56eeb60c73542e29accf078294a494db566c44233168b5107a778280aa0b75aa662b8dc4ef87469fd0b6c24d9a1b2ed475f3c1f39969b56ce140f0edbaa8a6d00af4a5cf1c6e475ea34d1f24b570419552644fa4e623cdc79f8dac353feddeed35c801047dae4d3f91306c9fe96ada88b9506b7eba4b153f4b352ddd1ae8cb3e7edaef52e2b78d30379cd808331bbaed96321f0f8f8dd487f9efbb64227e7a907a9ca7174982cbe244268f120314a9068572762842eb8eaa7c47cc225a5d197fc8e860ffb4c89860f7d88947c05be33fb60ee3f2be779768bf134d2ff93b49a68fb5ab8c1b45e83244824ee88c44ae3b7c99b4afa87d2d43feeb823446ffcc89fe4e48dd1d623940a5b68853c2bf05fd59dd3527c09b83c33f06c972b3f9063d8350882362cae7ba99a7cda1ce3c419a1074faf7397d9ce50dcad0822cbf020ee9791ec0907cdfec5ef309a866768d8d99158a771df0e9dd1d1ac02632d225cbdedbe149a62cbd4cdf1ce9d58f0445ee54b5272c397e998841235d083f5b2c1daa3bb9d4bead4f8c63657db4eabd1a6374c11be65972de08fdf7e9558540bf761c2ae5d3e5a4e5faba85c72a348360f7591cc3de755d108a443de8d4abcc4c6a682d5ae1e65d26722478cd876ce69f516e18613c4ebab8dc40c664b48919e5a4aa9ce5e9e0342c78a687838b11f74361b174d35e510fad618b67a04d8576f5c2a1fe8169a0f0c4c24e932e32b0f4b580ae6dd3a49c8c6ccf4cc9acdca6ff214335356e80024b321f0009bb96ec8479890fdd90f2f53982e9be1a29c9e279bf7a018609fd5d8751c1217c599518ae08416c900ee8bba4dbf69cc9fcde9709d1a46dc60b20f7501b127e69006845fad52c2b92b8d03c640c5def4b4183bc1fd9f42c788e664a500d2c11e29515832aeca8bc1b94e61d69ac6a45189002a3fc87d459a96c6faf981ed2e11fe68c3b2970f41496b31ceadd0bf77d9cbf5b8ca2c61d44cf1f4650dfcb86d5f4367d8b5df55a948ecfbe2ac82f4806f93764b4cd7c70148cd6344cd4872478297f9734e2b2dfc92b959bad55adbd60d1b45d43371f68e8c51b8c9505e000a3192d81d4bad6b9e367899ad6ed85b1552a5070357455c460e9c5dab9d1f7ccc107546ab4afd0c6b780d438d1f4572af98fe152528b3f68a23d2f20140dad349f6dee135756ecca8552d72782c2344ee20b25ca91d54302a6bcdf9b42ec164ed4634c880ba31aab0142895552e1c87a3756d6a741be5fe5ab349dafb270fc2d38c064a58f1520af38d9ecb10a719945add9c7e6cd1ee5f8aef572bd277d130216f46ec2faa3cc86ebc749f33db6e91021371ebf359517cc795f0e46ac5adf48f1f36d8b32d80a00583140795a4c8a73c57d170ec082610499e15f7b29a229ad024014b25ffeb212e1b9beeacd68241c2be40f3b24255601de4d2b27d9725624ecaa18ca532e3470264b81606a84d2f02641c9827915f155f2ab2e323843b738f603e0b3566e8064b8739672614eb71adccb135084e3371da160d9c93f994be4c94237cb7574c75be4d20819b977b4ae5f6290ee6c9334d78977cf85348c06637a7fbf06008d08aa49a01f493f12cc19086dcd15b8161f4ac78e25928e97c5c2cd291ba961da7b921e39c50ab5be245be25a7c982bc10bb127efa484f46290d018f73ed0b74d344edd96d80aaffbf880fb3c454dba4083e07c9bbba719a2fdaeb7df88a613f8e8b0b02516655bed99b15316835153dfd7cd0368c1bdd93e7a2f373ac1f78e71bca38fec57d058cbf29602b81150cc1fe84f20c3867195ec69208889de31b61a422b91ec59341b7730af50a0eade4a01f091ef36f82bda0c21c63704f57afd29d774f5864916aeeedd2b3f4a2cef2ba971b489fc835bd4393ead0c118564ecd4ad68ff515b296912424e4344e4561f0b441481a967ed9aa265c0796e4f02b89ca1cdbeaf0e5def6e901510502410d4726083fdfdde4dcf9ea85d70f561e5fd40ff9193387a53c1861a8b6e809e76d8192e298322fd84ed362df7e5f66a5a4b2785d7dcdf00c00785c44efb04d462d9bb9513551922f2945ca5bd582cf2efb051bd28c39c01a41d51feecbcb5dd636cd6eeb55b9f424d14c8a2b09de130ea6237e12b27b9c1d457c712ebf1bab56b8238a5e6e8e514e0d96cf138ed9f91caa20e6cf4efa6fe62d6a618a9a3736a713e8c89759cbb077f246f497499aec9c6e7d66fab3c81645ae77d65dd00cd9a5973744bfb377d1da8b5251ddc535508bad9d91e92087bac00219a4a0476c3036e0a551e9d0ca55b171574009ff12d03c2f3f9209d9aaeb5626dfbbe0ff76d8f6a5e2b95028f79e84c5347295911f78545eb75e350f5dfe28702bb56b6030f4a4ede8419066e613ac56dea04e0db85a517279c305ae1c620dbc10c52e6eda9f63f92e6876127f8fece9700f0ec631094d9e6de25842fe3508722a2dfaa2b59f6421d88e6e27667eeea479bd27f3bf5c23236b2d877c51daf3f4feaecba1f6b0b0e7fe6a00ee4e860db65fffaabbf36e1e035d4d38c39bde7d0c94e91d0b74adf829b6470930f036b03fe93f51f075f47b46dc0bb5465d3391d5453f6134f9b96aa81928736abbd8630fdbc2312f83293cf137f6b5ad53dc90538ad9f99ee3aa5462ae5f9db9cc39d4dbba9808ad6886676808c8737b614c0d71db1c7833f1ae26ae5ac60ad99052e3a202c56334edc1904b4aa1a21da0f8b0224c2925a3ff63190a1f0bb548c50bd862b834ef2677d9bb008c5d54ab0637d0382ae626d3a4d777d343a971fa603905bc9a3bf2f8e3606c2fe02f80348e7598172d09bcfcc5c8438001f64fdf2fbabc122c0120a5a3190d6c38d2fd00c9d3201b327061bad0880457705e95d8412edfc59e8f3d9d9d2e708fe980c33cf8523971d34c909acb46b603a33e75906853e2fb8046d8f64a470712787314e018735469bc102e5a077295b758dabf2183bf3caf1a839e0fd5e4ff4d28e18fcf94c79e3ab9a0300866699d7aad6c46b52dd9f3fd20a7bd203ce20df7a62fc7cf501107608d19d268df749be51c4eaaa276b1faf654d88a43a4f54398e55ad4b880c04648b691d4215aa78f749a97faf24e88c324751d4515b65ac7a6e6c7d99cc988629ea9548b6c8ec06243dc50ebc1187f70c6a79e080dd951960f7da1dcf060a909edd3864361e689b025aa390720b9d15f5777eae3d036802bc40adb9b074223db95d668a1a12c9974414c430e7b8e63b2b979e063bfc76ffe0eb6b2527e94d262106e11cb16acdf7f81fcb60abb2bee94ef92661a6b39d79fce18b69ee2b864526d544d691676cc4502fbdb4343c5f65d1b4ea428426e313ebd1dcb5480a0a1a77a8dc1b5a7e90eacb8c93801c0bc1fd4dec360ce6aca8337895749652c33cd8489a013d0e57d2b36021573476ac69638ba500757da81f28ed0956ba7202c419e57f9d7a724aa41b09de1aab7b670b0c982d49c55711ff3b68fe477e90ea60ec207d6913828d7beb8438ebdee65e072d3d5e0b377b9c010e6adcd9ddf1e82375815caa8288e4b8e8426daba6b25133e32030d24a31219751b020a934d0c953788c7440947fc44ddbec83f0c9f76d56c10103566df6f64bbd17a10869d4f30cc428c495853660d7eeea9c8a27ce2b36e9331429571a8a5ffaa1841fdf559a7202879c7c940dc00d5c2448a153f8941050a205fc58ee62fb8178a4074991226eebf24dfe5c98c7fafaf6cae548e67a3c6f3b88f83718662a787df65ab25670e141b1eed50d115e1fe39643280e4c899fc913e03426503c9a50f57e3a28f3689b3c23eaaeddd38a012879e54fd8f26e4814443974cb3569337ea3b345624afb4a4dff9c593d0bece5e258df73181c74312bbfeac0816a9df6fbd8c9237e8e5c6bb219424af4ab85a66cbc9e8c2a2872b92c71820ec07b87ce1886a2d1a3f91c71658503b6859758749b006195f6909826b1d1c5e4f197d2a1b59929dcbcc963596f132b510ea88d2b2c7c5005029c962c836ee9470bb6c8d5854e80856d1c77de43233467e3e14259c9ba693453d29f8da0b4a0cd3968e70a8d5684a31d8428904a70feae4c2fc75af310614b67d48f23c4c31cfad7bb0b44acc8903fd7e73e3984ea7ebdcfa3c9e89d4ac23d7c4e9d77a678f9de76eef6f1344d8e5f55a47a991e9f01a48e4b1e4d95f30b60880f35cef9a0bc12b499a85f9b012b18a7761287a33f80122eb593659ea4ec62f68446e1fe9cf45a93c658d7b79b0a04db8ab052e0542b8a4e0e852ce2df4877b463759739e9437eb17ed794b77fa60cb7cc10add7938b07415ce0e11f2beb37b5d71e76424f97f49d0cb7caca59fa76ce303db6de9334810cb2af4ee3615b89a6ddaf35f81e71777dc36232024c2bb88ab33ebb4bcfe165274712c06af914ddaf11511277cdcf96dcd935c5d84ced005b8f8d041864fe5d201dd3649b79aa20ad7c314df8bfafa221663e7cb0365e8f28addbdc6b2ed24fe548cff894f6d1d8292833efde0317ba3c105c67f257528e3e7682662eeabe3a286cba530932d2166319d389f6bee13bf97727a06166dbde408a151046bb7ba3a5b1e9b3772063590b7e32edd9853e9e8a296456637c17accc49c26a850782e4106a882f182db10cf5d41394203c9618213250517628fa69ab4ccd9d84981108ce94470c1343634cb1b65f99c40c17f4c3007e969b3786d9275a471d08ff47b719233c19c740806382a7f0a8e5e4ab4657701d215d3a8add80e5752b288e1bfe1817b98b0620b2351d035782aa2a2b3940a5a4ea39ebced224bb3b33fba7aabfec82864912c512933555ad7edd5e6bf14f2979b29a9e3e5d739a3b3d89a050a4d78c58108a842b4598af950e30930059965699f83bfb69a0d1720daad96ef8f65d1d003f53b1e37952f297e9967cbd9598b60fc35f6565b112f136f5bf44c7bf3252cb71527a944f96a8ec4fa0207ec223ca5cbdb3398e3a99901d8b2166818ada1dd706b696dfec9aad97153bce5f69b9f5cd80b57683d00f447a2d92a8800ccaaeb240a984921a6cfd5cd8b01c78ba6354b8ce138814524aff0cab4f62b6d3d2c1eb1f65584230f00e9107d1cad729eb8ccf48364dfaccc2ce5ff768c9d8914c1c660a6d2a62bb89092f8ffc42c2829570c196123383e9179b80cd3e67ced298d583715631782d8dbdcd1556fa5b081bea3da046ffb61eb03703c35bcf6a68dca931d85926f6c3df22ced1e3f50685f49387642fbcf2cd40611d62e3bb1d40667b80f6d040f10688ea4476aeba2cfe2d9dda9ad9b257fd1f1ef42cfbe620f6b9cee98163fab31de348eedf0dae54b413a8ae1c885b48a2bf5e1365c660ebd46054dac501c687b55844be59fef50a97b84d7832dd941a5e9202488885677f9939205c7569fd09328a22f554676c2ebc5e7e8151f145dcb86d3f968ecd60fc6ecf085ace30451aa1165971c57aa462a5e5410bc9b48ff1ae31d7f106ed72d1443f64c1f24ad5afc011f763b5c90b915641d8f70dd6927b2075eed318d73f444933104bd755bfd4d3ad5b1a780608820c109a57f279a10157690a427593a42b8592b09cef7fc707f991302c5888687416258ffdd627738a6ed7ae201ac9b688d9edaa1abc46ecb9c4c934cb7be8815c6ada5aedc51d948a16b8b5d38fe9eb1909777f0e0a9b91d3e12b7add17358e687902ade11bc81faac38d4a294cda16e8b6e4d8a1c0afbff7994292c1626e393081ee5eae1db4e1eebb07b3bdf6ff326f878edd9663f74c3c6496759e669b3c3cbbc9530cb76d9bbaeead4b8e6434fbbd076a3c7bbdab0384d64dbaee477f27f8ceb7cd532d38fc327c39d8c3a06c32b0a844714616211100cde2b8fd2fd90a7b43b970877f708f00c6501d0da9bb94e1f94e5a348012abbe38d8c3c6a91a3d3e7570fed22f0f52f259b33d81b8d522b4058a937b08afcea595b9968e94fd28259d8fca137a602569735e42b86d3fec2892b1d02dc90d09e298fbb8554b8b5fa05024ffab53cece2cf83535ae863538c5d5d4c3276afe16f6bd83e60f5864b27c40293e64cb85a4a3c678ba9e9f7b9df9d32a76124619e245ed3d546c32bde32c8d4c42cc6fb03ac02c86f73a0d539326446a99110456cd4c80fdf121eb166db80b76f818a7ce993a1d371c3e4727f2c4e597b98f435f26e748015b43e802555eb86efa5a818392f20d1df0ae2ab151c7166f8be4ea3b02bd01ce69b51888dc88d92441f44dd2d8d7737fcfd9875abedd47c649f3cba296467d93e2b05c0e7f69c4938ff400c8efadc5091f07967d8cf3c95d0e35e73b209f3a813902ab725d0135f335877126690f84916648bc07aeeddffb88e109e9b3c8fa8dc9e2e58395b6d7788394644a0fde638ce365bc6cd2d4a47942287b5f5edd73b872c39b20bae33e77657757310d62c6e966cb87431e93eebe2161405d49c5a327a4bf2255b36155e3642fc18081b7273004530cefe9c3fd9e856c730dac6f7870c395931167455e96c2003be021a5ea22afc10135da092be1516379ea10895880b579f82f29049ef1ae51075664c3fcb1210e87ecc0ee6326b66b666385ec57f6a281d20fab04a424249af9cac7c7fb1caa9a161cbc4fe4a5ec325c906d4a993c9cd075658d4edeec4b14d48d171eab1a9f410f8049fb7f7466e069af90c4a7ce3d738634a29f50bf963ae1897c00494137bed3905ffe2b46f3a815b0833d7975f28fccae7d9786cd269ad8bd0ef62e8a5202d067fa1fabb3357bead34008804393bd80000d3845540b8bcf2232c3a7fa70282e27277d9cd2a051bb25d3037948f0da54dd6cf41bf9e9afec2a17e643e70c6de9857c80a2d4d862fe34e3b3ce81f475c7d0f59535d9cceb279a2fef0a18777eccadb05b04faf4cf388f01bbb823e1dedd36f97f9a7a67c36d707b8de1950c3c497d8fb911e824c0817211a15ca12a9bf04da0d8841f0f1a0a42c709989d384011a6be2a2078a7c85c659fa201e0adcb9fa7f352b477e581cfe4f171f77fa989f8d9fc92dee803a05b152f5027b958a94295a47bda6c4a59bf011abc9239b88f9c4b5db68af5a888ac4ec7642796169fcccbcc94229ce7172ae4cc0451962bc56a561a0b8c8e55931a554786c65b8a1e72c1b0244a469262e3a57ccfa4759054afc8142697741ed2100b5e2f6b3399220389fc1263064fe0f6db16107a7b3ca9606de13de2aa802bafed12a4dd8f386c506d061b0d086aa0a3f09dabec65746316dc90a770e211447e75e0e07fc941780c1ae0ab1a2f68aaf14687bacdb05967ba9d86cf67f437da004fe8c1a8cd2b2c8e775172082593ea65f9f2aa79f8341b804ed9091bb67fd15dbbf1d04bad8f0ad31d148b3f2f0a10d4091e692273f5d25c5f203025796854e445062330582a39773d93551a83ef55d8f5eedfd7d096337ef918091f83a77a67644aeaa838cb020fe2771fd9c0577f73a76e1549f0d1d0db2a7dff7634ee63034dfeef9ecf8e713bfaef627b6e13401a0e28f2127c3f7d314168aa906ce6c8e4a098b15585fb380dbafd652378cd5edda0cbbda3378828b65b06bcd711288765e28f279afec58f71b32fbe3de38a4d12070520b93ad06233b057fdfdbbc843bfe8ba06c2a322a073c45c9ca56eb135faba47540ac569d17ffa51c26779df4450dbebd2e88647fc39da810ac1e69be4c6c09dba363f155c9c05ba0aa5ca0ff79ba6e4e60860f5ea82a36b4974e116486078e256676479d549c3fa22e851bec75096a1b92bfc09ae1f6b5121d71790c48b577a56e17318f26f83fc9853b2bb702c6f18ffdf9ff3944c12d98992af4ef9a707953d976c19967c48d112fc425ef8af3dae5d4aa3df1fc2d7af202d6cd76b82ff3ec72d68c7435cd85af7ed625ba6eb684fa4384fe239b9ae143259cdaa8441150d7753d68db524cfe91054b6c2f132a495d5b7e8f672c6f38e6a4eb709f4e5f195250b03b3cf62f80a621a9840acc85788281aa5b3503682c05aa498971e5cc0a3f2858d6974ab42714ea7132d9244caa1d02d79984c766323230240634b169b19fd8e885fd498778774df23f0d39cced17d383cad9bf9973e500248abe95e1caa3f32426410a1bdcac71809711d32914de0c792fc298d2e0351e36e72861504a36aff4bfbdab6638c941588e9beee7547dff41a2b4b32b3ab7bb5fec0e8ce781091bda22d7238b3e8c8b0ec6d6d827b405b7e3acb19fd9897a92cc9a277fc2f21b9303dc2be712b10a7661ab3cdc22c38c8898406e591b2833215aeaba4b3486b367d06d579b52df5ad1149218940ff209223ddb24627dfa660daf133a16b41f3572ae77b82483f117647bd6b2ae701efd820fe0dbb4efe4815156f4b4db05d92f172939b514267ed5691a6aba350a519c5bab3d03f8cf995450a53eea9281b1fd35e64d6377b0c51d22d6667b2279343d20c5a358bdca35b20e7bb42af885451396bc5db4456933977c038375e794786c723edf718d8dbe464e1989aea4326e0f6c6febf6c60ceedfae5e1270d285bdeb3a219f1d36c72454bd9a4dfa769421775c5c5d2b03dc6e7cc91a19c4ccad43d9b10ea4b54730d8cdcde2d0c777d2cfa4f939bcb4f12ec9d6c721cd1480ac80b3f1c66453f413463d45918f213aff5dd947435551774b1c6433ebd07686b97a6586fb196b35a87ae5f99673ffd652e77c4252e6d12aad611b0dc7d206d688e330a7c3f67a52fe0a59e34cdd884149df224ce4cb9cb7efd9f423ad842db29525a870c8fc8e68dca990148f1b08efef4fbd8da417566f272e95186bc9f647fccc042ac1ea9b5e4887916f764487cd05e9164827e4867034035e33f1a8669399328b11b52342b456b5b1ddaba6362ff081c698e31a84fec83e95d62c1c1224a6c66a97ad5e22422b149903b5113b75a9d6e7e6061880e61044458fc1e4da0e2d1f6b1cfc3aa6deb834dda2fbe9f40e595f6753c348461d88335a3fa809295d6f5fcac0c80999fc2c491026590fe8119949578cee90ad4930c286785c23727674df975a3a0e24ac6b56a1efadf26104044b71880ef2d74c7c8fe2d0089893a5cdaf94eded27f5e2b23d56dc13760576ec2aa3d2a3582364fcdbb9214e652b8017d7cc9b5b86add3403f94f8b5e8b714f46ac9f084bf348062ba8e73429abe55073e2a297f3b113fc0ab5f594af5d0a656a32d4cf15d58ed2d084813292ef5ef798ab8acec3d530bf9d323987f367315618bf01aeab536333961cd3d2c09bf2e2c499dae3ae7856f898243637b054490d7989319c672cd45018ed2cfd889b9f6752d58d6427d901ec6eee184b4009df0ad15014c27378570ed952f879d332772c36bdaa38bdae17a588556cbc02dfc0b860d0d7720e422aa8c71b278bde092c69e1b5304990752b7684df59040d2221cc21208dc814ace5cfde7bab176d1fd62487088855bb2f6cb7e3ee3d2b70ece7d5c615b1d5179b9e1425c53080246be184657c9b81882792c157e900e183abef2dd5561e245f4bf2c5391c5672af2e83193f7b063bf442a9559b1c4cee5e4401af6079ac23cc8495522f501b873cc10841ad75eb3910bcea199b8524b98ec19e8e627bcc9adaca0285d3830115ed1339a50db09f9d891d09a6433cf4e230e32f851c23f3c0e377957c5b7fd93a39a327e2726800e532aff97006e71afdca19a439d458c24014bf35b5c39a0417df3e8b89a1906ed7688c92728eed9c81f18a58bcce363e54502e0cb27e4d2f058c985fe7c5c8a17cef1bf4d527cc869f730b65967a14aed011b3ac7220cbba3c57202e5121417800532767a1abd49d4abd1f709c05d3a04f4b062351fa4f470464759e559faa652254f58d6fec8723195cb24323ba8782d075c6a101b4874891a09c76b87820c3d80d63f5f71a5980cee42589f44b55f4b970a618c6c80b267579cb4b8d0463f2cd7c3fafeca78b4d884b6fb0cf72d6454cf28ac326d1a4de47deee8e65d2cbd154423e733c7c23470122b530679f07b86ab81c5bf8a37bf9ecd4c654398d18696e6f857c2c8ba44e4f66fe9b7faf09008cd9fb42cd7fac850bf95297a63ac314b542585b4dac439971a45d82f6147f0b66899acc6584d674553dcbb03deb41bbcf0a4aabb0ae30009c85d6aedbbc0611329b0b8a6a2d54d43f8cfdcc22b95056e64213ef1b02b40ee3f2ab0b2c545f801c0448ac6db1393e7b25c2042afbd484b8381aa0b612ccc5ce06ff4837461b3494adf29940ec469ac2bbd73a3bb89733acd21d542d0466295517e14b291db64f2f332fd25da3bdecb2cd28a9729999a734356a1230ceb6d58e1a03b7e4446f75b493e5ad0281a0df5c07f50e7ac6dadd224472e27889d2a1a4eaaa2068b39b558fd1880c14212e9cf1fe0728cf87984dd0c358c3e8d5cf14a94ed6bdf40050e315445229ee132023dc82a82eac45fcb3b44adfca9f83605eeca442bdecf72f4f5a9e41e8441ed1f605f42b533424361097d14d8270aaf73d2fed4718e42364141316cc9953618d358a2221b6ea9d1cf70afbe8f2ebb855d71580622e80429b74ecde16c6b5a9d1f48a9f7d911873622a7ab234f75a996e332470502e54ff780a34aec85d2ec892f155e6fb909092af3cde26f55e3dbe7dfc81e8652c95d4b8c612463a14a7fa1448f10c1ff99982153fb5d2c3647f6107c3917f7646a760fac20e8322f0a82e3d980b19ad89b148368acb3f950ec0338ae94e85bc3af62323c74c1e71d6c96f8e80f4fefd6948fb01d66a7e072e8af2b6906f6dba264d85d45cba8abaed6aba234444078995695f1e60184d8982d686c671de53f96465d140e2bf4dbc832a40042f801f1d620636466d947d73a081e4ae217372c5c985972a1eeedbc95f24c99fc993abca3efcbc7fa4e093d658dd3bd3f70a410b88e4a4c17b17f7316080eceadcc1dd5e4dae40d59dfd000dc70766270c1434f09fe34817292aeb0fabb93c5a0cc1ee7cbe141aa8e668a8193ad3b393ac33a3c7565a67e53f856dc38e7e45b49f7e4bcaca2d32798070e46179942d45b4ad5265e5381e832c0af097e9cd671194177db743ae4f3b0b04e11aa24e08f08f7997e4b2bda2b1355e6c686054589049e26c96917437aa29b927027e06ae91ce302c056fb56ec7580f6cb9985b0aad3de3a1986a113eb2d1c509ad76f5430a56df918eb73276c819d347a80d96db09f0982ea8bf21985711231aa019b9626bdc6109e6c2d6c30d9fedbb737f3241dd6fd248ece67c59cfba9d20166a0b258835055888caf55eb17e957b4ad009ecc0fbe8c57890629fd9a8ec3456fff41c7cdc606bb46c0071491df2d25fa585aa523c30c189ea7f7ff91196759201714babb525b9bd67a0f48905d71cd47c397b2e062ab86ec4300bf4211490aa73ff86d98b9796e6dbce9187af81fdf92d44a9233fc91ed3b9b3b1ec406ea82ff87883c53571fe6f10380485fd96c5d24ea06c54de9e7632a99d1a1c68353caf044c45845e9ec546763861c701caf53d001a4071bbb03cbd7c6040884753527a435f420a6bd1ac2dcbb93d4846ffcc7dad3e20e950c037f1e187cc98c1544df2db71843879b9a320770b7cd2d811309a5a8169a484c1fd79c4ba51c3d19d727e4e9e1e68239a5727d423beb3f2a0f3759711c0afdfcc01d060cdda0403bbf181473dce97d9f7c5416b0247d266387b27f7dda61a609180a5a8a37987b3cc1d08244a786917ac15cd19f2905b0559ec1f11336c60a62cdbcd9314aa8f753de02a12e0cd3ac85f8d87d9b96d6b66a653f1da186d4d9562bc798b885c6dcdd619fad80d65963376f16a03df39ecb67db33b47eea546008412176c513742a1dae72761bb494db568b91d8396de1307955792fbf428e74edf1e3dfb62e9984178e8e55309ebd571d4effda96467a1f8524e18b7dcab02900a36798a99e76adc147ea052453363a5428e2f836b96a9ca53f098953b180010518213c9ff5918e63bba9f6cda95729eb6ee441e2cbd92bed7700bcf5fc21151803803f38cf883456e8670946e6337e6c8e78f17decba4e7953d3b8f26c6b7081acda2423d06e599ae9951f20b5c15dc9656bf0417bcd493c3c46cc3a6ea94133918ef05a95703481045e0d81fa552632f78da6292891c7761e2e417cfb40ba83049ba4d78448bd858636636bfe78892807dba3e9e54a29009501ab766a0523de068ae88a4bc2e99e3ace00438a23733f2228e2088f76d7a6602ce70775d241fd0f6b7b4015fa02323ec7a4092ac66d2f2707edec1038b3fcab8e5e2ef47db10e4e506930961ac28310136d3c63df2dbc35496d930b7630fa5b4b787aaac8996b9b54fa9d22e0945eab7eb3b240c299bba0ac3f9cb6f5b7043a2cdbe362a14fb692acb187f43be1acb5d9fd21c41ba3a74e1f1302555ad298aeb5a295606e4c5724e1d1afff9f4a51585627e1dd40d0e3e10439a0dece635d270c14eb1cee82aa68b9d6c9ca787e6ba8fb56dfd039eaae17693dd2cbf7d2d4201dafb9f5cc0d19ab1b25ee78098fade1e3eb9f5d4992f677f2bdff9ff43abb9bc33d0e7e5eb18557f7e66f2d3c441a663db6d460ff999cabc952eff95eea01a43a41c3c59974001d5de7fef4bb5745a6a11589313e12eb622b8f4fde28d6055649b617022ae192e8d975523edb93c613275ba59f2678f3ab1c90fc5fe466d1aca520cfcdea3804e5a316925e2f5f8910110656b2b6dc1647f9d672b544edc7fac71359aa466cc7a037974ccc815f938d40153183c893ad145c1756f731a047ff226a73574543056895829941c12fe1b4c75e3b1f6c58bac65836139eb6d2ceff0013880f4852801ad4cddf8ea99d49c29a5496666af97fadad151f0b5e37aabd0eda35575c503c584df75f79ffbc48b616c39e978ce79224cafef64b84b833414fff3e7d5e75e261b34ae15d745c39904bec9eea83c0fd11edc0ad75e140bf1a4802d829dd36ce67a01d8d014dab6ae453ff3fa809b13d84690a42207d3e72eac51efbd833b6e8d2ef5877cf860407914f50cfc100af5aba09008193c0a8c7e84a94648b231800cd2b8229bb9db7b526d7cb4c80a5165980f60adaaa40989c52ab962e7e71e223c4b92fecf3649b0734c84ed71cbd57b777248aa854e50d3a52a19a19a0e6fc672104095ce93cd6e07443ca83766c67403563d2a7d86096fc40c247b69dea360604845417deec57e4acc84296a504bd2755f20707643e777635fe0e90afffeb0d978ce29aa77a4b4ebd1d8f1230d5c6379684634256ab8686fde7dc55f19d5380f057bf6026f06f71574ff641e20600dc33049effd69f8b7deec921e05d716f745fa9d7a5d6b64ff630afb603111d84c4c17b0c255177a7e2b6176c16638b2825194aade2aedf5b7120689479caa43c15e18","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
