<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ce72daf177371cb77129aaebccf5aa7211354b4af160bd503e6c10f20f981540c741cc30d8995f79ab31e942f00acea9bcac577d131ee409ac2944ce47603e3fc579d28e69b4da95ed3d6fd2d4e5b034ccbf09d7a4561495dd59d543213497e7279d758fc09a59bd4b8b3f41317f75036d1d3d7b41eb381b04dfefa813021a19a159583f18b5c7868421115727509aec9c58efa04cb80c1e452c35269bbae27c9c3127fa3500b7cfc2a43343e53ae965c26897ee0d095b72b1002012f3a31616be26b56839fff6014e2779fce1909cb034321369256d1719f1dff7b43b1a14334b48b88404678bbd83db03f6e7c04d546cf00c07ec0f41500e9ed463eac1c8f7c66808e4f800bb07fef735dc550c1a6b4928c9bc92be319b40b5478321b8fe40bdae558ae13e53282f11283efd562ff6e91401ddedd2c74643ad7e1f8783963064eab3306bccfbcb93cc4165f248329c0a98c4f8d46d76fb50daac56be2a736feb6e0e43908de2a8c4dcd16ab7f5ef1c5e87525d5716f0d2f498b0254ced2d6f66b293056f2a983234133441c0bee55dfd4037268f583f35c153cdc17179a6d7fd8333cd6b4e5deda22d99c5862774646a033107e7e1bfac5c908adcceda0e2b3a360468efb5cd2bc111a2336d6548fb36bd9776ffa97aecfa8d49e6da50c1d13ed0cfa68138493601df8d53efcdcb2404b61ee85362dc3ba05f0a433c019aa81d1cc3a50a6a241ff432262e4ee115cdc2e39092cfc4060977e5b451c740d1a6d5cac9542ec428820248c9c1833970c065d00beded33d1aca27071ded1bb3cd1fb30ef5efeec64a7b826fabde64ead0d487973296f62f014feb571b892bcb26404ff77644880e931521835a1f806e4bc5901142cfb0c9015c4a5720af6a32094926e0fe35fd7213e0b49db2671716053854eaebfea7208f6a1fa73b7ac7c224e21625505ab9d1c916c9fbf57607050f30c472686b9a7349b5e01cfce4b696ac909043a0cdb5747403074ab9456895804c99dedbf9df4e6f9604d003e77bc2a6a745fcaaa5b1f7761ac7eab6ba70e69014840d9d517f7722863aad87b03bfc41aedb9f818e2dbd5aec038caefdbb483a6e08b2655eb49f5faf214e61cab46c8de2d7817d0ccda4221e2b294c9eca5a6a5c6d59a52aa3ea7ea1ee002c453ff81ffec4ce52ccc9fbabbd5c9c045a104b7bd08b4615b1381d50beea6d764b8bb9d8ccb4ee52f88a9a9b731ff33abb2213783cca7cd4039a0d6bcf9569b8f9c98bdb72c3226785a012403b4e333de21485101845d9bb6318357c97e6dd237702286b8693ed47be1971a452071e620239bb32fd6b4fc6627de407b9104fd3f720e0a1a4f800e783a4e23b5c8487dc2da4024384b6c8d64a6ec49ce139f50648dac443fbdb270fe1e90c0cbfcda6dc0f082f14f4ebd157a67b2c295158b4726c0b40a73c0ba07572491f016758821852659290c0fe2f7ae419196f9f597e2aed0e6104c86841937e79561348c59754f2defef761aa1c63f26f1ac513fc9f5c0a00cf899fc92e874318151af08533b3fe1fd27f7a1c52d3e51b55982167176f47227d988ea09cfc5db392234174a22ef914e939252bfa8f62179b19e22c281b05a2d8baaaa692825b0649a2ad80a0d507b3eba270a1c139635b8b683216c2b35ef7fb3cf7ef72c2f3cb9eec5bf82282cbfa2ab60c10e97d37f7d994e7a164c8f6a09adfb3f3c8f87463c5acd927c3593414decca71bbb9e3585bcc8616b56748d26068ce405a57bc94f145d8cd11b8c14e3dfaf8c027195762930a332bd9820630a84a6db329b4903578162f9cbb311f78ed39e5e9c43a4c78b5e918038097761e75aa20b0dd3a99eeed641f0444efa5e2deeadbb97072e322769db25348bb50f20c07bf0c03ef63743cbc6e30f71e4482ee3d62938f79cd9179888e83750d520245c0b21b79201ac2c6ac25ae57600f909c2bebca297aacbe71cb15494cbe881c3c131685ca252b1e27b97d9788f1e25cd8d33869e875bfdac4a0b4dbf4b0f51f3380efe061fc34c7847d81f817c1ea3b4af079547a04da3abb60330b04756580b79bec8ae05f0917785b89c4f9b5329eba2045722ba7415229496548e3fd5a73c4718fdbefc10882a59595fa275442aeeeb2d13212af06b536a7a08faa3538a475e2d9f76f58a72debca1a02c68b6f9cf6c3c3e17740748a9d0ef0c4118f25d04ce63b0a72841901198d894f9f2f01cb7c5f7cd689e839fb727bce7a1918d2cf5fd016dd6fff51684d39b3311dad61040dd5f9e9c28f100ec300189407727a12b68668c90e0e92131e169096906f662f291ed246d85795ed47a0f7273fa837476e526618f15b540652ea4e4d7462357f9f5081e07e582c56968fd4cc80aa19586e91149ac8bde3e188824d5003bf993dfd7f1d2d9849e005b52a7d32a23e056da89da3a58f694ab77bba6249866dcc4ad58d7c04d114cb81744455fc8ee55daab873e103f1ed7e0724845c41dd01855aee9c55eb5bc64e41e949ddf6511945bfedf467c5eba69501349ab504de5628156d181006e81a1455270a976a37ff2d8967492f2625bfdce1a4d590e94336a63671d7f6b91edee404fa374749f9dd398122688af48b9ca56f4fe01c60bef1ca282b9b79d539a986573f2a14be59035340c6ca3a88c4882f184e2c0292061afcfeda20deae56b6da6bea813ea357114f885d56404863e99d5ab2c81035521cf8b9f7d944cfbd343f879b3f613fe6f46cc3e942a553eafa845e35aaf9b3eb7c8c43f42966cce11c0613fe5539d31a3f910753c1617d250636b590e7a2093c944bef2272074b10ce84a50c00f9437d2f2d93c82bc925dad3c7597872c7de01917a21ff7148548d285c3e9adebe88a131bb2c00843235e3646f263ce5c0571334599a356d8039c7156019f2085d26d7437176fad791b1c27dc7b838ae7ba8d32cc5ab288526ba732290c9346941b7c2320ffac8700689d8c3891c68d761a2cc225101be6b876637b93053a440bcdfb25831496d25824b6b07ed77ebef570cb12bac4f93f0535ef0d0d7fa326318faf737ce8fc97422d0958562ea843d1ff0612277c2683a9e7dd90adb1c863476ed859567738fc04e6f7545e0dfe22958428b68267e7571521b5bbb112a4e1888392840ca5c33122f0a6d170940c5f5f31505b815b7ba07be7e26cc8fd6c9d7930b70d3c0b142c4aade9837fad11907c7656145e6ca1cb134bd05fefe9559c09a7a33fa14fb0b16656ec922a1e5e230d271bd4a6880d63de5f80478e418a471054de35fc95caeab2e798a0a327b2de9f1331d7034598319cee841524d76c23865e29c4a994a7706c7db1b230a89611e222fc71cfd96356802fea44461770314252c25057f5a245914f2d599dced241d672b3a528723a7e9dd56a952d500c3c1f528286cc66d922956c8aaa240e1395bbae394fd6f553f2e8eac4959ba215c93d5c65dff3a2efa21c60e9d61dbb2cff4167ae57e3504de8c6b5673f6699a602cdb889cbd0a85c7e9484f2be4a56bcceb211151713ffca161ef6c6ae5583e7aba414c5e657a2e2b51a858c23ccd6e7c86b064b4709ad352ff1eb245e6947c805df7b105913a5b33c6da0d8baed7ee9de75b848937f844e89c29a874113aef20ca06f6382093bf87a5197970854d6ceaef5e647f7287e461ea2c2f3df5ef1e6930bd9b279d1229beadd976c8d197d58059c76e771116b5bda2891ed252acbaab4a13fc2c40d8df47991ce0d3c55ba385c9aa4626c1905e64f00914b2789e834069e617e1cda4754cb6cf4cc104953edf4190bcbeb46396eb43400c3a91e854c537c3ef94170b40416be92c3fd2e24150ae422d38d301eb25ea03beb0a457badb8fe79a49dfe530404e59a365cbe5d1c5761ca0de244de8ce5356ed02a326b4a2776b63802bd9918235ff2d1562c2cd08dd6703a16e1fc9c0e55b9170fbd0c342154055c860a5b93ced6d850471b9a0f53321c4637d7b93d45c6e3b712b6aa2fdb267a6d71e05ae39dcb409ee0cbed99d77df56988440ecbfeefd3fd1fa7dc667bc1e93728fe03ff7859e45eff352dc67f4291b161833e0cf988920c3f80263bef6b8304af5761c1518a8e2c6f96ddff85ce0439f633a871357a743cff9847733d14fb51fc8ee5bfffb3bb1b5741cd6df662f5c601f7fb39052d631fb01a45a588fc893104f50a8780e62afc2eaadb92a3936a22e457d8f4d29efc64a60beb5c354debf878a2af7d926aa5be38e1b5e95e2273745d6efa7c817bec0354d187bcc626e74ac9b3e9fac428e689087f6276e7f3ddc8b2b4054e3a156f41831d95b68ca864d217089a164a61d5879892f0a5ca33ca8927e83f16399842bcc01258b94911d113cf1cb528ab0c4edfacf59f711597708e64bf5aa0d101f9fa620b41f6a9dcb296d2dd12cc58b26f054cab5a8944abbd0351acc39b6d049ddf8094fb52cd055f0c84d1b452a47306c3326d58c1a51835246dc4a073929fe29b7a634eb5b53cdcef2dde6c04c5efef7f8e92d0dd11e35906377cbcf0daf3af1faa2f2fc33bca545cd0374aaff91f9598b3c1c83d8e17e85e36dd507fdafdcc0e2785731c7c506cf4e614ee59744c7c35110cd9f0efe7eb4055f65f21c3c072d56de1a6f843d6b931e5ee9be91179ee85a11709a4896b6469e209bed984f9d3fc05bcf6f34dde8f28ad2302c8bb2d29703ad4bb59bfb0f7a831166c2a01a331d2692cea0711c6d29ebdc0b4f252036a465fbdecee066b4be0c3f5835cd1f77884510e2ce9d1dfcbf8ea5dcf5975c45e8d32b29ac355e8b1fcf18838f132019dd3aa79d9abb9cf4584cd6ab0085e21d7c2b1433f0897a434eef6adb17e0a0ad3bc56058c693225dc66df250d8fadf4c56cd2a8b398e381f9c2e537d4f82f2c7e46c5c835d807fff67b2b2292366f61f39b6936b417dcc177c01a185d9612ebccc46aafac469b3179e3e5309b422a7d5acc473b067990e32e2123ef4dbc2a70bf7673684f4c5a579959202e5f8dcdde4242923b077263d5995c10a87adce3a7035bd466c0c0688a7f8b0e73835f5124c5fd93c6becef79535a0186284c9eec27a15ef6e94edb078e13299e31cbe9fac252d1431e8ce1c40d2f09e4e4bc0af32f79f8f688049021a967512903d25c7efd229c92525418ec554a361aa409644e44f8944c05b4a179ac9c9c8b226ba55d5a8814c67d50a8bca6d195c12e3a22434793d5d8c8b870f3eca5075fea48d9b69a7845c9810b0970a4f63ac6dd445757d9ed1785cc1c38d032a4e80d78e02081bb389399f3af3237f5bf9f5f6f3912ef4a8ddb74ab6ba039cf0dc3cc670a6d6e96d9a255780d95814039bec8355ab28fce7ce52d0a66c17432ee2bd0907080185559196bf727f4344765b6a5ad4ebd38d94cc9817f2be559f6b2e61567e4b1c0b18d78589e3174d50a8ee5f7ff5a20c838603c4f80285e9ea8c2b7b9c852e83db5031a4fb4df78b964fa29d105b935df0672ad5e938382895c597a3d0bcdb3656180018db06dd457f451247573f54844f292b9f6b262766b24cb3d0293d0471d1c00491b84e58febef984a75d198bceaab1bd7bb49938cb1341821c3dda62e515f39728b3778c6d3625994e306249c768f66c881b43ac67a744f7e025f7535bad5061f5cdf364189d8f1e0b8f18b32e7797d362c3119864cbe57a1b136d678c0ec5d42c89039cd2129b7a10aa58549d6f7b5c889da239640316fd5bc437830b723668b53a3f7c37f794a762acdcebf3076444b56051bb2799177f21be4551af786a32f405e54f68431f142cc5bf98edd56aa35e8015d0cc72170e8e97c5959d4d5cf339327e65c3b0b2d052bccace1f3a83e3cd95afc998bae98790c67519de9abcc8b4b3be0cfc15d1ce21b01fa4218301a9ade630a60f3b3fdac287189afe6aa8476f6ae6ed2dbba51d926db7ab133289ee521f6e3ea1ecf7efdb34a330ec4e217b9a25fe59f88f42b8cebfd8d44e4645a7577b2726dda6d182ee3c1b33d6e67c1ff536bf0ce8151d8d4c4c0bf37702f18d5eabbf0e2c24b66251698b39718e1d4a8b2299b1a22c1d0f83ec92b704215b398b4041e9df747cf9a010b26f2792205627b8bcab9b055f83259f9711bfe99ae35383e0df4d86171181da4dbb9411d51c41938d5556e157ae0d3351220f86385c64af98539f34c2a06b560ac819790614301b21828a33246569175869f1afb8dc60d3e7f077ef1eca141fc1522161e4dedee21bcb56aa01e5c6e5af054e95a8dec6294825af7d39d13cd311c805a6728382a3b0b55908daa21fef2e0c14a6e151ff867903df1a1be3475708310c7f02d67719c7283cdc76c729e31a71a7ab73eeb91e8c57384be7572fe0ecd009d5354b1bd9bc7278d3982a0d6d9dc9a70288019938591ddfe9a87d159b45204e72ede1a461aed8f29ff0ae1b5b04f5efef00c8c03ded215f5f76250e2eed3b6ce03ff76ef1d1bf168a2634c12c67e60579e1653c54748572a83ebb26cdf78917c771872870564e798c7dc06d9ad6a0c0c4326e6930eaeab4cc781cd9b75e2c8f87a038af9c2a70aa9d2cef89c4b59041193a436380b3ea665717efc68c49de13baaaa15fab335a5b251d8c7d53ad62991a37a3bc44143f9ab848810148bf32cd3fe613c6ff6539010af619fe7de68515f5e8715dc85b9321e5812f5ead3fd79af9ba898070bbcad277e287de5139a327cdb8731dbff0f7437476d91811c27b0370cc8b66e323c3d1b45cf8303f47a3a485abc37dbf4755ef4f1d04e6f219cd67f3f56bcbe177148897839d90d2b49ae372e601fa69c01b30b17d7950622ae871441bbab2759a485327e694e3387957f260e208b48aa22743699f61c9ed30c5385399bd82f83f3904edfb1a95469fee5416654f991c9943ba4192fbb4d1af56fa041b00256f8f1355e0cd7a5aa09879e9cdc01063607b96a9754074dfb146f7fb3313f65f501c21a82cba6415faf9317d84fadc5b9e308d52a0ad206117a1d5c27db3067c18abb8a78a44b393738b16e124e1510f1243c494a3405b4bad90941ff9bfdc1e4c110903ac6698c9bd65ebbe9f267289be513b69bc0e6ced8af8a66803454fa29ea7094461c88db0fc171b12f5d01bac1460aa71e130748331127ad2d3678b05e246dbc34826024b2925813cf21bff633d8eb27acb22ade534dc62867a8f1ecc3c1f4156e536bf1e5724722530cb8a74a2386a6f8f5b1f7a1ef3b92f4586cf32a0f6ce9111af12e46b6b5d0b35d1d443fa06d9b826c57bbc4292c2c8d49d9eda6ea259c3570aa0cdf4495fa6ffd7dd5c149431ad03de91913397f40743f71e690f2d2a61e59ade587741ef38db17dbea3765f07f0a7be7ba7a048c76f2d26822f5078b7b380c0da16e41ed0ee8463542118e56d8fad53ccea61f21979f64781d08009067a982d7f7916916d26dd2906c577ed944c72fffee4d7e640e1a15bb0e29091f3266db52f78755181123384219fd159e3bf26f23c04c38c56f38e2166c72752f1144d267153a4133dd112a9b0ee1483596b163bf5e173dc08c8be0d285998bee79f90c6dd1739d1ed68247cd27d4ee9b26e992bc4691e762fd75037f099f2a8d3eb1979ee839366ea092b72d0270cfb75072a86e7a992c6f596e093c04b6ea91f3869d27882366b194eeb120063726704d552f6fad0be448ce8ff7cc31c0c074ebdcd09c62f1a6e2a4336c80589d2948f9a8357a997207fe3647529d68990c1ca12e8f42fdfe60e987fb59419df99799977537d97884f6378961d6dfc110f8e93fecd7ad8fd85fca0bbc2470de1075214b0e0f1b88de30b71eb33aa8eed9fd38c63eb616a4cec0494bdb606b0b46e65eed09d99afb71bedc1a41af09a8ee5622805bf2c6aa7a544efaf27d04c48c9ac18738eb2c61a9ae1f03875f33590fe26048383b14d42232a4d7fa98f8675b4ec847b3b9f6035214a8febd8e6fbad62cea3b3a8c9f575c59524c95362595630c07ad0a9ea1a578f45d1b70861606abf0ffe6b9d7aaa96bd72a9c6be6b655e5760b3ff915d07e1c5f3b5e935172d42a7059bc0643f79e80d773608457d5a6e0a298fbba624883b7d9db1870379fbec09456754a3c4670bb20252921b83228b66c6340289c93bc4766ee6c91688aa9d17a20e55a749432e1e49692ec99e5cf7d0c03bb541e84e5ff8d626cbe3247e58a258a6106873b4f56c56c427c6e2f73b60d300d5dab9c7d5a6e7c78b2b06f90dbda4da95d5d49c6b524e7db4198197ccd69fccf6e47cbe71109c6a5afe44d809560287ee01b93b795ea25db41bce2b91da8f5903c626e30816b950a404393614c5b3bd336b9c1b3f9f30ff20d62ac3a7c48ae291c4c7f72dc3836dfc374cdd9fae321fe04e2651a2cea14c6c5df370e8d04f007f87b4fee29bbeb307108804909097ad491d12eb2bf3c212ac3d8b0718d7de7b3ab1506545d1c4c793ebfd9bc58ca27cd2dbb391b933f204c92f970a3269271837c65692d027a69a2f30d8396adcb0dcc1636aced3a21ac7b626e8841b4f06403dd59ee18c61ae7d1ee8468d0ba26864008c054ab5ce514909e6edce6667ab987310554d7be67f3768c5fd3247da13bcb5ee885627afc8e8486b7e6d478c7e5d03395b12487c7379f000b2f2231266b4ab94aafbe0d413f948f4217e0770627e4d2eda0e908b8cf9c9af2c2dc85d0206064881ca7d55f068c0687aeb1cbcc84c0ddf65464f060cd90a9d6513d64ddd579f54bbb9f5b8f92725f84a08ee734da93170a8894b4ab1a64ba423f5c60de82f63a3abcacbd3b770ac581c574839a78102e5c427a460eb6458e6e51ef184a3d4829dd03a35d79cb6dc654018d96d432a868ff226adbcde8a55f480abcd5a5c428edde94536efa6889fb22bdc107f6377e551c64e7a7f6b392a9f5df21e17bf976addd2da6bb05ba4a4020f13e6b1a56fd30a54c1825a8c3683500a1ee7c019092a61191b8abcf2ac0c5dff2d59dde8896c6108a71f035e895a8625e7539a2bb9b915483a6af6fa6dd507140d334693bebfffe0afee6f259bf007c475e9f81d7a44baa976ab0ff3ba61e4127e2e47e0dfc6041ca2ab542bbe54e30acb51d6f76bc8bf7a469a91d15894d5fa483b3d756b0dfeb8287e62fbdcf73065f1422b449972daf0f42670728ea2b17c0aa521cd777ab368c04021dc28b1633b404189f90600d459c35241baeffc50c626245256032d18a86dfc79d002747b03ba55e36c18202d9bd31579d22e05be04ab36245f9c6b99c16dcef276d0d524041d30bfb983ea95682a0bcfcf39a754d34c2a86cb5102a32c0c4fbad7d886d8d2d9148be295f94cfa5facd2d2019dc250a4f0e1f90887bf90fc8e088bb1b44a37d524280dfe362835859a0d67c765f94826964801e5b410b1fac50347679d13a27134689a6cbdb1c3f868c4ae5c6fd4ab5f05708c85b8c909dafba9039534c09411405889d5610895be61ab387b1b4f0ef493635a205734c25aae0cde7dca2cfabe5ee1af6dde464e97b8765767c9d849d567ea59f28acd6991a2453ccaa0ab2df9c722a047efdd54c24a790f2ff43c8219f5b25b29250b3989b3343a676cc2510bcaf0fbaf8b49d8e78c3da07cd2383ac98744ca979a49630692e35a4a37794ff66cecd4fca0f6bc146d200d055d74bbc6e1c5b1636e15305813e231caf2efe5510108cef9748fd66af48e96a16f6f388a674b40e131d81ba3072641d9223ea5c202d78a4b230d61282bc15409bdd8210fe794d1a940ddfce91869de7c81829ad907f1e6e6c9ce94ba005d0680a5c2ebea3a7c60c860ea8046175c051a231e29ad379fa4f57c6be2808605d6d21af984e5f4e06cd985f3577ece70b5675bc7625d58adc3ea85965301d031aca05b4afe0aa862782ea8919af76184a01a8dc7005ef5dd51bdf996447e11f2dbfe2ed74cc34fa7c34a9fa1d9bb9ff0180995b2320adf9fad762d331e2383417cdbc97df5b21b15c2276dfc43a77508a5a7f65bc64668cdd6ef30da0f3500525a2e95e0b2ef73b896484bc9ad56d288daa9aa94fe3e2619321270d1532ad50c588d252a5239ac09709c4e3730757f625d04c65e5e2a9cf98234f5401b6987c10c902c90e39feb82a8bb283301568b35b6998e084c66a7be0571993b82ab157e59a076abcbf8c01d186608a4aff6f4480d1d16cfcaf842f2614844f4850a9b264b916bd19e7271228cdfae7272519a92f26e0c5cb7c834040c58051b449a168b3d6451b92bcaa50c55fbf7730cef0953d2c9b049ab8f6ce75c26be4a4c392a8f77dcb31ac09dda65af9e49ac28abbf574a8af3e3685176d5cba48854db267b3db583351713e46193665a73ca8f94f83ca996ac079dfe91ea47c4f3e4d88a2308716348173f252d5e7112ad1e189475265753ddb2f44b639afa37ea39595dfdbe6c0c1e98b63c815f1a2b3f84cefd64482c3566375fc2d97371bbb5332de55c1f0d007437d4d704d48b8f93d2f199d6f5cf49e5ceda26c9cc2505f1ffad1687f2d225ce9cdd1e797e206eaedc6ac377a72ecd86966c6bcde09fda2e34e77d653acae28e9d47ad14629080f34636a87362b657a7a22cfd0ba19b90079f0cfbf0d1d758e4b385f4f201b7a9bbe179fed05bdb2eaa6d73f7e48dc1711c1444a3cb7225488ca036575348aa6becd876bba4da9c1c0689a28fb5715d1bfd934e546f5d18aa2c94ff32eb8731be5b325c33dc6b550f135a6d67beca125cb76b7e2c74f0fa0896325d6efa54906e40942554b969614c2fd3de8d13406625f3088f8b72f2539bcff00ad3b594f9acf5187e9c55a19e3bf2c2bb5a289cbaa5092bae0a6b22d8db780cc95d62aa43ce6feea8fe7d65e0d3a63efd807dd6deb0bd938c3a0fef95c9a5fef9dc309350f9b7836dd216731d077b553dc59a441f8049d5588ca7ff60098f89a44e82c62aad217f76e313b74a3c29afb020ba8d93e688f90f74f22ec56de651b4c5eb46d2bae154ea6b14eb4d76944daf860aa614ab93e8728e3422bd2adfb160b5d6682388ea6347f705c9365ccbdeef512f6dbe640aa65ed117eae59f66fb322b4cee0311f0f83919f6ff1e4891eb3202d9e9e2571897a32ef571b3f478823ed8d2de2360554edbaddc0a4e6ea3f837c66cf60552ff0fa171e068c1883e7abeba8c467f51c4071852111f1c6d96d9054a1d18802410dd91fc8cc566ba4ecc0bd4c42e06e8c2e3c013143ddc4ef7d108c6a09f19c1c45d83632ac4ae038ebb35c9f50ee9e6ec0489242ad74795841c82ef70e7fdb1755e013c7bcea8139a8d02a541ba8d1e5e182c36400c6f727143e0bec3d70f07558e111ff7d3d6ed80344a3f858ce34006034146d609bdabb8c6afff394d6c04d179f792e83381e098d9c90c0f24ea2dda0083e9159025b3cf265933d46d8a990f3ddef8185b353d63a8ed2d0a2f7631c8996f288ec06a627059f08ecaa9e75e5b52b571131f300fe74545221757ee213af30eae5b7c0153de3ce3d8d13fe7105696e704e1c11da679082ea3d74b0417b3b934b4152a7cd20a0fcd6082194db8ac039af4ef4888f0bdc5b78e9291359b57a40c92a3bc0b70983f57e4f632163ada1a482bd7fe9a29b29e549dc04361bafbb587d03acc73b02a5f93503cbacaf7f34c9311a44bc9594223de63883d2110827b2ff462da88544585b97ed28d3a49bb45e3e96cb1c48f4aa3bed72bd6e3981bffb04e99328efbbac522df37fee5b905bf676df44bdc36f0c3a9e24cb26f110f4d0c8836d5208fafcc291e11e1bb6f4225b41dff395b3b65859140005063a22406cf4395ba89f8472f66fa61ece7d55b0e51dff633a2999027c2f2614d5e657faa909f12b02c351dfb9c21339add3b209c4432234c9849f1112e6994f7087877d2c3a6fa8922c847ed01822dfa22aa0b400f20c93f594dd1e4d7dd903f82752c548ad915173f1808efa039dc059a447dbce51ddc492d37bd132b4a27964abd0dea101b4e4bf38ff9eaa302ef89efd7eaa674d4a517b1ad1932386ed869c84656eaed150703f41d77c3847e68a246127b7db19deba226503a2e5e2238794bc33f7025c341b1f4a5b8715071bf1154e748e98c9a136b78995866cebe812fd580803f90dafab75c9e99fc79d7312ff9ad330bd78b047c1aa6469f173484e0082d69a55e7176b6398b603c59b099cd0955c578a3e7ced53aefcce97ee347265831b2301620acc2b45fb78ef6334f5216430e617a2e0f7d3aca8958cf05465f9d441abbb6f20dd26c46397bf6f4bace14195385616fea447849eb6b9372198e323f8908fa845a781c087f6a79f7a0c432669d0173b020e5d9f5de57f3255679a3ba458636d80e3af42393ede0b3ec09345e59fc12ac74b52d7b75a3c45b7d1e6e2bd0d47262ff549246bfb294340acac5f7b5a49d7310b5e04340cc889f2a539422f25d8d1a18b20fb539121af65ebcbddaf3c2d365787c37050b9ba12387a4550389419f8df067544ef13508048c4f364f41891046e2b20c57f859ac32cf15181103fb2d1337efd8a7c0a307f497bcd4ba66f7177e098ce59cd92bdc8f6f89314f60fe4048feb2281b1c2309853f364227b55110a3b1919c9ab0495f4fb0e11d0fbb1ee20d445e64bb3847aa30e2d640a11753885b30acedc5eb017d8efcc75aafd8683d21b25fea85ae858504871b00202b1f92da4ef80b5c076c0d248541fb935e40ad1a45311a19bdf433f5165774c788eba1f2b14ea1132d4108861a051f2d87c307f555b23382b61c448443d6926e4db1235b2e5185722c8ca4d2ad8bd7c9731283e3437edb0c247dce339cd916479d657f54fb6a2165efff54eeaf3f2a2cc70152eb77b343b92e63ced2a8ba7ba850aeff4613efbab7cf8a1e3b10dd7e65a22b3b8a9ebab6a9c9e06b82ce4adcbeb331200042f27e7fd1e3342afc56c1345bf04e7daf18232849bc512100e38625f82e3a9f0710cb5a0564b973e571537440218eae43dcd9e4407a7530357fb8ee6167339989d18b246c34e5c2358c43d8c08ce4b4755b7353a6735f92adbef42fc746105a13148c6e852fe7c9d76a030edb15e15bd0704745a5d6c88cac053bc94bae30ce00aa1e9e0418fb50ecc21bca05ac675f6f0049cbf770f3669e1d4065d67d1ee5a4a204e58c0f0b2671eb8514e5f4c198f97d878cd106f7b8456c81f391310edd37f68af124b6927e7e0749dddc27f3a8903aa7088ba45b8700ab9f406de8d3d63985003722240d18246ba88a2119f6e6b21f7eca454d7d6da33167803a81301e2249bea698126eec91fa6216db6a1232d48254f0e0f8e1e2b70bd6ec158d8f7c9563f63fb741c93f04f39d0a0a605e849b66638854edead5d73e568f76c0bcda157b37fd8d9cbf83c7c4aecc833a9730050ecf5188b98c70eb6786aa97e6a767d6d15cce4014445f999e5b28319caa68cdd9c098bf0c6d3bd32f65c7caeed5a6d1c8ecec415fbec8476216a88e3eb70346d1dddd87f632953bdca05bdc68c578589929da05dd1d6286c0818b75ecf98b757bc2222eee7b1b6264c96dfaa7b4e1a9c26553b37421458dd66f9df30b8b5d9d3d1e63ef0b2ea9bd5db1a236f325df8a8443881bfbbf836300c17932116bb4a6faab2ebbefe34876ca9bcf9fdbbb702645ac12ab11919de27a14bb941ae806d929fc6a8b86d692132b847e3c08b6fbeae28e2df2acef786cf14faf8452068d6be388dbea82b8e58018a2d897dd1e63375616162ba538b56b2232715bb7e6f0082a77b2b4381dd3c6bee7a088cdb9289d6c5d646896969868c5549ed8efc5b555522507e53bbdf2992d44d9f961bc89d19a0b30f9a3bf454bd080c6adfc2077ac72d8bb82f225fb63471a7898c466361329facd5d3d28543c56f6e3ddfa6afa8267fbe7da9755c20b32e21268c59bfdfe07d2f2104292c20a582a6f0dfbb9ea907c32ccce984820862444045dded76cd1619868459a393086b2cee12e2a92c4490bff47981f221def86767835767e018f0b06ece4d7b0056b974a1930dc80e7251110c3a8032ec32330ce07e056ac0d2b872034558290d52b5b1ce2b79ada1f4a7703cc6d286f3170e5cac804baf3fc222687e63b4f229216d949e4320e2cc0a0f135f979626b48c22ed3397a912719e477c4b3bc9d81eed7c6d563f63e9c04553f52b163607efcc566e498938f4d506562f86db8d4e004319a42edfad251c9c0f890c9859ae347c4add6f711e880af7274b2a73dd6762388e0a877d2c551a993d34d60371d018ada0bee955d94f0d7898d14c744948b589864ce2739cff1beca60684be336daa4bb69aa0a3093f5b05ab2f851372b4fdb5d19b4b73a4188ef7e3cb1b8a9067a5a109e9cbae19498017ca9c7c1071ed7a4b77fb9f712e5d059d0cb49a59c1f3e801593d7f5c5baf37623af3134522043b3e47ae84051047a47c3ae73a0253937264d4569236e93f727cc7c2c81a6c0e7988c94acd6332a7acb63368342b5db5c65097c13881a4431973238098fdd58634766504ddb33f61f83cbd2cba683f4bb0c7e6e33d862717643459e9163da85a73ca88bfad068fc8baac5c2d24720d0d6457cfa272956dca671d63c7977bdf5e739d575eb24ec0062f3fbb7d1fb6b1929a4d0a25b67b893efa28893592886b92b49a91ee77263759b5744106bb36592e6b84af6bf8acde44f812e11c075c0aeb2f01318180bb204771231259d2e73d1e4f11a4ef9a7587e3a492d4aa3dd3f3b69467353367fd0c29df62904a487fe25b7233571cd6850bc5e223f8d019017d6935d2ecd4f79d894bd6c811252a47ddd50bf6a9f487bbcd3c3d37ed8d39e170d1c6ddccef4979862527592b6dd423210722dc1c039b6b7b43be2869848842bc9a67f3ec978894f0038aa27aed45fb1f40bdbb408900f7276d2b45a9ed6e17030f12872975694f0d1680007c436100ede2c147be18f5d5f33cfaf335197d340bae0d21b2b2e052257d624cd1eebb1eda96e6a58ef1d8c91caedadfec16ad9d7cb027313bf62c7b42cf68a65f380526248d766a18578f6274c5d80ca807935f9ad1901c47264bf6600fdcff7225c23a9967d69ecc4d99f2ef6ca54397fca073b1d1c0892c26d8f716af4368c9584f38290b97199ca667baaf9c9f8c5432b34eefdc67a89db19a544853c134a9d2b2f3dc96ffa6f20cec9f8eafe7493b0dd5cdaa13331c9e70d9a2e7dbaf008ce2016b16ec8adee7abfe6565d2bbf1a7467be15e010b4fdc0c00fd38761fca538c402531e5922f3c81f658d6cd886112b95b1dd0e85b4fe6fab90cd6969d557ee18488fd003d2b649281063bb2523e965729d22f919a23abe850fba4ce735dfae7ec3fab6d25a6eeb7652dfa2a832e0621762382704018880035c10a982aba3232fc558c5c6d9dcd8f1b32b2ed737545dd17ede8fbffadfd06ff755ee30469fb5644d22089fb5dc3e880d72ae80d15106b7b9c5119e9e1fedb7870848be155ffbec1bd2b80315e8a70f5688e184b8004aeebb33ba99d6fd22b5310dd3b33634eae6316ef73627b3869ed31fe3a82d159ae47a4e476017622765cf6dbd261f41e3743bb6ab4c5ede1f1ff658afdd262d6cd0ee8d9390b3cf9da9367ef33c2c0fb3b77b866bf8ad51849944ad0306bf57999d2d17f1ec55b75063716700528f13bdce006b9b9fc723df09df863024e548289367d54b759373a1fbe33c01034746148cddb7dc1ff2c97fa0d82e21edebe93e0f42634855218ea061bfe55659675478c6db73681751469123b3b8824b40fed71bede8b20830d78338dd834a4fc8c61ddc75dfb5b310d1229b20e621906837240863f7db6aae2e04c943b393a3dffdab7a5442bf90c1e0cc16ed7b2a89b0cca12984051601593d8275c6798dbf56cacbde11ef758c0e1ae32d580b8e8f43ee164db16d0bcef7b4561117f3ca56c6b17b5445c988ed9d5bef916b10d9f1912b7dcbfa3bfdcb85e2b08519bfc615f45fde2d8f0c4659c7eb4abe21c614881f16cc424b210db5876d08bc53d97f6859d3096bfd67c45f3ccba56c0eef7cf91388cd69f4395dee5a4ec58e7c87fecf3f4e904be040ce4fce896ae6d93a4bd1bd331fee8e56d111f985eabc4f7e2d431cd8d8c6e7ae7b7614516b98c85b739ea2bc8f9b89b0dcb0ffd235a64ac6431d923111702c2c29bb5b2f9b6664d9b7f0b1f7943702eb01b13cb8a587714b02480dcf1059d5d4ded938b48494e7aadf65e25baada8ead5f80e4a678e5edb70d4fc9abd50e965ed389a6235bcc65cdfa13f5fef254e68a9262272b2fb0f444b70a202ca3b114a469576aaefb4628dd14ba6843473b04fd4f3b078a40be417631fce27cfaf96836187964ca387b5b601fc6731b80759d45a92dde479c0b699489ecac9c5b1359dc3561da747075e476226421cd5dd63cdf72bbef6d7dbd1a9624fd728586e4aee903b88a22be68c10d8815c0b95a6c24d012df0b60d688fec0105072da5c96329adcf5d4d71d5ac0e5bce7103923ddd89ffef99409007eb3e9b6597ca2d227ed04b9820d21e909d8f8d3e88a2b93c97e42830d8c2c058f93f2f00e383ba7e3ba3c917808c50b03699596ed0ce79e81bab363644596bee8c903567349bddc8e51b552831c6224f4ce59a72131e8cff03512ce90f9b98f006fa9578dfa658a6906505e2bde951195d56be1cf922ce4f2e0de68920b78a36482a4f5ec87f9d515914e6a144f7a85f5200ed9d804fe6dc382e7e2d4de087323b37bd03f409a62bebbdc20fbae13f170e7f0e8f29fcaf054c230cbb0134cc635849652294b9d5a84112cb5a79e5bd52383861f8c79441f42d6e9866550b4b10880409b2ad2db97134edeb1ba08f94d3517471b8ba5e72e776104f3a074aaead07b9844362576e16524a8c8d5b8c7e92bb945de6f69dcbdf424a2cc230b0d8fbf074ea87f34585affa667eeb658b876c552c6944efe5f9f75e17a929c68eb62c2e89390d2963224e0be30c8afe518c58c004fffdee0bf4ccb75d4b6ebcad9bcba55dcac3c96b62abe51f5bbe9201128c57493cbb88d17721b6ed932b0af21da6d07cbde94b6052edcb6cbfe82b0f9772bd277b141c048507400b5f566358e92172151db05a98dab7434216343e9853af168d8093807e4f7540deae4c612d14eee733ea382e4f8b6fa1a5860d1386db2ce5c2b5278f88dfe4ae26694a5a6b5469b25a576dcc8f7157f70a063ac6daef6a33ceab28ad99f74833d984b855b5991aad719a55e8c5586e6d5fe38971c41d24b2758526eb3e68315b5ddc9306d9c4d89acac6933b7d2e27d4f2d62745ef96bf33322da2dcbda296c1bdf405dbf27c6a5c01c533b2608ced9e94259c5f4ede495c4ff1c2dd9f1be556e41b75da3e389d1c0fbe3d0199023de5834737a1b1557405ca4cef62afb7d30fb8c2e26816fecaaada4f6411aef4398b71ecc050b219b87e8d2ba17fb417ae11fa5100cfd8c703ebf7e897ed2d6aaf91ac40bda3bbc3a21951cdcf20094815af5a65846ded1f23b72df8988444380672bb0d77e10b701bedda40e4c2d2b23b9e99b3449213d99b9575f2990ad92f88c1de78cc9f38fb43cda730d4f661b36e3b75390e89a915f39339c3026c70525efa1eb0016de62020c0078cf659806b3781d7c3ca73452a0e9322061b080eea8072f884089c3f15fc62b53587a9fcd55220905b4e7c2a73cba1a8bca9b3178c53ce128607e3243dd2a4269629eb168957183ab8c5f7a7c0e3b2ba9e8290cea4ebc7abe79f2ac7822fb0dc137a6ec638bdeec8bc61592d0f19a04419478583897c297b6db92374627e6e5d3a242fce8d8f405946c9cc2ebb6dc9997869a5caa08f4eede96019096f28b1f7ec7473ed1649b347d2d3423e0d4a18046cbe4f52ce8ed3bad247a6b35754901ae664465b95251a5845248dded7f3137abee677dcc250c6b06b8a6e8c84bd3c0f611b56948d08253f9e257c6d7c2a5de20b6bf93c35b1952295e6e9455208117b882c83378a99fc10e053744e6f5b6263670bcebb04408220aed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
