<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd3f29f40b33305e6e9f1729998329bbeb2f7c8e81899fd2f0d2a3272db04bb0db10cdbca21f4b0831334331eb77546b8c285f7d4b1e2672e902ef76aa678052bd527cf47dafc852dc6469758cfa70358edf2974d1087a5afed8a8ff8ae83f2ab695bcbd6c661a360f79dd696dca4fd9b6e524c7e39b628e7269b1b20136360e50ca8923c9c5ddf2d37d1ca37ae10b81532f3463aa0c3aee386041cf912c7bf110f113bc0083a80ea2cae8c76c36923168073d4a8d6c2edc705748c919b1e9ee49120cd937f7444faca0104812de8fd08fe0359079ccd087a30087b5cdd9ce55f972c389420784bd147dc8ef38f0d818ae854a93151c8c2adaa967a001eb62bd4f63ddcdc329ada4ebcd4e68d5bf28166713fc6e24d7406fa9e79a40ffa8788767e290bbc2e7ddc449f739f32e6e0575af9dd6b850063de3920a871a276deba8b5e4a768e9ce016045b01914792d4bd2b72ccfc7b092c193b2f92a8909a72520578857c3a6bc90c6cd0e476a79868c57464c8aac1b0c7e36ff146532ae698a3dcaa8a9b94c0d6da175c3c1963b766f42e5f615b8199ebb87701909b99c778ba0ff3a0f8aa1885de551b7965af26aae6e640ac2ba3135c1f573da5e1f4722ff039e5294099ffc8811d182bd7a40eb4e3f6c315ea89cf944c9331208c3f0f6c5c0aa89465ae1fc7d8c70d673fd039138bfbe1770485214863b2f38e8b083a2d8843d4c38c8701c772d6b43f9aea5f91d4ec83df2385b1eabc2a400e0d4c7ece879d10744ac8f2f462897dc96265387aafa32fd8ae512e32ef46d78c93c8db87ad22d4c8df9d2b9ad7f1c8993a226d61cbbd0c777ec11f98cc045092333e5e17577c7fb60044111fdc54d7a49c7ba54f73f31a371db7382bd1d2b910009146280150f3477666dce353fc3634aae5cd9a1e2a5814b27636e80b737318ecf187e49ddad0087f98e9b90473ede30a3f1386e517324455acab93b69c7b1d4bf3144b69069ee19a7f273b94c3827b7b763fff769da91096c14028d8fd2fdd4519f58ce32d2392b40181c6ad87ac3c7f669a55aec6cb589d3444a8526d29c2bc523b315a8e7f14bb089f2675000ac2c7ba886c70a69ff4464c6fa73e4f02894071f07ec44e051f7502af6481960bdc5bd255505c080a30f269321a0ca79260ee640a041e455804bc29432c468c68cae2243d1f085e9bccfb2393a47633cedc41a3395d61699347e207f0a1ad1ba046c4902f2d282970c2bff0f8e75365775c90bd8662483cc53f6d8726ba6776ba0995ff6aca85ef79c19834beae6beaf282b6c3b662939bc72c66d0bf5f24916ce7da1836eabb36fe90527573213e6adcfe52026d441d476ffc13615b2f9b75aa51837bbd31f8b10421c1d2f5464c6fbb840daa959c2f745011c2fff1132ef70fda928420449dc8287e2a6e7b3153abd2cd5575bd41cd8f424ba7963abce4a32dc1483a3ab2a5966c863eec8cabb3d8d8b983d33b874edd6112a06088735f7306737df5e8571dfd8367cc394a73b0be1a4ea3e54a716ef51ad85cb5d07842816fb9d54651ce3eb9f3002add07eaa19687d4fb23a4fb319c9f110d042d18af9f9e88dbffa54e1c9f8e101f8602f24eb3bf8bc1945af037c0fd42a3ad95a0f7ea1663294a5242310cf9b89d8b40d2be21d638950aff7e06a95f5ba5d106bc176dc4dd9b23df9ab9b1f26b7eac0fded54e00163d6238749b708202b36f5529625d0a88cd412967843fb49c6c8e40a834ade082f2f34d20f88c17eca081ab31b8d7d5c3c02fd6f338f9fa804a92e40e56fc9ece7b90c920416e4f3cc2d7486b6a1df9004cd135a19dbebeac3a6a15b326fa60aa77910805ed97490bca8a9f8a626250849a7694448b5fca61656a9e4c7626198e565538568555d483a4304bb8303a5b51ad5329a0edd226fe339f9372f82cd0e7c49bcf6767ba99f9838d6f40cd4d492f507269f029a142ca5799d91bdae09c3e619eacfc75bd8ff29d7f58ecf6158d64c253a4dd0b812916073c88e14ee8cd37a0c08957d253459293a985659608a27b8bc4217db6d7500800429c598e3386c18e15bc719a1c61aa09d50dffae0ae87826d8158cd427d3cf3f412b6b70491337c986e3b427ba04152451b4abcdddb48f1234950accf082a4a5e926c61fceb0840973a9541bc9a511bfa507f3c983578b9c48e4a87841c1cf34e6582163b0cbb82669f9ccf998b107ad4f03ef081e1549137f6dcbb9a570fe0f4d82aa2094e318773d074a1bef06cf97626e029343709d74efe29e46e753d96209ab30e8078172a83f92a231ed5a9c60deddbae3006c041a12d416b47824e0c128d1cb251b41459778007883ade65a2a330d32fb54e5b4ae585ce3073a8e416ee518cefc4044ea0ee35a38881797527fe3db80ec8023f229c724b42ed8ce2cb25e222835c2d7359a0a99f88a34c60d2c66b1e84e75994a1fa8253fe55a6f672f5c95f65eb37e392f3b3452c1251615aa31051823f2908548c36797f6bd94285bb2a4cd746d1aa53fd2361d3480a4f92193c6c643b78b5051c37720a99e4de3cd02398d42005f2b6643a81861a77f6de871ce56d86d3fd15b9523451c2caafc86f8a7792f8ab23b6a14c449abf2758ab395ff896eca910a34d3115c0fc248e8b5dc997fd5e9dc0a6c0ec42fb3df68b5a551a65ab9aa807fdcd91416247c9e54ff4a077c5a4c88179e1d83c66070aeb523601221e233e9a7b832e19dfceec90806ea0359df5d2b72624d0a8177c52de04e3bc574a8b9068b99cef5f4e5743a798606ad930eb147e0f3a96fa4bacbfd518c218b2cd100f56932bf9d58e180d7a50642987809fde1f0233e1866c4109a7e5e044f65071ac78aba559cee27b6fb29059329cf6cf4545b9bec5f476ac2395c3607f6fbd343ae124e0cde6e8c28a013d42437aeafe0314299186d96e7d66328b5d7466d7599b0588d75e8a73ff667ce17039bf1fe157ffa51c454cd42f94d6282b5812ad8e6c64e8067209d04d86bd07a2b3bef0f01458dd04cec92360af0a9275c9b5f561c62c95a07121ba0d24d8a84e257668899dbe1a43cbefff8edd7122a7390713d77dfb4bde1d486f2ff091e80fa8afa2b465c6c83e3452bdbcc2d361ac13fa35e30e15b3a70bf304fdf9e78f312cfe648a6fe9670661734947262e86a8c81b8ac10f1377be73a6786ae4e8d0b220f9e5b0c567679cefbe2932f47b29a53982735b68070edff4c2b09518104243b13c41214225d478ac21ce1b69a176d1ecba2cd6fa49d832de3f3df20d26321f2731360a3fe8e3fb60a6f5d63e2c74c5eca8412c23596349de1f9a4debfa0b83f2df8ed91d8309f655896a2e0756386dbdc03aa71bd15eb6e1090dfb1a74b767b1626383c224eb0e9e976def96c7ef70ad179e727f47d6a8dda102b5ed10c8089ac27e6bc5ebbe2611530b8226322df7e4b8cde93b02e1fe5271a7e81ddbdd045ef6eae55f1c8ddd4f743c6a0e04168edf2c07124845134031c3cd9048ed18b0dc9ebbace1fa2df322852929e4893350f0bc88200784a1604a7c870760c5ea10634c33d773c9235f913413c337a4d75761e770dc9f8dcf1e8ce66f771d8accf0fed763249a000520d3a3e1c674a85c8f495ca68bf3fc2ef632c71fc0b09b6d5ec74e4178b4809fb55a406be4d785066b24c0594455c5bd6963c6619a7b6b017fab703af87690206cb9b10efb91b41a4a610b3d42503b188fdbe27a9aa39a27a0425340d2e11fa63d790df14cf5790751609991be0a6be7899198b3e772db867440ca230e6c1b98ea6e07a1010261350f472a6fbcb064c862e7490ca6e5b2861ffe65e7a5ee801f9808b683d17c247ab7aeb8169bc9da85e916392a58cfbacb89ef0d7e7e47dc1e28a295c272436a8001e8353b22d6792d9d6564751c8a93fd63bca7d748adb149a40a7b4bda70e17b0a83c30026cf505f69e3fcd2b787676dbce99c66510c663eeb5c39ed41cde07f95e6c832307dc782d7ea4e1c126c1b3ef3f87467fd16012d6007495fd7c7d7ffddbb4b5f6e4512106267a498c69239760fa1c3c822b5003bd84d3e9d31204212d82d66e971fe4ffa687a691cc41ad35f5ed2b54ab9490015e387fdd87034db2b04bd815c27192c761af0820e3fcea7417c7ee6667afa865091b1b5c6a838ec9616b1ab898af4694ef7461080c5b845dadca07c68161bbcc9bc88a7ff99e1391d3fe6bf3abceadb1a5db6799c1d70872f404f80be72d9cb3a851069ff274f90d0a3c7ca0f8d65467f71f30ff56f8aaef7ac83033b8a6c43c031e0b1f739e2d84c6ced3639288850bfff759181b3c4f429bc0027d07e50ec7cf3d48e76b0dbe6247ddb9bd4e3d34b18c63c92bc8e78b580bc2b30d6e5f626f78261a59d38d49499d502beef515e1da65382625e98d4c701975cbe87f9710c64f68028759a6962bf7f3da8d609e435ec46229a23c4cf88eadf2253c6d3b291b30fece4668012021bec20843eaa37bbf2317f8f44dc2dd42b49352ebd5b53b7f69c8462b0961f3ea0ec6ec475474d09366d2dfcfde64606d9480002cc2d1d405a9100465203c7ef05a2af37e70fbd3d7d0f1944ed81d5b876862e83c2d149887198c057cd798efe991f118ee06fa5841b47b7bcf199df4fe54238183ddd414acc75924f210d7ce7d14bc180dc089937f6511d02d5d05f9726e47c59e8733ad2b301f1b13de87ce40bf593f7090886ec36dd9dacaf6f3727adf512f411d96061438fbfa79e77d52f30447d77b98e8be4fd15f93c12dd64ea83907d783e655237f5061f9be90dc06776981606b9e569010bb24fd5742af762f10a9c7b10415a49b77c11121a0dbaba1d340870ac209662f688be409822857a491e9c0f63b9f0ca6c842b903505607fe0f434f42b2ace1af609662ae08dbf37fcb1dac30a8bf41268cd0175ce9bbd8090215203e4044e90b9408c07d069e12eaecdb550ad5f50ce62282d9ce2ec8bc346431f4a2266ebcde6cdac7ca76cd6c22caefbcb5f0ab719af402f5d9d996cb193be3a0a346b66a38a68d2d6c5c79f0805d6a6c637d871c6684de6b8f83d0f9dd55bc49aa31a34af4231760cdfd03db5f70e058998b4b075f5e933c328c080d5bb574ea81eeffa9a45f87121b886e9be9602c5c91f52ab5bed0f1fe4ea18b005b8f53bf69e79638f54a170022dbe440a61575d255ca14345e86813e84ee616fc9ff1f4559a895582d9fbfced95cb38eb3c2b1ad8668b1520fd7265d64c012890dc0f4034932be09e86798248559464b7e260ea391952f01430634e7fafc8c27f23f9082f859909210c4e1bc0120b3abc9f34951cbaf1980910640e5e8a75307aa45104f482a903a564311c0e35857d1ac206f86cf9efe470570b8ba480d0b33b261252d5f2e204c4112ebf6bc6cb7f5c1fda13112b32daffededafcb4f521896190a9e6794b13c01bb97153abbfdc80315447654e0fc53aa94e7f03f29d91b38dc7495567b2660058875e3f8a46cf75b8071c0f41473ed03051dbe566a684dacae846107d49f360086032ab81fcf4efda168b33555ed14d29276a1c7646f8a5d931c0d20c64ba8f16682dd1f5ff05f283554e0a5825f863f6e167da492fc4901f364f4faf7458411ace6aebe08e5de9dd8a61f3a9df52be49af754468270ef46bb327ed198cc824f1356349b978747c120550ffba53414486ae18f6f2a83bcddcb6f17ba9e7f7fc603add9eecbb980a6dfb0913f544cc5910b714803411103d7967f406d5f4a9b56f6a08d177cb6968cf676153a4a11cb9312af8b16874d1d164826bb0cd4317fd9cfc29321703c532fbf77ef04e20680d37a191fb2bf3424fa26619c4a59c50c350a56abd62ca76609aded5da6ebf3e5285bca58acd2ccf749c8744c3f9147d68731dc4f8961b845329fea474d95f9f65c26b6935f4f531d200a0ac7b0efecfd6daba411ce808b5dbf69515faed18e623ea7152b8ca7068d807ce989a1e77db4bad37cae3533eca8c4366c68283020a6ed353a43ee0a8f9afba157c4ce97ae0aa4f93f810036c1df6c3da3795941c64bd50fe3361181499df8ae6f1e97bf9329b14f834a454e3b5ef0af0b6c27ff034ed6403c1c8f944020e81dfe4fe033ed8795e186c81e1924734eae1923dfbba1da8802935d6bf78933eb9171efb6846b610bb782b56663da919fe10bea51a2112a67dfe8c140447acaa2c8e36aa9c43b4de01e0658a8a27af58ae7ded64f6a2169af26ff1c8ad717dfbc2d4e582201db3871a124ebdf62f83f3e1374e5a421f47430d714e769c99bf3e42c381fecb2e364e9a1207ff1019f5ca2de1b2789a6e543713fbcf72d3a1df69c5d135ec222ab7093308dfd9a156da113804376489fb115c0a806b926c2101f81568cd0417a24e4fafd356d1dff43ed1a616428e101d584e8c37d97e284fb99e46990437e5e1dbbb4d4043063c4ea1097c545cabbc8a2a55ec1202698e2b0f65fd573caf95176b039c68deb42e0fcb82ea07c70dd1b91a0fdbad622931bab0b992f888da966961d82c4e3de341afbadb21a3de0d922e09618847ef65f24ca62a7204eb6fed5ea2c2fe545cba1f7805324e15fdc2cc82cae62f249c58ca62a32261f464f4c7f9120ef45e4f7f24bc4ad10a56d940262997f51c81c530f9cce0194ef04bcba629c46c7d58d47dc34a12ca304a043683f51a2651a7311aea6111a682ef0ce39fea2c94a53d7b06563f5f6611b016690e2af19431f7708f5d77dff3b11ff87a82d17aabba18f405d4be8d3ab5219de49bc7300204bb159a0f8438cbaaf0cddd117bd58c976dbdd2bf4a44577e4d58cc48b62e9e6fee482c9fcd4f1b1741b40b94e8ddd43bdc56df73d91bc4c8ede5e0bddb197c7cd0412af194b9fbdae2e8a24b98319569c14bdf08fc0969997d8b00594700cd666b616da12c3796be663d22e48a4aaae2eae9e92625766aeaacce6e3e0e709dbec8c65b8d68ff18201187d9a2dc04e4985ec04429c43bf1c59591a97fd69afaabc047686069b1882c53e0fd0dfe04749432f4a83305ce7dd00186125f6a748d04454f621a1a44664785b30878a986da9d5f87cdaa03e104f8bbd19b8872a17e273c81b220c78c3cc0363784b6527462d0e00a20cfb16e95d94236b13ec7294b4399f6a0e4836808f1a580c5aa5958a168ac1fe59856194c46e1d55ab4527f9ef7ba51744f232f29614f1e9086905db35284395837cf80c9a30f4a07db78654e4dba2370e3510bc317179509bd99f1feb5fb5514316cd8ed5a31a158e1da4e0b4e09c646d17636a556ed2c4dd7ab9433ece0bea3a610ba5a601123161eaab37948d69543b853ada7fa30b420bf7daf2a1b067c555d5ac5f253753fe7cc0304519c11c3f84a27a63582eb0a839c161fc4aff588b044a6d7b9c41d743870c191259c0bf55ffb1b99406264bc1f42fef276705aed3f8dee941924125f74b69f7dbc195090f0c0f4a713df8d1453d59e9d6e7a6b87ba55aa47ddb8ba7b037b993c11125500da83abb17359518fe28971bcc02076cb6ba5e731105abe011470bbf2a02d517fa3ca6f9d9996f7bd3ac17e729d0894e06fc0ebddb316a26aa92907a03fd6018ce91c5b5e535943cf8163fe5e4b40d42f7c8c5e00448b6cf9fc2451748e115577a6f4520ffd97219043a70f39a951abc09969225ee49d5479d42b88fb2c71c1766366aad9cef2192ebc450749979ffef0f4432a571560c93e424d3af4d8c1e0601701fb577c03eb59d729580d25598c96477d542db1c43289272d9138a6d67e612528d1902abe18a03f50214093a34201a7c84c52e368054e5b85034de163551e63a9858a9b77cdc60386ca0c6192928bd3dfb6101bc57d9d950d90ff7165155db3fd24614f9124d288ec065e44acd15a00ba2da4cb68c03cbd0d35f1fcf99e41a4fce0fa3d6d7de26b84a7f1778ac20de54f17592c031298776039e61b6424a3e78744d067fb7066c8ddeaeb5a710f926b5b872250be21e5f02a99569f868733a5217001089eea15871e26a47fcad65d71270bc2f5491de5292d6ea1264e4d72c6616794280220da48cdc1365303318884857c4d3e1c96be0c7503ad524271ea01aaf715db3eb9112924809fed8f53e2d6d003e679740707fde27b93ddf76f728b1259b7e4e77060bb029eb0c99fa056970bf34fad456e6a0540d3911e6488bdf36039e1cb826e30f235a6a20452fd26f38f2f1952629b7435698e4097567a7fb86031c36d644789c66b6beb8753e230065028a865e4ff196585d720371f9febdb65a6f6602bebbac877002c04f8143f671cf732b406e011e64a724511cb8428efe12d24216f2cd3f60f685ef13286388f90ca7b5e970e609750a2542bd21c86f1d251b1f68b4d7c73d84665ab6f4505474f215bcf9286b3f23dbd93ab056dc81d3da584fb6365fe91346a0711aa00260ca0381af1f2d61a19cb6f4df55ae4b09b3ece46975b5fd5d1ea18547261048c4aec468ba209e5f4642ea8fb1a760b7c8ce33902b57331f66006218e44fc59e03525d8181ad96429502edda44defd134c49722118eab27110ee26012099e034a39f6cc77c69eaa37096fce6485136e8694b0bfa2b27f462b9515bdc69ad1ae102f60fde216edb5a9811cc8d35872135582228d187fc3e4da4d8b16c0908ea652d174cb477b1e445b81a313f6807514f413bb1aacc0a6c0fb454789df42f5c5ca563d868f25a05ea1aa9627d9c9dc8ea4b9b53cc99a4af6784572084e42652d4ec95e01ea1e00ad17f99e8b1b4fbe4235ec7e6f587be8b88e1c335c122d106854c130eb47daacfdbd2d039f5c176537b0210d8bdca513ef66e466df29443fbd4bed3dc73c183c7beb1a4c92d99c479745897e0a842c823beea095f688a76d8940c6aa564e0e7abba53f36eda9d303acfc59c8dd57f136c629920143991dff1c661868af45c460ed8b215ead6bde9e40daa9de90c2d9ab8cf0f97e189b06d4f1e2a4e8e5e5d3f3045038dde9c1efd1e548364eeb563af017be9550612f734da4953d42199253cea2674d799aa7c6d08ce673741b13eecc07236f4277618d96d2794a84b716caeca418b7bb4bd2ee1509c569e906a78e235c05d8de3d6b164421c04bd0796924c884bcf74cccdc5ac136746d0b83a8fdaff4ce1715330ccdff7b6c02cbc31d2809683328eda491ff02de6db6989cd6abfe4d9a5b3f727c06b1055f5e778b25e045e488f2c04637ba761109ad3ef6eaaefcaccc80805d46d5000bd28b8eb9662740878821b2151ba091eb9da95f0cdee2c646f217a8ac6eeae4e03df62017d43b429c9feb32a7fb32771e0445e97f1e3dd809fb25fc96c7eb01828559c3f286900d20b56bd7e5b7b22f02bfdb5df893637499b65272db8442421668a0a5c59dd1722607daf3efc3cbeabe57c54d4badbfc2d3a0f9179248a2129a38f36b76d9c486b47994e5f656bfddbb1cff66f8c98c68ea8a5eab368e8a8e12a95c6be0c173b9b1cfe336c4fa2911f2dd4ce1d3753eb1fbe59194620b18bd02004dc60dda1007e62400633edb78174bb9013db07b90f1ac1cf47a4439121a3cc8cc6b96930370eacef8133ef3777b51ac361c65aeaffe39f41421ab67ff49de746c3bda73de60df39dbb24157c9a5f852d525b6d9861c2d80e11c0184dd4f7e377e220e772f7365ea4c9a10cdb0c4584c1fc6704ed7ec1095c6ef814446573814b0dcd543681aad66a6bae473942445e3bad2138a0e5cd2a06bddcd55925b1662d3ef6a3e4abaff63b87c731e07c5792fad29809a97e2b13292137b5800ebd44e8129ef60b34975d9ce45e120544e4981371b338dad8455c83264ddb8036bdc382c394e9d8f49f684136d9a21553b038d8904bd6f4cd0887c0e3808bc734dde6cc4bba93b1c45cafc8bf3488ecea6590936709712eb6278e767a3e695d29247130c264d2f2bfd686d62eb7e2bd4c6ccf08b2ad4cd9a2894f28059083fd1f149bb4bfab719a0bc9d12c5e5af56de5b7c6de4e9ad30292f42e275ce4c9c992e9da74afda68c4b85a1f6da787c916eb7c67abee6d12a2a02b0fbc4a16d248a62d9f58c67c266d12e9521c25eb3e8ebe085dfb35deca92f58bb2fdaba9e55eae63370cc627312acf715d8ef3833e548701a86abd44dd4ae07cb8654fb19d2e4e05d464d45f3efd5ba63c3c3d3cb47c37e59cd08cc3f5e1a1636d734c35bc58fbd058d9b6a8e28b375cdb2d6f8d8c14730153c17c515780f2b907338d9babbb2794cc1ca523fa713a43b46951d59f2097b8d2e17330fdb5eb1b0f5457d923cbbb65b64df0d31be6841d7891df05395612bd47b6406ea1a17f28a781e69c497f0f7236c457badc176a145f35507cca2a2223bf957d8c8bf27d449b5ea084db005fa55e9241c59e790e1a18492a3e913c46e336ce56d32b43c960b2f27be8436d4a9bff089364c93bb8d7621ccf448d1b6f6f5f739be92b3be3a260f70529feedd1fc9d57624f7e3fa49652337a524c2250b25de7909d313309445c9e929181e6275555566d88df11c2e0e4bc02c391c055555a6b4ced7bbd05ab432349fe42cbdcaeda3ae6814e206c7f08fd2bf9a23ab42a8e817b215a07b2ae8fc9433fb8149a419ac91bde2782881c517f7e27c7cfad09f6ac5c02a8f3d17df390aee2a29a341a97ef65828f20ab210c891612c0769675f0704e7a5690599f8c04ea625bd3e1c9da0dc4441ada542a18f21213492e7663503ebd297e34197d8cf327e58bdb111e813dbccda5d8bd001dc0930010dbaa9f4fa5f848e113e478bac099020318a15811ab1a4fd701bed3dbdbb8a089718abd6d22061073cb32f5024dd7ec8473095a5f2a72511743d894e77ce1d1f4cced7e22269554fa73d0b7c6354c69f3276398171471f2c7f6e7329d015993fdefc4f836396088043ccbd7b0da26d3bde062229df61afb4bc5fd598675add70f71fd9c5da562171afde92acc6793c16d654e9ec697648f302a2f19022e55a9d88cdf824eeea213a98170fab85cc7b2c22fd47b81701fa09bed3645d28322166afab4d9cd103749957449ce3d5359db8392f9aedf540046564ad84d5f8964800ef7c9b723b5c1de6dc6ae62f44be224a65f76ffbe8634e3db46aa063aeb5ec06477e00ed6aefa16f497865f08d26110f68b2b7c0206e298665f654d6b0472b77c3e935cc385683c0fb4493ebdb4c63e13f9d0558988f56583f449876c5312c48995ab82f7c4f2eba7f768a6df92b75cac18929e82991816ea71ca1c55fd403aec5d5bbae31dd933aebcb0fd40f791108b4326a0be1a0a4f452a0b910542060e0236b41acbf5bec9cee877622c2818bdc21a146477ede692f50abd14ce0fe8eafba5e52bd000cc233d7570557d839c04613804302220f6cbb20bfec37f9be0367bd6807fbffd55ff8be49beee6ba9ef3d65c63680c721aa167296731072ff1e26f60bfff1660e66268fd6b3cda71f1251b796c22d947b37e9a529ccf4f4509dafc2cb0eb2bf498e150d9bbbd04d426a8173cd0c0aa3aa8bdaec8004b51a3e809f96a2473af35e95d4dbebeb0b24c963bfbb940e89b401ce04c8ef22cfd5a63b68fc93edb71dd0fa77924a56e6a35ed369a7a7b8db7e7b904d167be4510e501f3132892aefb0a118ae19a58bdfc470b4554a2436c23fc2d43c6c247afecf6baa4f2554fb2b6c26f2a2eed2db8986143676d91aab5b74acffba91697c1e171a73d97b43e062cde6345efbd9c18cbb93573cccfb75a1970212382edfdd45ca94713506ae3a7c8552850f9028889aac336b055911920ccb3d35197ab02e2351c01f638b194ffb355f76e7eec411ad8e146b5ae1d74192fbb060cb1d4cb22d38eeb0df2da79fa2e06f4a25f02292e78eff9ad380c2f8c47ce0cf016f00ebb733b9f4ceca85cee9719fd86c56827c8a86b59f6b6eb867254de4d537f2049c35675cfeb619f934a84cf40ac8ce64a47d755f7d23c81622e0deeeff21ae40766a17c6741c576108ae2f598051d97307475d377de0bfc5e96511a81aa8d2d4a0b69c4e8162c0bee6963b7360b4433815b62781e601d99f1f9a14fa00880a852674718d1ae65fa3504c7d4db64b61cf0528bd8ec7b38314028ce92ca11a42a848a141d898183d03d77f15df53efcf4ef4d7672d23199cc64d46a36a6cc8b6dc774aabfbda31dac7f0056376e6a533b0fb5ccdd69246d21f09b9c9b30bf665a527a021bfd2579755e6e9d14c3db966dff805a14d2e51c27ab3db99295eacaf0e82e38d4fd43ece9b555207217d7c6c4df89818d1e2d53a6352a7f1a6a8fb34f082aa311a99b550298e0d9e58c0941a311a64b54dfdcf7cbff133a93b1cbff09738974979a38d736841b473629054fbc999a8863bc451b45852a67eea33fc0482bbf122ccf8bd07239093394c2bc4d2141185467368959746b3c45a5d235ba7607e862401a7b1062414e34ae117272a4bbb146ed1d70169562f5cb85ba2c88d5936c979a1c0b200016dbf50b133ef5ea4db51e9dc3de26110773557a589e550658a47ac9e8a6a2d816cfa83ee22cd51c7c8f50a09ddae3aa0d2ba0962303a1fa2afac1d65300010b070fc5edf3f35023fe0be61aca65e1c792a24115ead1aaaa0262d64ca752917210cef63997368e1bd3fc41aa2beb0937d6ec80ce96e2c4c503aa91b419041bd5a8243d87edbeabd9fdf2a9f2d4784912bde74772b30b4a92b288eff8f402185925a90b1c66254e90fef350bc306980e1ef2b011fb627315bf8a7b99b8cb4fac938664c3653c43f87a2a2577ad3e374495b885695561eaf2d16c18c390c518cda24b51e56d798d543baf96be8e133eaeb3cf162b207bce4bf1089d05d7200f84ea2cd88e5e9a9c8a3af9c01e89c80cae23958a081b3e316033f4065e807ec814ffd8120872dfc10e7bb4708da012bf363f61682360259943481a98cd0221780f5271fa2eb4d702780e79a257a1fda40c94381ed61c2ec97c264aea5d8073787721fe7f8f011eead54ad1e2c6b47e04cd4441773f1f045dc10f0a7aae01125a409d2884310d088e92d02904ab956e5598558396271207a8cbee8c240d1edc41ee8d0c3a094fcaae43640764660d23d6ccc56641f6390003d8d1bccd477f03c39cff9b471d124198f69d003fb3b451081e282eb5e7bf48094dc3be3265d38ada3d19873779a2bdd5281fc24c2678667ed377aed110884d3d2484f18817e8a3a63255eacac318ab47a795de12b130f05b5baff922abdcb461d3ee0a3c6653c30524752daf5fab86ebf74920f700470f60761bab05eba628c49a128805aaab4bdc8a529524be1e2146b1eb5ec57538c3aa2c6123dcbac4be1a65bb928b780decc7802068954ffae04b7eced595b07480d057d0ec123994e103c6624d1cabfc27c222d414fd0c85183d8ebf8e10977caa8aa3a0d845c362d28d8c074141ea3c35389e35624682a47e7e2c694b8b9e67f870aac44615e5107089d7d9b99e216b657f7c686a4d40a68818f73abcc862435c121decca425a169c3747363e9ab7bebe5e8e7efeea741af8ce94307f4c737fa7ef742fb067deca8bafafdad0717eea8c52ba877c9d692600121b939ccb6d4d14fc1253970836f65e88785d884469ae9fff693143e2b60c86e8bcf78bc6958537b5067b73cb0725680736b2807084e39b602db89bf1227eb08b13b2cecb51e752540325a0b0c864bbfb5a81621bd4bb7f0f7fd943e3fc92e282038d9d5aa485f1f04b73ecc271a8982a6f909bf1dfcafde8242b18e0d6526c98e1aaaa9cacfb2d68f19b6732d422372d6eb5a9705c72b168dd62a67153581fbb3deec9673c0daf36593bfdbce339801cff2724ede2198028fcda0f65f2525312a034ed73f9de1e7491ef8137bb7b593fe1fa66fc2e6129bb98fabdfab90a8e64846cb230795a479b3f86c78a40ffb451e5b105539c69409b2350a4243dc30e15bd7090aa3aad5772e66bfda57354d189b9acc963b129a31e8e6b19eafe2aeb608b3946551c50d8dc5481df70103f365a98e688a6ee41cc7fe6fcec35103e1127d7bfdb86fa9b80c669e0976784677d3a773b7272731424342e7cf0517d218f54520b2455dfae1dd386efef6dffc3438cea2d097487bdb7dcc56662e437b89bec7f4056d4a93cc10543246a120212dfcdd0f42783adf45a88d8403c3de3671ff4ae367cb53535c0df03e77670a155ddb7657946da4fc0f9ff524362b6d8569e4d7084fb23060002a992ebab25cf5b20ea39deb33970ceb09b7477198fb5998e8a1702f13299782037ecda904e617d1294fd336e7af01a72f02f420a90a21628a3018e80925fefb20c5cbba8acc8ae92a9d0c6ceb876af76008704905bd987371d6178b78690337307db6016d68bfb9b7e2345d68644f0437320f3f4ddf0734b0ed6503a8c31b54041fc7c357cf29ab57a24c39b8ee5f949a049aa87f6810f4799363502db365b58824fb59cf26504334504073ff4628ce99ce284d208e616da6fee03e432f32341bad5b62363338e1122fea4521494fd72af39e036f190d0eaedcd551ad135a778dafc0df1537227fa5f43c50abf8d7bcfe67d453d377695cb9c82e2208c2e596b02a9496080f0dbacbdc924c2e2a95f15a4a9f3d3d6892b8ffb573a8807d2b150b6a8e862d2f177fde9b55d78a8f72b646bff37f9bf2f8f7851cd55831b206372b9c67a79f32d4851ab091d5b680eb5c305875cb381d69b809ff54ce875a150667caa606d07b09c1726465bcb6409a6027cf1de3517074a9f478fb111c9fc107fe06486209de900c8e9797e1225e935a29b9f7d17b82ace1178c81d737e4154aea2343aa73e7f38e5bdfe26d26b891eefbf2b57bced9dced92a44a0661c75a91eb83356387441c7910a7e0c42d00e2514df18e8f475eb989e6eae1529216918a9db7ea18295e7f8257bdd956c654dad6f1f34769a316c50c6d52cdce2d3db72a4d660576c7b2b31439cd9c1d54a3a90a6e097f6d12dd7218ca21a5a0b3d911277cea5bdb3a0cb376c7b8d6367ab7f23b85a2fea44a412b47480ece3e53129c76d2f1b625298474b2e7981365e7c60feada700fbb8d0353531ff24cd18c76c526a005c7907388d3bd183ccbce2b7164180a7b455f11f184fd83d6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
