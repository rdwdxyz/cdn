<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"429dbc60ef98af111f4627fbd4ad4a694dd3f2a562bca6cffe2721a963f8a81e3ca0a8d464b9a73e02b0e71625a3e2209233107748af34abcd1f729fb27b0dab461160014fc9164fa61d3fff9856da31d08a2e516b62dfe8caa6be48f4f51583a0ec60e6a7744db769430fc8b4736f173f836c38e18afc323328b6a1d7cc87f672f34b23bc1ee8480d94bd4daf3880e481786a4a0bdb051908ed8eed1062bb5d2bf9430b15293ee65c663b35b8cdb0659c95c9579e3fa1bccb4d07cd3044963807afd79773010c841f67920b554ee562c3a7f5fe901194896d0359d3303977c03dba2ccd362fde7677337cfc0165d326eab44f09fa7dab0878cf5a9cc7bb7cc31e7e511b25dc6defa01de131399db51db34800000c45666b92cd57a55f3e18138203e1c9127534a0474c1b3cc457dd68183d29349448c3325bd59327d075a9d132db558bba4429d32d253c6941961f94db3bf1055788bbab047955619e7b9d9e425f96327a492c72e42649f078b855d8fd71cdc1c277c83f0106e770074af3bca81bea6d229a4ffe2ca298a997b9f6472b3946fe90a6323ad0768a0158bc8cfa052adf007cadf557e094c524703c67384ed11504a363f999d4ca521a0e10649b130e920786c4879f2a571eb268a0f6331b9c6bdb2b43e7f1d17e91bf9217062e5b86922ac5c15f945214932aa6814b8c75d2a2fb5ac7a889045264a415c29f23078eaf05dc57082f1e8e1d6372b8348bacb08192514fcf4813c83884ee33f0a10c76704563558fc3dac99b557334a978e9328d4728126c5a798118c10ac979e76ad59649a7cf69cf4de430bbf27a447201711b4367048b1051b9def999cfa0c34524b7a6ed24ba7d818109ba1cd2adcae6aa5389462b9c6be1819c8cc64b6f1e74411b80d7842e31166e444ff8120bacfe4040b9e5d48d15970fc98b6521e896a1b47ba87cb128da5a7880113c068afb380674aa4daa548a046a7c202683e73b1fca082a32e592d1a4d7c883aabeda37026aba973bb635ef95c15d50411c56311cb441a796a4707175d43f1b1b5967420f8562609b8531c2c5d54e2a0443c849571cc813238b5bacc9d47bb01b520b7ce8235f4ceaf0b1da20d612608b7b2d041df097148b91954170b6f8ea3565085b7a1bfc86b7df5486a0584c9a9860b70eaf2d9970915885b30819826fd253149c66b67f4f777376ccf169bf4426e79b7fc8cc6450624d52eaeef557cb606b9593b020df513a7259bcd9d625c1b075632537dc632a8410c49df80c8f591e93ff3416db3f52b135a5e04b9dc294c05a72bc906399444a65d7ef60cb571729c4aa1caf2325677ddba01a6ea151596963e2baea741d71f32305da024adb6bbe10d136b59252b8ee7f27b35de0514cf10f1334d57e2a5eb60b38179af994e11d50101d4697380f09aa6981b769d39be1125714d20014caa997801854ed64abbdc1213ba0c88f72de90339eec751666acdd03a137908bee11be96cdb2ee2343fdb66eda0e954ff518b27fd05a7fd35cabcde39631b41e042eb841519802661efe5580c32f9a70e596e187a760e73f68fdfae0a338e59eaebc237ca4d55a70764c1334018a95914193bf343ce7657c42e7332da24efcbc7cd162269d17042fd9ee73ed2910dd89d0ec31b0860b0b95a5fe481d3a4a6a0b2e82e07f19782da1850b9415d42e30657487c4aa5945ca2099d699043bdb7d8b03f9df047ca5bf71db952385c7589de0ea706664f319f1fc81ec05a981839d72a28722b048439b729d919041f61de2ba311ca35e4ef98e05fb40d3be640ddca08efc12a63bc5e03e2c5409ea3734c40e97f59e56ea5d4b2de451b9cfc4ef251fd3343f24644ffa7d112d37113eee520e12627a0d614960b37c9ede731b85e58476af97e2111c35237b954affab559978577138b4aec167a6c6d95e30ba00f3e5bfe3f6d5ce8374eb660678bca1507074b692e32093b6b5ffcdb3d1d34a40d9d04574d13fa122857fd6e871165981f22be42960e56f3f00ded442f71dede73a6094e32310a6aeb97ba1f0ee36a672cf8604d022d46f29e7b93357b30e3c844635f2f3eebe5dea24e8d7a3a26e43766ca3aba9549acfa9fa991510c3c966af072ac9837464b8ca7979940f31c4464bd0a248f71a53ed4f2a1cbc01751cdaaefa76c1c1514e5c73dc3e43b139b6cc81b4c09f2b4c3cccf6423ddaa3dec7a7fda7dcf8eb0d069082ffa28164c4edc84895bc0a1489d5d492d10a4438952b7a7ed9069fdbad699eb585271bae9215135087f4767462ac1668b1c628f6b39b08aa07bb642bd09b4145f076ed2bf8c4bfbdbf5340a45aa1855ad19ad7ebcbea42e3dd8200f06c3f5fb4be167af5f8d9b358b5fa66a5972463cf7377835163020b1d7b28de1a6d798dbadc4f766640c3e67eb23f56b128dc10a5b1397ee71f206ef573c1a11e271da3c0bbc57d7b482e6649eb2142250a36ecd3aab4be3c4043316f1df395b3cbb94bd6f06c6341a9bfc1fff588c303aa22183f4d1ac648c42716d27c6d317c34def3007071691f1b60c7534ae5fbf92935a5451ca653788714996c07ee18d4e508181f21b31a61f8b45ad5f60e57588d5b172b58e06fdda0704fa991b3393e37bc601b87acdd84b0c30332fddfde6564776c1e060e41ceb5936e9d7f30183c43cf7969648be7d9521531084d6f40b4ddd767b3d338bdc6699db1a5589b25ae532ff99b8eb44607294ff4791da6af787dbe2d044d57797656db3e1f7e97a0a6a919bb5b5e9df762ac4e217cc7ecd1072f2f836007d17a0828bc6004116cca9df1b62722783be4aeeecfb0fdc30740bc9f54ac6dd6e2a0b3c0f3880b0fe69aa9675ed7505bb6cba358152a976727461044a71a3b64fbb187c0d84384ad304bef0e75288410c063f6f2c7c0c17e52e4d0536d2c0f3fc457463f1eb84041bf62439533e47ae330eef4f41e7f4ce6c98a2839f655df8a3276c5d17c85fd279c2f9a3bcf57d53b107de25dd8402b448a332f8021969c65bc075b477733f29d2fca1e4e6d3a422695bae7da0597136b65e4960358a3da70b92ffe612523f81261fe822ee77ff8aa68d3d59dd2dfb3097189a0bce7250901f6abe3c0ec84bf15edcbaa61675d574d31e818639b2a450abfda154469fb5f8a1184c0f42d9b8a5feee51c228c25e9c0d409ebcb626ae7f07d4ae22b1550ad006df4ccd001545288e4d095ca810b0666a4fbcdef9ac735177865b76da8e9f6a35ef7106ed26a88358155c52108aa1afc2542cb72731d65522b98da84a6d06112209ca0172e3c231763f2a84a0b0583af778a08ef6700b0a1d2bf14bbc6780a4ebe13936b7665ebda96e2054e2535bd7b8a5d348f6a2c44cfdec5613578606052e6aa9e0211b5eea03e5adc4ea449f24005003c69e7777b03b510307a9181897fb297f1ee8781234fe2d164ded5949339523a01bfaef9ff8a019db4e127e33b33e2ed59eace8daa8fd0e9c48337cd7253c1d93406e014fc34c5570382f4f54b936ac77a18fd9fb5ebc0a76004bd100a8f6d0b2e2220708ed498c12156641f44bdeaf0243996d947ba1cedbb77b35ad90cef3bd1d24d45ab997e41a9a85067b7edf27b55c66afaa4d87c9397223156dbb7fc43ba9a905ea947fbe134c0c3b42b5b034b686ae5a0ac51a27510c99f55050d697a7ca8c0d766995366852ab2c90b0ed7e65cd01861be7e805f2ad4c40589767885c21b98607182051c7376f5dcee9dcbdf2208852c3adcbb70b0f7554576fbd2c4f71ec000c19608e9e40206c3c7d18e05417b794d6c831291642f6da061098d9a22e8876e7a8c98493ff55f1c6919993287c1019519c13db53475c59e657b44fe21a2aa0518350708aa107e815a94766ccab189a5b1fc7f9f9d5b5a30b96fb46ed86976d153ee3807e27767a569193d301b5924b1020c5d6e9b97490ed447ce67568346df22f496742698583024ca64f1b5aff00501e2267c84ad3bac80ed832ac05b1b4467c720b1201c05af3e9dc426f54e6069d75f2c0128100d80a2ef58400f5433145cb849293ec54c28b8f8b721d3f5b92acdf86684623ba3d5331b02cf307d678c6085275de9831592823c4add132418e45b902057a2a88100f74a2a58f4fca19a0d77d400e03e3087407633f1af3e9e138a930b014aaa16056be850fdf6d80404516f8e8b19ee23ca877f300362501125333bcac814ba3429669f31fcc12418a1efb23abe4bea8490db8d24e98da98f48ca14fc57cc81a3b794694a59bdca6545c471627136712900b990ce7b1f02ddc7dbd5dd8e82ce2f42bd9a174a464787264ff6cd7d2d7b898b62dfae20ea0a135ad3563bad8b531512b491915d9b4ae7482cd7934cd3fe0dea289188bbbe1068379c72294379a369d8d15d13bdae183d5c88611e736f2b50e5d248758b373e019177009d1cfe7e31ffafac15748d46751388697ab37d84f6db33d86ed163e529da6609dd7ee0d27f0834606f75bf6c2b2feda1111e198dd8e1b8655477140430ecaee00dc4b9879e61ee42fdf690c1173f6fc5819d3d54f969a7a596165ee02729550a7b4617348199c256faaf628cf378c40f16a63a63c0194622e203a7b7378951cc753de31ebdd506a77106c5c413a4e7c4dfb1b0ab44e0aa14f0e9b4ae06aeae2f649b005670cbcae203db1a9e735d49a54f9e1126de70d6a424373630d17752f596a73f5ace7254224f442943f0e492519d7704f61066f84a13c6fecb1038b8175540bcec93193f7a289fae78650ee0f094de9d7fe9b9f864f142d81402f67b3037e6a97fad0e33a86b7577d8bf863093f5de217c30f6c44c576720d8d908be6fc9ddaafac4db72f6f621597f68ab79288ad5cf9825cd389bf799614ea4a86e6c23b9eed62d1c0e752c39cf894652fd37f7cf97d0abda8d640ac2a2ee1a175617a9c82b61b75cef575aa1af848ee0f7c64b098f47fb33b5dd362592a85c2fe97a47e3ad8fda167baf9fb323f616fe2f6639419188d15025639846d8092ed5790e076723a78638530c533a88e904910c9a2afff977babf522961da3a7351bae02b4c4ca40ff43b33c1e13c31377eef4d07480d03455f644925a8ed2ed1bc4a6d75c0732aa831c49edc222170bbb091558292b5593dbbade3684f3d94e6b79bb13ab8c356354e77700a48d6434c2245e68f2267a3e60f97db210bc57d69e96be683091926acd2580dd88b5c45c8cad8451631449921842192dff6f503dec97bff3a89c8b105f7471052a333d332059197cfc50aadaa0f07b4fdb09f5e566e7583fc1469cf2987363bbfca13bf27e990b51b6d789e0ff92609d43f53bd40b89d4f149bc79d1ac6587531d875fc96385c3cd024f6ccde16875e466dc58cab9fad1a32315f0f188e52aba1139a029840e9249c978887eca9ec2519ed656dd54b83d03c35a638ec25e8207e3a4f485d46ecc5909189c6a94e9477882f24f00ffe49e6de5686e757f1897cfbe7acee64120ee618091cfcf2be959ba195473f0f84d19870a9d2f51afd9759b51af3d2abe1f721de92a9d998dca78c9efbc488dda9c4a66c5dd4719291f88292861b5f4e6a4022bbe3f192ed10f664a3d41e867c5fd2b10d1627427a080115b23f996f4384aa9a57b586cc8e7a9ca3d34ee16add82571b4e8a3597a6859310252fb567b56b27138b3b6b954b60f189b419a6079c5179b9796b6091945367c34fa6b459ff06216105b69e2d64b0901247e1da67a7eafc44f40187294fde3f4db05129a98ad7fe77bc3ebbd1ef5a2db47f7533f446f5e941b5b64fbfadc9f4f3016e5fa780fd34851dbff821335b0d2b72ace73a6858cc56f39f0ef7b7e5faa8485030a33e347b10aa2528588d9c27d423aa006ea19639fac20ba3a7ce6610ed5aa0c29bdf3f5f2e7871bf8c635649677a3774ff9bae65360f33dbae54035a93ca4909ed10c00d4085d2e059da10c16bdf97e7c1d8cd7d9ca5b3d3e232b6644eb3a12a14c4700da5724c073a592af3b076682c61dc3eab3f071fc646af089da8865d0158ee8c25f3787342339fbe1f1422c51b17e5025ac4e680bad23405f9f91edc5328d8358bc085cf877aaf4df4a31c3667b4219170ab3247f7a8de4bc3c4cebcf0525cdfcc6f618576052bf750b89c06f1d9a836fc0bbcc10befd38b9172b1d5533c0f3d20f89ac980eac155d4cccf84c4e1a4015323916e9a851fd2605720f10c78f1eec83195422f3bc90a32d57d48d0a742c5850ac545a47264dd1823373ca3a30551ff6a5f1c44c27c6f03b545d3476b9602f782f87e806a03fb4d725c510997e8877961c68dd2bb38d1452ba5c0734f045adbe9759cdf978f6f4798773d120c6108063441fb68822d8071d97897f00c0afb1b766d9897e7d917843706c08c7cdb1dc6688ffc0280819e68aead1755bf5dec7380cef227865faebf99f8f7a3e3e46444d6db6cdce655c07a2cac5a5fade03c9776338d73754ea2d2013b256f44d68974ef484c6729720d42524131b2a805c2315cad7604af6c9749123e49a6d32cb01e7f5d759f1958a7f7918d3069cf29d86e41297f77661f4d6a891449bae7d125ab2bb80093f1b0567a44acc77aebac10b84d957edd42a87bd6d8f7f7eb15623dc01a25e9f7c70f7fad9db0794268b09544fb8c718da6475c90f9dedaf062b2695017446e667bb471e09b279e0cbbcffe5669c9872a04c137061c92e52abf69eb300298850c3f9389a0ab109b7304716901e2df242f69bc7829218e80a690685e88ffa274ef80af1e76e5d85bfd53bc8ec62e529339c3de78c685f498e6cb28be247a79de9395e81bfa8cb979656ef126052a081048641b089e17386e8307f262618adea93956036762b84fc0d67415239e8cb16ba47503a7b869ddc8d84f8005ed652cbfd49e2c1a515b53ca0445e515d84af2ac85d880f1a947353421ca62a427a62bfa76c553fd3ca97e7459818b7dc3985b5cf5893c3e1557f3e0941881e0de48c8a9385ead584267005a077f218be9b3f220695410142d5364b1a6e96b4d3db17b4ca9101d8c2fd25b5ce406f487ed74773714b8fb9148bb8d3fd0309fb3d3544dd645c72e9d17091ad2c12403c8dcd711bcff6899775de15520b8bb08f7da87ebdad6a726c301ed9c2785d2ff1921c556b657fbf8781fa08d47720bc7cfa1b85d5b6acc0e1472b500272f2fc2804522d5501be5600d3fa60ac5fcf5d4ec9de33da0617d64832cd51d0e1c5900eadfe4aff4ead5b29fb5eb64c5aff77f5dba2b5efd43258b4394d25016965549fa4a3913e882b0fac32a37d3f524dbbab53a0f5a7f10c8fa5f53a74cd7ac168bf088526ef5b286c3fd8d48c8ce0aadcde010f74e25429c33701872344cc66fd862865f5a00dc961c153566bea2968f1ef7de7b7b62bcafd295debe39d615142158ba2ed8d5f601c91b82a8ee8a3f04e64f77256a1a7486b5c76dc36ea576fd48d937ebe92053ade55ff2f17eab59308803a2190ffc3b7ac7d8a9e6a2c175d3db76faf920c0ae61439f8ca91a63df2c0eb01ac3bbf7aa5beb71f93ca107167a1a93a3720e0297dd4ecacddae7f423cdc8188a3158992d7474a4f421c5d956466dc86641b742b419bf4eacf24ea93afd70085844d4ea812a93e30817dd51d6e2f1fdff23520712ca2164662699e0c4ab39b545d5d36bd7cb3a17a67bf63f429acc040932146a0038ef784baf877a2aab3b90d6c09574afde997c67165bc7b98bf42f55c0b5c508112da577a1c22ab29487c1da9aff097c7d827bb97a432305c91161a7ae832d57f812586baa81b8ecb31b9c0f26e8e0c9af5e4b10111bafd483e219374d8b2a42966c609eb4ac140a4309444cf647a836bf4e224dbdfb6ab81d12d2147bbe91259b1312af5903cbd57c70b3eca253d35a54592966fe29dde96e1b975b68dbc9b225833bed52ea20cfcb381fe55cc29309f01d38653b3bb844cbb13c1cfab6af1372fc6c647602f634b57797a16cbddd9591140e74c7abc25f14c8b965ccc0705d4b505150db880ef6e3e1e3d0d96e2f675e471a352beb6a179c05ab2af26aa5834bb65f04edbee5e996cf28c6205f5e1b898deb9c6293926eb501b449fc7043c4a3b9231cdb6ecd051390b4c8ec40c4c7fb64ac69d0c2bd2c2721cf78cf0a31d75328a3650313457b251c1aa8986cc1b41909b7cf16ce7d2e700cd93aa0329b9138935accfcf1a61bf981d9895b2a53195f94a3ffd5057d95f150b4c2cfbf4966928725daeb7403cbf0ea7cdbce476e49fcbc1e6d7b7c4a3779c7df0bde0bc24b6e49e3aa447c5430d29176a263e8e41987e1a343ae50b36b856be1d237b3a1019b7538dc7074ee6db01fac39946e14d8fa5ac4052a9767beedc0059ddcce0d42261462a5f2dca87736ab5c83a7554573a3e0975622fcd6e7dce52e770cb6216edd4d6acddb5c7d7bc1ba080fbed5463cb38b7955b05db3ad2be1a365bf85224b1e4fb2a332dea27e7d8ffde56f0e65149f81bcd1b61267653a3d7bc3fa737810ed137c18bc00432fce99431898e045db5e865e6a75bbbabb6a4398886befdee4bb643a81962fe972c3ec35704a0af6e3e69ada8ae9fcd05a76ac02331209991a830906065f8e185400a6e3c6b1b3119d2faecbe656d4c7681d8d92100b12b006689bef1f4ac8af0b5830944bdb603fd1df6a60e7cf677bbeb6f74dbec38f64a1d1eba1d5ac6080027f0fc5309df6218d91d03eae157754b9f28eba95577a70127a10c3b9a7b87a6608f06263111164bd234d787905f21dfcf0eb82aa1632334138919a9e05cea5e7daa554f4b2f8b79afdeea7e5c9ce328f0854a55627203efcdd2335c1aef52296bfbc26b331f0b818da0f666e7fb4deaddf1ccb48d4a2d8d16d2116df5ee7d2dfdb4e0d06383c393082574905bf728bf4e0b5643807c84a067621afbf67f464b0fa8a3bdac4a085903ee5c29fb529194eb845d8e94c0dd839ef42baeac9a2418d33b53870d703d42d9a8ca954cb9b3c732f44f46300018b7c23a97fcc420a7d51acb9596e177c43b9f74c4cafcdc5c429857946c4e20dd30acf701b2c775cf8cd7fad35db248575a73f77667e2e68ad05ffc251cf14cf5750dae2f2e43b3fb728d41c128fe375f8cdcd9708c05304c5a17c788902a61fee6dbafe7d5db3a2047c99ef51c49bf8af8614d8944ee54572d42a30b507cf262266789c789d32cce8fac815781eae18ea2264a069d72d3a1071d87330c00acc33a8aa729194cf17014ef84377e10836219f6e62ee21b817f88f3ad9f55bcfc7ca7fa100fba2d9d4ddc5a8d8de72e0a7d3cb2b8fc2ffe0698d125347e7352c0a4c07690659891a1a0080b4c4eaf449ae7e6ac3ae38aab881e86d96336a05c57220826eb8566b2ed482fb1073f8d87c3b6db1c9069e1bd68a7c32fe0babeab95e8dcfc33cb30223da0ee9f6ce78f785b5fff3b93e7cbe59058b763035147ad98da58767e69504c3cd7d444b5ae2d50a3defe832e92995ab87fe7896d1dfcd1174790a46e4895734e0d30800c5a3ad0914639dc17e774e990c73fdc7b5d399d52609f8e0ac95817099c0e0ff2d2c8814e53ce42af1f50d21f02bf24d01553af880a4420cef3f9be37a211a24e4ac7293fd462261ce7afc2e7a7a316fb9635d912073a9279bafa84478270b57ad4877d09da11c7f78478fd8143459a430983b1f318a7ce67ec3c87c41bbfd655df5aeb68ca326ad9ac9fdd4cfbdb839e74b358a6ebe0ab9dc9f6227db6b890a25dcd17949510a5645bfefd58d15aca8cb1be7455369c77e921040416c1c069fbb706d1e58e85d09dcaf9e919dee631e1d8afef3950b8193ca5a3281e1c593a6a0fd729c5a47c4dff9f95e09a6ab68f4089a2b70cb923341b261ff3a5868c203f1f8f03c9717e4a5b491fc7b3ae99135646868d10fae67f469a8d599420ddadbb349ac1231cbc37c9688defa99c45be18458a542e0ffa279586ceda23515d95ed3c6ad038cf9cbf399c65c084239e1e822c2697adee2626f844f99b99eb0c5c5802c3926fdee85862d196006308d2735c0a4198e6ea63bfff84fd42f3b7dc608e3b3c0aff03b03a5a724da74d7938be15a2d01345973201c84ec200bb5674f935a782490caea6821d94828f8da200fbcd5a678b801b335444926a2bf1385e7733fc8836718370c6f8b28b6814529e6020359cdb06f137c62a5ce24f2b124fc36f5741a6465a823734f497933870f57dbdf7940947bdab47fc812dfc36ca11e7c3d4ff711517e527247ce52ed4cadc1e6803ed108937cbaf86c1c9ba72b92be9ec659af34e6289c14f932459bcb357959eb915045c3c31e6d2896fe66c11be762d08442d665a52de16a5ca539d00ac8e9df04353ec168d0aa477f69fe9c457986be29989e542c5007bbb87695da13ee98beccefffca66edd5b8ca36fe44d81fa053d161558e8a4b15a32c07fe05990190d9f6ac2847c63bb9f648681fdabcfd1aad88485c56cd4783c33ac7e67a2f1a835df585e29580411ad3de3b2f5cdbc3f5b7c6cb5fadd404e7fba8bc6f7ce9587ae0100874567865d8350e881ca551a3cdccc9c4d3c5a642cb2a892099adf8aea6f071eabb5bb69abd4f8e8a8b198afdaa6e580c702b52b85021947f696a1f4ae6b9e1be236a9ae56a6b1f214c722be9701c21c7fb700ebf335146bd73a58ce411c649e88294b5f2b7638b908c81d5374192ae1561ced3178088a026c2e8dd25d2d8e70e96b087a121d91df66885d2e3295b8aa4f9d2f3b1bd99f5d74e3ea33dca0d6627ca820307829d22dd6c62bb1ec4774a326b7deae1b6321e13d9fef01be0c9d641bd42f981ef7658253813045c7fa8847bc7b9f0f8369e8de170b09ee52718f9bb8ad7948f46aa8d9e22fc8d42546f24f2eefed53539dc7d3a279a17cec2169d4980e9f7747ed96c9777d6b6222afcc996deb6ca40cc653143bcb2cf8ef9b572e9d48ebbe7efd4056c65c8deb05adf06b568d8d77ff39247b52af78607e92fabe22b085025d3b7112a9806cdec092f2811cfdcc950c40c6ffeca29177069074fd76a83df47721578e3ac84c7b82f68cedf655cbea44ed8289a524c28c52a566d6ab72448a387e7baa81ba237cd010d66b5ba8d5c97fbb12e5ca423b44c610540cf6f4e832d48c3575c0d4fc6290609482e02ec9adbba6734b38f3efbeedcae15c6399289e9c099f2a8104e1df2ab73c976768d6139a954881d2a941f289a035d3bec4f4432c68926d113d73ba21f58d31df4628c8873a12ba45ca39b7e43aed423e272e18521462d441ff282d7f20f440285ffd51d883731a995760fb34ac7d42dfce7666c47acfdfe8f1374ed0e4c5e5cbc17034ba26a8341e0a2c2cf1044e13da261be0343ef9811c8edc99ae258bc8356fadb53b15b8b9812c9e94aa0e637dc092e8bf812b42a9fbc3a0726f139acb1221f6987f51fc00acbe77ecce675f2c4ec466f468878c9902123e973ec0589dae0619d1ef1cf263186238622e725fbd23710150d8d2adedeba27192072685794c33c5d38b0cd86c7f9a16b2b43d2a7f522f1566a0f3d495ad64d568e0a7e11f496f0ba88b0b3644c165fa0733dfd41a2bf1d81504dcdeabf2771c2a082ae7311c9f286bbe92f161c51d8240df5891572a68f939eae11a73ee862d95979bf686ec97173319e357d38981d50e1c229492adf70ef5811195e2f8af654aba68df936b2ed0d28d759bdab1b2ed892d608c02ae88b0be5a93c1238386d3f2b411f41f323e4efc240098d4e48f7f2d11fdef025fb450f12b521d7823291a38711f6eca737d1c9d3b0e3a2147189ca7f20559c6be516eb269d7ae7f32d5f2f594fcb42effa019e32dbf113d9686083c0db0f01898b03bc62802e32844d2ebbb24d23bfe948a29275b71a50c125e825aa9473e32f5cb91144e42398d928ced47150c5d3fdf330b883702160dd9fbd6cea3c5b903e4762f7ebd270ccecede3e4a03659d04c7439fae8a997ff98b540755e92b8f21a6ce4bf32163f2dda6b4e8317e8da2e91330ee0989c48983adea1f16bdc41623b8fcae44dd672f8bce16ec5d8a15844a199f18b868282c1093db9e46ff0fa388095be5afb20f495600302bdf98811d2ede28a0b7711bd6941540e88103ea2b64e1d27d06c3db4dd9682b01513942da9144f7d8c076b61dcc83c7a3d7575e26e7cbfa11ae170e347503c574bffef41e9f3e0f18d393322f8c590da02e1a87e26aa89fc982afd1ecfd8d4a1e761abb8f4cc12a37c7c0966dee325fcd995482dfffda13625d72c98a5e4938679f73e1037ecc2496c8e7ad9c4bf5f74571d654d693357498b06b8534c836e4b15e0fa4d5e7234d58d83306774fa120318c664720997763a799adfea9b2c79ae943adc2cd8f07b156f5c907b0827001b112f2a41953b211d1646be778e096101f9d2d69cc10cd6d1ed9dfb2a491e3af2d4ccf9352c1dd0934c211f2efe558ec803ee8e23dc98edd929f0df1fb9b0d36c3ba41ed3220f126f5e9cf0bfcae1ab77ce5b39d8753087152ab6e02b2d0a75e11acff3d2389856163d904733c76be57ff3d8dcb3393247a45842b55a1d876120ffbe1558d2150bd3eaa4b11bb2f443515efa4ad59cbee57aecd959509afae558351b11ae736dfa7d727d7e4bc9c40b9f6e946f494d3c3e50f08bdf615600141145046c35df685f810eef715f6520fd778c6533386dfc6c903d9f38c7b8704296823567fda96464dfe3c450efcac70f688db4ffd91eaa1945dbb858422b7106f1584d5781612b6353d003c7537d808728f51f66e75d3c43b45dbacb5328ac0e477e138bc7d0ad9fb2cd483a32363d073fba67d56ae061060047cc3b6dc94a8907c62de89b9e35d9573fce8171c527dd50fb80b7ef91dcaa230d5ff94c1d3769989db4dbd330c35c27fbb8289621bdac57f13aa1660a70c14dca6d910dd45636d7c6bc2110bb5b97268da86e5d2b6b54e8e4c5897b7f74256bd9a21eb7760c03e2edffed23747ac3ad275486d9037dc1f9228e49abc2d1d327f52cec4d1316d21faea13ba436a2dcaad905574e9c8a0ad9ddf7110d55e0e891d682fcc3fd262b903a82036a99604d669b03fa36a0ff7ab72731a374631d9b4b85325525cbdad3a420040bb556ace9246a9adde781c3c45e367d04396363d25cb33714650e7cfeb2df2ac670500fbff9e7112c63f964313b44dbd2029a0075591eb905a37d1f6be2aac1a46f49f7b52942eaf50e9a2c4df9bf40c0a8214b3c400934b424b1ab3752ad8492775d9f96f60dec0207e7f7c3f11c04f2aa55c6698cd7f3557fc62c523127e73ac773b4a4891d55b0bb74f13836f6901cdac9a7afce36b535548feeb1792c62ddec4c0449fab88519c3a836047deb940f4be52c8f879bf1d053b7f513d4e410b6bd2afd6d0ba395f52b35ce6c52a348a807821e78fca1218daa39fce726d685383c9cb91abb281b576c76636df95c71312d380f31cdecac2db7159aae2f32d99c308bfe9e1a1f00175effa2bc187e4fb5c5c5aea51efa7381f7bb960911570272fb12e99d03da15556dfd7d25886ac90550913ad563e07956ae8d896c9155fc34e20d3db2f8ca46f148490be7a763a691716cd5d7d95f1cd6459641940a19600b6c6bd4546b45456ea2c70b1b5df22074f5926d1d7159d8ea68b2015493d74429b80ef5aad2225f7b9435f64a61b7776c3f595f681cf78505fe3dd1af2a7383b69ebe9238faebb4dcae0fb57356c5e2bb054340da5acb1cea3a5c8b38a8203f9d9d95ff731908bc877e513d3e4531aceff1c1c5b22f310304c963aff5c6bad7158001a3f0d2c5d6931b8b9af567cfc7790235b4981d515b1fae3242af242e7eeee4ea8af3908bbaaaefad8b98fd948095563ec6fd0b00219c51e219d50859bacf584f1e3d51c7e548b478a23a601b366136d8c7f93efb087ac8e36336a96314d99f741ad49a3bb0d1171c5505a22b960e24555a676ffe14f397ee48b6353100ccd22733e2dbcc3f5ea69103b2d4e97ea5ceda98f4dfd16cf975766594e64b351ebda8ee4772f1bc2d9b86dcc11b53893064f959e826fb994dde324d49cc63da349d97b1c2d694d7971c3586664b92665417db591a061ed5650d029294aad4369aba44a140866af80dfa7856b5a00f7c95c70dfda3e8a0da96ba21f034d01b70d617c1d52bcbd21a90f7984156413fcc1d576f07c9b5d572dbb53b1361d75d6b430125cdfd6ffdbc43f9027b0c1febeb59f33c6ed05c3729e5bb16cc439117d89961b8f97fa2b5eeac28316da78986ad5b18ff022067fc773867dbd723b2f652be85e3b958fc20e64e4720f59fe3669fcedccbc20da9e799b85fd06f17a543975dbb7cc03ec7e08cd42ab0f2765ac5a20082f9d357bc6e12de0ac8f4fdea3e738a286faec9053ac4e6de9e22acbd7f6acd2b58f3ba14ac4a6bc4ef4a30a3e16954d6a9b97ad7ea6d79e7dac588b301b4d4717acb1a7efa12e4ba91a8979fcd2803c6dcd2a40db9aea46012b1e3d2637cbabe9fdebf5c34f77aae1d36ab67bdb9d2efa0e73bd10784373623f501bb2a5616f904f21f9c80f98f975095560272b243648d3acfe3729ee113a87b88db1c8a103dd26f2969aad5054434618b438cf055a3c6e394736d025580faee18e9aed9b409133b03abec82279b9e8fb77b7aa835af4d588875004a3e0d5d889a8a3b051a2fe7f8cb2762674bc46cdcded3eb1ceca1e7747c1b85ccee5abb206a3244da9224bd7207ec33e9a0012d72e72b2b4dbb6646630fb28400ab43216b0993e44267f04646fa214625822975dd8c4929b92064078d9925e41e0845d60f57084410c70246c2a0d274f96feb85aa304ebc3026a2613e08278cf0fba6281efb68863580db33a6a4814b67d9c8b6b9b2248c85d02554255e25a50043995ee8baea544e700d421956242cc16f2a13d4b3ff51fd55b5fa96899cf30ca5ae7c2fb3808edce9fad05b31c26deb0f604e174eea6d8a44b9fc9a20c5a2869338dfa7605ee1c97ca71505de88d25990f99352ecd20fdb20b642b43cf69003b6f6514c170d862d2e43ddaa3d573be3e28354a0e77bad2bf2cca95fa7d45ab921c871d0019b58f5473a765f3487fb71c1d7dee88180242086ae97c73f962271c7df66a1b2a691c888042d1238b6278fe5c0bbf578e2fd8d6bf64ec68eecd03b0b414eb3591dc3b36d02acc722a42b751b42fa7522a65d82b5802770609f9e5b938a1691129d3425bd2699f9996356738daeb387ea1147994a709b1e7d44963bf89ab20276a0d183a93a29bae00b18716507e3b306748726c9b95ac6df2c4103f13840eb6b6fee39d0dd920a92f127d0c84e2f9137cecd0c83bd156638f2263ed999e926d1c13c7551cf70b511994c329ceaf205d65da3cbbe14cce5fdd1f0f8c263841b67bbbf32dfd7e9c149179a34c6a401b4ec21636bb76137a6de595be2c76e0ac0efe89509170c90650322f89960dae57ef33f6b8a107f51a5993ec3aa20a0cc3b384a25aaeed78e93f9c0597a5c70994e526afc4b609f3c37542ccace209dc9662376cdbce81c8c9d933c59738d08a9522a64f2d38912f429caf63c7091dc9bebf2cef7bec4763b3e80b49bef19d3522015016328ef24fd34d034f16affe42c9eeeb881918a4305632dcb083d8a57542294c0aaecd05a2920694740c5cedeab5f0dfd619d19dace842dc43f9648f1f41bf499e9e0203f3feddc3c8f0f8326a8ce9cfdad41613d5b8f549bd63ee6bba7410b4b35a2a03d53963a2b623f6a505ab6c9274b89c6190ce2746db6abb6973f91d4c6658652bd89488f1603a27649613dbe6c1861005adbebe3778db1b59675627157ebbb39fbb8421396fcc0a5be4efcbd43edf1921623af22025f937d039d9a381e0bae66b901430707dd77636c7552444988b8ccf98b66fdde2e83d32bc0100d8a122c984b828d67b23848af553efeedbfd44e0e11a74f82e830d8c68f3864cbc41a9bb246491ba780505efddbfdf07c2e7c80601b618313e4028a65e88131e4b2b04681884e32ace43ec9eab6b94fb727a32f436fb3814eae661bbf75e6070cb9d65509dce0df21a858ec47899d9a9c0061b4d547f7ebadc09b4ba8ba1bc9afdd29124d1ccf5c85b222e8297ada09d89c472b2c0865f82573a8138dfaa34147007e0dccfcfa354a6c36cf8c22aa6f9e05a87af89222c853272cf30855f0aded476ed9bb6709c8367efc8f80e35011f3ca366fd2c6ba169a3bc36fb4d3144f4f69f395befcceeb47c0ed148f06e7cb563de695b5756329c609d50d2e6963768cf038173cd46248e6413f7ebc9fee39db377ff06b936e05cf9c5122ec8700eb3bb9ca4543b166f0336422e26086efa386c93afd57894c4c08d2c7f5099acd73c225fa687baabaa7ad2ae7d33ecbf978095cad609302292d1037c1f65a9989a6ef71d73d856eac480b5aeb3e6e56f120aae874efc8e1f4ab9ba3fdf9ba605a011902e5aa7122a7d6d4a144d1f4fc9ea95be52ce15d799048d77808c72b592883396016ce255c113eb0e5b957cd592d4fd3efdc9c80ae77af7d91d0dde25f4f8b69cbdaa45b4b045d5ed3dcef0698eb9b8b7f1dbeca04f29e9a4d5a53a32a54a336991ad5cde807aaee74f3db7823308e98729fd6afe29c684db717f8b5e988529437aac52f9c7939469e6fdd5d2bc5f24f26215e5a22edcfd9885c32aeb6899f56e6f47de6fe5721bba46c132eaae695b5ee47d95ac680b28d71d448bd2e72e7f128205805e07ea5c9ccb551887c7a1f5adb5eaa64590b10c544db0abec14d0b822ddb174986c10b4df1133952a1fe0c0661c2d163b0f6fead41835c93801c4fe297c0fe76134ce29c1e2e4eeddda7a477e184dd441db287fd1debda755a9c82fd5fc6898fc360dd55690c63f4ad2ea985791042b6a1ab7462950c5d75c7022f0fa91620ff62641421802de0a1db8020ca7458fd703cac2e6afa41d4b0a88d7cb31fc2b1a5e324ce280335e6d7946c5c0f8a68ea214d424061c23b18243ca8c4c43d4646d299493cc956b7721e6c079cdd6df0d7f135058ecba4d708194df62eb2b4ede8d205c4fdfd24b2c3b853992fbb04a69fe04b3120d4add49a39a129337b47066cea6b769449e2bbb5eda0913c8af6f24080a8426708a5f89a902b1f07027b96af4904c6afe458f049a71365160763bbdcd708dc7826ee73907bb9780372e11001dcf21cd15a1b2e10a0a85fcc702d64e415af7287d9058dd4db5f870e3d105222a107677b60c40d32699d3403f0e2be75640ee996c68c1f984ad40ed9875663eef6ea99ee47f38d4b6cbe605d3edd58e14d95f9376725034193b63d49d0620374ce49dc46b96d13cb37b5ac15440cc497db820284726eaccc510ce1760e840a20c6ddff1795d0301b53540bdb81284521547231b1f228b56996375b158868fec010bd0a6dcd7ec7abfd91d1a2f1734368f76bdda398b9de9989a22c82d1ffb8e4827dec2db21ab19d4e0ee5caab5f86cfc559038351603644a0b896d22c0de310059a42771af1d5802d85e4eefff1dbfc5481b13df1236567f9ea17541a3ea9ae9451bbaa4b0212bfa09ad522f6993a51cec42a584d12e391aa33b772d38bc3c94804c4c88c10f6b32f4d743c144c75cfa69701e1e7aecc3c946a5176a4ae10552fd03924451fc12529e054671ad43ad714afe68e3eb5693ccbda2ba3e7664fce11b06f31ee3ab4c6c5df934d90b4701085dd4e4db058a720c53bdfeeb1cffef3120ca9469d1d04c8b42186499d4ee62153ccfb0e220c5e9f00c8504674b29b4297860840fc7026a7777f288c1fafd2646119fd448aceb1455631c74f308ff46ab3e66be2c289ff9819b6eaf32c0a3b80e15caa62e06ba4ed46d77e770975037dcc797f833fdf33451363e6b66b2dc91dce06ed705363fce6bf3a2c978e6431851d87b36354124325d860d83721dd7ae7a6dd1d0d13ddca270e76e4ab502d9d5fd18bf03e6c138820d83fdf228ab549f264b9b238e4693003f2421d80720e4f724f4786cf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
