<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d678ea15313ed89eaaec2962a6d1e794e4d6b1135a452221486057c922148948ec166749fe0499a4d29d5b438a3e4738a7c96fdfae28cbda4c1ecbc443c4b9bc722fe69ec8c576df0f6bd3d1f4ad824f45a29cdf124e30387520bd0aa7db0362642f628befe985b76379a1e636742932a18d79821d26556de269e3ccd0732f5aab4e7a38552a2c02dc75fe8687cf8c86ac1915f7d897bc0d06bf5e6b54069a6b55ee306038b0232789789e559b3ecaca317eb800b8009c30b630dc6a0665ce76753d4c1109a3846dbab1c84d125ce5fe82a53f7a3a25802a9ee9a281efa5502ca923e66d93f3212a6ef56370cce4b4e84de1b4171e7ae1896cb18201e908eb20d62e7e9b01d558de9ac40465b67d13e2da980f3dd7067bcccb770c164602779939755fa50e653d5812fb6496bbcc9250272904766a709546088cb8d2f5c4807e7d342fb0e4eab2bb5a9ff2fa81fa4607621530722d0ef57f11461b90fc43047ece0f8413a05738429a4d4dc7931c659077bfa2918ab3bd3258dcbf7142708f414525ccb349e6bd140dd0652edd9f2b43e22901b9fdcf11b50c726e48aa6c0742b2bf0db96c120e76571cc39100775ffaa36213926bd438ba5fa305c48dc067603010247e5951203fd0e457def807d0df5bc83fad61cefdcbd315f9246caffc51347d022e7713585ec83300c77b0ee853f7dabadf746ff05b7c92a6b13ce5ba798533cd36cba74d4010d42dca8bd9ef2f2915a9401a82b793154ec650bf1e52e304703445a4c11e7e71f9d665e1c0eef5018303b1884d7f2ee0167bdc23fcffe6c94f1f2215a4a82dc850597194fa1b5216dfbcb76cc534cea639ed83046ed8a0d2152dba4038d881a322c4edd2a2769303a214331074f9745bc979235af1bbe2e77de1daed7afdf43f0a5cfdfcb9ca52d7d6513a3748196992ff9670b9777ae7e26148cb6ad677a77c962bf9094f94e6b216ed435c6345ae663e36d087ccac897859eef3405934f5952ee8e0ea5ace432cf00e1724ce6e8287a206e9118248585a1a0f0be7f916556b1e9095cbe585730d625091df3f552388a3042ad3e2b61a50a6eb0ba804ee7f0699b8313aad61eab4f0f9b929470e858c9f6573262a92806b713ee8ae9dbe9791c2fb1183e2b4741f3be4750b3070afe66b4bc853db3d707056d6f0cbcf8fa823fc6bd0738f0826d07e292216cc0fc432e28b47f6887661fd63f2d551494c6d4a746d5266953bc45e5f47585aaf59a79b785989d653c84bf269433d9c4058db7711aa6b4243040c42749d549ac8c6e1bd604513394903b8a928d7dd59847859bc12d846a4e40d54fec5e21bd1b958411656a1b3e60e255fd88ac13151f79eb7c845c031db6e91015aa70dbf749241fdbee61d515090888a540ede50701d6bf59b2fb18c7000b303d4006b534391fcb0dc14248b3fbea727ed8062d6058d44e47f108b99da9b3aa5eb7b7e39738006304b68e064fede64e71eaf27f70f7b58f2c2ef30459e370ee8a159e76ca242a66f9bf4b28ae06f31920db1c18d75b7906e17a9af7bf412c6a7e48529f0179c0a2b5d265bf01aeca59f9dfb234d28c21bace6b1fbf37aa230ae9a162152a87b1b333a789fd71ce47fd6f5d4a89c476c93969d55268e0fda6070c0d9fe703dd5b9872854d1affe8ebd39f527253b0facba2d387000d8a80fb00853232be79af5f4fe79c378bfd215470ef8d33aed6ad171265e610b7e69d3bbb91b2e2b24188a94c4d985c8440188fa243e5dcd31526aca5b3ff99be142c7d855888a4fded6c2a6b3eec0a6859fbb5845215468ef3dd18f20df74749c781fbc1748c053ae8a5686eec2df37f1bb1152f4375ac394ecf110408ec009efed585fc2a44f55b521665d45e4cbc07aa21fc6e330910402e036db67c5629c462d1467819c8372cce382d94a94b62e61dca66f3c9621a5f3527b9a7cb50696669638030ff381dd05880a5f8cbdca603a4d4fcc12958b0186920d3fe06192ba74db13b9cfd8a2786281d156b41c4fa2c3261f61208dbdfe9330a5d6788fe146f02f8706be28630c9fc821a352b5e2027e02d361388977c08b2e591113cbd93252c8e2cfd0e502cc850384a00696237631abfc25474e3b14ec21775e0233370cf3255a1b7c45ed611ec9321df66f85acdb124025713038c83a7c7f267b8ea49e49887480bc9f73acc0eccd89e451c47365d40dd4345d96726195f86ab53f32127029acbc544989ccac7c1cd2fea0f44e2c63362d088b770fbe86508797124832147bcba8ccd7c72eb899555c8af2502b67ffda88e31e1115a4ac6f7ff776c2841f6bd1da5cf321d7f47f8f4c08e60a7bacff9d21fb5343893bb64f53980a540206377eb8a8b3f72047f1bfa209547e49a74dceb484973c748b7f6c43df54a43c36f78ab5706d839990a67e4cb96474fc7a06299414cad32073ee57bc43bbeaf77b856370c8af6e384f321aa89e94643d2c0707c34af2bebc023cb7d73a456c78e0749daaaa2e1a49e51e80f9139680ac55ef1365583d978caa20975a8762570eab013c43f5e471c029cadfa378a4cb9e86992640da930e328bcff1e0c4c61c65ab2f69f17027a52996470312431f2a3fefeedb3efb0c7234f01acc43e5df6739d6612ddee6c4c7721c05a9062501a237e2ceec2c96bc2156eaebe4d32ae98f977531dcec3e6ff60b9416c7c09e90efa7ffbd40e9b3e203f23ac3cdd0728a6cf29b5c99679d417412f77369494b387e23ef8269321a46e59e2b1e28c6d124b627a294e24ad95049e05f5825c0524b2756d3dd1144ac018f35b0c656aff10e4ad7fca1371d27a5f84907ebcff70695805319c8392d62688abc045b4cb222e7b92dac089f1e099b96d4ae4746318e6deb5262c848f513d0392b731f8fa18a1b9f7456e231e4c56c9081ef759e594c3b95ccc55f75f8f58fd2096e288ee45260e4629c7a3fc5720d85acfc1a42d72f555b60f1939381edb8902381ec2a994b1f5c079d250de864d93c0e5350f436af6cb5cf5af4345bb0880a0b068fed0230b4afe929f29ae9b98860acb53a0069b9437c7ec4e2b28185f688db4dfbf75da3f8675349f343c3052bfc5159634ce9dd8b41ea3b81c23bd27826e538877245c8dab9cb2a47f441ff497c6a1d382530b5ef006635f5357cb4305fbad467a521188f8cdab6cb168b176e1382d07123fe42a01eb008318fc3162a963323f08a478987181d54485e927bd04d462182092edb995bb5598c58d085abe3ac4881f52b23958f972a307a1176ba76256e15ee917cef2af0192c90f1c89e6c29a603cdef1a9e0212a4cface64bf006d7738fdc1eed06646eb0c34fc3e872dac6a4d06a8a17adabee04ffe4e7624cead52c57a8bca04729dd442dea2517f9201dbfced46899d347f99224da293f7e8376de9ebfde36c7fd167f0ae66d019450289ae995e2c86a1637be5f72a0fcc33c4f6be5e12205a4307c7fe8223a223f3df0fb3b80bdedfaef98756fc2c55b41c92dbb9e9fd35bda4c598c798296fc9d95fc422aa2a0f5a2f06f2a6e4c19c5b6ee79c8800fc25ba35c2f95ef1690227912d8230395baf2d5a70aa84513ef7b9b70829626dbeb463d9902252e6d8fb54cdc0bbb049de6168e1d79c687016279cec59f1deddceb2e8e89f8e79ca5a066161f3f1cb82ae8bb3795cc2533366c2a1a42b5fc192e0f6bc80775fd1860f54e3d8bee1d709766d6afe209961a56b4599cdcbfdd1016803f79c3eebb34d6ca22e5d431d24202eacdcd7fc26832ef2df3342da4ff47094a6fa7e7427943f512f562956a922a54d4045dae50cf712be042d327a28a7127b130993309937ebf77910b9543db676c567f49e171509c9ff0bc9d2c6e82bbf5375d2a63298498dba8365e955f9107c620eb09c0a71fdc26e5b30e382f8377edcd75079b192631c7729692bc0c517f0ecd3b7cd3ce608166dbe825250d1904fb79cbcdac2c5c44b2583174b44edf357632e37878286bc80b24a03f3e3e41cf15745422bf3c8dac006dba690a5205c0aa4e5de63fc3737694b7ab247bbe4ed0a378f836dc4531d8389ad29d1c6f405ad7d78948b81ed24f5516821236f48a6ce53f0f730c4f8c427827b9a966e5a5c65c485cd506e7970ec2f84e6897db792446718955bacbe08f3770fa52dd2bfa61ac2ff98d9969d8fba9262abbd1cdcf615c2e8d15d81b5ac0262cbb30468696c84b0b8be7c146db0502c8cd7c6f0f924e344c2486fda7664fa9d1751bf97448490c49da732fcda0eddb40fed36e1fb4b19409f94d95fc32f2c48110b98d534d91a4a0fd39772eceac912d3ae44302c86d4d2013bcaca406d4d6b86d2366f01134d2801bffa30ce9a5b7a12a067c3ab6682ca83f0f707a1ddd2ed975633a86787934b2463744420e645b30b4fadd10f1cfcdee79e56ccce28bd1615920c183099ae0cb95932bee75defd3f65470c7e91705b952abc8a5960ad6199a9e2395b9ce4785dd007bfb8c549e5edae2fa72282f4a3ed60678c3848c28af1046bca57367811202a20bd11b6a280f1b45e91154a0cbbe996ab455fddc0ad7bcc73898c6ee157b23088bb6b5f50c1925e72aec9c07532d30de0d6b2192b98c97289a6ee6236da9248a34e7945a10ac25e61b37c21c862ad6436626875d5e2a6f7dec72a8dcb5d0c38135c32def4d15f23151b104d83baa39d2fb069f866d76f9c9175813d2a1fa6ec7b1a0ff146076b366dbd10e5fa45126878467c895cdce1dfedf1f63d28070cd6d9df748b7845bb0860ecc5a2705dc26baa5b81fb2ef2cacc57efe26959ceb88c5d5525a3b4aa25fcf3c001fb8cf638cc90fbd098d7982e73285c32d87a7a5dc75af189190c1e8338482822d0248dda68f1cac074063e0e632e7744a10997544aafd91128035f57b9bf332a49f4d4cfbbb061c37f4913e3bb7b2a92994e12b2b24911a8fa44197cd6cfa8a75085221dc3f8c411541745cfe18fb00e5c8519444fee93d55d0d1a45f493f8e425bf45c2874abfb40a44bbed3673af1905f802df59eae7427c3cd6daeee60d9868c2f269faf87c57d1fbf20318e49b27767c13305771947d894333d798ddc285f7de559ef476acf94299b87b3ff5487cef80cf6616b033f4aea871133fef023b6cac5261725ae294f1e7cbc7e33e6bf8a68d6254dfef1ed069e59467b7ddc2a7b49e449f35859ff808d668223e8d875ea641d137327e4fe5f436b72ba5e12235d6032b14a4614b43c1204a5f979e6a7b2b84a80179cef3bb6e2e1c531ede3ece798844990fb1dc7e2587fadaa46e6f3f58d9098167b854d9b45b6f80117602ff1f6c1dc91b4e76f53ae8aa254f912c09ab1e9614d904030c36883c48f2a541f6fa67385d546e6e3f801995f3a553a83ad24707c8e88b444eefe9e9b1e22ccb73a7f1a8b9abd88fe26aa319afe72d277e008cc3c9c146edf6718d44bfb64af3454897a211d691c88473692098d9f26a15dc17f3c2c525965e8c07eaa669c34aa9ad99ac06ddc54b5a74f5d7196efe9bfea164bd0aee03108066d2539358e850d568f99f1bcf1c16c37d742c1c40721c9099c832e6fdac6b557609bac201a4fb0985afd89e2d491b343c0d1bcd55ab236479b5b1d3b0ed870f409a63f6db3eaf9b4e1375726e8f0ba824192df9b8fb97960beaf128a2a64fa2456ef849d4b4b41f1dd444a5e6e4200611e96618cb694ace5908f57f44d7b060cc8a1204f61e0558e1c76a002eb9ad3cf21533f38b7599b7d59a6dda932530ab8fd9e1fe12ada75b6a54ddda267a22d428c7ba1dddec25d50467d04f690e9a958ca8bfedda2cc8aa5b112b1b18e2532e2ec0434594ca9fb00ffac3ecfb7751e01502604ad78c65661fce69bcb49cabb2f881db52ec2a41916549eeb3d7f49543f6eea6a9e9bf3478d7aa4894fd825a05c80641cfbca1d731e6af053adf16f13b7215809ade8c115cf3ab65637f5614a0afd8180e06f2678efd5d1099ae3e8870bfea1bc82bf3f0da7492e2b42a370c00b9070259173923ef6cd5f4b21d8f10f0f6f3919260b20051d9b6d47d88bfaff22bc3ad7f4c2cf9082a5a6c6a089e2ba320e024a0168f956ffc14a7e1c3259d8a7bc25c2174a9b76fa498460bd3351199bcff058950ae0b9ceac788c367f70688c2f8c2c0e1bec6de6bed904e995efda4fd0d8cdfa4c668f8f321aaea43b2ace9ecc7ef7a2a0e7a34971ce62586eac6fa564bf121fa9a9697e3716b606859033287ca6163e9ad19e6eb95d2466a4b46ddfeb24229af276137e76a7f0cbaf4698aaf5ffe209aa188ce1ab1c84c85edac358a304eeb8854237fece173046706e4a5d7dbf83ba14c5442797ad9994749e20ff4a7754b1fefae1e997c104cf952ed9ea649ae0b8e737bbde31a9665a1fe7843ccd23d44422d60ae6b2b177c1afcddfafdb6b97367cad9fe8f6793b19263e63bd998b381858a48a520c4cb1884f9f1a69bd39976f7cf30ad06eefdb47f1bbfc2541f3a97616701493e947c0c7710a56f70599643fe9395cac22b607ccb7972ab5dde738c0f967ad5a3f2dc2d0f951acc21b414b757f775f59d046cc3276c7fdcf3ccdd95fb1c6ad0fae515473f7bd3fd6ccfb2c0fe92f38cbf4b1bb0a2fbec9bf1bac6cfbabd04a6d09e5e7a545bc0a2c76aec17dfc21198271e261f8d1dff4089656092d0f769a04a5be2c15619a1670cfb32a1dbd8eabfe87cba4261bb0b060ba0739719a6e8a34d74b929aae2dfd4a3e5d152bc9638b9aea118f1e0117d5f37e031ad0bf86b53c1da30bb773763afa2a5a9ad1c65d016da7d00c240589f00cb79e306555b2ac40f989aead850bed8936056028b83a721ae3bba48666deb9461b26b795bd92f671fff6158468bb7bbaa58395a4107f03ff012cf43468a02c155f34c8ee0f09bbcbaa16bd76169a03f2e9b12eb9277a2e346cfc208ec93e057ef234b8d587c3618923f187a0e3a82a065653893339f6dccbb392180dcb8e5a9e71a04664e9be4bd8ac735c2724243444299dee36a6c6617778e8da27cbbcdbfbecb6d826d6091aff2a3d55d68fbeb018b4c067ebcdd36edb436ab6f67fd9648580005fbb97ea096530b7a0355bcea6301bd0a0a7b06de1fa2c2960e1c6dea1ddca458cfbf2634ca49c815bc64438837aaef5b282d9e27a15b68449744739a6bbd9b4cec81bb41a6c0d4afa639385f6ade02810836df829e0015b556947ed352ac2708d23c95acdfa47672184083ff3454a753a3765c5b3fb276d81cd0bf818d5c1524ff28b9b8078a0d942852eba96968121ae137ee46b27b29f5b8aeb4b6220f1de675698a242d6cacb9df045a776e783ac0b5e3642ecda7d373373431ec56a2885a5db23d96baa16b4e3483347eb37a7fa13f6336a26245ed98db9804c3ac72840764175f684f38b54b3c789a81eba72eb1da30eb547ebbce6bdc971fef75c9006a9ac6bb9a3f338ec2c19fb934fe194ad3956343205b1e1a6fbbcfd3ba035c67e391b224046afe2488fad6621bd326416c3327a13d8eb29531c1f986789a58ab758ba3aca3b5718faca708bc5b21b4d1adf285455fd0f220f86f45323855b59e871c5c1074c0e850f0428cc2c7d9a5ee362d407fa0a05be8acf4575dbd663e7b91942aee23b63fd945f7dff310a4475e08bcf8789e00c9bb85fe0a40b91dbe403b5504320a343f3e9c812ceebd11d199a58e7e78b6efc41de648393d1d90d8f61558236790ffab35867201c5a320cbe130814ca94ac96beb66558e3763fbacabd3818e5ce1767310300081b254d65b778c17e3afeb7ceba94c2ec1d19f5350ba0a9b50e1652218c49fba9dc2017f636acbfc83040f662fde44bb7a11284592b8ac9da4bcfd0cd5c6f8535cea17e483e556141e4b6da14b07a3720fb363dd0d732809fba84178790c0a5beae2d21b2d51c6d2190742a0a46a3e3f8d458ae6312d4f59405f1309076c8edd94cf36322ea0e801193b5acd9cbd8ec8bae0657d5d97d9047acb7ebe7f037c6348a39463afd6eaf1489fecfaf1c99566edd3c342ec58594699d30ed4f4a29aafbe1af4817163a36bc1c5a273a03c7d75ab942a0b887f9799fadd75e695de0815c7978352423710a2dcec089c481f5bbc14b4e8e6870d358b1a866f244b4dc2de709324b024650825a0a34e170d3ac7e48d3c16ff202c12f529931fe6ec03b58255dbacaf831f9e9e604ed9af9f0763cb263296c1629591653079f9490e95f077fa558bd75dfcef5916321315b46701ba4ddb9e83bc23c851838367ba4a9856f14c2e77a591184b0824518c666e5ceb02b0f25634d81dcd06d73428855fecf4434d4ce552d20e13ce5e383dfc55b4bdec568a949c1f34b8bf86f91fd3831f949bb9d4dd02a3cd0cb7439eae199ca0626588bde53120a9b2c40dd74e232932f573971e4e25784b08f4d3ca237eb7b8ee48136d2b0592bacefec305083cb50842595a23ffa177fa0c74db4bea11eca61cf38c4982f1797c205e49c30aa5cdb9949e79a70dd0b3cb3f09d8c840e77d206e6ed64beaf519609862460ccb2d3fa5f3d70a24b94c9fe11b6ed8cc798a50ee8acd57698024638c6de6d548bf7fee0ba8b88f8331d81b8c2d343d951c3fa2463cbaf5af8367a0dbdd2383687e20733696c0530dd5acffd48331035cdc0c60bbebb607555700c1932f30ca7f29f20cd0f89c93bab4655eb84472fa4cd60ef8bc0bb4a97f1ef355165f1299a76fd19ef01cb91900c6096110536c664036cbc134eb5ad17b0b0baf21b4da82156797d1a1fcacbd4d5f86a61b8d8aba7cca117f060a31110e8d7f374e333b21fc440b5cd355930847d718b0857a8c12cb19d3e6c54e7e277096103df8f6d27b439fb24aed72446160451327d31186576c80e2bd9b3137b495baff1386c9c24182a13e4a2a6b2c125cb4528f2b2ae6726169348266371037a10d339db3cb5a041ca7a07d0e6bbeb34b4a9142176c0d68c9f387f5173a2e092818ec063d248b2a614d67bd2898714c742f65b0c1e7892cc370b4e50b546639cf219d5b137699d3a613b92c112835400c5963bdf192ea15ccda273eda0fa1d6073cc993122162c2d44a3b9e27cac1951f4f1c724b0b1fbcace263bb88fef30a5d9bb8a3c7679aa0096ed2c0fb75b7bc8f5e090a0e8e450b1d7a5b8e6cd65a3b3cd1157eedfc75ea3c6dfca1129b566da2b6ac434cee7e31567c3b54d853a5a3422d1eab6f03876bd022661a6c3e4bd099062f292addc2701660ac3ac097180b6725f4678668b0b8f57b47c61a4976de4e7fde9fbfa9a69b443f55c065447a730f1cf4a06d8da1dec4e5ec1a9b7a4a233971ad3186b38cb3d65c4a5cdca68aeb8ba6ec5a0d0981a2e1ac86edb0e4f849bb1061dafefca632d7debf530a474587fcb2018c06ad10d0ce1078183ce34bbd3736885c48da7b508f33295d1b0977ccd4a8b2188e359bb6f0cdf29a3795f02c93b874da6bc80c76d3f07e41378512604c841e9de502ab4b4a2082e2580dc16b9d38a144eeffa4987298d4d7d2799ad3add8fade06c6137dfcc1b077df96d518af6d5975d78c96e8d223382de84deaedfc9b7ec2a3df1d60bc554925e5c9158e9c0d10aa37792ca615e8815818f79ec9727793255f240e4919c1c5f9ad4719116dcc1fe1810c9a5d8a2c404508f2e3274922f13170d85a3c23722e872fe3aebb0815c3940f6e1e6bde45f72215254e9291186ab379c86476045fb57528c603d7bfd584ec286672bfb9ffd6c148d70db2ddff73519df60c8556f20dcaa622b870be942a97cb9eac51dacf543b45b10f9cb7be03b529f1df45b32995e6f1c95745800495d43c973b06996311bd50c67ce1e521e1e4808e3db43370bfb5d9ba2765827569f70fb57c3488303b4431f58c65367aafcc6d051d7399b03603ac37e63566201e671eea8adad1ab6155b5794bbeee9abb95f7c65d6aaeb8f64d863995f610cd280f13d3a2b3fd3cad99d9f60a49aadae1a3c4ef068f22824e3bf01367155b38880097cd5541fefbfed191f3b4993ec37bb58374ada27439f1783b40760367a53a3c6a0052511fb55259f9500ae4c32d7b790a2d0b274a5e14ba5482a3c7b1c58585fdabbfce1420df3f254bb85ded921173a481cbab67312d65052e4e71ed4c5506a6c48372f66e6587cb0f636a3dcebe9c7ab8cb68ee82d6ec90b3cd1da539bf042062e13f9f7c64c952ff054a4a8d1573d34d6f7abebeccdc4f5f70f8afd489ba53e284064551bebfba35a0a8a3d2c6661c28b81ddb82781dab66fa6f11b913c8fdb77622e5c70de49981739f57a6259ceb95f1778c2ab290d4bb4a7c2b855fdb5e30d7eb9ed5674aae6a5a625ec003919fa271b3900e7c13fa1f489755da4a1a95b9826eee9ea00b430578e7a97bdb2b5050de821a896694f2f49d97c62b62d64b3a15943c831f95bae140c90c890d0370b68723989f29f7661816ee2aea26c12b38ec3ceef6cd39d171e89d11f4b436a17c56b58c41750b13add9db00da953e9df09d954e2765c0046d184ecaf8bc79d847052bc5eed5bdc86db208e3157715ff5f14f5a74ddc0a2e15dfafb26b40953165891481dfcd16d31d7fe965f15bd04441acef5d58c0e127e3c8ea869f8ebbd1f17fe908c8b673e3ee7737f8066b045a2da296efc5f8d76aa2a5b5536275bb8aa5a0830901572dc529cb8315ae3ac2641433bf66a837758eff3143b6019bb40951f922f50ca49b7c6a2771b53f1f19f006ad9f139466cb61091f3f0965217dac55a86e2772465db8513f8ab23f7f0f0fa5802368d98f20c0434c7c5a1f035882cc91aab9f2f8e526a488c19d9e67c1f505fce36bd3928a562053e96eb6fc4c8ddff1afaaaa75c4dea3ee06870749b090ccb9b8d68d53871a8ea65d2dcbead466bdf34ac08c9d448d68b452300e18559a6376681afdd8e9177c62c4daa171005aad4e57adffaca57819aefa0c39ec39020a59ab77b5213875c9189d233512da6d81d1406f0856005374f173f091e1950184ce381a04e5d72b9951892f5840fd067bee799001ba80b787fefcd4f35921b92216a7c6bb71e1a34fb4fd2572f1527953bc0f04cd55912c44d41ee7819e2af88f1297b032b421609c698dfb3e841dd5e6ec1357c8d0ee20b238dab53fd855493c01506ac28f7c7bec6ec6f46bd2f70192eb530771be5704b8c5f4e84a7be3cb493f45b91dd0f0f61d6f79c3120a3b2c404abf6a0dea0e132e04af350d52f74a2a79cc1f2c35edbb3bebff044b71aa09311fff835271c4c1a01be306f0709f6703436749db592b34b8365d4afa3f5d5bbd1e0ff513c4d2fb6a8073e06c0ecd87d8ad50437dda0b1085b75871436dd8a5d20a60e9d8d5fcbaaf54cb6e1244c8183f7d6a7063f363fab06190653dcb7d9f734eaf90983e7133e9f95e8df0111b6e5b5057d0cbc2e2098d3e1efa3c0a5b14ffa7b0f0614912ef98e99deb39698bd35cd876c24ff777497ff6d727c7ed6a4279f11e3fdee8794c91123672a30e1d7fe5d18c6c70e1391028ffcfeeabb41593aff12828de16393a6c68a4254b199f06aa348794b0003f526b93bc413ece4938b4a18765fd30e377959e875cb78d60dd30b606c4dc60870389371888a739f056374b9523cab01d3510fbed8bd6c376519d2d91073de3af9399d21a8c34551e69e7494c8bc928d7704fc0b693e393eb2813840f6fcc1717dcebd803173b693fe57ba6c985dfe9d0a4c8592d69494a0a85670a00f562505131e6772fd4c44e87f2d9394ef380463a109beeec1cbae6e61bbffda46dc62209177bf5029c19a57c2d9877ac26bf6dd54011f715cda925be676ad1186b5c73b09cef5a243628083016bdcd8c96976a7588e13e74bc4f5328af305c154f866e32d1ffe5465950648666a91c513e09c2b355ce7bea79f369241ce3efe4a0670ae08cd5e805dc61e044c31dc01d7ea41ec7fd05569c3632de007aa22fb95f483275308caa10c0de7eb06093042ae29f7a46040d9c013b913556878be41a3d10ea449f91060ad8de0f407c0600068b7abed72c8db413fab9d8d03486976ef57c139ddfc6581c1b5d3c2eb6afd1977d6641e70b49213e7151746e2acdd1ba18b969ceeccafb7d7a20a0cdb6fbfde8cc44384dc6c598f3b227a331a6dba48b8908f2e7b4c434a452c0ba20e443c102a36c1fba6ca092602a5683c63dc0ca96599897fa33995c94f3fc3a03f66f24381dec2cef2196ad273f8b60240335bb0fdb136d237f22dce7010b330d0d0627a80022e93879a66a989660f2726605d3d7368de94b995b0ab2a89940353d35f466f84afef4c74ed569cd998725eec4e489827df668c8d2fa38f3220b2d37a8fa47f1de0d41f761180b7e52cd99f36b7cfb926397956593fb843ef6e8ff3010b9b513d954a22fbc385cbe9153873b47f506675f6d6add1278a334252289303dd4391d471a2d7ef3f8fcbaff504b235d436bfe029a653aed59e82e85e338465992bfdf05a0dc3794eb64df107d64dccff5368b6f3a7ce74b36d29d775e666e614505cfc990044eeb795f43541b7cb88c9eddfd5764498cd49128cb42c8aef95882772ea8e6f008891d1cdc4a9b4d4903dc75b12b8905e0fc06c77fd3916a6c080d4b1844f7dc53ed524a7f051c2533a32bdad7a53c396a217cb92a376b7c09a4ed5baff2cc7a206d7e8a5ebd957f870440be2a1bf9c7caaea2b2134a8906dfbf4c99773629bf1fe5731909aea78f8d4fd8fd31427dde99f13009b4b31ca0b963dd3d58b3e889bc3766779e9dbbecfaab1c46df783d242261ba2548e8b704bb0011ed290bc8395f9e81387e276f37d168f05b26b3e73a824b5b36208d1ab1e2ee10663b6c996cafee9d2f292e3fac9bc35de61d993cc6219e2684fa69ff4ebd9034e2f1a5c564ae49691183fcddee8b40799ff6e52a749acc746ba604295577a65441282b4f0ce09f5416db32613697926681474d0166cfd325065ff5cee1c8930edd383c09530bab79c6cc53f24e65f9b6bd45753155e79c8dc8589ae74e399d1a6d8707adada1c546eba93ccb3e574b8f5ef8578b7a56cf5bd110448a5edd2c5c1fc5a8d08e26cf8e8a89247d016f1fea857bc5c8662cd00f3243cd7c16b7bf8ab783c940094a5dc19373f3a35cb4861e3e68fb0c15dddc333293aa76554320ce4d5fbcb6372f0edd91821fcf4563dd28dbfd957fe49c88779a4422acd7da6b3d3d6b662e8d58d4dba7e19743ca53f47bd55edf47235a4c31a48ecda23ef8df9c01bdd647e6955a3d28328d4dd95670239daf6e4a75942f08572f6657929c4592ceea5576da7d90e72689af7fb9a92863916425e8203e94ce6ca9cd859f721eb5592a10c60807cf3a3640ee8d88d0a5bd6c670eabc10892f703c6fcaaa8f2d6d0e42ff5e0df72bbd8f8775949f67aca7570c56cda301b76ce25522fdc5b9cfe28ba1770342785bd5905022097a95aa4d493a49b37630920329a689ff050f5cfcb973b811743e2ae7fc2401cf7111907482d24548fd3874c1a30ae9ad5b6967ac17f821ffab0c263b1d1e3d3be5cd32807bfc197333a20481a4d6fdbc9a70106fee4cf6b33e58ef2f1faf3e2fbe4203e1cd768858742a2da9bc0be64c5e3a968af0f6a695aab9c3a84a89d5f44e718f1e859bca3e1748479a22e84daa6f979625b4572c88b037aeb5ec0d3c8dcd0a1b5d377b0c9c3fddf68d6bed7c9369a91fb7f4e6bb17cf738e25367199454132cc2c7211c001431ddd495d9ac8c7e35f6828868b85652bef779880e61af9ad87ace35ebe245bd7ee47240ccc22a8bd2f50b6326f19529ee021275da862526f6ab2e04827a198d3a9ef060c7f3d0e9ad842ec5ad634cd541d24adb4c3fda1f3b9e1e21394c911be8ad0aabf75b51bfc207a584afb3e50f9f6d51c4b8866fd1edfc06a32f69a9a6243e21a80e86c4712d1096d0e3daca4f9e068501fb8e5f6389a9f153ad3510c8b4719f85bc33ed24ddc710548b5de9951493a0473dd3cb9dfea78448ff5a92f1fc2ff3688cd8ebf53162371424f260d73deb7985738c4b51b5e199648b43af864e417039e104634ae01bf6bec50a46f0534f74bc9f8d87336a298f2ea26871654a9dd2835e39f22c3304ba4d087ef389755d377ef0a9dcadb1120af214dec709d350014a944b157d97c92d4ce5c24314fd7baf26dcb2a53969ed813d953e21db55aa718fc8e8205b8f7a5b4b5783d523ef04f4ec9c19294145ad67b9869d33a36c884d6b3f6f61a4ec82727bf1d79db776d0b737dbe898c56aa188b6885a360277661fce29983861b465eca65c64ee1ff72c60bbc979a0a780540fa840360aece6dd56f0dd061cf51988c14dda3538deab1b6ac3117c30bca72763a9ffc164925e1a210ff426b16f8571963d812b776bf44eb0559b9271192d5fe79dad97051a1ed8df831ffed04675fe59bb53ee0e47b4c0043fd6a834b17b5302690d3dba9e8cebb8a635746e24fc6f32f85d6961589d1b9f4e4016417c9989aa534b0b5202e1e67d48b242951927e65ab1fb3b5dc9288768cc717d88ea6ab0a8e9255faf2200addbf7bbbaf2844ce82b932a0526cc75fe2e1dc9a71421ebd223231a65c324817bb82aaeab219ef6eb8e34df5c069e725ead6bddb1fb89ea9c626c5b92bab4022f87be00d360d49faff75729191588edb05cc47f8a39471131aefd94349d471a80cb806cc9a23ea77a052406f14fcea9a45d7b5e63e00218bdd066aa5fecdf64ebb5f4f55760d4fafe20ede2f1fe142259608db9c0b73253015aa5352dd44fec37907d84c65918642a41b0290597630bcdb0f7e23a38ca0e7498862281d877dc213bb87047e2f29c481e8bad4b1590c98241dd6bff5d88a1a29708adfc6b7e1e1a41ea684062fca0b272b393db3a5fb7df748f9eb9b3ef5bd45ae575ff5ee044a0e374f439656d4895672551d5ecd47fb2a58d9516e89a962879f022511bb76f3bf9ded0ac6ad58c0edc2a690d4bf3c32fe0ccb0728d550cacfda072ca81e25a8d43e3f9b20763d948246a0bbf4f9010b6ededa06c73773638b7b2054daf5eae85f14ac44172a9e153338edd039f56661122e0a80f8d491bb898049828b2bf9b6f014e3a412eef1deded273649e2e879c5f8ed5ebad8890dfd24d1629117ff0a6d9018004fc14bcf6752e7aa2d4823e4afc5ced8f44d835448829e2e020614d5133c58bbbae4a7b4d7dadb815b6083982de545e0bdc79010be1bf5e47f9c9034a10386d6055f760798cafcc00f764a3f911688113c4080f3b1f163fd9b5ae541930bfe5cff2e37677ef233fa5dd712ee35b8d931e40ea77cb48edbbd40ef0deba7aadb8bd046f4f502a02ebbfbfdb02c09b761e3b43929f3bd20db051bf9a1709c2ac08490569855760722a55cc352ae03bdaba0565b56ff773627c88da657123626a1ffcfb25065ebef1943f018959915325f7be6b657ef10b1b7b61f0c4f013903501fedf5522b947c7ea8ad94ca9b2a63cbc3cbde09e3a878bade23d575d98646dd090d8c7b529e054832b882b25e36b7687e9a9a59faee75d50bf0c85ec1cc3ad38420e637da9bcbde577052ae176507f5e46b6017bdc0ee11556ec702922ed46ab2aaa0c0ab12ffbabbcda2d45bcc67329c681dd0353d85cfbccb817b3d65d44b516fd45edd333fced565f9f655e1470efa908c95c6331acab537d64393cd545600a9ed164d287eb459437d98413500a888ca7f3096589a8efa3163daa1b0b52ed606110457133f0ff9c33adf6db874a5e7c8f10f5249f173b6348e84a15d9e8434d014f123e563f0896b89837907c1e41f528b98f508a39104191a1ce89db4899ffbbda334e671300aff1b8bdf3394d07d6ddec2b34036ce6b7769c5ff4a522ce2ee4133b4793b9c05a8175082b6925b5eab28471e6367963e1706af0d2e0290ce2070659e4fc9c13bda4dddcc4cdee56e43d8b50ccb7c988756cc29b69864a7fec47d0e7e0756f39f5fe2afbea2dcb6c163062d9ee04c87ad9d784345c98f15f035af56d404362244c160d06b25f1f1ffdbec41ca54286e28a9468558e562fb39032238357d8cc23dd06de3f6d0351c5a0816ceaa6bae9f558322e6f329e6f1aa4494f5bc82549270fc5b726ef38fcf3360a926a0d767c8e828e3e27f3f7af856aae1a8ff6bb5529c65c9ff9a62c073359cdf63abecd86f8836ffcdc6c40812ee5c6c6f7fdf671e43af1e5ec4997148fd6442dc4d41abc11784a3c9fcdf27a2a92abdc8676941597fdc1893923f30316065ca70a964a6384c5e6aaaf90778e043527eb8f95d400fa479d720fbe7b096cab392d9fc5b16c5984e97a75abc4832b374820d7189163ac81ec1056c661f68533c821c69179cbca2672aa43c7ee3a97c8163c8582e152276d462242414091cbb88a3d7c40b9b454c19f4af2bc10613d5f67030c8cd6389c47f40b8ba22ad022d7887b951ced9af7ee241b65e3e2b5514a173801d7589f08f6f3072b9bf43aab9ca5633786fd13131762b2e30e2b393c0dde5786d98ab59fccdfaf6a744ccd35ede5fbac773350f40ccebdae6dbe9682ee45ac0a05f1e300fd664f8fc64fda38a67200cba8440267635d36c36a16e5d2ee5846405ecc7e9102e7fa083694ba25c2f25583773276fc8bda51e080c05c93de34abdb603eeb7ec0f542f4894288d5c2b467063e5c459e5a486cf18928c1f642c0c3b765e61f0e4ffa78f859ddcfa0677ea068b567977372d4001fe2e073c3b30bfe2106ef400cd878a8e14743e72f028a84ccbadc813498f36ae208b72cbc4d456af22b3a3c4a86cad8ed90ea08f3b0e34e4b6a6d69f6c629c2b4e3847144dad4a0437bc2be31c9c4f3c3224a3bd1a178ebfc03906170057ad9d5a40556d26cf7c0e836f22ade41ee9c2279f5781c2a22617585a277e36a3e120ac268964a3beb91caa79971d25ef8574217f9c08b68b4792dc0e0608e368e4baeb1f5a79d208263952102a81855a75738b58666b7021bca11f2415f4aee03379ad68311417979beaff541fb3d36257c3f7a7264770cfaec701cad75efbdf2d0bbf7a3842df17a4a8d0ab261991e304a3b9c4490b1f377f9f6102e00256df3297409e5f125ba3f473cda4818ec32896625afda92551a2d6cacfbe99ca918ec28ae7c5e29c13e89aaa5619761e160481b5771eea09b6bb41d255ebb3337fd1bd863c7961f2d1f43172dd60715d2ec67c7943063f3c1339df5807e9b9ddb1d42655799120aa13a7c7ad6aa7e30791a024ef1a8786e9ad2685d10bf6e56af2bef42306022f6c2eb4dd8c215a2362aa2c2d5883221696c485b0fa1e21442dc051f873c248050c415f1f460509538a4216434dace9bb081d8ac3bee4f0105bfe64936842ea7f5a8bb6b6477f71b480d1721a40d83f3dacf5e26e726fd97b2e0c3352f7345a19691646eab1bf8b8db89473acfec74f4eb2655a190ad8fca999f4ab7200f3f06cb0d266ddd5e86ebefcb3e6913a7af5574bd35f215e77fd574ffe8107a42088a45747c851100f64cd2de3b2d1039afb2191290325bad27a74477820e6f364a63f9d7a4234529cb59a8398b9ed32eba17bae90b2cb9aec856a0fdc377be3394e6282f305f07df2db29136cadf13b2cc107a8f0febdf66c1cfc53346b5fa41d5c43a98195e2b1c891862d5f0940628dda5dbe9f76f53ef96042e011a695edbb7080d2e23fcc222697346ca4f69d71cb768d15f536ef7f58da8c174bd5c3e84f1faada68d613dc4b50b52dcc30968dcb1527fa8d2ed598520390ca2d6b54cb5c6978e5d48c1f2bc3e94d0680b2af8adfda11ba127857c45d4ff974088c939b1f9e41d39c311fd3ab422cd7feac7e9cb382e765e12cae888d83fb5f4339d2673e7b97270504ac6ed77d3a08a7d86742ab350e984ee8df607a502aa3b52c4edb3e238335ff1ae578621affa8d64c98c41947e260f28adff6037247ef48e031a4ca4c1a9b663c09c959064c04815b46137094f8a667733a7bc12161d55b2d4c4405e5da173fcea1a25436268a62fb993e621f5a1d477c655412068f97bc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
