<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2524b84f28b38d63301c9422d5dc1b871d462cd260ea380c925d86bef37e7c1bfc9cf76c413631ff5e2eca1db456925ddd4eb04bd0f9be6aeca8765cd1d59d745ca2cc2d08810c682036f17fe85e99d7ec11842a6dd1c79e6db3f683a0ced0d38484bb9b5614dac6a8844921a1ca1cdb7c7af4e3b27e90664adc12bfd784ffc60fe63d271297742602d7c09ea6e7b800f4ee41e39252a1f19531a107cc2c849e8f98d69ac2472ba424bb4c0c803ea22db6747147a1c6b33c5e6f44598c990cff5471a5e288322da58d5d609be61ddea8423db56d37e3734fd58b9abe9ff68fc225a15514e89ed8fc8c9f04d2fe93552a5fbaeddd0b6f95ae1c8a5201e0f22c7f7692437dc7f3425b6ac5945ed65ffd1532eba2e4cdd6c12116e9f713b499084381b5fac902b6b52462afa72a374bb706c99f7d7c0cb4db1c8a0da2eb0ea795afd561202ea18363d9e5a763c20a05ac39fc92cd717b2917310da81b5858db8e34210bb470cf5bcc7674aa12d990057fc44a864296556ba63a05edee0d811ce0aa854b733800f8d616be9cc1c4f18ebc16e0c0b46939ec145034d91a4f29b3b9d6bfbc85e42c9a19c92dea8d95b5956b7f5686ab09abf3c9201e1b2ffe76c45219d3e5ad105ba49233677569232aaab0b8fe16162314c8add39792645211e818252b0b7713e957c4a14212db1ac0ba8cb9848e51e47142bf4df94891e32c3ba848a31988de2b68b3ae9118bdaaada46ae6a968d4d9a00f1d46617b36b8b2bc8f5a6190215e22755976bb984f563d59df2006f5f9aadc30a6dc45ba24df7be76100ac0ec71a77893434b3dc23cbe6baf32259515ea58b23283ddbdaa2fbb5085da467b0a5f7a2b15edb5caa184524a2f5f425c2e2d1e0f41bd8b4f7111999d31ebababd1f5814ce74ac5f68da4dd8de4e37b4611fcd6931475839a1e3b71aeab3763a9abb4b25bc590379ba3b9d30e6353ae05ec8a11e1d50383b2a8d6f8befbc9226521cd2b49573e021787abac6a85432cbb8e27340c571494ac9e5e423e1978b26e0c7e45cf021d36ae088fe5dd94cbfee2ccc3d1079ccc22f054702c0dcce082918d93a9b802f30b1cca306672f3a9a344b0d1e2cdbc4d154f79db80875a2d9d9fbc6ed863c742ef360fbaff20e299404e747041c1335d8b888b07886296e83e8a1295dfca032b7509955415113dee40264555a47ea12e52931c53386544e5a4507c9654732fac321e5acbb81d3cfcedbbf23ce1571c5b87a5893aa710e933323a66ce0ec87de80638e111ab2ef8a50ca512e95c92c57bf9be97ce840250d538e2ed2584fc9c7ea44663e78ca7df4011a51193f278b7212a5271136d023d91d851b8d20bacc0cfa61297e426426fca3a6b94bb931f7cf9323f181889ca67e3f3c85a7d47d5306d645e579afe9fc8cb508bd8157b302bdc77a073601f9e2934cdf8b5d1b81c3b7c7b98e6709cf2296f5a3129c812a0e0f8847f574e24013b0e5de8bb7f793e1477cd125cedb880c2a964037d105762c916c2fc5013e4a56ecb733c12fbbbe3ca575a19e4df70153e67b6aeeb024058a3f99c90a444548c13da8bdd883eac014515fe2abeb352797dfefe92720f6b6838ffcfa1233df984e7a2568da6899f1a9f4ec8502a225155d47ec8487d673d3c357550ae4724cf66f210b6c5c02d31b25852815ef8947955fbc614288cb6bf957bf5843c6a433a0b4f619d3880c7d3cdd3f2dbe0e141f7a43243f8fad1a5250e4fe11280e95327de2e61bee197f537de244a6e43a3d7a560dc729d31e9b8c6714d910255293a2d016cdd2890ac2eeb1dfbda6028419e67796c22b3c4375c7b7bef4639bf960c66049f33ec4e4e7933b45db675c809346deea59ea2fbfe5de186877bc4d7c70460b7a85a7fb4e110c0c0f2c72eaf79b42f33258f242e1f5d29cf1d3f0b371731306de01b602091b9498670576eec9cf7f9f5984932d65979b34e0d4b035054ed006bd39483f0154818652bc6027f054d44ddac7e4287f06fb1c21560ce900cc710f54fa8794d9c2d81018a448f6bfd05cd1ca6f28bf1b16732b7eb98752acef0cbc3011a89767230e698644682feb05474d7fb074b1a17c76072291318f7a8ab06c73eb2ab488d1ac7903012a4c7db66115ab315c5bfa147a3efd2a0f4cc4a9963c952d3e71747c28f13e74b70da18ba30a0a6fbd651e702c115154f30d70ecc992e26df0a162fd9be9fb8613bd52c060c0a466ca97df7a24bbde1714fd2a4fff5bd1c2c3df119e646da796515d83b01bc9f774b2d2fff925401b8d3365978523b1131e7b1bab74d410f80c64390d314832d3d3658e34ddaa1ab73db2b98236e3b637f70e360a8f253bd762dd0b4c08cefc15907f86120589bc58d3a666ff45389c22b9492c79d4c3f2b8ac5f7b3864b21118541ff24dea175c9894a74a545676ca42b2667b84bb337c947ac77130fe9fdde87304a4af633e18cb9ee3a45a3468146668ee2f5bba321753179de3407f8d3b4f165d4f781ec6badd672c220c0ab8387b09c82090c12a85eb74e0b296f9722fd202c24eeb692d7a73fa0324ab7e21d2f46bece09079bf1cbef24449575b09194b9f25fc6a11d00f9609db437d9841fc3ac4dc9efc0efa5d82801e9cf840c6e8a32d0f69546d36af7bd491d67368af00a2e5f163a19f6111f738058d9546ac6af52bcfe54fa2b7d3392fab21d5dc143281f818afca513089a0fdce43409b5361f9544fb8b2d669e8d432c3b57848a22bf71101f930394303cb416ebdc56f75781240cc83082cdef5b98f8e52ba9b85d9eca799c7d088b25d28132a3dca3f11aac765e2db10101cd62f8dd826f18af998dce5ae5c487ee1623b2b3e5d744cec07c7f0e5678c8e711ed4ac3bcef3f582eb4235ca03279a232da0479262b72eb137b8231ae92139009f98c42364d9c57a0e1d766ba95cf24fd8b5e8cbb9b51879acfcabf2447c6ef39e99a16972da7bcb225701cd3d103410e1431be6ef329ef3ce6b85a15e81fd3ef1ec49fdff202d93cc0dcd551f5b47bd3be17ffa6be4a4441e1bf3234136ad5323f2911093c935f1d9462a11dfb4a66563728f8d0a3fb62d82448fd8d1260626aa3dab96c120e9eb2469bb324aff7ddd881a2a4cc12beb31aeb7288e62dc1a1ba3a94fe457508aae4c5951389e6cd1febc12ddbf8dfd00af5061582703d0ec17d288910c54a89451c0e37f3f5024e08d23f4af46baa710c596c9430bd4147cc90f8854ce7e57c6d7c1049f521cc26f7b3bdc0e8cbccc44e0a189077290c8818516be12eac44d84c2f35a22f913a82acb2fdaae0461aad64a4f46a55aac4f97563c8f6f7b34919b1b5a1bd7701ef85fc3775197b1abfb36ad1606a4f170b20f8929bf3089d1da1758609fb071dd4710e4dbc1a8ccaec020370489e84fdeac87ea2bfe524891c0b12c83f5edd8eea5e7abdbdf0d341442a7f2beae910b39db16f950222511294bd633dd7ef50562dc0def020a0c077c52672f13fe14c805e4d081904503ce80f34bae02f2c2294da301a756715958a0289f266ee580b55bec29a3e285af425baa00c152aaca3f90b28cfd38b3fab09a20d63232492bfe6e6fab8852b13a1a6c399ab29ee980d7e6925d42322555db451ab88bc340929165be57d6b14f8338c68fc414ee68f7b926c4f8f69f3a8eeb730b5d15ee8d7caf15cddf0cea1556acb61d063df22d3c7f887999cd9f3396a022c773b3011163d25b55a2ad1b390f8cde8bf1cf3e9988178c05bdb287567fc6809147b279c93d8a0c8e2a7f37a231e221e0e9268ea19cebaf53c6eacac0c6c46fbeebfa23f23f657d7d53d8da67231d7035fdf12e7310bbcbdc5ef754732c9ddcb7f8cec8bfec93486c6e7131097c215e1db7d3105ff928c14ecb110e425ac1b5507e5496cdd427a7698cc692be4ccc801f8797c526652e51f1cd71cfed07ee4928563f5f8e061a527a62c902e0e1314c49c3bf795d15c1b903847558de3206a722a5bb4a1238a93ed253f7034f84cf218f6de3aa87b7e4445efdaf38b35c592d65fbff0622d61c4c63a1b01e1198fb1127583bada575ee2110b0996da0ed0417717b417fa0bf1d86bf3e109f1af7b7c43ceeec752f944130bd6f8b501dd6da82279a1b21569c2d41b0a4d99d0077144deabc7b8856ddbea52589d8ff46affd5b90300ec77dde8ea900b7c879bd93d9ffacb09346985fbda7d5a0e0aab462a91880ca9bd434d7c63eb3a346b191ffb60ee01a713d18b66ca8b1a1a0de45302b84a9d718e419d9d236c32cf8bfb8ea1cc4937e3ebc6a314e35364eddc1fe2cf714bde34b9a23db0ead36972e020b2b0d7ec8847d2f42954b6872492454ff3e8bff0f09ba1aedb0e8c790e49e2560d1bbae75bb259885824a6a2a7363a97e61ce577d855ed14fe88b56870216a65157810afd3e55e1846be1118e930f41af4154d674cde097e38682ff465d5184f6b82ffb15032fb2b8565b378b19f5b2f33aa2552bcc46c9cda339f9f3d2fc340fb95f2ece40b566797a43d45399df6511a897d5792a502d668b9d21275dc7de44472234e562ac8f5e9c3f9e5198fd8f6454a3dd91d32f597b9f6bc9543435abb9633cf65f1a33dd41313b8120f6b368d26f8b26506f07767d376b67a2fb350a4611bb2ec14738d3cb77b36f87be18d19c4747cc63b5b97fe6a2540c698fe2c2b075cd12e3f12b0b08efa5f4af268f0f88cb44e7c78c4d32457844ecbbd17f5197cc5f0c5649e11b03b6b52baea3e528e379b2d08bf8e66ed3cce70f6c6a541f5f187809289085e858711894aab32038db04446fc6a4ee7ba38d584cd456b69c194e873a69cd6b3ed2529095f842bad84a50f89cea2ca8769ac204806e08a31f9da03fc3050af7e6bad02321491ccfd1b711202048ce972d94772bc9924a373bea1aceb1a55d7ca97c9c668d14cc9a71e5f4afb5886b53057d69c9db0fd8abd49ae793d8d68566e18cd6a47b59e0a9aa1871cb2161148718a257258f774eb437f2df91fad603ef40a03ab394462cb8bb47e0905726b00a6a0fa9794c4207ba387ce87d8270ee0578e4b0f9f124b94bb2fffc12a85ff71770eef1247d637afe13e2ec66f45222d998e342a441fe29b2ad658c17f6fc7edbe989b35c491df6e93d679fa46de15eaeca0487b958eceb4c463aac211add0e8187b29da9cf6ae315cb7470e9eea66755601591f5f72181f41300e3ca1dbb85260c443c97362038f31b45c77f3eae9263016324a8c644b21644a0b5effac895d7913203d22e2348eb2c848c801928ca923af8a6a2a86900848d73e3ca98c0a2c4f666232d345ed38afb8c6020611eb7d4999dd454b620684f92bd8973af35f19c51aadd0d31e262f7c879805b3ab2db18d0ff8eafd439394d7a397e6f652696e813e1630b3f85fb5988daa9f6659bd21f1be375e4f5d8775fd675d70632944d731cb4e0c5708e192a0e13fcb5616e3eb11dde099b89d48d5335677d1948e3b314da12f71e3a23e3b75d0be891be512b4c54ab3b9abac17f18f4a121c16c8f4254f950549d2c81718e5b7fe9ca6a6175e6c406eac9a0631559d099f1a18d8eafb327e8fc99d26c817ac049770b2e431954873e77b715b2d70390853807d5600d8cada8a50f6e34c4d269b097d0f9b240103a34c15d1c85576fd848227e7457b94c31ae49a475dd1b98edc5a9e46e85bdcfe193cf13c427d94c5ceabfe2ed5cc97fc6d78a9ada2a9a62ae4df267849ead38f1edd27986b4dd0c4777e968b295a90289adfb1cd41ce73cbdf4b0e85b4f80b7acffcbfcabbe24e40226d1f7203bed541dcbe5bb5005a568530e06a589c6189956d96a788e5fc3aac6ac7f7a3223786dac8e57558c5008866c4eff59bfa8d4709647c49d611e8c17bc72ac16f0722fabe992dee2dd3738759ba8b7414b276e85ff9c1a79c1e655e8d888e434cb15c3d5b6b28aee8c82630c4bad0388b30937a238ac380910aa4a5d4c3f66bbf9a2e86a14e535fb9a8ca99873a1958eab8a0bc33adfc51fe8a00bc076567248159e44c8be4c01b2c6f8a10ec7f030cec74f83b06243d9c92579e5f6ffc0fac4b57c10453111b5def7125677020ed29baa1534e19884a3cba592a2deadf14e76c8e037151f5204b2d26b87890c060ee7294199cd7b41aded5dfc447a15823a3632c778dfd818dfc964226e18ff3ea74966c5ef5265e8aa0b3b5b3c4e9dca063fd939cda8114e7893b0af6ba9ab12ea6c70225f453f990f9c66a57cf597be7a715949bf502d9dd6afc9d117ebeb7524b5aa7ac2ea9b104bc046db20e47d1aeed51506c8eeae60d3c17995195ffc390c2fb7eb7a8e1e0353babf4054d00c5564e9059f447a2a59fc1c0b93a394a1e5dc2dfc21254c1b5c932751d98820ff178a2643f67295a459e807fe00cd29b713c0a96f23e08b89ef92e27e86516802cd20a1d709452c9e8cc79d4912acb4251d056375959f7a01c0bd30de7dc27c1d2330f7ee312fa7ad0e094017e4785a159ff563e0c4a741dc5a90e102d50e5bccefc7fd3bc9428d72d06d5333c4cefd6475414fad8a190a2a5f5ca0f025c5e05686c92292d70f91c8be256397be4f2138df45d1b77dca3c187b980d989f91573d4b3f002fc25a844f55759bb1239f37b0fb2dc5aa28a456f4ed58c9992db9927df388fe5e407fc831cb1c5cf007aed1bcc6ea1119144f20af6b803ee6d87b8143701a00e886c1ca9480667e458e01fc52897eb81672265725b3db91a0afc6009ab645ebab7326f98409009deacfa87c8cd280c219d5f88ae56847a40da9c18f17ad3fea1b1be3b74df8c6ae9e653f05972b97131be30f09e69d63981228ff23fe6ceb3985301e16263a75db622fd5f1bb9e953faf9d2f66ca224df28ae3ece8861f943b959af102d8ee19cac98cb22cf319e8974fd187ad6348ae402585abb565895f0e932e3aef43571dee149404fb5ce1fed54b056d1a2e55e70666fc33db55e34217e21abc561ccfbfe5dd28264098ed6aeeb6326426a922306dbb6a6702bf23c457fd4d9cbe795323b6ad433d7f2d5b862790332dd4ef58ebda5b89e0e7266cddec4f59e7d92dffec85099c7698b6ed650cb330cf885deeec1bf1791f08595c7fc92d5bb9ad9240c3d7a3221fd7f6d719f785be88c8b380c725e4f486e1757eb56afe5c52065afb0ee5c642d681135fb7c9b5ce47b744589f1fe7975809f56f8bcf595dedf52573ab22169a67583eb20b8b7dca04d49dcf5b441d4d073e850479c5cc1942d683f421aae3ea926ae8bbd7ebe8277ec3c55c76cb5296f146196a2c68e3f980c0c1b2879d70ddb7796c0b79ad1400ee1994f35e7ec100af70e4ba5ad1b995110c1daaff8b0bbdb9f90e68974f0578b7b5760b8b5abe6dd9a473c8a2557f9333e9772cfa1c131634a6b787c79aa493ae0ed84dc7e8555550f9093e12bea21ea0d02a28bfbbb63a11104410829e0d353dc4c6f35ebaf88b929b3d585b58d41a8c73f4fef0bd6d76fa1ff35c69c3f99a8deefd0051ded0ec29fd8c6f9b600a8736807cde963aba4102dbac07ea57597cf4aeb0832e7e2057df15c01b08960fd429cfcd64e97c0f9ca1d76c6240710bdd0cfe08c0f69ee4a2bd2be720647ea76c27d435d39f6a4ca3f8ff5af90b8bb2e1c77a1cdfc89bdc68d23f4421e0eb7973a109cc69b443905bdf5fb3deb32d41aad5b45625b91d7f685d20965e3b785bd0ec57520d1dfc4d9344d48418a90fd3f2369da1fec3fc15a32141036330dfe8109857f07499206b34360887235c0771eb23f13980e689e8350791dc8f79dc1718e7262f40933378367155dde1b9911c92f42c534bcdd4fc4b7694eadbd95f25210990ec01459368c95d9a6784f56bf6f95bffdac0ea6cf968843df446300df61ff08b40705626190e2c67481f32e968da4c92bd2ac0651aa8a5bd204e6d7fd731a1f73baa15eab11adf6246a98e510fbdd460c1f4bdafccff4fe8a1e73c2a2aa2bc9c1de23d22d8531fa8bb2a53dca7f65c916f96b6dee4c691acb892663e2af6886a945e1aaad8c4dda813bd6076f687fa6b3edc3018da4f331bcdd6ef86dc5ccb8ff7e6c90e5b0af411b0cf292e8bd12ad568c0c9ece026c7a2f41532763e9498846b9f1e8c55a86ed9f00fb721478ee21fcfe3949d0c3c43c9782aaafcbe815e375e9cd68ab29d3a0cc62d82018551a9728f78fa3d064a9af44ef87a9b4582e909344aa276f6ca517503b5878e8bbb01575f40acedd767c5abe9a520ec84ea5701ae77b4d52785fc5bd09f3b8e72c37d7419c6feab54a40c94a9cd821da2547e8f4ca4173be86b812e2d23f23b5662ecaf4b9770d25334df3cf72f6dc728a70a2eadda8e9e2487700496f6fb7acaa2c4e93f6407fe8d87b697a10a90be60a274daf2ac5960fd4b0eabc8e7922242616a34ae7b04fb981a1a3bdf351bcd4291f0f23613218f57a4136b80f0336d42fce49918aa6f3c26d7b5f58ad3ed3cf1d2e76ea610fda1320fbd4ef7bad89e055968236ddc9941dbc47fd9ca220d748097982415e05b9d8ce703c5b23c8dcb760307fc67392cf7f61b6bd8e03a932d21cc1b1552c6b6a0e6bdf961f44119e5ac8fbf71576bb10fc1ff232712c2937f398364eb98a7953de85862885281613887be71f739c3cf2c51eb5296a5fb27886e33d5ddecddf83820a131846ee230621719e4f24f40cae5192f80fef39458f27156b7c40dd488848c48b6430f8048263a4b83d9fce34d9f0a5107677eee0f7567aef22b6df2f23794136da916f1724a5bf775aad193adcbfe2153117795b9d0fd1bbd7066d206b696bdd05e694cb09a5b8c06f800e01563450b1a0f8382b78e973b16ce95470b626b2d3a8bcfa2c1bf81107ba325b60fc22609f15e0f84e01004dbc7757daeb0877155840aaf8c666797a2408a4d833dce107de85a08955b1ade60c75927b3363e1675e3c9f017a31add2c60ce44c0abb5fd8d6935d5f392c1be3723fd7714897a4fa1644094e538bf9aa81c102548a663a8b221285480115f96697998faf806f371c66a6fe1a3af44338c83180bbb8cade536f864156e82965765f688dfeb030b02c60a4f92d596706d9985cd765b5fd8d48fa5c8d6a99186bf451b0aadc0057c55283606456c455d4214491155ed081841228991200f55ed00c8021efa27eb0154e5e17db73587f8664f60951f6b3d6244faf9d62f2d49a70369a5ff9b85f4d52541c985bb2e3c162a934c8e3d0aa22f533746e778bf8fd72018a373bee6cee0970f93852290c040761520b692ae56d1ad9d2055d60184292a85e811b08f129690673a899c2c139d72021d8723f089dd622fd4e7054a8a58dfa7202514e74dfca8183f5a296e5cc1158fd128a4624aac2ecaf750c776df1904d1d1141e30577ef2213f9d6776bcf4ad1cf5179c4befad03ed317ef7dfdf8f74cbbe4a5c4de750462d580c21cde1ae8c024da2eb1b5fb416fc5fa05fa0c619d7218fbbe8b6d1d922aed01e48b353a6547751f0830d1ff293f0461cf2a0354b97902d704311daac600a628a4fc0f9257b33fe54e80e6406ce04f34a18adf74743758f91dbd4647b0c170f6da9646101823d5d38319d43aa45773c44525b3851c9451d508c91551cd1dfd29dab9955025fd849eba23e02b678a655894cea7e139d0867144e2b9fda8507f6ff38715b8c738ea27296ffcaf91f4e4770852ff5a93e63335277f4887eb43ea1e066a9d80cf86e5d3029b55be171c86fbd1dafc3d130ab2687410c8824951b5c5c5eca7fb5558de431efffc6d49471c9806883ad6b74e1b2c2c9a58b8aa708350d5a67bd38139e6b04c4b690b0ab9084bde3fad2b18b4ae4e4232ec3668f509732570c42fecd9c5a0ec00f9089741d6a9ce918002af9a31b313cb3b12da8f762f51165d67cce17305f87f902977585f79300db1fa17bb6d568f00e4d8fcb430fa0eb434876020488d75402d8e8eaf3056ec6a2a35b7604538efc33d0261a95255438c230e1326e5d6c3f8be12d0fd968d98639941ef482ab9aa68a964320add3a06721aab243aabfb1ac6fc8ce7edde3000623e7057a64929849cd65f8a2ff79e14d2d72fc5c02407849512e4de4c75214d66fa26dd044c2f5ea1579a1ed56021c0d7a89d7cc52a96dd5034b28c117041f34c3a48e39bdd6b99623b768a28fceb4c8d272cf97630440a6adff4c25d42ae32c54a44729419e016cd356b20ddd074985f62ea7048fbe201d91c95969510cf2142eb29d7ae3df56ba7cad9985611ebde1ab3f0715f62bc05774803012f076812789bc0555afaf0ce6558d6637f39b68d1a95e4ecb61c785990552dde94ad0576376f3b40f3763ec662372d1674a1129413d0f5b3785b9622c0f2b5a0745fe4b567597fea37bef8b98cea6123a65af36b7ae27dfd8760579120fc748edffd74d2e41d6180f0557fda8ad222bc0a30cc34d400d23170a1ab17d8e32545785187ea691ef05c69241d43db9bf2762aff6df7c3e2b301887337d89c5e6c707cb19fe802bb0526632460584f6bc136ca1b64b3affab2d2eac02cd663a598757639fddf21a070cd058ef734b461dc0e350288e9729bb811602c8dde12868822172d3b1f11f92ed283876fc5e4a199e6a263c29f841541564cf9bc5efa82e5f04e10104fbdaa718e4fbbb3d59c4e105b4413132901eec2d236f8b1e535c041f14eeb559d7a2a0c01c8a9d735aa742b70cf4fc85b63c929cce1e95620c5e992c87994b7ab2a30e7e856668e217d4fc4a31969e8b32b3447623ed0e4b6bae176eed89e97a796b472cb15ec59d8e8836e3a279be77cba6b1cd928f6ff9dfa98a271170ec4d72f6858796b32d346d8ebc9597df78180c09c597615724554ab0b2ea71563a47d9b9b6de2d7e0f31b256fcd0ac1afe38f8ed44c25c45ab57af2ab8becf3d72d2c7f9444a469b0d57e8a796c506470fda872bf2bd775e9c6d87ca762c595bfb96116ef6dc4e8bf8eb4fbc76ce364dd9cd63fc2fb372e06b4063d2888dd6b4067e94c4c52dfef15e58b6ff1978f1c33209516a72aef26e8b9408ccfef55282a1b52753df1c16bffbb4a6291c40d940a9a856632785a8ff7c13d207644a8c5bfac57285a96bba8a7fcc047d3820e56ee0beadafde6098e47183741603cb81c1fe7e770ffbe10d6075d765a43b22c3963a45bf4004203b3d0382828ef28720b2a6dcba56262a2ea4b66b628adea56a3c25603932d7c9411a1b5b5100951bfac249c4d8d3a24120c10bb3e593b5eb74b16c2049146c03380da13c685c07ed1d18db8131bdb2838c8e4bacecbcee65fde9a58b2c41f01ef3208cd0349e6651a5ade5c78d1ab484181ec31644894244f9920beae943024cd7cd00ace96ae4c625c841c77b5e95a7e5255d3c702f3a29202ac6535b025053e6095d89ca6a8348b356322912e6e6ef16d433dced66efd187f8b44fd30a8b293a3e855bd7d22ba625372a3db453775973a15aab0e59fc7a65ada7b8feaeabd387d0b3cc95477386e13bff9a975bf73ea9a8194e3054f5d13f1d1b606085af64e904880c95c03e47e191dca3cceaf74e70cc0372ce2912087b55f00e1c12889876984ee60f4d9dc51eacc1f237b8da8f32e2ba791ea8efc4aeecdfc70fa8e6f94ae710e57de36f085116c0154c1c33dead455f419bc5754fe2799fc7cf463d4ec3829da8bda67eb2034d86d81814b41cff9769b15ccf13f4ac2866e58c676d3ba8900f15b157c79201d54a890fb48327315d7e59c5bd7e0590bf07dc9a8a4c460d167c354982df4c4bf2f767896de63c0163c54ecab21fe526bbbb603a8235007b86a8f07ced93a5f7d453e1ff45df7863ee8c83e63fd864a2a68f95f919dec1022b20adc141504bbe07e3cd7186285d2452ca8be2c3cc1bc347da25412e5f067cef98a79e6d74c77f0858fcf6a38e995098b69d86bbb2f430b7284ee659d09893c61926521c0938007a10a7993f87374a60fa320ac8b66ad4944642b7206aaf5199362338b71125df9dcc6f4e6a7a0bf2152af06ad249fbc192e6b6b50e50b69e6ff67f026c78c538eb0497298b738d17725536ce45d5777d83aee9d7ee70e254ca2243b7cbc4bdd0d48481802be82dc9f067306c460485d3ea579161e944d0e3abc2fec1d2b8cb59617de73f0c63437229c1be7bfc15876778ddb235850e5a5160c795b2e1a4d7c8f31095b6c99aae44ddff65d3d3833bbb46c6a82da941c83dd311a19f249ed94a0ec9d1849ad3c84aba01e3e393abfa1c22d993925e6912c16d135b39e3ffacad21f42cd908bb4eb15658546212e100738bc6c52559a44ed5f8a23bf8c3c878a25f90b6c594a06c399a9b3d2df47751f32304b17d6347d0b3609d6b7f3e89376d4cfdf56b4d3bf5e58a9b63b6d7eaf01c21a9d35764ee5258aac1e3929ccc487bc2ef7c2430a4313c19752afbb173cba1551374716934a83a7f41807ecbda94d9c809a36e00c89bb52c9e4da73790178f63dac7b64d2e421b0db6ff0fbde9f45a37d8bf0f9925d9fe0addb72dcd72d22731778a10b962816a57e621484076b049d594b221ee2391bf2976694ac6364a234f310768a69784b2b9cbda3f4021036a68efa104246ec28c8777e804cf1c9bedbf1e168e662d6001897c96288af0e61727046e8f597f8f493a6621ad0da1e2f9d9c508c857f2d9c4b2eeadfddc2c01f99d7b51b8e76517e5f2d2a28bbe543adf0b4b99dde5079a219283a7e0012e13cb320bd97b79e7743a99435b5f34cbc9f699e2a67fa72ecef738583f9522a64411ec95986e92c20e9503454f89194f051908b74bf087d7161b779d9fa6e897cf38fec55bbbca03b4c23782ad1945b98a0a522a1ab50496f5d22597227c649d452795385a1e549eb66bca70aa158bd0775e9379fffb6afe3e9ba913be9cdc40750a8fef73c729aec7d5c5174f2f9e5862125b16329b377afa3eedbf3f2132a9595b9b553a5ab9f4c6f4d853feced4ec90973be92bd87ca317ee33222945f0ba33f7654b3055365002d481fee0e26c4aea2622c6419d6d299b8b1b9fd11ae8dde96b5e887c4d87b2cf52b2e47b976c0741aac9b026f71b8ce3a967276b7a79d3c4b43b8feac41a4c5718f267baff282c078651fc3e13296ad93f293e85305cb043f1b58edb2156eb5355d8c1712a3be1f68cfcd1d7956bc17f5c8a9b9928202e30012e2731973071f326e4d4ccd14695697da540609e63418affee52a7f3deadcd8e7369d7ebaba775b8d8bf010562f0439466953e6a682f5657f8f222baf1855d9a7d93dc2ae0abb23dd05e77251de549aab1b863174f4fbdb67ef9f8973bff44a6601953b3eacfe951f33feae0a2d0533289d6ba473e702c3d747c3ab6d7068fcbd57e6fed78250de781c73169f171b349218f870d580cfc2f6661c4a3d95fa9fee6cd3fe0e2e56038b379e478b6c51b153e33be19c07e91963f6c67aef6571c427025b4d900e496b2d22e761101c7b27a55e5541afe92e68d4f3ac79307d0e1a48d8f650dca3392bbdf5783c813a672f5c38d3475ed31353272a1771ceee5a2eff5509d6997c5aad05845c02d7322f66f994730a70af07b0e3e39a30e2e1eb4fa5b24401f477cad9557b33f2baf6daca85ea581cf21cae6dd504ca8873d3c14b15fa01f01a9797737b821b29f0f9179ffe110d55185d95190649f10488bb4dedb69ba59ceabaa1af84034b39ff47c94b4788ee4bcb82423bb390af7161bed0cb2cc15a8060b436b7a863186340b622cdb6cd2fa070f7e697c3753016905cb252477731910f79ec1ed328fa26e8169f7fa2e2d1aef190cb21997a04009b7cab536036a0444fdf2a2409619964ad733f3ea31e5a26d9e8d59dc8e0344bdedb80274b9c01303ef0bfb9ad07ced499da820b26094ff174717cd085ea889634452b0aed4166f80efff2fcccb98363ed35ca088f0dba9c7fb12bd252d14a62a479c9d4f3a14590b14dd7f04393bd95bcb1d7f0efe4f0dd8060e0bd1f7b6a9084eb235470001a9646e808fd7a45387927b7d006e6d27abff00c965b8207d6cbeb8c42af6c6715466f4b438e7d4d85422bb7ec5d3cf7e6c041165298a4987bb0a1bdfe8a90efa2711ec696a14a5c3bd7671068fbb183e78eb495850733c8864d9c796d04302a68711b1d36c260b6179915bd64cf949cc8d4c22a790d4549043d6333f6199f9418ad643f694fcc1c2eeed741d2f64f6b16c42327da1703b5f2732c0e58b82a08157da331048865be7c1f957dceb2b656953a7f0a05fc138e89a418e5ef38bed09dfb361d0545e6b6abd094bcbde728d01f7658d37dddae33e3e1131febb0643ba8680558f6d3a9e09477a14c66020b2e3396f150ba1bfe514abb1baa9e9d9548350330a0f2dea4266dd8f12b082d7a9c618083740833540b2ffb3744ad4723e7a136d344b4513f1fd05c67c12d97a22e3ee420f69fbfeb318cb42d0f1bf7324fe6edd6527e6b30a5541cf79c0f2ffc36bb9839f2eed2d6d5f08136d1b6fbdebd3e82f5fdf0e6710d78ec3cc8096d1665b1d5facfc805a8478c5fa24a2cd3a2a8c7586526c0b88d08019a685ae10abc69c6083a25a6afdbbe49c101fc4e01eadf03d8fa2dcbd7f262cf85db8396e59355a4ce600c7a76b651f48f117942d57f286a2a202eee185dde5c3ebb763e2c065291ed81ad00f7dfe814635fae1bb4aea820c93a865ed7dad440f981bfe5bdb5701043c111c8be57a253798b46168a4fb1e30161ad9dacc5f5cf00358bb03c0fc76950ce88317c2f29b11002924c34921f5b8b8306c899aaa9926d67b843a0c0518c8cfdd72e94ee30cce42ca203c09772e9a42c55ed7df3948622060c396e395380c76811e13d96820d89d123e5c38d29216cb41a15d24bb0c85b8d788d50a9c307d820d491869bcb7a261e9e8535b593547abb0018e8731215dacb6506e466e54b55e387864bfce57095b60cf2b86e3a774ceed1c8ecaad746ac0e765dd63eca3f70be2a4e616e800053a282c73e7c391c80edd615d38370e07241ec50623662ab63c49b217f3eed9b7d50edfdaf8f95ab4d095611a7070bbbbc67e9e5e2b287a59e2c9ed7bb567f63851093824ea95b6cc0451bba139d6d5e4b9461e36","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
