<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a08c12ca33e882b46d3b0603f2a95527a61f154ef6a2d33b2c05f40be68b6a2136a5cd1c92bcc44ad7d3fc534cb376acc693a77b737a9cab8c72d661812d46c3adfcf4cccfd4560c365044495557190097bea6a565395edf55acb7a955413f6c91304e8015229d0848f416e5d979488ca373d3aa8d235f7dcb3a1ea0b74ffe1abb60c5a5b8da3b65e29cd3f611c4b069c0c5aa4a3176d782ef82931169849d43735fa4fabfb550de7ab1cc2caf56f162e12c10cbe0ab87d8641dc80c2cb617e60b3d9051630b91b647cdce526e883c242ac179e963e25022f6d210db51df0fe64a850df3fff8b0ef0e1c9299849e3c44f2b08b52f4458c317ca3622bbfca04a5f4e25ac7453083e3051537560486b78b373346ed7212a47ef9d4c00020f54418ae8614caa6866b8c9ab62054ff2a8ceef670303b4f4a69a4e3e6ebd24b6a3a5f216196e2bbdac516cab696a2f99deb051a12a7e2a6d9f87569539297e9296220652461a4a116f7f08e0725c1ddd26d3bfaf380e2e4176bc5646ab48f77f237646964f6fa13776cd6b1df6af6be606e223915500d3da734fd193f0a79db33774291eb9d6c9371217c98c389e8cd451329c01b7edab38e51f095cc707403ee93ff529a6c58a39b263017ccdb154c61be146b7747754534cd69df0b3a0da9cba7b74351b0524120d3af7e78045e7ac78326bd2bf013e5326d8f9c3b32f864a3fc3f5ce7f9c0060d1d9984fcf55e9398989d1ee3a7b0e0e81dcf718a4ddf6bb195f9179c4cb5c5a24127b62ff7dfbb41a6d9570c2700fa49e2dcad796147090b39047d790bcc80f694affb7c01d1b7cc5a2b8287ccf1df9db6095d26f0f139cd9a83ab67020046b3625cb4b42a9bfb7709b3060f49c438dbf2a47beda1612b9f18e6ab166f5e6c05ef95f02419db75cc2eecf56bbfe29f7f48a0a0958703f1b432842fc0b029eb06869d696f4dd9334b9f117b88d71a85614bf441b869239d4e08db030ba7901d9389b9139b43577905f97d43e8e8a866e9e5b8bb62fe41928bbbdd8c51bfacaa2d5fa0c16db5600c10b0040340c5f3033184ac8755330d221094db46e49892921670deea2e9911d926544476f9c2155b2c1450a34a4767dbcb3461b4c81475dfe802bdf8b906235251cd38591fe3fadb9a041b7262b8d77a99f754b50b30ec05b4c81112f00870117305229347ee4dbe580b74433f523aaa3df61d0124fd6b03c465ca5ccbe838566fe6702553751f2d161f5a66270a0c3af8fc5014a1076a4da14a8e8dbd1bfb1db56426c6408a5b6c85d71661813c30ca4691f572274412f6ebab365341c69acd74b0f0ee9bf83c2cca32fcda3660309f3068e63f023440c849ae551d1e2e43671271369be2871dfcd966ddfc5908218ae6385c98e167028bcb5ff50e779c571bf0b86244d0238425553bbb1bc6b3e390d31005bba4b63137b0824173582956f2445bed4d6f5c599498a82f844f34e9a9dee5186a737b075ff150102b8930709abd1b20359d44b7b2c91d8f84130ead85e6bbe40435b4a6da3d9801a8cef64198dc558a2dedbef151b9801626a41a8c2f5df56332696b557f1695f0fd2a7284fbfa1d7ce08a9c6e03b4bd0e5ff55bf261b2d8584e064f2915a094372b88fb56d75831abb88fbeefcde20971be389340739a6c251b7abd27fb85a709cbaa5d60cb24b8e26df5416481e80bfd10700c3b504d1ff0a2c7a5d12a476473654631fbbdffbf645e25f400256012a14614ebbc1b746b9f01882a23ff8d0ecdf601875ccdeac8bc6af5334ab9327a9c444e3c60e64134b1de9049408587bca302eb99a583162186236a760054119cecdc9beca8aee09f80ca10ec24c5b78355369df93e66ef2a820ddf15ad1b63c1f674a6cf22ca7eb35243b401ca8246b29682915117c936d2678511fe275923b5fbb8129a8d278bc59aabc5cc88bc77836619a5c4874ab41b2e9056d95f56609d968d0e6da0343e9f9d7ffa9e8a5e31f2ab2805cf257c2d25ae9ab4b6b04f891da19a3fdb7fcf82c0db0b8582d5b7c08bd447fd8075855ed785897c19d89b8ac0f2b19aaf92395145db852ff97a343922869667b850d915cd08637b08e7f9e2acc0e8c0e97c4e920fe7ac81ca804c106ba5df22463e993ac9c8e3a33a03908a384293b336fed374761ae9fccbf77684207443b58a9cd1ff393f417a5986776f059adc038194acf90bad85e3f546d9b73a95e6b70483285db50819026b72b45885edb420e8c8701845398d52541682504dc0146caf1aa54586e0ada29ac0009892df738cbda4dc55704be9a13db276d5f59ed07455d4e6dbf462e7f6b7bbd4a313f8ea90a0fe4b1d2ca3dba4540ac907579e821c7a8a3bb879052d3eb70195b79de594487f1ff3a41a888bf5688d3efda11d7cb7c26bdebc86dba70b805b4383757aa73bd6e5a4b604e23eea023792ceb75bc81b72297a132e7c85b0f014f5bc29b4e6f3faedbd524775ed90627baa3af4ff7cafa2da16576924ba4964e33a20dcddd47086e2d362695802d3c4718ab055b76d9f4ba535bd429dd08e91a630f642f7ce142cff9f4f9915a679a5726e0d74b7a8878699eb8f96930d1297113a598f7d129e9bfc7a5fc951dc6fd29f3e71b113712e0faab4a8f13933e36f7e7766af6bf8e634449ae9febf00f3e5cef577fc0fb9ebd7ade8a6a44ef2033dac3bf6aed02f85b6cf580d9f5e93955ad3141a8539b23d5f6e47b2491bbc6978bca17e3cf0a311386f5b1c0f5e867a8227b7b2e42a4cc464f0e07980653a14a06d7861ff264fb5def9bee65fdf5f6723949328dd101f4831bd03bda5c81cde77cb779c6b8da2c839095f93c0f40d7da68eab9ed2f13af7a47d86c8aabca941c56dd473da9eaf8b31d82fa1238dd1bac8c61c25b51c0a14d5ad8bce75dac2d43f4e85bd694503092f8e13d72d6cf9e02ca69ca3ed3b32afbc72198e20060d95739882dfc810bcc36782ded4ee423d58dfd66620806a376091577f2588269c5176e5a6c2af48ac262220249b5bc6a5815867719330e1feded4ae0a6802a2129c85f7a22f046636b632516958522613e8a30a9de1bccfbf41168c5c0b15107e079c24c3498562d1fe064925e5ca86c4f2454b74d3e053ebd1eb9be3eb1cdf63dabcf31ac7573232f0ef0e84bfc2ab1e86395f76e8b6da4da63d4923dced4e73285c75d3e0bd00597127148452c586f43e78802ff57e2646f2654c45035f9556d948a1a7330f32a049f391e6d221b5220694f765be8a589966b3e031a2435064fd45699003d5447ff91e35f4657236a21ff456d67d4ad464b31cd974ddd5237c0e7f5c2a544d7f0eb0bced7143be51c9912d107d8b61ed073bf3bc33894c689e449aec9e084d665248b891f4a827d0ede609b6c8f9c5eac249d49c728aa8ba51fc2f0f11bfe01e463e95397f1fe697898b3d9d2e17b349d7e7ff69eacb69525a2e3e7f63efe8ea79447ee37780494c78caeb07e22b346ae958461c0929c3f5642e10da960f899ce2d25c79a76d0f4b17a76e650320ac14dca1354ba9019d704fa21f58fdcbcac889fb7fd2f8b484c1780819018d97c08ed33ee4afb159e439351ab953c1a37a939ef7c1e8c0fa488716b70939307417c206245eeb0a818150caf8d4529f64e331423f964e66c2609c779d95652485d22ae7a883f784a48e7c7539ecf7e8203caf1942baa291b8e21444eaa72bce9550677b3622f587ae90df58004241f6f44d56cfed52d59b3b693962cc879f02c03c303d1cd2195213e79f91d13754c98d8e9e52e0adab4a9ad3fcda8c56496fb9da271b6d294c53b1701efeb02b5bda5ddb0eb9ed5d7928967315903abef07d5639ee3e89ef1cbec4d759c07e559ddb95ea5699945ca0c1e6673ae9fba5a7739dd971f406595caa3849d1852d6b9af1f6981f45fc151d7db1302692e56e17258724dcbe81f1c718cc5a79f712ace09338417c27d4307b60d761031d933907759e6dcb62b5d6876e281fc361a7899dd987977718f7a94d87afc0d23dbd8480961c81cb392f45a496631dad4debe3ac004d4be6381312fda5e3a7cc9687b8f6cb3282b7087a7f59689e4c722a34db9c05b8fd7391a0b564070cd7ce8a1122e1b766fdc61751d31fa52f4469619b658025fe10b4e6bd222c545141923230f27ebafee9e81a515a9e95da8217d7155370d561f215b1879bfb72c312265b3f88eb154a20f54c7484c762803a38021cfd0b2bc1ce40e348352867b7c350e23900fb73570b9478e83833ea7f34e03fa965e93d5ca49eabb877f49533ee508498315c235e77d1873951750ddd6a0b234efe5daec9ed97a02ddbe9a44f6254cd9b3cca07823ecacd596e45492e7109832f0bf8ac560e2f288570e02d8352ea5c5b5c44310bff4444655c84fb8a0b9cd64e1ec69c195e82d60d25a0fadb19428c1ffb0a50a0e79a197e31347dfca890e2c283e8fd9fad811475ff19629445042e37d159fd69f3e9b8ba19c3b8061f9b0dc66ddd9ad8823040e8f1e81c68019b3000ef438cc96d439b5a9bd1e2304969da90843fee501f2011ccbf64ec881ddd30fbc03d0ee06f5826b75607a53976d0354f21155ba0119ae3457d4a61f645174556154bcfe856da7e4b3658adecb265f1e15774d51088a669a7abfd36f7cf7acac8333e8abee175713b516322da695dce7d1fa891d85d93b6d8ed638f9102a5aba5184518a11ba4a11517ad94d3289eca6415158815c1205bcaf51e8d18c75ec59e071fe971b150151b6066d669c38de1811f68fa99d10909d092344b7eedbc6d2517b8c081f1836668d99ad0ad1366f6ba59290c39c291921143cad5857bff06284e1fd6f07cfb9cfed504532a991704be7a4605bb6b597eb78a6afdfc5f8924a0a1056e2c8e9b57b31fec906385da73d8e3132c5c815806cd5d07fa9330bfbc70fb9faa31899b484831b888e3802a2c10fe04611cf3156f43aa82535d09dcd2cfd866cb461feb85a7089849d6e43f237629eba3d2e3aa3ba5d96ede626a422e3f31da78b4227a9501a7254e0f4523f60425e928b92dd8432580fa0f14eaa93096b014b37ab2935078edf727550fa2f9e3a6174ffef27b69e68fa721ae3b19f3c6d4fbc35e2389dceee025a5f3c4a86db4097cfe5e55a14a62c4477057045d12b4aaa1f9031e6b0c3dc871a6de8e6b9a8d1bc2807b318160f6ae85c3082c892887668e03e4a27d5ba6fe3df061985bb0bec6e643fc695c9b5110bb1904a4cbcc83d61f93e87d77a36e44947730d10f5bb6848a39b5c2b2b30d8e0d7211c2b2b89a93842346cd3b7d3a5cc59bd9af33ab2b1d99cea3b06ff30650e3fb4ae6494a3a30076506994f4f92841d948ade517faabeed512b6beafc426f59b7b9416bba758751e4b768c5afae6758e54df23fd221ea41c6f94216211180f38ff44625a8eb08b27987ac60c3c8172b61aa4b08cf3f568f2a1bafa97ff78500b927b359c37ac08f5a850bcdc410cb8455ac8104c8472d67394520bfb8dc6d39c5404bc1b3d722bb8d3f079b2e26abdaa0adcb0236a58bf0db40ce31dd51ce9d152fa4b52f92e118f94289ce04518171dcc5e2b10116bcaf3ad2686446e89b6fab10145b943f22fdc7e27b86ff9925d007bd5266d9c04c5a241369d0a7e8a26e758ad6126533f7d0bb685d0ca43143bb146947ed98d91439d32fef917ca28b5b24e698ccf64373267bf9b2441b39e875f0595331475d07d2398b1fe8079fb0d9429e662698f8f1ab177725430b8338e56a383a8ca9722e3049387292a412d0ca5e2ac910531c537195b00f0bc05fa3ff3324c2ea877461c596dc6d83e39bb6eae17d7509bae320c4c2be7e47d7c17871c65fd7bf0c7c46158679a60e31c291e2edfbe8cbc0b1886fbec98402a8b4012da7ff943ac77f1d3b41bb2f90626dbdaf2c79388668ff471a01d09efea006c41d5408a915d46a2cf334c13f398913f97b8b0d62b71b7b7322be8388baad3a71ad2a9356f852ceff032cdf2ea4e82b37d8f55f7e36acb0dc54ab73ecd13d9cb26f80f805581f4b7be815a914ae838e837e186ea4022a6cebb6de8c79195a890de94831141273ffe6d4853d71986cdc2384220a79d1373d3f0383ba770d0e93af93e262644085957b9686efc28236ca70564a9854921c769743105b0c5ca7f8b80b63840e30dc9193f684884075aa81e9727493a0043d581adabefdefa651d7d9fe299dd4ca0c4cb0602c0f821b08c7e516fcb2326d16d4b7b1dcb1282b715489b54548a2fe7a90ff0f616d7ceedcd7f13f3dad2dd2322f6173e65e80985713b8422eb2f54fb99605755956e3e1924e9ce3d7359132225f918e189d8d83cd942acff872f25fe1940b3b2646c9df8291499eef9c59ecaa5be3886dcf1ef68dcf9c3ef997b0a847007bb911e95ebe59e95d91ee10083e1c44f610e557f4c2ccfd9fb52336862464266bc8a47594e3671b29a062077453215f72f272a8e411ff908e466d9887543ea6722f8287bb36db678e561930e58521587292878b41ef92150e2ec32b3a27e949bfe00acf00d2ac1db86f1a6afef500cc4c4976a47de788a78ebe7bdd821166cc867e55bba13b883665392e00fde876a379f30710cd55c7228418259eeacab95b4056eea9e2c7b690112ad297cbbe1ef44941b490f05a82fbf260078117c7765715257135c030b08960652ce79c82ccb5f3fa00bc371fab2d444f7e40367ef8733ddac4249bd8c0669447a378c8d2431ac9b687a04d1bb0b586e6ef967e7212f0a633d5d2a28c6c60bf58b94024bf0d983beadf47176078962a59fea78da262247587ffd308b8eaac4b60774bb5ab307d7d2a14dedee2de04107b092e0315bfd3b554c93e54679062a4370099198e0794734f926d02fba38d253a3e8a70265f9c84e147a0fc14f8050e6f1e5dda96c2a7fd643d1d097045f88e07e7371530d7eeeb3a5050f5d0c264d9dda73fa16c6ce00e9288cdc9340be7f12626c44346211aea9a67403ca2e2e22e6704b24550150daa543df11bf17d6c1661ce72ae1f029860a210126b9e9b74a85d822db310878b2af2eb5005b814ebf56aff86e0baa102c54f4268f603d4f3d9380642ea25ff954cd983069af9674ae530e81752e7562afab5bbd28ef62f5785ea560c3cee9d442c0ad5b92d785b748770b0b4cf8dbfdd1f6c60c7ba13abf64ab4b5554159ad94e909d455a940a3039ceb5898fef626f22a965e899a0b42ed0876438b5797f8da2aacb079ab883d26e414045cd1948a20df4e596a4964114965741286d3ca076cc25403376bcb733fc2f59430a791ec4f70a5b26250294823b9482348752aa2558fdc2b6ede7fc2fc6e509b3162390da6c71068a4231e1e06936583e70910bb9e05c2bd2a795d5e550eb0361b034477b943ce2ccb4afa2f8fac5e99f26ad9865a02c0f7ba8bc4c7be28dc99236e1fe2ac5bcd98a5a8c272a95644fbd768e762cb7ed4c68c02e605529c7a9ea87f4d13908bac1b5175871f1d681d146b884cd3c665763102b522d057f2c81008581cf5c5792bc8e636e4e4595202b7ddaaf200b1a7dafd1973f27451dd759c17b29ff0dc35dcc9e68b6ecb484f184d49bbdef17bed7d8378d8c4884da191f17681a95fbd9440ae1bcf205234bc1e2ed966c634fb4a385eb35813dd395970c48d0fbb6a58c81284ae2c79d29be4d0d078e45f356a13df85f4a113a8a579c7ab242c1b221da1c775c23bd8d90ffd17c8e454b312dd6e30b67ce34dd7d68a9b194a7c25307f497e2dfc2b218f39f50a5af278f6ca139a0b199c09975e7c9c614dfff26b025449cc944e6d208405aca7f29d28fcaa80d106c28b7e7434ffc65f0e0a45023146a5e525046c0e6f5a09b5dbe01658e35b3a6b4ace7c4a89deba5db76e2c2cfbfd5928bbe03b67c39a60dd4dbce6efc665b219cd6db2b353798f5fe3daaf0e2f85b4f7e98fa6c2a1b4aa5a86440d7f100a45aab7c7d81b687626777ef44ed6dfa748d3f8bd012e2fe4e01323697d20f8f1398d66f492b7893358a13324314ecea55c83c8b2d3fd7cd798f6446bffea1042a04353750a4c62122d639a0a3a463f3d644d4be6e095984f8b05c21b66516da86c6e3435644847b6be39d57fc9f5c7ddca272be1e509159a14e5e17fdd93a79d0c7c6369d94da7d299d320f05cf6220c4ae0c9d08a497ed2fcd71126995446f30ec8fba5521d8c4c76e14a29dd8890f6f042af566197f6045d7afe337b765f1a0313d396a5c5f7880c8e22d7aefb391a428889ad9a4912dfca605034d61f6c332ab93d0ca49f308b6e53ef4f602e91ad14c45c9115978f93cf7f4e466b26a4d2c76e0911ef5d19205eecc8c1904734a6ae017c18e13f5527d7eb96633e7856f0977d649b81ae9579634883c3f86433a4ba4b20232500e2138188fd0bb01f160b5c18317428f98b4a38dc5f3a5019fc2f14a01e6ccd65ebf7ca047694ca1728fb96305ede981e66d324bbab18f61d5fc3b5443c6535a25ec99484859ea787985b6a5d95e3e728c520f4cbccaa98b6c0d9508e501f424f05eaf0c8e330dda6f4ca3402ceac3317fe86600353ac2ebacf63a77fa2e6d2e9a4d1ee1563089fc31eb17f8087c3e930a05cf6f36552ec9d241492f4f52f4bca1849429527e139d141334f8b1f2615cfced1604d50ba35f4d21376fef325d42f2c33d98a38e3ccbce04cacecb91c5da140b49aa8ed1488ea981f9396aac0630d6a30302060aa56d8cc36ae3412844edf38054ece5fdda14eeee01145713d321170c78ba1e59ad298fcb155bac8079cc7c0d848b876e894ab18e2e33fbb702dea7d5b059afada5db6db52e350237f37632a435e96a14dc953f2a84f3593e11e7187de2da3b3a63f1b720c76c3ac836897fe93ec04e468514f97899ecbe4cd85aa79ebb667ded7746329a5c2a3dde307f2b174e0fac674b667cd69e17746c722b8feba1ef63df2486933194625b4a129cc556f67b19c9e8ce1b512ad065a57c85c907a2431213db27a4d5c3a74fa03535564cc8014ff8b9ff02122ce51e74e555637603e62b76059d10d7d738b122bd713f47eb2a23d8834368566bbc9c197ca0ead9adab0d9e975d338c0f9fb59ad4efb6f89442f7871a9c840ca0831cfd49de7858d1080e15f2b1f6fdfe12d16b7d751e5918d30c71e2e519350f215e3a5a5cd71707fb74bc8de092e0f3a45c7520f2bed87d018beba0188bb4a09c223628817c94a0bd134b39497127c9d883eba0bbc154c3eb660ab42cce3f51c484b52fd3811c669b1764ae11dc66a6f9fdc47efc840988979d1bbb16518f68e04c2028c20b3b3b0fbfbb7654c38e293ad28f904db737720668b7d600c2f257c03c88d9b98cbbfb100826cea0426fb83526d7f786b8812ac0b4bda1098a3816d86faf3fcb24a0e71fea43c7cf5a398760930936e4579d372cbbbf11c2cdf155c2ac74b06ced2ce4a9d9555ef6a53daef0f5814402f0cba9bb8418ae0f3b13f116627d0e622a86b27e5c18756d9f8df4588b4e5232c3dd27ad6ee376c83188786ee568930bc58a77afb5b540ba9500bccd5e27d9e94b5fea3fa51b611c27f3e7fff3d5453ed8f3a200277401337865a3ae95eb8de66a9c43c464b8d959e271c464924c2a2e85ee7e1df5e7006c2dc7e02d4dd6aa2d8e2e8f81420a22fcf8f398797f4d82881b3d94c3e2000ef8d346293399fd08456661e0f0fdfb3d75f71d4b2408c516e0b2c775576fd80a1def4e928358533ad485961d35c0955ab283363addc98deed1e8b00c8740a63b36e4b38e394df91aeb947d0083e1c744a7b63160e88898baa8221b15febf1f7ba7c6c67186d95eb1ad9049cadb577a3f1373534b12a853929f9afcc6f88d10edd38904b888ada877a58133874198b1111c165e891166a15ff462100e5f82fc93d32bb57a72366425eb41fef02e4ae4e4e2e593b9c99533ba8a07fde8f8ca966e0be8efad11a192a0fdd2b32fe6208942717324c675f848eaf090f61bf7ae0149c13428d29363129c0a39600f6dbca49365500afb15a59da58f6660e44b02f239a22361106ebc31be7c6c8e2d01ff64db07acdce404acc1b286fbf729f12d133e107e756da8f2d6de72e67d93655004f44baa4bac58ffc9b2daeecb3041316fe4dce836084064aead997935d907b4c0e9374ce67c6ff8b4067f7ea93bf0128a59bbae911d9f6f750430d190c8fc9abd7e57cba0fae27c2a78e736f228be1b6ca3f1ce5826c2608418d0e9eda5e4cb9eec8486ad984a7e61226ec550fead04377b59fb3f57cb4471ae3ae4fd629cc2274c8f3b7cd0a09c301be4090a635a5b34119ae8c63a41eb7fa8a22cd15197235e8d659fe0f602167b28a4587abcdae077cb5aac5a5d2c041d57a283b71727179020e20d8405ec53cc9da9c0817ffc9dd4cfa9a0e45fc2fc030907690c2776bc702e7b5423ec2f1c5f5ea64dfaa8ec54d05e567055b602212fbbe4600e5330f2c9d34cbe27a313ef4bfa385c65e82c831e10621a9ec4e7f77e3043f2bb69eec2247ea35487723c7831f2bb021d343974b2583a982e4ef8b8adee086ef3e0ae208e7baef282c8740f1ad222c42d1f337932f77275ffcfd530887ea9c24a4ecdd76227601dd34c56718d3c6da6109446729f0eff28fe0ac2723c4249fde9b5b4837d485894716bdedb331494d7d7cc77685f3b96a2880f59b15a8e890ed8582095e3ed7147374194d5a020128788b5203fa48f8e5305b5e122738104b8d2af0280ac0fee32256c13ba52dc4d4183ca869579d7baa1164a8612c50a4128c48413cbb023bf2407cbebb1787a0df757e5b4f400bf82f117c4b5265f7037002bc0d2ece104783d3627af3498e26ed7ed2f6e9a0ec8c58acb39e0cde8686899114746fcc2d40eb3d0ca701cccb07a6a77c42bfeaf0b68ad7c8e868f4197eb0c6441d7088152a897796a805b7d6800ed498a1ac88e1b351c7e6f1428b1ca6041d23f13185bf0df687ff1befda6ffb2e89b735c5320f34ceb9089b5f0562456c21ce3060100a6fc9b928a9a025fdbab4f5b674d5164a594a1d2be8214367baf20fe3f9d00eee1fc04353080a900a29cd802f0f1f35fbc037f443972ccdc7e1f2056e2d960addf44239619692e907e110c06cf8339e8a8073f2b6290ba04b36e0fa233350f579a524cbac07aab8b3f8c70f6d081460569604e2d59d583d1a447966aff67af507929135e7b8b690250c46d5a99610883eb01f70e1439b9ff839b88bd255f998c7963bd1020340e49b30a0d46beb0a16bc458632e7ed458b95b5aff929b17e41b0c58c54fb190a4a68c42b9ab6277fe56f8edf0dcefe4778ea716bb6a6c329695a217e27766307c7e65960124413368dac99c665e81adebd485384d2f7749fb9fbb5a801f025b2bc7528a997123803d167e2e39724a6b8a1a769cd1681ed6b526e5136459f97175679cc038a2d579b3d8ab0d9d6fe91d7bcf104ca93e5d48364cd796be6aa06acaf966a3057702cf3e06e6d8f2480e4cae0ef760f1a17ac03a41b0c4088424b8b0df7b4d9cb0baf36017764f0d6fd6db3c25bf3165bdb6a31020dbd47784688550d97e5f955f0c35f12cd602bde9a284eae160843d8940809d8ddda97eab71086c1770dde1c5a5b076912f9a631c6928eb8a4aa0cd0640cf8f819d980dddc8efbbea8161b1aa87d03a60b5058c0a1ba5e2b1a9f5d36bf683854832201b67220a401da5016b97cdafb3a889dc494b9e2416168a16c6a369e87d3ad16da38d6e5b6b24ee28e4a02dbd67b757ff993cf731e33fbc387e2154965ea49edd3b8d9df3d128ba9f20fa59226527e133f22a4c6314ec73f06f89f06fb9ee5d9d7673421375ab50f14b9ce25d9f6dfc5e03d61392ed3a62e3ad781a6860e6487e65bb804a52eae58338fe47f189fb320e660962ef643fe5f8c27dd84bdfc9e81ea4edde767969fca0a6d7f2d764aac6b36e7d07d3571b73fd26fa34ed9db1dba8b71d7b9835b056441cfee6e064d350782d530957833f18279c49ef500e9d2ac392b4a4106b3a856444c559afea7d92afb0c8536c90c47109e48216bafe0be79788ac87c7abaa2706bd7fb554b9080128b72235385795bf4e6f6c9292edd2ac94b6c2e8c87092857b7fbc57de2fa9ca5b403a5e1817fed9fe1780515ba0df7ed2c1894fc4050583f204d296826e077018cdb04699304ecd6ed4893afdf93114e4ae9f02e917f2251038d207d306a96ea3b0d381da71065fffeefa2635db30913bb2eb81d1bde96fda204892220a36b629f89d87cc9573842d1315795b76f4733736603eda5db8cc1fc662212a9a4e8fd8b90719debb6f605584582a267839e36ddc9ee3ce9d64a240e66d023f8fddb12629eb338a15533c23256418b9f6c97987733d98f5ed5f8dc050a217d1514fa060921bffb112b6c432d88a7083f7a1f61630d83bcc45047d3a02ef698dc6d0b64bb803bc3ee95afc23b28e44ca531ecf1215369f83bb94835a11f40f63102cac6951e0af8070a9146e381ee631afec96eabace1d0efc658eae8c939d92fa4bfef834272b4aa0e7a70a9cfc2a5ad09befa59c572aacc81a76240dceb1a8ee3889f2ed0780d80ba66f60539b5558e6bf52fa78dfd0b67522892066a04793f37dc6127529a2837d634d361c926d4899c0d824e91f54170e58e255044a26e206cd17201cfcbfddc3a20fb72e63670255fdb7634b0f72eb1675f5c79657ec14bea01754612d77ed73d76671e8c1af899d389a10f76ccf74b5d2ea2ea468c777f7f404b22aba2636ee0379c79c0c6176b165c3aa29cc225f496d548a842104746c12ccc34db2da549ce41d0d9cae396dee2388a8d89cb8295f29b8361a08de6a1d6fda51eb581f5bd153dd47b5f2fbe86506640e016cdd97899076f36695dbe55efc3ebcf72ad5a8a1eb0552ac29f6759e1f0374cfe719278b8e737a2a0a0b6130ddcd96e845ac2e028bcb7ed630259a338d0e3afd83846c62cc1319c17451775cd19ea83127d1fc4b67eeb2d83a34dd9dbed1ca8b9482bdeefb627dfd54634a9d2f3972e957381aa9b110a578129cabc9ab35b462e23fc3aa893cbbe38ed49bb5e63a157dc16716506076ee4037cb1df8b95446c7c57cfd5a1f27ce7fcaa89b3cf9bf992f459c746780eaab71115e594b3d68fa7760cd0381fd1b691ed327fbc75b40cee615e2245628baab939b2aa159ac27bc125d83deda0c823f7eb45210115e8aecadba2936845302001a587e96de96ca8b15bba9745e42beb974f60498f150a1e0a9a9df612862046088f51cdd9e53b80211dd0847ee3eba7417b901b50479e0564fb9d0e3b3be8ac7939bc15f6eb1387731164e7aadad074c14d871f26b01a8fd9583ea3aa9a46910211c965ccdf97d126a15661636af1a2eaf70063e45e1c024da8038ca25fbd53a7e75b6c2ff8ac4398ef52b9031947218bc07255955695267da3986359213e2e9012a2948b46fabe9ccfc87dd45e472fc187de52ff303d5982f0773a52d7385186b0b3a6050490945f71a832f9c20b5f3ca740e7dc96e8cbab164b76da0e67ecc50decf763a602b0a7c8c0ff22c230995445d4d0e0e9272663ae6b8dfb6ae2b4b5d0d04ce8a3db5e4b846c93eecef5baf4687ee6bfe118b2a6524ac47e8eb4665a6fafb281e1b3fb5414912e7e111392d0f741d0123a883ad5233d1fe2121a29200219fd0c75d03589f8f3134a209629125c79913cf2733ece948962975e99e21b4528707daee7477b75fcadcc94522af29418b31bbec0ccf0bad13389f36b5805576d38a7b2493b9a4c70a02572d81b7b63c856f7adb5977ecf408d84fe7a165dfb5977b61901b84d7e546c47c172f73c13b8146f171956695f8e24766f71a0d71028bfd104ec2a2b5a6329eee82f7f6bfc7c71eea4102c58b52dd0ae0b5a22b8c453d547c18208b7ac0a4324a053363946f787a5a9037f5ea848585f7a7f0489dc5b75f5c01e928649d309ca48e53220996ab03b39f6414ca3600a8779c3362906fa999415d888e33efa6b02afa26cbb0e5c93f51519c9fc7d037ad6230570f62ed7da5fafbd64a5cddf258b0367f675a1dcd5d4260125e55d80db56259148de3df049aa8762d8e00ff431967666e9c7aa7d267f69fd40cc7e9e8de70aa4a08704efce40753007536bc554c17b96279885901553867dc0d854f90c849b22679439e386b7a66b733c057e9e9688e1d6b48b0b5f2dfb3e42b287052685c5f4d3adf878b9ca1935b3429cb6676e0797a75822b638382d26155fecb59c0d3af89089627b872c3735cb9608b9bc8c7102807bfcede15c465299059f1cc3aabdb68f93aece728d6f8d6a2ef1358a56fd02aa769e49a2a2762e04046ba18a976434008b573d8955ab8f2128e4abee69fa006882849b9438f10348fe8fab0b952efbf5d520e6e535b5a52cbe87e6369f402e6100bcad149c761ead5b4dc2076f886bb6246640c07c5a4614d6628955296ef7d6076a43dc46b46378237aa1eb191729a66c0b2d80243f87bd3d2ce8cf9ffa28dcb925d65829fb3e312a41c3619afad0c0b43a381f1edb725b5c820e0cc24d1333ba15933cea327a7a88f5f081bbb55a32d94153cc03cefab0abedb5e92e993d2cdf326f90e56d17c2b04edf03216a866eb019b637cf54d57464ba30c51fb2b9bac51b19534b08700a62af0931063380d34dd42f03ffc242d3c89e95717c157ddc95774652ead19b4276889ff484f996e5a1ca8a46562439cc773de065e1ef394dcfb5d6f98ab2f0f9a9f426035bdc6612cc5c5085a8bcb3a8aa65106656ba08b9ec2cff9a7bb41985a5ae9c24c98d87504a90178f7d3d763220b81fbcd33ca74ff84cd44654f3092540e8a9415bf688c2cfd8e87ba0d9923d80c864e0c36960526c5060053627994a2c911e97d2c5c067cc9805f133a2e5e518d946ccb4ec143f042de7c4dc6bbdad8bb44106cf0d188da2b6a2aa439fb5fcc229ca10fef4b360b76967ec9ae49f2119d9d8e0e0fc3067188c262a99685977db21ac245db9b32ab25616cd244c55a6f1d3b06ce0302d871ddf3baaacf03e48453a2de2f33e9f650cc7a60697098222b04dbeb3ca65a83df12eb241764223963cbd3e1835c3109cffadf5aea6763e4cb1bd54f3988b85cf1db6b5f8146c7ed4351ad44f0a2d0c9621846c48b01c9fe219e969066057c51d2ec438a5e7589356b6f9df0ddfaa1f4df65d91ce74f51a88186a83cc3bdc4b596c227946a41ac5b4462d0672b32bad8e166800e5f8c2188b0dd9ad0ccc01ed8e094ddeec79bf4321a09bb5d923b8bd87fecc4b0f71fd66be64e04fab2c4c40a0a006411b3f25ac84d112408d10dd9b347fe7be97139fe0ab75c824ce96eb46fadba942a2c8963492ff26321f04e0660789a238d339dc9de27bed87a3fae7027851bc7bc03254c604e17f664c6e27947ad93870613eeb3cb59bd7cf49d5b7e7cdc5b792dddd709eb85f26e652c473ead41902d2aeb382712c14f1f4187496174fbe256cbe1450898b10df8d7d920821399ad0958f0c49f60ad0f2f12bda23985ef5fa5ef118145e4506f8d0f3fbfa10437dac1cc831c4156baf1abbc18749231c11ab4cc3daf6152d66ab1c21f850881ef567d24b2c6b2cbfcc8f7d7e71904f594a94880d061b9aa2cb7d12699331bed93717e5b09b63670d591b8fba10ce4eb924f0f7068913e1077c277e07add360105961cac13474d761c0fdddacc08ed94164d63774938af62a40769246fa8f05518503c12b560a4615f3a80cb3db1ab13c7c92ef2ce50cb701610454e7ac6b99f99a9a1ee94bbeda1059b713012d464323293710998c26aa04d937242812da0b0407501933a9b2e97b9ef6aa43ef4e7c2d545c0a52dfb2033ddf1c526ef91e2936b9652dd3d577e8c641a740ce1584ed4366ed969bf0402503e67962b902855a70dd88a501a1ad9b3adeadaef7b0289e5d75f00975754d739c41399de08639ab6a75002bdada6516a438037a2969e5a4572c468888a6aa79b8092ed8e8553d7655636bd51d3a8355f72c4002799d8618a574e778871f0013bdcb6eafd362eac902a12b1722c20ecdf4230209b1774d71e0e43eeb2bbd4d59db4cff0116c512d10d93ce04e8d9cba72f30ff792750706a7247277c73c1997e2549ebccf05e1740326442779958a7169c5a9a91d71d1040cb4cdd8caf8bf9a607e42994e0c4f0be62de2f5892c289c52df050ab5697fd11829160dc466b33d2a72d290e25224abeb96c6b493be330d9c4972f067866d010f4936b97e0d5aa8471a0cf5c2234655cc106843006b908c3f89da7c42bf297f499631b863bc9a28364d82c7443adb092a1f96e0c9659cabead5a990affcd1aaa854fc447ab634c5b6fedec71a75947c2eb2ee58fd08e330500c673d8878bfa27f74fa3bb2b75122c6ac9ef6143617f2b13ca356078bde26693132990277768c30626d5e26dd9c2e2a52d68d9e2266ee143399bf314209dfde4e4bda418c19e46e472027411836e28386ff65f5ae8f16052381d332d968c8f07593b083c4d0975fe9c04fc32b36f69734a497e618364051c29ff2ee481ce300e42419c396eda32e23148daa44ba76d0c419f7e13fda329cccc43057a7712c4dacc39e0e747a5b2784c3013593b16e6dc2c5b68e5c1c1a5f7de8daec8e056675e5d9b22aeb16e69c6277d5778009506982c7ad0a830b04ebc92a0366e37a979b874c3e08f95776689733dbad92d310d175db84007d81affb5c19d20c87c4b5e4894d8bec5aa79faaaab7a1a5cdb3457e87c07b0978e6c9df847b73d461c91f48b793177a66f11b6560c0a70fd2720eb9e34a268ee843cef7e456b5c59b898af4187ef7521e56c09bddcd83c8e679113eaf8b97ba14c57e6c1c4a64dfa9cab2ea9e3a84b28578d7f294e4fa8e95a9b4425bda1aff5e9564b19fe67a93e0f7488a7d27be9c95fc5d299cf5dba08f0271b7abec879004c1e5d8160008eb3a69c2bb536cdbd5af7613d366a16ccef5642ed2b801b00682f339fa24dbe65e1847222821a7e5d16acf23a22f304c87fa0afdc493da125cb5300c5bd86f1d89f6a1a11846e0be79a4f7482a1ab163c9b6b9dccb84e55d7f197780306adba1877936e8681b38a61b5ddbf0f75ac4913aa2840b95194a41ed1eb66cdc31cf4442f766506ee7d3606e432c7ee36c61525fd974a53c5f0b0b05509c0123d1f43016cf2d109d3fff10c48954a7a58b04f42424393e5dbef9246d721349a27a059281a0d41a26cace92c644547c97298bed2552f3150e70da161b081d8eb1875801df2ce9f3e77c59f4dfe02f8558cc503f2181ba9eac8873b24e95d3bd039846877f6c2e1d4d4c745f13ad15f39be529bf9517031cb6d8850f19c6519a1a9bcbd1449c4ad7e03bc8fc1089bfe1bb8b95f48a4864df81c2078c9deaf18f5c46e784a5597cf3322240369d06f82bb8d11b0f8d3d2cb930073df0a55699590138bdb765e03b27a28e0cee040d9f3fce30850b29bd4aa1afa89bf02ccc2a8db40f9d9431707a672884f810691e20afb69f6c02ef824a858584878a1fbf4f4f3281bbc5730b2edb565cf7b58646f99c3dcb6d9b94ac2f61b986484fed9c84722ae378155c7276585d848f25960d3e339f3583536f2d23a4f55b16ff0b3aaadcf8e98670088cb6e37bb1bd4dad886391957b33e58d81ebd6a9ca4f275664808887d04073e8f752619d425fa172e84b2931a8c571c5294b916659fa2981ce8c3b36122d6858724ed40491a1aa4ac08039ee99dfcb2525a42179433895fb892eea33b95dd4f6e079d4c416219b38a5030113f59134366ba6ac50812fb7cc1ae132c21a0dc845788456d30ee01285bb9db62bf9f4b51619c683879ca13352344fa6fcd90713c766b1a7da2fc92c1540b5e98fdf84b54b1cf22d332decb7ec0b501a0801f08c8288bdae28f6538ad437c58534c9258411970d33ccf621dc192806de6e60c84f89df50c1c724799edd1366a14c17496dbf864518fe56ef46ad5c973715327638bc9e08acdef2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
