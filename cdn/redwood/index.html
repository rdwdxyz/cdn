<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b943d221b8895083bbfb130042583174751ad2ae2f6940a37cafc587b54753a9abedef2cfea1c6b215271a2a3703161d0c584664354d2461c61ba3d05df6f393820782e2f0725c4e150a69ac79f0efe36ee392d49a9064f98f3afaa89f8c55119e2079c1ae51dea08f34b0dc567c4348320fe626378dc11c8cfd9421c66c339145c4b104901d77fb6686a5a625d6256f93ed0d793630dfd9790013c44f49ec3faa9d4f3c32f0ce1b42cb6b7283f81469dd10310eed3f3a365629532febb3cd819b83551c1ee1af14ee9e9147a30424c725ca8ef893aa7f4c7daab00007c6bd6b802da885b9ae15fefc57f8d804a741f33cec2752b59c1bc3f6e1aa387d780869ed95f4c6d7f2843b984575584cbb46d7f9c35f5677b96e835eb4a1b21e836eee65c97dfaf21c379fff1fae80877fa8f1258b9c524a72b4f1ff657812cada599a6008c5e7f0163e857e839a94d323dfb5435446905cadc868f2837a951b56f65e29985f299e82d5f35ba107e9fa3eeca9821d1d822d263ec2ae2195408b804d83545b92c2fe2371a74b7ed7b6179d1c3fb7ec772a9c370e0bba436579282401b76b21b3e3d10fb3ac977ee809026a46a5e32dab16db6e82a72db534da2cc213931162407ab70fdfbe976a76bdfba042fab79b7ecec53d5ed8c30a7c867265b088d1e652ef6c67b48cdfb27f1e96b96a44a9fdbe33e469ce78a96846646f344102f14b7415880bb71b4b33a1717deb61f2012ee072b37260c95ae273feafd9f157838d17a8edf71d3333b01ea325d4a6fd2982c8159a3add5b10b278b12572b76c2749169aaa495123b46bb82a260ff1c73b08aa025ef14e7b8eb3da85e9d7bf4743ae7ed1d9c40d727414db90d8904b41bf15b1831bf20b99c37569946b368fe05b38cbb06f66db9f2ccd7688693ff3d71128e0ee2aa7abb670fca1188a04285dbe8fbca68ea202340d3618e81cd5b4159e12d7ebab80d369eaea262f0a40355c654e57f70fd5a0c4797a8863c71226b330ceaee535835e1202d114e39c12f40965965417607d1e6c34efbe56e440f0d6fb34bfda9861537aef8104556f93fb6a7ab0f85fd280dcc658661b57eddcc1f03f7e43453ce6b394d10059b97a741362d9f0a12a4a506998471c423dc6533518b4f9bbf02aa1050bf1782d946c23ccdcf303f5c68a8e7f6bcb52c038f3e16cd655db3e026eba7758613c304bd106134c71cc6159d4f924e3f0a8526904661fb9a4418236350e2abde856b0e3a2045b090c8be9f0ba6c6014450e909021901173c30194822d91e84500fd9b651e06f0351a7f0d09a0aa5eb2b335f5f53827e559b8d6822566105b557aed1eb646d0c31d9b78ff49c1a7101ca9b59936a660161310d435f3397afc46db73952999e189d7ef9aa060126bcb57323dd02672d5bf0666fa6a7cf38483dbdaaed489db68d49b8f6ce0bac37d96215396255ca6965676d3a51584d1aae66594347fd45fb934c27537b963dd06f46b0850d9fa0510e7a975ed427ac100592156e724c340886fbe5798a978eaf1496fad3a707245ac178999df438d2ec42e2380c9ef31e33f928ceacdfa2342036a3773db1eb250babaf682f7e2e9779b1d8612f7b68af399499b4aeb0e82022192cb51229f61dfee273d0b8316b70a461106714822a96d70e7b87a3829ced58f14ec8897749da68954d10d252b0604cb555c318edc928e8853258d88b357c53acdbc0ef7f412b21df01184664021d162041f2bbac83223ed318d2e4358a446843453716e9d90f107d7437ca02fa10b22b9c7eada78243e89580bf3c001d0100aafb6a7601b7416374a27221ed285739b92e6bcf4f3a4dfcd7b891dc700a0941b64ba17146e2f18f40262f03a77920f7c982d79a8f7db2f6aaadecc6561e9d624ba7e7f89ac08afb58d2041d34bdc1af7090311e84e320f04fc08356699457bfb9409bdb3e2e0ba1f15fdb6a031eb96485f8285e607293598131bb086d42c7461b9f50781e5c45da7928a3083436e3e44661491e585faa8db5b34266ab2021480f36bc12b16ee8f03d5aa4bfd6e70e56eea7bf32f7ff6776f0ef40ceaf0bad5438a40ae1c3bf4b45b584884d808dae0ae029be32e7eba3acd6092d71c435594dd11b91bf97e8551536586f55ffed132f1a75baae6558bc5fa4783b5bf25414edeeb4fabb7254153b9f1fde921968516ec363b363c380e8d794fb894bccba0f6235dcc6bd4fbcd341c4399b7f9fc737c6c96e226377e53a45ec9a043698310a3d01f6528f051ea9b015a0df4ae2f5057d47b8a726b976408d0f829f8a0adf513158eb7c2cac330d564aa519d2cd051b77421669c3ceccee89ccb7f195b11774bf31d6e6378a7227f00de34d3b9d7d79abb64b0c1919d3ef71ec2fce9f66f2b241b67116cc1e79b464f53d8db5c2ed089fe67d409ec8f82304ee0f57393fa2c12b1a8e2278520cd4de68275abd694cebfdf50419bb379bf2388e824d6ba9acf7837a3560e3af708b3c1a55b7bc1189d63d6697507ff03256ae7f26545e752c1626100b5996095c61ce5f7444b43e45ab15f9a525429667fc621b640172c09869a09c66f2d723282cbf6abfeff796944b6834b53cf7acf1e697d7f40a7ba267cd7474088ccf4b9ed2a6aac2061a5a9f7c5b8159edd4eb660ff8e4373f6493ec91864a805e2467254ebc8917239e4ad0c1530c16d2b4385d90072ab5c0f748278f868be2f1211ce94e409a37e581d14bfe3b6a7e07a47f2d68deef970515a520d5d7c7875fd17ba50301277ba8fbb85ab202cc2402e47dc126450b5c5d2d454957ac8dd65ed7fa62a69a95c094dad79cb59c6519f18f910b9b68fdeebf07f3f74e526619d83bfb87204615229375b8521bba636a37744ff7aae79d2c897aa6550b4a6c956ad0e31e52a1bbe7143cd8c3406a79330e7d3215a187914ca994dd8fa04c329ef43afa6aa21bd1d92f18fce7699f088f83f53fab0d43a4d0019eb2e164c6b4b33e2fa63710e9189a867cc0670e0efe89fe95fd6c6dfc59b5698f546ad48f5323a36f583bdd54d9c93e9ce53a2d6b44ef2211a5051387134408a6c213ac56b14d6cea8ade2a3c3285539a7bba4c7027a24d2f90014bd420c1d34827995674d7f5ddaea29240600c9f502f48356275484dfc72f3e2e5c64c0fd293c817b8e62afcc74a88c90994f82482aab716e530e300c02313d2a401612441b1b3dfaa725b526ec14e8a80dee6906813d1a2a04b8534390903b71e9a334240a02c6d2e3eeeeea45894bd66d655ed70800ea53c6b030d50db2680ef772cd5757cacdb92f4ffaace90c70e0bdee1e8b8a8958083ccf05b7ad3be088ad989309c54f6e07f9171a54f3ad5bff1a1863d8e3ef787f7bd1c77cf07f7ed588b1c1c836fab8151f9faa639e84d9dff6372bbbb9069a109e6fd8778e594c9c887754c54732a0f66df2db1ff6863a0c292543ee85f0abf01f6afa9d6b8cc60e1cbe0904af3e8081843428c621a2971a70686e7ad5aeef2c78539a8c52e0bc8c3b27425aa32f1ddb401d820b35f6f0fcabcf5908de5286f24087d950c4a99ac4e68b0a3da4657386aaa2b4d53a85481da9324a570fc274361d2893e7d6cf34a754575e40f2b6dfdb649b09d5287143873d61c18452d0a05a2e127cd52752889762cb09965aed829704fe1d85dec1116599d13d16a4397a07088bb5bd93b0a3fdcfd980c0e992f4f60cbcf2a72a9effda6c980948f5258f4bb0dae5e72cccefdde5a9b47ce4974df90696f2af4e3d8c87a5bc8b88652fed44a37f56af3a4276e089f88a1f5210a74db05aa521c045cad1494a7561e9018805c7b929686c45d4677e19eabad5f70068a71ea49eea71daecd7c863552c8fcf521577be9480e434334b48532b1bb9fc9de5027ce964d3c3f7eec571d996d8b70add138e7c85a3203c6219e76dd68d8cfe27778104177c35f1b748c0c52c6d5fa0e8ca088494aaf0e53ea263e06ed8623f6f703e43ea83c91fac182977e3da1a6c3880b987fa816ec2bbbf159ecf4c8085f2d7fdd74a9a463619c9718fbbc913d6bf7803de14e80bffa8c18167873ade1dec16ecba840d82d9046d3a7c693af7c8f1e611af3ec8acd16fc8c4ee75d2905c7c80cf53480f4f29573178e5d39905ba6c398ee45a8a342d3c9f694253d1b08f7c1b4797913ed1ca98d0f7eb84812f454d7d9f28b95a7b2544e5e7f97a3fa0094fd5af542c5c038df7436ebcfb53f6627e1c86d95b0a6f7c80056df000e6cb23296dfe0c820aaa9a4f61612a8af138ca8986c780935be58922a9b90241f360448ce45edbcb05a081430675820e0b0b95c2a2170f7220917bd88ba927b20f295a8d32073c92f3dac5535ab74ff053bbd91b18a00a27212412e1b8b481e3569a240e90c86c359bf569dab32c065734e2dfcbe8c1bbabbbe6166966777cd44ac187a8887e81078c1a027c65ae9be1e0a4fcc056a3f537d274a51533f0c35dc11d64ebb4998bfe789c849a7554c7882c9d7144bc3178d7620b2b51dd13a114fc5b3a472603414ea495843241f20395351cfc99a85370c0ac5fa8997a8abeff5e5fdc77d4cd517573a1a3826dc61c3848c355dea7b44cb0416a7dff778d00270678d818f34af6d1081d7de365d7cf21d2ab9ce62bd5c003567073a0e5a2ca7e8459e7bb27053fba7e915c4cfe380c6810597f5ddebe6962ee9e80294b8c8994bd34cf5a9c0dd8b1a34c16be020e6fbfe7aa2a60f69437b24fa24156ed5cea0b5d1557c17903d8264018778e5b895185b13c30b17492eec4c0e0fc5deac4d7be6fa947d9882c0b26ed142dedbb4cf04d1a904f01c7f9008d787853e42dbfae461a71ce9f6d65909559b27c0dcfa4ded49776f39a0f53a9aa59cb0c8f3ec08f6091f40d68fdb9a31fc7b6600d8f09454c00ee5404a7455c1d48dc7ec99385a4818886323f14b2196d16808100517a40322373f13ab394c5211a5f80e3c9363d8cccbe92124d1f449c048621f9ab9784c8ee223d33624d8c57e51eca8e9272ed889454a44b9e0e4fa24fd5d778ed6bafcfd198849b697213388d90d0223bb423c8a2bc7c90f36ca7741160d8ce18c226519aec7b19f1b3225134c45365422d6452497b63c09fe44d105728d2cea5202ec2edee065075dce9be3ef4a618a4a52a2b1495e712e78093a79046052f6a47e360eeeabe715ae07e2dd69a4fa3c7592be2866ff4b72510d6d7e491c8220ac418c9eedaf6561081737a7f0e45216633e6ec2773f8df3eee03f979825b97aeacee4db44f2c810a3309e4114b6fad9f5de8a3ffec63964af521f2610b96c0ded6db11d9c602dd825bd7ebb509dd548540b42971d0f94cb1a434b1f43fb5765923b1069bc011c939ee68bbed7a3b8aa3dfb61f42aa57bb42013e7b079688e1067a83cd7ae397a8132f587b213fb35d0f3c2306897fbef54c3ec3d4c9efc6ec3e290f63cc9eaf1669ba23639b8e9823454288f772d6a005c7db179c137348f4a8dff0175c95f1bb046c43438b625e91ba1c57cd733ee9e0f4179c4ea398599b85992aeda7aef60ae1e72cf552fcd7dcf8b5d68a6f176c969d6f0dbae3fc8401a4d529ded32b5289101fe796c05d98320b346481da502580b7b51760d488ad784714c8c583a2c249bcbe159416a5940239f86f94fb493c4952345e9d94aa14825aaf5a46df9be6eaaba22128375889ce39be78d924c736896eef7a6d22569685b735b424b63ec3eefe0fd58801896627ba012602f6220b1562870eeb633ffdc702426ec9515a8fcefd21073fa87f22c2328852abe388919e06ed39c4732983f21b8094bf5443c3e5fcb30b35ac77b93fc6ba0115da5e8c9bcfc9caadecf729a3fe5980e07329462a0ab39e9de697affaf63354ea1000c7a36d3595cfd6f58abd21eeb21af8c60a44697f2fb1a9ddbc45373dd41d58eb5fab403028f97267e7b7d7ae3caa97324d9cf531d39de106f05ea9e7c522ed1a6e72978a1fa7e12d96a68b23291a507387d823db1c1fb12ecf43f5928c73cab911e95a02386ad70f8edb52fa4d0d9c3888ad1ca697fb69f7ab515860bd6b5bda9309444c95a99f0811258386cd9cefb7fae2263cd151ac71d07b6309fe6fd1c260f2d9116727b24f8a42dcea44a9afd320159e88db31c43655250f499579904850b57cb426362a93dd8be7592bced205c60a70adb649c0b6b277e5703de66f3fbbb5ad87ab83e3e855cb297704997981cb2f7183b5cda4fdffa2acc4701e8ac07706b1339a3f34d384165b13305e63cb40798511d09ada6e929a84b9fc39115750c32bf456f5b63f66108586815f0be94a1ddeb480da6f77ab58bea1351d64f1bdda9ce44321e6e74c78baeccf5d051173cfe6d715612e90f1d0761bcea51622c4f4d5cf18b1bb9d1c38e4da547e8935ba2c8212972d0c572af6721626edac9b3c59c816aa0ffaf1f24c4d72e4fd928de3bcac0e10395249d26cfc5f165af320f121a3a41ea57d5372c1ccd4609615eefd379a2eb0be0894f96f0e214f6b07103ca250807ce78471586703aa00cfdc2dc3fbb33bc32cbeeb8f32a3b1341b08792413b114545349816bdb1dffb4b2a219e54ae781b5556d93b0ef870861200e38aeb83df2db8ced3896ef1ac9a63613d5947e14cfc9c127971af7b3d50b342f5645eb73d4910ca6693e5a856809424188fb83b1aa959ce7e84d421bafc606acb0f9ffd5c88aab724546b01a2937d9fe8407149dc9e5b83903dfd670b707d6c5bf085fe82fa0c39f94ed0bc2f81bf43b15c323309924b90c6b7cb8fa8f8c381466de1c3961e0cfd42b37a847c54cf0a43cc603a6e8d6d4e7a4a387c51e5ed11eaf56588f8c2a9066e57fc9473118561d96f38d895f0c86faa602f21d89c4c8582f88c21417c66346ef212f12b4f9842d9624e6230a0bd8186fdf4894a41ac7158558c40411ef512e0b24933ea8f8f5b553811262047b826d3819b1a98994ab5ab09ed0fe4e0a0311f58480f6b5accd727922ff2eadcc6f011e767df82e61a26aa17085b923fadb033c6c247ced1afac7a5a460e0ba87584a9783377f57f808a9c2915dfa0ac1b9006b0b9f3985b0b3ab5b4a5525d9f22ab18d05cd29fa65bf2136c552262ed3ff62b89dece93c61f7f18b754533621170dd345828c41c5fccdd648f7b22bb3d3063f0d3e89d5e73be86a35ff3c766452b74eb23f61890faadf403df418c190c4688d565fa383dc9254e80a94f927df33f6a3af6799846c04725b421ecbe3e4f6ab35b00bbca8f62a39c9622e67c05f8789faffd67de4875e45640878b2e4635dce4247a5530746d2c03c388d3dd5e8a623c72378ceb35845ddcbd8abe8e234bfe43f84a823e15e7c24e442ffee4eb27b14af6e3ef3f2695b26ab36c2cb665cb167cc0bd520d7b89532b36f644ce0b417d5482b46f6505eac008cdeec0e7a496783b80154b04a1fadcb7e469d40bf9c628b7032b02329d4ee984ca79a47e2d4964b4f466613e4f8cc6d9a3c57ef934280816efa27a1bca2adc3cd5ed17d5d257d5016c4221ba303fa323edbcf09714322dc4f5d027fd0df961e17820bdc3fbcedd41c7176e93d43ad0ae762ca7d4ce7f956d430eb96fe60a28a4e1036981380d575a003c6c4b3234f1e15b206ab33eae118c728cfa2dca9f200dd3a515d095bd45e200b37e0f37db069b2cfb7c0c782068c618202888f5289375e7b732d205b4b3aec7dcddb59fd202fa1f6e444c8ab486ec22562d17f90ad9da8d7ae5803f047712edbdb66cd05d2205acff183789e88119cfd5f0b23dd4d7f94e14ebb724b09d91bb89001fa05cd99d06a59d168f2e7f787a44114c68de713931c84fdbb0198959fab6c00a985939ee5846cd991cb086abdca44f699ab95a3eea5ef7269df5bea7730c202f4bfc99bb87ab6b8230734a1872455997ff6f1deb61353fdd2b555287bd2d8091aa4f78714b395783bc8497947f790d471d43fe7e3fe8fd4ab9869554a573bccd2f440a9138b4ad637c4ac2909a6a18d1a03ebcc89157f17f76f6fb21795ec68c6e3780c7aa7a7736a646ec48314e9dadd571c7fee2d9de448a43b821955e56bb7de22e41a26706d9e83b778de615ad109ae9f2bec3486fd8e043f3ce45b078ee8868b068a9f111b70342e68d5ee23ab5d2131d0d124ab17d53fd5a891203679611eaa1ab433688d449d14a3f67567a750cdde5fc3fe44964691d45dc959646fbddf3751b79df9f69bc9aa0c869ee671225fe528ac6506f56e0df1f64011e92c3ce1c8c946c2a2f753d47ffcfbe606cc7d4cafb12dce826172b7a2f0594c6b91e1ff84e301bed1aa44cafca48431b248a8531e456560ae9d79404273b783b402e3141d8fae5e47ecc27365897ba1b272dd1fa8c4fb41a5b9f5e86fc0e68080193779a932cc985572953f2cace184a96399f1894ff37141a4be43ce2f55a0120238579d3b655cea066d36013b97f90e60074eb9348fea89d48bd57c290ee7f138a041216206e1d9a79ce14a35fe88188d1d394c84633138010c3eb22e5049d15e202059f4c56d4734a19476cc5f931d123db24f2c7df8d72420a92fc6a3619e07f671187bd6e7e68cd2e16cfe51b541acbf336be2a4b6a275a571d8297f1f4272bc1475185977511038c5cf4b3a1786e971ffdc8b6151f5ff07d24c1728e627e9943890f936902b8af3eda283e252bc32968b9ae79b08f48d1834265a8733af6a7e3d5aaf1fef877c4cdbb3407433a9d2b4aced4fe9fd7fdbd9b39a5083dcc990f691d087514b6550dd34f12dcf495bff092ca22f67bfd45811f2f2544846ec556ada788461e7adda245ca7394cfaba3167aa621c290a92579da86268926c9a72430f6d85172d19ec82bda3e9fa278aa5d9cccd1ae41a32ff76a79e3233591255297b4c82a0f206a874d9b1777b4b812fb7c909f075aab39bc12f563c4359860c022a005c6f9c189dee23e48e1731d4618c29fd59510f71cb0e165daa1225aeddee983b2f995dd65c1f57ed9d942ef0c2b3e53a7525d2803d9fcbafcc7cf71ec834eef3d79b55a6ba73a78d180ee85a7c5756a12b15ca4dab2c56eae7696b6310599b8776efbbf9d37f770d80618bcea0368b5423629e21f330d906d537b00b860e80d1ea9b7282e31a9387434ee6cfcd3f73bf18d64834ad4bff1560befb22c9f1641854285d6d25b80aa3fad21dbbc5bf9013fa5a8b5255d597a3b2b71399df270755ef7070343e834f279e980371cd27d1fa977093b3d47833ff8b199d84e928f224f6cdbe26afd10fce9ae84f8df73ea356f9fe5a96df19752e037331a744e0a4d24484bee24fae3d991b7e195f3dcb72a7dcaf8fd68dd81ba914e7b31cb3a2ffce482c06a895b96e3c6cfbac3f75b68be9d30f940cd29e4100d6b7051d22d4d1e7cc0e67becea9ed7de457b15ff4e730ed14da252997f89c74bf957ee16337c3d9f9ccbcd8038ed68d331c84d01287133201f1a9713151ef231abcc7b3adb7bd45a9f10f754b45149ec1f4a44ebbaa64344cb302639fd779535731624ded1915ee3c166399cb4e5da661dae0cec0b9557ae894db8dc67ae007936fd44b570f0c194e64c70ab6686ea98711697e15fdabe9f314d5923265eab61184e8bfae8ba82ba08074cc6512fd4365c6a1ec312bb6d62b183138858080d1f41b406d994a442c9af87d5670f706e042b5623146ff17ee290a7b24764dce9ae663d4dc261f988d8a25dba40781012803badf537e14c689630627eb488d8502e80c6db47579acb043a37c37937cd0db0582cfc70c5c7c9bb67f348e59c1ef41b7c899d0e2c9b14ea43d6d18f038a934a26170494100e7b78746fb142ca6cc24e1e6d1ff23cfd94476b5359e81baf7536782afa7c3f84d8a8708964384306f6a96d7f64259955c13a79ee4d18dfb4b20ccfc5fad5332835f8bd66054a396cc8d1ac0c2f61dce25272f95b28727061e6c7d91ed0fbef976c38c32b0c988eed3ff389150a3d85b05c1ba23dc3cb073dbdaa60c295148487fe8988cdf06a4355c31e2c1ddc29a81ca1b9ed47523db43881c607fa0aa3a6b05197809cf7ad423f4e305f147fb4292620f65b6877891ab719ae85d07898cb8a65fd923d053c6db7a52a9d0176e0838d774ecb32cad960cc717f12fd63f81096ec067c68bc9e8cbe16105d95a5c6ff7f58dbbb852c0c138746950965326dfd1ad6614d80bd4f876447ce30b8903d4a2336d5d1389409c6e37fff662c60d335a43495fcc23386e958efc997c94d77298ca6781b272bef9431a730059215cc4995a218fa39a82c7c2bc3ff06f17efbc05d94bf9ede36a1dfacb37d6a6e063fd6794e95770711319b4e571b00762b0a3c3c33fa6b985459fdadebe67d0025ab68b450c1d349bac6164a5361dfae15dc187d5c46e8e03dd55870afd97b1931d2c25b7a24c32008d987f934d14ebbe963a10d15a5020fb1906d7ad8209e34d09a8717be67493806f622ce87e2dbd58b0fb7681040513994a8a1ac3eedf9e3e8cc1eaaf5a9bc10085cee5d2134f20cf56c213cc3eaa4b2f679ba5ba5f2b8cc272c2bc6d9d26700a21941820091a99b4a619aa8fa86207f33785a53d407ccb451e87b7845e0574ffb02965a1cf33891439f996f9e754837aa258c66ad2d7ffc0dec63c1344c541127b7526e20b3768698aee00f75afda81b16d5372f076aac8b69df987490b5e02153a6481745164c2a28c20d9f0dbe26a74bcf1d57315428007172f54082313f9eff84d12bfce5d438c3d36d8dd6352bd228158c93d8d509d8fa41b3ff141af0c95a8c167f982a7b81f52639dca77c46e9d9a089aac13800368bdec1f6e0efa0c2d6498193a0d0b93eb0b9f7fe21f8b7418dcd2247236dcf44de9bd65c9ce06bf2cdf8067e575f78de2468d7d8a6aafc87d08c1d489b0d1300533e8dd33cc2a8ae1424cd940aea5ba640833e177681706ef845ed35ae056a4a5bf22e0ecde5b9bfbb42fc4044af4ba91d936b89be21c911c83359dd8d5bf1cf862b0545311a63efef633e2bd27aed7705c37df91e79d4e0cc7fd9205edfe70a6c3ae8fdf34e73f6a8ea2920956e91658ab925d6dd8269b027e260c35af72e47b9bf274200874cec33c7cba2a77e500a84f36366404b39b2dde95183d1f34a1e29279ad25400488c9b79bf53450e5d5041c8fb116985a619ed1dff364899699b5eea2ea30129cf209d04490f1c3085357a6b854bdfec24ec00cc00d00199472dbb45e650429b8c1c260169937e2e103a7863b4b104622f69946ce929e5d3d6cccc0f83b1905c4ba12f05b640bdc3a0e27a58c51e6841b289213e211de013a7b94cd29748b7383283b15ac7fdf1ba1b494b65ae48cfaea5bbe309b29b107171b45dde9edebbdd767131b4ebdf51c77bcb82917c7790640f59ad570687056985f409e94f2a529955be0fc1ac64d2362541edf22e57b6bc445c79d023a45e27760bca07f4f37f59465c7fa40369329ea205f7d462a0ad6d83a63a328b54803e5ddd4313e768c5c2f2d4dfdb9fd77b8101cd92c331937c2f269aed9956db493d92f9b4ac9e23372b59300fa064f35bd8da8751b0b1b93321900304c5af1046d857b43025219e9db22c8f129ae1cd6f8ea37d937a320f7860d79ee9c6358d62dee96973c4444d76a1cf928fe8934d0b517e00d35d451e2f3e93215874c99a9888bf24db238eec9f8acf5add02231b297ebd2aa40f4ab3e413d6cacd2515b4623ca9b4c95118dfc57b7517a4a599d98c781023fa4704710b788c2774ca5ec3c9e34ed8feca554f3eb3bd15a3a6f333d9707b65fa64c38bcfd2965e337c7da03d27b9dc4e5b53ad8469b542b84d24999d5a15ca0196f4d351ccec5a15a85c993d09f21838099a5abf3db82b4007d72c81d3d36e746539f19d9520a966936d83e3967c5cd222f976615ada517ae3864216744d35436a5d35a978caf00e073b032f7e8e4eb590a060a566ca8e1669a93aa40458b0b492e198a2df33fb26d05c38a63d3e51e2e3e1bc7fe509a6d4f7067173ce9b04751953e154ca845a673ead3cd89af2f300607c9f2f7994850ffa6ec0bf16b1635a4d1e996224eca1e57d663d82a716bf44510c5c1167968264fe3a46a7ce3413328af301f91f7c5411dbf239cc6565f195c9a47061a3bff8c4d6bfea7db3579c7608b15408be0a3647a6f031d4972162f53662f0dd1e6ad91702c855c19652e05086fd6541faff58e0242405c61e579e80ffe083f650cf8612b065fcf755dab9c356a9dfd022a37113e01b663997a3f73fa27948de0e9c4f05649b156790ce1e771856469231ce00ea60d2ecd7a74f44c98e8e37cf6e122c997851d87919d1c9aa7c270fa7830d85bbeada9ff5b89bbe2ca13e521858114699148757ed17fde874889d033abf5fc069d600086775062a2a2ead58ee497d65ba0d68f23865384da69516ce7c124f3f25f7292a7a6a0bea8c6d2d2606757ac326d18e998b6d1c71110308525255374dca755260141d3a0ffe923d383bf32ae7ab07e4956647711f4350c06d2aea5a4c6d6a085f80240ea76bd95e13d0c698fb7bbfdda9b64276c5d154f2aedbe6616740d570de8e73c218f2f970963ef61ec57588821d538b0ab2302e6618cb1109f4a937f2c8d74a8ad42233c37ebdb1deeb8ab5b4697b3465759a386577c3b50ca0a6cd576d0c4e9b5e1d8268ef6c04fd1973b5eda9cbf7de891f9b17d65d8d77a6f4d781ec3b6150881566a4344973847aa480526af3b901ba142a3d191b1f65a8724b359f4dba6167c19c261a31ae0c7c7b383773c0be760a5b407820990833dabe5e306d30305271844bb5386cb4382cb27f6b5dd4288b3c24e84bad98d4f2fec47447f06d61379ff6644f8222a7cdf4a993930f5dba9f9bde8b4801af5b544791423b123ed693fd38baa105cec865f7be36050ab89d312377e577a3a86b7303c9803563ee04bf69e6ea290e7564cb913efcd235d93988e942bc8e7880321e5d2b74bca8606b6ad5970ab6eac9cbefe7101623497f80c6e53cef28b8f3a31d998573584c104abfbe4488331e981918a563a4fa17d69c090236c13d5dfa7921b884a2cf376aa91b2b2ed764b8f57aeb9b7848de0e6a0a178e97b85bab27afc70024f1d51867297b8287e18020ac520642870825933fc5df7463d82bea38f581a73b40ba6395d6855e53225d84961f4d5eeb34d190a1499ca246a533adf40797c1a30bdaa5f2dcb8f7b137c414fe2fdc275f0d095e9777e95290d89eed201fbf319c524b7c0b2c88777a9dc17dd9a0b7ccdefe6cb3675bd4d301d8f3d15ab0e2106d0b3c6eb3a4c73ca424d2ab7097b9322bf3321d049a2a00c13908a26b1140b745f2bb3a1cd50ec4ca29b6c5cff1f6cd50a444e53d930a46941a0f73b3b182271f9524f0ae53e4faa49b3e15579745617cca01c674598478d6f469cc69c8f0051edd088864b1390324eb8ab923fa4ab8c56649b77f7d51980913edf9cf5052964473f34d126ba23d7b18e22f44467d220c63f7514ab3b811768420a0582f2bdcda42c7a69ed59f236eac911ce50535bfd0078b7d2f54e352c0db4fe0a02533187da55ae2c933241c9f47c62e8eddc4375f42b29cec190941e4a2a32ab38d193fe7bdce82c6f6b6196c5600856113bfe4c41bd3cabe42c88c2c6b7b30266543879b2635a147b5155260222bfaaa78c24a4dcb014c92e14727ec6cd7b2d873ac316c7969ec331c7de8c9cdf426290a775597114fb7b312e54588dd4f877ba109ce1be6df680bbbb5fff546355d8069e3fc5df2b3062738999d3204cc91964bb842fe11f31e95fb00692de58baf27ef4f971f7792e03251bbc00c390e3fe16bbb797e5654e327442c82640676490f21594de18d2f6c0039fa2a214f19c00ec68e21ef0167f111f2ab5c266a3ee19ca6bd985bdd10086d427a63b6f90c94a9c6d9f8c77b658db9466c03f3dd614be8a168e2b77eb30110646b3a5acd31a91429ca41c45b1d07ea0f8eec3bdc5f506056ff4f68a92f0a893827a0abc39af72b49e83846896077f8e12ebac0dc94aa8904a441696276cd545b889bc9054aa706db593eff8cc50215dbdb403c7615893965c877ebfc0e10154b5aae3fcd9b22e537a0ff0f5f5af82d0b29eae83d0b944be2a9ab91223e9e71c67c61a13845e54b563c757c9e430601f55c10fe4b314e24e70c98ed209b184f08852490c8283fa3645469c87ec03d221c4c1a2ddbd2ff166154f48f92ad4aa9024bf78f1e4fcc0e62ad3019d8b061523d36b5803ccc2de404a2903033a13e1ecd79584cacc5e630a351567bb6b8f2d056f24362f6e2c2799f0f1838927266132cbf73b3897ef26dd810cc3ab64c20b634dfe3d3bea1c8f09b4204146a9b08ad86200797f8b2d87394218ab1318258bbf1c9a8acd83a98ca17ac9d3ef112d337c28e479e9223162ffe607f64f0f3e8e51328e12fdede8e3f6d1c7b846eabda8602dde2855b154c822bddf85c216a712efe3636cbada5609685e5733c1b993dc26f05be85f7df21372afdfc4573424dea6f1f18584a687b3e1b0b134fb00017f04ee0ce0bac6dfe2ad818c24c00bd467017161d248328699ce94170e4bd5ddb409bf5705ee2bdf88c7fda854cbe229a32d9b915d0aae42590e2a53da221816ce2e89ad3a11400c291a67e111460656fed91ccf828adbef59412cc80b389e8862babccb5860acb9630f60e9fa24416cdb0cf8afc197e6693cb06388bb771cfc136505339acb642c16694fa9adbd5a73fb53a464e917a114c700e7e7bede4d1810d34472cc1890af3531bb31b8e9b80413887715ce451ce3e3da8762cc28e7dd7faf3976962df55d169dba62c3b6ea2ae9b10544aa19c024957b4d74aaa1f0d72dcebfe7f2f6a1e7b8bb832aa0d038322b76226f35b144f4bc352bfbdbd523286e028760fecfdd04709ae792e653799559bf631195ab12c965d891793ea9a21822aa5a5ef0ce6a821342e269e42edf407f6a04fa6fe5be6d83ddf6183e3e41bc24803566465107b3a2f9b723b788e66072f0eaff7c7c7ffd61abe108598badb1c2cbddde4fc21206ba2255ad30b74f824c167c99ad7e21d0f89c0e92bf4fce4861c1c352ca045179ff9803da82a3c1f1a1936b1fd45bef5b34","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
