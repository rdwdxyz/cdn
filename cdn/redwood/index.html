<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eac13beee2ff1c035c3f70527f31364bd61af433acd61bf05db196024b0cf8b7ff567c5008fcdec7e33335ddbec8f946618ce6eddc11c07ceffed74dbe1f4fc3e425a0336a2470c24ed7da6b723846ef0aa4b415f053b61973b03f61e20420e118e1d227e738650b81e3d3b8eb47cb4a4f5ad2032ea87209883c79f36f7fb6bf0c04ec87f7d6de853e3cd73182da33824ce031626a88aa1991368e491af42a396ea3bd65a1779aee756589281abd329db2a0e7a3c839389ddb9be61e990be1f7643dd513d6d31b28a00514d5769ffe90c25ce3c55bd558bde82b10a8f99d4b6e25bb5c16426d5981e6cc952ba5d48ea28ba89593892b2a507c685d026e59aa27a920cc461e8f2cd405bd1e1653f3d9e6c3b99c217249a3ecb79e9bde230d2a9341a545f9b3103ae7abd7733c914e97a38bca948b111151f0706cd4af64ce58ac788f17427480c68139b4ba52fbcf6c5567c43a932a840a5e622a7e1896c0e5af4ebb44551b2724c5714b9b6c67c3f71bea5dfce80ed98a6f3ae6330ff7a2926347e7bf3edf481812a908cb52ba2992efeb573761b72a2475efe47c432ce3c90884c9a703fcd5f6ec42cd1db76519e881146a360460ad8d6e855b4f355946f33be80c98a7e2a7273e0cd7a116bbaf6f154d09e205409d496c7148d83e80c843aa25c1f9fb14e14bc0c18e7b27dac3b6e6822231c20dd8601d3b34d7c2b014742af79d0bbdf6ba09ea7ebcff64cfaed8f8bfd795cf10fd7b77b713e8d6718355e6af34df830ce9194b94fcc17eae93b4709887e08d3a09eb589f76ea3bb6a5a8eb85ca4cbfc3c91908a6096f59c6f2d48253e763e58ca9fdf33919f07991328ecde7cb78b7cf62e3b6bfa7f9ae9266c195e114b93cb4dc29c85f4ee2466456a25d279a8f2fe51c58109adc794a575cf78db136848b22d952e8da1819552cf3c9f083c8660bcd215d19256485619abc1445762700cb0aa86e57df611307ce3e6973a3c6ae542503609ec005baa9014e437f8869493958d6b503ec2fe018a94d31f6d7eae20fbeea9343fc4a5098faea75f5c08f77177af0915a9df5ab4102f2090b1facb3c14eb19f31d4948977486fd01e8af6f14648e93a6a755a0e7f233f3b870308810aec4be526baa26a0e33b0f70a8847066d7b93f4270622c668123f423327127fd9bc01085535f36b03d00dda60393ff765351a07353b000385918857a612cf00e3bb3bf1ebb8c6a2746e668a2a60d1a86bbd1cd6ab30dc1720fe05675106533e8fab39792e3c3d8ff8fdbc6eda4b86ef8926fc1c9ad58ae8a1135772a697d4dfefc17b0d195be67f4256cfa45a0d2ed68edaa1abe3b950f91cb04f42444e36f374e98d21860b185e3dca45ec6271047b316f7cf92d4ca8148e03c83780a484bb3581283bedf5c02572223c50da2045427ab3eed5a9975f64c314177bfe28cad4062b421a13626f2480b68e96bbf35dc4184b0f1c63e605b5ae259f2d23c7ed5847b0c2e4b59e3ac8f1d53eccd424619fb9231f3cb316fbe425216bf48394be8b68b7c7486c7db55c5327c364eaed858dc01563c8a0da1fbba25b99e77519e7a324b669abc9cddfd8843f7f0d3cb3c7fe735043649670b21e4d657f2e42fa9a1a874bb74fbfc1cad9568d912f337452819a06e94235d595a9bda9e04da93de226b031af590f33966c235b83e87efda720cf2eb04e2177bc34ddc384a4fb3118cda365893c2a43ccaaca8be2c4fcd0c19fcca017e4f552b32410b55a4c159b028e57982fa06037dbbe9f14326bbfad9b9e64ab59a8a964266ab40c3c17618edb89a678ec4101777df08514150ec95f07c35c5436befc2f9bd4ebb21fe0172c72820e8f3abd931c9520c356c211ac70d40eb15719f6ed5bb1979c27af1a932ee4892331daf4f7637bd8b7ad7c4aad67ecd5a907c5ee832d9719eceec9504032ac27d766fd469c1ebb8f6c44b07ae85f5351181248e1cd9e92be3dd22d89752352a9a3525a30bd153117b9a7a7bcc0aeb90a856ef034db6a26d9f09e61cf17ffdd5dbbc3ce096fed13ab1a92ad334e87359ff1b563ccaefe3bccbc23d5129c05aa327b7551e17e61db1408d9aa41b136598459ee5144761d15277603fedbe6dd82b578c54ce6f2e4f16e73c6167622dc85c1415735943dcc2fe9247857315e8acbb6912817adbca9e8e4dcaead85d166d8cd18b83e393580e5f6024c14dca74f40ffc71ebf3a5aa80834e8451f7131c51c36938fc70adf523c813bdbd32812bc3b3163a87de2f6001aea23f2c9b246264b73790a90251b791d2a1ad8c7f0dcacd86d692d15150689327bbab08d9f290311e651509650ff705e8da9340371674935fce11a8a8f661bfc037ae075b4ce1c930e9a0bd6358d8272f4cb5c663bb34f3a9f9d25d46d2902ac5bd3371c31b16b9de1f6688d600bd26723dd8fdbc2974c15407057dc1ede10d97ae503befbec009898484db97552f0bcbee99f58eb84294026f479bc39815200a46feef3763f88afe5f535f0946e5aebf46fbdcacebda718fd1d8c941cd5c06a3034c2d3bd29cce3012760edaf2083be17b8ded2ce3de2a15f0b8649bf6ce0c9a0c51dd97561deb165e9254cdd65704d8b101d90c16751cb6e7fef3f30848d3d7bfd8933946289cb81fe74202d57397ff42145bbcd81049481b88d5efc1fe99adbd20ebeae99a4e2e0a71bfd8f1fd14db62e5a8b8591e5d264c89288b52f22e1906e472dda2938c4e1ca0b5ebebafd546c39a0149058dd80fdec50368f7ed923509ba47e8b278368c9cdcccc2c9f5e1817c47f9487131da362042b1821610e083939735dd422da4a2d97e305d1105e92338e12417119e6a7e6ceed52cbd67c4f4210f23704073183de0b5c71ea97178ce2b35e8ef108aa8d0287f037af2bab2b8421f6c2898526a003c0705d70d73cd854f805139226f59b08ffc7cee0791c22aa9213200685bd2f75a7239584b38215df57b23e30dec1a911e1df79f78a20891e62bd0a108d79d83a600a832daaa5c2988ef6a5e58bf0889372d327ed4ddb10b9bf51d7be041ae4f47a2fb57867a74752b53954daa685ebd824f8df2d743765b62b04750f4a612d679cd2832cd1c88c991c83d8a1685e8a2103536bd6d9405d5746d15daff5e38165edb7d5ccd83687f78b79942354860c5eaff03d33439839d1e6aa11baadcac51c930210a1d80781d9461f4040d110575edb9012378bec1dd7d79cb9b454cd7dcf2c20f69dbe10805379fbb9c99256bc836581a62213f6b94671cba33722fbcfdcf5fc6d88f09c63255cc4afe60ed0ca6fcccd3a3bfbabe68bab9c915558be0fceb4ea01451808e5c52cc7110983b25ee3a85159cdd3fb3f108a80b325d8f6c4590ccf62cf5305757a8414bce8ade21681e35a666c8c0af65e4b46ad8d94fd3d02c1df3e97ac1bb465af12e28038275afadd75df14d475f7a2ebd7758e6cc1b4dc2e01d184501d93477f490a8a48c7afef0586ff1d043481dad4ae35966bb1cd47436b4a241b610fa766f5f98dfbf6e02f884274504747ed5d25063ce106a92bf95de253445fd5b12798474d3732a3a632d7ecfb600fd62561cd3ee47af35b3f18cb5af0333e5a795e973a221250fbba620a4e155308759d0cd03a753f028df5459e58314275ea64bcef674a5d017b361e2e78ea99496333fbed5d4cfea221f1c4d506c646760d252de354f9fd5b871fe3b84f4ccb79b80e6d836ceaa59ef8b887387faaad74b50f09ce678f80e3af48c4f17c492250e3b17af151d218b9a7dd0dd3b8b2d7417e591dc5a459c841b2b878d739c0adac5d22b62f0d4d3f529fbc489e411b6cfd5315688922fc3548c9fc7b1b536f513d2852a1f40a84a64bea76f090e40c51c0ee059642acab0fe25a40c09bbabfdab29a02fb003e09971c92b354ae6c92e0e5723456f86d16101bbc22a852245e2a214859c3a74fe242fac45a80e5922b82011d2f593d6de3ffbec2ac04da19f26e76e2a12103b81b6ccebe60daea697c5502c730a0ed3dad8ed0564bc090f48b0d67c332cce8c2fa38b1c7f8b904d4ccdd58375d4869eee7473c37bf49564d30c2f6ebbc8187f0b5ecf462fec3d2b5dc7aa4e9f6ff66ea983a788cba1daa1227ad3e9d227786f805c24f363cd39aec53146443c2f3b2b24b2ea83e19af5633335fc144632d1ff6ef74e6e3b9d3fbe8adb8a30ca0996681a5f86d6e319dc16aee0f24a0c349146de73a9ee0d7b6fc5dadc8807402d1a0ff1c7611abe7e7cab97e55034ec460ec4fe7c1211273dd40606f7563e190bfc23f314a83aa0c29b35456046040fb5d8270499cc656679bfd70253097b1be648714688e1d16dba667a501f363766e667df3f852f407c0c5daa552bd5e7644e6c8ad3701d01f4e28578d1c31fb55154a1bf152b7c0779308498367a9a55476bf397bdd2fb6331b9bfdd5e20681e2b0ac3e096462c04d7f7bb22410e3952b951cd96f77cf4b6805823ddde13d440c0e2ec850300cceaa1f0058ab2a019b1049da9a84decdd2607e5804c524c6f5c3b664d12233a69560f341432dcc4589ce536edaa16f4cf6a910bb262fc011f46a7349312d02c22d01d77e91d3435365d032f40013189ba4dcc0b6ed04d605ed55cd917919f26eafec93565b13542dbbe693310480bbf441569c4c24588f4451eb177124d7a474afe51f17f23735f98ad09bbe8cd3c3bd1beb8a6340118c92dd7778fd4088cc984ac510339ebbb81a59816d1c6432e65111ae48d28e333889a7726fc8cea634afebc6a8f7e20191143a48f808c1286f2f4c0815905bf39a4c1040bd4508c300dba04a23aad974b24bfb88d55253f3f01bd6d8b48bd0f2dfee9e958c8fdcb71b01b9aa4e839e33efa7fbbea37db56270f95a5146436b3a98bc6eaf940bc3b3eb7877a11f5d13104da26684ceec528ba1825a867e7c5f4352e196331bd7f355ab9d513eee97362b6cc01f40a649d570e5486de5ea2706b99d107d9f66ea3fc3a59f44201fabacd0d03a68a5dcf4cb205c1806553fd56ac45a5b33f22004a1c09aff1160b3bd8732b8c46235ddaafce544c29a1f009ce274051b6eb01e4df0f2d04e40fd1b2c49816a796b22d39fd9d9c5b5180fc76854add9d46331c1fbc42c8c6f6991c9c91ff41e53e3b73e335ef0cfd21294a4e2f289633a20f7810ef7b2f892e3888d9b0a67a95c84f16e786ae7962bad505b2dc7dbff17bf1835586c9f124eb2aa4f3721604b569fa799658e7aec2579a3fce15797e1a91c2b1b71b0e21f7ec3d49280d4501f903ff1ffdacb4c2f8e0eb194c217fa752541f35e7d6930e93710a97850e9c3b7faa1f2988c7f676040b38b68446037adb62eff8f31cfad499b86e1e3792816d68e4b81895743a4d8dadd8b3cdd2846fb501e18e0a073873acab07d9e136d0cf4bc4df950b8c5195dd5028cba2a9c439ef11b3245386e6f4382fdf19b71515c52fcf5e7408f3a287a404ed2dfb72c5af35dad61d86ab779bc1d342f945c9f8a9c311dd7f220aeb45230f0f69f491cfe1c0ac0cd574e37f713556a41150a5f7036568515a8eecdc2d55df8f57930518c5631696a2bfa1228fd2c901544a25216a328b682c22777d22edb1e270b7ab56dd5783cc2b6165849fb2aa39e9f95cfba6668d46ace8d2555c5bbc5229612491fb3b79a4371aa928598ae8cee9fccc15b27e3a2a37a598c2e218d127b8829a3cc0e6402e2d7e2fbd65be71821937ad2354d3b9b2d7208d4ab28170cd3e2097613825a78220448c6013967fcd1d2e13359c1f6abff3fc5e7364d4c6117b7f4bc81d1c1f20797507fb3e0e26f65ca1c92946558d05b2246b4368c43f38bfd5ca60f1941da931d4696fa8fc8c5f40645b074c8576c3a5f1bd6cef3b10bf46871e456d5ad4c660b764b9396c1e5420d1a2bd1658636ab0282069adcd2feb3b36ff7bc6239c0473c017604231c46b32708d4444239dca9af879fc5abe9dc4468f475eb67d7bc7801dd9b7478bfebfe69b91b2dbf5007d4704231ae684c247697abb409dbd078538be7e5d48491740ba83f133b87d8f25fcf730cef3c6d03c6fa2ae407941c571d0e9e89733cdda507ff124ddaf035a4234da09f065bff68122590f4d85bcaf43639dcb87d22d7a81445996c268853ad9267d4f74651cfa0b4a5106c71fcb78d8a632a12549709200edd44072051cb96e895cc7c5fccdf5fdbd1c347815c662e07cbccf225319cd09222aab2f9fa711b4ceb2e445790dd88c73c9a4c62eef8d403a82a9379902828183860f8525780b9018dd788e0775cb1723bc3214923a441cdb3aed671728468d86c057a041ebce0c3583d0b93e635ca754079864db60ea936c445487ae3a448e3b878e484e2e460b4b27629cf76d84fe22bfef3c9d11a476fbc9368e24a60e436751a69d76c6d4588b301d9061010084f11cbec441fd10c05bd7fd9d9a5ad38b015e8f9d353056646523caab2e12d5acda8518c3360a3ff659587291bcd306ac3dbf328e57256d5862c0e74297fe5a03d35991a2d3ab5118b391390ec6f30785d1f71fd1a41a372fb7f0203e6d9ddb2648aa070317404b5be7e77775b72246d60b3cba951faf653340a6c038e3406bc029cb5d4f83eedac8dfe71edf999670c2d7c6573262f6465cbccdd306c300f3aa2b9a4f0cb04f91e9262797cf0df2c6554c786106f46000a25c4382cd83535d99b223db229a78d543c09381443525f59bc6b44821c02e8bd6bbe6e3b6701fa21eab432cd33b7f8ffbd2fc5943fe8e5870c03bb508f5d46d439158a0faeaef7df21155f088a73fe6d96ed12299317b0dfcf1fd743ee9108c87b4e82bda5017ba2e6d353622dbf25ea9382841c992ae35dc609d0de86c871f9ec46b4f07d4d81c24dea7a0d2ef0d209b853ea7945082cbac9b0cd9dfa6c7dbb155d8e0a25573b526993e80eba1f9075d3bdb0ac5c05dadb0998a9fdb239b7719f65a2fcc48d7e1102d3c7be50a4cab872be9ea3f77247d3319830ab091b4b8b239e29fac7df3ffea0e1ef2f0948b145c83a0ce79978af9347bd66531ba04bc9cf4a75693c69b77c4ed420cc8e984b6ff5c4b8f1d2cb8a317df891552f35dab73a488eaaa7bf0a1cfc7140d4264594f997113a8e8bcbbd279a027e225506b950c621af5fb32616015c16c31f98dc398e8342775e3241698245fec70339b5a83e2c5f13191131f095643bf17df123761d745b866c0f198f596a4e66e9c884e80358bb697580b343c225dd2d277c07cc9a2349c24412a1adc99c1d7af1c3959230461962e2ba418b213b2a88df82fa416bbe427cea98ff5f8e2b500615ebd9aedb69b1ec736f11e3ec792a8830118781b2f1f70a419c8cbdc58ed50a004fdad2949ebd5f8e8eb84ce315a5da173e841a97538603525325e31b09752def384dcf8fac3288f815395aa7be768f37f2a71f747d8ac51b77617748eb0173d0f368cc8b3ad743ed8e48921ba82d92b1c90f9dad79fe74477f133dd6365478e1aa199bdba6cf516e64dbfdc9718ca7a21a6ba8046ff05e5464d1a6c35b1d4b97f15a420a419ef9f47b0d0efd7ede3e2323e1bd9c079aa6ff1d88a8b8a3dece45d92bc7572322e43da62983937b16bef4a7e9ffe76fcaedaf3e332684c61610ef4d3a7b4960189ae20f63071f1583dafed38b989bca40a091156dedb4e7d99a18f9662ad4caf9d33e384cc770431315e553a06e3e41c4eec6e89676cfe0622fb411a6e20347e1f1949175f332bcd00b05ff286fb583a27c4f84ecc81b7ff3e3f2263f93fdf82c0d0b56e8a0a8c41925e1dc77038d24c7aeb7806211712e14b9a3ee3d859d11fd9b9ddb2a9381187031321fda4f81b036f12107024c04709a954b0fd707d0af84ff14cfe9844c8a668ee3040eb4545fcc6eeace43f53e615de2bcd7beac51853804ce9a516b539795ce4fb0e8e13f811ee28c038cdbdc163929cc23b036fd6a14aabb4ee62c77a4fe2a6b7885d84a6b6d8889f1354fa5a210ced68488047cb6d8e3f5aabd7d558242b2f84c86b4d1c6b9c00ae1aac92b18914803b4d9022c1b96b973882c152e5334cfc627e005fc1665e4d68a4c327a5c3260405592b8c1c6c4ed5c6267ea4b5a9d34699f41f2a6a220541e9681b9111e973e6056f13934151e8e843287ac8ad5ff352854df0361c5779bb018124513dfa7b3f9f7966b26f9ddcbb834defef52de149f57ea088281fdbdf4abb0f6d7bc559b79a3dea60a4119f955def3fabc01f65221b60fbe5889084332c385d76f2c4d20b63c6825ac136da6226ed1d1b619535e982b6a12204ad507ea56adc0d5250b29465eb05784668aede62eccd24a68330cba61897914fb7c8680790e66762606800f9df045810c4f50627e7799983a08bded3a6c539c4835b974f1a61f2ebdc49b7f17a55d24ba95ade004f290c40eeeeb6cd2b3007a1483840f91b2998db59a34fecf4b7f0e91eea18504f586a012f851553406c88d1bebcf89aea6ea9faec6b4b5f4688f117c371c5386db1dd40b06e95ac93827f6dd186223a234894d2170df31b1812543a3af56116eff1f4be416c91d61a4ce7026a8b96f1ee338cc4dec583da36eae9f9f17f83a88030256757e8b2e636317814ea3b195ce4f778e695ffc5a2dbed2379c8df6bd2878cc1abba8a20c2b8c58fadb30dba5839fc01fb70d190e4ee020770ee421120c143f325689e16e72ad20b8c12832ff03337266e5e567da6ec92bc9a645661aa88adf8ae9a021b70636fe5cb11c2084e1b3361dabfbe495842e17b2873b9fe51b99051b089ad0bb68ab35a135940cfb491ca6a5226e445bd60ace30bb7aaa39a811827f1b7db1af09bc0bb351a594bfc773a5d451b2d601513ea5948f0be8097af25a070d93a02d6554206e5ebefeb3e9900d84a978dd529bb81355ada6fe3a3d2aa841c5145b35eebb656d53cc2472d0fa535073788b3815f8aba6ff0bd1269ac3cfa3f66c6a6e918c252415a59d7c9c8afdaedabcb7d91fc054cb7a96775bfcb63d8dd35b36e99a4cf1a132b87afabaa228a0bc8348f8f59ff3d86b79a11a139623b0c469715532485d7cb1f5c1c9f9485a2646884d11c245ddae7c63f0e758ebc78360f9c34517c071d430f7f01008b792e173fafa5e3ee4fe6c1532a3b085850b46ce1a1b559888d4d2f192b80cb13d4690c44281604ff33a215951b4ca8e4f184354ec8cc8679b1a9deecfe2074028a17432b245363fb58fd5d14c62bbc8f9b290f101c98aafa01e4c05151afa0808ba94cec66a536137fc438a4f5ca56558014f9eb3c0ae78142ecc912b1776f768f0e2700efe62e317e9efdba5c35412aeb04b3583ae4e00bd6edc83d5eeadbfcda63eaf3b6017a49104813fc7e3bd11398d8fbbad9a8e77074b5b048a0bd9764a56ed068c531bd34052427ccec384cdadb7f3cda84da48338659dd5546d6e1dd78fed266fd4133430c4918af2a2dc4afe7d5cddc5eabc35016e7e516257bb22b21fdb99e53c528fd5fcd09822354942471f70f51e9c27cfe8e4a85f4f2d3bba8c23ce56d47a920c6c429e046c3bad4678352140bc66c040ec8d3214d24e44d69fbcfad3a5a43c11b7ce9981d8fd36f85efecca699a90e02d67696db5c5cb3002d17d39f5c510b875512cb15750756ad7f12691ff335be8cf1844c6324835bf47db669efe74bb8b31037aa0de58a937b63e6f3d4d490db43cb7283ffcbbe352dfaea85a48aaaa68209e9da9b92e9a43725b8fa50cfa94e382cf9dc5cfe4e5c87649080c45b47f5a1d801ab1d46716f4c4298fdb1162396dac6d845074b6125bd267bdd6458eb51492762d8e809bc89f19ee2e58ccd3dd395a70dd5e0608e6af87935fffeeeda82e8a5e3268972e104742a52c5cf9b37bd834586106d85b0488da9155aec30ed74b8d7ed6eb7c303426315a3ad39656ef75a4b36488d42f47ebda5e478bb07dfaaa6e8f206bf7fc30ee825e7f77b0d5b760f649803422ecf36fd510d2b1c1f799d4edcbae74fababbf44c94dd5e5bc170d492019a9219e54acb3c6a617188bcf2121578979ca1f79d05e5288f1cb27af2c48c792ab8597bedf962104df2dc4c127d1c6a5a33fea50e2918efaae7be04c90909ac697ce83e393dc093e8e795d1e1a6c8668e7bb531972088adedad447f38da5bea429778ce6b32d71d80fbcbc7d72184d01568f55550d2d98b5bfa9204a0f7c7664fd2b7dd2c8d4a698d7e4cfae930ff9321cd5e0687fc651ed14967d17b50739221ab8a0a3e012253d5d9514c0cb90cf15b136131b3f3c99679b08e434e87b84c12ce9f438c81f5361e9d0e26d7515823a8cf1b2bf410960e5540a7567b6c617fe8fbd94a866990f80bc8826704addb2ce162049ceb1e79caf95e09302fce6789458ed113c3cc4c3c69ecd90654edbdd9f7c266d120ed71891ec638de44d78afefeda362119e12243f28e7f9dacb325fe6e8bab31610844e2846712425b67e72dc8d6a2d2e0b84c9cb32180428696792eed9b98924cf6aa623cc7a689a452412b1d1781544af870428b289b956150fd85c7c04865814f5ddd304976d045801e5995bf72768d9d3cde5854696d852c242564f257af3ca5e9f28f6bce63966d0258920000c1f7167618c4a6b7dbe518b36822d49e624a405e5f1a5c35f8ebd85382a03020bcd60c38647fc6b64592026ca000706eaa109af1e8db59c8d4a97ae2bfd8e7723ff1643699c077917b0ce4dfa730b393cab09ebfc229151c31ec439d7b97288acfda8ba5435fcb942535174d6060971aa49b5066888e7bbfc0279f03f933801d0c8a9ed9fe6298c371a4c929482a747b6c9187d2c3e98c249d55bb11d54d9552529ad2e06b51ea4d939dcb742499f49ca68e288e6300a45556fe17739097e6fdc1722e2359483f68df59a15a0dd51c1320bf8a367a4a3ac5144d378ca6d8870601b0ee94ee0af8422151d867d46b9d4f8de8f40e29245c8c5fa6bb64d6d0aa53e2311174e3332425431b00556ccea8a650bc56d52e40d3e953662b34328570ed0fdf3088cb078f62e210ad006b914b33e717df04f4537bc179eedff4b3633b9be7d26d3f1bddbee68eede3685ce0e92af49e5cd921801488065fbb9366e7782951e7f534e62123e271634576aa237de639abaac258cffeb7dcdf951c7f683b392abe0d9b0626279abbd45ab02d4f592fbce564a6ae0d11d89004c527100b43b915cd93ecb8698a387d9a5864533ed64a9dddccac088c92cc25fd5571fd0de23f69cb0c0481419366754c0424c517d8a68f837d3c7230d31f50dee459076f5c3146cf901594e38c0bc381f0310dd59ab381e6e60fd446f9ea10a26dae905e609fcd24df3275e13977d6ff64830b15f2c6d6f2b9b1796e4cc77e3996932c56de17fbaeee41d9cab5c8f2fbdadb6c66a3f55c5e336fc74e36dc42d61a1145f61a687d5bd2bbfb5e49816e5d102460c905d071e144400f47e2e820356e4ff680bce972dbca607ea8fa7cfc4a1e8355d704738e413bb1ec9e45122f4c74b36dce539c5b6ffde0be78ab12cd2a38a52be9c0b6efc35251bb9ec0a9ef245dee3abe7a2a3d9a8c55c1099e20dcb1ebb62ba48ebd429b98122bfb324970cc91d85d6138eeae2f11e604f244175ecdb0f4148f5d917c42d675b051ff4ae9cc9dc5174686881e4c4b3edcb2f42b149cbc39f8f4863bb6cbddd0e4e1d4ef6af752d034520601ec30b3a7b41520f95f7f59a5a748fb04c4c5d66ec91f7f7f2d4c7d0bccd80690e63c9587f8e76c2834b597541eb223acafd3de1c0f495c56c107d09bdcd6fb3fb0d55203e6d8783fa215d4b49445d1bd7c2d930686fb1c121b75bdc25a72138e3a1b81024ba9a51d5b33fea7189819d8291ac70e20739b722de38e1e3c5958f343dbc0d0c3a40d83c41fabb35e71d0059213f7a80756c95d50f699ed85e283d5bfd1e292f64dcb1b908d6a460b1c4b6439fb14bc20951a1ecaa14b840eaa73fd9f6de181954ef18ab11b31d253956aa14d201369263af877a18a2f72a544d4a87c6ceda4557c5da56b8576bb4f4ece770e0a077a542a2a7be6609f0256283a3d2cb083042a3f6c36e477ed8d68203d4c2cac3bea46859a6d8667c7795dc5fcb565189431c439a2963b3f05d3bf43f1a01ec5279384a01788335424dcb1408274d8529ec700f357284684f83eb4b5aed814d8d2a593d7c6b980ca038c0399fbf5ff7053f79a7b0d6d41512231eb9ed2cf768c03fb279820d20c2562a8b40ac74d84e2b996fbc6c0e25dab21a4b42308f8e8a410d2a64d993fbf1e2bda7b78b82b71fc25bc2d4ccbc003475142d9120f272048c48f0f60a844e7062baf7f1bdcb3f0a3bca867459ddb678df289509ef5095573f7b915755ba9f75240a2594e2e7041c72cf89ba5b2a7f4a223b5daa39c80cbf52fcbb130aec570f01041098a9f5169a4bce4c39053c4e18498bd075647adc65982ff449c5285cbbe26c490f2e67ca910a323fc280eea4442113f456a081a00b80e9f572d8b8985af4d6005b3c59685313541a4499a8523fa31d3b78318a2d2d794ffc1a47c5a47178d391091ec7ee89375f7e04ecde3b34d4f93ef1c1c8c9f355aacadc55a432666ce1a68c33cc410e8ad8c2148bfca04abd2ac95aad05e4e44b8bda7196e4f8563151341fe9413c9434ff5cbc5385f09383c7ba3d2a22cfb0e3e2b4e0cb4b0d50bd8f3f5f8694403d56502277801ccae9476e0a70ac6caa372e2d03d873894cd86b517d61b81e87684877a5b97b9f43bbed363e4f71731447a7a1ff6259bc12dd58e44363d7ff33b104e5729cfbed2194cd8db03e525044e37c9096667d0a0d3abb064ed53bbe66653011ed38050f29c96567d3405e069cc853f71e9082d6d30a6188afb2d66ce7f418b681e0c4d0aca8e6c1ad469f50e1386a01404e502459fa993901a8408a0d4e19311da31d4844364876aa94a03ba43332cc776569f59b796288d41f6dc7a9682fa8c625292fb2450922e810924a91f443486b0482a4bfe588fa3ecef4017a12b40cf37eff14cab10afd8facaaa5a2f4486534cad36e5f055f8c73d84a08e69a6189bd1fd1cf907c5a950d8f1026fcf002056c7d30e1c5df81e348122ecefbcc0ee1d38451f750dfc359b740ca373fc2b31db375e5269a5e027d5f94094eb7b36f803269cb35f53e1e513f2b98c39b887771480a5f5b181c211a3b6559b40bd86fedfe7095de5bdc05ee34e86ae3c9a0daab8dee0a90d60b40ec0c865bfb74bc2c0dd9e844bcf29c375fbe19c7be80a081a1be1d1259aa117296261445ab2f3420f4a09ea378fe46edfa02eae836f28c326bbc2657f5bd0b686ebe86ed0adaff1876e5a4ff22aadc16b766bd9f5dc7f87030b2ab15e0c1ada3bc773dc4b1e633a58be4b4f28fb17716dc16f2521b52f3b2dc25bf7910375c320f883b7d911e4a5d80c6d14b46589fc73b272b689ae160fdf63538c7165af4bf67cb758f00aa046511f9334a194b98b895b7a4b63dd09ff968904d6f7d4eccf7219ff78af86d80b14aa5a8297bbd859515ccbebe06a2a24523a6ce9f16c8f8ce48fc6f51c1163f2e290dc5eb5c6e333529d9d9ccccf6fe731f6f6eb930d7e40eeb164dc856c5c3e5b1d4e0ad05c9c81c0d36a00b557732d9859fd5a753aedf16c5d586ce31e93363fd6e3136b2f9dedba0e1c3738a761cc6f1eacd0201f52260389d04965836d5ca2f97d6318e4f3d568de3664ccc5bfdf60a7b19cd01a5efabedf5ba6f563eb7c9c52c18db427e53a0c536cd321140a20d7da1df535ad350d0e0cfe2326a73e01739da34596e9596fb1a164e68a94c88cc88d15e03e3039f4962d1eeeaab50e8872a9603adaf046843aef646d76c1fddb0de51b37e1ee4e66839b4a5d0c6247e6785a9028943c55e24a43b0dc1e5d47b3c0490752a13bee659f2389c50d65ad4193cba16935ad1e5d062ff8b9424a2dc00f001ffe17422961a52fbd09ac45143c198652fd7793a938d11fbf2abf97da8d397e52e01402f4391a82929f8f46f4b07d2c9071d58e8c8ffd032c3e9c6f18c78477115a5106b13e18b69906f412d21d2bb8c1f5bb846a3afdda876f751f4d39f82115cf3d4b7daa5e76a8acc555ee5c52e1f5bb7a2efc4cc4673c1c45543880419996aeedebe46630ca4d03568c5ae95c0d90e322d3302e211a4a28ceba857809f8fc2ca9ff0079860fac454bddbec039442f04e84e6bd870ff4f0d782a0c36aa33f032d2567f5460a4b8118f5928732360862876b1e29e180df7e638e682a30f124c010e0c86b950c4d023293fb700c1d20280de308431ea93af7fb22c857812def1381e3e52fc7a2cb43f2b146a63b12b6c188bb6ac65c69bda555875ee526d1962e3db790a411d4ba30fea1296646ed6a6c579faa340d3f3684c7fc9fc0b481ab6dd1fa06c3c40e7a330e228f624fcebf64cec63fb9cdb8587b94ccafced9e196fed4948d1d74e95bc2c6a84386c47c3d1d02a5056be2d170a55662e80a737ab683ce62260cd32b39f1e1942bf812a5d19e665694b2e258105a55c79ab9c6e3d70d7661fade2f9a5fc563e724b9acb0ac33dfe525945097266a9ba4b1a5ce4e951390d6e92b631a57fa71d92592220b20adb69b00092d7f6f1ac5b4e7c5e22a915a9078de81fded815d7902ba2bc5177ab1072ebfdc76386708e273b53023612cbd5441461074d7708e1bec3c73e0e287366356af29f764c0061f9984e84d13f8d9b9e7812039b9e9ed4081db21ae2cfc0e3edfb3ea2276ae8a0444bc29c9efd99959180daa72e24889adefa03ddea34e890454c414ff37136a2fe021cd00ee009722bfef7ba17fa22b8f7073941fa749749becb0b4cb74a8ecc1e40341e416893fa4967dfd48b0c8ea88ab0cad11b1161a2dba0110b4e2ef0570226d8d6783d257d4df9989df41a3de24367143116efd7a69d93b1bf720a9b3bf0e020409382906b3d26a8576c86e5de51185e4619f58cbf9b839d27b7480bbec0b35ec9836916da10334b7945fa5a6fa177bb4d03c4ab38bcd8cde4c5f4dc3f5dd2c3e6d0fd8c026b82da599de2665e8c643573dae6e574dac98015d64ba02dbaed1dbee8cd38c3cf3b74feb2c2d314ac58c85117d24204102374b6f05a3dea34fddc4521a65adc23","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
