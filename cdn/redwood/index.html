<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8a292463a479d4b265744b09544516649a0f93cfa172f47ec5d6a8916b345f292af50e518780399cb2f385b963d75e2507ec87ec0278e64246e6ea18e46dc356e204a53dc035b56f39f4237616f9eaf91d80db60afd5ff5a5d3d0fdb737a4bd8733d283ccc9cb9abe8fb4509437ce93cf309def22edf2a583af3f4117c0643d855446c2d706287e9ab24c4478f951ed97534361056abdcef0037e6ee535fe1ca571ca589e4e3150edd803ff7a9af7c7c13e59e84bcd44d5ec65a5edfbc6c89820d9446035a1e2ab5b918c1880f43d8bc4c6995123f1b4b9e4a5e4fb025f7e75a31078fb722f97869a1442fe2dcc2b365b33fe670281b5be45b5588f38584a0acc24569ab350fe56e6501dcadb658ff7311ba46fcc2799da0e52ef4126767b242d15eaee187dd2b6a21586eb94d6a821561bf40a06cf7a64bdecdf2424dfc44ae769451cbadfdb43ec4b3edb805fc19841ef9ae3f2c8cc4d6e8d38bc7329504f1d73f1a5cb5b4a455fada2a0b9a0b2e8dd69df14e53a4fdcdefa2f0c205257a1124688285f9af42803a34f1b475cc9a52e5f9e471caaab5febd99b3353170cde248807efd1664cb9503fca60b7469494ec125c26c36a8fb3e9325941a06ba4acde1a4ed07694111a7f2f5219877c9834c2301284ed182a0d258fad09cb4c6bbcceaf853229f0bbbd7cbf198dfcabc4b2b0c98baf927cdb43044951bc6e9332a52d27cd76ae2471697e7e04ac0c3a782a6b62d25bc0aea783274f5d2828a211fd462e1d1512ab37a5e69c8cccb6a52cfd1898d08b1c8d47be01f79fc64742d21dc4e33ad874d82f009f82dc8df1442eff30027550465b6d031097c4be9f1377f72d557f96ec3c24c3c7b7a04bc914858e017b0044c29e0407c4edeece60054784d2d1a558f1c29db470e10dbfede59ec4434240489645e4e8587658457feb0c01099af1bb66c2ccc7dff6f076366b12273a67355d981e6872a3ba3101b75f4cfee5ab7dc915beee632a0108ee33b5dca3515ddc48baf8b2f34015e39de74a91dad6985abedc8c9e26ba660d8761aeb4e0000a4f3d0d29c70090b6d8c91bff6d20400c171b57a1140906cfbf94ca67b74826ce3786674175f2269ef37892a129afbdecc331f772a04e8f72f8b4a5afe0945c95b1dc999a990543c2ee3e6bc33df58a9b7662c8414cd0d5480710f9e81f85d9b4f24069114903294acba1554cd8011837ba9306ae2b61a57177bd16f0b263d8bdfb8e55e8ecf58c17034e047b8f01237edad9fe5e4bd73c0a63262056724f39a9e15822b462c7dc25eea4fa47bf40c98f8c1636f8e0011f260d111da749cfa2991aa721c9054aadae4a756611c69e04beaec070311856c5aa6cb1172d2ba3d8814008935b26626645329ade99e2b60ffce1ad4332c9818c23bd68e0a6119f3cf44e401bb1d903a06ef9b8934c352efe3afab4b21fe9e00cbb4da3ad89d2e5a1e68bc476c6b34fc9f96441cae5bf15d98ad82422e166b426017a4c9c66c669f235870d3daf14fb5a14eb87f655ef2edc98b1c424bf4c0000129714c9eb22de9c15323989817e78ac990bdbfe6774ddb74af2791ec9b2bcde4849cda1cf7a5d3e7af991ce88d2e053563de33895a3dfab0060c886b04657ba65838dd244c1384a50f1257150fdc4217ecc27ac9f3c44752348a9415cb0fadec68263d458cf0337512c7e4a1d9a83f487af2cdcfef54e9812429d4541cd2480dd1d4f7249974697240092695ccd85d8293001637fd448187db528c047498e8a031d0076124a38e8a2f5f77c7953cb18f2ea17f722855ac3ba0c3786cb48ca2f93174f8dd98b13289e0c2467c10ff5a61695705c00c9292277790a7e8d61377aa06a74d8bb9261f93655fb08ce800fca74309fc4c25f89e64e9cec92d2fe3a9c854dae9dd1c09c21df120e0da195f67b7abfb70fa1e9dd196baab13be640c4b7a2d452ef8dea6b4886ffd580278adbc51f04457722bed86024c73a785391b2d227349da339cf51414fe49c65b811803e427bf5a56c2f4316256ededeb709c5cd25528edf334aa987e88949ee859ae366b15b25b6bcde658a8cf47aafd9bfc29aa29d31ece057c6fcd2e5c08063789318b4d2e68242b2cbac6eecfe410720293e040a25ec0a874b5af8788cec916d60df1b266fd697d1d6571d2261649fc2833529ec84c093ec32f5fffce916a702cc2ac890a38ea9e77f929a2a528ddf9108c61b1809cb974e986c84f2876405d200bd17c0e6a0776cc0b62b4825eadae39d03c9e6525188076bc94c95c4c5286461266d38608db946c96d011a3c0019001de8920252c5dde8f4370cdfe4cdfc56aab9d6879d2fd76a1ae8f66425a14df37d8d38c4d5dcb38e7c4d1f50d0b7c1fd4c9f17caa507ab111629e4f8e5bcc0bf7e7a8cd5f15c828c93cc82057beca592c15733e4e04504f1326bd6077dd416197a01b829c63ce32562d4c947f2f0045519bca56bb64a47909a17bee23941c84af809b438caedebb6b8d3b8b66945680284147c414babe492befa209ba5ea468d86f4196ecfc72b83fc932a5f0c15febee8886a0feb0ba83b363e175e544a6ff60ae600014efffdbde5fc4f702e94719724bc9c1bef54ddcfed83f37368dd747dd192880f1b80081f2712fc113474845421c6ec608fa2e91c413dc4a2c099074807e022e2551681cf2e2a1604cb7ea56bac70200dacb9ad2b841c3eaed044824e0c1e726ccf890c3065764abfabfb4310b30662362d8aa4b21bbc73441f75b3b00403b0e8f1b9096d19324347d344a1f040cd020a321b6bde126beb48c573fe41409da73c918239fb357fc819c31f021789b0253013ab440983f9a1ab48a6836a835cb5cbfee504807c4d13cbd988c528bee00ee89a553cc8040869aff57e7634fd6432eaa69e70ec4217d4db7a7a40853098dbb81cdb38fbce67f5ca85f8c98457abf0191981a8d8f360d24225366517cdc45c022f508827d37c1876d107240f3fa85bbee25a9950abd19b7378919878fed9a9206ea8da844553ddf97ac4d5286624c92e3af25b87372fd005b3d259bc6acf4d6131a1983ffb3de6e5d226110e19442258c48261a02f8dd7d7fa7791f546e1bbd1fcb16cad1a55ba5bf95271e173d3a839b9cb0d4053c0bd5978d68d4d79db50b3c5121aab2289c84a0d42d8768bbfae40cfc494f26c46a568216d0584cafb2a97f65a3652651897bad6850d92d470e060bef98a45bb0673b97db93e3448c3d7f34cc6fd25dd0df1de3bdea9403026de58203f352d3302cd0d34f959d13ce2670927f6867be40843347bf517dbb5d06afc90cc7421c2db267cd14f187567e2677c47603cb89641ae8bfd1838cbcbd19ff01003dc6b28d19cae9fa6ad7420508d083bd873b64d6d4ea1ba8cdc99004c7123ce534522fc1871e4da6e02dc6376b7f28729cbe1b6dcd4a7ef47a0897f418fca85432519c7534e034a59c4e93d5310640dea7774bb61588b8f335cd7fedf83919acbb84de3d793f19cd378b86b20fff8e7f8dcd4ad8115d759ad7c30dee4ed24d0bae2a7e281a8b83c7033ac5257d6476be62c23d2d85e2397044ab04618eeaef6eab13d35d26d386e7162245eb42a1ad59493e0c16de995f9d3bc3a60302d6a1ff738b4104e7251b37fb82a6988c26a2d9355cff0f6f4848584d41c829b31d723c898ccec0ec0040cd9b81c4a084b131e99a29a327f3eed7b5a4ae1dd6f858b67e69429e8d1200389a7259f0d08845cc4d930fe38b99028bc16b97389f46a968e62feae6a2d0d18d2f12790868b5a3d332fde86847fc347d91b1e12b9e036b997c689083d6d66af52de468e12a3ffb7fe8d5d2b7ca08c084ebf2a9f24a999156fd81ae6e17561f83fb8931dd5b10449ffc312260e892dddcb13d40f41bf73cb7a2c41d0bf77d7dd8690636221760eec39076bd9cf62838ffc89a897db01a82397245a07cad160c3b2a0a5ccd5e8d051d677173abe819c0157b4861dc8a27bdd0312ba9ba544c928f0531891ad799d1b6bda3ff7eb4cd0f19a7e66bc8bb7ff20f91752eb1d4cd2dac8b7aa16f78b8b1ca972ee5a1bcf303fe054a12c11b4d0e228904b4c026e304b3ef01183bac42240031dc0853f97120be96087055549e94f4e1c2e277bb1d9b3a596ebc08fe20dea233ce64729a7737778bd02eaf810d6efbc86bec09bb1664d8cbf52a5b9564b298378778467aebaad751afd35a4959ab1f2590262911b155c437817e1d0925da2de68245ae76ab47654befadb0d4707b3d96ea84f6e7a3170341e09958532e9277f2e81249ea6b78e15171d4e2dceb4f82435909151b64f981a0c6266996aaf52267e347c2488b4cdb2fffa40a07fa6ba5ba9461231436cdcbadf07d3795c9302b716c31f3913b786c3107d7682c6537401b8409a703ed3e7cb66d79fc04228dd2d1d322aab8ea7501e83493f38cdd72ba139bc7a42b7dd888fdd783348027cd55c0bcfdf6a87808e53d85ab87563ea9d75fdb4e7ec0263c87f34b4c7870c15d85fadb6d42e0941b785c7359b2df8df665c7718228f545db614a2ba6675a0eda3116564d8a2bc765445f07c6de6181af62cf791eafc234d1eb6bd5a1e6b5583b4b1e42f29ad7d39962e64f479e2edded0600a2956e5acd29a3728d1a786ea68a1fe731627d3b5a8902fd03a45b48eb112b7d0b6036b8fb746d3d8e8f9caf4874e6d8e97cc765c62540bc50af503071767da6eba0088669644c5cd1b94ecd992c1c052fdd0c041ff5d06c764e27e630c2e8a72079add9fc787526334f1d66463ee1a82177e9a1059d9ede5ff397f6b17930d25a7d3249d96699d8c8267e8a29b62b89b791db527fa86a27058a54901d2d957935d2808ca1c85be1c5bebafd9739e4c7b91dc2446148d1164679649c63a2bb73f3233e3d5ae628fb348ddf59a3f6c82df7a3ac3ef17b69b3d905e6098eda793dfdedf66f4256496b7dcbf27214c6765d46b8bf95bf3cc7e690acd29e9f2677cfa5d69c29b087b3c35980be28e2aca3069cfb728af8600d38c235cbf1408aacdb52551af38348902fdb1bb34a72dc2782c6ea6bfc7599b1bc005a13d9795a0a3f80c507ffcdfdb7d280a055f3fe623c9825abdbdb1c8504cb7103aa66607f62766f52349a79be85f74eb17399f52bca2c74bfa70b6733477994e4797f626a6c93b893b5c410d584bc993914e37e3c18e2a6505edb521609740c13f6799f6ec884b2e78c0d1e158b0da09079c9c5bd99b7dc42b7bcbf37a76ca7d192aa722ebf15bfdae178565950077e0c0ea41f61c5de5169c68b385d605941059e6260431fa04bb238176bbbb90dd1616406430b26a6fec4ef6ae8a09a44826ae359fb9f34cfdb1fb34c2a98f19f472157b331e744f92e429745c53f9f903d73e8d433dae36d5e0f4748713abf1e76bab823bd8c16da632ab89f175a765c4fdb1c6cf0f4ec31ef028ffd8a3cb0f69648d898ff092a6448c8a726ed0fb1a9e53a44e47ca3087443ed66dbc7544a75b463a0ec91d79f751799a7848c400e3e1356ef17aa37536f67be19fa12c463d738c4cd3072806422f1ca55c22f2cdfd5bdd4e56d0b98fd4291646355d40cb72f0eb94efa173e5daf70596abd8af2e8c96188ff2b9dabe5c830b2d454073c509ad0e48468ebf5f4fa76faa6a97f399f58e123cdabf7eaa5b8c63dc82ef4b301bd0fed49e54a42a21dd35728363dfbb30ef0c363356e13747b5a9537f151a88025fe68eb2a190deb225933f8d93df3e888dbef301b96643cf1934f0143850364d02a7bd282007549b393797338edd59cdd4cc2a4cfebc6eab532d44a09b13b625e348bfabf8fb757afae0966046a2a7cf225d503006a117ef92e9426aec31931fa3dca44d399edbff7f2d4e183e40e0b8910bfc440a471dfec5046afabfae63a2d294716ca3240889cdb318ef39864dc5ecb61ccf90b97245428c70b714d03094090136389101b49ee7811f5b3290e5574e2f77fd1d449e511632831a3d4b73ab96797c5bb435e35ca9e15421aa70d59e39bb395c48081f4b7f0067171d645d901c3ae7b5ad00ffe70b813d575e9294410b4721ad52a630ebdcd231cab97929b03cd4da5f4a6d4e92c9014b5d8127b7266221cd524ccdb08fe7f359d92922962c53334065c26e165a68debdd764f79dd25eed7f63a6f66f37ca5288dffabeee45dc9600c64d39b998e07d9962f2c660f55aeb30b1ae7b4a83ad5328e64efdfffcba547474529985cab5ea87ae9df5b543e7b68c0bbbaae103807ea0ff8519128b480e436ac5b756189d6f1fbd49fd02129b5a334e0de149a9003a2ae53786181655ae434243ed609f34cb2b3cbaa1c218a3312edf3f80629ea8150e1087979b39f82b30e5aab492614a3f7581e2e9def0221b809074f7854408c1273e741bbde9d871b03a61ba67ec0794ff13efa3bb9b7891dd58411f047b916bee03af0e767aa3c7e96290e5e4e2096b1d491ce194821f09d744acfdfa77828e6c1fbfabe7b23d48c3a2b0e425c0a01021e7c52ac53c9262779fa7042bc1bf2f44383ebbc76007afe25cf2630fccaf183fd8cef9ae65dd9c0d020b36e7d6278a6ea3eca4ed0ed417ca61c339b16cdf2250bcde33e6b3d34473a78f17dfa1dfb384e1ecd110f7ee433b5ea6c260ef9aac880de1ddf97eafaae04f37bb0a9b9938572f316d96f60953f71a05a2cf555abd39fbbd6a30da639a216af412fe106c37a2e213a5286bd4b8960b43258847c77a98f45d5d2f1b3d0c8003a096767b8f493e6ddc9eda4225da0f98dbdd5934ba6122d01461ffc434a8c90426e9ca35c3093796dba8bbb47808457d02c56eecf9240e5a1ba39db03fa34e7d0bfb957414c87c918ebc1cc31b3f6fa4e672bca9236c75ba9b6ef1dd0eccaefc58cf9a52b9c16933cf9e40d8ccac3651cf99e08341a293b1ce5025afb966f15144b9daae9deceba9460df7b5edd043435f3757d9e47ec531b53e49fc8ec952d1c5e85d2570183b55e8e54244441a9c94aa125deeeb13a438c332265dceddf5fb8359c97cb88978527ad2ab14ba2fc2d09e75f24a95f95d30165f6a9a5c09f1335cad6217d23c0a7811ce51715736b6304d300be540aa5a0b25402b31d210221dbbfa0938c0efb39ccbd0b2db15b6d35eab14579b037f76a4ed67b8be6e157910c46754956947a2862bfeb1d82c45339b07e4cd08a2cec801d4e0f19897c6aa354e52d9d32f437ab9f9e823411553e86fb06a1484acb87b2a0486d8501f547fbe98fe7474ad702947adeefc8371db2ce61aa9c5cb0e28b317c2ea2c4d537370e80d570a24fef58d1876bf44a5612cebf40c85d3584a528e4607ce607816969802d59b55ecd2d21e53921c234f66235562f13207edee2db6691fb84f2098ae6d92bab1cc4305dfdd79b9c4a07d7b3b021822fc95aee267cdb0392dc804a1a1f5368de36b297ae393a342a04018ea8d87084a09469950a4691e55998821b536b3a6044b81487628f7c9dc6c9e8baecb37e0b1d3f587e830e999cd974f8427d7b9d03e2ed343c5e714e17d00c35bef7f4085c3f40a068fffae81f39e3fe9ab5d5aded8aaca57d57e9d2ffabd6ec5df9941e895ce9ba818be26e81608bc92548426b86b13c305958bda2090f083aee00f096acd23610c3fa2e542d90d4e95d67b89c2101c68066da303623c9799ff3181badb9f42a596daa2646c9185d8b9790ffd43a42076c52de232a8e7a5bf6b4415eecd89f41e5451669f9b65b329368cfe78aae8cddbee24e4f89aa44d9ac962ebb395f134999b3d2c81c6e307fdcceebf82e021848974c23a415a0939af88fcdce56a8bb1734fb9a11b65eb7fcce632de9773e97ca1c8479d4cd7f17f8b1419a3b5791f0385605a3442e99c5268f52548612679b321bcf18b02646fc5859fe080e04ce52176f9b0e3b0d26d685e53c179a29838596e058bab4cc6b060716425c5663ec76f87b0ab54ece20c3d6dd7f42a4ad4c090701d0dc62a32b09a56af9a50fcad944900858b40dd28ec4b07ff329006407fcc1779b45bd15e9b6f20238ee449336a271a3864d0329e5adb0fab9d5479a37c70efdbbd2c8c83f0d10fa79f17c20087b48045e94d6c875b002962ccc67bcef937b4b48899f9754435477310d2cc30d5b1a65de7054c9d6e6ded40fac4a147db18d7170aae399d350591a12d917e1f7c2950024c187581cf949a54523a5370291fd0e548ecd2988ce25708a21fdc5991aa426559c6c9ea2b72fe6cd2bef7f6b035dcfd882f8c553151a66d1cf981665aac25fe26403fa91e38f3839acd023cd0b336a5d6c2134e4d3bb54e087aa6e3846cd65dbbfefbf8e92df6db724a6f8566b163f57b419013455df9e482a84d2f357fd642e93ec849fd53a8259c4fc936324ddb4b7079c16e3ab7c2cae7ceb71244001d8e89578485808b3f59060e7bc96315527cfa8c71eb99fd477bf496ee48b15873ca0933ead7f13535aa9991c6e0aa11f722e0443f5fe0e4eca2ad793220f441f2441c603a281fb41f0ec3391d3e457097917c8339a0fbcbd4cfaf614390c99ecc85864475ab158ecbd2f99189948597dd476efbfd70e9bd4c60b40c0fccaa0d63087b953ec863d4f77fdb923b8384f1ca8dda916bd3a53e332a27fcf48219712f47f8497bcdbf18d6dae4f4e428c7a74c9aa1f0d5769783bdef7a9c88fd2b02d14dc59e1f4584c14f15beec0febf8eb5556bce9b9d0f28f4c79b882126b64f5983526b9f398d280367c29603da0f77e3472a5e295620142388173cd5cfcbf5794856571afdae103513a3335b199fd424ce692085d283e9edad318d73db22ca16b75e5ab7964a813654de1c8f4f04830498657b88d8cf945eae7b61017afdb416101cc6f246399b45312a94db351876493d958cdb0f51346d3c895af52326b481c72ca691e9fd6d70923fa9fc895ff61c669083b97ff4ca95fea477842f39f3c7bd65a9d7e8594606d1afdc846cd1babeb2c6a379f5458cf6b07517fae9f93c8dde890b7cd32c99d526f03118df9661edd9218e253e3f90d27766086c5aaaab23f6487aed776df787e9264ab0f8ee16139be7a17c75991230b360bea360a02f7c0b4d4731bdb2ac0b7bdf2599a861ead7b8b5fa69447c1cf6f4f18df3722e40c7bc55aece3b51a82d78aa85cd16f6a5c5d733437a4a562625758286a3a2a7fb4b30d52d0d324f1c03f63ade1487873944be051b4c08f52e335deeaf53e1b4b14b2233bf2ed1bc36dbcc1a398dff54fb8cb650e2169d7c82983f755eec2626917ab3eb5dc636671381079e747b68228d93352971399f2d0e872af0ab67140390a67d740d48cc19077e99c272af1b9eac74c2843a90f6dbad02083d0ebfb43aed54134da7275c5d248b4e137167ad2907ec333509385516ca8b22ec714384e7657a39a8c309c76b55bef4a2191a742edf4ed2aea52d0dd12a87e0e2760a46ec21f1dafa2748ea50ab1494e23c6f98cb952904cfc9b5d1eb017a7f1eb428b60d0600a2576a37d1dcabb18458e67793eeff22e0800aac9ffd9efb6c636509c62dbc450395abf33f925cb3a5dfe042501a875435c020a72282b10a302ab1ea12920776a31e27c415b0e34f12a5981076f413c65aeeb038bd849d9393ace6222af575084acd9d03444d9acb6fdf134399e4bd16886d63002b4c5563e25f1be6f354fa01d14f70aece4711781c12a2c29163a614b335c244bc33563fe23189c02bf2458eb70f305044175a198596ab843a9af758eb0f3583a062b6bb7683ff0518fad84d025c83ada716d2b0f88a35d486f34676d751ebfa11fe2ffd63402ff58276c8ecb4b430456021eb485bbf59515e9ef1e3c6e350381beff8192dda6dd0022c01c7c29cd777c63348369d4951c40265f8afdfa81a84591756c88e5f4d53cee41e36d5326de8960432d905d033cea40b2984a882e5d92d1ffe6f3d5e1b2c56f42d94f3122ee510daaef27366cebff8fe2133f3329374f7a3613e464acfe58a5c6b7ddf3c230588bd8fdfc30a48d6a1bae29f073e766f2cf44be9290ce95d01e604613000ebd1488ca9f788417d18c976f085d7385c3e14004da752b74475da23a89d687dbc363a73c0aea93d33fd7f61a9807d6f5f35f8313c3ce94fbf2a03f96bf29e4e0811566307da92801305503f95174a559d61d90541e351aed25c057730377650ee1a46c0978aca6f533a8688723df983cb659741033dc19e80f8da47ec7f1ff83b697f491a23626fe12d796309189c086294f8ebf132abd8910ed336ba761c930869581cb14665a0c826f4bebc7172e05ff63f113551502f56a6faa10a9b4d7c125f292f4cbfa6a20e1ce063d9168228d0acdb29bef818e35534aad353f0330a7dc6cc818b492d7448b0828286d969760f71038ea562fbb15e81c9ca2cb7cd9b8da04bfe4def15d58f93632eec01edea1b2e0f6a05b83a39b33d9c31e017ba231aed55c7dbf1bbd1574f390c5676b527206bd8b95ebb35d237b97445a4e721f2fff62054185dbf50776c101d3a2baa64f7858115401597ebadc731816d9dcd93db46ff1660e140d1469572711fdf3d0dbe7750e47aa20afce0040b81f33effb1343d8064765aebd75add1759d8873a5d6d2147e00dc216bff727793a69f8e502468f4143382aaf5fb6668d25ef485ea889dffdb822ae029dd55f057b090f7c2fe765e079d54f0baadef2b833fc62bcc3f484b6ac93e74254708641ee1d33ebd45e5e3c8c341fdd13d2b4c2c83f143db2c01ca378adb59024ae13ffd74235e0246149099f06d16ab00a0d4555e266357e828bd407987a9dcb7b5b694231ebf3d0b9b5f7f08a0710bdc70e8da0df50cb0112ee5223cfb662869b2e6d39909d5e1cc136f0e705b53d5b8f428aadfc5d5f3042011b1d7665172d6674e329fe360dbc069033b02b2364180521f7f8fc08d8fef82f5a53d9ae59066cb1d453176ad87217885711bbd139e6bdff7b97b225a719921838196d178440e059ea98afe015e93d2a6f80e2f18ea014755ab240bea5ce37971bf32dab1c34e57c76ec8cd5e66269385ba7d7567b0dc53cf936990ec6d000b40b9e3ce74d091435a7d4d50801b001e8646bd355bf972ee16e3574e9b761595d53b4392fec88599b570a3ff43c16c2c6ea028590cd5f0a906bf6bc0e6146281d701fa127eb8b5af14d480a1c91e5b182c81aa5fbea9d3cc85e5d5e49976524443b2f910dd3786969f7fd520854c49d41ab9b43dc22835a2f802e801542a0e3592a11de26d17b6d9309a9451603443cfa634c78f39369dc7a844d534af296dc717c81d7a6b75d5a193e004af72860d5c57657b17a0c0e434235a143ec5724d89f136682a3fe49386cb01a7ca266c4cee1cf4d1422e5aac3ad2cbe4eadd45233beaeb2802101910366fefb41ec0750edc8d01b853908339126f149eef6367fa1fb11ab3de49c33a2ad3e49ce2cbd6a4a2560411fa01f3f7da7a9e73f5ecbd51b1996ceb6d9196839449d0a381243bf3e3f7ba3470942c5ca73228324abf826370c74318d974bb4304d39c0b4e4161d29d50c4f20bd490fd414db1f2e7698d205874d5582eacef987dee7830ce687c04baf2cfad0b979fb39df4f98241aad176e06efb7465465922f1bb763bcbc8fdff8f9f009740bffed1ab45e4b3fb8b36232fddcb250ab24c59c779329e10f65892912ef7f78635a69688989c3d98cdfc3f3c6d124cb28d22517dadce89a547a13746b40bcf84f573895fdca072a31e16ac315bbd5fae640794fb82f75b00cabc517490df41b3749812a644808818906a2f4085bf92b9fbcb0db7b258cc7baf42f8bf8e34285e78a60b8cdeddf21ea3ed1c255abb9e195a825197eef77891c09074ffcc0c9caf60dd7c429ead39e0eebaa737bb79664da05e05c4359844e732cb079691842009702c43e124748f4c5ecc229f1b048f3f8de04802ffb52a32fa7da4ae601865b1830f4ea29e948cc798a3cf30d98fe16d1842ec3f808d0426a62ee7549df6428cebba4e392a96e7c7ad529aab90791de40361e783f3008de3292a90872422358d60626101a6aa36ee4005a824d3a56e2f78cf704a6592a313807c87a4c96106ee70f8f650f34b6ac738dd3f3c362c76bbd0377db1eaa522a63ff425bafd6bb8f8307a4a243e1b85748bf08fd3dad80f36b0fe2b775ca7c211038656c24970e94b61268652afc2c6f5c7e18539aebd39a779bf00d89a98aa728053b0477292d8509caec0095eb740d4963c5b4e12f23a681765a4d1f41fbf6dd8cd89db03b82ec7193ba465c5a389357e4d142c92a6caa58e4c2665ce4fc3a1447ce749876e66f2ca8fb618b53f6ada6423373ae0590cd2c2470ca19434ac64fc6ddcca315d3bbc649cf14d2bcf2f0f8e23cfc9ab06040b0c83f8cff12aa3bc0852ba0c7a60ecf5926dd752eb0cbb63e501ac9070e9d558c191ef3c5c09aba547a43cbd62580427ed686d270f074483d6e16b7eb5260713241add326121f02689c6e48c4698ddb43876797617c6107e8be4fc3fb992a634ae4e9bdae19598889a39481a0a179131b7582fd38967bdadfa73693750ecfc6680143d196730c086c67626dec25d5653bbff5bf2e6b154b2e067a48b05e4b6e707e0df70793d377b65de57d2b145881a682d76d35560bb855eec3232a4348e8efa7bacec2b7c4ac06a1bdda086f8bc3378101f8547bd67d9cd310e1114152d91d53b6ea84f74036766a6e417d1bef869b93d7fd5bfd50020c358ff8088f830d8191c5c5131c2322eedcdf1d5097c00c601023f91a8ac993ea6259e6de5a45939069a9c2adb344ee7849bc5964de16f4ecf85b3c3c03fa40282033750d3aed296f17b23ced0537ff8925a2605c5e9196093d327b8aad43b71919e41925bc1e90628833f5b259b1e6e99353cafc061ff4c611a0aa40c6c2ceaaddf8af9246e95c1a2ee0689804c64d3c4506371a13a42556a1814bb42ad81b43f694e54aa97c952ef6481b13061545b6cef52e2551ca80bff04a3bcef417b24698b29209edda0b4b186503071f5d997db8fa0a6e6938294c2f2f3c36ad9f5b19ce5a60fe59fd2f17999c5890c92b02b443dd3fbff02da9b9e8d71ddfff7a4b93ad4006582cf048caf021e5e95e6c5f07627c5faf75ffdbd2959b09aa856160cf3078d1b4e255f578dd0637caa75c87452768ac972b30474879f028c57b4f300108797089a00f80b417e18cff25be41f9ce0ebeb0c54ed6702a7b7c345cb62d6e1adca3b3fa0a3d12f00eacb111c46840e32aa5a0d610e7661b218a72cd440aef54cf360b721af101f8ad9419419676eeb53d0e68d46093d88b5bf366ef49fac5f00ad20dfda0bd3ac83ab6f7a0a3b30d480677d0cee9774f2ce05ce9e9d289454afb36867c9b27022c834bca8a0f704aadbfb28b11e545d7c8e16a47fbdfa12391a8e15be756a0d08c21e15223262cbbebb325c3946fc193fa375cd904ce38e6b7c31b617856e9fb196799bfda1f0cdb8aa485248a0170511a6253dee6a990b1239d3c71eea941aa9d4a6a6ccaa1783ad18f8ee2e1ca3610da06eb2b73225ecb50d5f24df713cf16604770cbf4de2559e3da5aa2d0114f6a05e4cd4384fb7d10cd8e69dffe3bb1003288c614f1c8b178076140e8c38644ab8b25adecb02c7ad8c6a49f0addd5cc85549a31fe70180231a534418b12768a89ad8cddc08cc942acdbc23b1b38db0e140f531535ada7462de1c1e84a18966418cdbfd82779a6aee2c102ac2006cafa94bdb463a11532c1d2c76629f9d6e637a84995bc3214a319cbc4f437cd57d06fc8eb15e7cb5e90a5ea7177dfbb3c2544bf5c1578f043c64a29d23a4a3d8443099587cb6597190ae872dc5c87dfd1540f9f6c093ae36247acf5dc6cbac44a17dc2b0f3740e9081063843a78f5a7dbef259cca7de43dfc158844cac645282f9979cb11c58cdff26ee73019806cfe52fcd6a9b9d4f99572c62f92ff27a8ec32e12e2da236d4361aac4fe594ab0a2cf80e568cc7744ad110aba338828f26b72b95c3adfd75255fa4fc6a5b49e4fa062fb78f2df27035cf02eb5d12108a08f63954ce173afe48ecb857c2c434e850ac7c3fad4aa51d1b891ec1e40f3e7294b2ad687c81bf42ce6d99e92b3666cef987c68126f193dfb69feb67bb1639de71e2146623136308a975e9782c2e99582eccbe11bfdf8e664031f7fb1f0a26fe472596de7df30a9ff980587fec63df941aa01d6a3267e67ce8a067cbaf0afa39bb167c7319bc6748cb5cde0de5ee48b3236eea59333ecc53a93d9bb20e5fc4b76301c779390192a95abd835e8fb99e2b6b594131a5139c7d3b55162885f2704086930260d0c8c02e24ce9fa185d9d2ce55ef551666fcbc23431d4e54d6a62b205dfd8557d218be7d85e96589a44b24e12a4cc44b83b680fa5f6f8668fd4bfae1ed394e73506a85322cc62b29db28cc2d79552b2163fa6098f02486db1c7a4136712ed197e43946919252e580445f3861f8e69da05c8cc9d4bf044ef864bbc9356734d11192680b4cd78d6f1dbb3ef6626f877ae7b000f4e4ba4979465aee9e95c5cef35adccd0f13932a6b96a091794a28aa0cc8226e3547c2b18557234d17031e3d9a9abbc4cecd9cdcc974066cda83a25b9f9dcd8a6e38a8a4cfa93bc528be38749a3d362e2456ce129b2f84131828d9c4a82eb14cedecb919cb5dd1da948cc4b156b3fb4df1da4784f58c30e6611b71c3d7dc5c07de5d74f25b25e0805baf057c4b48793db2be3ff3a57144cc253517e0a3d895063b594f6cfaebf7fa3eb9e7a9e017f26168cb6b60442ed529c6c72a0fc2d336e58c4fbef31b53486da81d04c4d3d7e316a81fe6e6f0fa8174de59f6c665f9e2eb7dd3b7b75cfc5ec1f29006ede3ca9d2e3b2f35f8f8707c77443e4c96ddc69244d018bb727b51988b59eda6e81091bbe91e76ad6b8ce8149d63300f2e95513d9a6d8a66b9eff13ea3c8e6bbb060da2eac5bb5adc1a48fb1e591bbc5b472c3e69d840677db2c08ae6c9c9fe6d90bb70903973840fa9755fe6d3f7d233e41aed18d4c4e330007e7b4b7b456ee1865dd2b6837084f28e03f95480e47a882f53b1c47d7bc1fc1c8dc1ffc9bb5834d9dbd71fe0438a4942a5635c811d480d47fd27ff6590e2acb0df014ae9cb44bb8a3d66fd553cd14fdc488609a13f5f72cb5efb9ffd1a84217f2e135938f9585d37b9378d26f98786a52363de84850de5a5adea9d03cd887e41dfda778c42720e566be09485327bd6c7fdf9b1a5ba4178b364571869eb0d1b3e2fe04fba030e6ba5c6e8b94cf05d19a457a1a23b14c58aeee79bf927c8412b774874acc83ede314b5955b69243a746f536c55d2f8cb72357468413efd31ee90024298db06b495a10115dd96e5ca0fc2c1a2c4307c59632f3bbc0de48b83026f6f64b51af2f82fca86034aa19f236afe9cd8d38879ba8629cb17a5941ea7d13ff976021761f1d713e77617b29a6d8259f5e5281d8aad52d403761c9dba5825299f756e2d81a67aa74110609fd8d0d8ef068f273755b80b3df56c01eeee49ede40ffa6f5bbf03fe398cc619a7314288c2d80562d518c66d999a52c5571be4e11b5b748a6bd516421199e7f797f95ce979d81554628e3834b83def9e7fbd65fc0d6cdc2629e4b882922136aae46fbd74c3c97d9c6c4ad90a832ce843dec85eed3982edb8f4678e84db10ba7b2822fda6c9602e560b0b35000184c5ad94fcf852915a7982567dbe1b70218dd7f81cc4798c668a1294ff97f12da21acfcbd7849a366d941ab46ac8b93e3e8025c07c227d163e341f4a2d0da0ba7df9fdb55ed8efc7ecf64b3afb786182eca6b75b6a98f419533b2b60c914b3f5dcde406bb18da47e6204e2e59c3540d2b2a6ac334de7f8cc40954852df244b64c9137af7907d55c1353b4686317892b955c52fa3cbc0b40255def07815269fcebd25e34a412d3c201fa8dd2d5350c60eed75d58c54c0757f7420b9db7e985a916e07c5f22c678ba46f0ef9fa20152ff418fa360e79a693ee0260d65aca1a04a4cf8e76a5629c2aa809121591e4f531face6ff2421b3166f3354be51cb6b3160685aa5174051fa33257f376bbc853d77e4be83ae864493e948ba56b70c010b298444e9a0bf08032d159b98a8c967a909d03160d197a6dc75501283aee9faa4e9769b7409812bda80b018d040a9cf54746a1a7f3f7c590667ca9e498d29cd0cff020fdd85dfe17c2c85daedd3cfaedd08500486bdbfebc6d2fe6150bd359a6f872dbde41381e19d108d75f6a42c6b8eb1244d8baeaea8f27418ffa3db6a7f886ebc277225e0eae76fe5477dbd598aa93d8fe86f66d3f1d148ed9a5024093ab77d51b9c0576cbae656060427aca039779f98f599fd7a34b42aa21533f7ac56f7ca22c363fbddb40e147a7fce3a41457ba4f2c355cdf930e64afe51aec5715d7ff9c5ea316ef146e69ea8c00b022c86538a8003f301993f97f1c73f7dc9efca1d08841c678199bc64734e73505233a475eb9f49a95aae927f31bb51f1991e99435f15b47b30b8c5548f499bacc61fc6843bca9af3c65b3a27fce0ca1eeede1d8b23076ae8b34982161fbeb5b2278ef165d005af4a629b2520a6e36e76a5f04cd0ecb9501a82c3cd72e7585d179a90456d1e42f8eb279aab7df9005e9590c8140822446a4af8eab3d6f0a8e81e15b1fadee89b18478372660847b771407ee919077a3f37cf01fc4664e9d360f15f09e5627c11e780c4dcd60de302b0445fa191f4a0f1c13a38f3aea7795e9076e7476f78d02c6658b58f9ae3d6f68be3ba2def8402b6a9664e5204717fad1e04406706426baf78d40acfc3743a270f20067a93687b5c3cc1d4a79795c9ecb4bdd5a10cad0f37d0c2a84b8ef7cf547552db7accc84b080bba694e2e783d062a4de03a88a3c71c6e98f0cbebc7b141b3d646dac96a871b60a656e7bda1eee1dbb3454545894cb8ddf9962f2166a8ceed3a6ad79c44b17979ba3a679e24d66550e2c16bc6c3ea39ba114e8a66f50719c2d1ad7462af67e418639622e9d49951c3aceaf181833a61d017bf7b26c5d53340e4eea5f3b7578ae34de2057b678fe5d17722befef9597ee28065e5500ab7572555a6de4ee1c6b2f1a3ef6bb0b00002615f48c4e2c29d378b6cef032f4c7e31a60e4223f388c18cdc30e7bbe85e9e333e7c9b694758746d52349c226ddc968a21049e73db86fb292be5f2a086a15727b6e038fb26174ad3c0c701f5c098a2eae950cbd7e17fb6a9d989bab6e08a20165436dbb2a2aeda81ae7ec28eef4ae456800455832d279394e195bcc395cc80b27414e462bd2cb7936e50aed4e590fec301a801b885993882e7ae657ba4c59a29c1b397992fd73884b0ecd4eec19d3a1219b52699be711231b90a90914d93954f91e6b72f5d7ba91b25130b0be913b9753734d4ff7d414734f5229851f603d932834acc021044879ae239a497a734e455829bcf1695745735f10e0e3046b6b2c5854d167c40dc3ac9b94c3d6bfe2827f1d0edc2cb811f0e85bfafe10c938e85c03bd8f3faf7ad8a796ed5ccbacba6d4c25d5a8baf2068de6fc3274ff6fc227e09c69ef2206066692d683c60f0b530de17ff10e87d89a8d88026bc58e0fec7b9e52dba3afce60221cccd0333b2e37c4ca7a25e30146a620869ab24301323d7cbb5c8fdc123f762ae7e66d287f2d78904afc65ad1d61026bb1776992aab0c9a44f1df6ec21da136dff1112f5de5613c424bb63174a8636c5135a1decef7c25ac696ed835b2c4f8b456d74db6cfdf568db0a40095175eed5227810b78cf9421d747c44de3a517a78052df750ea74a6a1e54d7b934f57c69db2907ac8a5ccbf60073a17359a45732bbc0c34640e1b6a287964708d88b1f4c3333e43b8d1f69363fbadc2ea40ade3138da178366bef55e93d651dcff09c7dc97b1b6de5087cabf79798af3f54d75da12566f7c4d9ed1f99574a7818fdbc4995aac3f81167598bfa490b85cc59d55c9e8172a76bd1839ec95f6ea0a93fe292963f09ded","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
