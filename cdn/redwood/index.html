<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"411300c75a96bd90d3c57246b6b719930983ebc1f30c3081db3a25c79f16a411b4b50688e231c57a1d2cfe39a0d6df7f4d0b037ac89ba50009715a585c3b90055cd5cae6fbd6c70f29ce73a7e8e0081825dc70d436645d78ac5f559b5c2a57b9450db6224c5e48de71ff9db6896ea464e20c556975ba5555b0463b19a58bf664120d18cce57b5e4ae10f21201264a1203c77d509bfc3702d76dacd75807164316c0a7dff5386f40fd714f65a2c6e8594c29205b15b3250150ac37d3b86e3bb572dd87abad571844046e2a083dd474e78d39cacb5ec1329ee16cdf8da26c9c94ca06643d6aace61d0a8836e8e88ad2d0a86ebefec278a486254d282e0e1760d3caca2a5e0104446fe23035e9db6ac4d1236169b8970f0e7dde67f0efd610b75836ee1250b15454f6b62449410c544b60ad8b288fda1b8d76ca1747670cc1907914775f00d11bb7b092f4a64ee200fb9a35e8da84f37d0b2b23aa7ce5fc28cf747dc8d9fc7739495bdd0e61802951e0ad07535b8b059e237ff0a7cd6b6cb8270f8cf1bbd06a2c3a866266464a44a76d390ae647e0c94475c3436c890a745e4b6389ea4bb12f08950aa5860ad46f67af4e3bb3481bacc67ff6ab7093cc92c33054a6177c68923caa3dd4f89073ac7b876ff60ac0092f3352f7a0f402c1bb723d5a525a11932eed7af1fc52b285ec92c8c6d9cafcc17e3feaf6b86ae840267e7aec84e8916f00ea5d205469097efb3ee27c93cce05ba620aff66484fe2580b0d3b6067977a3d7a7bcb09898aa3c8722a0209031f1166c5f94bc3eb2865a80039bf4b973ab4ef7ac761cbbdef83c60713031b21ba0bd291c4697169ad6688774f811f9220c7933d721a90c4ff0c4fc65a1fb8376475aea20315f35549b99b8cdb6b5c2710bded1311a61941e9e212fb556c7326c41afba6951de22d093da45b0fd9d9996bb3cb319ec82f3d410b9530dd62a1cfb51debf6c004d0e504e4f074f549419e2c1d532fbacf944638e8925e17b6c762c0ac8d6a7eac932c4002359751301785fa0d63b7987362b523105d624fbd8d9a96a219f36898e7f6e7ba574993a3e0fd4a84cb12767c45f1e5a4d3d31393a30081631e688d10bfbf3ab145638fad0e0f17ed6b2de3018677aa4d26dc5ce779532fa201a9784a5ba833f5f2d8f8bac9f584c718d79a5365d90b9d4e478ee87092efa82b7d3bce8b65e08fab2e55a7583b558c040613f53770acc7b0247392cec583b6b90a943bbabd69340a56a5eac3e4f4b5e21481a48ee4bdcc7182ac95c6cad4eaadb544a930a5b266bf6f039c0f004f94516dad17e6e0df6575d49f44770725656bc1b96f83cd5e8fc7df38f8bbae01534d6285e30441dc342f36d5967e2c29ea7dbc941a969df5b90ee0dbeec05b6db63355a16f3e79e986df969648127adbeb8a911fcd663e5c3ee6463963afe9d02188017c417d055298ccafb32bea2603f5dc3dc10a942374ceadf63634e33e167ed4f2085844696dc351434e6ead6185077e6084479295f4137e2e605d6f62f806fa7c30c66205ba5d41617001ff34b692d00cbcf490f7a2c0cc6d9aedba3179c6b606dac0e81d3de36e2a2860b0cca655b5374c237fba7c5338330603ca5f84cb2154fe2c060257e33691ee82672bab0eef7da74962c4244b6e5ecb7db8e8621a9a587a433ad06c57859bf228fa10690f60f30f94928e73fafc616d72c2fc3eaca711bc302366dd956cd5ede3e8dc8e77c3de7f290bd3e97c71a70aa31bcadb9d1bbeb7a210c70238d436d69058193ca575358877f1c6ce715234ffe85d649586c834f5ad250557483b51323db16a31de817a9baa7ab398bdbb40dbfc246e2ad4adb46e35804a14965952ea95cb48a88368d616da12a8fc2619fcf5296681fb021decbee421d0a036a0f2fcb10af15200302ad08ed3e19fd67cd8b9f191243873c6c393a11337aabbf2fe689b31f8c90fb462d3a8ee401f4bec80d8dacb39284a67bd65cebcb5aaa1b2a6bcd25cdda699fd4859008dbbeb5e37b4777c9aea87ec73671dd611bd91f39e1b2d1c205faae2a7dec1dcc0cdd49590c4397544a70a716af1262e459b7cb42fed6296fa227e5592b5eb16ae9952e06452c21f2d9b45c755b744887d03faa00b65ffa828cf5de6825c421c796b095a27468c5b71a01d09edb6f0345a637c68744aff1a66fa1196a7de2379ba688f990c89d5c98471205bc9cac8f94448707afc83fb6f265cf01401658c56fb4f810ae2dcb159eddc9ef07c795efcdf94de0746e9c89515ef86c5766f6619571838076158f5c3981ace8a2be7df831c4bf159801789cd2d96d1d0a8176b541a1d38188cb592ed9679130d294a66c44757e3b977a91404f8ba5cc46bbb9314333b34a9cbeaa78dd87e9d89cc783364f79f18324579a0906fd51ff96ac3cb345e4c693d2166751703ab650fa13ce80dcdad512baa6426c37d1602146394b6ea368a2bf8eae5d17074c86a9926c95e7e69fa93b348d430a79a8fa831b04cceca6837e43bc46ea7874671976814e07a14315435848c84d7d29f77bb1d586ab201d3576716b3d2d2666aca9816f686f3e09b5b297a2221592685152b4deda63d29971d1efbe93bee95658f6465258fed46b00e4245d91f490d43083e669bdc04f2edd81bcc37ef7d520f3dbd971e112462b07059a61518d51605ef2c672429d7b366a37b20504817d113de7a8f4316281363d2be5249051c1274da834a9ac8ec1a1580c56100a3a564dad0d6b6b2b0731f7836239e65b53089ae1fdc8288d2c72d42d12fc984b7110b7f3eac380c4a5e4ed884cc4e6eb23f08e6d7e55714d3a7812f6924896704f40edfa13b001e839389ed11a88107c2183a1166550760d09a5ae9b2653a1d80bfd8c303361d32bdb64c326252c003fe7ffccad9c75266645c5751fdaaf0b0b52acd85d519f1e217f7f472f9476b0d1851bea3cfb083041ec36708085e56135aaf1d208dc318d57e1c43dc2046a30e8e34271aa259c10435c32d39032321d271bb278767f347bdd0508131aabb79400e8fc7b6f62402c83967747dc3aec9b6c5bc470cc40d732b6524cd0e526f391b7fe8dbd4b2b17f21daf9d500ee335b64519d04aaf438a410c89b9d4aab515fdcc3aa98d5c0930cfca6fdf8cdde66736de2395308bbce5e4f01a3b0ec2e9c75b7ed785ef20aa6d777bae692f8acf06091835dd41186b350048109960f346b10866c22bb6df7b078dbdf2c7dcf1c30c8db1d45d8b070ec6de13996cb70ec5a1e253b2dffbfd77ece34f6e0e4bc487655ac1e3935ce4fba41908709eb1ad2831f5f1c4267abb4a690e10f0e982ca31217610265cfd4e6d9e831072891c5bf03da45ce877bf4c4dca4902f32d470f39173c6c8783c89fa7f8f75e0507389003b20ebacb39411f9a2ac5f53b0f057c07aa21c21bb381597e87f41c5e563c9b129183e3d0a7c7c9b1274aa9747e1ebb89af94122b5bc487744579f9aee5e91536161bf58728c4c0186e4bd1d05b955cfd80c9051bcbd046d00a6424b09ecc73357a99f2942aea26ceda9e2b878ab6e064dcf0b64391b0ede272c0f4b647f69fbbb3bcf2830dbc0546ebdd621250fdc8badc93b12d7d0554b5529bede366c1ef8e88c98e95d55c03b015a82558d717a65daf65b7f386ff53579ef7bd4c83819e21d4538bc8199357172345738c5e79ba421d695f013b73e95eb1d602660db19bcea10fd1c29cb26ae7a64cd809b6a43aa013aa17ce5798582a11a9c860d9936546fbad4d1c923b71e3444c31f64756dd882ec753aba9b949a7451fb839dc5a13e0cf58c5efd6e589977ccb6b4e24ca1dda0d1a04aafea778f70b81131853b1e3979e4ca7e0931ac5ec3de092798ba2e34734237be04cdd3e3fa7e8f863da40b6c611839ef227e705a1dd4d73b7ced10d8bf8fa47a27bb64ebd9a000c18b0158107fcc7a2a7543f4758bdaa492dfcf9758709c00fb9bceae7b43f2b2f6d6b3b7ff8341f2874e0b51dd02b10345add34b640dcda4b85f41baf462b275e924c4b144d86173f7708e152d1cfbbbc3bcd34c11b0836ce41bfe6c9e4586c07be50dff9a9abaf98868f1c1488674b04e654a422e890cbad9573f0b410d3d5645453c2f9957fbaf454c11969eb1642cdf55a02f6ecfeb508e0192c0fd85cd1785ebc1f87a1b04229f534ed6e2e209614791662fa623ba52bbe7e93057d8d36ef0f0a25f7e5715e86ef831da3145eab27fa4fb730e5950c7e66205b58b633b50953bf0f537e6a049f8c02acebd627481d66fad6be2d1c19132937c0cf102d86f47faeca5dd412f566574d5b8a1fcc0962c9340c87d2cc566fb1d5ed68e6d0249de72046fa3b595030109be6757851cceb74f9dda28dd340355b4d94c22c0ba9654eb0b670ee8568ea2662414ee49030e324dc6cefdf3f3483c0cdf21416424fa96b991eda1c1d71163c7910d390f1a08e49e1f6121faf155de1c23aabcdf83b96cea9f8dcbe42611e7795bb77840f10d52544ef0a92efc44fca3f37717d235add630251bab95bb7a8cf89a797f74cb01c2a92212d55beb3e87550a8a3af5ad9e55df1d8e6f8e545c2b56d604b96a39e2f39f7eb262181a75658cb3fdaea4f97b0316bd6713e560cfc62154819262c756ad80ae1e2efae835cd56e2c85928bbecd3f96f8f37a6ab1bfb6057649aceda08dea39b36af996f34ba717d946dc647a1e4c11e62e73053dafac6afb4c90e8ea7a243770c9b995b181eddfa7409d199ed9998c23314eb0906580107a30a40250be1451fd87510223a092cbbb84de97f8fd40b1ff22221e80cd287dc4bc1099cce194a43390323d16a25de66153bb4fe4b9b5e50ee881a1970bc6a9ca056cff8115abee67fca5408cddc3cde60983426f13b69fea4d6b8f515785226b6f40a6577fc7398b33da693e80534597b63639ed3d8e33592b9fc33acb8ff47eefea9aea2e2139aeb9091703ac7a0cd8737a10cd3f4e6eff813c2a351b585d4b1765faf7a5d9f0d2cb8f031719e86b534d13e173e7bfe1d2bb9d2c014fe982b14ca231ae4fcca9c93bc10d2ebc8a894a431bcd1d803a66dc9cd90847fd7d6c6760937e6c93727f85d4c3bdcdb277ecc7ffbc8326e2b43cc2d94f2140bfd7bbafc3671636f08ac266d1b798e7f259e1687cf6637e10bfdc8d85fb591cdc398b59a1077340f9a1a0430baff2c90dc78b5a1c05a708cf6f6eda99bd3825437533fab11070480272036ff011f776125cf4695be1cb3fe7d53c10ffda959b9f5fbeaa8b9190b94b2a489cc60d3d0574bb18365b62454f9cc6f42c7f1d6ebdd3fcc35e7b81446202673bbc84fc5c4b96956a297b64836ab08df72608b2ee789e342a70304c08ac293a9487140f491032eac9c6a40062b9f5220a79d0e6053e947988eaf62b46a3a5086c611fc6852bdd5341a09e0f5a3bb2c4134875fe845b0ca869331bc340777c75349b8598e1bb06f8cac7c7916a5b38e1e03fbc25cfecc63f08a5137e3c9354f35c81be2bc26ca692be6c2a5649b436a49f4e04c3cc2f01607fc63466c1bace4e65a4d408e18ceee080581870ed5d474ff8aff557ac22b27024d927369b04712989cb3190fd630a12b333d740e08247369727fef43e6631edd9fa58b66b148fded6a1e172a1dbef52627d9392a5b3c3b97df0de3d721d7b30b99f09a05a6546bd4bca96fc7e56696e02022bcbb92c4469d00ed5e204f2fc68ddd7bca322f7d92f88b5c67885902b22d81645fd976fa1e27165d37b062e86e7f4337d6938e291efe339ab076c47c619d48ef469535c100676144013763af9b2237bbaa012141f81d4182c5c430183ca75b50882f8e1c78973d77da740017dc4fa296aacba111866a2adf04a4a8dcf62d38723ab154f0066176eb06056d87410e717a517e40f7ce5ed5fe0a64b5025d7106d14a3366ba86a158d9d65d543c1c60a57eec924ef339c6e09deecab212526237664a6e27559305ffc3890d9d9b2ac4fc73a1de3e9800f9ebe6c4e38b18f85b57ddf47e053f77462da78d7fe168981528a6117f9f76a9e59390a6ea73d54e083da836fb1cda8de55080ee8523ef2c6c7b96ebf861bb7be2d9f5d9d38806f143aff78631c884be9368ecca492bdf571793ed8efed1826f14c1975e95b7414fa3c70981c3c5716b6adf226a64493947e11f1368529b2617098851100a6997e2faf233b2cd2773209efb6a010048b0bb99eea5f9cbf9293c1d855896f43156620510c7c24eadfb407edf8059c5b727057a9271625d0d610139ce223e9b0064de9e78f1c6c1e97c8ea5dcf62420c5a0ce475bff32e0c1d091eaddd949f48369d3b5b58b9f2218402f80777a3cefc89f2ef66a5004f26d9bf1723f038402a034697bc4b2414cdf3d0744c5b2a86085ef25a846ea65600c39e1af91a24c16ca10c9377e09cd473590a651a35dc8b0d5673c8589496a5028b31f56a8c7bf08587eb6748dd9cccebd2d961937dc4f7de89ad1067cbafc3fd0f8946fcd2bc6f6d91ce31819678613cf3d011598be3649ba994fc18f407c75f6b0c7a6498bec3f1a9c32b2370542f96c26d4c5cdf4114c4419dce9a3bdcf886d824932aae5cd0f06e56ba01cf9dbe6bffc794669dd1b1400870a2bedfe334a9aab4040f3f375a0497ce6b6565b5dc6cd2c3b2bdd2ff19e58cd5b2e173f9758accaabd1f42dd13376a9152ab518bbf5a06749ddf8f031da8324d680a78c958229b49c5790df3cdb1d79d0367ecaa2b3e7fbca4463b94d0ada1992a049a7f71eba745cdc37954eaf2335414b413e75817190ec37c33e9033f4df55bc8a9e9687c1ec3577aa49233caf6c3aa78da987553a49ee6719ec2dd1308927c82bbb7e5f57c644b390699b07ae72b6d131bedda731fae67a11b4c923ebec4cf7f0915835468d6106cce0a077151df88e97fe0a68a0c4d7fe8f2bc20af431c02b5ce763b82d981cace05ae92783b60b059f4c671dce60c4374cb10a00975cea4dc3ab52d3cceeea1729016f8cc95e959d8a1d2f138978166106bbfa6e8a11a0874fd8da05a6fbdf4fb0b2c4dce8a13ededf027e4c177dff7d778def1e36540ece45d0550ec642fc14ac453a31c1f0e55c01203570d6d1aca0ebdf74e3f66355b4561e429703f0d4f955bbe43c59617a63e2618dfad5508484fd79d6a236c0e978aeebf4f695c3fc5f9ec958e84f51942b5cd222fa7812da2befe811d3b4a4c043204c1fcdc2b06fb3f7bc346cd289c8206b5db69840c79e9aecf6f823b83aea6fd9800cbfe0b9d57518e4d9f98f1a9e5d830ad47ce5fa8ab5daf053b3508d1e36275628b137ed468d2e0ad9787d9c79e70132bcd5166adc4abd1060785c79a13e2273e8ec4d9cc725990ab601afa04aa0b3cf54e4d552d18e6792984cb1e59d99685340f972c0e78d0348f246c82ec79be686cc089e0cd264ad7527b123c662812f7f127b7e18b4b18fe20def4dc2265b52f30d96a5061040104241e45e15b95f7e80b50d14af012155a240bdacd78eb04866a8df3842fb9ffc59bec5392d0c9c4bba55b0f56cf871147b287b3c0da5eaf3129083866839f1ddb26874cd77a1c69072b12e710f13f9780a9cc5fc2512cf1eaf50b47a07b011ca9c8980abdfb6512da7a0f29d75a54f05544a245c6b68a565bf484363c56c9389a79f697d7c5f5fae314330809c7194bfd177072ac4f631a689d1b0b2e55f8c5f3e1f1fcc51c01a1313d4aa646bfec39c75a6fb320a17108ca06022632c67164b0b07b32dc65b6ab459b4a1f642dd8f45bc59cce644d60436a61fbecc2bff4a86fdc06ee34f2b74761529bc329eaca332831394bf28e011cd21ce4cb2369571995dfa8ffcaf1091c03d6939f9f6ff6b4195679e49cb3ecaef40f24708f3e9510e5db6611b2506b0ce412d0c86d46ccb33aa1649c50eef2869fd3e9b84df6441eba4584e72fa0ba62c1a15183a32b256656f1fc3bcafef5baf9e6cf29c5588c90bea54004e7a370a7717263f17150fe58a92ee285eac5b4d062d7fa8ee972ec4027412a7d85c08b8aca06409b23959d2f7fa3d50dc00f103abd8fb8e1a68090c9a117723599fe0a938db5520b5a0daebc0bb2d2ac094e52a299f709d08e55dbfa6fcab89ece53cb5d6c67c3103ce1326f5162c2976c940d6857341fbfb9480f186d795af6ccce11aabe7fc2fc5586f975f608815a6571a36237e2137a7d5502e3c24537eeb21c344569d84e71ecf62f6c9233a426bd4582dc9dd407e82a2e9577303da821cb86ac28f6818cb4a9718c2574b7c9388d149fb3147e8f70ddceb5873c91e70088326dce0ad2d30230470d765ef74ef1f15905d075bc4be73b5242420ab904b2a0a17763a81ccbb5c8ade007a26cb5bde4ad6f4c07fcfea510c74939cb39feabe4f901161fc744a72dd2f4c9b750d172fe2f698cb1483366926597d2242fc367d450d63636f0f079d4c217931f6f69ecb332212ed68d0a716130bad1c7289ccdba8fab8485ecad965723c161db8d581462c0b93a7def283a1c87bc68330eb70b2d14dad722d06e60df9974b7444732acc7f7ba4fb75953d9e7435177ce7288e00a908ca22044e8ae94ba37d5f86effb1cd7fc9a681db60bd65a5130ed9a12b3c3d252ca20cd07ee0cb7d1d22b412da6fc77cd808870de308a37ea94535e0e5298b65b7d310e33acd81a72f395ef6e157decaaf6bd236df8095bc5db2d3e22258cf3ca157928e852dbf8c072bf6b68c3ec07696f130318fc4a9ce5ba7819c7122e54589e51a40a1395c635c58447d4e47ab4848bcaac939e0f1298c22374f79b5be04840483025a21915e100029e0f1c30eb1f96b48902c57793c43f6d3259aad0a630fb55570a9d71ec983e1208abf76d86265077d6b78f6a3468204784feab746d9008d78e3adb95e6a368c1ae45d66634a7fa70ea6d0c91903258e838414797585b834d4cd50573211d7fe1eb24de59b89bce860355fd444457e2e508c51b7781aadf24d649188678c8c0f0b7ef18aef5ab2c4a495ae9e3e3069b4bfef3df2ecb9333e3e8cc88b1fa125f8599c6402e4b1f307eb6438aabf0ea87920ced6dfefabae998f43a74d6b980f1a88a14012e229b0252df65ea76760331cf1054582072ef16321b609511952750819cde0e3ad6af9839999371ff19cb7160c036d5a3fbcfed5036172ecd811141376ead739354119c7ef9bb55f8f49828ab6efa890ce43f1dd744851c0e77ee80e9e4b9db0e0d644c1cda63b03469232db25390bed1eb996568281b71444da72471c7922700d7aa170a66960ff25ecbff5e4a30953296f2af3a8e9aad694e746df58f9c7f9ef978a95ad3b0cd876f55d7f3bc19a266a4dcb01e8966b582791a3a37615efa87703e54b62f56bac7dcc7753402881f6d31f3041a6b4af6bb7f05fb6cecd1a9a437f8cabce2dd30dd1cb2f1395be0cfc8e93a443aee165321232d25f37444da2c167ae670916adacf8a97797a3116156726fac6c7455485cb7adea5d390173441dc2d506e71ba6f365fcb1516a805c925473981cb9987123829d8d53cb6ff5efd232033573af1311c07195555e6139fe602a69f2c149e4c8654c4e914c8e5ea869c7c3573ac6eef65dcd119afa35030aa961670c10fd3e89d61a42a36810986c753647e7ca1a90936418df0d17efad561814ab03fea4c2275e737292effdbacaecc3ab95638b4132f49ed02c9ad297926003dd971ead110704f475888b407ab1921400bbb881143b7d949510c5adb1f09608479ea8bb010c28f0f3aef1966a641db852e6579c9529dccc76c59796da0905cc2d5251687e7275b39461596216591728d5e56556dd5c793b17cd9b209cfe71c6e786153e49a2690d6f29fb0416ff04152bc93d8daab0342f4ea66efcb6eb65947bccc94e580c0d79831c379b0a0c904ff4d0cc3cdeae1e2d96f6f415dc2a0dee38ce7e3296f24757583787d74fc71d51bd7bf80413f635853786bd900520246a8957cd31f494be7b3e8865fcec6138f751066e952b5df33686bb341a9892664d57dd0d24e666df7f9349457a6427d9c7e58ea5b98f01fd8e6b2b01b44d36245e9b62658fee640040f18a1435a9c4e0878928e9d6d950d00f801c35d1eff01773dda66d4c55e3e9d13c6375fe19eb02f5135502811bee9211113877998e5a50ac30623ea9e851cdc0b0a1d2e421745ed283fbf573669692e74ef0d325e23f1c43e054d784ffbfdb8c9b78a3d133c636bde73f6d4da813d6057f241193644cdffe41635e25167a3e06f1c32fe20aa4785a9d177e97071e4aa5fffb5d01923a6516beed2523954d9c5bea73bed10af2117187b3c0ad144cd36788343d6eaf1f87ab95eede442e52e1ea8290c6b3a07b5ec744e7c9f48585565e6708cda3d18994a8bdfc58e8e9a60ccca78c69e26b78313a1eea750c5c007e3e5a36ce3a64388b334d142559b616af7f81996aa1146ec012d64cab4d0d35c1ac5e93efd1382c5cb6a831bf37e20842a624747e575c71dd91c840c68ac7dc063e0025206e99cbf2465cf4314e1c92fa0e0e6bd0dc034a76ec1de6f32ad1f98dcf4cae30b20d3a4e99e01993f3473ca0a680eab56200c6a5da4b009e1449733f37436dc9f0cc2432d325c56650fa294746b41188080ab432b83be41d12985c0fc76441be5dbaafc8adcbffbd7dcf30e8d4951e946b5fea0c97891821d1ff87bda1895d96a504fbd345397ce8746bb1da3ab52de6c4be1569befd2a9a74291f6a5a4103d7cfd418b24c9f4f6890c6ab3177bc8d3a8eea55eb3f7f9ba705341a9b716b97b21fd8c4f4c0dca5a900e559bed24f8d8dcdfed311753bc50ca25e1c319fc5dd565da5d0e41fa5a02c20cfe05ae378f8374a0ec007e5d4f2b39115b91bec76a65b55529b794d0ee8ca6ab6abbdcb08d3d3a19c13820ad2dbd1bd54d3dd225a2978f5ca11a6646edfa7d0554160c7bbf88fdebe02313f91e410adfb149bd1a05e4732cd9020996ccac3fba2c9ef851799cb23f2aafa90a801f728273b04da5e5bcb303c577718262c11006cd4c2d99aeb590e19c49876d348409cf5c7874638b95cbd411bb528d3568582050d1eb0f6c2aa66af3b59c6fe68fc63fab8783e3d1a3b6e56f65ff99a6001e1e23c1d8cd3132efede743ffdb5772d326920b84c8b3b6874136cd394176431711fd90f6efdd24effdb966e9f68da4b63fc24799b70fca2e5472b63cbd198482d91fcf5b4d30cebee1c4bd0f130828e6d1298c27b9d4d41bb9e4aa8c9210b82b03db28771535d8fe8667f41936758ede31b6cfb7689f08892cc8e04f4fc518a4ec006dc49f9f901c3cdcd1436056c0cc8123b533786b990c2dfb170bdd9b68769315fd4994d9d9a98100dcba1e282cdddd30312ab4c522061f3e7ce500744c46b203a54edadeb8a61aec3174065a008f4ab2d2687f6e59f079138b0f59af1ca51138b67dc83553295eb3c295a16647c49b0a88294f0766460ad3be1f63e838c32d9469dedd84b82b2e77a88c3e52a6ad15307b58fe26934fd5143e5107fb876e9e2781718b9d01505b65bcf052665d6c5af7caa1e9cd23978ed822b9bd425e7847f9da29e247ea804b3ba3d05d16ac0f330e7c88d7c8b937022c309a491ed29b15626f464a17404f507478cf23c7f408105ba9311c044bae317d5774263aabb7f3d6b89450f8e3b53204c08e887316f9dc98d0fee7180018e6ca4af7c979996a4a58b27071d670250f7b24854537a481190a1db4f9abc6e6d187b36307f7116d9f6e53d23b618a8a9a6836a975fa5543e62bd3599eefa154c8f77dba2fda8ce62e2319ad5ac97d92ed33e90a8f6b5869ddeddd05ae175f964ef888042776941a54de5c335567ead61ff1b2952f22517656ccd3880c2895e6ccb7bca9f6930d012f20c6394a9e6d7e0a365f7bbe8fcd514c692f2a030e64903b5c619356b2d9751c301d8447c994bd9103282ca62af9a609c5698ec9da3fee41ea8c8f41abe4cbd8c13d31a9b2a5de47326b9eb9d57e1126448b368e3d08c7326668aa9f3246a65e6f3e3fdaaa7c18e5882a88ed13e5d6601b5ee8cc4f2f37c41a25bbbceb54c55bf1f657ce1239a41a785d5918ff38cb2fdebf12b0f3d30c884cb4136d2f04e12f01a85708cd3099f9f8f34035c7901dfb7023c04778dd1d1b32b87bcfbeba554a626f94299467c1abb98eca55061671bc23618790f4b62044a60080e00d9564f359eb9673c04c3d28b530a86476306473fa008813e1a67ad20bce00620ea763676fd25b4d9e1b8cf4bd5778fc040329be4364384423c35728603be2137ec57910c3df59577f13d5adde2f7a1efa333a39106c7cc5245f0477d8a58117e47e02e455f6876ab00166e28ee6eea6e22e5015c48e202e04471b65a407ba0f4b4b52ae7e2283197a90978e011ec8a6eef82803e4a62dcbb1d8b1b54cba26f7d9ed8158900f31c14b3d5e9b8d3c5790eb7c479ac4c7a7c7b78b260810e990507fa649e2bfe452e7d1ee1609e093c419f2ba6b45c75cd208ee1128a927ddd06cf06bdcf9a28c59b4b16a9ea39a715d6c1d8992809874c8aee43a04e2442d0c4a974b2ef813ff7c53c0f747988f9206bc94b611f5a466481228ef8435965eef831c7d600f7a854d7ce3f6e54ab1c621f16646aa21a570512033dcd6371687b23e473ff3c42b7d75e836da5762c56307a6a1ab2677d1e5d00f0c80540de7bac7573b4bbd2510608aec8ac23ca4f5305ecc8d546b2d83ac3cfcf8a675fc17ec90ec45c7b918484abf2064f8a99408921b11c13a96a3c6aef071d7bd44eefcdef295aed5de0f22135b1dd4e5193375792f53cdab64542de8111ebd6d82f2f36992598f1b9d258458c25e56101a1ac9394e75cb1a5309bf7f3608192f0aa2b3f1428836b00f4063a47d8a8901ae5b4c634b1cbc271073a4880d3bbd9228f10f6f71f8bf5c0c5a5c341c25ccef3b211541fc7a3d3595ee5ce297f2c30d0da8e001b7c1a8494174e543a0a7b8c3a42b33f9f0de69a3a3616ed15c6596f33141a4f5640fd2c8088edeec2716680dc91b09b9cee351e4fb915abe9a62d9a64cabfbedd7262eda32ba9dfc0b24030ef6e5865940f171b23f9028dd393774b3716afd3c97eb9e3a07ddf6811df7cc0d11a4c6e612528e3181b9e6467aede82ff0cd52944acee1ba97bb12707284e8be2337af29d02a668efb063549740d043cdadf18820576818110483a73e06190236c1b721e5d5f99ef10b44512f52909b24ce53092c0fb8f881145da77e34e683194fd3094372b76ab34b4ad1601dd9cc57053367563533265bcce9cb43e4bf2060c3574139ee7048a9e322350406598dbea41a5a20e65e2b90349d300e5df1775826597390425c7989e50ca6668c740003463380c01d9f0a72aaa84c1c9c1be68bc25f303f6a14905c0207abf700e05637dd7fa319235dee606fd07bdb788857bfb691377e203afd9b8e26250c1ab469a06c3cf22c6dae4670f1b9395036f2c29a2dbc021a6b1e1c0d91e790767eb033426e0f7da8e35c49793968eb4d4d7b3ee7e88696be575aa7896d783eaeb2bf840c27f2d6fa840b8bc2af0e8b6d74e7fe282f51360c938012cdea587d9304a71a5bb90bb64ffb1de1166575e3b3420ec8b59d3e0a2e9a639dee8bd0ced68dde9bd8519b196815cd945ac9e92d097ca21b8808e4e6d1d221eef07baa03f555d66e3a6b68425272ff8361f87deeec2bf1716e51fc62992109b8060efe45e12282f8284d07c53b305e774c8386be0f575d1e8389fe88fbdb7f584fba20da814770af4414b0b6b7971fd665ffd703ec0fb5890843ac306b0fc30c8e32fc7e6ceea9a4da3f594e447aecd2de1e369bc0ca16461a6e43e6316c3899643471228621e08035c531ad272fcd8ca5e6190b2a290a7423dcc8f847596a14e8be218cc68cae340cb7369d63cd5cb904922063575c5efd2822abde6472efa5306d70203049f53b10707910b43721771b80ccfa4b6b493bb6c41a4b3ed67d925bd74f7789b80612bfb4fd31b27e7c5d71567581f5c9a6efe0ee89033a4993b8b0dc32c1aeb0602c4009ac8487b68676a0e9a730c14ebbbe29692ab97fac83aea41fc8a9ba05f7b29dbc20d281ad1c58c30f77f8dbe9eff07e9633c7c2ea7d01d86ca9f4778dc6141c8b4ba3c1db51b5371cd8d0ae6959247d0013520742d46f4f8d802b14c17b56faa9057b36319b2e94703773bc7749d27c3db244be8ff24e5d40b71abb511bdd9698b661bbdbbb2159383471ea21fe76f1eae7faed73d2250485db1c7abe78f84f9e4e0499392997224f20fa83d3742596c9890ecaa81c506eac8b7a300534043aece6c1a551f1fc88fe96796baac0d40558bd00327894090865584051b5a7b9e0388da0c224b9b091fcc33728a3f465cb26909e974b7cadc6784e5a5fc74f4a57eea274251347c908b0e917eb27921bb3627cb671d79906626439e081cdf9a6547c2a5f311b3742d1f0f5d37833e5c18e5f581cf00bbf98184cfb92e09268e5a7777eab2a903eab002d8ce8b6712431d747962a8ac1701650e036db6c854e3e031bd293d828752c1e05522706d61b8a3226e6bb6ab369c3d4f083bd32791cb0f3c59b0d31df9a88c05ea135bedd572b3d8e4ca943f15f502b6025ce69801c45948c35045627e2e4eff6ed28e3c8b3d460b6eb1526318d226a2c1bb80d59c6c2569e9ccc5865360bd20369d722ae3148d279423fbc60126e106555ed9043cf910bd7e97d256a715028973c510ab3641281d9d94e5fd82e9b6dbf3e82625c9408fe507398b6e8ccf52dc6f857aa8cfa41d7f7bb9a0df21a2e77e7cd58ff66a3a03376152cc0ff8f3600319e414a980aa1db742896b5399f37f61f672e28553ee873322b5ed3004de2433062b625309ea6e023bc92044f92cee2fd2d50a530a948bc2bbec00c2d906903f66c78504dad996fe03b54d1efd4f9ca7c942acf7370a45a86cda22791ff386ad03b9fd6971c34d7d7e5975b2381e094ea230f28730fe4d5feced52e7fd5a5fdca8cd6ed0ecaa23ff3e5974977633be920bb408a594f5c7ca35f34565fd94a2341a70daa1c6f07f8590fc41a2233e849b1d4650ba4ad241708809fb22c146ec01273e0ada7920fd2c87934c644e9323f5ffc7ac88b6277493cd1d53e6977416fd7c7d44ea28a39045792c13cbdf4a1f5eb91bc1185356c3be8b59d93f2f2d7e8b58d1c82ad0e38a6d089b5a2d1056dea2e40166f48de4d47aa4cc1525e0983e17519e4d3de2492254c689931a9bef53283ee3f097640625c79fadedb3668278c873246c407b202a52f26304db124648d922bca06de0dedc260c72b477623b8e14f08a829461dbc58e12a92acad013bcd96f81906cf7acdb93ef06a67a277527262d1114ef78430c7fc77c208c7245801cb7900f534aa3a396d8f5d7f18bc04d80048dcff8489a988124c66934c51c37f1a491d93edd1059bae914c4b50b4abaafabc4f6880a7c0bbd7bb4da1a6fae30b6e4219d50450efc8891185f3830d19e5f93fcb46736e4fc500fcd918e471ecb7699829cf51bb405a16b39feedee1bdd18f69b3fe238d2b00b572860b5405e776137c6c5ebc0c723a192507ead95ecc572154204397f1cfc3316617f971416ec76deeaee16386b96798e190be0503e7f8c52e70896fa718088f08e3ce695514824b138da59178cd78aa52de692af0f25d2b67d598b07653f4808baa93963c45a883a361a37f077492d7ecb0d9073821414013a587158a1b109300d376c86e5355f047c3f2402e5c59b6a8f3ca31438fc336d6a5bf7ac8efbaa6f0ca59daf5caf092b3af104cd429dd670176b83718619acbfba9330322cf1930b8e4d97122964c638701d787364d5047ad0a12d84e6006c778f865ab18869c1c521e794d9156bb92a4c56e8ca288fe05e5ba858970200abd1e715b683e093400116f5c17a00c10f9b7bb4e130845cbed1d30ec9515baf03349123a3b2aef48a500da8abfe87220fd66428bb0108404f570b373b699f646b428f8096468f1c7b08e5a68c8074086140eba73c0ba62997cfa5bf258879541420f00854facdf33dd7e36db592c89dca160e8d6a37a128a530878e20ac6dfdce6493cfa4790ed196508a2b91cf8ad404a05f0d69b6a25876d3eb396f3d6b93160551c229ce792ad81e1527f9c45264355b892ddefd9310dd8da2f549fa3315d25c74a8c0a28035148619f714c5b4bff7525bed2b3a397c9b860f0161b91b70dfa8c57292c742cb2fbc87468e67fc991b93daf34a91518490fc7d144b030528b0899f11f426e77a7fa7687ef9afc4382a820c7f1c771aa873176bc7a73929b0814a83c32c71d419cb3babede01d88a050b6d8052d75edd77f0b050b808b51c1b2213275aa4dd7149989026c9f547f0e5cff3a94a164eb8cf9020b1d6264fc86c31f7c4e21953c11c4a019a255d4afe9df0756cd8bb6d94d401d5bb8357da6f716b0ff51d62e083e2c816f100791aee57926a4fbaa229fe7f0866e69b0f2870ecfb8fa8225fdfc92de49613c72546afbd40d532fe5958ffc9895f77609451d9ce45cd9d47d48cbac8bfa88857376043b33ca8f49236519cea36061cd8efa4a1015913ce66f44ae9fd6320dcdab36f412c14f20d1183d82586af183d177df3aeddffc77aab61f2a8f23163d468f284d1bdc890cf7aecd696d96b403a4f8ccde45c4ef10e0f25d6353fb88d22f2ead854629a22913c387909e53e1932e176b781c460883a1cb3b4a73aec92466d8d135fa4bc7ec69292f577ab441cb32b3b407420456161a96abf7e34e38884dd3deb9c2ee0bf9364b81f7feea32c9099aa7f2fb0d4fc76ff4c89fa2f0aaed2266b4ca0d80cbf4a0c7787f92e9f9c67b8794b23c16ab5023a7b1d242d9fab69c8e1e7a4ac00b4aa3a7f1df19628d6979628b6733efdc18289627d38c4b8fb619a5c7a356dcc8e5ee128748f095f3b8901861aeb523346c099341f45cee48734197a1fb28d47a23be2dc357bc1c5ea9323b05660acb6118b37ad8aad347f9d642611f65e9f264e4534212a9da42177a75784087dab431c87630fde4d5acea35246de0bcd3bd8128eb60cfbe655905a29e83052e1e810df04981789e99b65a08abb0d8e4aa70093b8958352c3d28bc51001468655d7f518a9b467bd9924553296317cc25572f9275b5acb9abcbefdd85d20c5826d540dc726485a9e928f127e5cbef59bf394dd0df154c054344235d39131354941125050379f6f79e83304453c7dde5d21df5256dffa98114c08cd36d9448e0c8f7f41306131c434a4c85ca45bdff67c6be98c39c63176cacd17bbf6647ba1980049376175c60cc9de020e18aa9a4f33857dba4b715663d9f029a086338a27a33667b6160be9abd16a23def836eff78f3d00b18fb1eb77561af8088d4344c7b11687e0e6f1b5891421b85e8d86169c2ee0e957c9918691115007ead7ed2247e2dadc841b46a1793bdf025c54f2eb64f2ffc0f3cab03625ecf448a325936423e08709822b6de60105d01399f0ac6d472cada6d7a76de297995f7cf762d3d2681729821ba69b8da282511a99edcf20a8f0fabab5921d1207bfbe3d3f29d5d6b411abe1ea938f01c548e3bb21f06324ffadc841d05c7b800d627054e42e4de3b67aeaaaeff2ccb9c41aa0d9c0a0e1b69031236f6abd7d7f63edb32568b8f69ed6c238e0e952f3838ff741ec04d14c4dc3dfa7f1efda12c1142f06304d4e5a40e1a5a7f2a4e1054e92336bbe8f807d6eff1de143b782c5ad9be8a772f5dbf55d6f685f0e144a42e18fc97b23e354923e448c4a5aad9f4c79b6b0a25ed202770b5e9ee11d745e866cd0d0270599e7489953e17b01656f42a22b8007c64af5c3785bc1dda998843c43dff10d684c04a42092f248d0fffc29bc8f05dd767c07d6b5efdaa8fda81b5efb1b5286e928f8675ea47262b836b9501530dcc697b416234b1be39d15d802ca34f5f095c73c34198d8d5d37fde81d4cf9851c1ad9d2b0722f7b60198ca400ff144540a11430e600e91163cd12c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
