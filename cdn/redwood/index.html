<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4d14b393c842be1d3c26206f961d138be7d252fc1f61ca7fcc5611d01a738296417d46620690eddf3b4b85ef8072b4075953e32c355e6dd716cb833ed00aeb07cac7f8a4c413c4c563d9ccb0c569efd95e54f91de48b7a518a035b59da1ebc1f05ee2d511a388f386dc1bc3d56893028cd5d2578ba8c66be7052891276fa2a7cde62e964292709509e9608e9386312935d83706324351274ed63a6f98fab6f86829341ad33d95a4f832ba1922691ab20af82377039f053556ff75aa5bbca41c8b43d32338b51328f4c59e0f51bffa5ad4a72f7d3152671b6b098f91de2380d174a140d6d9905baf367b3b3db7a19cece1983e1193b8f4f2af395f96ac6993282793c1e6ee39c00c336ce6ad88cdcb837cc36b3add2d5a3d869ed5a10470e998d796b2092ee79e4da3c9d514a0cdddbabd6b5c7a4c6306ac0934ca445258db22ba096bbbdfea8af27ca8aa12bd72fe865efa59b43311a029b964e21e6eb38adc7e17adffa24503843dc43efb52fd64c9497f6e926f72ef0611523081c9f31533e7781379e5c195a526da37d228ec8d51020ad3a076883433cac9e86254d5dd4b9e297991d901c69f0a4f001f0bbffb9bfdb04ed6ac4d9052554677532c66038bacd8d27535e42051a88e64ab84676475d970f103e7fd992291765ade445cd461990841b9d4e1750b5d803cd511a8989f042e773b7a8a22682c625b2e47df0f9f00a2fa460e07f110d13e3d01bcda49a93b54583557d9984d0ff530e58e6b83514e616db20935c93ad5ab3ad447f07f05e11bc8e0fb3068b52e8c1a807bd10bf7a575b32f29708d04a9dc9377984adcca6cc5cbc638075ee6d56197a2d68e7a3e0d7037919869604be5a81aaefaa6889dadee0e243ea96bbf213169dc9d9b46d1a6a0e7221ff30dfe6b994b718b2e98fb7752ff6a5056710a4c5b26f850eef3aef05f7ca2d0cc7df243d35610b2db3b768b9de2e39fdcae4ff8b2f25ace6a8f60136812495755f356208d11ed6e185161eb57027726a83c402d8f9801ad5dee94bf99d94ba1eb5621f521112657503659cee8a5a1e102cf81ae9649334f2cc44d1844ef0d58444cf8cd299c6182a26f0fe9197c79dcb295e448de8fbcebfa11d1497b9367acd5353ae5cb3f43123ed9ea0ef388f52c25289695e5bfda7b07efa4db0a9124edef1ca44a5c5fa029513dd5d814cecac0f87f04f10c0efd12956b53f8511012231a9c4ebeda1c0aa5391997ed2078a8974d52dc330c40267cde8f7ecb93a496dd728eda7955816772daf2a8dae7322d19f7cf4f4143129a0cade56dcb77c73cb50dcf145949610d9882b58478c0a7424387eebec851a802d94a1e5d388280b8c81f0663482fcd62f9ea4c9e1eefa49a5a69d1dbbaaef4c98fc102b889919ccf81164412797b0c5fdf621ac17044d26d4b12891a3397683a7b49f471774b06d5832f602358a87d9771a8ae82e16611642f03ed635beb2db145bdfa0adf8331c3215b780725f908ceb66ef468a70d35808552d0ba00ddff32401f64ff4324dd799d3d9cc6fc356a2dc39e790c18bd06787031365437ce2fa2a033661c08ab884c8d1c5adb2a575bb49ba4785ffee4a30971451cff45ff29c3ee51de28d5d65a84a6281f5cd9ec0e5a860f7cd9bf7769acf930caf404395ca98853e8f9347a125929dcce83385647c351212dd98da523397c7d9f392656a3d033c338bb0d0fa11f66f90a0405ae413a670636b4ae719782be23da182316a5d424ab4a30829ae8b22f6fd9a8bf11abcee87f918d6e0f76a96f640aba3fc05884fc2d96a9f689bc30c8f60c84dc6866bb87235088b9ae0876d90db67f84fccf99e3f20eb67c465ef1cfd580e073ce0e25da67a68e2b68293a50795247df4926bb8eaf62ab19af603030b52f51f216cc89c65b225924844eb9b8c732729bba8494b0a368e339cd33163f1a9e88b37d2ee063d5e0def468026cceb99aad46154ce7f31c86ad4a05571182dda8a925fa634c748ee578b94b0214e01e4b3a0743fcab4f8de1a07b1b56e1030e47f49e0c9a834d11e2ae70a2a2e6c49d33ec58da9a1b7e1ad8c9929b639e0e4a77cf46bd58d54a3d45092217606ddc65f62b0fbaa5698db463d33529a7f492ee9bf1f6612999e9f9b11b8f2455714859210c4a46aa40f5555c30984fdd4aaed8d3befab49bf85e8bbbe3f3d4f034c5878d602c23ea6c3dd8f2f1bad5299c3c39a7a271f7b0131d89405b3987d4e5e70a53823e73e601f8a77f12fdcfde6f17c3576d2b7b853d0bcb5397ca128ebbad537835485340f8d32a1e5335f880ad45f543e079548e48745a33249e67bb3ded960f29a31e80fceab6fafac3b9cda4d1fbf13651163d1aab0c2a351a35f3910a683ac4804359b37d73e0ae4931d2ef83d6a854e2d26aace7d798bf4de9527392a72c4cce5e3c76e45136042eb07a45cc7a9e2c23d8637ea23a450adf3d8c101f6886d66d1c17874f095e062f569d592d55d9f4536da51704809e21f01556069a8f2087158d550bbabeb5b010b636203e3c19dea44583c7007fb4dbe2667c4fab2a0612fc7ed59e6b6e9cc053bbf9382e30f779bd90928c9fcbf5934fb5eef0e826bfab1393bceb3c5b9b0b25abf618b335df97d3b8e6d34b84d3eb41c0ac3a7f1569cf9a1355840b7884f98c62abe01b4fad7cc52e69efc3b861578258e8d3a8b16093f68d568192c084f44e90df0f5cdcc8c8d7342af0426615b626569afb6add4d01ad5f4a20a4c239e2251aedc83fac9b8e39a3caa4c376de1f164e0118791699c7e6b36eaf25f479d7b07bce364baa8d81149a7411e83729790fc53516bb10b37bd7e44377e410e497a33b214a070907733454bf05843168bcd3ddf84a315b8c6b7ba0e00d8a720bb308972dca419371325a7f948cbcca0609cb04f67c59599784a083419542ce81d1c34deb140f6fdf862edb95aef6196fffa4f1b3372d421b9867b89853b9aef55a333bb6632027e4a721b9a1a24dc75872fdee3e35ced5faa1703851f302c32b01f09cad560fa01e758adcfc32df4589991c2b7fa31f979269af26a4a7a673153dadd4d426b0b9a6d8d937420d346ea5fd2776ef14a1e1684037460f76a4fb39a3ae953d37cad21a53fac96213f59847ba5c15f01851bb178562094a7ab8798490dc5bbb4dd4e5b7efdd1dc405fceb3d1b1c2aa78bef2c6ae5d2314d06eede20962e97e204981d9a3d74813e25f38bad4b75c4564bdf1c7d1f6016a51fa22fa532ecdbb9936a63bb48a35cde6fdffe971af52eb125663dc3bdfc1bd375ab9808bb8d214c4c3362ccb08aaa1d82db219bd920be50b93effaeff44c785a4b899d5fbaa5054b9f3b17f6ddd077eebdb98162a8e7807b3c564755b0f2a13c0ffad0959e6a31afe110eae6118e767a009aace72de046dbee206a42a041375ad18bbefba89bd6b50997fbdc8e58b5e19957e20623ef9b517aaa8f25ad0c92a6c390c880ee20264f8274c769ce5210f5e6e6164eebde5cec776531c3c5c09ba8dd2ae96188ebb21ebd0f0114aeb332894819976ae11334695f3096a20991b3ff54e26ffcf0a157fa8cbad308f46329dcf74237ddda0c3932d2e207ea117bcc035d6e0ff87081029a2a5abf3c00373ee3a471c1611313b093ea0c39e5d6169850861eba7ed0c0219b01764a522b47d87144f961c666d66eee7780263ad84b66494cd13f60eb5e3d8d4246c3d4599dd4a445390c8c0b2d89c7685345c7ed7688490411454fbf0e2c99e715a8f2dd635e768a1b4b1aef4b144c4a9a82504402c80824de0c5a0b820f7e1daa97c20bc2f2da09d6168ca3af05662da38cfe2826bc4cdb4120e9b6cd49509875dc9ea6d08ed2a96c3d18c238867cebb3c7c17c8b157e8b6d5fe9c055313c2f728a8415a5c3cb5cd5a7735938a8bf83ce9b2b96736c1a1dc646d76470107343ad8bbc9d1b5ba68ada334ab87db114139b4df04779f60f5866eb8d2d8cbc25df11f1e48a33b9e3dbb35325e3e9f7ddff464fc4a12beb63129e35f7a9f49b6b0bce9b74e09a2907f0460f1138bec3f1e520bfc8dd5ad8ea4886efef5b47ec8675ffe800e4b3810f7290e4b94009dbbd1d910939688a990365f155d99596ab367661b4e685a4e08d9cf5be324ef2417d3a0bf0c6a2f52cc8717bc55c5a1beb5d3e3a25301df10cc94d321fedc039daf02a4b51b6bdeef030f80bd4fe30265e1c2c4361ed53432b3ce7fe0eb4b9ee767e47217d1addbdbab5b2bf9bcba43bb1e079f0e4f3a97c2087f5aa46d69af52c9dc4d35814cd7e05e811acd04daf0349f45c9b318d9e2aecbf95a3176ea6ed1f73414dcb65c2a113fc4faefbd6fcc523936e9c66812098aeff270bb00feafce822a3d856956b3b146cb7a9d5543529ea89337052de6c2da0906312994f0fb7f0bddc804f3f08b24b00fff6abb3193f512f21c29e09871c7f7a7dc7f0eca439ea7b09a53490dcd3caa49a40779b052ce3f39b7d67ffeee5bf1ca193bb9044dc3e40974c5e0aaa377eba6241f841c6779f91bef79fe2a3ebbe69cf855a729fcbf3fd9aa6466af80959dd8d8a6621553423487331e552e68064e89564317df8aecd7ecf3f7654c9d835b13a17346be9e3d23daca3b7b7b09501dcfca88ee2c6e0454e9219f186c9a7fdd1bdda9a0d510173f71c390496ffd0c075255e97c39687801b297132c1c01065a34f612abcee2d94dc3ea1f7d45d791aa86c3e70ef7cb87b6ff6e73b35c02673a78f79ec3b27e23187d089dfdb1fd0c5d0895575d533503976c07b55463ecba72ed0eab2efc0e89a4617cd43b4b9b960f8d8c4a79851cf54b7b94f1b20bc00b9494820d53a3a0f6a539a17bf632ceafe73ae33fa8ddb818f39e5e86d517e4e8fc5e1d49ac2f92d603f93320121114be780e2bae1e0e368a8a06722f2e4d2937c6926b8931a845495ce7405951c270cb9ff32f0862db1f440a250fdd489803267d68a9f25c167e8c679cbf6eab6d453dce45aaf193a71de8b5294ebc146b7f5e6d9d80f6c283e65c600fc6a26992045534a9735039d5a3bdd1d91475e1854a9b2a0adeba9dd86dc3c143fed7aba84bcec02cccffab92688d0d94b811788c17e883fea4911070b5684e292aea394e388b0ec7f30bb24c8c288894163b5b222680a251d23c84f16c29805365ba1d0d65304d5ed80450680936c47c5d86c87aa04e8c86f17aa256a8ddaf937fa74558c3679c80ca033a5fc1d95b219c28ebb765969df1ec94ea784761ee4ecc9465d92b608386c6b4b3a7581d236bf510ea6d942b5330864974212a5f86085137bf38fb678f95bd7fea8b5b1c57357bbe7d21fc0a64f061abf83d0dbd91ab6383db141890bb1ef8072d6c160c270c21f08e4cc9d6a577c026ee5916e97b63717cc83fbace004e14c1832fb4c3b5280892d930cd282e7e3d02cb8e69b2e0b560e272c6dcada39a7712346e32cb39a643913c670ad99c5f7fdfa1fe3d6f2da28195f3df903326e67f51582158058d02a5057664b9e4091f3fd819e96e1fe9f327f5a30bcb6149e334f01743709ec200de3b7c42da7bd59b98bde947e63b68923b6b5e21f22ea8ca3246255ff5e7d2e9c501252960d872feddb87510244a75102222e20e52be0f131fe18d4c3d502a983c3bcceb1b5484f832077e1d88c996ed6799f67f0dcfda20b0d3007ea5a951cb96d35034366c5ef35e9226706cf4431f0a69d48be562549c9bb50df5466d9f0b1f7e2d655a8884a42004eb6be485bcbb48399b62118a2d0ca104868aa6c1cdffb71bab3c351e1accb49608571aaf15d00ac929cb862fa1668fdcfda31f03a57d7ac1c14751d1123e9390281f28a0bba140269ce2f44ea976f61b9a144e5801478662495c44797baad50939d29f594da757820e8e74231cd903e0a6111c4d0408a97272f3d4710e27e25e0ac5bd0ba603e51cd84fdef1986800a6a48019ddb70c8e541e64608145944afedb3a876035fb2bf9a611c38cf655d54d0c3796037d1e977722b161197c8607c64791ed925eba8275f6e84a3103abe7e161126a4527398b3382d0639d205fe929ef9ca0eaccc4e26631f684a34d8f4725b366676a1357627f6eb0e887f9f0d9fc24796d4bd395df967d6bbd4923a4ff54976c0e7521867012c0e72ffef83a38782f6db9535147864374c3ca7d0f7152ba6df86e5508c86a163b7c389c0a982a0b99c32f78a548408a41e843f6f1371a46e49ae7e045d520e02e803ab6c11bfab73f3138d02ff34c399f60cb9045b12268799a913d088158c559af557f218860435e98f91bae190d50d038a85130c6e6546cb8c8291a61fb3af9749576b7f29384be3c0f3e8d8c675f46f015cf5b2e994236ba6cc0f975d2b4eb73d04d82dbc72980e598f686ccbb7c53e18da6b90459bd9e87acac056c59fa2b4519f63229ae0a6530963db5a1cd9f3a28670f58150a16f1345ab2a9adc5b735d33f172859782d273b5648f76de8563728b8c8531137f2d5a14cc853b4ec5009df2b7818ce49913fb8bbf5fcba4ee2b34f78bfde6c5ae2534618d9a9838b09135df0eeeae99c8384a82b870d6e8c93aed234436498f037c2429cc2684fc716d97a5b69c16ced49e20acc80ee2cbab84aded2d667e85a9522ac963a3e6e1536883f50681e1962849ba51bc3f5e9e1d7f3c3aa5be1f999180b6b870ffe9f56a0dabe3021c5900bba1d9630a6f05ef49623c0ff47a6c0f001f523aea78e267fae7a2b427b3b7ec817e91719a50224616d235746f3b69093447c4f1a76e2e730b10f32c960836ebfb60c42cb9965f4fd100eecbff4d72a3477c6cd36d88da96e8f937d552fb784d4cdbe03f62f81874c94e1b2bb8c9b70520045ef8dd09c436dc03b3eb1397faeb88e523117c2302aca465d9c223583b8ce6dc9465e16bdb76d0b733cd11a4fe6cc7130d3d5bc1006f9433f2a256b1c5b0c5c985dc43b2a3c9126220989c5e818164fe934b498e74a4b2e8d5deff8c3ec99d27df0b12b54563ca4c5e839ae45319cff740c69f3da779f117fbe062e0f359288a8f9c9b4216c92c68c7e04dc35ffd716329a1444d026a9a4c717490cce3f45d5ef0f12379be7e002f893102ec77a3765b372b803285c59a7f024432d085446aad4525b6b27f6ea705f12c8db0bb7ffae6f30484570790e53d94a3118f78c128baad897f5425117364be09bbb9267ee592f4583d425cd3287c68939c6f76adbf04e0d1d3d26fe62ead467b3c1d5dd4a6212defbf1e8a1f8986bed5cffbe08e155908d4ed778a1b7f98a8c5ab087e4d970460f75a3307866fabbd8b1901dd43d78b7c9e23f17f8b3743e0fbe8fc16f2ab9f89aa8ce5fcd0d42a7b1e954105b91b809e297975201f0448eba9ef1993b044497c75e4935215ead8154905c2ddaa2c4d9d09add9494cd90636a8dda7e2fcb1b0be8a0371a2546355c10d79c2833f2a57f314783c6de743abb3561d4b1a630482b15588a53a49521f558bfa2bd3494b2bd78327e36f41ba3b469befe81a32c779af3774f539c6183b3736c8046ecee32ff90cb42604af239d2114844c1a0255c998f10c14c55846dd5b248d93496a2de7ad184d967fc4d89462fa2710bc7cc97730fb11201a18baebe3a4e2de9dcb6c379f55a15587021e0d578d8147ed200f3db130c72b8e97d8d126781c8b8e7400cd6d058f0162f8bcac2d4cea5263ded7e631a79c03d6ac8cbbf4bf7ae5f446393333875b44fac4cb0e833f36f19d9552630f8006f4e9565cdb5075f633ce39de67cda7ee5db6969a8c62a6a6dc5597bca4ffe25022300b8b76bf35bf1ea078b75d3e6918d5610b96cf342a118c5509af2ec71f625aaf7599ff694feb5e8bda2e6c6eac7f100f994bf5f2f5b7cf00a394394a92ca9dac1ae598ee0d867bc8cd1009b4a29397a78bdb66ac59690a02b24119ca4a08e05c04a445ede5432d2aac686f4acc979a421c288f6c4151185d2d4922f16ea604d0bb835cf7ccc12ca037e79adb7a50e8b9de4718428d9ff36b63e69f7487944ce22feac83579029ee4759a8e3d1dc4974ef7ad5ab97531648a326a148300b5426d7cb31b9c468d0c6afebe42ed53f568d6a0ba268b0be8e4f9c1e21afa9f6c155aa524beb4af852ed79aa6d3dc471953bab88294c19904e9e6e3092a0d79fadbf75e552bf3c70fb02c59b094ee8672aaab2a015aebcf381776e816b5c72500ac73833a13866a56d682a87cf233139c29ef7be42dbec24c2bfd2735bf14325d4a86b499b6392c752b2f1a8481a1c755f9d5418af10e6137ce35deeadd4af6d360f094e86c8273c79f9851e51dc040c8e29ee84afd9d98d2fb3754b2e51fb8cfaeaaeb17c9b85ab8f4a74d4f1b03832deadea36abb9a8c75ad4468d122f38920ffb6368354d163c9d8a01ba79ef967a78a1a374e7e08b7f84af43593b86b5a35fa0c139cb2d56aef772a7220b79dd41fff00d93f2394aad3a7681962928cc6dde3981b1fd098d95a9c7ef79975ad6d7ea9c1411428c343f74894eac1ead1718ba44ace0e1d22a10fa8271830c1e547956f7f5d8ebef09a069958145c749e17070100eeb363c130c1e45564339a9f14caf6c592ee2c452b47fabed4606b4fd967f71c14b67b0b7431dc299605ceef95f487d81aded0a2ee57ade2df8c4f53724a7b312a472c473ec316e23bb995a0fe8a05c0788c8d2b1d34e37561c22abb04582a9abb7aa260da0e2c50b71549ffd6a2777ab9a8e0d6b56dce93dd4243060ffaf0173b560d2b519c4e36d1681c2a6d2a33397133fd31a26a7b13b78ecd05450bda388d43ebc5f92667c4bdf8d26457d3510b41df28cdafbb800d9be61f66c0293c6f5a9ae568406eb887aed6efc2735d7f365037f41a3353d54e17a536531458e359ed0887cc0b6ac1a8c5bc91df318e5751787641447068a8d94595e2e7da10bc8a3d2a1d7fed047f28a0216e8d3764ef86285d65f3028a57bbbeb770763a2df256e532219862e2881fbba8aecbabc695e814551d30de85ccd7b5506bfc8eb332cd65e2ef4a1339ecc7fb7cbf5fbea54b8518d58a7a16bdd0739d23048bcdf4f24a17a71352c2b3d4ea75e73f69a34e63e8127b37528406970c8b6d905d37cf2cc26b29ad39d02a9fc94f89a1e21891e9f50d1675e663fb9a20750d27dc4636496e5d1ea2a8b2dd8b463321ae2acfb004375b261280be8dab4991ba012b96c43b61263f8c12a1e035b78645555131fdc5b19b0bf1ac3574d780951e33e0cf61ebc89983967dce0d7fa78a530b28302492ad532e016e0ef0f4d2e82b4e8588e5b76bead3201a6ffecd0db6d1e71d21c89c9be310a41d155ca20a6e17e1e3a147126ed5e1f022ab16a7d1d45830a0ee37742bf79308fde94c9bcc1305f25110867ba080e59934d8b999376d7832b0fa4bcceb7baad0623547c1893960661b4966f37e874051e199aa37717ae337642b0bd32f320d4d0af5d2113a73084af7b54d422127dec8c6dee8f37e1698f70aa39b751a2dc24c4a15f01ace72a7b154b7670cae75b40e462efca16bbcd6db3c6044aee548c46c6f69435b44e6dcf2517d1a8704378523b237af37ffe9cbc0283ed5217563974a52fe73952b475bc578ef0fbd789725a8748cb1ed796805d49a9b5847475958e7a8ded9edd6a2e9f286d95e50a4579165a2e279d86dfc93a06c8e2d953a1764e984026483a80b2677537ea0e3b4b480d85c6816a7062c8b1313cc648f41a460f57067f97b851f040c38085b245bb632e2b98c098875129a6f38bfa6aa5bd3aa97dec8fc46e5884b5e07ea65c8ae4e386a2874b2284bfd7b464bc11a91893ba8cafd47e319f3d44422b9418d069e55638b4a2d36567f3444d25d89f18ac44d92a46d31961705ec5aae0d8f8e19ddbbe3e1b2c11e4f97ea8375a8bdcba459b8f804164bdbbf174bbdb65d3f30c5ed4b2565faa53108e4dd3a91435bc9d61a7938205c159f867b8d5fa26a2561ba17aea5e67c05d1c2d46521f8c86bb7004dda6b3dd3aa41a444f77027299b1174ee98142d07cad8d232286ef82b6d7146daf0298c05509fceae52701aa1d43b94e62b8e55a2f5bfede63ecd1ebc7a04c17676f244799549f7275c61abc5e8437cc530ed2b20456648ab50704ea5d37c4c47ff4e949aac2c3a16feeabaf3ed7d3e5a932c119cf0830ba1cc28fc6b8ab62c2a02fc521b887d001dbce9c7ffd24c1363da3c70af6ea21d597cef218c8264555a2932fa3a780e4464a53a0c40a60cdc2127a9b4b0a854c1b86d227d6099f7a7d25013cc1886cbdf4abb7825f0a8aebe2384da233dd581cf9a0fd47fff8885cc49dc4c16972b85ae71f9d5052c0648fecf76ba87cc82f347df468178a67454cd6296a5be07be06190311b261b9c5dc12b4443245a8c280f55c23bb4b892f7b942d9b8b53f53766ca6a3054a19f0a0677f705a150f5cc3e8937baea349a29ef18fee6c3bc27e567363bf23162c43a139db1b10314c2805216b0f0666e541731f0725d4fc22d9086e6a015845b61cbf55acb333c35abb0326109ec786d93f9034aadd4c8919f6b0e252edb7a344031ff5946a782871d4bb2c86229b8833d9e48234c22ee6b5aa71629eab2a4bb0437cfd4c67392c07348dbc15bc7a2ffbe3e70ac83a14c0e90b8c53b4a83b5aac9a2a47c80d6ed64b84cfdfd5beadf8c6778931b0c24695117d9c742f33eec8dce8a9b24a38fc131053286fddf15033008b74a1fa02769761012544a343009255c79c99543456708e66c2cac12e5d32aed940c5b9ebf42c3aa85c01a7ba7ec6e6f3dfb5710703e120aadeef0e22f365f2e7f2abcfd8767b2dd6aeffaca51ae451721993b36fee3e303bd826613d04bb8af9398d03a7e2ffdc581614b90eb980d7dcf1f02537a7b7300bec0dd57b7c4fb5cc9df50d953683a83dd4e60be193a74addce7697ff9787780754ba67d077c50e08e84c080eeb471fa3603f90da8c375445c37b549bc8bb6431f51202af9f96312721e23902e72eb9139a31c6524c9fe95a27f0935a6330af5f5f059c92b299bb546b9de1f2f7434e9663d95eacc2169899ea93a65cce4fd4b09f319ee2fc556b062964283e7157cd776739232b7a189e2375d3209764780447b3818a7a09f32584aa40b47138c7a166168d019fa2781faa0bea020c2498e1d4ced110522c34585cea35a1a9b7ffaf46380ea70a0f6d8f87c4cb59dfd7813a80a1ee85582adc087aad3b774895723680c415f50b183f8bc691f0252dd047c14251193bae36271e851e4621ee45dd7650f9a4faa1b4087b7834ec11b529ea77ac9e594017522023176693a8e06b27a744ceb51be9f97022359862a4119e26ee0d5161d25e9fce565b27ab8724d7cbf9094a0d92e7b08fe9c0108ef115c0ca9e3cb3a31adca730bbe4cce7f0b0f8a8c2f429de3b2349b18ea2730f177a179d988f597339e11bf942e46843e6c7afb7c55eca7979f7950dda7fcb3167871a59636a8f43186844186920dcae67e76ebf33565ad03bd685458749b95b8e4ca5a749b90ca87a0c95d31afbe154f0ed0bbc0587827ecaa6c9b0b3a5299477086019c0813f2dcd2cd1a290fa1885f35da6cefafe19643b3bba60f8b6fe44e901cef97c2fad8c2364ae787054ecc64f574cccb569d1a6550756ae8083f8a711e6edbee6d48ef83b47a1766c0b55863bf4edffae8570f09e1faf3bdcdbd5467bac37ef8f209aaf8075e86461060a390c66feb093365916a246dda15cb4f22d7456dcbc56185c56bc7cebe978964309c71407dd14c8b794690fe02e87a7d74aa2d6af491cc7b3b87a4ec849ac9d50a99b9cd507b59bd536888a950b1bbd27ee8221c71519967614619cf34e9b8c6d817dfd4b2107c9d385ac2a76a5ddd395f8c262b1e00c8b96b708e30ac3eb9d76223fa9ee54d19d7ab048c4ad7ab460606a19cca1cb2e12802087dccb1066559750a485f4cba4ed09cbbe17e36f96320e6fb40913df7abf4b4275e12dfc958ad76f163c4a8c2c265310500f225816ffdf6274f75c2b83f255c790deaac508b1c5966d7ab32aa8b679122f6c76c0757371d431a66f632530c2fde5583b116dd157e3f4a8ebf3c086e4998e4e671c3f0066bb92d801811bb079700c524358360c3f3d31efca1d7ef824f9a6beacbf4ff2de6f3ef90c9b5ec06067ec4aeaedd5457fc6a975cc3f241b6a7a722b1f612f2274b3a7bea0872d41776300cf4976478eb51eeb796197d1e3d1adf7b7fcc2d3864cdcfcd09ff27dbcb7007e4f5438b93f2cdbdf2eb6d26791bdad31ac5f941cb6e1d9b4630fcfb2c847ba57628ee9db949135b5bff4e69a53a660a49144d01fb1554bf69b293556b313a8ffbaa9250c33409aad50dc5b3b1d6cd3a387b4d827bf74b28dd8b622eaf07be134301c09df678a8f5b2da4327c64b6b46ea47bddf5f971b25efb85457c1386cee8722862461d6b2900e8dfe46977f61589e1a005e8554f8acd40a8962ee2a9c75b12d4a8a43415a25896059afc2ad01e80988088cd5168fba3ffd7715caf7156414133886f867c92fd235ad47c1d5fb16ebc5efe8fed13fbe8db24548488755d1592386f515c3d9da903588e3a20ad5ea50a61461df950cd115dc92aa97ba73823972af9c22ba70a20751d7369a9b0974392b35011e0ba0fcd14567939fcb1ce28ff07ce3ea67ba9b7a317a3842ecf49edd412dcff43b59b025192439d23bd5545e9bfd002a87c7e1c5a3c71195e601f8f3fe5fe467a79cebf5f7a1ae511b11324554258401d5043f1c55b44a82e083fb2a2dae2f1a8732aad05576748d6e67df0a24c66ee90dbced36dafe1966346db3541a733ca63e95e6685b823f3e0a6c6ac3b1542693e5a443f519590fccfaef3cd6ba7ce3e2c19294c1dd42955fe8d261a27ecb97546634f645049021dba698783e6c9323bc4d4cdc63fb17fba449a4760dd959dad121265ce5f033d77cd95dbed535c2ef08c4246aa4077b24192de88eb8a1847e5f79dc941825062df3f14fd5b514da3e321a8fb1032f497f800932cd77bc6f59f30b7cdd3e85442ea3b8c6d44eb10f7297e56aed86dc42a5cf3cf5e5aac695447167035c5a4c4d86b2d795ab5e16ba2ca4e8751e38ae0c35f9940c4d25c14d56e00b635a9aa79959f145f841f70cce5767f9a5424f42c2dd232102c08783afbf5dee2363cf5530a6ff6baa4ecfc5d134a87a1b50b5bcdf4685b112bb41bdf7f1e12fe80ba4c462367cd41deb1bf9f9228f1000b287a7fd1e400a15a4c21f3e697481a61d960a7b0de566b3b04709d0115f1034b01666e0a861b704ef45c5376aaba7295b7d466f802c33b86c174168b6eff3345d29c49d9be9a85154a3af76423b20dbe918abb41836ff397370cf4f1671e34a937a6bf0653e45cc035e9bd098f7b34942f6dad4ed06cfe2769d36cdeee664bd956b6a7ad4eb02caf52af7c2b3cad90c1f80150614518cc893e3cf1104010378636bb1ea43e53ec1f42da35d4d19904b41a6328d7bb717e72ed936126482185acd97de7fde946109c6242c904e19f4918fdbde07571df7b4ac02fa9c4181b428b66a1e7aeb1b13ae6132a0a91b4e76a4cb37474b21b5710426bb4ea71cb301ebf4b1558951a1f6e98252781584999965aebc54ffc4a80410c9febec33a1cf8b09dfcfa43beba81edec843c299266a989b3151972b1ba7f406b64a7e0366bb097867971bd327a26694b675d70824326ca1e26e3301579a9d66010b924954518f372162b4b502fd1331eb46aa8126de19e88273079323bae28b7311bfba3790139bbd703f54352dc16674c2f1c5d7e0cbdafb6f888ccccf4e163fa0d0bfec412f5812f55dc0ef07ac1f3b3b674a13e369e71f979dffa000cb35312ed6da637a4ea2a2e0268f2927255cc2a2dd6dbb0cd546cfa7c09978d0965156d02d58c4936bbb29818663d2d52eba2b4fdcff09a82df88a4727740b06a358adc844301a5a40e5d3e72e513d0ab7db78aa007c9f3159546a45b2c130fb9408675f40c56d9bac54472027b08ab20c8972df42c1d9ff8a3ac7f34718e2051849e77b535fd9b971fd0ed87dd99920fc015c43a144a96f27fdb2169991cf33f4413636533a15406b0200e67a01257bfa6ca1baa66570da550e5f7ae5fd24a7a6f76d327aa34e0f87339e5008793be53549aa4c426ec47806a2a2e81ec77073554a83dd6efa9a98acb42e964aa390d79d4ed7967e6cee3849d4a991f10476d334becc4583bc68c4c5a1520d089013be4e828e965f320366b425751a36da5a122e837e9ceeacbcfbbdb9ad73f24f7a76d90eda4da868e6743bfbc8a11d31c8eacc6ae1c5c87a2c35a6601f994cc8615d282b9fdf0e59edd1efbe2dc78b78a5f25f5796f9e6cfb7e1fccf36a26b1bd96318b65cfd82e8813911bed2f3678eb08df6b8d3037fe2ddcadade04de900894b4111b79532566931fb1fe8caf66017122937bd68357c60a336ca621b8cd09c34c4142f7dbe96763ab6ae1aa1b1a473973cb8cafd87b51ecfdcd74531afa8a2bc63e3a75227e56753458e67cbdc652aad54d3e6e70d4b2aba5c2ab6f5af5b8994e31b2d0c1711a3c8f56e58917ed3bf7f7eb2f7e6a3081cc981d68af2111f4de412cf4e21c47aae06317e3e17cd0ca3db8dd7b93f17f25bf76833ea41c07004c0709fc249039303aa8ca7f3f6f75cee459361b9cc46dca1a031c876980f3aca800ffa07ee8075307c2b36b8403a01abb94e144da7d186ef2fc364a0626169ec7ea406185e705284d11cd139654a0b7fabb2e4b24b683ff81e9b949e920325f0d0c0dbc9285a0ff27dfbb02e37274da4b9c49b1efac2c7d5143e74a80265ef1bb5a9e25c971d082abf4023b24d16e5b350c68ece42d7a373bdba92d7041c3bfee3871c06066259f7113bbb91b30e5113f054516ae315f6cc8d7324637f7ac3e619d57bf4f5dde0a3e576dfa867f58ad303fb9eb589c38572cc39e07abf4643b94ddcaf3e890782bdd110bbf42ed0efc4613b1ad850b6ff4ca1f96fc85aba9f68db814c9762ecab1a15586b1fb15b4a9ca040bfd8c77009ed5528e5c90d01bc424ad8bdb0ade3afadd81197ccfb7dc376966a274737556bb9cfafbfa3ee77056362ccb52c855a86a31bc54f621895fc4a9415d85742bfde03e3b5ba711c2d88622f6525788bc5d2e83dcfa06ab05a1ee0eff23ce5c5b2ee055aca4bcf98c4e8d74a3683a9d046c59d910a8c6ca8b35873b9ffca9074eb65231726eb4c42820bdcc993da30f8428683df0eb4ebf8a59759c91f2b253e1c6e4af01b15dd1ddbb6557ca3545a0c80418b1c2aa9b49eb420315be13b4d040e2a0141d5fd7c3325d95daaf344686550fec133138b1758a3686c7942f03fafe1270e280292faed94b39ea6aedb2263b965828712c87ee66f3ce57d2282a8cbf76a4d179f816b9762c733599f467a9696472d9313f5345b73b3e9222ccc02b10d73bf953ee5f0651804e7bc605c067fed53d83c8ad4f007beb4a6e4a7fe43aba4ede4496bfdd478f1e1783751475726170487421de9da4569a5b717d362d702698dcfdf98ea8f30cd61cc43c865c208dafd610b2086bb4eca31c68fb9a060840902d4508b91ba894ea027f90c1730a476148c778a1d1f2c86a76e5fe38fe8d4996ca1e09fd145502d547cfc08c8ede0ffb3cd9fd6e2695e705a04920027d5f2f054796928aeb198c6b141c31e4440b36d4cf4d4cdb47055bb20ead2ebb34c573ef8f5057bef9375dc1588eac51215c921e4ae6a8f9e9ac8beefd9f7e9cbfcd814fb41067f83c64157fcbfb175def4f2d582a9341542e6ab79bad752d580d9c6e898df6906b29395ca684a2a2bd755fb55a5e6e98374954435bb76ac74ba52cc0a77b528e983d000cf4ca11885001a69150035221ac15b99c33977dd03f68de2e3a08c06e70a0a82c5b9f2a7e5e3018aa20894682836eb0981a4d110d4e86bac93203194faba1edba6657e7aef5f6504fbc106a3a963ac9728b10bf7d093a178c95d8bb440e158a61a388a2b8fd850f3412d4c0913688c5d447d920a05a4b76a9a04f736a8a7cbf7046b71bef76c992f7f7b89f410a7b07a0713fe1c0deadf5b4b8e00623fa9db422dd02db36bd615809a505b31f0099f679cde86940cca390c6af4417efc883e4a5f59385bf5bd6ad283bec73dc9c257f5d8a4576e04ea60d8997916f51d547dbe5030ae492158f230107933974db34cc73b00bbfa064da42da32f091a42d666e0cfa3c4339be2fd48f362a6111b06f93ba9aef4c05a39bd99c3e624b6cde1f4f05d800539e24e65a6fed65222a6284f6c99f72472a5e896159aad0cc8eb4cf18fe195eb8b2c7e0ef398ab941db46d5d6ecebbad0b1cd70dee499447ee34b3fab88eff6651de2eb213208eb27d179328c7b72574467ee756955f01376084d731d164e4e5c053ce2d7140ef27ca2637e5bf7f3023e79487e1021ef99d57ddb9ca2c0d86fe1249b2242f254c2460738b4351ccda9de795aedfef8a59f3f7878111dea7ea5fecb84aad52d885a62d649e65331d63b5275b6f9bfe35684db72f507e406f3e046fb253bfde1fabbe572278412d1a071d2026581d9ac52dcf10cae729b32ae817d11a02fe45a4b6626565fd2fb910bf97dab0bdea4152ba47ce6a8281cf5d6fa6efdd2b1dbba8b1501b89a7f97c1b6b0e04ea6e76739b4ba7fbea2191249514e6d2e2d1ece3ed19d3df4d3ce6cbc6229c834741d25265e36430ce2244f7211c425d43a2d5daa142ae01c1c64276ed715206e1b65079afee7fb898a1eace92765602f0f21ea24efcfe7d7be0c885d56130b0acd93ec6ab191e245333e0d14e805837f9ed129e9b7b62551631141b6aa12d9d2a7a257d5f19cf25faec7dcdeda9b9ef185e530d3fbcb4df267a74aa85721a06928389048c5d3643bfc955ca8202fb1090a5dc5dd6146e1527885d0ec425f00953475a8626cebf16d9acaec4e60d7e027bacb9f7a2ef6c0b515838041848b1db8408a229e902ce70fcd521dea74561e7404e365f357b59ce53bf7bafe95e976e12eebca47fa6a27ac9b93a0e6d0cfddf82a6ce461fd84eb95e0792d53b2e759752b0d70049602cac0fed4f72be85860beeeb4cb0a110fd815831fa0ee11eff8987fed03c0dc414c387f1e195d6bb7bd687699dae326a066bc5d940cee90082183fbb0b72ac950fcd330b7d4f10cdc216031c2f4094bc4b2699749d99166e152777fd2d8e5977b72fc74e95be5bc54569fc7f6de21d0212ed4baddcc139d86357efb5cf0ed6a97f4325fe2389548d5121aa75f03eca8934f0ee9223085677c4901f8886f2bc9d58d90d29effc12ae869a492d675af26b17fc0d794f172b8d776e354ea5eef2c30dd7d853ff30146daf84c3dec32b7f6e9c3e2e98d667170f2acf8f3865f78ddf25db67f3ec0a84a360577f527ce385bc0c92072c95c84d517a81b7833da32637b6668df35af59882bc6dbe0935f275ec2fb2730aa02a2a64512de41deb1484011ca090634d94680a84aa54c77b315f1f9903455cf33fcff187a09ccfe13ffcb87bb15e9a66b7bc7354f26d20d37d5d55704582304405a958ed83c82c4d78378cd42dc9ba60d3e6bb32883da11434bf3bb11c71b31ff5dbbf95c3d6a20750c460175db335032cb3be0fab6b2c01d4109bfcf09da7522300fc9c1f3342c4f57ce301a6a6c772df1f44e493242af4a748ceae0bc5241e3bf19f9151d04a06d76eb8ef37180a6cdc680b51876ef0118cceaed6ddec38c601c4e33b4921b1e3c28b297160afb426ca5b4940b738babe90fed941c1ac5c87365c0f1173e06a76e1ffc4e6f4f918625cf8f35b74103bc595c9ab3d615f1cc09cade389bbfa542adfd531fc20432c2549cf494dd956b02f6dfa2c7fe81833cbf884b4a6bfcbf48a6c51bbd3a06d4a1f74419380c303c31c9b2ca63cd6b99ed61663537086f9cc4654f27dc329a28a9e3593534f343b0504f69c414a9374b24f74f142ac9730cd488291d7b7b6cb48789684645edc64652cf636bc08009e59bbf790d591510bc31ab18a26abb12f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
