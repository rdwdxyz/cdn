<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0363360b24836c0524b8fa0f2a36ff47484e9b22d338491f5dfc099ff5cc22e83cdfa302124dadd4824fede34dab998ed1f6eeabe6e00dcfddb85b28f8d4b14c21ec1837467d20badf298d2f9d319a84849120eb69fd995727d6e145b5b1b579d726776e8ec9947fd4f48d1cc3723aeb9784abed6f550471dd376099512a8286e5f9316ee05d3875445923a0381b5853615015878dfa11b896ea441dff3b1c72852c43d4bad14ac65600550ae267c1c03c8077ddd39d045aaf5ec482b405c11d7033f42941625598d0e9ed32699999fc78d09ea29069e43d015f4b55c2808b5b99d31f917c0536f20b44b28fb10dd20feee52d394ce3ff00e71ccf3ae2f427411a3be130dc46725e9e8f09d849a3224a0bd7bd32997a6817cb1e608e0b2889c474381426bf3acbd297006a35dfc2be9254d7c4311485cb0cda4a6b68556bbfc359113e04f6b20eb862f8d1350f78ce8745527b63b31eebc21e41de9971bb198491897d8d1634acfb8ec227373b032181a2c734de21c932e541cf85e10b23e81e42370046397320770cc10a4063d3a8016448db67a71587b660b0fa734b91e73aaedcf0c3e1e196549eb6bf0a17968a0cef1637a4d4ead3ca7d103760208a60af2cda2b92b128607e22126d563e5eb3370cef485e3e7639c0a38556059af1a9db3897239447e86a254d6b8a191afc3ede622b477440483c1f62df3f34f746b2f24107e55cf79c431262a2f9284a7fd6d58e86d20523b47696fdaafd382d3237dd40beb8aac9608356345fe70a7ea82670fb02c54358f1a203bd18343ebea1a44a169fce7af28b05103308e17c774d7dac599f85174661e506454419519fb7075e069a42116e1b6596c84821ba8ca422678e8f8ff9389e5c7f072680aa12419cbeb0ccac4eef81a1c77cfa3fea6ef400bb697ce90df2adf3a925254fdae48b4be260d61e29453f13c8ab35fb036a8fe04f81b7f71573bb7412f97df0790e22ae9a2b9249ef5130d942077f834488e0c20187ee5460895d69a68bf0849e8645489e01614a039d02831ce1171ad3733ec344f2e47e8dfb4559c40d2bd2364f1c11fb2f7f114672c90747fcce77ef1aaf83a6fb1d75e8aa439d30366ff3427be4595a172b7a5ce7707e07f92831d51848340de8445e249c588eecc2dec2e73c1f735993d51853a5b2b06c8fcb394188a0a464bc873716731d46535d3c46c418610ba55f55c5d4e16526c301852060e0a4247356cba317c286a66357e0dee73072871089550dec3013b70805945bc3556e52e96951098693393bdf08560b7d77d10e2e0427a8f0fe5e808af596746829c3d77bf9b56d2f817d2706f638785f022caca3819a28fdadad3fc72b47b694216ce4276be46b2737170f92375aafeff9264c6560058ca74e881c10233aee0d8361256d553cf6d29c2d0fd697b91f9b39f50ece51c9eaa9143d6f52936c7f5c8d7a5391b22823acf2c93f1646ed6f2d14e5c0b436c938374f9df77efa88d98aa933adefd63d588175ad4ea13410cbf511de256f4b1d77557be365645fe33af691dc86b9ebc8a3be061f3da3a7a17c9fae68da43b7ac0d18d92fd1b9a0115d9428b6b50ecd0337d11fea5885dc92438ab97d6da8fc217aa33604501ac595a05eb7986c57937de4fbd302851553ba68596defafc8ea8b0b4ef99550081890fe596c220d8f9969ec3ee549dbad330e55f121ed87cd0d5adbe3af4919fdf5ca60bbfe75ca885c59cb39770d895f50c48ce6dae35eb248b4256af8afce34d6b500697264bc28c493461969dbbef6e2fcc02e63e620adb30d55f62fa009dd0070557d9ecef535083d77da8718a1ed103554767ee8ea5d26681e2bad1da7e7f9ae8a8a53470d220ffd0b69f508644623d76aa376c77e9288636f334c4afc3f490cbbe242abeab5a59af4292c97289720f6ec48a52d48710cf5c56562bdf66a27786caf70e886da4806a02e4177d913253cf1b2c0fd644e9060f345a8eda31ba25e84d9629319bb8d03fcfee6b8ec45e47afaeed163b31312695a43037574f489e99768510107dc2fd21d04fc239b94df64b9261db85091f93f65df6e086d1f170212fe618c3949b7e759882016dcb3864170fac47a9d7ff3b04558d5e39853207202bb909906c88805be4409a3bd6e695f997fe62bb8408c5c767ced1e73d6b61f8099b31d64928cec87bc8a3307bd4452ebc8a40c09b0e6175dacf9862e96c6aa93c0f248cb40afa5711946426b53d48320a86441b89318d87648fcb055c52b3dce4b7d5e076386327dc369fae5f46fcf4a5fe16fb03e9c831c78e072f106ce7803b2d683deb08e21c8b52448fc387ca81107798d57643b8d2501bba2361f8245fd3a4fc8e5b5c127466909c4b315b6953df75dfa72d3976636cd48459f12e67300cc79350d4be9007a0f7be72e412fe26f67977f509603188cab38b610ccdf498bbacc84447bcc6b428ab1fa7818b0932339489b3278352f0e397a12034add265a6e8120ca4fee0d0970cba176d2cb73feb5fb9d4500c7d8021c2f046599e89f1c0ad910267604add6cdefd6df81ebdf4d385d462475acb4f0664cdc23ac8619d7f40350b89781c2be7283882e7135f9c0957a2b2cacf1ba9da4ec8c9821f2aa16b22bf9d9192de95c469d0bbf88b62cd3bcdf2bc4d451cf4d92a91f3a9ad50965dbbee1eef9f93bdeb4e8721a8c5ff296f678f5e7b1769620726e15ef8674659d716c953e542b8552cf2e2223c7fa3dd179d6b97999fcc4f0d59be40bb6289851abb9e12d70e5c124830947e1b61a470cf740e0d519aea37663da489ec9fb56ef7fa0778f977a5b13e2f225b175cc566aa69293e899dbb78fdd4208e2bc27dea3fb3edfbfe40bceb81e260b922895c4d86d554a447d6b4ecf17ad45bb1a2266b77800e6ceeef58403d40ba2522a50c66930aa8ea12abb365146d0574c71e1cc780b77a64009bc3c97c5f85c5c52bab3e0c5e92a711c6540c6ac03285f79a86094a693a373ee0d839c0f8713cb9675042c1f978b99e7a0eada0b02b013fef2b8eaf5db065c31c9ba7f651a92f110c094cc8721dd70b18a1bc10caa569613080bcb873b94287bccc2c6a75dbfb82a7f871dbed5d6ac995853fd7aa4b9c15ff81f184f221167fc8f74de79a1c3b1b49790b53311d2abcbc0a016f878c4273fbb4861dafbb5db00b76b444fa54270ad1d9811c30a17570b4d8eb563b5c36a173f9c4550a73dd85b9a1d3ea82133f0be05c9b0c61055cea9144382dee9d341000d28cc565a4a5a095f25d4d4689b7a2af95c6e5a2dbac01481fa41139ec26231006141fced4e0ecacd0d3968220de85bbd4539ef689516ec99a3c8e567c9a3f25c839c4705906b011181f5d3de9c6c38442b721047370a899164b7103279ca2841623031fefa4aeb6531c22b55cbe055c06ee7630acef3f3617241ae8b6be554b836b3f415bf45fb436d0958d7ee055103e2d2b5912d29c9b2fef62185fd9edcab8c0eb52c3eb2afe433f88f6c0b7a2379b3519740c70149d7239f71c9d38a072856d302e6ef9462a92d3a88cde456136a09ecc00e3c1696454d55e655cd37120b560c06f59136aca9d09bdd697ce8f4e0e5041efd5bd62771cfcd2b94a0cbf4d5dcc10028c2c4c1e42b01342558411d93a00825653684418b7872cb99adaa8f3f1050ce1f6aa9fd6319880a31c413638ab2094abc38907a2fabf38d1b197c538e5abda667e230c974f4a5946272e008d5e28669097de2b3594d9b3cd910b31bc9b233072c68773692ed01c9eacc213c2beddef21461d93b775b311da8f3700d7f72774906aac123cc95e629b2f713458f503a21c7335e9e7e7e912c300004bc75d84d060d1be11c90af44d250372d001c1a54269cb97c75a94412da00ba358d4862d3ebe00c25cfe712303b7dfe5ecfb9816df1e3d3287f2457325d18bedf57ce55a45b2644f38936bbf1fc4199caa8dabf63ce1fdac7e5b1ba07117ccad2d46aeb8567402a353df04022de3395a691b4cbe3532cad423406f940675444e67db59565a372248ed7e8ee08c208a5ddd9bad8988a8e4698f3a8dc51e2411d9fa4360f52b3c945ee5577bff062699d7f8c14e26b0b3cfd70b062be40c6103e790a6bcf49366b859877ef2df50a41d00e7d18667e329b7d09f4031dd8ec0fe3f2bc2f4faeb858b2c2efb96674a7db96f32a35cebd62c9ae6a2b956366793295872fca6bb0eb0dd154157eb2da6add0bef1fe44fcb148e574fb1d473edb05b7ed2ce4149d17d73940caf11aba2090b13ea790aa3a44500de44ef5094c4563bbc7cdb801e15b9841ad743f1789c29304be83c3827d4e3ff8962c8ecf9a6f2676bc1d3391a684e96d8785c3c1324c18ce62c2f107556d8282f4fcf1dbb2db2fd44eacfacc3cb79eb4d3b531dcf8fd968e0b29eca2687bcf591cc122f0c14919c2c1b70d979fc8cfc194f716f1e3534acc86c6b5e21bb5bf839cdf1e6ac442c0a8cc555f1eb881060f70601000b19794b58141bb719c119b2bfb860a838f44991e0b6472d3cdb0be150e17ef86d08f18c654d37b3a567780f7c073b1e66292db06faa6c95a012c1f4116af4a1546f14d4132a4f680c91f3a867f9b612dee9bef90ee0bb5f084fe40baee704c23da897e24c673ec9f81599f497ef31d40831cb5ff84e1f16360e28d1a7222daffb9a015be830f16d8d523a3d4daed577d69798d63d03a8eca5b1288b58c8e8abd794b23e6cd1b72e2e798481b9f6db903028ab127b8076b400506c46603096fb5afb2d85aaa7f69407b7fc905d0dcf87a1a2f8203675daf4b93a93d437f055aad57a215cebe7a7a487c17731a00a333343396e23be2d875ef10deaa863fa3fe29dd5421f1b4faa990f59b283d0c9808cf8c09864bb008af376b5de47cc923d06d1ea060474b41d0480f46f8754511dcd4a1c7b08589f95774e955cec3316fb9eb2ced7eeed229622584faf02de3e664c2d48628bc569ad2c169da6d2151c9eec8777b27b6271d261f844c25748f0f609a925af968a1ba01ebcf482f94e187b625f20e1098ddcf81dd5df4d04c0a8342f3638712e8911680af3b648be3b5e7a005e124a0b9fc79695db7cc888569fec38d09fc5fac6e10998980f8caf424076f440cb8699729a5e8f5050a28976748893ea91ca07d48e0da04fd994381defa6a1373b67e35f6d18fa5649949b96a3c81858ef17d2e5f5812765feba3cc54ce7dadce65c00fe2eee468bd439e3651f596e5d2042eea165ec9d389392b88daa535623ccf8189359406646a4234bbad5d7e22bcace644b5213028f8e7e09bc77657756f22b4502efc5340053be5ee14cb36e92ca3293c6abcf433fe95d2a66aac71e8fbe38461b93d43d1a5162a2a1363582d4a603d737f342f49c6266cf779718bd775b5148696ef2805b9dca69408f15bececb58db9e525b61b6d61a9126dbc7ce054814e823e7c6ca4a9317993f202cf0995ce96ddb954644d34808a0ff76df0443bfd51b249f78194567e555200eaa9a5768583ad3c230287e698b904aa9db97c0ae640eb9b2a08a72fea0f945a269de0192e1499a8f5a564cc8c51ab590b23c5a7997c115d0cc30190db5bc7ef6dcc3b8770cf7e90ee68e2c291012ad44f709691e1bda5e5a5174ea9275ed8e5942e26b11906c99d2cae6033234666c743c841cd8e29d9cbfa45424e9d64f13cc967a87289bd65b08b5d4d0d7d651eaada3960812fc2be8aa12eebd64148c7b4b32554f22d5ef1f9a7fc51a58d455c1036f8f6ffb30a4a8badab43eebf038fe5cdc05246e054c653ad459838c4e68d3c91d3d20006f577cd245668f0ae2464e5f2dd52fefe4e7a41f8b5c96b73917cc645318d2eed1ce60c4ac05d25305b7db8fbbbbd4b40756c6bd4b94989a455e41419e78e8f0530c548438d324bd21619d4d955e27f47b2a9dfce6e3ef7fc3d9e86ad78ce37119106e498a221fe956dbc8ab763a138bb7d4a2249399030627823a670de925f544fd65dc0dd5a79d27e2c83741f85b786581371e88b43997bb54b8ddadec8ba2bd19e0dff9f8d95b0d147d9a132f1735884c650b4680015bc654289a5608e4f45533290bf63e331a6f362525e7b08e4ede859390ef1f481c4d04210886fe6c28718b55a5146d1b640c977c627ef04df6b4d90997ea9cee4c377b298ebbc1cfcc9665c84d47803ef21d7b36e036cdbd832b072800a0e99873d568e0fcbe6663fe56b45610d097318ea1fe8d9fc72c3b92d41126501479d5eb8220029408c6fb82558d5d2b8f970bfd74587bd3da740063e8f7287e1813cd608ef2264a48ab7e883e73d0b496c33de263874356227149bef838a5989ac35a49bbb357ab35fc9a4c39f4e6d59538848865115c2047eafe62cc241a28e28bc46d6f26f51746ca1e51079ea79a64075a785e89559a7804c33c6523442fbef14148db47eb0d28d9d74a1dde793ac2d3faf48c14c2618ef93124b5ae81fd70d192bef6273ce6134eca13ca4a375ec9873f31c3f34e4d96b1ba8f2277b40e129443fbbdd1ee1c919b39bc9dce77568c5d5bab44bfbb859ea9b6a71a49bdfd42eba5c7c9a737c439287d33230b272b653d6a31ca9054794eb77ee7de5aa193a80c7abf73c79edb6da510e74887415016e094ad6ed3f110ff2eed40773f142b32884c427ede888f3e6b0aafb3e0600e4b0644a12d9c2d827d1d03e1a6c5a0fcff5b273cc6ebc0b05bc3f63f7a2be4f08e87a1647a8d43e875e0e3eacb8d7b5619309fabf6841a3af27057782a65f9ffe45f2051493ec7b234bf7da0e39609bce0af1a5c6b6d42b29c9c10d962e7212ffce5f57a6d28f2477b1f1b013f57448f313ef4a9b9386efd98e3dd4100abb1a09525eb57a290aba126373471aef424f8be75f54c75ed08dae815203537e767dcb689c79c7acaf914c5149f78dde2f70c5ab42c6664ed4fe53e46f5ec501a2c4425140cd406a2645ee10380725820239e56fead9ebd86d2598657dc22a9666a30316c59c1248f42827e1a47e19b350559268079f12ff5d4aceefe86f6b91cb96059e5acf60ee8c6742bc8efd429c8e957bce797afc0f3114ef1cd4bf5e17db9d8e59f31097d557fe3be55dfea04e7f58db97202c172cacb45db00ed227e25faefe92bdf376638d78b0d86ed67a38dda52f1e51f95d294b7204a73ee8ce4840bb8f61e520c2b2ef47f108193b1319f1d04971b4c3936d007976e47735c6b05fd10589f452d32e4e2a079ae9f4552455af83ba62a6454b1605d11e753afa35c6be8a8185b30f7626c4fb36da4f8f79b7654b995818722677742bc1b0d38e62fb245c627e7ff1698c6b26acfb0a2d1b48c68857e1da33839a9585124a087854f2b66fee87d103144d21108800e23187e62ac373c1f7d6cd1fdd2f5b2b752995eabca23fe6602afa1d9555f44e9775659a7cccba9df1f65ba2dd6ca6485e53c01f49901c0445fc00d1fa074100d9dfeb83a0bf4eade1ceadb5e5fa8a3d2ddf62cb5626b4eeff2c3df083b026894ef23b856f713d1340cc86940aa1eecf289247e4d105b9bf8125393ce28e4fe992b9773a95e7f6423150b8402c6a151ee2f65c0932207cb0741d36f49c5f653b9f90c8cdbfad620481ce98a0a94b0cea8c8490aa546896e579f1eddf762b076fd0d9c671c86ef057a778acfc0401508e2f5495ed5b84e06d8a7a7adaaa66ce1a29f49bddc918eee2e92d5ef873ddc4b25fee9c82ae62b082e25ab9b6bbee278b88e1cfcce64fb044979d9004eb4c1d2a528dee1841d0ca3cac8c07d436cbbb5dfc448cc7358037bdecdae161fb1d49e22e0d1b22b5d9fa8e55e96d708a2731dc99507ca939e60ac41f66c38ccb78a76150fe85bd13c7122a2417c25a4b48231f90a697a694d91477a20fb2bf6c0fc98d986b94e0ead64c2ccc3eac6fe4b66a164f9116410faf3b6072f4fff05db846154bab952105432495d544cf816fd674fb8f14f0189da383994f06bce3ee255b273158035d5a7257b0a05ed270d87f9c8c445da1c27d0c4411592f725669d5610846791c45eced364f38276ad8efb6babe1e37e0c07b1251d71372a5f8cd948de65796905c67c93b2d64e5180622f762a878f628343cf2ee3ae27a5d450908006cd6ae013dabefb9fa9d398ed35b11659431e76d8fe3f58d3e5798610711491cc71b64982871ac67fcde45079184cde8e3896c9999efbe0d280969399ee0ba879a9751f9b07b77c38b8ea33e1e916fd2e7b77e3a67e10f068377dbc4b1b8c9278b674e101144d1446ab7efba3df080718ea43f1a9d0ce49ebc7133306b897493db8bab8dbfadddd8144423d64f6556c868cbb79b69a8224d738d16daaf53c13df4f07e6c2f5a8a458c071ea1cfd2044debeec3d56b5c235de880a223c12b37749194e8f9fde577684e4139c6d54ae925c4df30202eae80b162ff781329b1a9e26f4f90f275732c2d853a7b9e03b4c33fb928c3192fa049a9aae8b77f2c6f8fd98ad1dc0ee975edd47727959cdae1ff136b00686fb17f6f2287684a6efb211e9466799e1b5fed5993110b73cf719de2a2b601411a3619afe994e39b4229ecc7228828af4ddd4f3812ea3a9518bbd56415bc50bd2446c9ca00d48c2703774af3daeea189b3b11f09be11846fecf6498338b965c11d2d607c7c20468a973311229fb5b6abcafbf95dbe7a57d2ee9de6fef9cf7dbd6c9d898c333e8b57fe89b14ac49db876c501988c980a5fa6f8e6a99d711de482e212200d97a1f86171d41641026494496c5e4a75dfd17778ec430c414203b12f887ca2310d565f3d772305959ab5a076dfa3b39bb4b73233697f0e15ae9a7f3331d0f61f082a0564e33ac7e63702aabc5ac5473252ed070d60b51c340624170b20842fd172130944239e69b62a7b971991fdd02551c923e7e7501f0f9b66537fe4530ef5fab3be06e0fc70586b462f5efd9f56e8f9785457b6b1def763db04a042d9fbd3df9dd08e97c82e4db8a14877ee9d2dc01933be9c95fa3d6104a1e889da1d6965833b2a93caad1ffe5bd56204a415305dbafebef329bb8eeda02050fdbfe964ca13b3a8b59ca4c95dd1e8a1e4592bf276a553d2d39c3af7393417cbd49b21a53f149970ce57a68c85637a42b48b7498240cfdb8e4bb0e0832c72b6b49200ba6fb88a42cc93fe77e36d4598a4214777dc300e1b1977f00b33864906f60d194c8b994b92458366b6e1ef94abc271170ad0fc4663277faee5d55c5f6fc9f590b9fa98c1e32103676e556a078a39d45b73a6630e8f2e024244971abe3f2fb510f060ab51064ee78b9c1c855103ae59b5ad7d8eeb2d43e26a17090bc166ec8e60e54943ba84df0dd824d2eb72be6cce29471c8348eeab2ee15b725caea826b8a8c5f1b7f1d0c4f189f6a851ad7f61fce7bdb138a6bb1ad2f9b17b6d78d09f785b18dc6136f57e5e279d173d9394bc9cd94d9ccf6c763be6a8e6b1ca3b38468d53e6fd04d9543ff2a08c088e3913cc475889c2cd0168c59e7f49f800ad138b02888367812e80f35c1b1cd83cf673d441b142fb62b083e92a27789f9757fc59372fe0fc718c51d53ce4e66ac0712e823136c339bbab69a31a3f09ec3ee0f40d017210356fb010dce721c6ee1f357f97052b823425b1dbe07dce9adc4f68c0edf10bff40ea3ff1dcb1b747d18a298a0a7b65144552f616f276d7d032a826934798e3002e6c35a7baa858f0e0c762f15e487f6ebff71352992a8ac8891e869cecc7ed708b35b76da5ccd41af5ea8ee47b9b8ed11013684d126cbcfee1ea66ba74145893a2df7779342967b19ac729fb236579a4bd6400bb011c0d035292ffbb4bf0047ca80b9e731aa08439883a2e1983b9ef6824b41ce1d699eed0653b5c3eaa98a4e1da672080f5f80b8c27dad07b0568914b9972a11ac3da46237fa8432126d0d8ccbd142f27a18b69fbdbaa9883e00a274edaba96870b2553df4fb88cc0354548f4315239f7806b809a6f20e68d1159b2c9dcfe22bc91ed554fa1f0964a018397076e9dc4004ef8a2566258ecab7edd985681c5cefba1700b6be17c25c1f2c92b0ea1d48f8075afffd28b1c55993b6f2208192520b4c38fd8ae37e4ba743070a9e56613046c8afa093d5e8e0726b98339b292a3aceebdd7796cecff6d16eb8187a50125c6cb35c1f6ff96b7f863e19bf559da7e8c251cc32d78e59511d4dce2d1c07addc49bc4ea3123ca9fd11e2da045286ca92afec16075aac320866ebd19cf5a4c679e60c8bf878c31c07ea56290299a42813ac10793834b466fa0a4836790a53fcf9024f11ecc0152337beec189ce441ac413b27de8bfd7668401221f8c962b886e102d9507a8d6d1d98af539d41c2702076120519660223206fa43b6c8f0a1dd75f71c9affcc42f1b007fa64be1a3574ea75d2c799d1ce6188a3f3c3e517c59300df2e37952dbd799612f13268fbee95774eb53857f76fb9124deb26326120b9f0312794ae23ccd27789217b4c69817e6a89800c4cc909227921457cf4425cc076b138d4c027267ff10895e1860cc85f53023675fd174428c8c30fb7bfd82f8c526e53e47b50b127f04702caf41117f1c9d377cc16a8e69c20f0a68045b7ea2d0684ae76c91abc969f7405182300bf27197fd06d7c9b7845e54fb32e8bbb8f777dc4f2ac75b2bc8c7d409fe70c2629457c3aef1c20fc4562a98b288a5ae33284781c20ebe66650101d0de1aa9a8e0e3042390068e78525ba8f4d69bf2e25b847792236aa75b9ff8d48a45a358f12e877bcc2b38765934bc0eaeed58aa86eea0ed115b826cbaa0c105514b4298e9f9deabd9aa8e40f3865204af3ab67162a103d364a2b4e713ce0d9e8e1075d531ed879907f5a21a3683a6b1a06860438dd22c981282a4646885e745d9c548565edb5a1da87af2bd668788966d7792eaa0bd238e2a1aca2443d1eefeded520dfd7ee3fa34d8957ded033a31a1b38b04cbea776eb364a8823e19b96405b37b1cbde89f0dd1a6dc3b529a5194382d65ca56ec3622f875ab4eb8992bfc9d86b49b62d026afb82be8c8e626f4e62ab519e9b1745322dd29eb173ea56a8438d43e4bf98b59686aaefaf98d7fbd3040e36dcdb22d60be288d6a0030e592909e949e3c6159b68e930f9c394c1f0a7757bff6b6d91d5cd9df9abb02241a593d996ac64fc7ddfd21f177fa852d88fba10f35dc825d22019e79e032129d10e13e537b4a4698af90b8abc44106212fcec9e9227914705f4900af906e607be6327494cb7223abe3f3b774e5ee59db0ba67484889cf0eb169a2019c12eb8407ab2404db3a58ab62f16fe7fa8c034796e1b0ba48100c41745ba8555396fa95a15fdd4512ff2f895fc546648ee740e7cd931320323f495d1c04922041e25e66761873cf201aede1600e8c53b5eacf4b06bff7a8c68a2ad057797c9747f0ec4db7a144f8d7f8ae7b7c84d8487fcbc76693477809ea3ef63c8de4b45e89ae4f83b54546e2f5cf89b8da32b57662389565cfaa135cb9026923831e9b5eb0b55a7c8d32374f6f47ead7d46a89bc15ad8a233f5131a9467c47e35bbfd30e4f649d00424d5741cec4a3430bcfe2941b3539f53aa6a25a6d1f01da8c74602c73d2537f4df735cb5505ea5a82f8e2d1504ebda3620ccbe260b0909d704d1c80a9262ee769720f636dc11abadcbc94a914c5755761c232814560c620c3f6d59afa97bfccc3082e4125c13960702d02cbc5f4341543c8323a0ca63847be9e3b09393658e683d60bb207197334e37c1178b2383b8479fa3c12be96aa51cfffb228b626dfd961e7096ce081e66a0c9eaee5e0a7feefd8f0f2ba7e86461b604d4e1a15100ba00ab2fa818473276cfcee44355a1bd45edbf5ce19634f527450c4ba7025437b75f75b54b8f3c2b950b27d23c5ba6f92a325f71a1c0c0d0f82e460d28702411d6a8225d055f315badd0dc5230b6f06e1e10ea62da43008b07d9b6daf03b44c6a1e6df5861c15f08167080d6438130245c234c793b3bbe4e06a4fb17c1f42d0a3a26cd8a063e6858569437f978d294fc25e633976963040d71f16ec60608ae68f7e203ce4b630a07eef507c38dfa53eac9fad9509027c14c0930e5c563542152716ce8f3f53ab34608aac4ec5af84bd2dfad59fa343798527bee82ab80cf47149742b8289762f12fe75b87b082c012e3119007a6478a2afc6b389ddd118537f1c0fa057ea7a3b1764bb12d8bb55568770f002ccdb1e8c87d5bfdecf54ea3dd0870b669a402b2f98339c614e3a6b3f122d1571145b8759e10f3e6b1fecf5858286c80dea3e8b863437e3d723938a2ae77d53cccf0ac5c32332f4e029a4520ce97d22cded978c003093333402c5c152d67a4f88d1cf519689478a529fab9819dbe2b6f72ad843b513fa68751b487152e15ae6536ee90a864edcc26d3adcf1fbd952652219ada1a81153f7fb144e05e54ab5d3f17d22f3b8308ba8f0a15b407798538a64484cd851a1baf34d84cda9d78d4dfaa5257d854685c5cd00533017113a988b66459dc403056934d214aed3df054a86c0cff99f181c8f6f84aad0355c7f23f4bbeef6a7b1908bc095feb6505a5582c872f6c78be33c67b011aedeedf9fd64486133a9dd860b7c5cacda2b11d6173e0483e8d23460078012ed5e22fb0047a39caf52009999c2200a7bf6d9be4a52223f8d220a0b6e7b851f3fca4ab3f5944b7e6f0404f1a4332238b468e640954f0e13679cd8908b32a78b4c5453fb77b71db12ff65d79435be0eaef8e17bf3523d11b192414f0f61becfb4137198ed53d13fe34bc770cf47d98759e564c4f3d7040f1c86386e589a3d291839bfe502340c58bf1ec60b60ac03773b8adf35356e8da1ea450e789a41156982d1c5e450c9db05e57929eb79d07f9220aa9a626f265a56c88d96431412f6a8946eb2c1302887ad5b21e9343809d3ea030e510dde89b44836b42a63fd8827790ad3bce6530f76ccdfa419a2810335539ea1aeb1eb0da751e9bd26d282ff50fa0836bb1b0bc33e0c646ee626dd64f117e3d55fec074933cc3394db48b1d956d1cf24b4ac015b33941b788a5b300db4e8b21978421e30bf9b83d3f3cf846e00951317eba6de3e9149da4c2c044f47af1ab7076810f80bcf7d6c3655bef20b84a93398fef33c89b3e77de5e976416de561533f495b2d19231b07103349473fd3e78a09522a79d849ca2e02a8a424a7a1ab646e94868b7c4f7db146dac419693ab2b987d878eb27ba864a6b8be63bea505cd2c30c60f3ee818ccefe2e9461c717e4eed7310e6fc5c74d01be23a7c7686d760a99150eddbb56ea24aca994e6015224069bd6773166fac1c4ee27d69d8e10857a23f1cf4302e14ad8c680b4e596aa00dd9b0ed0c26a31c3faa39f9f49f7d867399b6d4ec4c72a26a79c611d76b34322a2882428aa7da817739669bfc00bff66f3724bc2f4440adc6b6624c093c72f67689b78ba0a96f2b7071ada1c9cf32680e71ba1041a7ecb1854df075175f625bab59d4f73280fedb9cbb01b50096bd2ed1b72b29dd530a83243978f4d06c7391bc1093c62d851e52f149ef6c851089e23cc6782e309f34fab5865519e68785f60750899271d8866786cd6107e515a47355d5f76da2558a863df9b82dc3abd110ea34d331e0500e492daf3a1605080be57b8b60615170780ae5afd982a82006a0fdcc200af7824dd743816a141e99ccace9e454b3740ac5b8b1f3c81b6195df2c085c29017db918d0bc171c2b1be7387a6333cf01ed3b668049c2cb70a5d64c71b585fa7e4e7e8d904d20eb0bfe271a0a4c5bfd2fb5c8947da37b4ab78357afb33553f7f22d840ee415c3f8d71bfc54aef1f7af347b9887704d8bbf9abb66db234651d3e8b0d258aa95df1c783e0a868c31d21ccb05dfa8a2692db7513789879779635bc7b07d24de06f58cf6baef053791371aa0018fdca83505b0a39152118a1e10fc0a0b17e270ea9dc14a67ad83866131e0918fac8717b3984951c889ad386ffb82f59b458eefdd2fb35ffdd83a7a3fce12ab8880be1549d067ad5856d5cca67641964347ea1d9adc842f024d9e2556bd73605c3842280b1cb880fd63035d1663afa2bcda5e0fefd22f54945720b68103c9c12fae3099c8fd3111f232aae24852ec4c19e2d240c3b8cad11e373c194a555b444429ad23c9ff0581fda25c1cf431239711c929243cff605d3838597c72c6a5f1f00a2299e8122d3e3a41c565d73077e0f0d3540e35c77505614682592a6e0ab06a5b9ef370f16db74a876a86e867dd296c5812eb1f3f5b0df48b7be7cab9264275a181b70b80febb3c24515bc9a240260653d302b0586b07dce085dc65f0fd58cfe8762879100121dab6114712efe2adaf0f6aba844a53ce7566b963ffd4e3b8db17533b677e2ba2de8d67889d35d48e30e17464bdf10e7b9e1c7cc1fdd10d73505300326ed6f6d2aa165aabf05d498c3ae6ecf739fe0dc7a2b3a339c203964febec8f7781c7f112d687ac4aefcfb2aac6f71a18141a854430b1d3e9c43a00ca01c0acaf95d020adf06afa154d8c5f0f6d10ffe364d53cec4c043a111e9d20320d36787f7586544d5dc8eae6b1311665b2c03282def34b4cccd47702c8c0f4f67e65ab54c57c6ed58ce9b9436f4c94686f4942fda0e5aec548f8026dc116c91edf84fae2b52cd0f59ecd37cfbbaf0823c95d9639f1319b554f47336e8cca33fe61bd35f5f5d7d9da50d129edd7ca7484adb1e78d8b64e607aa6e67b02117855d4c749689926bc97b23820281df0a50d0a9dcee99d8966ee896b3b3d450b7b8ee52c439352bde5e4ac9afef32d62ef2f4754abb7d63d560c0038cb55ddbb3a7b93ee99b00335fabac45a0e907b92b415b0460c70f6c47a20f8c45da161bef7149652032f4549caf532d7b12849b1b7450efbec2cc7289df2c076d983645aa6908d2bdd2c70c5641bf6552ceae16f7211703e774642e3f20cc9726e2a3182a94b7e63feeec1307a5ad2eb6b7a213d5e1923ddcdb5032b6a87845ec0d3097230cd7e433f3a066e6af1207f9964b25315b56f7f60c4331b5e4f33b27c3d884c7394a2119f18eff7a106c124db4b451fa3da53c9324f96ad2f70402dbf18dae006623194d5528ac35f9c33f0ac96a9017bf41b10b13c5d21dc767f7de1ed7914cede537b0898e1bfcc271954ef76bb76e26ec10006f55342a529d819ee13dc4d7452213adc915914ff9a65c07166b112941bbd7306f9a92435b3b284bd4be9315315a4c12ef1a3d965a3ec0697401283f6470e7b9d5b62f0732c5e66bee8ff610aa7f1e58ec4ff0a9d76639c16ed8467d9c1042eedb2409c3aac591cafac03f06e3c22a82a494cb3be7f2344927513386976b419b7c5860c6e3cfe6d9139603cd70cf9a4daa570dbcb285e045bb818ac2d34426e0515f035d56f540d18b394f36837c240fc498bc7cf89088068aa37568566e25f56e628646c0b0b9d8a35a9e3403c3be15443a59bd3f2d4b6e03ddc5ccd478a3bbeba22e7a9c38c60cc6883f0590c17c8c143f314903b7d6b3d0d3d0a804ac1fb6deb4e9501b02bc499c9352508b7bfb821b8b4eef776b2d9cacd3d1a17b2b56998c4581783891e82a9b2b39d8982191b943c1a23dce131f4ef6daedb7c87e4fa354426124180bb46e178dec70721c581f38c5fddd8165aa1cab27dbfc0176915d6a882ac4fe2b0c17fdac1aa72624b0efbcc73e52e2564347db06f2ec8e1fa10ae2b384d87ef4db42f218d0e2e34924e10c5a344bc9149686853a1f55a4d22b464eeac0c9687604eb0a5c052e5f7f29e0b462e8d0fd0d4e5562869476619c3bf14eae2d5cf3ce2b8aee211eb80a4445c20280e79318a825fc10de2fb5f99b4745e359cd18c581e0981754a391f648da91ac1aab897dbdca736da18c831ef4e0df77afe02012ab180a15dcd8fcac3f255fc5719b2ac5ff55da6b28dc0e7c219ac93aec81578147d63a2f7a546f5c62ccfc0203d1cfafc05c6c8fca799dd2ac6905b3c4b591358bc395a52b963a153615dd9d3e0f67d9143f3fe05aa6dde64fa4a5bb3b1b9dc7fac0d2d106aca8a235edd87837a55a06d94c127b7dcd70717edd51446b3baa08676a9fa3d7b5afd5eaf57002d4488c116383a323a549ba0b2014dae00e3da94efc038571f6c190c24a00419e7d252118d5067e37c1a2322c1d0b07d278ce91b274102a9c8f67ebf034f1bc9e9cc7993903abce6b8ca230d57301014f8159be67b89a44cc2fc56188d7380b001401fd08ebb914604950220c4645b8e9c37d4b7de2628f7d9a379fddd68d010c3bf096f90154df97e25977ff4e4bd5cb64f3fcdd5614bac115671d861b8097afda3bfc197a1a42a0d85cdb030c67524d97a64ff5ccaa841fff0f84fc64461dfd7028bcc3426b3d23699cc90947b27e5186915a4265809ce503b18f9b5dc24f84257dd2766272ff717a3e8324ad75a3d232f353ed00a460f65a9f45d3f97c15e9725ae311f9ad24643c6b97e3bf5f1bd1f80e9be20c02ea46a8a7f061189d7d4060076258ea44d3ab73a598cf3edf35c1c04c50f3685e3c3de5560305e53e04455758f440277328be1c594e401bfb56781115e84ac98e91c8162473e7685ef448bf44017a929e69ade218b38ffb64dfa1d3436d003534a5c4c1c7f3e50d64a974106bcf85213c2c80461b95e5ef257d0daec18e6b3471670c29452b410888361717c58ba9b57a1b221cd12fb316e02a19602a520b2be6d233cc1ebf98c2ef19f6d52962cf9368f00f5990f64e83fdd46467a4a37ff3bfbc241eba4307a12d3467c6ee89c8517936e95418c12bde70b52c06bbfc38a8c53f0cb8bb425be91980f9095df548f7abf1b605d648eaa34a1f89e3561d0c9cde578af6b9a365f2315c16c95e9c8191a3504274129197a2fd2e535c744ef8955c2de5ae7771422af0b0e739fe579659cd09633b19b980651826ed1b9444c1741b7b1bf7b5b1a93f3fc9fdcbe8448d6fd8b2c2d4b78767d5c9d99298dd44e9efc302806b42f328e0fc17dd3000b1644414baf40c2fd218bb5b051678bb14532f3684e581e48ff2edf3f5eaeb7bad436469c6a9874ff6a2fd34176dad55979cb050b252e470d71f69eef6248b992a26c91be0b1daa197e2fdf1be999123aeaca26371969feb604344934e0d7b2d9574e0d15b6de473a2a12ffca32002ced46cf8fddcc2ec36295b93f668b7cf7857d03bef82a4319d581828b7e0d6e92cc99d868206d5f63a17b99f3a683cf89145ab8894eae161e9784624566d34efafd692a48ff3bcf1a0937591d7460a60dfe19811dc1705c4e4711aa9fcd596273eda5a919e3a67881b1826eb7d3609f233972f65c52970a5744fa22036234943e8175319b0caf9ac1ca3198841b2e2189868809b947dbb48814ad2eafe0e15f192924330e2735a250df5240c10ec7ddea4b52a18f83135bee403d54df75286ade4fb0588f7714f6b0f23cd5581450262cb57ccd101e6e29b5850a37d80418de7e249637e8c076e4267c2954aff532120972fc3411c5938027a29b51d93145eeb687bad35ff2c562ab05476d980de7d0c3b812618ff11c7d39fe37c07e9d376e957bcc416952be2c5f7c2ceb73c9ebec50a826cd7a1a9d4e1c60a9fbc8e6d272974d047347f0833b0dc44369186a788ebb2f24ffcb326113a4d02f01a8354ceb2c6060a02aedc764ef0545c79f16250efed4ae0609be92527f4d86580072ec241f70b5badca797a84c84f35b2758b249efddad822ffc704e2e56188e56bcb148c04451e5baeaa72f3704651e9d548f422bf4a99531d9f3d4fc3df0ee7fd76ae80f9a164c35f7db0c89ea69cb57fef178206ef8d65ec4b3f72dceae454a39a30bdb17f220f5c7f4a806e54756e0d54eb64d5dae420a174e76cae488ea5aa0bafec4301884a762a4cca1d016ef8df168db09753c6c6e1fc935541baf1bfb9d2022688ac83263e2ab364336bb5a9ec60e9055e5091c25585f77b782beaa9c072d23db6d945ec757387a9d11cc209fa332fb416e749a75a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
