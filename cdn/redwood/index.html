<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8bd1a20e0dead1ed1b49b2d50e40900c09dd18a5f0ff554774a99fb9873e270ae1d6a7b16a34f4072ab2a1a8feaafd6c69e56c526fed9b2f8195f8ea6e3302847c19e9eb9a7dfeef5fce48b910f80a57d37c9f88f5c639ac5278adc546c747c9243501d6bb14fedb5ecc8bc59f9ae9622c1158825c8521c66e6931fe51f890a013d9cc386e220c881045c572eaa27e34b9a2586590c0e26213554737ce63401e6443b1ea9490afb03a033e279f6060ea7ca6a7600d9dff82e69cc692f2b2c3286e4fbd75fe8657c6653541b765cea13f4e8032cb5bb83a87790bb309250abb213ee7957c8c7410caddd9d3994b236cc517ae84a4ca5264c4717eb8d3ec311a02266d6206cb92226082960833b5d9eb5fb55093cc4a9d3a65b9ded007e0f601d46d8784a7ec3be8d056f2a96c58c4a1e3f861cb904305a7aac5eb1e1c683cc81f4368c47bf12adfd6dd40be6cc82bde1a624102b8304bbcc388a8253a83b0e30afea4113805b546baf2ee5ea960865b40e7ed7292dbacdcab670ad50d4f1eb938a4cfad467910405a072ae435511e0cdc333d0f54dc711479762d3a1df0f37b79a64204f32602daa73aecd9dafe956bc99766f8d618cde4300e34e6a378a3428be054799ebcfbe37d9f69edb1f1189f14facdf4b6534a08597af00cb1d464165756d172c9a72993b2c39a8fac10b219c47912147acc51cbfbe0037695afdc6b149cc577721fb34b3291af7943ec7f98454c3d62b3e7fd93f532b919b0031f9173eee16acad4f4ac7c3334c4f9e412db53ff8fb12de89278ed0673e486728fab9fcbd1efde802695d8366c2d75e1051308be0f1b55a1ef25b8549d6dc25392fca07e7b2f046e61a8db24b60125386789a181932f88e29115970bbfac8f97561120d494749e41cc8d3d67f0e8f787de9e7074d0482ede9e2b1e880984502a87f14cc68a894e9e97d36607df9e09b47e57da823b7e94c372161af743d147f3a4ec001ea2d5724c810838ec30d9d94f9c16cded0abe075f0855e804c483b73491ed5e44e60a1b60e2a34811e525843e72f972a710b38fd5f49962699b4d43b31f7d921976ac77c4d2d6241b53c8fa9f2389d5d0313303ee68015b3be6338897e1e1115755ca46cb21319f644ea50e036459615eb4a0932ba23625fd604f48dcac201f60fa0f56098d6eb66b0fac120f55dbd4a30f4d3bb3de8e86a389d061146376a58603ed62266d8f34155373693b2f1fd404e62d55ff96060fa9621bfafcdad430de2a2faa4af9cf9e9aaf00d88e4648906b27cb48219fa65bae60ca82995975c77ccbbba69be77c0197fa449d531ad832233007e4140b4d92aca90c536c0261686cef3f8039c970131569cd780f04907dcc42f5ff6a1d521be739bb6176c9cdd5bd50afed6ea474de4555f75661e87b435dc2ed3faa5340b83700d5a215ec33cee287761fe6230e92599e543f4e0f36ebfe256c14f0671bc6fdc6b8d08e8fb3e5d808f945d3d0d1784f7d0c219749bbd0ba7ef9eb8d927f79cbae2841acd24d6ed7e410897a26996002cbec339ed7d64f410c24022bf6feb4267908e360e407f1c787b0e89f449421edc45179bdf289a4f477196be1c0b8514059aad3ebd9414b9c19ebfcfa1b55a1de9c04838107b771495544c2680c8a39ab24d77b2244520fd1bfff6eb8ca1a92af217c3e8485bca2a9fc32bd22272839153a79d1c51a1013fcd0f9b77b6527ed1050cf07b2c8560bdede5792adef03985c5314fe50f456f41d36cfbeff4e6fe71b2c020f7e45014369d5dd97120015c72562b784b880832837b8651299e70f179c5ff18bb2bcce8799b4caaa21236f5a1d1035eb011738f2313021a32c1c5856f64531c14ba9b65d4995eee62c4c89a1922fd9e68d0fa812b60ed180443e7cb74fbc62ce55709518a30a0e3c0f4aba9a5a3eab90982816b49c3ecedffeb6e38081d8e5119f5bdef87be233cbeaed7102651567789b86a054d270e83512618978d50004a3841533c029f4a20fb2d4b85c159bcf9654f99a1c32d13400689efde65e8912ad6d803ccf8e06fb1530e28b04aa541a09f4a3e7e9a8e9bb3aae6dc5d5af87a5505416dad8fc993df51e93da5a98d76b43bffbc72eedf9cd174e7f13de0760c20c513c777bc884e0e64c538da1bf7aeac547c032423820368f18798615d1efd4b2aa05d0d59828b1f615b431c5aeb8d405763f4b235732f48087a673b662d258634073b656c1accd76104ef8c080ff5d8bd1d699f2fe8c0d077de78449444a4e2b8698d8408f85ce897fa8b4d6ef5e4e68ea71c94edb612772bc32a60501fcdcc43a1f7361d64b7b9a318679eb2b260daae5fc5e65b23e32e4ad68590e9040517d04111cad0f30ac88fbae28baaabf4a88f5cac8d53952994b0b1c78d9604ffdd4680ea51406c0d0e88fd98ab2c88972fc5fb0b28acbfaa951d8730a12de0134de988ae9e60974c4319ddd965a9b07f393360c0fc7cf722ef117a35fadf1b33e95a1b8970e7961da21625c2cf15bac8697f47a089f44ff1e11d49b6679b804b7e67f308d307f3135761f1f4c5d1dc23c3558eeaaa0cffa4abf07101cd2cb749bac51bd7a9b3615cc51658928d1af37b9ed1ac200d787b9f2efb86059f38a7e294bee1c9ab453e1d69a3595b7cdb62939e4f98acbb05ccfd47e9722f2272c8941db3653bc3897c2c14f9d97a690feb9c5cb0874b4c967ab358a924c1ad76cb717281b9f201f1af5d8c7e8cdccca4ef3c1180b8a953a3370948bb308d6e45a069dbd3cd7771f38f0e2438536f3a9731395d3b62c57d794adeb0422a187b36383e8575099cc9e0ac2199e339513c47dfa9d0fd0854b874b0a8be5358f2d54fe59924a7dd841907628ff3814ab1f6f1f41ecfab1f78382f9f4e4dcf261eb78e22ed3fbb6257b7cba3c2fe8b7949e1746bff4e130ed2fb33f13ee1e3daa62f965d3305f0e5968f0b0e24aa1073997d30aad0eb3c9fa04ed5fbb9924f67a0008836fde2ef6dea6cb60334583c74184e4a95fd014bdec0a4ef02b048ef9fbcd611e2248bb49171be9be65c87e4556cdb51b21ca58a693d5ad2dbaba4ce8775f3aba9dad016220109d616551793822853f969651a8676eba4bce71ec179548d8cb81486be66386e70aa322ed38c5d2af48ddc7668b8b8cbd6bd763f25e4b55df0966d17f6b07d73b00d99316c4d23038cdf524cee0c4440eff9024ea59830162c43002af0909fd5fe039becb3efcfba1427547cef367258b64b879326ec515d70400a10a24411a2c0c738e4f416f9f209892bde6233d5a2171075a9962527dde37375c8d6245761c057a6e25501fef1afb31af6d8f7aa9f0f208cc8a97f7973085ee511132ea0ee74018a2a316d1ccb3d60831a52938cfd4fe9413059a270c349d8953de51843b9c77cb1ccddb2d468ad738f0885e7c0d55e9f1b5ce8e3d74f21107e85e62953a2082cb3a4b7650e3292c45872cbcce9761f789d4e3e130c1187d3643eecb1fa1445c9a65e33d490ae45a761551987eaa7f8119a00c510994abad28b5b95d8a6da6c1407455bb0914c796c294bdbfac6b192e575366b5874320974f9f422b584a137774bc16a3a955f0dce4bc5108f36a7aa074c4184cdf8362c3d1d8d8ee3819d34ee4b771d1e058cd677d33f0ee33e193ab0ec078f5fa2e0f2961103d693ab8c4f813034e5f4cf97db73d4b8db17f85ef4c66049a06bc67d7c4a1fe49b7ce43c8691406600e1d937da7f2d82b19b048df4c6b8638b78c6784e5b234c6e6af60c6f1b9dee7cb0c62fc98cb73d3d9011407235af1ca969063c0f1d57694e04d5a9a4e1637895b021c32c70cc3575c586c42b3833fa093bf4b95a8770fb7cc0efd246e75b1596ec283c493b9c0550941faf4101089064fb368acd2270e85c12425d426c4bccf8e45fabe6142214b3d037793784b773e50b0bfcdc51f1189018081eaa02eef759ff8b7f4fb2bdc08fdd5f1ac21924793124827f966289524e0b7ddaf1cb28a9d1e629fd354e29fc95913c29a3d7af6f807abfdac7e3e54e272b887f3468b5b4cd3b07a066f408e89f7e3827170d8ce84ef99d52bd7b7a373ac629c967045070255aaf52a3992555c7eca1d193d4dbcb5c9a970ead70290908c98aef0c83520a9811f2246f3da820fa953c1bc399df1ff033d7fc99b73be0c75b520eb935ffa9610e4e19103475e02a7e3e989123c9a714a27201d17a43179f9cb21fd5bca377bf30211f9fe7ba619d0884640aae13ff80be1ded70744fb197b4857e749fce280e9e8640d8685cdbe64097db4d5126722084ee93d30e29803c7e7e027d952cbc713fa060aadc367cf893745b69a2f1c4e86fb9087065b3c712ea241b13df5cba84b939e8aa03e8bf298c84574c3ea41b37e555e6463ffdfe7e371c4bbcef1e24760530bec1eb969e2d96c7ec6dcd4238e849a0fef432db99a062cda4302dab59bc77283b9ae5605dd0c05050c6a1a9a2843fe9532780b0981c72b3d55870e09bae3508e03d78eab2265481e0b1e2856e20dbbca2a812bcd1a44103d4cb4354ba620908393147e1acc289a935c5a4240fd52b0fabca054e4c643666866d3e2f7383db42dbbf24a9ff8c23d18788301983f8c98678ff89263f38d6e9e419a5180edc60e85421fc6ace05c7a33aa73055e2a2d9c6e1a737491d7e7dbaa06ef2e4d3ea29f23ed51b03fbe1aedb07d51f2af0a2d975678ec9f7b68c565c3976b12a7a4fcc39c9fa409cc97bbd3ec4549437d8fc6c7d87186c13b60e64d740561e53819e64b6f7ca1230adb6e4bc0413a2d61e77f87055b861fd2db1b9971b61b46d7c711af7ca9aca312e4bde1c50fe7dbc23c429f2fece8ef514c0502d5afa3381b0c87c0b8f5c73d74f82d1d12ac4dcb19c7db21df9d344b7681d6a5f2eed8f5bf0976e5e15a8be30b989f85e18997a6d38c4b7ad54eadf557e00c0cf3ee2a756cfaa157830b37b95752f79d791e98139c8579a22dc8a7a073af24e8b671b3ae323c62bca973bcbec0b6f769637f2fd9c6834bcc992d389d48118a9b9c87ee459853574e92f807df8c7fa56e88cb7e0cb9581d0b9297bf1e40e77bfda1ee639736fc734bf89f06d0c540cb3a609713e6ea3989aa69d6536a33263989c37f3c6b2cfa1def170e0a3f1ee2f3bc80235aecdabc6112c5ea24f095e6948a113e8bada7c88ac6a1b33dfdffe7e0ce2460263a6aad896b1e1a836528a721492bece1d2c5578d1662d5d09fd2c414ec4158b338bdb7cf02a6995a5918c35897cc2fa3718522c8d47cf62252139d0d935b2f938f820d7fc542332cd6cb20f3be707243500d56bf21f1600cbe7871942102f5fc98b42e94a6c974bbf4a87df6b40b6bc274e72d91e5d31e3e9e1abe6c7ead987f7a8f15f9bae2898d1278947a630fdbbf9d3235704c79c74690db279b61753fe154b3ff9e169d9f3916c15fe6b1161d5822fa23b1cff3c8b289fe37b4052075de41dbb7369156969b5412cf227ccc002bef9e413a96ea787bd6c9db1206ef293a05e3a062fac60320ab67b5819428dba03cb6ed161b34745a19300e6ed63430fe60dc2a5f13a25da0e90eae87a3f3f461ac25d624779e13744f5f0bb69a1104cd6b514ca8ddebceafa70ae4a3216410cb51b9f6b58ac5b3196a72bd70d18d5cd9e13e12303bd765327b3b0318ec5b077d566ca456cc948f572fd6ee92df02d2deb2797326b8dcd8cc2723c6a9ec0260d500dadf3f0e2a075a18746dd9beeda9a0b44d0c3a017476002e6ccf9f7a1093289d6dbe9623807987b5497d4cdbfae0e7d370cafcbc80b92d6492ca0e08cb746353d7f350e50e713fc1d72fc7856368fc2fffd94e00d3f405d4b20e1dc671f707950b02e79e8483970b48371fce74e83eeac32b0639a365bf4ff630b147b7ee46abcdabf9cfc5e0ff09163daeff09b8def9f768cb8f541d6787859714c2800f76265f9377f1421f7c5fd7e8a33b3f99eac7695b66fbe78af0abb069fe6c7287b9d1e25e9b6dba68d7f4e7b4885215334dab33f5b382804c5e5482de5e03735c6d19936f260c8021916cb72486b8f8cfa6c56db4ac6991f2403ea693163a88572911d13badf60c2ec3463a4a580eadb1bcad0de79d72d262ad7dab25712395e0b2489dd36fcd173a78b8b6236bfe58deabdb9c856f61e4b411b8ee2ab73c38043d8cc1a9d5d45040f2068e8a07bc537b208ae101d0b7748a51976bfdcf4d111f140c2775f91b9559ae2386f989057cca3789df37cdd7f6e683ee1e9b7d953c7d21b08f5bfba363228d870e26a01cde68732405369ffad65ac6ea10a6d88ef1b4c325c9c768bf82cfc12cd00558fa222a8f8a7a142e65f7367af6193c8d8f051f7a0eff8275a1a38a0b99bf55af2a02feab65b01944404141bf82e750488653346f49eece3a3c63823a80e8fa0b0740c58f8202024def5a1739469f2c44d6ba6aa341aa28eca9549d40dd0272301e3d192b2fed0eed3c35e0d2d8b0f0797b606f8a0a083c73baea803cfd284dfe157da820b9f640a65778d97656ba1e928cc1a9cf5eed8b952a00b6020bfd88f2872dbe2757c5386189eac9cd60c6a80e7e3a7b5a9c9a067caa98d9b50612efa610f30c01c0c36d0fae3788476a57b91d3bb216afb395a715175f7b527cbc071b3f8176f2de1220c84fc9309c1fcf97450bd905d14ea044bb7a79628805a70ae312fed0600396d3eb22c1487830206673114aa7b93a1d43387ed7e6fa0029301a1ef3c348b9fe75a792194e7f7dbc922b918dab3d5b0cd5594903572f8c3ed2844bd6123a314f44e91242dac14f41e94a89f32afb6dc8226c83e677c5d7659a39005407687c2da4d282518f084f48a09807a640f8704f9e211a4b4afb0b4c6ff0dd8659cdd00d5502c76799385dd9d73ca257afd3c53cc326ed5c400ccdb55e0c04b6b61cd438f038a76fab13d182bd60bc8c75bb91aad2ace564be8c87d4645a4ef3a43465855aede4774ef012144dbaf87552f36d342aa8d342ace21a5f069b7e64e02dcc7d0e8ec16fc61de64ec5faba114ef5aacc0d294a59a7edc898ab20af7bc11dceaddbbd210b161724f0039af9fe6259a2b17bf3cc946ff39a76583d0b667ff2d7820577a0e44c2a15e637f5e35d24a8df1d929821f3e4aa19ee03e508d9b40c9746a50103d69e6fefdcf9a9e739115c3479a393f2e509d210a5c6d431cb12e34e5177f6038bf3ddb5700b55b71d9e9b1065414cbb6d4cd32de3ef25f99f8817be7fd18f2e5a418df3826fd18d90eb1196fc8ab8acf927140ee4afb3e89ac2b56fc956b450a090f60796c710e86e9fa028b1a9e6581c8d33378523b1798c6204464aaa4afa2a9b8f6cd77826e3efe686129e9dd8f6508eed3fa934f5e4efd5ac2f4f5e9543625e8192f1668f88ca7dfa39f1471f370b5fc5132dd6edeb4b01ec58e48db643bc8a73ed6b2cfdb1aad33331d702701d4634bea71bdc45623d167f97043d681cadeda4396f8f5d6fcade5de56db0d588739f84f6602b75cf58d5462b8a691681225462219467d45068f5db1874844ae8c49a1773a04af02152ad7cb9890a464ba81fe224828fb985b8e5af64b31c9b8a9af3995781330ecd2b548826170cc8b5d623bce2b048feadefdbd8a879b8695aa876c851f0010e8a59db3e5a43f0de860c952a8d080ad1c38c36684cdb533563eb1c79b1aee8937f9d3f251e2b2ef9135107e65b9b3e6c9f4b105d446cb792b892764c5bda6efe75da0c4a5b9d0d28dd953bd6110724d4ba95b8266ca9a2806eaa35dd801fb7590032e013df4da5c234d0ff71540d0eb43d445bfe65a899ee1c2ecdaa409db9cdec66e10be303579767a20319acd59457fe91bd9ff2c0ca1724fbe34ab136611ba91bccbd4dcecb5e3109bbe3e0b85975c0f4b77ab58176922d3ad7374142d78c2051d99b972191ee76bf0113a1286694017a518db80a0d08d6e57f3215f69c3e72adde3538ceff99b702c511af5d8a9afafb4972b0fa63d760b10ddba4d8639ca85af1ac5f3dfaa2d41a5c6ce4cd9ed7f77c89590caa68bd63bd077ee2bbe8cb1874fab0d702e2d5ce43132967af9f27776a886aad4e7d05b158a3341043838bbcd6f73df355b388b77a2f28fac38cbbde3d687f4b5f4c19bf0fed2f082b3c46115d5d7079d39356eb3d9865dfe9d9fe7c242ecd90962661f338db46b2efde2e378139b33d07300cb2f792780841c14f021b5f620e38f3b875d324d963dec4794d1bbb27a1e12acf4cc5113f2420fc4e9f4301e9e01a83f2b142231ac85e7473b98cf441d52ac6cd76bc7f01cfbf5c5b8f14882ddb3109a98dcd548acf30ee1d01d9eb4f02e1b05ce4083f99f3ce437cd9f97931b92cd14d243da963844741877c0baa4dc69ffed641c58d63b6afb5ee6082641f478918d97d837b24b62184c6edebc0eaa98ee9b5b2ac31d3f5d21c187cab52f66b5eb97b60ed4b4a1636d9c45f49ae6e4a5f33a20c4e0fcb40cd4247e2148ac9aad4f0b182a8390a90b47902b351c23e23ebbf8e4960c9a9a7c73296876618cf4e125b37feb3a21434b290b89aa538f1cd8c96ac6c9359e50473e695e331ccd06f4814095b0d28e0e57039bf020b3d55ff89049f04e29946eae15bd920d01dc2d0ce880865f661ffc33e890e321d120f065a9e18bb49bc707aa0649a4f6f8a9967154aeefafdaa152d520d8fadc157211b5aaee5f16ab1e0444cc0e6f08d936a2ee8b40035102a214d503a32a1d7a557f68dfaa53bb97a2828a9a8043255926a5d592b5808ff8636966a1b04c8a2ba4f07cf7ecc0aef4bffe0813c923d68029ffbd27321e14b058c4feec1d3001ba621addc332f6b19da5b6dfc6187b7e02065f9fe8d209e03ce78b0ecde2cec90624ad877240b1af72acde8f4a7e323d098adbd75d5079e45d60e79464d2548d1b46eb5991eb0447b0a31696b003a6e165b2ee77b1afda336249e204b26e372063caea2bff7d7b7773a21b508fe95c5996e4ea9f134baf7ce4a6f15777a367f223db4be99ef74a64f880ffce65df45e14b4e2f157765b889f5e06518798f5274a63228b62c11408cd6da1dba19f0d7bb70085f07083acf6fee02690698b447f038175eff528c8c6d3ddd0458c8150902d7c07066366ad3d21aca6af0f17502a675f7b047185c28bdd84199236b401302289d68c33bf9fd784c622567ebe2e227dead18947adc30a79f6cf910e8c87c70f00e53599c3503fcc1bc6cceda6de6620077902c5e4fa1ce06b96cfd7622f7d5122d35217ecb772c715df09dd7796c393c987f11f14855462ca3352f42a03e1224c61577d7c45bf25b065f0869d0ccbaeb48b686014333794d96ee4b6001c0fdcae4c1722da9eca7297b8e62c9e9ef2c63575d2344171643eb83422315403e1c9bc597b2d58849e5ae9f56e561fa6b00c08560f65ba999364c57be15a1c6113603e7a16f27ed7f15106bfcde477cabffe657188b7fc76f1225d3eadc170cc15018848f9ab1ee8779a27b0cda256fa4308016d0ee1932055dcbfea90e0bc8bb9d949cef3a73e4b4ce2236ace8df36d298a8530ee9b593b016ed847142e48e69df3c140a41914f3d9f0faa96387e265fe7b8bad106b84a3ecb05961d5b4dbf9aff75e5f62e7f879206ba6b904d0ec1dbb9030012b83afebb8f006171fad8b2c06938b8410132a968f670557357ead29f4beb8dc043ad367588b5661de7e87338b4403159ef14c7550d12c0361ede814d74d9bb4dd35be4414a5e396aa34331181062f18203701b5dbdcbbe8777ee6b050ec29d4ca3fa18eb739c9529e2ae58aa216d55140eb603f3202ef2f18ebd7e000be3d9bd663858e1b6580f6362b700ffbee3d5a10d366abfcdd390c44915387aeb07687ac8bd3783f0c5fce22559299e9cd3df73d577ac9fa47fe95d21a1bc42603ee354e7109a7b735f7316173c24b6cd4534dc68447473a67bd3edfe20ec2df79a8e68c6e9e7a3a5141bba5799b5817afa6885ae7dcec0741f19dd2a80b064847b4ea8071ecca5517fd982c4d6700ec158432dc77f6b09eb17dda48666581c34286290332f9cfa81ab5ba8edf7c860f6caf88ceef6146987d7c1c3e75c10a4d8e99bdac54701445312eaad396c559e96ef9f72f5e13c9144bf9c01549c4cb69ffa830ed2f1060ab9026b3f9d3deffdddb5c83939fe06ff5cd958e58f7d25a9c8c88927f47a0711d73cc9fe5203813d107757c61e018953d1646ca66ace71961fe97139445eca6f1a8759104a1bf39c481881b53e695add45d227a1a132348d875804b0b9350e90efaf91dd9f61e5699a952decf63485f340a1d7d8a525d6a38e763f995163fff38419c431374b1ed144bcf9153dea47e26e784fa6525bcd9270af383125c660df6e2398a9a5a5ff56a1734208950ea29c4a4b269b5691db6743093c182440455c59dc19666307c55222a716cc755e6f0dd6f89ad0a0aa4a1ebde525edf69ca0e244fedea6398be31abd9e299f7fda57d05d8de3b1463d23bb60656e31ef177992959a03cc91dd8c9e37d161779aa871a4c40ef76e9a7d60b93a82709782afd3ea8918d2420dd3622f81f6c9398adba8ff1adb7e920f3a5e2df084985b83c011a0c77bc5c62e9b9fa49968e0e7d34485556532fe27a04d6b52c83ff121fb3300067850d6d774d1a3e3f3b84b2cc6c485264f925712abe49ab048aaf07b937bfbbf4f734682b9fa656b8b42723c26045c4285c1d12be256703b67dcba47a7c946435b22a5765962d26f13aa8a96e7839c268ed01c8875929c4c1e010f67910ffa03bc4b926a93a87401ae8221e8f5c0e5c269577333f8686bdbb9a5e3a3c4821c35e37e703ea61232c9fb84c7edbc34e73a4af55ca7c4ace59d9cfed8c184854796c1d563d155f11e01ee1e8ab95edfb94417be1840577f1d03e58bba5d59e9f55e76593f1cea2d3432ac41e284718489f9844e4da4fad183fcc3e110e656d5fec718525885e48e7c76b605da543fba200bc188b023a064cea7475b4b8f8c67d43d99d08043982340b92108aa99eb7e4e6cd468fe61244c7da82a70fe2f4f85068fe4a2b554bb78a59b30215f8d586b2c4c878a6966e7b333d3f334d3c521c3c605117b64f0c339bb7630317c749d38a616d1ebcf84762a3ef8a451429e4135960db14e05e6586f26da19d86d5e79c3813b6d88607afc7f77a0bb57aa38354defa8d725431cd04ab8bc94d2fda2ddb51cd31343e7c2cc1884b42882f138cdf1ea63eb83d1a2857ba9220890de0475f912d9b823c52b271d54ebdcf81fce783806009a139c17f191879556408107be51063de170157ff1c54f4ad9367558b8efd53bbb3b17a184b43ef78752c88a7992bbe01192ceb1847c9da414a4fb61dd8dbac9ea7473ccacdc9f7b1cb3904a67ef97676b790379a1a96b76f065bf39999319322ed3fe177b419b0dea89e06a79cdacfeaaf516e7ba46580489d60b123149976715207582f80e313c9cdd826b318130b96dc4a204c80ee6fe724a296225c90d1a6fe822e480e75041b23b086de1d3e0beeb081d5d44478fd5616d730b27fb1a2e9b509d3a3e1c02b681af46d2a065d860bcc7225f887a698f0992929f6eaffd02a89ddd44cd7ee26bf144e67aadd0a5e6a4b29a41bb6b093234910b9da6271cfb9723e6bb5cbd889e7826f5a51616cebae7bcc2174b7c5f365fc8f6ece7cf5947dc67fbee0de9be25ec25a0973b54ce985a7c4c7af182a22bd288b3d9be4683c6cc44254d3b63678615dd1d4713cbaeaa49d07157a614c4da3ee9b52d7acf401b8ff1cfe62e4a68a903d60377225e111fc70fa0c9ed179ae8d51838b287a60f53d51ccf4bd87e7e3a875371e629c6db531343f74796fc36f3f18deca509608050a28af8410e31a7629e3f7dacb027c15fca10b7f58b46d25b1a08270d27314ee8ee5cf871c10dd62320e901914b06367a0ef0ffc38caf841e989e0554b16b980d71b34c249f6075541d1ed182bf918f36d289772fe222e9175eebd8a7b157f5fdb88bc14e4b90b18fb12a85714512cba4c2cfb3f7458dccbd4b91c98306fe6eb650dc26ae41c54cf32718197801d61cad60dd85d7c06c72116175e323a95da33837c83847ebf83f3daa9d59724146c00393257bc6a4cc96b5c022527b5574aa1ecc9f618a332cf4d1402247f72e0f6f3713d0bff275f27900e989e9e11da3eb1c466fc7f56d8acc5607db17c5f4a21b6d1b8fc52263dfbecffe669087c125dde0e83f159f296c33ed3f3f1a74d8dd5a9cf672fec9064fb9011ab83aa18fcde5ced1f3a0b382c4b9eb8fefe7f8ef30d4702cd9241fd8251f2b4884a8fe20d58fa313e1e8107be26d975fa7242eb401eb8479f6b2d7bc88ee333b070116decc7948ff30898f57fd2f825064ce29c6bd75d0ff8ff88bdc1691550531906e916b27cca995c75bc8ed6b910a4b59b69a100da29ba0761cad73ed35735c196ef8bef730d17bcfe2f9c4954555fbece7fca73d78d54fc944550edb62c46a23967e27b11279fd6b94ad94d38c770ed6b881d9b61902f2ffa268cb26bfc8c7b45786a6ff904e5441a498537acdbbadf7e075ff06a392b3f5f0f64289df3abd145cf6765cfcbd3e38bb7a9764d2d352b72250aa287cdcb9844be590de42add2e3afb58052f50a3fae82fd5f8800be3bf28284bb1db394665def26dcb66c713480087281b65e795912e12f43ded1840aef8b35e7f379d0576e97b4f474b7e08027c4ae7450d5bc97ccc33819bb21bd895b7a8724092b6e81524ba1aeb02d11ffeec371fe370a47984c804bc34dcc2c6f861f5b3c473dc0dceed07a58ff4c8239f7e764240a5fe8ab507d80dfa59e81b22b2801139ffbd5bba294d822b6d55c1686dfed385a61947d5d356deb1b76f5f6280edd2ee69b66d6e519ff277e46ca874ad65c72fd84a904b32d5c0892691c2b944a2faf3e4bceaa3b7018775489e7d84d972c510948df9bbc39f8fa43296c6c20e2553082413b01569827cb2fa0d93c0179decff4024976676c2499da15eb3508917bbf85256c34ed5bef94ebc5693d37ce2a56d6aff19245b66b5277a81174701c453851a1953eb3800295a2e8c2a6c396d15e23ca2cce2769ec74337c900663a2f7fc16868d7aed9944fd9081f30c76c3f6be8d24b3e80af35ddbe310e201251de33b511f50617a3bf6fb9395088628e4287a835435820add8669e3ca8fbb1f8094e4b589f3bd204adddf3e7f2519d80a0fa837abdf7559bee65823d01aeb5e7e9fc15f1c49973d97ebf7212958a456f28060aad78ea31bb99ef6305f805cd8268eb22f85c0131f16c6acd95e02b1b1e686b3df59f1940d073a484ea17c3096531e851f471af6232e54d1793883cb5eb5d75c09990349bf1f624dde7cc7098f801ffb60acd35e9361df69cd2473a6b47aa39e052bcc35dc12a03bf0e399fa3ee5efd777a94bc2d71c48ab986ba3805ce9dad239e9936f8c5da21f493e63cd787237c633d71b59436ce612e38b75c281c2438f435c64dd5b662579f6c8a5af2c8d3ca8855a90d28f89eff44b2f4514965254f72d0d59a85136f819ac6dc90ac8dfe06303ff55420f6be0ad80905460a05ca8b3d98624cf3891c30edf4e07aefa04041e50afbd385ccd6ccde89139511ac3822edc970da6110d2f4dee628f5eba9966e90031ffe3bd1060fcfe0f0ad18f5aaea2ee9ec1e83e7884ac448585164ba1c785cd3560506bfc6a862ac60832750b2e59cb8f1cb282d3bc0d8983be9003af4cd967bcca0c74123f5bc19a5eecd1b7a9e7f4b1305297f61e0d26daecbba755583cf931611f5e66378f16a99507cc4db39e3637edc262a689c2e5d3d0ec519678b1a8819960b835c13b62dc2a1fc185b6f0ab1f5cc1c3b0f381302047c64326a5fbea992b0b618fd73712ef1d38ff5f72ae5933d94757414ee50de06334ec85068f12896f6a9f33125c7a9b3ad150f422d7643630fa70dec1210c832ba0393126668f83c5e8ae49c2d18ac8221f547aeb2a4ffdfe7d5f65a1fbd20a6fcb08a8a765a9f4c3035e6362626d1473616ab54fd9eae9169a0e6b145eee2afc20e44f713ba894590013a91c154569da5fd736f7384945b65a0e66af5bd9cdc0a5fc6842e1186a48bffcdfe342409980c1061ac3bdf289b3e77b7b6cddcc2fcfaff29a1cf7f06dc0d6fc4fca6b5433cbca5f1ca2de772970ae961d3036b536d59cb7b7c1ea4eaeb8988a4fff4869ff584d857af48189892c6d9ddd03630d5b6e06fd6b4c6862e6a16fa717116a81f2f7af1ed37650787c1a3ae78b63bef17ed8a5f076bd534530bf2091c138f10fa0049899f0e2626edb2f12f3977b74e1c50648ea1cce11b2649091563dc3e1ddffbbcd548840b78b1656abbfe98f770f3c2b5fe6f3b6e6d4a1fd2350d16ab4d69b47ba3fea3c55dae94c628a09790b0b38652abb7a5db6b5e944b81fbf4021ef16079a86b2aedae257e6a0dc661640aae195d0be009cec3a13a2bc11befd76351788218aecb0ab352ca8ce203b85436f0a392439042132a4b066b1e95ac725e48178130436a50e64920d3a0a6a3a379ce4745686f6e8fa481ce3965bc0b764c2bda32dc77244df0f65af1906431ee5daa517809f11f3190ec939862653d67adde40c78da9c4f8bb337122b30123bb4852f2314f405b78dab96edc33a7b718c48e8ac46f0552b823d5c9314d265cd919eda7366c3ae0f1135130a89e550bbe66c0d67a860728eab32cb22b7f84a3248dc7c523fd308fb4bfdd3ef36ba48df89a2b017b5fdfbebe9497b7c6be70d0e2152e6d12a5ecc784116ae84037e7478ae0de67c7020621d7a8e815b89167eb7f9072bb874045126466c28174128b9d4c205dbcf52cdf0d915c502d5eba94c01e92d8a10ecb58b6449b774351fe6e1eaa2410d6708184b66e3375f52350dcd81d53f450c158e67c31702ade004176cd631567c5a097b696060885c88a8255bc111e9dcf322fc75f5bf97392856fb4e2b31dbb5f7d8226fab641f30e20e8080b234c7c20729333aa9f54e7096f0df177053837e323ae71a203c673d232ea866ed772607d037ec3f40054366c66af80a1e17dd651c197c988a65fc8716cdf96182c70154bd07684de1ee7a087b54eebc4cacc20489a77f66a890c5d0a6277ce2d5cedb6b14b08a7d2e168e60bd1282aafbea8c373e3672dd5ada503cf5cacf450bc665330ca5a97eddfcb8449b633cee2a41d1e1164bf4781d273284d33abc800aa02a92432ad7dec4fa273c78793274dbd6918de477538abfef81fea628390b377198d0eb07f48b16dffbd90995b23651916d2acf55ce7ef4cfb97924befa72ad0c35ffe23406c2811ef50bfd3dfd47e195124cc2618c2f49c3d6301acdc3ccfe93d74093f0166e88898f08b235a008d6e0f14b42ea454a24a243d34da4b7903b3f10064eabbfb64c6a71d3ebce3eb451f2b0ebd770166e4459158f132696fab9a13b598950c4bdb123b378fabdba3ebe79a23da500e50ad606b54e3dce3fa9e3b182b6e5b0f298f8af67e210840bbdeba1fb90ebf0a470850126a116554011b476d55f5d639ee3d1c6b75e933e8839f72c1f9aa155c0aa96c14cb6d7d3492a2ef814255bece300c76eaa155fc33b08bb0dec3625a5e029488496ed33dbc51c56a018a259be7c4c5a90611c363dda4cdb4e9b5cb8c252ca9bf49116e026f9f2eac42910b4dad50ad54b52ca7f91d4ae4595722b5cb474759bfbec1d3e1eb8ccd962b0f1ff52cfda868a7aa7f3ff1b10f0df6596a229a6b65ae1bba938976e3b036ab547a311563d3502398458888f883c4e0dd648a3a549a4b4eb060f4b07fd7bcc1b08da0c0e0cd4ce89e31bf557489ecac86173b69cc1ee610a96bad19e0c1f93f25dea911b7ab9a4e52b9f291d64cef5f0f02d166147ef0c49731c2c54a614831c9ee7f590c270b14128e91d63ac8fa0d04dbb41c22e8a01787a2d6a65075f80981556bc738c227ee0906ef329c92bc6fa95fdc66287ad5e0da90a8c386aaa3826753f4d17c954d281c09a4baf2d5a8cb72d3854398b768122df87c5bcb3957ab5a2ddee11ea1caac4db22be921b45168043ed30960b6fb4f833b89a2c9c49ec29b71b862a381e6b56c9c3b99b147b907bba7e9fc637bbe855e2b5a7415646302ec028934c865cd8efe53834d3e0724b67684e0a356086cd1b2148062b103298e7bfe34bf94ea0997c35bc68022a5f05bb7d21d8abc357090a458120b1384f42cad4b2c8ec8d2ca5c9eaccbc8abca679bd0fc6d964a5f807071795eb9250a63a6e38df1e92bfc00fa5074690ea5cb239ce74af13867a4dab6e77c01dec4a6ac90422b119113731ae5cc9208ebfb22c1d8fb85a01a85908a4039ac3224b0afe48339ad1dd0091c0408487dd4f4f78e0fed8a06fb1933a9d293522adc511097a3a025f1189b2b63b6365bc3b47adf5d64c27c9924d02372f996353c1f1782100ff04a9e9de9fa29e43ca735641cd17cf978f878a45ce4eba44568810ef3adcad742ebf3a49e141599c6a5518c0917d91ddccdde7ccb6e911361113bda9a2ccdc111f7cac688062b4c4951c00dbea0a19fffb084f9f6e9a7bf540fcf97c138a739c008d4a7bf6a55e5f228831ad850e9c63b5978e75473ca5eee605cb02f4aaf8beda5287340e3d4295f491830f3631520ff68be3d2c86cb36a4e7d621f6083a9d4dc6b93f92d2f912956addebfab8b4c9279f40c4fb8b5d2c0f904d7f362b28b58a114d1a451c5c6cb171eb0ecd77246b7b8114e7c1b4cab6c21b326de70a750da84a54c4003e39ac3bef106da5ceb4d8c3ef70b554bae9c9f9543d81f356ad6e422df197077e8ce20dddfea44f195fe076b47e948bd10a375b80f23d1fccb1cfa1af6f3017703dbf8aa44462a6f5f62d4abeb6977ba91b116460916360157c1e8a319ba4113eba7ed58a126020c05699da953c6078cdaafe83c9be9d6bd6453c9a2618a45eb3b33c919c4d6a032f03564015c0f712ca2b8b09a86adc15ae416f3ffa7c478b1848274f85376827a2d8c8146dfbe808e4508cbc1b995f72512cbe5a285d5776e35e7e723ff1cd135ce5c04c59b0777f7183c33bc40b0df4c2330b1b3f2fd1e41b103a18055fd4bb6b1a7723a933a76cfed1780c10ea4b4a00b02b12d7330218e7a55e0ff5af797f98e7d58cce97bfcda31e46cdeac4b0f23d8a067b4b677600565110d1881c6e55cf8e26ed4545f5ffe5798d7d586dc0a14b002a8951bbdec84037346c100c6016c7a86eb00580d6b645cc116ddf6e8d2792087f019eb3a6d2b5f085b2cc80625dc03710db2daa083f609527db5831e08679d801aa0d63960f6b165de3ff37dd754058d707e201712df93fda738d5f9998ba86bd41b76141ef5744f456a3715ac389361801c1a4bf6b39822a3586644082a22eb1e5b2bb6615941ba78bcc7573e5faa0271f1b5b5d87778617b00289fd1b80bd4ca11633bc3af932b05811ce54efc7b463314687abc3ecc825c9624f0813c09bf2babdaf0c9138ea34d5380ffa195b0b72bccc784908a6ff678393733b5f041437d32ae1eb5d70834d3f87708dd147dc7546834391bbe8f55b28ae943c01983386f2db77da4ba684ba0b1f7da8fa71b79551bb9adcd768809b3a7ad9a8af317184061c2068207454b880e9d182a3b41d5bb3d1a014e9133a365163730f7cac6697bb9a4f98bab20bc5fdd81102b2971b672fee54b03b000622e43855e478a830ec2135a5ebe2effe9dc56fda8ba60908634f0732fda3c6a8667f568dccf8849af22586a8098e0c86bad46ce8a53e0433a869b55965ec33edd1928bdb75996258dfd8be55d3d6a4d5ab8362acd8e02061bff6222717a5a4dbe769653cdfdc2b493822604464e0b0af41b6516b38466e91bcd0214cf0616703164b3f097d28c0f7f1c2187d8c43e2f7d29f7bbdb4d5b171d831a4ecdeda44f8c988dff6ce396a8997c1a5364aef370a5d79feec4cabd915e6f59e3cce98ca24ec380fc885b8c3a19e2221c933b5b912f9603d92881e64f907470bdfd821b6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
