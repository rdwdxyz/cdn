<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9c4d3f4990a5b442baad73021dc1eec32b7d9bc4e23dfa1dda9b5ce34a555ccfe328d41436eb8ee65c9cc848f7c2e91c9e8c02450bf880946d1e663036a6b230df3bf2080c022f65a127cb967ba89aa22ee69331a97e18aa50238455a86b5c252dd3f37595870a63d82a5156d70f5227b56580c109aa72b2b7b8afc5f881d89e051eba6c889cc71e14d88b33d5c96759cc34cc40b61828911658e5aecfffad21423180d124dd239dbbcf64c430ca1c85a3eb2922ec5949d75a0929536aba075f99083a833961bffcc7fa89a3621df27488689415aabb190b58767dc3a1b62ffb84c9771ef261e382e14c3673d252fdd6f57cbff0c8eec0317ee26497837e57c0d6e65664fd9df10665e3853ac2afc63ca79c4c79df774ddd7aab4fce4f1ed03fd20704d5b77eec0dc8055a9187bbaa137545d12ec345850c753ad839f58a785fd955b2d67f5ceb6f002ea70255d3c2ccb06eefbf68a65671c97d77bb3ff4fce7814dbcfa76f345ebf2b3c82efeefec75a64f39016539c587c4589d39ecc835346d57bb226adadd8463ebc5492fdcd0fd9ad9497bb317cf4636c17fe36257b11fb94f65b00a647e7ab4be3f7997f20639d581c8d9b828e173b69deb3b79afc3706cc57536addbcf04798f992e7657be58cfa0e06a632d41e3f45dd868b7e7e5161c73a9ee5d1b4ae01ab3f1c375f51fdf43559c9b98abd52c4eadc4f4413d8dbfef8d5804d5f61f8adc852720622d509dc234bafc4b915658e48d932d82358b2e77dddbca9a4df75ca348b8b560a4dd9dce9bf09b22f55e97af4def94cd4550e7d9b6b4ead05f7c6e6012bf6f99036327567a72540c686ff2196cdbb9b15c561e35290fde537e26f3e34a8b6e46793f60b837510d958fdc615aad60a46643e56c2c1f348e1135093f60d64becd9270243f5fabeba44de8d2c08c285a020b1a79a6d93bd85a5bc6595e5e1208687c3e02886d20113ab77b98e3f0b355153bf3c040c45caab1a106e21b1e824914587b333cf7595022449464d031b1766728bf2ebece72af4a20434d7f7ff9a9d2a6ad537dd5fd7815b8c38955952db906fd91058ba4b1e24aac7b4e542cf34a53b7d6ba11ec25bab73ec3d1d12e3a7471423dcd1d17209c464b98745f51641c6cbb265f688b44a0b765d957688b80c0ed0d9402ee96bddd9138ea8a626587db7c971818e4d6c94c1adf187c600da87b7963a632c963e304e351bb5a2b0d6f0ec5d510541d4b5a86a06c6d790bd0e09dd8494ff96c1fbf80e707f87f0ba7d161c431ccbad11ece066a8efb30058c523d3047aa5333a1995d2e6e8850b41d22ba85bfb31f28cfe0c326d7e77dde85eb9b5a0554c7b3f5c321f7f324705f49b209ba3ce3c548f44743a66236df211961ab86bc352ff496260a3af1d87feeb9b13503c05602561a45795ac8482ca2f21e9774ad4a8465db90fa63b654a8bab4dbb5307eabbe4a41c8e85a35a18a44db0883ed2a0d80bbd6ff2dfe311759e505d42d2c038259a5f9f243f6c62e3147ebed3bd4edd24369ec42c4a3e8a54e118bf9a24c4bfada81b6e5e0f21fd9f0221f75d8e4844156d26b0441a14663292da6f70ecbf5229a128cee940f6fc8ef33feb2ef10e81958d586eec6d8725e852be9e9be8850942a17fef6057eda70096c8783adcbb8cbb47e3c759bb44734ab6195404c28993bddfd395b4a999355d20026d214307d0d0467943b7eeaf00ba9cba7830744f4eeef6abb5bce06ee77f15db98114e42335f17408d6d26be93d103b217b53a997a8706434c39ccc71646bd3c1a72e3f81d03bd6d9cfa61ef76ceb80b7581cc6e1a95e0407125e7d071ba2dd82d39f236ffa0164a81cfdbb5ae9d45abb79a295b9444484f5110fcf98f7e0701d1f33eedf80156063359ccce616f835951b1039f6cde88f00592a17fdfe808b42785509689a54d7966e7d405d5230f67b3a422d6698b9324390eaf17932cfd8140718866761a4533677f0ac1a512ac91d16ec4818be2e1261fcb26e5e9e4c889cabbdcec33713a9ed90927c7f77c66cc5791ef2b4b4eba43f41da2ebe80c40c91dddd7c17e8c7fe3d6d7219d9b70ffa8520238acf01499b70ff39b6b0ad9e345dfde455057a38b902e9f4d2b173a3cec68da42c61d7017f3db4c94602b259e241c600f41162240904e3aad3b3254407c1d003fc13927e251bca5397bdf2e05ba10e350d580c4db0114c545efd7f4cfb60593cb859352d7198997341b02119422d075bb19875bcdcfa0ed5e46c9cfcea76530e760b7dbf32f06beb80c8a6f659afa80223729161820514aa70c87be88e0591afe9b11f0eb03832a4d37ae1932e8cfd1644900e28bb704e43256794b5378099c095fb8f29bc785bd7c467b805d754e74aceea2712eda93dbcc5ad5fc0749b45f140f3cdc47920865ec458466a55ff72e1b8d42c980b61647ccc8878d153e09ae3e490c523a41f8627492a43da10565d3bb9482e4b3eaacb229bb6285c6f52259ec2fe8962560baa8c1934691049fa3750feaebff295c839f5ba9203df56bacbbf8f81cc47cb31029592221b5b92b59797457b9f778c459cdb0f5b3eeaa7166e0e812d939d4e93094b610b2b3c2d8ebec01b892a512d7f12311e715d0c6a95dd798f854ed73efeeec88a7c7826064a870fabedeca26f147850d4313e7e17ffa6f707d2a20f2b8799e03674088a14e49f75f65bc386c2aa46d868cbc9a5a4441463ff622d8fe0bf17d45f766a7a7a4527a880940f89ff64a39e856cabf9103bef83d22103bc6b05541df6fbee3595ba63834de4bf15ba99274d2a63da0057ee37e1b6337274252397ecd3fb6a7968ee84bd60b0917f3ff39d31383b2098157ae3acb13afd3793be1864b324ae0b8b0529e67101d7efadf48be668b92d009349077339575bccef3a24286036b18973f6dd967c60e680f057772dc13126685392dc3461a621a077f283c9f5d15814dafe11ecf299b14e61510cb0f381e88b75facaf315199d9e63137d54b7cdba394f7c73aa9c5aa1d697b48fe438c8704072bea735373ac1737a925abc4ba8cfc31267dece0ab791e19a3e85e17304898bd76cde807515fec1e512d8188498ef32fb60e9d3b4a2b0b155b7acc721969f45ec7fc8f567c075b6ba241dfd10bdd2acdda2d182ae59b79f75f8cc8d4c2676a220b183e82fcd02010201a9b92c40d06ca4f9c29b1a3d037691ad35c70fb074566ed8051ad71f715a91f4a48e80ab9ea0a5276d6729077e817d5b21c8fea195b9332a69445b8b3a2fb582b9cb52d267fab3c53e95abacb6b2025f2c3c5768a889b910849cb991d23bc94b1d6b96d89ea0616f741786566782083cdab2381a0a3fc6389b0ffa0f3ff2da0bad330686bf519438ac2f3e03e99a0eff3bfe594618407ba61168ed02c11f60d3bf53f5281e6fd18d8f8ddc6be235d243c4ce68cf9bbb0d49e4dafdbbfac981bb8a7450c9463565f16932666345c8099a196bb9748d56bd3c0b674b67887b54a4ac97918343cbd6c5946d9ae27d20e2634725aaad662a30efda02dac86684a9e9ffea79ac6424998b65f38cfad506d8d658b72d36c9f9f46e8ef4938b307ab44f7af80f421e69ac5503986352ed24b5a2a05b6a63d997e5437cacd3f71b639b8c29d8b526e0e4b8b73b6a2fa3beef12715291e51dde947f20500dd32951e0e9f0f73e4059318e22fb2ba6b08918afb1db8c27a938877d8517d4806fcba43e1265aca825fb4bca49ed81873c049f43d01d0c5b931045b08c26e72472b9287b6076d5ed6983c8c7893c6f1d37353c8895088b79788c3e953aeb7ad64a2778d345977b2f11f69dd9a06f0c1bb998f29de692697fa0c93822540afd5c60f954387443a57c5cca8e529bd167798b5782e53fe4ce19b76892501bf16f177ae43a96eacdbb63445c7b69a02ff4609b875e11c732160d8d53db22b3b6fc4c202dad07213ca029f9e570cd3080a4999c02eb328c5f49e86cbe5530c234b2cc68402b295bb8aa299b6c1ed34a57d6ab702539ddd9c9d9ba9158b6ad4bad841ce0f60a0169064537229653b4c71d57fdbc3166e033497f572502ad71f5ca0531db646f1d3b29c3fa544e9abc2a5b3a3a72e9904a73c48476c0d4ccbb9d6d4f3b21c665d9f65c88fc1b11d847a486765308b3bf847b9752fa152b902e4af11bacb83e2fde524c5f5dd46f78c636500766ff9ef96c5e8b1f4a1b4a3fcaa2e88eb1138a232ab4e1974dd6722b0b2cfa53a44962125ea08d45af6f8f0b42c1fca0fb881732307497e3dc7f7a76211ad24fe982ac35f78a0f7d0d170079091aefc746ce6585be7c6df4662d1fac5bc8dc62d6ddce83828090ad0f768729ad536167ec3e1cfab42d1a36380853fca27ab42196025bae577a07f427a6c4a78bef6cac2410dfaaf9fdf25d48d3f6addf33f3228c86341c53b3a62df6e3c0cbc610ddfb33d713a1c24f031299020476cbb0b854faaaf24beb9fbc014dcbb164959b6653ab20e556127600810dfb0a8610e5ba5ec9355a2aab89856952bf7df156ee983dd3f25bdc5d8a5020ad33c70f2b40e628f8980266e80f171ffbb42deee2682fdf125438e31569794cfac7308169627079462b90343111600be6adafdff8203f4236adb8464c116e26b09091ebe9bb8351129dd4086676396fa22f7b514efa074c51194f5603da47c4bf2b21ff8b34e3d4255564e323e603e7364ad580423828f4c6f2997f6cc70a881efb485bf345ed399d67dfa3efba36f73b5581220f9c33a2eb1a7490043b4707ba8dc01c52dd79ed9a4209d9c29636460c601c77ef9fbe491ca220504ca075227966fbdcf3a34888a5233d4e44a4781a40d488d110852f2c80ad92f1b07d241afa547520b2504d943265039d130dd3249ddfb522cc493214986c303f06bd826cd9a5c8a9a29b64c12c8d1629470185c5b45b7632365c6a27148edfc861a419e2e61dfc3263fa05fc2e6f195851d51cecf80a9fff55d9abd8103bd38fb57acdaa6db606bf2708d7a10adcfdd0c9d861a2db519bcdad38ff96b95ed626994a6412aa34f5d8b4b712611b794cfda4ba420b110cdd7fc11cf90dd99af67dc9a92929e4de2cbdf18d4d7fe1a323db3418ba75a1e15c3bc484da6d549a1cba859f85d23d316b6fcaca4d2c8006faa99d3882e027e8f722d8ab56b1412513a1332bd4b9f4079b4f8d3bad4b8843cb14f16d23aa398650a0ce297895e7ffc06dde3003815f556584aa99e7b5b4fdf3140e61f9e6513224588e092d38e6eed42fc2061041e31cde1520824b32c28db88a92edf3709a4568b117dccfa05427f1e9ff8f2bbe43e686c8ea73bb833542022f50cdd404e450c469d97a7107cccfdda0a14f297eb08330d8ae696e01aaa71902c09832deba654bc928cad4fab63b6b02ec45bdd22d1ac512abb2787c91cd86027c8951a3a3edb98b822592466dcc0162bc663d56a527ee57d560f781aa92c10b2eb7a7f99042a298e222464874b7a51ea944abcef254d1964ef917ab60f9e698a9a6f48a540a4c6a12288bd22e18f40d578db69254ede33e744f05931a41213c4e07ef373e3f66d3718aacb08747144ec48c19fa5c8c89c44baf1ea0d8bcac8bb4d5f509336e67263a01bec36be86a22f0b5367d1e567bf337d17963bc1f7fe48753a5546b5844e7c7d7e3aaab4f7a863385f3a80a18fecc55549881f366d353e458ced5ee334f2054e87ffcb8b3e5a4a51ace024e06c9307d0a8f9b7f1bf5faf2b7eb1c7702e98b1180fdd40e157f1f3663e8f3eab16303b7ee96a822f76c2af13e26ef6874c942df83daa9798b6d3fe0e5e933304a05a1ec49ede26e5960681bd1c1c9d1d3f542c7c0575155be3438158a803c75f81ebd0c7cae13379c810f54a7c6cfc18b841bee38ba7ad37a5b7615ebf42f89bf59954276262fd9a055ced94e73fd8e4f002dd913994c3d6727b72af0ee189619cda9200efc80f8808e05209ac3190148c6fc81ddce1e9ad9e0ed8334dbc888b0b98fcaa1f5570e90afa1d758ba0322608f9a4c71f8bc74eab8b771c009e9546f2b339483086aaf43c9b8aa1d4151f5c69b3a469e7b879391cc7319081c5c062a7ecf7972329781b0a63454d5bb4192d870961c2921db7be96c4efbf88d12b6d016288370d8f85cc27f455ae8b4b801edae0f0b36b3e44cc5c23055f19ab8f75b1f708c646b266392b87221ec46c4e11baa459c6167126ebb65258bab4aa30900f0b9ad9ee52359f28f0fd31ce4431ff41db6e0ee6f474fa6ea95c2c4521ec6aef361dfdc6e9cc3e2a17521f48dabb8368bd01107a7cd8ec3ecc9deff95ff66e4241a22380bde5051a0644c97bbe14bc44fe488117546197ed153a7824ea880121f677964a7913099a1248025fcfa09f2c72f582e0aae572b2a414666748030b890cc61898d96f7068474349e3beb77dd20642b6aa6c7824da8e23cace2256318b96435ea9a02cdf77febd3e846403e5fb28444014cb6caa7f5f4481432077d67eda4f96c5239d5628466ad3b156a15b8bd358666d3781c19695bd0da426309843472031792061a0ce28651fcfddf4375a4d064e4391bdf41329625764dc64ddcdd4fc361f6f7f81bab20f70e1cb116d0eb4cdd1ac2bce1e7e5da5424d769f4e88247c85a17db08a9625e2d1fbd48e18d681f95372796a2191cdcd9c1bfb18396afec23482479b64ec10749584703538510c92f8c3991980c682e019a7a90aec81a970f79976266716508061e8f28aa4054514364cc250c60071b486fb68ebed2f0cc19356d23215d287cdb502b64fa7478e3387e6283552334c9cc27cf3b2311eb3b20f69b889ca16d14e6fc60127cebbcb9dda64cc1d690bae30ca9714f82a0ee8ea3173af229fec79bf7b58dafe83748138713363416eaafc0782d2683f8d0d9194010656fadad9c33dc05c431bbd42fde4ffe8fc9a40befccccfd1d6bd7f30bd9641dfcebc8ebede047949c3d80f38fa75571cdcb57d377753464c9b20326bda82646ebc9e631d6f0276b904ea8c0edbf4676db850207d17e5596d12bdf66c355311c70ca54d0b6ff9f46a3bfd67a968800c57d123ea19d73cefb4ca6524ad567dec79d57cc0b4623ac928d69ef1f81c50f6bbb9f259494cdc942aa97ab3172a77252ce3353c629aeb588d09c78ff20319717dce476897afcb5a95b56b93ffcd5b1288d57dc439f966c82fae32a40c12bf2525c2d3656408ccd415c8fabc241982e97081e73a88ff28a5619591f2dfdc099d1fc6363fed8c3f87a6b69aebaab04ec985ce4e500df43db98aec5ba665eb7c442a76ec27d0805a8bf2c9e181d000efba1bacfd9e23014c8844e1005701d7aa1e5b8a369eb863de2d4c77a54a9eafd5a09d5cba8ee45464cf3e915cfe4afa875799f95d7aa6c118f506ac12db8b6ec1ef0ae16a5c7ffd16631423d84339c66a94b6e55ba478e70ea285c426b27ecc59b30d965a3c4337a3443e01b2feb29d0b1f5362a33dbc2740c6b3f2633885137fce2e2222447203d86179d97fc881d0bbfa0c0077acb40b3ad61782ba3150c3c1dad7f3cc6aefd21422f38ade4e3b6dda640233c745fb3ecf99d77de4289fc6bf893bd7e7d8b84289678a72741b16b14234563124dc891edb4ca4586be3d53d1deb2873f7ec9293a534a509dc3321e85d50daff5a2c7efc7ff39b3763b808303a61bbaf8bd9ec14310f42ac04d8dd5d17a83c400ca04eb5abb38fce1da3bd26f51830b6e2271dc90294f128cdc697cb3e87804aa344228d9902dbc9d54d49ab9f9cc8938b47e79927615d4ac97fc0a135113c7a19cfdca63a1002d43204f24f25c2ddcbceeebcb8ede30b9ba696a2441a1e61c60eb6331589c26acbee1b334994ccf0848ec58f682d9c6a4db4499ba18bf8e705a29c83258665f8ccf50d6f1775858e5b68eda8804e007b70d26e27667857ffa7558bef1154a7cfb0d75046df983ca34f2078f12ef579a61394c70d58f4fdbe3e5d013adfe6ce369a337d9e4848a151731a4dc9e67811588b9fa8ade59c338f13ce57c58d62fae766bf5d58d24ff560eb156dbf5dfb6d29729aabcd8dd761ee1b3a749c5e2884798b5246ecd225055aa0b44f3b4499a830d96afee65d9e41b45a3f65ba38fc8bb7a1aadf1287c297d4c4bac9cf635c3cd089563eb29f34f3e6ecec54bb7ff45182a21a1d0df430d6bc60f454c27e0e01128069d991bb882f16c1f1056c3bf51ef04d5f11a21105ac8d855e3e4fb9204a03f77c3dd83285b938d98e1f2c2cf446eb61973cf1253868c7e74fb68148b3ba0ed107f27747a29cf8d8fae532ee4be01ac524556eee2d819bf1076d1b258e7f2d5cfdea8b4c42a1b44e5de0853356b4577b2c97ab587f675720e2e4f7b87c09f7505a529c9f363d5da8d129467c6cb7a0e15245243ec3e653661dcabb315e41d0e047db5252f453528867247dca97ce645b7e2e238bc1c53ff658a79c356acda54fb2062226a26220d37dbbd58bdadc1032b3b3055eac466d3d047148bce5d595c243e64fa8a701170efed2c0a8d0b37ce3da4d74d582fe9ae93d42254e5dae7986d04fd1e646a828fc66ab0eb85daa7e325c416ea303b1275f8cefe4480b84d95fee64cccd766da2d3cad21160ce9b3e0a4f3830ba000e665885ef93160e471a44ea741dc3f8f72cbb0a61d965b6a35695417aac61c7f531854e86252808d7af94a5aa68563b5b934286ed1c736a6e5c087b8bc8112be64ee7e4985e90609294e7e1b338b3545cfb05136c0c6377024195903b3aeee9c817c6c072db639eb91407c02b9931341b501f7ece3c68d52be6bf0406d58d33fe9243d237343251397a38749548e15b0e8a0c6c801b2d945466ff507c2da71100ea5c76ba01410310ddc9b9a8323db02903d4e244ef91f9992004cc324459a70a25353cf8e6c033f5fe137e3ef751502f23819eba918fe3a5ffcf1d303041b7ecf6c07d0489bbd5a4865c81d74253636940803613a046173290b32a4cc01e3b4ce682c292477056f403ae7943d09e566a6fd1572f25ae8651ec25475da37633bfce2147ae0d8ed033f08af7837678f5cfe54262f2583193256c866510201d434c5ea5a7dc50141fc858530c731c5bc6d4685dffcd51fcc5bb6bcb9d8c0f07dd953565a087d7e35712593882fb81d777919e8e916d2f0815f72199a44c6fd2aea9648c9202273530d6c740b7e8e825288698b9bbac65553500897174fc3cacf322116abc752b78ce324365729bc0d8d8229fd270d68eab5656ab9ac43d0be0c90a86ca28bc80051e9c7c72247b054eb331db377dd7f95678d04e04b01f6af10abb18ec6c4d49a29af68e27da57692b5bea93cbdf696150b2ba6ee7738fc440f29b54536286a96228b0913b1469fbfea01d19c380e9e2883ba123dafe75ebdbbcd6630b0866a045c0766406659fee03260aa9927cbcec234f831fbdc1aeac9e6ae92d92ce712dfc565438c20463d3ae4e4d2a9bf685f3256514a337de053518e78bffad7e48da5466b22467f26dff2c8d23935630a772a5cf8616fdb6cb8d3fee04e0c387a0c6ce1a0c9e2cdffc0259146034fb4c4139478ec057055d4eaf40444fff4f83f67b6a964f31774348ee33f769f18037e59950c0762c42756d821cb1e9ce410957e02b914025e8957ff47244a08a480aa8762f2eb2c3f799b9fcda5e06836f2feb19566e64d89d8f3a20965bb1010301c4f9d105a822866c9957c5a0a67f97985dd100d053c5811ffa43bb9b0730f1c28af73c6dec1698624e131f2f3515155c0f722bcf30832f42678a7d9e6f505f60ee68fab166cc3c79ae43a8f00f8c58b84ea7fde9def9e4ad10befa296cda11f7e570650f029ceb0b7617dcbce91dfbd1fc3abb57439ac48a32aaaa4939958ff4464739e14dbd39dc5b94a40f2d5ef881ca8287c73de7754b94791baa482a5666fe4c7df4752faea58f349b9c0b7442b7551ae4ab1b952f06ebfbf985bb6cf5ff0e91f710c1ac8f4d83678f4f44ce195f49be768501852b737942e7824bf1c28c294cbe8e65efb898d34efc57ecb013f3613b1200fb50ad928b697d15024a77487cd8ec28bc186b212bd7907dc852f3f53524e271895bdb68874675477db3305dec065e7ec193a06b9c48fb5067b5258eb170ebf6386db3391e2424967896324589d8f57bd2351fd4e05a349b32764fed9f876c6eef5251da93dce477d93cdf9b0583c34d80bc41c0956fd5a312bc80f1e5f0ed11680ee44243690accb847b9294e5bfcd3e3ec4c8b323f00d06138e52e08cd3806b48b69a307b3d8a350caab8670370c31648d64892ccfefc297068fe99cee00cebc727443169b3278b4669ccd2f55239e4877eb108cfb5c090df201cb33f193a98c08edbe8c77d16a57d6536e7ab25676de46f6e4aa1fa89be53478c6082191dcf5a84b876232609ed3ba8c76c319ef3c5287fc2b988c5b19f56b2faaba88ca20a94b30f0bf2e30c0797af5e829e0a09109aaecf1a4582d63ea8cd87cbbc4016f2837e52ce8a80837be5780a5ba1fbe7a5c4b22f6d69edcf5d2220540179dbc271d71860fcb90ab198510e11a46df4b06c4a84c14dd37b088a453cfbb5a0371d6336e5f8834c0393a6bbcfe0c48364423888f73a7d7934a28ad52a613bb4419701b3fa8e40383c8c97b33a5bfd0a53cffb5845afb98a86a129debc82527f99333a990cee688cf1c384adf340db0b8fa29b279c997270cda56049d721b1a4ed558b82b86a2c0c071a37455b572005d24f767e132a02fbd80140d542ac34fefa29892f3ebf0b8a00d9cc9723b55e7d67340c272afa425068077658741ba0fcd331ed4fcad5b526bf3e9427f44d1998c2241ee7142734b7a8a419eac39a8151185e177807f3beea0720b663f156dd869bb53ba0d75377dc6c3d9b2c149db90e1ab02b297cb410ec26cc4f0d70eea8eadecdb61f341db3b910dd3c79d8efba21b218130e4610de270a64ac24e2a940627a4f21c83b405a8fa611e302d1c9abf3fc80eb93e192888464cf12e9da2d41cabbbe02a7ccb65097c07a46e24f427d7199644f6dac404ab12f96d8f860501e33164e16e1699e10effaee704c149487d3ba00efac572e8a754faedceefe146909b74cad2256cb9aedcd7a937a84fad7e412243df061bb1a1caf54128b524f3f1112eaa029aca1416d0c86a14bbc741112ce938e12420bd209ae501f238624ab8e3e86845687be7d72bb2e182f0140c0faf47de69fe617cd66c7de55b104095296d6fdc0e123f4d39e61495ffafa90e25fb12370bc64b928bcb63aa72b8b5a45cd8206d19d68d7e7355bdb958ae418a4baaf391a7017a81b6dc64361a47e53260e409d8161a6570a28916d63588ce3ba50696d253e1956ff638a4f8859ca9f537e9b67214544614b8dc56ddf4c0b439cd5f66fcf4bef5b54764758b103344ff9d48e06d6c9f47e4f1d2c316d1de17889b717a704afef409f18495c6a4b787ede19e9cbe03b1e04304b01acc55c09f440f07041df546efb04de644ae55bf8d29e65affbd52bd87c9562a4c58bcf76993f8a665fa7e16521375eaf415f63e73f7cf9e4ce9d192f895a9929daa99a311e71c572041e931715ec068f1adc8cb8b94b785a7b5f65d9e6f740446f584e84784e063e3c4a8d9ace849ab22de8a8a1edc7486dad44a3c0ee90eace40a15460588d3b170d1b4dbd7ad98d667557b4d89847c32705e47658b2d73885bf4a4fced354c189bc167a2b76c65bcc4712408a499143d03074cd4912b88db77c11825854a7d7f1a2ecf8cd37488f4bc9eafebaeb4af9058596466cc126a30b48913655e25d46bbff7aa661243c59c504ca66776b66331230a8f5b8b73888966f87349d712abb21a12b2db7d339137ff6e23dbe990ffbea00c43152aa0b84109d2230da684b7efffc301bb1ad3e157ee4946bba4221ba3cc6084d66ff676053ac4cb248788154008c9a5a860ab968a587da69ff35e271fa1ceb1dee7c6897b00e7de288cecde7cc35c1490eac6027e4e585810fab470d45adecc4ae627351b6f5487213b1e1a88b808f9a739b131275b153710d73e501805746bfdebfe51d056af0325e4951c5c5ec8011a8bc4ff90a0fde1efa5563e241a6b731867895e4136b86296391a63daa8912b3593231efd405e61348f9e678c67b66c5a19b44364435dd6fee4709666a2ced37cfc79a04dd3b78e10530131238618f225caf0b632be24ac17a6728e114a3f142d71899465b5a67b4b456089d5a52c971a8da67df8af35b31bb7ebb6d34171595bb9f8ec26c829fdbe54d393fc8c4c6e0344faaee9bb37924434b8554a1320f0e3fb0e1f705adc5405565eab3516e92751edcdcddfaa2464bcad3b527de88427fa5726e15af1adda19186e90ba1de6eecd8876bf187fc3b34d8f8930c2fa959b9ae226ca842eba4bb48793546a190df8c8ec361b05aca2a9cf9e58751caa8cb6ed6c1dad8cc2430de6058f187eccf473b95c59c4022d60b9469e8959cb197f008ef837d862843a3621e96ca134fa4170d0040ac917dd2bad9fd7c764b8b4fb5cebfd459db0bdbd9d3a741f41fbeb478b3c69408b735836c1b3573aa66b7d3064e73e695c581b3bd2a0302abc32976b3d14914218b31ed3e40d15ef0938073adc5dcb33578cae01df48989870db78b689e494395ab93245415bc8f0994174f29c43bc943071226574ce573496d12e3e496e3cd69328f331e31136cd493ba92009f9c7d1f5d80e0243d7c410ce7970f64ee9b250c13ceaea5e996114dd582a3e1606cd8e46c319fbf544ebb252ac373ec584d79f2b9afb804c60fff169fef6213ad1dfc05608bc45324f8103ad621c3636292f19d409104a40f3593d21783a0e21ab2e720e10a75224124181626a85259fbf5e455bb8f7579bbdbf422d536289fa3d8d60d0f207ca5a51945795f0f7efd38d63a2123d26e38f524268c32e1af0b25456c2757a135c85213b9df0c27dcc2f26baaddb0ab5e46830c9065a67f1d414f774dc05fab75cfd9120f0606263ebc93a5ae180e39098c3c13931bc97e06d2a67c8142040a79135801a6d8b19c4d4b772c2f2622c8826ff544d80d0b99765700c2a81042096ea6f6ecef1b4b6a0cd02bdac481adbb47730ec955f3e63aa6f388d0e2459770c658346231af7690f94e52581c4554a3f239861dc8efbf598d298383d4177cf1ac92fcf787a5c2ff52f4fba34d36bbc79178f2bbb0fd1540a459129aa5b3b5637fc8ba3cca6761db8cf4630da7a7ee11db40b9788afbf3baf11527cdd2ad049e6ae758de6147de6fd86f97a33c351a92022b23094b2a6d9116769bb1d3f412a6d1330d36e10f0417d28ef64241d6105e91487578e032dd982cecec2a55af68ba5d565cf56d98d1b504a3e70cf2d77701292f824d059a6cdfc7e14f49adabf3392a457ba22deec96d76aaebd9e70b96b2bc7c90fd90bbb0634d007a71d367dfc294d67b6d0afd4638d9dd5269de71c3a3be2b845fc8ec3e1a6d7b067803bccbbf2582e6a3d11379306bb025549aacbba240b9aac51942453daea465832867954f4f70e782f33eeb3f38ad9bceb414ab5cfe509819ec29368d5871a33ed09ca48001918d6c90b38316d29e854b4eda63c47c5966b66a39e016598f6a157944391645000e6dedf70daaa7c90b0a6336e10c0b7e0a853ea22fcfb0fbca39229059bad9bff6dff5666077faa4c3905e8da460a462fbf0423d3ece80416ca08ada5963a4390077fee8e5c440ad109d8d6dae8c6818caf034db8bb05880a368a54a4308cc9bd69b234ce62dc1c4cc9d95a179066ba7ac75d84fda9163e0027d91a72f5a5c253a2c15df818c5f23ad5f9d1b67636147fb1337ab0aaac737e6f2af7319d509cf4badc1c44c759b6d9516a9c78205da3ef43fb80b20189bb2f4a626a2c4b2247fcc18e3e5cd55374204c9d53c994885f0d840c78cfb7f86fdb865d4436e0b94796dbd4b643a2c0eb8699b8c2b4820e34f06a25aa6e24e049075b321ce64353ff066b5aadf0c43d6f7eef2e6ffe395106928381409ce14d6153af29190e9ea3ab199e764fb22d2b2ff54a10db62854b0c96133abdfb26c17196e935cf6b76821eaee1cbeebe41f0e64345ff6b7e867c5070b023cef54ebd4f343660d6d2e5777dba5b24c4237405fff5bb9fdedbe7b095b289368c52f62ffd3d9695abbd74f540600ab249b9ff86aeb6e451ed038e54cb29dbc00da000102fc3c12e91ab753aae7cdccda7225e32935f8e1ea1e0f2bde6a435f0ae368950457023c4a7ae44548bc043b2de7c4fa5359e80b5371234bf4188a9fb2dfa6c3174807e86fa1394e5433e3aae962e8ce1e2646cb3b09934d55a0eab6e6f2da3a12a7a3abad1d7f681dcd6ce01ac824fe44e8bf985c7d5cb7a623447eb3a3214226b76121abf0d917fc4eef56fd4f8e72fa2d5303a8f4730df2af4a06f6d2018d5526535bf8fe72ad2991bc2c37fc2ee144561b1ecc6db65e25011457cbc4ae0887e5a6247759c9474f56540c0fa02abc9cf1fe3ee52d9f2cd7ef3ed9a3680f7a64c09a6faaeca022bb634230bc12aa4450361caa0b4e7de6e01e34395f1f9acb286af577958db946509966ec151d9cd2a1ab6548b5fb734cdfbd9cc3d63f64b8da7e2e8f9f609be49b89150e9cef4e911442ccc6eae9753d4d6788413982d49814ce35654645adc3d37f267ac14b33a4f916b506497fd72f6f035009f5752fe293e5cd6143d4a43586055a36100db7b834812e4421f295cdd057a41add9d1e563e300b210523e523b10697a1111102e8cf98ae7116876ea7f068ed7ca6b80e22e4085f6f235dcc9ec878ba94bf6570642cf77fc3fffc3670eab82b9a222599d0326fba20bcf71d66d3abdcb9999ff51094541a4a794d5f9f34feba0e0f5d3644e8ed0005bdcd2515df105e497034a401923d06d4a1271ef5195621a58131ca0cf3ed5deb81eb517ffc0c32f36f3cc8c604ee5373b8838463d1caafc176a3346872fffea4db34f6998bbcc74bb5937b54f88e35d03271e4f18b5e1d75ef95498707cb6deaae14c9e46277ab6fc6800075f12ce8bdac591549ad4f420a30ace0e57fa59ad0ed629fe4704387b7d3bc0e91c053f558861b30c0a6fe67d60f7ed1a56cd975035537c2e620c9ab98cbfc04767541cca99ad12b2a8877f9aae0944664b4392d15dc44c01bb5636b0bdbe450910172d3c27a16d877a721e318f46a709fb2cbaa46f07d0fc3add15e062c3dcdf6de3acaf24256792fec2c06613c607a54dcbbe49e92064eaa2713bdee1c92663bf2d5f873f0ac8fecaad4de8f35bb82880759dcf243d01c29897698cffa90a1cd3e9c1fa05a6ed5f1946544318eccdb72ea6f9a893dd41246f1dac16037ea8242149413d8a42e7877f98a945ca140de04023539f15d3a82c816ed688278539d3d34d6d3c95a3bcd44634e9f2e8b5d241d6c4d24aad981942f427839fece3e806f3af602cd38f9e8a33546ece5ffe59c565fedfb6a063a0bd53e92a6028597a09dc8dc08afbedcda83aa84cf029363ddbfc632e3305b907194475a20db4341733e2ce72bd8e4b0e119484ad701d18c96a3dc9d02a6af2b9d349a2dd347c045a32fc3f180788704d0dbaa500d223cf1190241093622ce7c8177cb501f1ec5f883084cbe06ce0bdeccec1a8331707f05e5605ad132478f9e8d886ec458c643fe5390a79c038b9717561567f1c980730eddc976c2fa12fe0318b1fa09b0008d98717bbccd8be3f61926af69bc89cd113988484e01a105cc2d415beda133c834e8a3cac0430b7b9ab32891182f5d19eb7ecccbed280d16a7decd462d5c54c74362d4da88c7b951a889d98e4009e24fe9b9179ae7742fc293f0670d961beb277f0d8d1d4e422315bd9ef38126617cc9625580dfef12eae6c00e6702dcfc46a2140ab8170e3363eb76b59066433eb767c4ee71bd1feb41975242a1f7184860e8cb6de3c8ba1d132b3a4218c2a1d4a1c05df7b0a5a4ab974cc91363c34d6bcbb964e6dcf2cda6cc6f73b1093eafa3309455216afcb66590d0e3e9ce94a969cbd816fbacbd289ed41b915def33a80d8dba13b9925745586f8c3117c6f707b51f681eeed901a7860ab5ea0bd3eb718dd107a91bccf79f00f904631c5b7634f7c1c6ed116e952f4ce8d334c3cf4de4274240e1c0c7fa87ee3ed3291ee3520d017fe992ca41f3cfe257d429ff2da988fead34c831244ea34c4486016be35af2e34c06d428085c092b2dca8da30ee9154d8d1d9e122f1f3ef1b32bb2b0c472fcc2a23fa9bdd0fc3302840c75648beb3c13b886f70213dd511f165fa62b23bef7514f41e8bf72485ec74e4997e3dd0de3416c3b7b9a53b38d7a8644daa9a17e2208998ea1f8498fbd9f71f21c0c68ddec127b7cbb183deb7120f744af4edd903ba467e14f8e293557822f740fea508feb49da8e2fe86843d4991a099cf439818a4527b1a4c6a8c02c04458a35826e586f2b77830d40d9de248bf8e90cb0baf1d9d9cd72500d84a7b0498f06703365084694bbdea9a3cd5e13eeb1cfa7cd697d82b74b4697181de2e314a093b95adb0b5ab65ee009181b8475f2239a4f3cac140fb1f835ed96154809674940b0ae61ee36c9822f6ca8b38d72247c47f384fec431fc5d5089f04a8c4644f20f2e2c3eb2444f7156917b34c14fca1bf315662b52a8693236ebd9c696808ffd4dfc61e1420f866cd3bbde01c24a7d75f687ca211a90caae3dc167e902e2d620c9bbea6fa97c7e6fb5792a809e4264276074de8cbbc1e809dfedc2fbc30a0bbe733568b593eda55d3c591328b8fdd5fd658ac941f5aadf257509d7f55d146b387c2718e54ea046afac20892d639a8be876076533efa000dcbdcb0842b511296d62c6108b778132afb2288a39742d3382be7b321811536c26587c6f6bf01a695a3cabe9c4bff22bca20bc88ee41e2fe32b27943f8f285afc9897f5596a99755629147eb03cc435c27b3e85d4b4bac7b182b5d894f915e4546e8e78107e5743f8f3444e1e704441e9695c5a9c35c2d36c28cdd9379959cfe57a61a9250f453feddd630c69141d9f25bf3c961c40a67e456221224081159adb1dbdbefbe7c6bd953188b98caa80df5f623a54305b9f96243bccb079db639605a2c795cd01014473131652dfa186bc19c358bb44669247f6345593d7b4a65ecafda25b96d27b8b6627cc0a2e4edaa1cee699e5aeee0989e2cb3554baf016cd59f0886e8d918fb4bc1bd414fe08d017548f21227dc13ae5da86a2fdd0d9ba4ac3510f76e73b196bf9b06c603938b4119c9a9f2a7c5b797c89004fdbf5843a2a04155c7dacb65f9b11d02a4e8f274ac3a8a05b1d495a5288db955ba3bfc25b8bff8bcedfa969b9001072e9bd2dd78677e9d99ef7be2cccbcf2ce40d1112ec8fc23955c1afc814c45e65bfc0da2277b53b8cbd6ef16dcbaa5a6953771b5e1ac40ffed38ef9df089533294946f131676878a9236270aeabe5119f21a3adb53f581455acf309e608f9b2835a292547fd04b6cd81af3e42c00e1215a7a0a85acbb33f12ca3b7195fa1f465fbf28b5d8544529b77ac2d8c592ba88bbcb3c4013482600d3667e0eb445497f2858e90c09e973904b556d0aefda22ee19109a004d320625c813bc37b1b4b6b390fce0e5b2c4a9e55d82f1164a21a7e1e1dfb9d3c74f9dc5af89f225b6ef5a0eef839b561f5107d9984333009ed037afb83f0111a9df9d664efccb61ceb70fff15914b4a01a9f0a3c1945941ae1ce27608b2deb6d871a4750a085c8753a8fa429bd55df2a32188ae065a80e77b650713b3d935b01ce7ec0756a6b0d53ebe59fb90d8562101dfba4592eacb34fb706908fb360b47686f864eb6a80cdaebbc334cf3c60151e6c86701cba55a76580b329eb4cc5ddf552bf6de0e8923901ee23304ea27845491ba2d2e77b7e2de93f8aca272414da4c2d18eafb6ff493c6daf2a35058eaecb4a93e760974442e33d3c42efcd86ff2d7724421a31b021655d3e7bdf00322efd0888d67aea606b03b0e69ccf4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
