<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e1a4e869c7909d887afc68a82486fede553b6afa9071e5b202f8cc7293791e4e39f090bf5aa0281328fafaaf48eba9895d8980adc8a12ff2842332744eca463fcb15e20d77b1eddc560df9d5a62a9399995205cd6adf0bdc9bb76e2e0dbae994fc34f1c7c242cab48bc8e2c20fe2b9f870c24c47a0f3dab31d03bbd68bd3cb083ec8ac67211ab06335f10b712369c33abd9f2b944a1ac40dc1cea9336c78693b46b8e52f03b8c603be79b6409b55e5add08f9e62f217bd4e8e038d9a42a57f45578c2d9ecd21c159ab969eb31baea57b1b0fe50328a2d9ed6fcf19d425dd9782445ec831ee7a3d0fce2ac6e726745433daf0cbfe90f9869691ca4b27361a2eafc96ceb54257a419ee6a380b8932dbc322f60cac150b0c99c1804a3eb922f7dd278847a82e1f1a4db947d1dda2645a3b9fc6dfefb4f7dab3bae99f7c3cc6e35e2de6ccf80755793f100bcb4f9c85dd9c64a570d78423528f8f82938bb40716f0357695c6f60e708c1a706ffcff8879c7049122a1cbfd178259372fa3953e56c10b5c86d17b930afc2f30fb343c08f50d4290fe670130074e34cc80a761343eddfc426a14de1121ed479455dc9072591551553f84e517dd38f005ab959d736dbcca8538b26473178b7f766a2665dba8a11969e4769097dc02137957dd948d2369f8a2fe29dbb0d9ff1e8397e8ef31aa66c993d4b7714db6bb28610b1a574855670428388e13333e1d7c821e233e220198bbc6fbfbe1d85f3b9d4a423b73ea86e4118bc30d18d6e0fbfb8de6ba15575e1c77b68615367f8e934fde801ca4f00523dc1c9c1fa8b5da70b1883cb68e3bf39cd7b02a9a255094ade3e5c23efdde0b2f222643784eb8ab4ee4ad2f470e316d9a6869ceb7f90cf45922ee32be3bfd78cb0edfb7f0fab4f371f5611d4a6a72f93c4a653b2054f15b11a44bd2df65508a821abd3d4a7dbaeec23a39e07668e5a42cd564c008b96c43c5262fc50c0daf3cd6d8005f0796bb0d15c948ac2f6a3eae7762d41dbd740e820399c2127ce25b04e605784542825b48a1ffef1295b594df3bca5bc658116b9944d2593a8d357bd6217817509cc6183d4a6db63d5019cbc092764314f495ca4a6e4c3c0c2fd735b941e37b5e0956c3c7f936a2a3f4f10428b28dca5eda549e969c00480e9f516f80297332ab015a075ba4067cb82f4f0736236aeca156bf86eeb6716f63bb1cd4a0a3ad5d347cd132e00eb89b5aa644e30e0e13baa41211ba6f624781018becac1d7ef8f88f8e92e5e9d88d67f55187b37d5e87ab1b243aec0afe3cb6921d61447d2076c7a593a2b189fd5c5a7f787d6b3c9b879377f473324e8c74488446c96ad6cf26875558f42c61d52582890ca75aa861686d33a58a8516e68971eaf342e658adc815fe795d08b9744809e2b2a11a96a9fb00e80c275778f6e69ea4d24a411df365d955e71e85746b92505a18ac25da1ab22def573b39bd46d424bccc86399307d00b1bbef9282d343af8cb4eb0c049ce4ea299f7e5ef58b629c60a7e80a974048547a571460c91cf6a5b1e41be502689cb8e0eac7de4f3f1210c49255e022931a19238d30503921f68992bc63cda1286fb2c46bd419a0fd56293b455e4698387577f1dbd3e34a35fadac174fbd8ede45ac003d34d08cfd5843fa150198aedcef6a42fbbd331436ac34388eebf0831b921583b373b25371a1addfaf1ef887cb9be58e769ef24674a5153bba2209405a0716117f31b4ca9e2db9ffa15c493428b8c59fc68b94ecbed781929158015d827edf42d4d71a1a45d8cf35877d7eb635474b59a8ff428a730629ebb646bd04610ac33004a81142a2f853fd3ab5b2eaf8c0217e0222c8d40d6b50c7517d98e47f84781ff175108f6849d058051525f5d9567b2ed91970846b63dcd1ff206659a98595f180d12d0b1a8c05e603a5e3b1c3bb4135d5b858beaf6131d7b720724f0a51f9c45f30c63da1febf329aa85843c66396f4f6b95f7bf3b99885256235b261881de3ca989bcc78c3a8c9a4d26517a6451f4fca0e72ebe5d802d3c3bfa617225b03c6ce9e89f9bc78d0dc9a25b3b6651778897aff872eb8eaf44cf815569ee728638331e9fc9081704d0ef4312a8a9def5665b8adcc8cdb7d875a57f6f646958adb5d2790cb7656d3f13cb16e1001f68d0ee4ed8945999ed1244d41b3850c6c9f7fc033674c872e4396df9c80dc141dc05c4e6d5a92a5f6fdd5733ce81a0d9f83ae84766933c3c4a82f6e517c03c603465296ed6da03bd9752ff01ef3a25b9ae382967b5b29065ebcf3ad60eab7e4f96bb5d83664dc0648235259bed53f38c1ef8858aa4aa51ff8483e51606b0aa94d60688776a81903f96d03d0eefc0997f664e1235a54a2247ac9af9f76b6ee6da7c3769722f6ac5c1caa78b288c77923cbfabef76e7079f556e325f73edd19ce3c9b9d8d4f1f2078893163e594a7a9d2449cad91372a917e5de3939528f6c92695888d8aee31dd281a51e854bf08ddf655f2349024f2d88f36a44f98bbe69eda59ed9e98d0512430412dd688e9396ee39cdcb66efd551fb571161b61463c89ca1ba30197790500b4d5d9e2ca59afd02614dce9f5996944a3c0a2dabd02d701cf3777eb570278a54173486d5bb99699e150808755b48a6e7b6974e911db8d9c8eed7da5989212407aea72ff0a82289863d560b00977a8d062d945127af2d155b5232c54f0e6172e9e2a03f6821eea2dd79fddec2f82a61caa5f2969872c6558406065631f6213b9155257dd6ecb644b3ddf1f165306697568ea0d43294908a6f73521289f8979490644ea553e677aaa9e89f982ee9fd0e9cf37dc067774114938160c964c61bf08dcd376add21a6d679561b043448be003cdb16310253c20d387bf488f6887caa7ef366e8f785e816fd981b4c9cfdfc5ca1ca6d562fa9857d5f44bfdfbf62d2488687615445932c439c554abe47a82e7a1dd89a9f29415182d1979454886dbb56432881befa901f41fbb8cc75a73ce3e29e426cfa8346386bec35d7c53be00ce4ed69a2af4135f4e5b744e489e5a43480340234b8dcee2e679a7b5401ad9a3da0f99cc2449a9e0acdc7659dfab2b698722b68dae0a29a3149d64a6d49c20ded839c9b76baf4fbe96818078db5e253dff003a9c26b3575fd2e398b64c1fc1be7c6a320afc8abae6a32096672aeb5d926f0462c23a34e2ca9ac7a5254711e0794e5b17d901719d9983c3471594e1ac541224925dc5f68991559c07b70e65b7b48ef935e1d394533285bc7f9d42e70778bc454307f82039c8e7a973dae1089e96fcadf1236d22cce30a108c324cc724f1be859b739157b363504e796ce40db98d507e9671e866c09fd2a6fdda37eca53ad39e9038a4d9aabf9f1739d02cb020dbf7b579bd4534f490938e6970df8bbd1efca8e95c1128396455c790ac292cbf8a30abdac84f9cbbef1f443223843b07b1cafe193b03eda452db5dafb7ad8f1bf1882f61734ac6f109c156d46ed7b5600add33d7c077270a1897465fb88787869848a35447239d70279f04abbbe07a2ca9b6e88b3301fe02d714c0cc8c8a842d7838b8c98d452d273fe093a0cc44cbabacd5a5d7d8eb898184c77745dab43eb2b21b8cdba84d82a3c85ff1cc98515c9ded85792134b76ac39270fbc9d6e36df90c9bd998b58ef893258c41f5991e6423ef5241c04d0def5973b76d91d3544068ef24dc634e33dd4f93c4d4c612602f643a8117f7b7d561592a68a4e4d5fd30c5f1c3d64fa59672e98feda81af0c3c1cb8594bf761cb0bc79d353bb1f1fda2408bf2e6a635116c91c40bf79f6fce76772f236410a9285cd5a2f4a246d89160fbd4c9b1388db345be6b37de93716fdf823a942f35e446b0fa07329288fbd29ead2112ff7296ba4effb340a652376ee683974b3707e454c07280155582be8fea8485c4439e98776d110b43cac4fcb39de29460b1676b84926652a5b26030dabcdaf99ad634dbe9833ee51022f79aa0a79b3deec5a949059fd4dfb1ee6443b9396515e422497d0ebe4c698af288d0b238ef75260ed581adb9fe63f263c071e1c16edeb75f72dacd099eb4f45999fe475d7f4a1e86f2565c4db90a6f0b7b72df0027943dac4efee0eb5690c58aa0c60ce135073b208e29076e044a6261702567ed82183d94cc85f15974fe60e2156b7150bb4be8b91e97f7c26543a091f90f5121d226de04bc994a15673fbbbae4d446991e028da6b0d52b0b37f1e205b28821f4f1528d8770ce989302c24803bcdeef4003770c861f8dc6707c74e234add56192d4b84864c61c7a979ceb5fe230cd57789ec26a24389e7b3e19a98683ac7a392d591ace3b51ee94f7187e0fdf08d43f477e8d170f5895f0f6489e1e1ec0c62d1e5664092d274e32c4aef84cdba6c8cbd272b3f9789b18a6a938f6836cc5eb522b52d3e3336ac4584d5634fc1b1868ae793b7894338360266d1cfbb669b8364f8eb0cdf600d436f769af17b9a445c615d480b566364a127c8204c12d5bef561788388e437339acfd3080172d856cb66630d1425cdcf26fa90a876f127194b8e9411ba142b3cbd00fc880634a5ca3c71f133acbb56314ece086372143498c343d6536ec8fa6a4a4e38108e6c2fc20b572b14c00388353c581548521eaa0f9cc560ceab1b272e39439c6ecda90c2e07c5f28f82d353066d521ad567037a13fbbcc41d35b44fcb1d16b0232b01f16556bcb586648afc564965c1bb53c2c9b7d1b7c135630c55df09ca177ebfba89f0911da1fedc8be7b58f0929337864265c3409f7d134ed3ace38640b6c2599c8f79ad7b6305a86a6b88ab1b3e2880503f1d16b91981ea21adc1cef933bf62389ce983131cf2010e77922918bf40732992178fcfcb43d6b3d6dd95b07aa98b5af074e3b02f02424a55f599e9ed4ca7cb16d314fb1d98376725bcccfddbc0fa3e2277b2e18fc417fc235aa6697534a37e837fab6a18cad80acbcecb561ee51a1a590b91f49d143fba46982dfac2adbcab07c8300252e498178decf7e4eda9697ea6bd9e2004b0727b6f1764fc096675debe7192271bbe884be4476a14485c0b32d9bbbb05a1456100f72eaa4fa799209ab921b499eff5d5de345a59e144c03b1a4a7219a4c9a499884108e1668117994729dc0338c42a1357989217e4853d46c670854caa09d332a6df863ca818fe4bbfc9212b14176e12088f7f8103d9743bba3a10fb0cbc104cb4c59ae292f5bbd225ec9919ccc08f46f6db2e67170223d1b45697b47dc5c1a6db7946e0627f3f560e4c8de6027d63fdb133db0d0061af3a6a1b974da8f389dd020965b5ddeabc8355f818f003f5f2e2788e7a8b943b7b04d3696b23b1271390fbdc5161c89f94b517a3ac4600730924baff56f2d01a329c44cd64cad9d459b2102bd380d01ab765c54b5d151fee5509ba3d16a055d97d94150c172ee833f1dab0139b57068d96b91e583bdba1f2a7f1d99b2326843637b386f5270d8379aa15c3fb45a3b665a762d40a78400318b5833fb9c01ffefec4839f41c1d30772203184c10b8813047328f368752e392db91fd4fc8fd72f37bb920862ad2c887a68e7f2c5ba0775cf40caca65e96cf224fe65bd031430dff51d424e2490fb7ecc072a74de8a58bdeeb41033c54961aad4b9e0bfdeba0c4f30a186a91cdf096554764aa6cbebd5007781b83514138f1f32f138b9d098ebb924d09ecce273eea68d8b147e170a2ccec89b06d1fd70e9d0c2049c3892293b7d0048ddcdea1d459ba9297b3f01290dd7fd9a97699557a4f8c7b43595ebd793211e84c40b451e0c0443e08e5bbb5822eaf99b4c9a01153231fd677ccacd19cfba97950574e42df2ff179d219e5f3052267c71f83daf606decfb44b73a5d4e47644ec49cdf6775bd693b1da923f09c1e751f3ee68bdfeb392c24361aadcfe1877714c0d0a4253b12d8f223c17e59aeb7422b19526fa8fe47522a33b7648a78173697bba9dd7764910997be0d96b2cef806289fe7b8ec00760a5ebf6be5c451773d0410ea77894ad522a1a069c504f1fd66457af8889b0e76839b24d5c5b6de83bb300a0991db8437ab19f9ace6173ba76ba76b5391f626d8a86f274553d96e1ac03ec93c264787381a0cfe18a840c70173c7155dfead874d21a2556cb9ae441c2a0dd0ebe5d23bd1594d9931d21bc5d90727ba5d06d36ea0751d511345d3b111cda4978c09c4408af41704198e2772d91fc81b3a38781f01e485c29d39801287f352e67ff0c0d9d09b07f8c0ab39d093ae5fe821d467e10bb478e43bf1acd2ec63506797ecf8cbc416d761ba8bb0dd058100977aed26ca6fc27d1f94c99ab9bdddefec5eb9b25add39a62fbab953e9d2e502791e6fae5fd6b18f1fac26f1011c5fa5918bfcc6d6379e10a70070838f4935156539ba04159f2919a5df83a1a55ec5aee53783af20aa3b31e6e61e2bf7c7cac97825b63264822351ef2c05d257774356ab514678acded3cd00395e8115b68e68b20e25f65252567aa981cb330f4873176df1b42e8067ba27ae8f274c4f269403e98c51daa92016a2ae5cb0c770dbb0a826e526747d8afe20d736f4d7ec1dfca116673704cfe7c1cc4cc1d666bc97749dd733536c3c7e650bdac14c4f3ffe71a0c7563288db0b72c2f2d675d2b20d90e43c72016334ce22039973e0fe05ed46d4ec99ff3d3e8639f8d439317e0d68247e519b3662f282b8a8b2165b851b8e050477f54840bbdc8875849bb8152400b6d8178074373512bafb78a57e9a11e8028b06bd6965e076292e2b8a22f2601a67deabf1af042dad59238dad89e0f582ccc72da951e1598bcb65fd37ba8a2e0683b9ada459ebc39509612248c5e0c687c30d4877864877ee25516b2db699a955b7823b845d2c0e76fa943f26a49c863367764e4bd7b24a69acd0c82787381972b243d37571ecefd7546d81194553d6a75409321ea69cd530535f0760f67ddc66a278c4d0d454707235cf33c5c3a0ade713f5636dac6e8b4adb637faa5b964ed19ac547f21b59f569285a50b84ff74934043f1d3f03024267982e3234bc1cd9342dfa8f67656a4423b7c01848bd82823355d31fac2d8dc90d3237a121f161df5c5b3bdee221cc927bbf0e82e733ab905fb3734a66ab13147c77b15265160f22d8bb4cd25c656749dbf3b5bba8c8b1e0b226bee3232ac0cb40499db8b40c2ebc87b5f46a783f658fdf29073f2096fd745524fa1b0b0efeb44e59f786ff768d170ea20029b83d998930592faf330624815689f2125fada16c838bf9f2d0d28657d669fe2fe31e40591f3f87ac911eec6b9e94960ae4b56f3230c5e6e550782e6c73725372c89aa0185d68603cd83a47a49bc875164885916414ad13d382185a097eb190ef3541b64a268ba06ee99d9e4f324369dd947807fc6417d4b1a00860da91be5a2e7cc5f578b0f9b8415ac7597bc2033d05468c9705ca6f5aedc9c1f9ff0c2f255f99d57f5785096704a87fe6dbe51ea385d195255e1dd5e4dc2a313ef73421ef575845c10c429cc66012f4ac72f158b33b6d4ca10ed9af128d7f7a31f55726b6390da676f0db41a08adb5ce76f0d6ba765379cacf11d3954f015d5042af86250a89561cbabbc69344f73767b6376bac9cb227f937802f10b63e8e009278144e5299ad7d792e19ce79423dfe05a6cd7b4f86425a01b67b5449e03a5185d27ee2832df77e8e6966ed7a07e21debd8080f1527becf6285de4e1020625014b49dc1d01355adcd9663603b53114c74e072b389bee76d6991022766bfcdb67bd35bcf7d218f6ae775526ad8095d25b64ec8e22c2ca47745d9db9f9d294cd0f77803c567757e0fb792b4203acb020f9d40dbe2d861090c0b7f30f76b5c641dfd5a0eadfb8a3b7826eb84d221a10788cbadecd0e4faba22e0ce4b9ff71f386d6204fc0bca54a5998b1724a7870c34a6aac7ab255df384565b08ae249c004cbb6213cd3fb429f9a856018da8bfdc749819c20ecd7fafc74b433afadf51e3cdf230bccdc07179e9d2d987c816f7c75827f6b926b884f3644f6a7065d8645369c271376e8c4242dfaf33e37a38abf9d983c9deffc1f4c62e1a3ba4ff360644854c7d54a05c10884b92c951e8c0a0f091db442f84002a7548063b3b6cf4eab3f77c993c4f87a82e1996fd83ac61a2b0304d3ab8a11f8355d4ae4dc292732c897d8b36aa71843b223bf8b8daa9648f4e782b62d059d7eca2b7552d13e5cd516ab960924eb78a467ad3d7a9076beba3dc85dab6e874ae922ae4150f3666366b70265393d26ca851ac32dc4587399bc5a2a3b172a26819be774735e44b525cf0f6fe69beb6f4c5b176189fcf044a8de38ed75d61edd17aca66e3714c7045f13d362e06f5ceb1ec31f7abfb0aacd45b4c17e62d966fc03557bf7e673de101dadc0f34b1d2ce6bb30a9385cc57f5e92d1f286ff23ab0456d96402497735c2031bef3f29bea105b2e72339d6f00aea5a87ec494c48aeb8b7f4438d03f78d59591e405c2fededa1e2dbebeb755da8dff8a0e14141249ae25af07a2221c978d49cdd3bc9f076d4030272251e4b9892b553b83d7d986f7c316822b26f5b41482d76425743bccb4adfb0fb8add0e0dd927b23cb39d7c2e4598300baaaa5df3a53ec479d57c9972aeece4c97101d504f9c4449fc22b5e899839ae56c5e7c4ed57b0bb76f36f6745f4730b425ae174746ff99c913e77f340680854e48a7b52cf0a71531b09128f02605acf00caa87e732b745a65610453983092bfacd456484dafcaf4b49536f8bd6d51b71ec19e2742b83bc0ccc6a873df3e4802edf0390e5f78d507c419721d5c8fd44656d90bc439dc652155d6d9dfcb9518c92020b5040355d0475c3cae30be41d55b0a4a7c0022d40207ec05ec4c42f6600018f290563af2190cfa52244c5978c29848cd013da38088f5f67cb94f7595930c7eaa7549ee187efc05f42942e9ac4a1647ef0c6a18e666b8452ed3b29e9d01df3d143b753515739278e81f6557cb998e683f75f49a51d974c54d0b0737fbd3aba3c8f1d9c93716ad81c11981a97ae1d880c2a3f779577187627fbcb6712754e86ce52542b40657ef8db017981ebac50799db75d2c08c95e65fdc4d95f84a2e877236def018cc7db8c7a009b55fabeffdfa7bbe1efc6c9fd25909588e6638a6ee5d5765eba53cc11886eaf1a80554dcc9a9e40c3760567eaf81bf04e4110d745ed7646e9a695bbd0e856c48f4fb9cbd2feefb4b939f56dea48ce487c892d00db2d2e029da3c161d31996ca10bb5174c7a1b876e2306c7d72ff061cfa60d5a77864224889d019a47a87f8b5a799aef3c39914cf5a1b2ef391dd03a17e7abce88790ecd7acf0ca67583c8ca3968eb6c7dcb9d7247bef7375d1f56c1d9e81f5dfdd4ca957482f31f488bc4a419299a0c4f491464f60464364d3c64316c6d743b5961e1aab3b03017e0e1c86e03415869e07399052d1ee356742e712ea034984a766edad6f021fab0d866d15814b84af931f0350e6bab7a03e8d756b459e011109e5c52f37da3e3ce13fe8e867de58ce564df5e23b4e6c8177ad741314020abca19787c490a64c5820a7f6a0e40dccc1b5a6ee7879e9fb420238063b8e19fa6f8fc1611b78be7c1195e970a7bdf6df50da9c6b8fe52e505596de364f54e9753708e2b0f13f1d699d742b7b45837c6db2745b508fbf01f59245388d87f6e2ca0bf4a333da1c965f69fa35af0d3cccb7abc336472c63fca907765fd418fda755c58e1bd3c6591c2b0bfd606ad8e477d5ee29b668df902a1405f5bfd1948a0faff3bb57ffa49172155a70873d3ebbdd15d2acfd19ce77e9e2676aef0c71cef705d1b4e9acf66e36dcdeb7f28f37348f9d78ada3e3c54cd24e8d787aa61a1a20b21f99d00b71aa13ed3aaa254ae2d58a8519eb48dd63e35f33adff511119cad34f9200028b8d743eaee3635dc02b77b4f42d410c53997fc83a242031d8bf3107a79b250e082ab96179bcf0e05be5377b73f06433473d2fd8194154a54d128d79f41365db568b18eb58e9c5942fa31165e746c4dccea654f9a0235731899e5abef0a661efa39eedbaac5e6d60ce2bf09275b989667830454536fe6caeb7b2880af9fbcc4b09a9bb54d8871358a925ce67a77fddbe2f367f82d7d595affa3fd792a3326385fecd23694c49cd7dcf356be0b65fd2c43391e44297c0d3b82f7f51387a5aff153cf9d41156012fa67fb1375c253367fd7ae9b25a28085a46d71531c1baf5ba01e2dcae78b0e972d2d4722b429043e3d09d4ec39c031efec9881a0a2e44b8379f5daa73c8a9466e9de9d649906bb1cce2ca23ba8da1de4eaf56551226e8dac16b614b125269f162e59a15ef41a80ee92bc875dda89171dec3590925ccf1c4dfea67d0e744d88b4b7a58a8ae8247ef245e0d804a7c971717cfe9156fffc84f92179227cdc021b0f80327bddb89c789cff54539c9cb10a1cb4e9b8c77b4c376b833cf9e6f09c18429222ecf5cb2f48d7f11467bee61c886a24fba4b5c788f369659c3cbb57a771c052ff4a6d23d29e7ce6dab7e3b7e9a3fd348e035f023d49256f1374f48b4055c176efe49bb1555fd0fa3186f58b04fb214be19a5fcaf5eec57ec712c65819d32164a78e8f1ae5c2a6cfa7073ad5e9d83acf10311d2fa3b04afc5c3127549b7915de7c3b9de80314ea0d0c64fcefaee02043ec8153320127023d0a098e66477ad07fbd99175410cff759ba09453036ceb50fd02b6e71293059f816e3ede66353e8cb98bd2776d045b8cf72fb4a42ec93d2bda64c63a845a7a237a0d98ffc9fc72a452f078ce0e8c997f6575340ffc238dde379c1071f8391e7cc2b1a6398228883113fd4be0ca6385a10981b05b96201170688059612d84c94f91a5ab85a4134d9c8af0470dc2b3a298dd01e5c3536e384d3aac6da01b3573eeb2cf0bff9f2077af3d89945b9fc802b0c2e58d981999350c60c809ceb7a48435d2a53b398813100053638a844614d57be037d36bac10de300f9aa48185311b5744761e4521f2bc93911744988ce45480391a2b218f8a574d8d366278d9067ee9456172117c2b3a2bedc194db57c297337a99a6e2c4f64aa8cc1e71ae214b7270f7b38e0f872b1d8e9faee294db2f65bc204f4d77c574264db44b83d7e8db3c190cc3a37ea77cce251022b20dcb372ea15c8c57b28407ff3c4083b8ad0b7e147e33eb496fa53042bbf4ecd0f2f330fec8c7576a2b20e7d0dd88b6d24371d8a279502162203326b03696bd7037725ffeff59bf3f52386356ee87878b256999679f83de0787f36df5b40966a24f6af6f067e4a246061fe797f877be95be9b821239c7276227e6551fdde4fc9eeb79193889007a315b433c5406356ee6c2a3ff009c630d1c570ebcf9498d2b8628dd76a8cf625f0d72bc67c02d459734db206ef378d7d10ac130e5630f02eaa50926d2c70a6941c8e90bd63aa146054fba226f4d373a7d24b103a2d09c8ec60909cfbdc4d7ce761d849504229c4fc9440600cabfbd85cfb952cff09fca41246a38790a4a2f90409b161de5a427378345513459a88871752e626478c4fea283e8031a393b53886997424afc7b89917132567a7a3a112a69a2775b84e639af62ec1312ce6189f5ef4f4b236eca808a2782bbc43a8b6516f3672f83cd7430eaeb0bfe31c99b0f3ed077c234469bc07a10b1fbb48969685c6591798e324b80bf7f3f1b7342bd1bc40f2fa1e9dc151717b0a406ba4f3a0020c0f7d27785e4c74a5e44b68995bd0946a5e26fd10fdd059fba16a1f309e22ce5b601a95c36f944977f91f4ee69f7efe25f9c3c4b1e674b89e238618c9a83a3cfeaaac2a9094998e649cc4debc77509a88b179da8dfb56a224ed2b4d3b398cbc74ad74afa0103a00fdba2674a3a4cced40af596da96e9b79390a05ffbd26229931209daf4b70768bbf550e331bedc2b60629172cf8d936ed7682e159843b142dd2d279cfb3a33749bdb536f6650cb2231c0582ea2bda5a0a1b24f50c42aafa47afbcf08adaf9c80f99fc61bc2b2b48e773188446590bdebdef717d2f442646b527a8d85bd4afe3d4e06298c5eee0fbdbf968e2ef957e81f7e359830ac3bf646d29879e8e54dbc8e5b057f6740c1cbb203c76981390ce091ad994f1950a5f11238534626528c9ebb920000099230985b5285351300c58c4eba4a211f53629ef145e6e0931a98573f3d26c872b12b84cd9702a7ed5181a4f5fa66ba2640f6cc5304b72eb88fc81044120b6916d7df2862b4ab98805f7369fe716dad620f1d00e80fd9d20be5b6006c166984a4584b897e05fa2a7f6f574f23869da830d1c63e6b284aa12cee7243134abb65d22fbd7649d2faaaf39321d37381888195965e3da75a14205becdbfb652fdcc3e1c41de9998d2875a7bd6d6319133337a08916dc49ee2e1fb035433f34d77206f02e499206f2c2555c16b4902dc118b3ff6ba54f23ece5c77e5cce5f85d4af5e5d606b73f400eb7509065ab16962aab396d518090f8c64fac35d6d9fdf635d0b7720ae16dd778278d6f17bb6e93f305550b3e76a73250b2f4bc6b4efc271a7017abff5946af4122bbc31aed1a489697d83e9cd27dd37fab2f5af6eaa7e8f9aa733ba8a803dc29f7f7904df18f02d274672ced6f4af45834775b646fceb8379e1aa759040d5d41d1fa24b7e4ef8f05a2a9e513035b894507acf9d1699540ff9efea19da350399e82f5468ee7f40242785d3155626759f3f8b30808acbc113801efa764b44c6bd8a8fd8f3c59d3367487b3be3cbb280b60676cf30742f6a6834632c910bdab64fc6a3eeb735f507a8e44ebc7648a089fa3801aeee699c2fa8b8ccc3990b634c2e1fa7ffab55feeac45158b2f3ca574336859fd10face74bdf49f151dae96f7597e137bdf57554b01e59a740373ce9d3bdfcda8d2b8d6ae7106fe0e6bdeb5b567cc424d1000055b83ff74a0ae7d4da0e39d94b0c1df1fee85b8d04fcbe6ede679ccffcac25b937548d6e802d8a552da93dbaf5b058e714504dd25341f79810bbcf984a39d6cde60791e5ab2e14da6cb8b4dee54f93fc654e525c8b6e2d8b2791a08d97f99eff7f8c8f630745d85b0e29fbf1e301954463720fbc8fa3ab536ecb10562edd7a93ee11be03ccdc038ba42cb6af5849b6417e60696225d9859f1c22f1c979f16bd1219e4fbc1a38b9cc3b327a160709dec57c4e1fa29ab34c444c2cadbd8ab2a616c9c3c6bf024579892828076d4b2afb146cfb71b8328ce73726dc1cd06cb8af0fe2a6d9b3d9663b05f35fde5b1ee74ecc2f848025222a1bbe96d74a1db7d6d8e94ab92aed6d7987232f346b26d0ed5e604a1331584c279c6ad60d5c47e6e207672d8b0397aa5e44f2af70006335eca855c2d480897cea43d37f87a48cc517bbe13992d71dfd477cd4b31ae3f4c74813d8675b6d755d7d58bd01dec9fc54649cf2bb8824b3ab8991450efdd79f7a67d3ebfeb6971c209cbe108b3e9db1ac08e5ae0c62a2c57d3d3dc988bb9536e882928abff4c6d46f34fdbe7f00d4f117df2ce89ba7df6103bc19532a2a6cd899c5e3026135a73b870721ea3b7931341c4c8b4b5c11e84ee992a59b8ea0fffa83a7307b5a461ce31eb688dbf0740de4ddf696646fc2b4592b220c982f76ddd171cb44118a434c6443100cea13fde51afb89bdd3c0af7580a95b42575d234f1ff6f8cf9a1148b3c5f655d3f3368e77694949b14c3cc4199662921e74773958220aa9d51f125929d4f84267a916ca4e9e7178658ccdaa06d0e3cd325d27d16aa26c0360171a392520b3d5da3b9ec769dd90509a98c860d61fc922eb3f07d616dd2fe18063809b59b2ee2c4fe4d952035d8b267863e1458bace9c913179d77e2e4bc8c9ca9f4d3a13ad61f39afd60c5d0d3d231af4e7e9273d8342e38f3e8a3a743ae64113dbc56b4147d5cc3888f793dede583ba22ea42234282134acb14bb9b85fd65ea3ee7b4048477bcce6ccd5682bab5522bb1b01b88fff088e0ac700a0398636cfeb892f9a9678a1d5b024a5642919c6071d8ca7cc335ee3b8fb3fb32b8c414e27a1fbbbf8c3ffe4e2262bc3d8697bb65f70c99aeffa2ac7faa8a1389e9cb7c3e92b3854e0bda85890cdec68e0287cff4a255a5fc8970ff07c12ebda3982ce036d1ccd1e9390378b467843dbd2f106cde45da0741199259826538957c4cd14ec16b9425264acf1b129a7436556c22a01b6846690fe14a7a65498c0306c0db7db9bd64864c50747a317f3b88dfde3d4000c4ff48728b10155f57b5d2cc79b4d832c75bf9c6386f8c7fe0ca3c1a6caf1e6c5f27aec2fba24625a3f24bbd0f75cb2c375d62dd0bd7382eb1c51513fb985d0c2f610ecf52e3e55b8eb581cb33b6f5d9f8854f11f95a50807e3c5737b34b5080cf9e239cc926a789238420713fa0797116b8372221f113a6b539230631955967556e15221fa9bfe47dc6d6ed45176f105ab2ae5636dd3ff0e7f510bbd2fbafaff3920107c85ccb85a49409b88d6501e0e902b99cd645811c32daad66ad48e65c461831d373f0b7b1b8c366096e76030dd6b3f04e1de14882ce1dff16943ab66e2fddd13209320b478b0b189c09321018b4f70562c8d3ce1ea3229c9541f61e23e8be76148fd516619726c2534210fc2a345e6d8b357cd3c0d2e211b9bb52f85c3b33c5e70205afed8e6bb7d5733ca44261325ae104c933ae01465f2407d00f96f5a2e77b559c0da3454b9d690b5c8c2ec67f77e161d6f4ec56112d536be2585e42bf78165dc41bff2c07b256f48fe31a282aae7570dd95e2d81ca96ae833619b7a5a4f05b91b9f22b3bffe47ab53c1c96fbc2ccab90223c523e2861d58f1e3271f56c9fce9a02fe8cd96fb30165f5b6e9403176f5f9bcceaf1906d4b12000f55d1aba22e56c6961cd3b194259e2403dc756027e1e8df8102c613237dd61c9a61c5eaf1d1610f60220ce7b6ed944485bc7007219539cdc8e41df89fa015b713ca578780970df5980b38f1c9f05b905aceed9c8caa3431b595dc190afae4ac6ddc899e8619d4542ed3ac6f369ba02ff195df9f8498a3ee59ce93a8a60b322463242adbac80fe25cfd773f202b149433b19404a602982028ae8e121a0f1982f85484ae93d6f5bcac88f134af78b2cf633f0a8f1687f080bb0f2d1ba42cd22a5da598145cdb0ba6071e860bd66473d82c768f4750590402a82655c62a2b2f751559cc9e61edf77c22fa3d0ff642a05a09d3923ba4be10f9365e0d2187a57b523db42b420b93086c2af5b09ad393db785d5c653313cea010fd3fe07f8cea4aa5200640f6764e720a93a64b27ec434cb5c94a153a370e96b57d96feac976160b861b8d185fea8579a54326028ee5e8aca32cb4bab67f1a1b4224b67a99e293812ac50a4141f30011a46c0ea4ff4bdf531b0333df025eff32727699e6452b9dc05741510b25bc4dd3ba866b048279eabab8ba8e23a209c410ca554ee0b43ac1855b9e8e21525da9b7e54e8728afdc3c2c6b3b6ffc9c4fb99a4e1228b3c816af4bad8a198ddb7deef8839f74d1efeb3aa7541b2b0b14fd223990b3992a9318edad9a4b096bb811205e944381d4c8803935a7cf6fb63cb9b1dfd0132ed660f1c420d4596ce3f9bb444c92bea1b0ce1eb932f3db90353e32bca5231dcaed385c8e5c858b83417ba82733459c56a206734260233321dd6743731c6712c8bda0428689d5f2678a102e0b146f4d266a353ee356908045bc59edc7f0f080c284bdd59e8b2d30ad8cfe89aa7141c55b233ff295c0bd69d3c82bc6a10bf9c777166cb49f119c17e184dc2dca4ae833540b4a85984218e2db6772718384c0728f82c6e0f79cc10f1997f4c268fd88f227b8692cfadf2ef63e0b6063a1e74b0f340b8c13e5c3badffc5ec8db29e3fe74c4739ae4ab95c84d030cbc5c8a5a8abaee0f24c8dee1bd201f5afc175c372865814ddea153d9673e2cb129d111a9c4f78cf638f8b3afa80831ec5dc0900d5d9c7aeee678748ba23a2c592adfa681cbf71f86895635b7d15127a29bec5b8443ceeca8001af2dcab41dac3801bbd5ec19f7504600aeb0e2d806c977a9320a15a1c8996a765e274d4e33f9bc5f45ff5da2d8403faf64ccbcc46a52068b26fd7fc9520d3583f33e49bf89a23eb8575d0c2913ee787a04fcc51130851c2edf80bd83fe0874c1b6b67d9dfcf562d275c0767e742b88e2876a69ab3c8686bd52c9f411af9a16698812dc0ddc11c3b41fcd1e2d8fcc86eb96fa8fc3f708a5b50b4724cd3ded18d7939d5e9e22441193626b82e774850ea81f4c73ccdfadd765b7840c6b4bd329bcc5b5aa1bb58fed9b1d8bcb497301d7a7438def4d063b03ef7962826b903c393c5381e3e7d837a37bb724de4674481067342a063bd2dae2597e72fc3f3d85be3038ee5dc0ae88b09cb5deb93897303d85b4626484f0100b2f8e397312af22aeb0f50a08525e46444f7b2de1aeff83f344661e28fd8d2b314554a2ffa9901916793d454834da14ff273240ab4ecfbe7fac5749a051cfa6bc3fe6e57782e26593540c00cddcb35346554712d00519e975eae1f7aaba59166a74c51276d03b560c7386fedef0614575bb103915387b35267d5ac303e0a351f41cf7c6cbc68a4259150e35c714bee588c596182383240b267710763cfa9e28461dd24300da80dc009dd0af13e8e04c999bdee3b2894b7198f5b8a801f70cd0b812af4e0f22d4a104928a1a99869efa0714b4677fbcf447c079d97305ef50aa71ec54e69620606ff2cc379d3f8903f7d9c12b2f64bb988962ab6075881d3870268421768dd9c82b757397a27d81e00ee1e316051bf366884d2f7e7d44f970014c38b3a1e5793778c564fba3e2c5c1aaa355ad546200328d6b5c8276911b316088eeecfcca558315ce35c8fc433904f629943d61e2a84a23d2675340e36e21ce010447a831bc0b9ff587b3fd5a019245fc29bb9714ec158c57688513d026eed7b0c85a65ceee0defae932bc353d7e671f3256e3411b9ae24fa209ab188e033d1a916b128518985fd4fe416f60f6214d2a1b97c5f01cac05f34d8f3c0a9c0680765662eabd7dd6d1e3c657b4b60d499d689ad92cf172fc3c672cfa7a5087d37581b8b64723e3b2b634844fc4ef7cea0d1f6d60c336bd0f98627f8cebc4c4ae8894ef78ea12deb122b8087371b1a58f08861a22573349aee19c322a7bc9ac77b573ce90166c0ba84d01e0c405cfcc48e10315b587159ee536b1d7bd3c4c5276bf50339fd76073bd454ccc8a0d8446866f3ee01c1779eda53ed12ee142c215799611e68b4085ec13a36831c33de35a9f392e3ed2859a5a97e9d6b431de46f8264fcbfc1657172eeabd01acec7e9222fd6ef0b1200490d9158929363958c7a88517ee0dd6b124566d4fa67289176a619eeae2eebe4620c161e0ac1d52f7edbf44dc79c825bdec6092ce912b44af717c1dd6b1335e868dc13f8d8a2791d510a09b964014eb2aa550dda10937b2d4ffe8740cdb4c9c9d39f46e475545df6c655961af9b765c11be6673c72e69468a12bc39c75e8bafb5320e9e781665c160416e91bfcd81eba4d8fafede525892f712c2cc96d1855d9e1dafce73e2e0338197c55a6c0dc03ccb2bc9446b9c4747ec01b3c5c887114ac531a0006c488f3680f83911d13975607882be7a7874844f231155a11f9eac99f3c6657f0ee7373817210c767ea2be0bc7ffe59eb642ab9bb9c4beb49d235b5fc65e506ce439538f911e6fa71929b6e2ce364ccf9e9e69d6725a7805d75fe78310ca8c03f2220f5ba7ddc14933865ebf6507a51b40976904bb3c89836bf7337993c6a68f9fdc361c0a4d4e622da5bfac6a4a10e975deca367a1ae0d22fa470bbea45009b1674aeba30db30cd70b5f139a63552e5b992e40a6d655528ddee2030026200c11c80a5ea5ff8f3c1ebee675cdfd245638ae6bcca8b9ae1b2a5de8b545102b2b58e64accd2814a1f5d8d26afb0bbed178464627055a78fc68af2512f5e66bb9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
