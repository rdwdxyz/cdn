<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c7c76c4eead7c68a8b4a91fbda6006e1d1c0dc700060be08e3ac75815cdb529c14aa82fba6967f9cf2893ab68a31529f475a52c4b6f66ca12fa28e6fd3b55a8d402337461fe16e78c6bb645b0f5fd7f307788fb7837edd533b399f8a0d11b2d2fd50bd00e257ee75441fc301513938faf1c0bdf957023afd3e608329eea82f6152ad8d29a40d9c679e6ecc4a77dfbf856bd7accb9cbec69556bf2150b2f363ef0db5ac6e5595886fb2e6110f8553f2f93d358b0b618e739be42fcec8f411d1260994d45726080e272e1e96ee0377d1962d009e205be5ee1ccee567d8203cba051b491303c7a632b411b6fecfdb3dfefdc8b7a93a96b9b0aa879689242df88894daff899fec2c6e35c0b9a63495b6f3dd150a12d6f9c84413883116ebd62ec97de8caf17758d50658e8dfd73a46314c077ad4eab4876ca60ca7cac124b26480221f3f5114598a8fb9cd5001c6765b53b2a8733c42539a13db62deac4a8995d3abf7c39598374c371cba5f9041fce0c1da49149f2252329fddfd05c8b95f24f4557dc5ea495bc13b52667736926623a89dc11129361c7a07c1dc09863d18dfb60ab492360c785d9ff163a7045dbe80792dac571401380584534e6707dde670de408bd74c141554f486858fffad7d3233df268fe7643f7560d5e282805ab0e17835e01956bf9771a74946403c7b00583b321d47b1b85999e2e9513222804c606615ce1a08d1dd2d5b4ba5d9ecb7e7971eb54603c0cf5ac3a18973f7078bbbe96c4ad47e6a1616743874c7c8a18f06083403f62a0c9c7706222d78e12da4669c403200f80abd0c8c2b70987cf01c537af0ac790c9a67e1f8bdb63c2bf94eb7aa5b8e809cbe000c8ab87f6be96afab407a7bac4dff8e6ce6328e7eaa287d43e4f2049c2d08232ea91703d81c9cdcd225f2def358b24b1ad8f50e5a29bf4cdc87a483a9a84dfea12d41f2e1db292dbbbcc42bee57f93e5278a11d4cc13dde1735c8d8225ad0eedd8dc529d38201bd5d7c936af324add6315976deb2201243058d12742ea89106a944d75c2988785284716f97b3bd9cc2b4e7d82dadd8205215336212358da23e2502f3531a79402f9710bcf6de9e7138998058b9800c9fe51b5f437b33ff3bb75d8b453f6412debeaf2af81203f66c01621948f27ff0765078c3f951987c3a828876ab07e5f79e86a783a452128d96cdffd70810c94e5402f659837510cf74bdf1019efc0e15537e2eecce8b390c7d8750157e278cf6c1ab4a3a702fa3db233dc8dce6b0f1fe5e9838e15e85e3b9455fb0d4ce81d943939c6636ead9cfe786ecb4d840e910018489df0f66f380e0569b709215f3af54a68ea49d25115f00ef2d41e210449eaaf92af488f3772b019d7e0c1f99ba54453b2825eb98d304682a0a8643597640bebe2a68090250264597a7f1084949f51708627191a5ea84664a23354c452065cff5cbea302b1a9b3631490fe2fba600a179a88662fa99908ba9cc283513b8ad0eb710cabb82e542257622c5be4dc71fb8542d8e20d0221722615d224a1ba4ecfe245f5edbe966673bbba0251e1d746ce5dd85a4b12fd45d319a0830c68ffd805a30f22dd2c07f53b806b18ccd711e62bfcf2c729dab0ef9555228f086a9c6641292806cf7b6c0942e8be543b2704636609060ec6e31143c8fb7d8d9c361a3ac7b37f333a4d58aee292fa5ddfa6e13f0f906ca7d6fc8848719d38a3f95bf1a41eaab32d7d279ab205a60164477dd551fb211b4023f1a9543f3dbaa37ca9f2f0097ab32f6d9fcd7f64b0823ed01d637c4581ad429f385a9fe17976894f95fe211bf9a6d87bca3b75447c640f75212791282a241807cfc4bee62acd6f96b1f444bd61cf66c4f616d98d56b2a435772436c257c5eff39cb4792b36ba05b56f3b79c4b8877ef069746a8dec202ba7af47060a492d7379cdf338970eae22652154dd86378c5e78c74932f1e0420fb1a106285eb0989eb64f9b9073ab9000e8784fc839451921b9fd75ebe9e64069b1ab897979d78f2f681b76ff2211f5bfe7dbbcf98b2a9a87e486dbfa364dc734ad98100d291df856a232e8b76fd5db2d7c3a57dce085c2c0dd994ea078ceaa2a66becc00083fa01aad76a8db399825daa92bb1426b39624d3d5da12b3340b15a8276ee762b0988d09b8179190ed9c6f541e5e1af126dab37195e75d98ea3b2cc2b88874bdd28b77a0a1e642676681413043cbed14e404c8f1dc3564c8590140f76dc823e26ac251a6dcca94fcc9616f01a809943e03a9e60e87c62941b7b3597701cc5624cbc68255a44fae0b9e190d33178bda7779559b838b850c8fd054299a2486c6365e4c1b27e24fb26a707d22b0cd1ca463d78d5811c209c7d0120997e62cd32a836e08a7e4ea882cdbb5998756482a38cc3a6eecb32e46701a71ff6dde45698f108ee08fe842002b13d533933d3f99dd35d976ed0b2c525b9126012a5002335ccdc59443540396f82cfa38aa68cad453748d98dfa89696385c70836f222e48f6ad04697da866b47a608a0261ae2c32b1925d733305942646792308fb97afcbf0072b63aa5ff73d9e473894a87393e1d7ec54a32ab513be381093d2d0ae7fdabd36074beaf4cb47faa3167b4d3f3f54ac450147cfb4360798153670271c94efbfd9aa011bce98228c53d76ce0963452f7c914adcaf12b9defce02017efa276d8b1bdf1722fd4960d7cf62015fc8b7c581ddfd272e33ba038512a6288a5be84fc847a172290ca32a11cf9c567f91960e1678129359447ba44d815c56222beb7dccaf03ef99ceed80bf06ab7d47ae7f3573f3b72123f1a22b85e1980a5b2a409cf1880317a987b36ad729610fdccd01527161aa3be9a474c912894c89c0d5b5b522d67f5a5f5d26e0b1e82f06fd88d9309dec18ec39d21dfc01ad240f1a31a96ea774b0458d490b1462f75da994032088fff8657ef8f48f5b26f8c4f6d74b4cb5f8a4497043f15db8c758f474c1c495ba032de9e5e098a23bd0e47d9146bdb336be8cf1c32be6d47adbdac500a7f261fffd01f2ead3de50a5a83306162c13ad2da9eee75eae8eeba9110c4a76e5e797a6ba52b2b612fa68a8fa72c0f3113d81f66a1c3da5b128c72fb08d81ae5d1f75a38ca0c02afb0a60a5db594208d83b3ab2a7c22da8f8d8a9c4227a9daef6199e7582067d6e8b0a717ef1cfd40ac12a1c7757352719a4715e11f3e6e901853b03538e217e00d021c7e5a838cb26d292297192e25f7bd767702ab442f503937681137ba5e1150a0f2e51faec958af58e3196b766bc8dcdfe0367511a26a617a61307433e4f4a4dab93977dbd4c025c2bf9bfdc3675a0583e2741584dee3c4d0082bd6e68fa8a36929af1735323b1273c81c6013b3e07c0c0b4f9ce78783e7f063bec54069ea0327e613d6e427215402d07a076c5050d2f3a625799ed7dd89a5cede27114a483a2a284aa96e08851e6943f00becf232a295080b7fc74558e3fc5ebac6356051133a49153d34cc42b70070d0b03aac5b84b608063bffa607dcfe63d7c4e3dd26af5e551614bc1c13f51d43f20aebccec1ebf7c8db7cd4ee4c5e33531c375b875e4a6cb67f1008bfdd371623c43c25086c4f3195a499e14c9288912c054f46dd6d5fd6ed3b0f732e60278eeda5d11374bff615bed90e2d554e33caf5ad78fa7a1d6b0f25e0aba800cc2a5239f0d79564a64d74a33c461622d94ce798121121b891a04e7c77b2de74978d6741850bbf4a365982f8561b14118b66556c27a5604b8cffb2ca594eb7e216dd5a35aa7d8092bfd5e7598d6ecb619db1b8053c540ed70b3bade1a5cd5aec0fc0107fc4f75ff2c759c218ee77edd0910578df3e01a6c7943e9765f48b9baf3c6bbbd0f2a05c795f99ef1c2fbd6f7192f7611c08368fb343f082b6f9f2f431a4fab4e89d5b6896e8870f1c30aed405788a3bea4d0e42f842cab4d951ac56d6745e5bc87d560eb359138407a6fe650333664877e6652c91412f1c160d422e2f55be7b7fbb843f6c8e5706f8384f99c42e8255d098a5eefcc58f01bd7b98db135d4d5ce446ca2ae4330d86c49772eb39e56ab8f8a5b8901d38e375736e1aac19a494ca917be25e22bdb2cf71682e35a04afeb9a86d37dedb122a0abb61cefa197e52d0373872396fcff4a60ba8ee11ac8483a69d13bab51edf2c4539aea517d94083ca4e6f448a82a30507e3cf3e162ecc00de7c5c8797a57dcc09d2b4c7cb71f809acf819e0ced39e71b9f1954b23c5e9238bf82d0dcb662c460826cc79c506654aae7ade6a08d36000daa327b26aa001549230094ef444c493639878543e0deaad59512bfb7106b3321792b864e18c0fe147c4592b1302d39d924bd94df49b07d4af8e23e8a12b2afc2d917c07387694d50323b7f18c6592fda811fb4d7218b1e37bebd9f6f27263a8989f78241a6ddd90a6173d9757bd4e2fc8c668bb44422419022cd58ea7fdd3775fd2a532dab987231ce0be80911da986ebf509160e40127e7265cd7058268d38de34e0a2190981189ba641b6afcfe4000a1d7d603f899a27ed25ee978579de7d579663fc24f40f6f475d0f561c5027561e9fa5b540d7f7fbd481a95c62442088281d5a8e1df78898adaa4b244dae23a4d4d22e5e07e9ddbafa78d7248d809b1700010cded2eeb687066cb310f977f22394d0ecd08a32e810fce64b10268314205cb584f9d18e754c5f38838aade987a10e486cfaf36bbc96eda307497c852f2fc02fee81277d0cd5a9ae89fb5ad8633ac73362c572c3fd14a4acb634347b2199187f84a50107b028bb47ee735e33bf4ebc745bd4221cd58414b2fdac9ab35774ff534841530a79ef98a8b3a1c3b26e24bb5fb91f79b04f9dbfd9833b2581eefa35fe1d13212cd263c5566c843896f6658801a056f965fe0d246800b06f5ed1745154d2a561a6106f2a9343e45e15cac82ac8e9126146ded3be1c83e5075a43564a5968b3b12fbc81d03604d68a73ec76702063dff44827a654c9eb7efa5763a233351972b7aac46619f12701be36790e1fb9dc15a3dea995b380be7d023d28ca003e5f91351b4544e481a6c0ad76dbc83ad90b148c38b6c14fafa5bc43d888076b01af1181fd506be65ae810f9d32029f88cc1d1f88f0bed1132c7f92b7dff188d582dee7fe307c5adb0d0f6d606e86ecf5c8dbe15af89b07dd4e5291e437ab2da09f88bb4669b38fbede27dd7cbf4b34f3888c4d4207a25fcb760ec7a7feddd0021415daaaa21cc8ccf7ef128e49c840d6cbcfa5bda9b4e76a55ea037f85b0fe192edd8b2d82e95f030176fadff202bec12c1bbd4b35cbd95a8b87ddcad7a15e10dbf32096a638182a94d461a6d0f338dcc263648051de70c0499b9bc95ad9c1be3fd4dbd42c8b7f3579c10b8610f4b5c13fd13bb934831918363585f65aa8f632f5e2ec2ebd6efd12721ff3146e0397062a283472dd784e592c9c07c4bb4e895263a362d220ef5719b5b5dbd31283df839df08a0a1500051b12396963f1c050272e139c9095c8323d2e246bc00a0db513ede385238c4d66897f8188244d30b0db287ad8f1e781790e10aed24534f1e01966c12b09e2a8a2a1f763c727d955d5053fbfcb9d09b00352b861cd5dae519ed0256cb9c96517a25564174b691704536532b9dabf78f03cdedbe7b96deefbaaff691b8595f90d4ef096301d2481512b6f951c2779c4ba9dfdeadf0b8e3cc795e8d4fe9df36b0747f5152247f084c8c8c430349c9c80cfbfbc46948d13d40432d084e892ccd3e8572de2889a6587485bb579f3903f449708de5439b8dcf945fd9e5102890d650ffd66508ccf946bf297baa63558c2b3fb2965161c5c6e8928126f0f8e0db3378ed1e26365b10ed5e220db0046d3245dc55bf7ef36b1e3b5f32a62d50dba3218f5baafef1940c0bd670fe36cfc578fbb9493b3ab0b5aed5033abdf826b91984ee3ddce828378d2f0d72c7a1fce7562ee36928dd6a8137f4ae34a11597489bff98cf9e2f7b287d7910470e014be6cf2e408ad09595d957b59b62d60314ddf39759481915500835130f31f901f08ab653776be47cbde1ca2e79b1912065664efe97b692f4f5ef2bdb35ae99d73b5efb9ad81fe6b41bcccf2dc71cc8998675a07aca0079187614f78e00a9861427d1f5f1a815c072b93d3087170ba20a3989c0c008035ae7c0b5f67b8fc9188f6e6cd5f5e34dd0badb5484c563ff3c06795be0a50ce765a0b76e701cbb7df3ed1e7c2e4b1d963832783a61a5f6b9d384b4271622da62ae63441bc9d04231971daaa6344389848752164e6526be38d58b4a6c54fa5f9cd5af5133f9d1f9d65d8fe1716484518e09f99dd2ce4c02f5dfbd0189c131fcc0fea397fd4b63f065e050992bf37b5541ffbd4c1d007f2078b836606040ec93662f75615358bc911d925589ff3907347f1ace418041f72c45036ec65b7676e67c499d2ff7234e7dd505d1d58f36bd5c0e9c52777c3bb9cc7abb3c1322fb4d24bf6e08ff87b17eaa2310a38afa96dad0a004da61d35b1cba2d4e0e7f9e8dd54a27242b87b6109595c3db2d8c800bc9ad33218cee432985e287ed8d559f6e5e274c69b741dddfb5587f8800f835e3919bd3cb2409e8c18bcd7514a1d5bdfad695964472174fad5990a16a7b215ec9e09210744712186ab379c5e3b2fbac1663074a2e52585f6bcc379c16575cb12ee30f6d39bc0cd6569823e15000ca69b00d30c2cc06fc47d375ee8f5d4906862286536b4f0ddca8e44e0f2707cb4353a544952c5829d5134f80d573de9da2737effbe541341778ed9ccfd16716d2995f941ffbebc0144d4cf9aad80b8b1117dce77b331fefc7282f74b9a744d973f7d724abac42ee5c1855d5445ee376f318837a67700d6b4737f01268f3cdd2ffa08285ba243b14e7c232d989ea7b3cfd4c1290e6f6a9defaac4c9c1c82822090dc544c43319d5712241993cbd575290b77cf2736c30d938a7d66c19b6c04475e182d0fcc62cf5f23281142ea0098cb7316fbe60dcc33ca8c2881a41b5a1bba9d83e36425ba4cc7bebabbd6d3e48850251244b36cb7bba8c1ea0856e95a67b14558900a05c9bcf4232521d523e9dcff00ce7083c7214d3079953892ff76e6b1af66f907bc81b50f6b3c5c505015a9d7c2f14d63f44646d7c141bec8be843d4f26de17213bd54a9ce29c73be1070579baa6c45a5a974abe19c3ee392e4bdf65bf9028b107ef7a0c55b738902058118c1c00c75760e6d1c1e5d3e33d54902a4adc9ee73104dabbf68f285be7c19feface87e108df7491f07ae50699aa61e7cce1b10fbd020118578fe9fcaa69646d12d0791086cbc14344b94a621d0c9297f83475c6a27130df65260a164bdd4cc8b11bfa0eeee92e82e1b65f3e7ab7c1944bd5a7b100a6e1a0b823d564b5c68a0b1f11141d9d500c6e237bff4955cd26b9d39e9c269806197cfd5952b1647751876c38498381464e3a77f851b921a362e0b9368c14ebeb5ae040bbf5956e9cf965da536e0fd170195025d6501d5174c3340a832a47b5bcc57f39f4d3dc3a0258d984f4931a15660f59fe8b1304aa33fd7601b24de7962f00215beb906548a31036b4de90b37e4139a83c7538855bb2cbf1211e3bfeeebaf4c979d2049480718261bb946a3575a342b61cc558658c5b0149f34e2832a2c56c191de01dc3015653184532969b80c7a8ac0dc44cabdba5f744ca2805d6ed69f2dbe7890e3306f2ba33e8144400eb9c58408354b8284f85754b90fe851982c7640bde923206787c87c780b80531bdaaa0febfadef406a2285cea96d701264d3af90039becb501056dc350a8d5823fe6ed004202133f605b66f212283ad112e8bee05772dd99d834e4071b129efbed6b6f7a61c11151a919f12a232b63aea6a0418e4433a2789794099da06a1208893ecf7bdf17c31d2c8d5cabe7b8fc918168f3fa7a2f944a86d150890f7d4b5d5d07e1074cb2a252a4894cf438bf95286c046ef435c2856e4f755a8677c6d7997150e8afd91961e1edf86d117c192fa9618f8d6db7ab2f5603203eef0723db3615630683e391a1cf558ddf0b3701d86deca67e76a4a71a014b1f661b3483d9a21e605c51a1565f34480728887f8b340093768570af4f4d06fde896cb92de49f33393ab670091de1a61a612d596a109142982c0bd536e8d54a0a0097f43f1df9a3236c41feebb80824e5a401d7c59a075fd01f8c57baea3265805602e6679b3116607eb70074c12f4f3c712f03f1f0fd9808b93d1fe8c2e159f14e4f722838a6939b3785fd2ae306be55bdcebc5c2a3d0c4706f59f05546133c06501b59b62efc0eec3164a2f3dde5971de76d531cccdede83f8081457bdda93b431d445c59f3aaa5a4c8e1f8cf1438c61d8e040c414e5c979a70b376441097ac92aa3f778df1bbbeb3d8707e123f68d75ea605efd1303943c159e64273d19ffd9b1f0edfff7217e9e5bd70cec0f1bbfd56e748315d66e3f2f938d9fa96a14177d98d9bf2df5bc3f5b7f83a6953a1e7fe0f779a8ed927c227c9752cde6b2c0462ac11d838c1219c82714da87da8f7250855e841f658184397c0c80581d38b60ca049bf366c36fbf0be24cb453ef4cdbfc11006239b888f49941e07aaf5c5c4f0280d5cd4b76bd0d9b3ca48817d681b9d1e443fc2f442bc5879a18c1a4d0bc0532414ca8d7ae3138149ef47bd675e6de5b83abc8cbb3d9f13d4517bd5a22784ea013838c43390ce13403c6d3d918c869ad1b5b39f74f8cd994b5664ae545fe8bc5e432f652c9a48f3a3b0466cca4969559a8efac181d8a44f4a7f901cfdc393f2692b1fd2c5cabefa1764b35182c91aa0e6c4ed9a8add2ea85758885972a72d95ab9da7ad8686eae5b3d88969d8024d92c1fc69d9c5dec310a2b5de7a033702266f06a0c5e7f42cac5175d214f086404193e9f2ae427575d29b33687e41937fbcac3ded60425d9be5e1ea59d2070998b23a3cd9e9c2cee25e9751e45b77e4bec9e8ed48e672407262117b54f899874b0642ca9be9c2e768ea8f5725dc04fa356c47cdda33bdc4dad410455234f3850d39ba504cae90811888f77a29d7a245c9bd101b210c61f782d7c628bae3ae3f48374e9e3629e1720d169db905b62b34e9f7fbb7340336422af5cf99c72e35311810f39c5fd48ec9c348b9120c2047ccd2943fa7c8cf33c21a3d656c3336cde68de25e6238d1a9cb286ab878a8370ee810725fbe227d9ab8dc01210d62c609284704f595df9c8f2270c54e9dbdd0cb125685b28fcb1415a67429d26bac5395cff38e19c8629c13cb5145245e7818fe1a895e43306ac1b952cefddf799132a06a33ee98e6ee63e2ada6b7ab474fc513600a0236b9b9821e6b3c8f90e1156bcc3904eba79ac1107767615ec8f1d146c56594d2c1bab135c3db4ae450ee419804ee16ead4c4da04755cb1d05e9ce0dbd859367886e5c52642ea42462df2f1d40491d8c71265c009e7c2c4342ba4825551a105efb59e4dc2588e86dff7283bd911b9123a8bec3d5f115afb83f32e3d37c00d03775aa0c1a0a898aacdc9992cb0350141b60f91a17ff1e287c5293547c56671afb6ed2a8bfa786755717b6ed653898b2b0ed7b3943c5a594efba5e062cf85b18b88b29f54b059fca33416219aa9f0dd3b4b117ab17f38b029981b6af083fb81ccad831cae98a09ea1b59b0ddc1cd707526c81b9ac9067dc960a0d847aff5044c331dd23a8022ee515fdb88fd9e7009d9ee66e92cc12e769bbcfb8f9923e3849ef2a126377173915fcc5e586dffd4c29228e551f352dfea9e2c5d2b402a1c6edfbf87064dafb0ef14f6e9ed74b2d7643c65f5f4bb6f4765d581070bc3af4c7a84e3eda13bd35e23a6fe131965b2f6d6c81f5cf3b153b09acf40c70aa3072ad94794870e8c7320f2c469e437591dc3959140a642572a68148c6998f6f8dccedf1d71194435fc89820122a24b5033d3dc8033fef1cd4e85526a9278b5bf9302960d58752f54dd42b214b1abc0ea6ffcf8f18cf362fcc509d4204efb75a3ff463f42456b2bf951b69f316dd7428307ce875a4a9b1b23bc48e8a76cc6b22616a60b51c5b3e4fcc7dd0d39856e4c288ca47d2c039f0b48cbfc6452bef9e68a530e1a5ae23ddb11b0a1fc2a6b90d564b5fc7c8d79fdc400da101f4c9cb61996f035efe2c5d74da9f5c2253c05d11cd13160dc48c8daf2d8ddcaf63d667c0a76e7fdcc2981273c2a3dff29fab4b0bdc650e1f6f14ef2fe80d76aa12e57b1a7ae81264056186050cb7fcd7c3e74e9313848e6a899e26d36cece51e751c157b1d8c0b91bff8fe4c77754a634446ff0e1162236826c9e219d3274c62dae5ee1aeaa153cd48149cd86808c8fac2402798b0e4d0dfeee4d15232c59c7272470a30643d441a27c9f9b31577f3aa06dcb73b82890a62f7d10a6e0e5fe92cb28ceed7ee402f0e7f8ef8b9de18842c273735334f949fdb404864b2da065e58f8a37f2dd7fe5227fdd9382b161af31290e267526188e1ae33980974fbc611a5a5fd26e45a32d14811d65a4ae22b4beef659771c0e6c0bc3377bf9c820ac0f4a2e194ed4bfc9ea20fd782bea807bb1396203960e56604c931d5e565a67bcdaa34ef1395fdcc87730cf45c1bf6a37cac05cfce79b82d136b193a33f29abd750df7b3deeb4344f487dfc99d68a27d9f3560e48e5b2f7a5df36258cec6e782113c66dbf5db55718176cb2a468a7fc80fefdc966ac8e61b96f4c5319ed96d67b4114833ae5d9edc915aac67ddf39cd55198ea5f2ae11f6d5ab906ee19a860ebc5023e479820f47015cacd9cd0741c736e2a4f2162e92aea80c3f2f8d3863254286dfb760e292e725a1e7d42f70c2bfbaa71f3425f4cf57de21f5b788fd1b5af111c4217c433bcdb64b0e84f0036a98bc362d8758690daa892cf66822c2214e334f6755358aea5a78f6c4eb67325b39c6bb5cb3c6fb784086334fe2e0681d2678f5e77ca9c82779e4ecd9ce6465d81047d2a9f7056094f9275ecd414c2812af9c0005c02b38c2ced269936e57b7002ff780ca212f5386aa5659a5a09bbe2969b3e94c9c4d52250a6068632b6de8fd177fc79350e575cfb30c0029382a5a79f4b967dd454403c4ddf01dec993a3d48784bd6a5608b3971f736fb52b1c87a994b5cc028e4db24fdce71f5c289fbcc419f5d68782f28dadfbf9479cefe7b63c8dc49b345477fabe71daade3869cee37d31ada8495b4fef2bb04109218845812b61231f2720a8045ef35a89f4cf365fbf5c89867de1a4a0eb0b5e12cf677bbe261907b69c7c10f824e623868a4a4cefa90dd55fb905fb46eda3b4b0456549cf966a92ed05167fc54696d4fe0e5d8b4a5208f68edeb9d8cc05ffe631ecb455341cba739e6e5b08198b30a2427aae5d1fbfbab0f2260788ba31c03141c50fc86aeb225326dad0f9d6e6626049d91db79e7cb19580bc6646ea565c838b9ce0d6fc9b5e66f03c70e3cd089386b1a6b74a58abc92f8dbde2f3b6617e6ec2f76f3845f5de80f5dfbebd57417b11c67de1bc6f8174cb0cd5211f8dff8610cee8f61df17ae3cd62400df6d32ebda2291aadb44b777130dfc93cc1850efdde2e2d05311c9dd4a13a13e514c9b0b0fc0b9237cd3ed5edec7d1900963bbeb55e73966c50577c41a3676ba3631e716b2d5ef3d4cf716389d1ea47a7524f547dcbc74d8f5bf4996e47e3869e9b31abc16bd091ee73e85dd0412f5e8e440a6871a15437e238a15c27d143ac31db1cba9113a034ab41a044e8b8a59567b6594229d53a55f3e6da3663031c502c1a18c14f8a94fb7e19ea7b8495096a53a056f60976b59aac2e8c16c88e75e9159c80acb9aa79ead4330464f86eb45bac7b668f07cfffe0a29723f4c693f8a52afca47df3d45574750d25657ceea2585c2b0c8413562e140981d44db596efd57d13d2e6cadd0bc9dfaff069d7afcb729a494bb0a45eb2a69ef0f0dc6e18ae5362d0638c44bc1c5230afbd09a0a4e30160a49e97c0d26660460035387f2bca5680da45a51c2f852f2498ddb702d65e2b41718b56246f5020f212ed8f8e2dd6ffe2b59862fc5a0291de74b6c1297c56dc1a05e49324b8f46deeb09cbca6417009e6e620c11bf009ff8211aa284fca8d363eb1d1de5705ef9093cb76e475a476fbf6bb88a77c1586955568506966da0d972fe92c77aa609991e71c957b962882b4f2d15ada66b7da917bc9145edccef385d17d35402f54d7bfd826fd19170a3cd508d8ee82050a6c7a42ca68b61dcff020820310bf7babf7a5952715c57d4b4bd828d5eb2e8ee09175ec509dffcb5649745f6e1791d4bd9ad18687b82fe48e900107562766561260b0aef57a920ab0487549db018e056e9d7a9d4394fc5d820952c617c8496024eb1de3fb42599912824ab31a73b9fea8d9e4c95be5b78ff429018cf5a88bce86c22d50c9bab8a2ac79589e58be28c6e2f3ebcedc9138cb46847887a3addaa8c047586ad3ab660ca32277b1458a5a8fcd0419f2fde21acca83fab5f90afba2395d5dbaab43a73fb0b357ea0fd02b284507751fdc79087554c081171ea99d61a49a556f35414e0632b99dfcaef9f9aa67502ffda90360c50688e3cd0c1046b95b8375cb862952b56b9494637eaa1aa36ac033578b38894d65a7fa1003c01f3b3a53bf9483d952ba12eacd954d046b06a3ae166b7c684faa50be9a8ece34729fcd1c505845527924e6fa54829930292a2ce8beefe87637627866a9d0aed4dbc289c6034dcf24c3e9b7de2d7402995215707b05bfee4b814e7294388965e5107e046511a0df7b7ecfc1638935f3ebb03f50e80c1d66fdc538bdb170c1103508f7c84f45a85eadbd1fc28710fd8b1dfa537534e86ec3ed613b70af8715a93aad0e1facfc3ba75be72f2ffe59912c5141816cfd26e6453fa09db416c66874e9fa57649571b47e9fb2e81611d79eeec02d6398fc036d742312c045feeb9881887dd528a6a0b82c3b53eaa8319724d78a2810ccdf7d8a5de03a96d4c280b609cc18b3572c0ec8542d1c3ff1e6d34ca0f18ad854a93ee731b2e104af849a44fe7970234337018119b145d3bea07871701c89ba394db3700fe744dd1c336ec5394405fd6467c593691b0d979140609543f9d770da6667974a99b092df4bc4aff6365087828fa91f7009e82eae5b84d4e50b4629ae038a6ed2d06a40eaeb85726dfec141e856cc7ff6527eca8b665ccc281067b78e493e7a4b8ad12544e9cbc3fca1632932e087011521fc062261da029d21d0bf14f890ebef63c886dd72a0bf681492dd88e23651323833bb27222a8cd78184fd1fe41a8149591801dbe2f9ab5ff1f6c9aae35648868b1abeec81a0848c3e7178a85025960f5db052e3a81f2c57203f1de3863a577f488cbab6fe75727845715b392fcc6bfabcf1b86457a257c642971af0948192738af191a23217f3e0f0daa6a5407e25a0a8ae00cd046fb6ba179293c125a2ef126a798968ac6d70fb1d3603b26bc280404ce26c496a18e988a0b62aa32811a3bdcd97b9f1020260b52d336dfae08de35f9d260cd6f0120006f4f3caea770304b3aac8fecdb0b288a7fc99dbed5195d6762891d4b7fd14c9a95e57d588652737dce9607de103e61f03a73c2d3613f60c5a67435dcacf205e37c4825a5560d79964378b3afe3c5ec82d2f9a016a4835e8a6c13a60d05171e8760283d5d95ce5dacfd456b2abb307fd311309d1e12542dc133499b2ee10083b17c486297c33ee27941be61674fd4f6e8c596ac2b787358da1a4f631d0380eb5835377e9bd132e25f99ff90f34c6135abc487aa712860a555e7a8aa00df263fc79f91bcef226e8c63a810e8d95f2fd6e9cfb82832d668af7e529b331e5c172091ba2baa87bcdb605ed09b43725b54e53167bc78557dc4ae26c4c544da2534bf88df02783834722768f289eababed5d9ff855876c5b06d2c5cb9b2c776ec25bbf28cda2a35ae74d0fb04efd9f4ea333818124f78895f0ac56ceb185db7e67b9f60116cd860410be34887bbdee49187f5f6262f86a1ad4bc61850bbbe39e17ea2afb9715c6bd16f6f6ef0c856fb85768bb4de246455f14b812cf7139a1a72b203f581d0790dd2cbe246f55f7b2a221e4a1d6bf010808536e31f8f4f6a73ee0846a58810ed612b29f90423e9a59fed8591699046dc058779dbfafbd2f8b042c0c46dfd7fa0bbcf80663038f96b3a341b7b08d03904f4d9b201195999f24b6c35cbfc0313d96311fed2cd9dacb6e1467c667985603c2f47fa8e081030bd958f8ffdcdba5fcf552132009fad333884c8b6c441d4af822152afc4e8a48292189ca12023ec141b3bc5df2cfa4e22f9e8c715aaa0c2d985e04550d6845dba089cd4e07a4f0e25bb66e9d4b815483518f8450205154594f3dcbaf97326fe627bd5391f31d4d6027b2bd581d035ce05d05864f040420b8e3013effb1747fd4813810c208e6d89c18154d4dfe72bfe5e2064c1651d8c15d3d78bd35a97456b65d161e3b3ffbd7dcb1eb461cc9bf822b10faef1c428a90759cb53fdde695a457f2c15500d9490756be720f9af7550757c200d9b8f7dd030030a65c2fb803c478237bff016f60b768a4a9b1b51a80aed505b23c1df2b5527a1e8631477a47352d1fd3d4894b5206ad1ae944cad54135a5e561f7809a37a9dac25462258538c0cb452b1ea36118e75989991b8bd166cb7c96f2835b4d85b08dab2b5d5ea02dc7d8850babdd02677152deaedcaf88ceb419e40538696e0ed9d6d7f4d94d72b0e7f2e319d4ff962b12e9f5d292aabad031fd9a0b3635a7b818d933bb646ec090443ab595bc340fd3c0c82b2525e05efb49c9655dbeac4b55c5df4a1fd576b0c54dd933512e4636dced30a2dfb1a47526a175a8d05f7185fc101bda96ebee499fdc70ba5cebd18623f7a2edd0a983cf79fb5afbde99fdcd04bac73adc40ded8291eaec10ec1f70e8da53fc00a7a662cba3ec04efe24a62ec5f2363b71d11c80cd9059aff3f397debcee70ffb64e5887818aa4540fc5cf7c5de0d33cc130398232764e1244c5eb3e7eac2fa3f208a7a40eb9c01c0000db68ee7c2a5a1bc406d8c11e4fd49c9d1a762f6d0226a47e4813a1a050fce544cfe96b47759","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
