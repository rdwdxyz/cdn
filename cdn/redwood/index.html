<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a9fac1375b0e9dca68f720bcf19c18ff4e08fe5b6b2f784f376e0f72f153cf8f55ad8e2a97ada70a477bcf135023b22ba79385653bb04314ae94194ef2f1abf5e2d37af9d3e75615e76c99b0c5a288dd1a47acf34e012bc28dbced164458176c9126d8c0631bf35f827504b4bb7d12aaf1df32cc0f97781421651da83796fd5761600d21d7422955711bd2e7f84cf58de88774e9c93a6c6d06a02206a28a2359d7ef64cef4e0e1e1c8e3dfeb6b69d36511a6349b4c0a24c9fd7f12f1867ffd161ba2c3174bce0a01494bef79c17fd08336c4e85b31035f9fb96a82465d81f60acb6919a9d33cc850c5541f2ec13b1dca9ffabf5e4868d525368e0691c7b6a98d60ae3f884e2a23ae1a33f82556e288dd25330e0fab1602a2e3168ecd64c5cf088589b7c62ac3bbf9c6c3f1c7b31fcd31ad093d29317a5f149e03c019be0b371041b718bc5bcefc6ff62a378cdcfb97cd4f58170709fedb8bfa9991bc370ff412514af8d073e96f14a936ee1c03808c062b8d30673c8912f5e7b8269bb083ffdf295d082398115bf9ef5d130d24b1b725b56e515495840909fcbba0d29bf40f111a8ca1a1322fbadec2e53d1086ac4bef2d63ec80a99dacb46800015b921be357ba90c5c02625f7156fc66f6e155a6afa91b6363678e4045527465e50aa0d35d47a833ebcb4e760f635d27c8d4801357d19c6298e24026bd1911a5ac551028926dcdd4a29a0b298216a3170fc85ed1361417e22b33586aaa405dccf4d162ed6e23593a046f3dd6b5ae13ee4dc2eba9fb3bd99f0cac1ce8b4133b98abd08c2a0dc1d8514a3121c5d5091a90b2b62ba35f8ccf2579447e550625753bc99fa4a01b255a40384b048193f7be393fea26839b75d2d0e63d8d44cbb5231dd0ffde7c6ee01b5af1aad9650993ab6911edfdaf28781e5d5fc60b0d27d60d7e7b7e53514959a29408ed57b02e8cdde2165401fe5d6a97f2540782a6d01be27dc0d41db6c444a38b1054d3576743c20aa68314766d6ae8f7ef39b6f1020c7cabb32edee32bff1dd3616dc5aa8eeda6db40e6eeaa7df713954b803dc8f8f8c62110dbf7a7897b1504cfc95052716e49794ef3d469f008c67d056d5770ccdf1d29041afe80665c7df8320413453d12cc53e9944869af130e5d85fcbdebc1baac0181b0c1d36992ec4a1efcf47b114a653c7e761b216c3c75751fe4dd58703c569ec8f2de44c7aa18aff5102a5a1d8e54a3844d0e08197643a22b2c37953cadf4f6c8428d84619fcccc49b108bcf317fb89c570967be04a6763724ccf020174d78697861a0a1c9b0ac56f5f374bc179a9ae9084f53653ffd795d5032f8b4b78ca1474021ac0c90e92f0781f4065df1d0874768a28a2e0894cfa94374f77df7afe088e33b93f426c44481cb43ad9af92322f4f9a6ab4c4ec120c1b0d989de0021c955558b7fb422672543656a4816e282f0205413e079ef13ca2e409466f9c4caf4b7772d3e0befc0803ff1101ed9d8064f388c1f078bcba7d04284fa2b697c7f6616c30ce071b25f01f21d0120b3e4c43e0a5df19d7d205092942cccd2d4e9cd2f4b8fdf50d1880d6951a936dabbd12c885b3e04164f72ad36ef5d1df758517c796ec4f1699018ee6770b59f44fbaaab804dee41571992e4fe78d8f4179755d55c0fcc7ba217743463acd9d4a22a56df3c06b509699d60a752d197c00f7cf3061c9e8f9474825534bdc83dc2ba8b918e8f0d0124cb5601d060d4ceb87ab3df008db0a14729c5d36e9bed139cb709ad8bb110add896a47779c421d23675ec1af734a0bec83d67183ee75f0d3295f211d7eec037773bf209dd7ddcb8df6b4cc965ce7775781787f064ffad872dd3cfa4b4609a74a3f0c1f3dccb4bf09b02b254a5554138dff6802d983b3c67baeb7f6b86ad69dc8418eae64e9441c6729fe0310e702a3eaad96c6f4914d89a22300e2394e310ff905532f72bdd1ce05433184294a7d1913e3528964026144ab593ad82af682edba323caf7ae2ec264bd0003c41328bcfbed66d6700869a6d5f20ce5d37864482da147f912ec93f1892aaee4341b0b9bcf7cdc491a6509f4bf7e034970c3015053b43ae76c27ace7699a1d10bc69bc7eafda70965321f7fc648f03235f4defb93e1072e0691d54f27cbaa08f7926a8cb137b114a97332384db78f000fd287a6160836267664377d068c023af3eddeae3ea5187655f82aace687fbbc7228765c1f7a5f13a1a0d1cb82b2e75ee9a45dd12798f60b8c97070f5a30d674e0c32bbf6837bbda6e4180d91003d2e230dab9f5264547a73f43f7497d3fd2eb2fb320537347e0fc3060bc26fc56b4341d81c15938e79ae11ba018246daaabf2c834496e04f1f9793013597f438eb887603cbac93ced257780a96e0942a276d4f83ad4bd5f1ae2f6428654273f5116425f41f521a378f05ae7abe37076d140bea4dbeeabcfd6e2c4580f98c322abbf304ad289d4cb621cbca443b96a004d8b80d300bfcf2e6a5db85f82caea170a1d202221d8c98b2ad2b05918cee5f0fb07bb6e6d18eade473d4ed89d5bfd3556e3925ea5a51b905b48301af109293f81b2133321257c920e8ebd283baa13c6cd937bf1664adf721c00b57f4beacae9a889175e6ab6c772c959f1eb84fa6e4f57c3acd11d08f5ea8c400731758e6285cc40b7809e33c76a3f561a4e8cc3fdf474face693894bd6bb6f2f70fb11814066045681e0f95ed15a5ab06e4b8abc87400fe18e04a145b655b3583a25e7ee5b11aa0561529e409bb495439b523f38554eef7be9920547981ec99f2ce906bbf54ceaadd694100ff3b5a0962a654b14dbe7da69681b35d103c5b547fefe7a0b03c95aa6db753840563dfb5be9402b77d797e784705cbdf9a424fc2b1e311403bbace8067f83555f0e4d46de67f08ad0283367913bbd18dc2a40c1aa0cd9dd3cdada2afd096bc0f46d9b1feb99cb2d17ba1b9bc843fc8a1113bd6b0d08f9eeacc749aa83eece49a1de5db53de46be9e694fa92ee10c6620a6bfff96bcc21bcc090418a9e74eb889dfffef8a4c5a1c8d7a0bac9edf92f3bb7f8eb10d7510a4f14cb6ce03aafd8d15dde56abf93f09cd0cb6a22dd3e3c001a21527c1bf20d19e66a0dc83ae29091e4ec80caca44c94223ecf27342fddb41f0529efeb5c913587a44169af597491f0b306f645ee71755490c23748016dc063dedf7172c1b301e6807c18c1c9b5da496260b9c8e66c34002962d2fe45db5ad7623383bd735e6979fbc34fd1343faa343404a8900c9c6b0edba9e157c87dfecfdd0da65bf58bf0a0d5a7f39d88c471b902bd92456e531337aba23a34de5b2fa38bd2d10af517583224fd8cc9ab8b7632f5bebfe233347a9ef76cb19585f9de1b6e7f38562391e7bf64a8ad4f6f77e02d976e17bc30c29457414c15ad77fc4d512586683c768b69874f90a2c444a562f8f784ac15ecccfcc847e2277616f71e9d38cd0ae994535abaee88ff3b45141c9897371aa718d037f0354ec1a033965f199b46b4ee2dcdd02f5e26df6bfbfedd6d30077983573329dacd31e10aeaa17a0ec5e1b4e12d635fb6d734cb2a6021d1989a85bc10359586e5fef6efdb3d218cfb4188dc08d29f0e486698a70c155be2d9cd8c80b57c4300ec17140490aacf257020fe2e8f691b50c8f529b64817fbbf74977fccbbb8b6da09546ae60e7e0210e5143108c55bc232cc6b777dc1049a3b33cf5fb76f0334fb0523297a7ddd0f655015701a5806f40769b9bd99940cd3febb66a516fb883e98168328b994cec016fdce2c7a3e116a586c35853f89c0cc00d125f076341bf831e6f01ed52ca0547b5c7662c807b806d4401182faaddd9084b678b3d856955085c1f615c43e76c094d5e6af8e5189e465ddbc7ab93de28c529a30e97e4f5b9e2767effae60042ca2e30314c7973c05fc519e75ba9ee17c65d5b5924dc29fbc2dd3e504e6a7f7b533753ac665e864979f342171313e58d5e361b05df45eb408d09ca4d09ccdf54d899c604113aef8448c6b19777bdb6b8b204cf5747ca950f242bdf2fbc789ca45b868d36e3eec6ade8e1e2aac0132d97bcc0061bc432585d46e256e88b97760414cff66cd634e4fb6c14fe2c45c65b2fc722f56d168449a12845eed59b546e38196acaf2932fe4422cc1d8465f18a2e636a925476f7ef1bab00f0bddc66dc91c7f595039cd12e92dcc10a3376dc8d06dad8b15bb8f8a89a024f143b384f5e69ab326f950a4c6c826ba0fc33615cc3dccf1f38145fc72062015e4a5ee9736a65055afe5a47c57fa32ee30971b9616371cee026cb6a6bf5cc22360c44c9dbd139827dc10f441f5778689324ade31e538937f31ddc706f9975bd475926e69d76c675b07de499bf4de468458843b20e27d931b00e0bc12fb2bcad36d4e10f0f4656e188fe4428ffc2c4892f383bc8745465af941c5b0532e57d5968eaee555d7e8883f02ae1976f8ef8502bf23b9a5861002b71eaabab00548e90baa37f6df21a08ef253530e10ea4bb041de1e49cad96d4d4414ff97ad34256ff7bd800533f9c1450dc7ca32992bcaa869dafe144a26a4beefe4883f462e3c89565bbf7aa4e122d30f6dd96241e33d765874c7a74d3a2ca0a060be14f1fdbc200852e9d10fa9425d044d9ae1280c9a228d32bb2f4bb04a2d641cae6fa66d40064eb6029dd28d5cc9ef59174418a5d30ac22b354ffe3e4531759b52a4d8210be831b790c42973f0c1f8ca1bf4ebe9664997471281d78c9a140f4b45edf4d0ebbf78d29445d8ba184ebb1782a755d8f9dbed9ccd05175c6fb2684e7a652460c6d8792140642a7af1001831a3683106c74207e11a535950fc58686d88a78608731d338bc3c76459c0a9b3903de9b5994fe44463b9c6b6d1a2bc76bb69879fe682afc29092cf591fe487be4a3e6cd886072ee18c3c3609397cfcc20b3800991e6da229dc9498610c5a858dc809752341b1c7e3ae855602cadbf35cba23e8752c26c334ab1fd64fc607ca91eab57deff56e815f3aecc2a5130a60d14f568aba2b7a871f2b1b743651f56762d208c16d4f588d8a9a8d5de9b009ed69a1103cff5e415a5741bfdb5e2ccdcf54983e1279abe4b804b1317a3fc4a50302e7e944da08b16f70927b0952b7935d96f5a25fdc6828774f85508f4ab232038247eeea097c1f655b85ccaf8e760ce27573c46ec15eaa04b58a71d46f033fdeed6bf2271c85e5c4a6d41e3b8b701059724895bfe9ea5a4c1d5b53b7bcd799dca1ceece6d078406181dc0402caf11a8ad80940cc776eaf4d9a9aef3cc25f6a72c5bf0c05ba06f931dc06d73d719abe0c82c950283abbc7177cd4376d4ba078899debf527eae63abfbd1aa51978ba05fb2bb807527ba04d9ef6ff2052cf622855cd9448fe9e00980c785e0d246b90802b18edfd448d2fda8cd7c0e4f29412f9de1bdcd7f4f972a13a9ae74089be2697f95ffad347a561bf01eac2b53b7a26e01a320ab589fc95f3b86c443937ebff441863d1b0b962e40cc66e18938fc8b90addeb0d18c064408fa9685ff57dcd0547f34acc727ce97605df447e6c05249d90b22f1b0cd18ead580944550bdc36d36c06fcc30456561dbb26668bab1a716aa30a155f8a8f5790dc0d132183bbe8b900acd9bb0bcec9c2948513138313e8aaf815930eb33b278a5122751ac89bc5c463f60e067abf423719b7488d996bafce041474e76cc8ad338920e4bd7c004a313651043906a4cc501da565c8574574a8430bccaaedf33bc3c1c17626f2dc157d22d0387442e6c4942df52a6b65da1bdc7b33c08cebfd8325462874d915380ec58d1f29f3db82e37bf70cbf8d498da45270ebeffa2a1647b6bdd0ff7dd7e697336416781192f43809ee5f12e6988237ffcde7a2f6906c7dbae132605a88c94da45f1e601de7b1357bf9de95132223484e40caa6506043348a21d9318b3d3de1d4fe9f21294157f67e2a29d5ebe5fc40c6be3ba42fa3874a0088331d5ad681a7dc17d54e91d61164a08635066ccfd41144e2b72ce663a5eaa8975b43d567b6d55a9e18abe760e852a74ff7807b16c08fa3f976ea3c9b0e8a9601d54d583bbee316ce9ae8f5cce991c0f7537e9cbac49a2bed983fa5394c8bbd38e659e11eb1d29c2424f5a871d78006da94674aebd7747e4603457d6c7df1977e04f9ef2d130617f6aa70f598a069dbfb11892fbd6e969ac01ac788a9bb823e3f186979e7c76dde5d7de78702f7d4c20a4f2978becbc7cfa63023da75311fc90e33f3ecc3cdd4504490517ede60728290e8dc52894fa3d108571e91454b86c4b2b50b450263478ced365d300500d1a4b1cfb7a1e399fb430344838ce2602d894a61d49a590b2f00b629f7d53c874dc6ac8736f7b03b74a8fc83418d173068ba45fdf59fb7869381be4152ec2ae3681f583cff9dac961d2fd471569fa22b423a367564569c7acda0f48842dc1aa7f0fe361b3c1be38afe071f94f3fa48f581c76816e560de8b336fcba6460da69daa83427b1607c49cecd6b0bec2e6e450d61979948d40459406e732cbe9d79f1d827a507530717e141a5408a15a57a14e410aaf4dcc6efa84b853c23696242c1dfed5ea5173e4b192bdd40402665f32934450c24f193aac40b8c6508b8f1e56031f8111f2bca6403f03a47e6ae2215f5ebe5693f7d13c43ac211613ed9ef993c9053ca09a9afccaf0e5afa5191dbe60df52ab07afdeeaf4a594aa4cdb602f7d73e0408a0f4707bebe606312206255edd4e912ad9e15509c950bb9db4d6ba72c9aa24456f8e31a8722b3f0fdc1c05d4e58ed7e35d5f189ddc9addd9a3d9a7b3d64ee550463afd118fce851f4df5e6dd5ee3f2831020e69b96cc13fe2cb7ba6d248b85964603449ff47a1a5f960670a765c97b3db4a9615fa046b2b0a121c64d765a3120eef50a6042c6cf38b18b17608ba516bbfb236ebd3c9023e191a9f2fbf21cb52ad35f577e48af5198e162e9ec1d21e309dacaf5cd7b07eba3957b4c55061b7e3240ac9297c6ee86200bb340ec32102533410d037ab578f88a613ffe6a2b15e3a0ede6a2cf280cd1a23250520a2744d0aec5d2cefdeb7afc7e1289699a9e0c4d17c9274d7334c51e227c631ce8b5993b300220bfa7bea89d35d05075cbb5d12b0b008479cd73ddbd5f60a70ac65561fc0e333b70013d719576433812e5f90cc85d71d485016b79c9f6f2491bcbd8fe846ba6951e1a5cf8915847a16008d6d763c8da80f8238a9384f003bc0705d55c009ed876f0e02caabb71f18d08af1fd8850c88e613d2a747e9821b49231de2f93b784920326c249ed250ade2a16631690da2fcaacdc3f5d50d81a544bb4afcb56b1eae66c4d1810332b3321ea988823e0dda984d53dadfbff5a71bb6e19686deb6a5f841704f1ab26e88b048738ee8963a30b13cf9c8b6590742ce22b71460446d2cb0596c4914160de8c0d1bf12da216f0a943e2d14f4e864c0c9a7c2968758e27ede5959322147ae9386dab58c38e2f6c8c37ab6c6aea39cc40312a4747eb897565e57c3a0d831fe38da7ccee81b52a7c574162e26cf1d23cf1a95be875af75fd13c62a5fc695fd9ec17e3d334a0e9b23bfe9f5b93113839cbaf20dcceb210582897a369f843a8bd583dddc4872a7f92db3d8e4a8e37445387cf581f02a30d13e367dca16d24482aa01364522ed23ac0f371075b2cf756b32d218a5afb16bdc697bdd31025b00ffc7c9f88f070763784cc3a751c496070da56ed91cec929772d226fd0ce78830e6c59e15faae6cf710da02741db629ff08d68f3d18b0b99297473afb68ad5f06b1b7b08a3283cda9e34f7b263595123f044b1872ed21dcad1fa165ead8b3e8068556565f91fc1dc2756381d87c1dfd177502725f45122324baf4f9f1e54664a1e8afdc2ac46e6e2b09c5a9d8878e3771f9d507814b1aa36e3fd5c6f72d7205d1dc563b76726884d5703a5f50a9250d5dce8f52780323b67f44c135fc4caadeae358853a594387eaefb6c1fbf346db28bf017a1abfbe793a66a8b6d92293e5998a348f9a8d2776b4b1a2740f92f2f32257fa7e8596f954e40103d8c28097e42e6024ad373b9a004cab0c26cfdae8c704a9d77698aa27b87d7f936a78e6f11d7ec838dc7ed3a115d4fcf76f641397256f44e945b6e57168d5843ff35acfd181f198bf2517073edd9b07febb9dc1832198f66f72f2efff4cc9ec0b154e8cd038de4f57fed5089507190721f1dcb558071442e1907b3c199eb560ad34716373d89e8d5f749e1885ae97033b265a61a5f9c793e51d2a5a7cb5e2d702d5dda17e4e72d1c2976962ef5befe5e7d5bdf6b6ed7a0c9d749f8aebe3085ecd6b00f7fae4cf5f95be14f3ffc2fa5f74788a0c721362cfae11413aed6fe7c0a4a8bac52e55081824f99654b9cc960cd8b0aeb607d28a4ab35b9a6bd8be843109a679cf93b669e20474f27214197b4dd58989d855c8b6544cca125574fc6bf1b482431b8b4c9865721eca900403f7a51bc354debdc16fceab32b1de7f223265febf31c9676ec6774c3d34bfd20c605260916be38fb635cc1cde0ee8978ed79cf60c1122da684f0a6ab583203c1be627da1f2eb32d0329f5cc555fe0c01bc321e113b1030fa6fb7589db6b54e063bc7261916b392171dd02538fbd002e9f880eed4ac5239ec53e9b8cd07f922806dd9b17390ffe4ce5f839e7558650938f54af167f2858f35b02c3a4724c79611451a763509a1fb9d08a17820e45fb00e32ef5f849342b6469611ffc38a8bb17a0fcdf2e9f423f9caae3194bce1ff310f0b7f112dd05fb7255f478140e7636126803d0c4cf7ced33f6e78e906d42a486bb4df459d67dd78fb1cd0558993adb702e8bb7f240caf4794f31cfa3909fd050e3f7c7ccb3a7a4e8a99eb38f8fbed23b83167c0a50e717d89ade3acc0923a28cb20c97d33b3a8a268e68664f89e2dcf1f5a67451688433692d8b25b8fbc2429edd257ceb421d0c7322599d92625e8ddf246c8d2ff570ec911d3c2889244004aaa76b122531150948ca826ea33cd3d57b0227d4f78628b5b97688f996c10693eea641925debde7f7ac582b11b6898788b9d580b65271d755a7c99fb2b52b8606fe296ee3ba295dec172ec94603723c35873624044cc9f1667caa87f9f7fc0e43e0a6baee72e2c7cfab5c8152796be68f6b970f4dc7056c3cbde3211b0733624a0277a51ad996a5295cbf4f2b21de70718737d5182c40ced2f8d2ea34052405ad144b2c607f8dc6915fdb1e407f16ba8cfada3e4aa92444d7e0f2249216636d754db0e6644bd0339e80abddbed85602232b5f2a90922a66913bcd8167474a034bf8343eedfe5e46709eb1a2c40ca077364d716baca3aef15c4e45a57b62ed33b35f6f5c38ba5035d26ce8465c84929d33716e74990c926a307ffeac5292a4c8015f04c5330baa4638bdcef3a2f6eee9eb62193e7e384de57697abda5f4686df7b76ef765cd6fc376cd250644f00feedd9dcec9d309e5785173bd3ec575c8af6853bdbdedffc8a064984fe8de2c4a10e0f742d1f9407927f871199ce59aa915f5bfc2083eb81a887cd8905425029b1d648d9921fbd214967bc0af66a6b4a31641537842455253dc0a8fc44cd0b6592980f84f1a9f2510af0c666c7af9b4c024d89ccf850d602319989ba23a9c34d87e04449a6caffc5f6972d0693eb6560721cf97ff5577817680fc8b9bdc6c1b8cc8f9321fa7c60ddf1663e59eafbe53fc54cad6fbe1957134c743a2d08f99f88e30b8a2afe5403337f6092ad28b475ede27892171c853ef73f147c4d14fa8de77bf3f295bae527df325448bd695e5f01aa15758dc179b22565a09e56dec31b7cdb53b28cd808f05b4936a6b4e3aab54ad5a266f942509601a857476f8400bcb1e6b0ffd6be0453d4ff41776447bbe0e69c16a271487e3d9ee779bb9964a12a73caa4c8e0c441a4dbbad181f0b16fbf8cace92b273ab10be87bfc0481e9073563484a5c8819b86910db88b92a40c3ab0e0d6271003a4f75ef22da7283a3df42b578fc4bd47cc579af828368013820e0b1b765b7194679c79a4248821cb561ba3ee75a110a29c2a050cc81cef5b2111d0edc2a3a4e4c6f516939ed3e6de6aaca57d9b9eaf2a514adf6631ed722265f2787c678c6961504a62319b1cc65c6e0f05409a655b41c154802a89ce99b1c03ca1bd3f5fe560d653ce1676963d5631859fb9838471d2fe71adbbb7930e67eefd2c246488b98fe96ad42f056161cba7eb7b316ff7dfd4911a6c92d2af2bed0bd34949a544a704c9c6b72aebd046d4f10b5f3a14d40649f7276f1bff4e2efd20a391235bdd440f52fdf0e65937059bcd839a1839da11198431be02488ace2d86660dd43b52705c09a9f572abaf6c46c2984a2854e0ba85d2e0c752985d8087d4b68a8797fdc2f8c58e0f6aa7f80277d1af33d9e564b187320cafdd31e1b5abc49f45707d51f5d2fefdaf8956f3555bc85547eb955c9d83aaed34482a4fea4438b3266cc2f6afd6184f1c421abef2d7817caa5404ff9bf6fde97272817f2a25f683926b74e1190b9e348eee2ffacefba9fe610a0ac4d3928adbe507d17775a0e8336f68b89711f79dc81444792af975b9d94714936345efd1f31abf58ba4847e3617fe31af1e9b6fb6646c66c4a2548a01e3c29693d5b8b261a6c8531b6b561f516b01409e3ec88ff8c3274e9e971dddd526c1fc70829e6e8655787d5fb7e88fc68366a2efea333de55af95af3dd3a8f68522a057d272a692162468ad22d6df935d04086becb6b29649fbdbb6a6780460a7040bead1f067857da7d1073bc2ac998f781118d9a14522189dda47c09f8632585f11a1bad36bd3b11dde76da103874370ac535fb520a72769f189a8289c7c617ac25076f382b3d59b9fddd38eb63b06751f31777bb43a90cef5214d8968816cbfc83a6809175a961b4652228af233c48901b5246dbe4ba5ab7b545ad4161a0571cf1e9a9d4a176b0c488aa929c09d962591aaaffa5c5d9fd1861d629c7c15d4e3f059bb0b51592b84f8e9643eff069dfde00bc3a3bcec489bd27e51dcf412fc96c05e1a1aeafdf48c8a54c8420f8cbb4095f926fa718ca9149f16d508e9e0f1222f6958a26cba67aeb7fc2f7efcfdf7d6f1a21a408d3dd33b009e7c17c2680aa89c22a6d5d0052378f20f49e8a5c9f2ec2abff6992d3c5a05c502b7c677f1d48564689939ef4e5969742259e1b14a25152edb9f9d5b4bea90dc967893ecc94e1f48e7071d012f45d03c2f4ebb7e62c2a86996149de6a5a6f112a1a93d9fb6f8d33eed0962a0e94a67a28a44f28f9cc6b984e5ab7c9a77c1dae4d6fdf5e59bc2528e24771ffb64a5a9fec071a97d2c01d7d176a51b36e099d32cf6153471f0f76b61aa88be59938c8afcbd5fa286526e028b902400901b1b3375a7efe49f44d03058a355c29e1c92beb1bc00c1b7dbda754a6e312ff82aedcafb64f6112d498aa7f029ee7abe62ba25315e9cf4b73f95f92568cb99c266d2b2de7db6dd195539378b3e04da76dc6cbce27062901fe1716ead1eafee2cec45aa2b3925a9e88ce67048b7b3347510219702f80b164d966caf415f7179f893de96a2070ddf0eee58ab1540b6068666401910e00d2b187eec1a493ccd2b52328d16dee02c51350851c55f0542e54e41cfd72ddbb97378eac1c6e4310d5b8f0f5ba835649a23f51fe25f72f796fb2d24589f749c7f799b308c8ad92339a680e4e746bf697f0b007437041dfc6bb5d7693036cd458a71d48c6c6919b40058dd59590b5fb0e0d5e6e6b579fd1ef6376e25ae1e8cbaaee5dd9f8bc8e7e51574ac7afb86bae001e9af99eb11b5a4e01f42d4cdd03168d00baca077ffe212836e861595f57c55e6e8277efa14f2336498127e18882c73e83cc42476d78bca0627cce50f410b489d49ec2e78c3115bebac4ec81e7dfe96b386d1af34f15f3b8d7e8f4b7f61f248ebb37a6544c8c3f18f42c6e967de30094c7a84167d5f432dff1ee8300f8dcce13daaac5132a68f614e09628a7f189433a102f1da8364e91dc2899abc917819da6a524cb863cce7d31dc892b74c2a82dd4f68e603fc87ea5e00175b18c6729cfafd2d87e363e6eace8cb891b7705ade96b5c8299f11bf087977b31ed2085286756d7ba5ff9530e4033222b992c2a7c9c00e9df4751ee773600437ede8289c75983e830b270edc711f94181ae1ffa0c9516f6a47ff46fff4c37e112db986cec91b80a35449de3e149b600870804daf62ef306ee20bf0e302930629eaadfdaa4581b5e523e378c9a3bb97a90bc0188f160fe16e9e75288af99e942f586a56965f4736a2e73b1f05df432e44d7a63c0ca2a6036fba8aed19c8ccbe4b3946a1e1adae8ca55be6ccbac38e9cd0c4d5c2cba572dc5c93af52351ce647ae5f010c9011662052cca25ad71af6368c2920a3a428192093f2bd0b093e06efbe48d5e9ec8368d629f3e0d0200d91cae892e07eb81caa66b2ee7a8e084bb1b8ec44a37bea3b366d90cf7026e7eb2fdd9b0cd25eb0b18b5043ac87bb6e9f7401b6854de15877a599f000d9b886133c9a59878f567e60c15b99feb8037c9d6f82a6bab5696e9b088073a14d82abd16832bbf0beaba2093f7e62076ee7635c44d09cd60f9deb1c7cf1387b299cb9c5a8e8c8da8ba25c78e333a3318dfceae738374325409ef326178de8804d7ff7c18ebd27de4901ca423e5dca09078d0130205c3210554bcb43a8a2bce06b9ce0d7e5101396e2f1830f56d6b904b9c99521af36e737c853cb0d10f438d161d9677ad313a7657acb40d284435fdf369710b95597f97ce3390bdb45c5479bfefc147b116d9488c6d2ed3b8d08b3cacbaaf8b384fb1b4c86a4140a2f06b4977650e41879557b7b0e7472a6e6fb91f76537568546f3290e532a65491a02eeac76220794365f8da105a0be1fc35e6387c39c27b6dec0e47db94e8d7c74e9673d8694a4772f008c0972a378fc0ad04e177d994f6b9756dedf3788f2d3fde56fc39412e41ff71a58805d4b2c35c5fe07770f2fd6fd86be242499d1cc42411e4123ae2ae91837e4ead8b01430b457fff5e158c7205a4df1610272f71a4a9d2e7a135bad7066c8504ffcf4f5cd998c85a5c5a9f2265be101b8ff743821423cc82312e247b532bf3da50d84d31a5c9ba69b97bc8ba072893a3946e8bcfc1ff6414da951b333251c76fd8d61bf9f842e2d35ca6bf3026955f0ff45bae21566cf01f009ec70bf36cd1baafb973f4fb8bcdebc06158cddf8d4f70489872b1996a31a39a8af9ff337ec3e535c201f8d11ec1abc30e5268160df7192320d775e92b0c82bb36606065af552f2b9ab79ee9a840cd3e0573801ab42b79aea35f62711c0c68dd640e09bb10d2d62a9ccd4715a39cb9d84640cd023cda94c69bc6528048b1c0a0300e37b79ce97b6a1429d17d55bb3ff6d6d10e386532cbbd1da1ed58d6866cdc1474280e3017372436ed1f0b99b26baa1d9fdb10ebcf0bc8f7f4a49268e33d2d7bb96cbbc4f8b15d54298ef3a33489d47d680086e44841e3652c8e05396639f21f790ce58800dcc8a1d99b801c8eafe86a5fb996788f113aae289057a2b0670dc0ae85d3f538ae844f1120eb65819ecdacf3b9d96ad15b47d4d26a383fadfd6f658672ee0687e8dddaa783d38f21ec24534524fbf07228c17022ad2813076e4c7c2a75491d852ae5b1f6d7ac4a4110c14877c990e63448d08e848f7d16f66554d64965f1e52f9b2128f70426fa6b58c46f543bfe9f4b71200acd17d1d19394360824cb95e6f7e66bc56fbfe240ed04f6774a2e9ac1acc4f10a10ec207d9484052edf544c6c3ea955bc0665bc5677beceeba579a1278bfd11f064b074def4c001c4e2046730a5cc5408dc77b09938d04f3072de6db11a3d6a0dca3cb24082b1b34e8d877a8e4d31b3dc337120aff0e2fd97e0c50f0e5826658114420c8dba03e508c6d03bb8243bfa1444000a0e80ee954188e646fa6e84e8035bcb29e2122167eacb188f8aed503de0e31544a0a45a04421b82ebe11fad7853f220d27647afe4254f6c62c6ff4bd499721356d0c2c7c07737a6847cffe85efdc9dc5d260d7170d7d601b4cc90a827911c599dc2316e698a75986a5967ec676bb7a6510b1b6e4da2577ed46bb6f195d85f5aa3f012087a7138aeb6721eed359da718b11a858a3507d522efcb11d9f81cddaeba335bfde578eeffe3f7b3e693d41b8f7bebfe67e9430f5078ffe9a3eae69ff9144e531c525d05dd165adb4c95bbe5b43ea730dab0429ed989d90b2263311b6a7871a8e8d458558f53cbed8662e601d2f38b944ca2629f6b3e1957d5d173927debee84028a3a7296b6e0297328ee8e5efad509a49b6022b23526dc81c3676501dd12696ff4d1ee68ce63c06390d69c5399ae73f668bd4d1718968d5e4dac55f3ce35e74e7d881327e58b8ea890e4fc711a2999e2e97c3ba8e8171315fed9ad63d5a7ed8aabf76623066505cefe1ca9f26fae44618b6b6bbe414d87bea2a2769297b81800aa1a744df40d877ced3137e52ee378a2e7d9ef2534e607254bdaecfc3d9a5d1300d2fccd9847f8749288190565a0343ff9f979d4ddae73188a96eb624591f8394e107081e5bb8280c45799926647674fb7ce3cc88ab6bef11f9078cfa189a182e4d3b232acc242cc1281642878675024264321a4278e04c6609abd7e1bda78566013ecd828e55a3c11b86822a37aae4bce155cbcc11ba614ec0b09b5d275a53a2cb060d6cd59d31da599fd69a2e36e79b99b376f502763b93e500351e3313de460fe9d7da408141c9e684136c3f53509adcd6bfa785fda86e92be136e70442665833927d0535258b543f8b71e3ce633d2f3d3bfa322987fb6922ca8fc203b81c5265766261dfd3ffbc11dfbad64a9e332d94bc1c837c98d0f551ca694c9d81da02bd2b8b190c486cdce10378b174ff7cab4124497d55cad234e02970695ff268566ea0b869420e92a35e85a7c8e242272d786b0bc4d5cfaaf35ae5fda427c9469cd72fe2cdbe5f8e77dd45f7c50c6513f530cf09aa6bb33ed91f05ef4c49a75fa68fd8fc93ec3f1a7f3154f691416ecfc13788bae3781b14db2e74198047e4375da1ebaf826e36d58f70a08a8291ba6f2c77e3b7898cf31c4661050c4a908baf352aed1ca9060692c65d4736b1e766491bd28a60ceae4aa9910b384ce5707265c4f8380056e282f2656200d6401a2fecebe27a4833eb0da529af9457f73935ac1903e487d884032dd7c3ee9bed85dd7b48b69e8a8bb79679e01cbddba4354b4bc693cfa9e1d7a1c68e9b6bf8e4b3addffed602e8559786cffb2c11534b06466e211184596e022ade129f168d21a334a30be830b08c5fa4587fd7fc8a0988c9e4b6e63551766c00e420988a4a7bc2bc993ca2adafd567a18abbfe377fd66ed5be55901fdaf111271a6a05c4aa1b98a599bd30f39ae728278745a5756b31e3b6b7a78cbe5142bfa7c4b479e972db28943c3dcecac05e9728da45a25874e3c9c939e87e575489f0e5ce38118ac732fbb59b8be0ef5434e5a9cce8024125911c2cfc617764bc8aac6840cb76e3604a56895a0299900545903360f2e53feb251b68ea6fc1b889eecc4071d18b9b41cfbaea2b8c81a3060a015f106ccd98cea6a9838abde07937ba7ade8e952a7349158028ebf49210bd84abd2437291ab9c123a80fbe1b41c6d5149aa08d8d99b8d43beb1f57a3c1765ba4ddeb47cec620cb70215c4d4c76537f5a594dfca97b63a8163b3fe016e83bc153acc99ed10f65bd1d950abbbb6396f0c425f33ac178d73cc4c01e9e678b7d97997ce2869af342109332fb10cf1a2ab0de41655108105d06e6389a2e3eae636385e93d3a7c573a96f4c5521e43b592c4eddac98ede28d91469d58b4f9cec6354768b2b3e7c50be70e34f655e47aecfe5cecfd07d9a8640c606f03e87c66f3e8e93b81c4212ebab19b8bc4b67f351e714145364506fc36c9853db26f18808bef0befdd6b9bbffe2ea154f8054830b5649ec34909af3c37b84d139554129f6fae7316f2551c70cf34838196f63b0e28d37257752d1ca3f23131f5c3f4f7d8679272e49e3148f3d7aaa42e888a5aff29cd8b832f479f0c636dcd4e7f51a8cbf3f26fa7be0ad3bb9edfcd875f303d6b35a74e1b4c718a35035178e696e11eba3ca8109edf62bafa881a70ce3477cfd493f3c416038e5677427660a7be1850fa0df55bb4c02ebd50277ad993a71dd1b0bcd5cc8704b57c322de971e9697f2fba6a0e8b11558969f93be7d38fb3fcb0ca03804a46c78b48f817726e942a661b9e4324d9b558df55548979be22f91d9ec0c382fd278972288c704a26086f880166f5277cfecb9d5c57458b2a39f9148476c668a9782a8f02687eba4bb3b045da60398cc9f2afb5758adb36a2c6329322beb5f5bb0a0e426dcf24ca4ab743c2cd86c9faf2c9ec8ad6f5a43f01f380aa7e5403dd4a59ada00874c0edbba3912a554a62a37c84e70a1f091158555f3ecae5b1f2ebb37a875fbb6d82b3ec31c3f7eb94dbdd3455950e9f52ade119adebba2ab49f0fa0232f622a2c01de3f91855eb20dbb39a5e8a9533a05338ef33de2fe5f0cb14d41adc02c1dda99fe7c1d0dfff4ddd7d16fafa8bddc28feb4d131525f6a59be62ad496efa3083b0f9dc9b3935ae9b7a21b928255bd88d7e4d5c5c789c548653531dc5ec87ed327cbe4ac10d4410c3918311da40366c7bae783ac2536389f88465cc23376395a351e645ee65e67f6f927883c4e7a8074ac7a3b4946593eef39d02d9e28f23d66785da0d5c1bde9d58aa3e9e231fb0c8f15b3d7901fe51c899da749f36ef1b6c660ef74bccb559f3df797afdeb55bdf214d9e7d84bc0e1eaa540c0583c7e1ffeb976ecdbc6e060ed9bdeb42f28ef535b3f85a510545f0c8988dc8e9ad10664523fd83137126b921eae2f95b6b15c649f0411fe56499c71714eae23953d03ffd769140c3dedfd2b371c5d7bf2eee3f2a647f701599e8f5226b5a0a36cea40d62c1b34d3143fb19d77b0c26e617474f5a718412ad1ec008f21f9d0b62ca67d63cfc47b6fb069e2c981c17248c1ef827c1162ea191a5d584caf8d23e2c7434f25bb633943fbf3db94b6c9d2bb8a0b9cf790a2dea7516b38c293d277a2306787d6b80008a36f03c2be47fa32e440354793f9c80434fe1a300f6efebf6e1e1f81bda1370cb81d6101c80b42bbf97a95576a601a40142038d3c15b8b5889ff2be886b50d00bdfd3ec8cb612c2bd005809d242dca5f6b5a17faa3fcdd7a3321fd6d2e5e7164fb525330ff2fcfd07b8f204afd899cd12c2c676e7f05fbe736a2b197bcb9c7d501fad9ed439f56a39378a653c35db8df23262ac7f1bee67f2d33d966f808674d3897422337d576ba7b799a56bf2258654fbf03adce5c2c42f9cf7e2428d1a47b00932a72d8c24fc01280d63243c85a5ba1c53fc7af1c7da0302c8029773a64069c4e904be4a1d6b133b767ed96e88e4b629128ca2dbba29eb7368bddecde49a328e840a65bcacd4bf82a55eeefed07c235e88b4dd309bd71cb61dfc354ffc29ab393ec6ee6284e385c48aa9dee249c0843a7ee1cd9724d426a752eeeca157d773296d591f5dec5aaeef8a09eed5e05a4b4e6058ccad94b08ed61946f20645ffcfff42e51290aa5f1c2cc233fda2de8f031cf3e326859c22b15ff8e75d74e856bc4cbebec1faeee7a334e9a9261e47adf059e1e538edb2c4b371a7cf36947ad2e6ce0ffc491d6b79f6debeb3da926873da4517126b04c53371fb741d5b9702a702f813d487c6ba06b7d3934694be96f273841ec24a45efa41cd09630788f885d1e6252f0cff3bbfade85ff13d6b0ecb2ef3e9af5b7e7e169fb864eec1db0060bbe062c9deb58d76a2cc6b8807e0e109e112f82f8a35f7b11668bbd0aa6ad23eeeb8c7cd50e9628587df9e845e57e4494b4fe5a5b63472ca9298ac7c696fb03b13e78576cce7751d83e9bb029f344f15cb16422e9db8052","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
