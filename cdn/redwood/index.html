<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f838b82efafb9f3d05646f3b9b6bd21db289863723289a6670ecc147a4940247aa9dea521a5122ed213a8c8d5379ee1d21b4695a650b0744948718861dac1f49ed3fb2178a7428b5790cbbc68323b45c3e361956c027fc539e80c2045320d07e6157acdbc0518605b1eb07a1b78d5ec10f546b2c80e37bc65c43f268ab8f9528610b35e91581d39bdd0861247af5b0bc472fae0135c81fb1ce94969594fe97597baacb5b80213de512ab750e607f3132055353010b37bf1294d3822782f568e155fdcfcdd5c07d2e6a53c30abea999b3cfed7487e7fae27bba1dbcdd69077be015b1aeb87b281fed9a217f5702d31e84534ba692a7298aaf6e90fd4616fdecbb3b17796cea02f22b217b7994847e42d65598bc9e2be81f52505ab82b64d8ea880afd7df793e4c596d4ace17ae145692efebd759df522c66431746f7aad6a8844dd62b2b8e430243e2de13157de5e67597981cb9c5f23324349cf34ed2de1ed83480647d55df3115a1c52faf2f7b472c4abd763125205239ccec53a47d4d521738502b8a64567ae3fec3fae36ff5c23bd0302fb23c93b4ebce0c112fbd71a40e6c6caba34d50822ed5d94b3b091fc3e12a9dd7aa89c3fbcca02f6cfccdfe37f49404e5797632097432376b9b99e47938958e98a2ef17200b61536682c9f2075d0b99404bab9865d75912fa16143924350f88868675471cab82fce4a119203d512d0f2e6f1bccab044364680d2b37895aad323c648fab501d161cba1f1d851be0fbf3d8c69d0d59575a2a9bd33664858eaff145f92864b85a5b89a1f43f01c603f951c4d3bd123c7fa1d9f668dd88965e994a915c448de39eb985e1c45202ef88bd493e698668b31cea6240b3d8c73fdaa6d923f717d93c528a4451ce940b42d1d1061acd88c7fe48683df4808b81ef2ae1eebf9b16653d471fb2a179cc66487d485227ae95ac1871b267dc69c828aa2bab1847d93928a1240af1c01c45424db391ee18c351220a88186aa010e47e1a8f781dd122c6f33eed9925a6d5da0b3c2afdbeccefd0cc38f2fdd3a0fe81763ede54ed55cf4b2a86364dfe270115ba7a737960be605f4fcb23edbf75c17398e82c724f68c5d118da667fffb62fa35b5bd783cca49299ad467beff3d558cc7b788d0acc926dd5cf7d034aeaf39fbfacd77159b022773ea714e3c2fac6dc4de6e661171c06e7f267572a96623125ecc4d3e82f3e8c63ea82abae612ffacba947ff75fb6e168c4488127b65faafd770e49198e676f864ad67f205b1c347a6b305fd26c1eedd3dad901d73f5a3266a7d981b7c3e65dfccdf5bebccaccdee72bf52de5e64b25eaf2789abb0527f836fc0bb8dea0a748324a0951b6b6f4a086e89cc10bfcc1112ef53c3d759165f488322db4f89eb60d0f34ccfd41a37a48e2d250caa442bf6f11bc9a50c165bbcd84ec1ee8bc8caff34c5fcfab446c70104bf2a2ce541115329d841bba3df0d0a3313089e47dc432f3adf3ecb791b6a2ed1747483ae5edb4004e9730ba871621c0b08a6aa1d2b447920bf3045e4b27d73dab420d415ff337df581f68469c7cd98928c37b4a67486459571845fc504b1a528351f3eaa9856418ccb8a957f89cc9f85a7aaf4bda2b89949dc1c9238eb04ce1b307ec112a22fb3084aede2b69228c6ad7df71be46c2010a221b64ba34cfec3e911315aad9b35ce1cc4d77146149e61a2c0342405b80d6a880fe4864c50f79d994008def08febb87c9788e8807f06d4c45a15b254f999c29bb9e060140cc1b3dc198b35af659efa5cb98b81e5eb416db51c5c2678eef96c65bc146ae9c200f8eba3a58912b3414e6a608efe82155bd06348393499211eafcbdec363417c5223d614e202911c46aa673e3a75784a754fe456135c942bcd70c76677065c28d577b88ce1cad03463473b9362c1bc8d3dae1aeccdd70f285198bccb192c2db761c869c12126ecbedd0ed0be9309428754e23dba2814c23c2e72781a4d44915b401ebafd8afb1e0eb2cd84ecbdfa64bfc1007cf3ec3878fa588f14d3e8fa5e8be318afa38fef1ffd84e2583b939485d61094ca09c6ab0d625d89a8b0109b583233a9fa698ac864a6c3a77efc5add7625cbed034715a0d521c4e1cfba075a6874c252a3091012db8875213015e8dc087fd100150906032364041861be55dd125af490e7be25ed56814f199312302d766ea0ef9c98e78666f230f2ba0be685d227c025b427708fc61ebff4c1ca736b0cd01a5e375c466240bf4e5a12f8ee482ff94a8e70cb885b6c8f11c2f295b40eaa99fbf4477f905b126b5fcc2671b56631a62c8f00608e195145232740c026816195d136c106096eeacbf4c4ace1cade41cf45ad02bdadbdd0b232fee59ee27dacb074f769bb72bfecd1b95ea3d6e02557a765ea454a441a35c247d16ebc6176e143b51e9db6209953bb0cf5ea2c6addee82d3fbf7d41d0d2261026363ba2778ca8cc9bd91b248830bf674c6305c4e76aa824efdf082fc75e6acb246ce4c4ff240860f014b15b74f46b7600fb96644f5d459df8660aeca6ccb2e83c2b16d20e69379ffa8ec1a31a5b3fadeb3472103a488b55e26581f6412301614104509fc87c1f307f3bccedebfc7035916dc7c5d970ad7fa459b5784f5a99b00729104ee436f393d7500e6c9a6abd74753b6578b4100b951867a71c33c007e3ac5d55e0b8ea58e16a996c01b5c35b716128ca7dd8c59c38913b90a15e2d512693edcdc798691182698fb1e01be1efeda6e1761678c7286b5df655b645f39630def1119af5376d470781b8415db3de80dcc59b9d3011f711b10b3e5097b776948afebeef95e664377ec40945f2e4dc96c7b173fdb2778db5d9ace086d407a8fefde290c487a1e6e105ccba64e7f33a798913f71311f2218e86214ecd10ad9fea77b243512471208d61c669d2bde3e0ccca8d294f9593702d956ccab59b89218c21826d85c719054e4b0d5c51cbe88118f76274c77004489436e0a534045b91bb0a2f31e8dd20195e305fdf9870c39b221719406c10e237894d7ce3bdf922fc22cfa061e0ebf97fb0fd6441f71a08b7f08fae626172269eceee3831543893bb15d6b2f7b86f8593b5785b36959f33b6b67f121e41c797694b8f550130f71d982ef38f787c66fc3b094c42cac1fb2350cf0ea22dfccd0c1dd1b294fd3b49d1619cf9916082289e47661f92bca7a03b3cd0716b39955321d878d7c20229de1a82130600ee3219d028e2e09d02d8fd5f3aaaae59fba98a20f6dd8d3f856ec085651ec47f2555d19722e0792e13897592d0f95329379ab0b578d13f12d4f61cdd657058019b145d32698e015ec907804c51cd8025a9c86e660fb9297d96df33f14cbaf9037304bd1c160e3d6f2af1fdef57c3c7283b029c43f82467c2d453b77cc537c65631f2d5722842a3cefc7d03acc2ee1d7a7f0482b2631427396c8c9ea037be7ff0d66d7b7dba0ffd543a73c66928596b16ea56f738cba5e93786201496b4839c5e7e3ebc63a85bc6edb8a4fdfc0b650e47c7afc4ffc864a19904f06567e7269324ac117a186b3b401dee7ab5431c618d9f4bd2a7c5ddabb35acc07fa9e462a95d4cf883f87a144a41be40458ed6b1cf880e10df30b680f974034bfe93be4f90b5d5f8f01694b63533c7c7f26907a4444a36842fb07f0940e5592e262041000eed5bdd4ffb65a133e025da09163a4ed096fb134a51336f6fd89ed46ca1080cd36da7144a31e3e1510ee782085010e5f1fcf8327259b56dd153a628de14b6ee2390924b2b69c1856b0a3a37e527d965f02a281bef01b96d871a6ebb0764d0080f2b5618489443b3dc545f62039d7e1cacc4e992dea53b9bb7035362ebe4e4469d53f2f8924607572519be5191fbf34d50fdd7fcc6e2c302fc3f3908ba7033f1ec700046326beae3c8275caa146272b0bf6570f152082104ca0e1193facdd9567777391fe6cfd476f49cafcfee470cff7e6a9c36061a3aea0aa4c78b4557fb60301f1cc73f97b7c479a1277cba60bbcc222b9ae1d2de72604861c3997078fc6deb2b5601f41bb06a193fbf481e716e2fab9441ea7e8fc38f3dc2b6391b629d4e8f71ddc3a3080c348129afb82fa825390fbc416443fc98efb41580d8329c2db4fc62ec07a384649fad6b4e709fada96516757eb0e005d26645651c15f4ef75493f42c42a42ff37e8e95e08911a65f81eec9c22a26a6496f551a732917e8163979434022f45fcdd02502f8ec385113aac0da0fc4ff96cc353af55380d75432c3156d75c9776ce443375fbaaa80c3d801d787d0fbf903ab88fb5a6c826419168da2325cfc8c6d3ee40d2f087c66d73c066fa05e7cc430c01b8a588b044a58d62105ca279170d1fda6d692a94b200067ef39299b1dcfe3c5dd9044e9ddf582edb2c4dacf330bfc105117e6e2ab3171c366606a1a7bdaab4eaa3df6424558153fd892125ca92229c2c21ba644e7938dc682636f2ce7d0a41052fac11fe99c8f3ece7f0a640cbf444a200e03f3688329e013f166026f5beace06a414d4620bdada8e3aae69daad56b2ce9ed2b1d58cfb3b0f301453c448c5d1939bd6e9c0b76d74d21c213df5765b10e1816815a39de7f8f667e675b076c06b763f0b92bf051949cbce7bc32ccf6b2182346629a222ce8111916ed56acbfa56e234f34bedc005d48104f7abdc86b9ba2658429bb1b17150e95224f4f5f407419589c844db49d50215fb8160b7a954100d076be70315e199784b1d732c08e765a47483d9c98b47f246a0cc76252e95c4e6eb1b9e58cad9d39c05dcbfa7dfc333258cb09e02ab63b6da1311047150b5538a4c2beb45e297d3e2db1ff065cd77ccdf863115d68add6ff95f81f621a99f983bf4ec44eb56f7f7bbd02e902842e087e2222642bd979dd928403afa01bef0e5fd6abc21489bf5a81d4b4a07c300bf695cf5f5ae9f6ac9e4104918bca828a65b32b4d8e4ca1f4e8b5bb3a4d0faddc940a1797a2e495de2a07ce212a02e1197766dbfd1459f0af1cdefe0a6e4be3cc6e8449eeddeb9da9074db32c13697dbb7d02e71fc36469d97b7f8715e341bc03a523d44026576958d933edeb75cdc49cd0347ac2f3df05c398cd4857fd6a27bf67200e1aa86b42cb4ab483367a8c3361ea9b644a617cddc9991d1e5f6c67f69a6a69d1bc16ed38f4f3111c53cdfd5c05e5e0f50bccdf3f56309cc3349530d288d378c4252a448a2070ad605d70fab6f0f061dc93b83c57c17dccaf835e20637692c8b1a754ee507ea9595c5494127eeefc60e36e3d46148e00beb57864f6e69b687490918940edff95272a1c5d7dbde05b24cbb1e5465702df1afbb2edec0f83d9695e53991c9c62262764d7d86e1845ebd1e8b80afaccd8d22af9159a4e8d64af3f62a45a978decf9e903c17a2346b3de93b2300876efc197195fb47a57cdb6bf555ad052ff2301e4f90ae61f8ccb391b4e4582a6d2b4744a5f72d605ac180ec71f6e84a003d9a5fe4c90610c2b7e95b458af61b6da4095a543aa75ad75c2f8cbc15be78c037b4212201454f4492b256d6e4bbeed8a787f50f2d9c1e2d52a93015b612e0d0c0a52de3cc34744dca1ad38dd970f943ea970e9e847737cb627a976deaf5d2484a8aaad2d1d57b6d0163f1710e00c640b5a72ae662679672b30f63d0d752e90ef99cf43a74822c44d3cc3ef498cd43f270a4b4c47b94264ef3e3ce75765891e5586ecd57cb44f75b6f36ceb44ec8712f9b888d1ff2965f908a852bba297bc5ef5e2d4bf76c67110b765449fa520c8584d0e0ab31cd349ef6e12a268980246a1481a60b2130c8e210a028f80e3608e3e81d130bfccb36c630f0fb705fabaa0ef12d1e28d15032ea7d6cfaa17587c67ca49de4fa3dde77d4ececbf02ed648b0e87f435add1277ba0c0994a33bb6233a92f5d6e757768dd1febbceacd9413e595056aea57bdeadce1cc36f8748be20d110c9c221295aa5f59fb57adbb0625afaaae206444ae091964aad83e5d1ac823d576dc833b6ecf8804dcb0f80b74949b5b0f3dce71213141959d8ac1e99b4dfbd9962fe1e28a75a72409a8a939774a23b7a3a83b55b959316b647e917e5f60f44679ac978aa5e7dabcbf1a95b8a2b922785b98148bc9e6d8c26bb04a14dfa93fd3c88c63fbc76419f36be372e238e41164a9e984b54ea45aaa7922f41e2d3171e94ee40365263ba053d37c917445e2667de88b8c6634ffa35d030c0fa828179d70dd93a65331646876f6dff7b40596da4e5bf14c99a71553ce39c1bb89e1bed538aa89f429404c7dbf86ab580d6c5b2200a7eb5ea8bdd0f2cddaa0799a454f89a8b279e51b7845dbbca25c1d6922e04e09b0fcb8da97e8e1d6954e01847585bc500a986a170dea3f07666a02a3352d133729ac7f64b9cca84229f7328c42c5e8b328d70889f2db0979109fad0b778032ffb4322de9c425e4265d692b3e619a4e7b63a29f3d2338ae36ffddebef46cc798832f73b02c58b88f495769f6c605e9889d88bd7fd2ac634d1369153060ab9b643c8ea7c99d661dfd2f050255a0e549f9fb69f25916e1a1e8dbfba2c199999009c87c687b1e3f3ca83f982674b83c270ca2ea60df270dc2ce01da684e9bbbaa75b064f0ca81a664afe07e2f8c4ccbff0b3ac44ec3c0a1b343e66c87808fdb9a802016fa2f0a15322b4dd1d64b5e448ec43c8299a80fb044b8fc7e80c77e77592690499ff2cc6cb721c6957c64ad378f3d5e472bfea41288ecce82ca2ed392886765ff2a663b68cdfe5ccf90c5eacd07774ab99994ce6929cc2a8772b076599676d8cc0b2532393a5615fabcbbba20d87450799996255f453f0ce3cc9098759178c9a4d26975eac3f0c4655c532011c6f846b030d73810807051a455edab33610a86f69d9e5879b9dbbb55b7982f032e1e974056cef34d52814c79465a9fe5030aa10e79e438cd80d29eebdeab1b9251ba6d3cb6e686760ad5c836ac46fd1ed399800c1fe9a9f6cf50797b431d3dbbeb577835603f063127e8deb7b6aea848f4c41ce94caf48aead98d77a2339775743ef841028dca0aedeaa31d2de74e11d187bac1c4765c233c5fc6d685d776dc94a321e61e7d67d50b8ad55b68586587cc48fc703eb809c52e888536efbef862456a386ba0f9e2e326654f407ea47cc6e1601316afecb59c776edf2caf34d7cff2e46930c5991c39b2e16117723c43e9e3e71798fffa81df1a5bface0ada619abe49cfc530d89479871eefcb96cc8bb48eb71bb0fec01e7b6f5880333af4250a8145f95fc8870924a97eadfa355a1aa05ee941cd975ce343b0acd3d8672b9aa38fa1c5e26e2a490a26df458131e6432bd0192d89c77767ce3fc4c8fcfb05b944fa3a8800df9c9b15420ec2f6cc3295b9fa211f8d7784bd9b89decc750658dc36244297f0abcad66c160a8220fe0a8ec72fa831f0b2bf840b3d3e29c966657175d6c32a03445faeaa0a9e9cccce63ba2fe74c2988cfce53b2726ee448034caf119b4b2b06adf4dff542991322378af9239408c4d237d0394ce26bcd726fffb38e436664716b7eced35cff220b4843ce1efeacdea8fc52a99954a5028aa5bbccac1de4779b744e4ad69ae367631c20c7a9dd41df0e66e08083c213e552ed1444b441853ce2eca8018de8aa064ce2b96365838dc26b9915da25b45b376b1dd2d56167f28608d911eab5e9ef32f483137f5a464dbd9133dd3d37f07e57d6b92f61da0b65a317598edc3de8a66897d0255bad3356410c5c6200298db16f762bcee69d9496ca6469570f8eeed01cfe5d1714574a2733145734a41e45a7363b1f3bf2f272967c6ff4de0b7842cefdf7a0d10b4df3d219b5878af33a6b52ce7966350868c0d05227441c5665ff4edc72e64ee0dbf4730f509b030ec3c9d6843c0ad15758c0f8a49f65b31b1fcfe59b76e427de4d6f99cf9bcf88d36975af9b06a0bf822325c3383d60eb638ed19166a07d544b7782334e9bfa1c6657b510145040464d060251c633f83d897b84552149c16c849c967acc892dac8cfcf439024bf7a980ac630fa841b6012d285bd8016367652513e4f474a269e926c024394a7307b00c953c8cc23a227019fa7a4323073d59df224d2a2160d2e23f47bcb028797ecf0009030d73d2c618acd6439be156a2b16ff4b30a12e8a5282e9c88e01b98d52aa9ea034af096577a7430469e888f770eb562fea606d8e563fc0e7f057581bbcbffa09f849ba2b4fc10ba8fc213daa12fa0f312b098a31fa0b995846a22bd08201dc6e29feb1035dcf22db94e0ee196dadbfb9b65e2eda1107cb388f44983e2447605047f21411aefab5f188008297220ac10b745b9af58bc8a81a1ff64d95902fb3fd58f7dbee6df4c3e4e94cdc83f6c1bef91a3bb36a08dd66846985f33d27b4b56f8ff202f3ca56cdd5c41be9dae0ae2b429e73684f345f4ee8d6eafe2bb36cd2592a8d586e88918915e4e9992b4feac60ec917cffc37b3fc91f0773ea13b81082709b60e3f1348b763b57fb9ffef1fd58c01bdfb07ab39a2f41713804d3e1b3d5a06bcd87124b83da7498c54dd2899c43c9183bbce0603a9cb6af9ec387dd51addb8e17677fdfd414eed67a40f8937b75bcbadf3f7294899f7ad26699c038f5842710c2c31958023eb93892de99fd42310664100daa67c0de879ca4c277cfa8dbda298e59aa56c6926bad845091ac4e17c9830a291991559b5eb64905eeb8e53567a70a81e8af6633ad32381e7812086e755b05fafd4e3fa9be6ee7a928514f4ba0599b880f078c32c7ceb218c8680aa2df6e1873bf250606d8a642a4aaad00ec690724e1f7d80e25c8b2d763ccfeba4e796ec2675e533c3e3da4b283db87beac1f19463185e25bcca68d24e51a82c05c694fea2f24856831088bebc04ab81c6a5a4edf5538b36b98c4adcbac81b4bfa24f89c0a56f2a75bf5a7bea2bd68c9a207d4667dca4c7d51096ae45334eedb7dd96d88d901edb2ce496db3d84198cb3ecfeddf7ab17b9cef91bebd5f080537ff59fafacf417483f6f29a1960dcb5e1291550f26be2993fd974be5a2e21aa1818a9d3c48b9a1f4d858c1e22ae829ea2f71e739bc5e4b68662c1fe2f7c6e49aa31a30f529e92e8fdd8512a2e3fee26be8db0fbb147a8b04ff3fa95a09f33efa0c7f0958a8d60ce08495350e098822217c047aa112528232436706dc601f7b202137c6e480dab048887441f7fda7ce5c7c3b16a5e55a40b9d26610a1672f6ee2a0916cb954fd80fc5b2982072be6ec61bde4b575e8872a8100d8f302db7df06c971d7f205bb6c7871bd00d92002c241c24d63a317eac428f75bf8056d9889b4a4632d0c0e9a36276220b563a4bcb3a3382ec0ef9b6464dd139f01f86ff46ced510dda42e2f2af6fe01f2d96e00e71a54a9493f5c0d085c685e284d94ca0657ebaec642562b9c0d5c35b680f0f84c0e5ae4680529ecae064d7d3f5b7922d7a5be58d83df2790633f59b4461559f0ae3ad7e729aa1b2acf2a3474a054c4dffac5d1ded846bcb6e22a45ec53239450e39325072e535f8c2a5fa03d25bf13761b965589863fe71dbb00c5eeb64b38f398d8686d6329309c781892604b226db86afbf206a1a51925066fa347f66ce8ed78a5b0390c66805c7a6876f404a59a94924c67a46a7a875ac62708ab4211e683488b2afb89a9559493e3c560ca20762074f5384596b99db0a9589b3fbe1e7ae96e277f5e538f9fef544a52539c9ccc33c63a0506e888ddc1c74ee73bfd2de265dc444661f2c183e7ca769d3191e815092e88877bdc3092895cc756bcec525542b67354f7f9078573b0df5c3d67b6f99b4b86f2fa4832652a530c8db78216decb15fa749addc13ef2e50a222f7371ac215fbfa70cd704fc752d70a307d09f11066455d727868ff677ea9351cf5321840532a4379d81d791930c0de61aba3ce8f7995333b3d3361af2c7b2a677b7af24d52b3b04fbde23e41b133e24c99d558f438b557b437bfd116519a9ad3944a06096396e02184d7566314d351cef49d1e810c5ac7e3d6ab591300796d5475c58b4f8664b366d9e0f92a23df9c643ecbc634f7b29f25e0b68e7a06f8d2fd597d53c0633b8f615e92d222c962d07bbca223e45f74f1e058e6956651c96b4b3b04a82569503ce1472e34310d03c9ddd44b459c7748d3e18468dc67967b50ed261408c822ec38d16385ac374284d0eb3dd59e97bb7c5a886e95d64c96eebf3cbc0e942560679a144977b94de7bdfa7a432751867b3e5a3b6fe9875136fe87643deb48a22020a358ca0d6e2e9932e1fc9c50c663c953a95c7d6b7ec441b50d2d9c63481e717a40482498acc75e2254f1aae74489947d9ce9707031f3ea65afd6b8ee132e5cf4c13ea99ce5466750a31ad87cefc812d86392dc1d0f85e7cc85fadb58a7be4c10c2510d551282b714b2db6af11fecfd54cb426347aa1959ae2346a9f255d82a480717d30230a76a21c3aa72c6ef52615703c578ee318aaf4bbe1b52d8c33dc9427147a9137cbd8e27b2e0d4965f54dcc4d6d656f074bc1c60077bfe80af966533e8a3eb06908e0e648959ac648d964b6d25c82c78c92b01079bbdf8662df4590046c5f92b438206b6d302f209c84707d1d245fb26c71487d5fe96b04c3afe54083c027358ae70fce15846aca502a719fe958006942fa62939ec5f7890ce3f3adb6085dbbc48cf24311b6df08ee43072763ec2e76474770fc22d3a261cc0f52069283f71982cb37961f52826db497643afb7e94b915e443ed4c725541d7b0078c7a03c8e11e130a39d35014bfec0c0ab73109fe26f1e1e90366b6da71d446be94b0ab2a56fc9565b68031930c9ec3d523a4430d99eea22f841734679140047488f89defaae75519f3c6c29644937a86b269b9ab7bb45667c93a2d20b86698bf9f816018236288087bb3eb361f57489d63f7eb3999bf1c1d9c18f0df8b116643874cb72099c289499d44bc031ccd91f6ef0b410571e7e92cb09b961926aabfde7de94e970aed9eb34b78247f61fa92c375326db96469872c780c54712042369903611cf8edfd70e86642ade25e1b3e0ae595faf11d3ec8a17d6f61df8a21690c05185167752f2d533f5abe91fbf72aba40fcac27061cdf360bf39c6f7f30ac3539ed18a69a891ed081b0b856aaf90a17f320e92fe249265f9238998112268efdb5506a6c80c8f1b4918346d7a1f3edefda1748203084f2766aea595ba550ca07a7074762cf46a3789160d0ff622905187fe4d48e93fab94da63d2431da751d5d15c4377af36a2d1552d26e04924dadddc0548a66651937ae58bd1db7df5f3135205525a2413113fe958958639185b06e214112d41adeb50e5846d665a0cb63b95f151beed1c64da18a7027b310149c9d9a99f4797b1b506385c864ea4ab38694474ab9f633fbb00577806b00b9e7365bcb207aa50ff743346df36b0d95bb542ae9ca769a073c64934f9b504dbfd7011737c5ae1aff4d2b51c6c001ad0f1cc6fdd585ab434f9d4dc3242a4f35bad5a9f0117b469152ad58b106bbd0f48a54594c308124bf7ba7ea963a76a34f05784a6841190e83cdb9cecd4341b74dfdbee309307da95d9ed5d465ea09e90342ff8092c5da981198dc684d2fcdd699b909273364788ba10b98b818a6c250d91704560a308f3aec711ee580df0db26a8bf0af0dfec3ca8eb494efe279c84d9d9cd8bd8022fbc7370d3b92cb2fbd2bc58a085e20e4d5a285fd9534201962edac9d64afb1c31be3cb1114f63466e6442a9dcdc5a82016bef8a5597dffc0a14a2aeaccf648fec8041dd471751f7bca322b7e9038c87b7fb54e9091fe4f3b25e0fc382e4685e933203807b0f4c1cc46ba3926e7b7b4cabbbc3f375bfc40babbe6641410416da41b786ef2eed375c3679a0f6c97028d1893cd2e3dfe484aa0bf9ff8bb80529cf09ba33063d781b101b7ef9154c14ce2051c294847a60cf42dd44187e3079fd4986fc359f1163809bbeb5f466d560809589bf7a0442475eb7f8fcf428e011d3de1e23ffa70148ddf1941dc09da87ffecfe56553f4d97ea0a076c0b4327ea7e2dd57984381c1b75f23af09dd63dee47d8c57cb644925cb636a58777454d3acd1fa69ba32e002f6cdbf8b2c88cb5a32796830f1dc1c10590d8a66ee8791ae62e89cebd5e0dfb5ad6a4b793efab92445f84acc7b2152c6b0f380f46b15b5c1e9974ef4a83d805560b95ece5270eb8fbeb825ce5e123ea729a62878d215491219e2b1825d44daf3b7c9fa02f84b7bdeb4c53d0cc34c9efa914168388d4d94bfa8ffe2940c99ceeeb7d95226a3e2ffe673ad6e9e5d27892ee10f003d5d667ef9ea4617255b18f45df15ef75e6b078d55e68a8f89b91300b44cce07452c57833ddc89cd51bd53dde33e2a64f502860d357f5b9cf85ecdbc5183e02a9be869825d08235c739c570ee0302d85a946470274ab515eb7ad31e08df071b59d9967e1c51d3a3c6ba96b5980edcb7321b07f0678865dbcff5bd37a51f654709d4f29482c5aa357b61c619095849bf6c5bcdc245020ef225995d608d43334632dc31684f1e123ce6e3bfee70271cd460e443b2dfd24df6a8152277b7031b6d2ca45fde0955a836d1bec362bd86245cd28372eec068ac717ce99790ef366b9b1393f5260b3846a9b983ac14d97e1606dd9ce1e5e8ba18457dff28b595ff2ee04a3cce57109114033545b278dfc41931f25a57b28746dde633f273f9b519dfa1cd2d8c675eecb9528aa670a7ce343d32a6d935fd012b675f384ae98c82aa1b2ce7a539abdb5c60bbd7785dee1142af65b825d9c75f732f651c46305782d068039727f8085e8f062623aa9962a15c214835f81d8f7c04c5f7ec14bedf4c5ec1e94f96af935f92d1419b45a604e919ef787af05e278a5e3a2e3dac0e783a2b19931a36c6d5056183bb6380c45a4c79324dfbc68e6180a0469c31f115db173b70d8a9b975c4778e6e34de14fbde05a0a166001c50835a82f1a11078ca453f5c398f643a18741b8fcc967bb7e620b41dce8e313b6551ce48dd7e1325069d8cd27388c8ade793654d6c8ffad5ab01a4f810f350a6b84c3cfba51c0aef0d218492a47267989eac792af74a9f2dcc109185a31821e178d35c74ac2155e492f122d9893247db9750eba4bc3c016f023db0d0779277b23f8e0ce7bc8af17c4fa27639ab722fc017be412cad1dff662eb5f68a5a97c5903d9fb8c2147e4b730d850a79a62e94a94ab4bdc34c7cdfce2f2bde89bda9ca0d6f0c9c994a9d8209854e698795d7f7d2b8e0206b6abd792f80ddac48616071e2079046a7f33b8aa1867604b87c25561b6bb9908f8c433a53d4464b5a5f15abf5358e6d96b7c4eba6ba8faa40f3ad178008d7c5c36b5981daa104f964c45a46f4db304a747833e0ef844b629e23aba587d8d80975f86aa79740de54721e55bec3fee8b37f130e5e1796466e0f5645b80f064b5960b54d557a74d48deb1835001a70b4ef958ec51a4a56bfd5ceaf0624c954ff78df80182ce02301edf1a0b2e54fbf12ea8b19f2c4b2ab9b4393607888a03d9e4bf2b71d85d05546a3c3a3eb774927f9cf92fba70420e13db4753d779135eb81624e2fd82ca45e90961e4c0fabc07422e56acb563bfb81a89dc72b0e696e546baedb5aed3c1b7723726f682d3e4e5d9a6e517259b613930bf67211e33f8d04a00512ba50b0a81f45ab1441e92f7d74e821ed04f095b072995473bed4fb01094523693b9e1b68cb72f6d14616bfce14d3723ac7212b3e3746738f86452934e4dc45ebcaabbf9c9d26fa5120d7045276bca5566280073210bcbe0e788ed12c49cfb4b83abd4f637cb8efd3283f6ea800729bf7d61e838a68ffe0ebe49537ecad4bfc67de0e5c25e294931f865ea19ef9244b752dd887b9b55086b31713ee1713db79c863868e3978d6cc2257997318c73daff4e67b825df43115921e038bf9683306b2c410610d92f07b1b524fca497d9116791a8b450cd35b4e08c6c8e8d521848b928b2eed6be5f5776c5354cf1747d43ed8398e6fed769c69fdfb2c48d8fb3e513baae1e7c385f004a566369d29d8931d15957902581565e3cb59d3574d838c67bc7f71c8bd685d8e4e6ac90101cfe121bd02fe1562992f24eacba29af279ba032db7da6c84c307334a3b7230acfdbe3b2eaa9600a78fc7f727d6d51af53e9fd3c9c378f47005a881cca00dc22c680ea85441385abada44c731dcd8626fe1225f017eaf9c9aba8c05bd193beb0ee4b90917ffbad77dd7d1adbf592ca8051d9d6b281809131ff4cd41e033dd5ba0a459edbc7cd81e3ddc3dc521151013ce5b6fe240ba5418d659fab350886abfc98337101072f68a25e4ca623ea75907386f8906d21dbc9c5d074ddddb07f332288405155f4b3c311820a9c8d54261eb878e8c7ce08da96ffdda68c44a5f8dafc3da77e04c0a70448c14c1ecfd1c6cafac4487c8b85d32ace9a43b1dbbfdce698a2c145df0715a97415564cb2bd27f47b43bf2f6eae1c6fa5c3fbaf14076ab628f6c075e8ebb3054c548a910c2d0eecc619f5cda1d8f5617d26867f3834013bd64044600fd3c4d8afa40e818be8f25833bbf51c8acee33853e4d661e90c87406f80c25cacb26a4a487a30aa033fc5dbbc25ee9be969afe94c2fd66dc7f81e70d2d86f8009c70ac8f9673d0c6f445242883f9e991b36794d847b43014f16837ef76f65360d2b84afe3983e6f8b0ad4ee30519df0c0662a626bab9b674f3bf11424632c2decb99341ee6053e867347c90302b73f6487420cdf9d89534e7b798200900535dbbb8ac0bec14d71a30af5e33f46846a86b59bbcb859a3cb9162a8262228b7a6208bfd861017e69fb1889383432105991f9752b07d7bd61e8cf83409b776384b9bb9181706432cf4dfe36480b97d86133bbfb8aff82456ea77ad6a9953194fd2b96a59f06077d70a6702a5942f8547e97415b5024abd440bc4bc0f08a84be585b7955495aa5a0feb4699f76f2c1c82a7a82336db543c9b84d071c7846e9e2c80cc5475e93acabbc84079e147799029ab67862f72e66a1a5847ebcdb05088a3a6cb2a504310aca838d2da04cfcb5f82904aab93af98703b8d88fb37434da143f4f58adea20182293f88ccbaa8e0792fb3fe8ec2b40f70d3bbc22d6fa802f2446bc751519dd38c8e4ada781483bdf714dd35f489fd56af68d42ed3cd2964ea761c83ed4f6bcc336c0eb95a62dd6305214ff28bdece645558c2a0ef7ed2d141eedb8f7dd927bc7e302bca9ea70d082a3a4ba90abb7614192fab6ea754eb3bee3d3174e83a3a32850a8f3814a3e11f3f23ab55de5d8c077dfbf0ef8abe47b300c91c3f9cfed5a9019de3ea3b54bb6ca26d6bd0034cb42df358d74b4cc3173d38e3959a00bf5e8f69e55423e5d4b32fa43ccf970bc81b6cec930f9376077519cbcd2d51161eff932740bc2cfdc979d37a400dd04ce3d444fcc9d6061e0ba3bff747ec4ff923094281e44a0b977d43e7a508ff6eb5d6a77a892b42df3f97b04bc0ace7cc27fe49763db2599930311980d5436ff9b6e75e2bd507a6354b2e9e22da46966c853528165799b9c28321b8aa6a813166e4ba9c8c04a4859658c7bf3cb9699c429146faacfbaaf8bccaa9a92c18878b5d4ba52f8f901f87e871d202e30b445d41b01284116a1f750c607d7011ede24dc348a12c0b528913d695cb148d039bfc7b5d7e0cd80b62607c9db59813ec91b0d7b098c61471898c9683a1ffa1636bc11ddde35fdcad3722a8693f306addf55520a6ec5b776dc155fd385104eaa3c3d686bdf764c31697d2bb963b8ec29af99b38246871e95f1498352ca556452a9e75fe8408fef7aa3928f430349b394e1d7d5042faa8099f5a2a8956fde571906177e4433f8b615eeb568052c8be27d4475df3d0791d0b58eabd7ccdd64882e2fbd59565d23050ad7a7a4daa5d5c182c0cc59deb7136d81ff3908feda2071536c7f9de29cb5a7a3723684a703b02ee5d7ef5c012ffc20ade52615b68d126306dc2d1575e60c61506d14a5932c5046a3b1fad43cf41b014b17a52c8ecc1168b7f1c95082df09f9a4f7e8c095e1a2058ffaedec20102bb4d6b77a815ee48385c9e21f1be4bbdaf6938edec789307de76c8e4f919c008ec3e98de2dcad0f1c5fcce549c39be08634a63959b8e51ea6aee0ee7149cf48a25b3ec50ae171e3598bf1addbda3534f7f766657924983e34aed0f20059b8c00fd2a7f0a448cbae6fe606dbc42f7ce4fa1411759a5386e183929d5f87ec1e7422c4626478f801ed865892a35ee04915fddbd40fb68ad2337ad1dcebb3c82e44fbd0d60bbf648aa2c9694a57223125af8322ab41718af6142569d2a0334c96dce94491a3ffbbe25b0f55156a68d981a9eff9151292be5a76d169e1c44e82fc30bf22e726e379509b906728a0e3398146ea960d467b4db703c912b3b7d4474b7806f921fb0634e63dc1820a86ad5a5eeb14cb3b3dea6f2d2b664b6e03973cd57ffc70678c31ef87a2358f5e80258ec812e284323fca0be35bf08ba07e9cfc035932d6614a715bcba075d0dc1c4d1f3c70ee12d659aa2f5c0b28a61d0fdeb342b0a705be7fef3b1ab74b4bf333b041505ebacb113afaf995fb35dfd777a8205079af47d25db5586449d2aa338fb52f79d5622c0b01e258280e76dc404090d3cbcbb9dfd775d538d3c9a9f467fbf1a005a4246657cf9703893d57a76662ecab3b2da027a4082e15af378ad2d16d1c49c0c267e275cc5ad9f016c0fe28b441fa2b16aa6ce44e730383276f5c80d73f2f7453e0a126f0daf5b1e1e8aae003de1d159c731608b77033b4e44061f4fccda6dd2438fc8c3cd594c73bdaad429b1cfc7f65081a72e1bab20b7daf74e9975a84849468d069c25b28f6603eb63734c3b6f62d2f66cde5f80b88aaf0ad96f7d688fe71115731a4486df1aef4c9f18f62ebb2901495205c8e6d79801b0e998529531228958a97167d9991e71322dab50abb8b10a16eab18eae048eb15930e4a6747e6dd8efedd8aafaaab5836f86c5ff91d714e8a945935cab1f41cdb0ac08ba41329aa4cdd3551c2c1cd45583bca93291abd08587465599ba1b112bc2676f68b2364ab983709bb21ac867c45d7c16d318972ef7eef5efae8495130189e7ae34977373b127ba89ef5dbb4d25b8c59675cbd4b35c1414fa1baeef95f588f69dc8f0cd9d6e70ad87ed376ec1155f7a8c5532790d2ac492aaa432fa6ec617e9b65888ee8b07e9577f563173ceedf9a62640ca390b42c494ccbe14fe686cf8eb7d10accc9ffc5b13db69139c81121e1f22a7945f90c6c228f5d416e926e7f83b0e74ad35794fa97f8f9642d0517cdc094966728b63a686e4ac95b99fea0611c99043c6686a9999dacb5ca91b8c3f2c698ba588dd19752b2f701e56af7539a12678f49f033bc171f1d75fcbddb76c27cd93c4403787ef548d668d3658705ff08fc09b638334e05ea7713459d1cd98b57ff949c3a453f67c8a000c7df5fb4352a4635da2ba5b80d6cfe4ffbc4ec5ea07b39790397456c2e7fbcf9131dc0c746f4730dd10d91da71a0f6cbc13a9d32467bea9c1f9e618e1e2998e9f01fe7d6aa305b30af0dd998cac8707d37e88870aa3d5ed1b276c3686aefef7ce9e6c29ee96bcc2aabc54d91f3bd6f5e592de443d51a13c24e58d935120f40efadbfa56743498a1f145523e89d4b4954601ec7b58aca2f636621daa69fee87469773ec409ec2e831275b71775afc8e7f27bcb38ddd12fae47d87ebe59c07bd470a499049c1da199065ed208b64a7197762f0c8b426436b76b92f9a79d034043a486702df5a8996e28baabb7d047f524b4d3e2f761f5bdd5783ea6c4243523756e5abaa027aac7d26090f1af3c81c5481fe689008c77be20d6c9b98d60ff1188f9475c60951354fa3920218810a7e1709cae760423251dccdc09fe1833813465c618dde1d78cc7addd069cf44e4e663bcc6cf92225a6fbed6fb130f77bb846af2d927518c89f7bf0496b3bed8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
