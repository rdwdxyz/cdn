<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ea6995e37c55cffd4e349455b1d14209e5752cd06837f5e5ef6c6255d8354f998eb98fa25550167377bbd4903a111b13d94d84f92b82142c5a00cda68fe280027675436e050e18eb97e85b63c8b76ffe02f4e5dbce64c105d682c48a6e713698fd4335fa11e685f0e246f1362a11eb9f97a247151455344f89816b96eb771d37d62bb666581638fd6ed2071cc9ab20bf4ccc62e772c36e4bb9ec0c370b986e1e4bc1a50d4c41f49ca10f62da0a9ddb08e596a02b358d62ca294dddbfbaea5b5bca2b0e707cccdb6152fa42ee4db8b423962f524f17b9954243cd3a6c3829361bb8d3fd5fa5e17cc6f136b20647b46f8cdfe89ea171e0aebf966d88d69c4eee83f851616bab102d051d44a50fb828ff5571f0f6bfb3838e7b64155017e6980382e808fbbe9beac8af9fe583be81c3a14326563fb98a75ceb7ae41dc12e0c22d91d88ae511b60500ea0f19330659e25f291e921a0968a51372be2f714c7d901bbc0b6e15810855eaff4327e976adba0375d4da736eff0ac2309fe6af65332d4756ca71e72afb25649105305e3f35e8ed78d98a4b985557ad3bafc9cd23e364abba9f11e556878112c27f2167211d6be82d5b9fed19fe3db488be3e9b48d8c1d8de5ccc11fdc07468b9a6181c72ddc6bbbbe88bf693db5f4003c55654437c5e90ad1252256ff87e75b54ec37c4571ed5991d2ea080cf97c00627810129c6f075ebaa66af6690cbd913bae8fa0ead5686f0aa4e09c574968eb15682b91a4b64677e69c8ac3d9e850f39db2de9e0adb4dcfa336008b411b4857b1c2e0ecab0b0268f2ac58b9300084ef8f65a7793705adb7bd9cf76401e36c0a17e8f788e71012a58a576b50e2029365ec19cedc0ecba5f731310844c62885dbc53c115d9dc14ef8f5a5148cfba89e1ba8b1c98e356ee996b2e2f952407013b3b8c6e2b03544e9317541edd4e9a18fb65adc991c5de4f217c2c2755b4cb3e6777caae81d2298fd7312f1330163585d38ae2bba3bc030adb0f6300480eec6989820b18ac92027861f67706777c74888b632654783223edc3e045c8ac4f29596f732ad6c0b28ae545059ab854b498de9d58455c3f95e6ba575ce5874c88c5ead04426e334d247d78046435f610532a5f75d34fb2811c61b49a405e0182bbc5d183374114b30d295c279e0f2d6cba729afd95d0e2d21492529cd40f118a1ca0b0667420c84efed7514c3cf33e0043e764aae7589a674d05a941b1fc606ee8e6efb39ec886bd60f7971c5d089528f56f2d8abcfb9d2f8b995e05d85092b85c2eb12464b470d22d2936aad25c099de579fee2806de3847690cc35ab41e2fbb5f2f7c18261572e9a65b72070cec51411a9b1f546abf0264638440394427e03cd335bcac9cebf7c6bdceb6e92bd7151cece17f8f1af8ee27f3779fe2c609241519b11dda06b71622f0d09290e2cf6d0ce4b09a6eb1ef55f90d0dcb063608e1d027aa909a2a08a5643c190286441ef3db1a62dd342397113dc51815058281761f279cbebbf3e0426849fd006de4f83a728263103740219e25bbb5aa658121983b4f162c437dcf7ab381380d7b6e9320a6c9ac2a3f8a83b95f472160f5fb236a9ed8a8cb32742ca2fecf11c1c03febd74b350f320faa262c2ee2aa76c46ef30cfaed614c81d828d7484d8b26937487540fddf3d26eacfe77863f14a27ba9cd5a89072382f9bdf4f9fae72d6672416026cf84b86b0d3f95affa6a45a5924a1eea48e78ca9631338541c6d6babab9925ef4fa4ebc55c6a7b46964d888262e15365cbd98e6079d9eeb27855160f70842540537ea5a6a2324cb5a344720dc9bab5ac74f5dccdf311dffab81c6926a7c9b85aeefd74e70cd5dfb7a6ed9620c4cc8ac3506ae422b81b7ffe09b291edade97afcd2f7a6065b4d318978e365c92f0332f3ff37e02f0dad0fddb2a39ed71fe56871793e38edae3a614c234311965a2669e6d78bf26d1e7368494d04d3858a81eba5b7743ac559c66aae2c742ad3ed56a45d4946fb7130a37072b02d703ccbbce7f4cd74cdb01b97a7f8bb6610ad1a23ca54b27a781f026a5eec55082d7718f1ba7f947d5f7cb266798c65f2395c28ec35a110892ffaf3fb39c9b934b1fdc80c86f2e4d2dd37ba04b50c9d40e1aa1da2dc3a755a57b315758e18e75a229a98aa3ef725e2fe8f0a1176613828696d0669d6faf201a8288cc6d9639b7af96a75aa860a8443719bf19e61c87abc8bcc7940c962c9015c8e4714aa3cc8c12ec8151eab60d651d10451079817783e16a0a2bc55c044be98237b9ac4c9bb189eaaec22ddcfd916c2ec3dd704929cdf4c54aec34ffafdff39c1b1896e22fda59aa9580cd2d60f1cc051e5ec4c746836836143482c4c904ff1a684ccafc8fb345f3828e317d63be2908c7bc37e1a6fc019a1f081eb2152b657234cdc269a90328577200758104ac51c1ee92e29f4f2457a252a0daea6c82d0c6b16accb2b55066ffa3041a3571bdf1ac36d76b9b7a2761fb7634a46efd19550e0e89e09a96122ed1404af1643a19b0ad28b5c87447333b0f6fc14e1079ae1682b3797fb0473f02da60190f6d6a556c7e961f4e084b5c293ec14f6ee097925538711170c30367b24378340cf3535f2496ac655550baa8ffdb0d292960dae5599d6a98bd7f579d35fc4b29b2f0a6100beb7f7a433a1d590d68e4c830e6d2d1ae0ea90d0b8e7066da2100854393245102d9dba6ddde6455b466614ea2b371b8f141c291cc49602fa9f15d45b3d6d86f49bf1af53d4dbe6ff5d1638f09442a46d142152be611fc57e19a9632e32848afd89d93fafb4ee07315443ea3fc8137e2d39ce42707a31eb66422770422f5fad4f0c54104bd7db6699b2ba41fc5270ef251b25f4c5624f965b5d6a9f020f54b02064037e779432232675bb0d7f736cf5b8d87a17927aef1a6231ca361f62f0652272c57403cf46f20962763838e04d3f4d032080027c23c3fdf84c460da538cc991b9c3638e846e8f177fc49172d3a5e6eb887cb6a839c5660ad98ddf5fe81da3929a41acf599aa6250bbc27f2460bfef67062cfe5fc574008dfa5f5ed8f2add7533a77d0777a28e1bc673130543d91fce22c11ea996158036b66b110945e373342fb2b88a8a4b828031f60bf58742aa9a8d66f323b2746fdb485e803edaba2020bd6b94e60f067e82d86568d016e924aa6437b0acfa7d8e09343d4cbe75bfef9125b17d3197a1b4e750de7557f5f962a1f8878d63193c4e88f095aca7b777230124bf198a042b80ef2abecc97fcdaceec9d9b748434583f141b712360fe5c9e41d183602146f0ac0eb18c050fbb08da64d1d5113509a9edd9570337cc451e55f899e957f83c8781337cfa796a463b174787e20ad66a4d2e32a8bfc9ea8e2c737d0ee99ef160424ceafbe1a1693ac2978dd0236b52dd54fe1934876c92b5500bcbeca1c9335e3b49c2732849c8b432da3402223fdf16f8e84cbedb302aced9627efab4334bd055674c99b8713665bb61abdab6e9cbdac6e3fc7c691a2bfc3d0659119c3f7ec388ed43c561d36b5be661acf58911fa939bc1d951c24725c6759730f5f83cf54c62648d9dd777ae05395b5d0bbf6d38eb15bb6618e34863a83d9908e6b376a32b35701d2a580d23c5cff2ac9c3aeba69559cf4151e16e50dea5e2f29b17cf981f965a5b985b53c9179bd660f03c7522907d8a026c2cc5ac7eb1fe9b935aa1519d624abd237884c271040d9afe08d4576d111a428904c455cf87cccc405ffa44c15bb492c6ff68a33f722662c2ffe2abf5e62e17290f8fa4286fbc077f49af72cb98e7ab6e0922dfd9f88519233eaeb2e80a1c84047297f5b2c5146e3907a2a40f0f45e6a9e6885e7dec1c4badfabc10fee3711fc9722fa94cff704e236ee2763de8d265bbd96ca1fdc80ce9d87a00ea084fe5bee2335dc0bccae577d942dc3e6b2a77a93107e4a66b85530fd9db4515427e360186251d3fb931f4098ca5796e1c66b8e950a24ca2b8933ea89b8b7c4c44b970b93da360754b64819987c1f30005d62d8f217be5c166ffefc66e5ccf6b3f8cb78549f364073c52e3cbc4bd5349ea243fb1370cfe91cc508ed092872a6cecc0406b4f3134d3ba9fe44c648c7db3c32ae9675305d99c9195bfcc3780dce4ec73d989a665f21b7d4e6da4ed43746332fdd4277b36bca7de92518fd27fabc90d7f900a93b9fbca6b6780d81175aea8c73c16642de1017845fc16c476f89a3f609469c08799232d092500850b511b0dcec38a232cac1244e96e9642fe46c38b61d0ef787eae24433b9aed8e7294ebd019a4673cec434a77866085800747a8cbc1853e39ae1055d3bca22d42fd03db714cd963bc30b122a2f88ad3b4b7a7f691e9c829d0f25874b78b8ba11fb5ed92c935b4693021e256539b0bc031b5ce1ad79d369d02c44dc59dd90639a21ed79d48ee40f9a4803a6a1efe972dabe2aaf6a1dab6c7c9ab6fdb18aecb87bc533b7a45d09e64ebc2a60ebc3851e08bb6d3f3725425d3e5c8341e18147dcdb7149a77cd6004494766684e3ed924de7e42b6ff552c67ebfc1ef96ed9747c21b579a8e5f336b9fa2f05eef395073e51b60078b9c0e32c6fed1c46e36abb494ec9481e1fdd5c41bc27a25c381fa735c0f7aec33680b1deae369c5295b7c7a7b61138d93690d0ec472d7b4f2a3958d98d1fd8f92a8c435e58bc32024a3e0c7a9521241a2c6f74440c147ee19bdf46d150b3e6acabd54b9cef9d89c7869fa78e8046000d03a243b22ef9e47f13f0ef49c74d95fdc6bae2fac7d9dbc24aa41031e3817aba273eedd99358dd0cbbeec0fdf5079a0978c88b06727058d00513730757335eb5905b04864cf7d42bbc408cf67e54fdd83d48d888f9f6edfb3c95b1a8c80a76b7c58b0fab6eab3282f8c0029b6b3fbadf718fcb942e42d9285aa7e53d2803d021b5a2901c16bf686b76dfa5d6fbc109b125af74b490b0cfbc61fd7685b38c1050a855226a1075e183f5a41508ef6c628ecd2839f5e870245a55f201c03857550d04d0ac04e8bd201621e604195bfdcfa7ba2fb6c7a5ab1b367a62b11932bdbcf01f027e5e4d801830b03eed6081727b2db04ca1bd8c9d17c16d219e5e8b426c4d80a6c560484ecc1279e949cc02b4fd2cfc6695502b01069e8ba70d5a29a51fc3911bc9abd0d90ee164e6a72f2fa2df1c82cba65c4380909264a84000f0565ecd75de0082131376133d688153f3e34d4c102453fe69df54c05204d782c8eee6c76792486d9208accbbdc5b5037aabe19d116fbb5cff89a8a905c566c87fdf739a9931d20736e2fc8fa33234389146ae245f2eb17d9e67d518107d798e1cc4f11667407acd1915112022fbaba614daf1d9efd49981bc42be3624263b85fd0c65ac6336fc4704521c68b7f229b7e09dcd491d57caab8a9b463e65170429d05ff85351b06469e7dd5374506327d9e1ca700551b42a35d37537d67c5383805f3d8f14764f6dd10d0023e081cf04b7ccd79cda75b4e8fa5e038956ee53c75d7680887a07f0b471d8f1ae096bfc8a8cd68b8e44c0ffde2ed278695d61200c5e5b3443a5588343c4d9abf7e0014351aee568190242f28263c2e9c80a004b0b6bf343463829a9efd4a31f5eb3e4f6940809863e5bfd5e6e3e87d4e7e7280a48e9e0f1194cb7ca327e1bc3e453af6a2f0b1c6ef69ba2ea62a804bc55b69f3ee23c2441ab711c17800855feb23a246d20bf6aa5ebb290a9bc878a537d9ecb0018476a7630aaceb572c301a2a4c02624089eb2e84f45ba384e5901665b4d17e11e1ee1fe6e36d65e72ffb370ccef7d128a33225f628c7bfd1608cd968bf08190a7f4a0267769fbdc83dd8be1ed595b7ca9be1b23c62ed33d70ee85c1c5a4f5e5680ba14282465a99ff6502da5d74e3716a08501ed8b9feca6bfb836cfb44ca2648d1d6663004e30699b2d9be7a0f918ed28c74ea613e24206f4ee698fb02a797c67db1846dfdf399be2bced0edc770ed15ec445ef43b6c95f9580cf28bbd00f4fbb6a8302f29cd187c5db13c3e090e682e21af3537b546f79ac4e51bf3dbf2fe16a8589fb9d373ce1d4bfb08d7f89b95bc985bc088cbe701ca0a6c0bdc768f10372012053a23b0ba52e363d9874ad94f966af204a5bd8bb4dc62ddadff25ffcbc36e14359a8d9fa1dd7635d38ba5c809bb4a2f154ded421add52aa03da28b51850eb349e465633de7bb7630842cd65623f723902f1a3f52dc13828f2e73a84d8117ccd6c3ec23376719db94c5227b7acbad9a96ca4446af5058c1cbde345945c491908abf7ef30a835546e6bbdeddfd171d0983e006716f45ceebe124d8385087ec31f5d673fff2f415f14132bfe8f1306062f3cb54c271eb48d14fd8356ab1152ba3197a7b940195370aa579ed05b3193290c8a4ca03df0ac6f4db72d00758579d6d77c4851ea5e2994bcef385b42b162d4833930e54027bdcccee6f0de2398a9c54de99bd14a3741dd5d56e2d6a294fc1758679a5d61150ebf8941b8bf6c0eb33c26441c76339ebf7855271bdad3a0486395d6fe3644f70056013760e4f131857d62303472200e849cd639d3d2caffbd6c840e2e596833174326f11d15c2b53a56ae9f828e70e9cbbbb78186d0ecff2cee30b2de1dd62ee57992f9a4931f617d0d57fc36dea5cb77cf82d7e57574d350aaf8d9591118c5c30c1d7b2990795986cac6620b24e1d87026bd38a608fc3ac86128ed747fa22a076c86cc07dc696f84581bbddfd139e001e181d64a1d190c0427604d54234f386df9d76f4d0a6a3cc76f8a95a73139035c64455af82d621a4b5c9fee8d7f95438e75ba15de2ca3a22b70d50e6ab52655d6eef64e103245a09aaba0cc652b8820d17780faa0aa01ae580f1b1be4c84ab76ec5c33e3676323167212abfa17d58b9c46cbb1edf6d2c1bed0d0c0469efbe6b4346c4238ef9b382a3c9072264c11f289dcd25e1706b35c4ca6af3e49dcd7e9097c6852702348f9063cfd412426d86940216a98287837e2ad457d49c66ae3331d81d0b046cb325a0979443a107d34909318ed0257ea3bf2f8cbef8bf522fc96f09f8c9bb8dafa7edb75dcfd3d772928a2a919bcff1bb3ffb8a5e86e693cf0a8f05758c084380b794fcc99027e46ea0a79f2d25182d71dbef40b998d7e4a52e5422d3b2df73bf97b3eeb1f8ad8ad0a0293f612daa2f26db686dab95bb8d2eb9db0ac39ce4a0c3240270fd9c30e1ec6fcf8384177d9b1bc75fb25ff6b8cd0db659753937f9a6a11161339ec17c688ef882c5b45c2157278b3556282a10efefd5436ee18b3620519d3c620f720fa4b5469c7ecab41f655823ebb85920f1b787f4fab9ee07da2f142dd9bbe5da69d3b6f460793de6c14513998cad37a7f2430a386b7cb413b5583c9b421a44b6e97403f7be59bcb207bf6466506c3daca5e206f40c90653053645d1924cff3094f500a5424999bcc936ee48ee1e0d9526e20f8459b1d662b82ede589140b08eb0ca4cb38ba5baeaba89d02fa12ff00c252bd67ccc749c1340457b72f2da2497f4dc5b21b8a254c807a92c80310c6f5b61040bfcb78f7e48c27204b9da2ae05acf57a15b1b45411f47b681ade515da90ed7212122e373c479c9e9322b6d13fd1765baa3a4dfa270c586581ffd48550e318315baddde691a891e5e3362bb56a22dd5650de615a1c615f50559324ef1f2549ed43f2e4c52048c9e5b9208d5c2a17d858091135e1396df54ef793653b7ece279b84842a94c4da378a70dc7ee0640ed8abf5bd2579f9f430652123118ca2c7f29c0f2c2d15c44d36df32b6c2b74b1ddc5516f66f8a7a0ab292a4e02ff032d27b46c9c6fdda8747ce89bab873440105a9e515de878f692849007c702332c94843b3723fd8ca3a9b41c587fd32e6c53ef0b1236c6b01f48e51f98e7efbe2c5204cefd719f6164651183841cce5c73d84fb928d60f971d84afd7c4269f4b3edd133f70593d60394be508998a0466d0c431f9addee5b3475b5dbebedafcb74400046fb7d2e922cb12fba5573b54afff35d1493274831548ce9cdc085cfa4f685c5d54a1ffd946099a5a92e18654d16a48e0d01ff02c9478a3d4b0c3a744fbac911e80bd12719fa088e4730f20e0cde9963a9a254f29d381548a55d145e1eaaa53f7461ecb7a0b065a51b40ece2a3fd2f5948c33213e7bb36504b3306ab6e6081c837c843d0ca1d6e1c7b85e3629bd8fd76a315718e0345472bce778004bf96670830037c8ae1c4c4df6dea9398a9720d54dd0e52f72335c92024156a9080216d2d43d1e066ce7494e58f4af6f74c6310dc21941fe89cdee1e7316b295f7816e0ceac943c523d4f0c703050e2d1aad017baa619d26e1fb141dfd30637c2404cd127bdd089eb79d6587a70eb7018274689ed2cbb03f533b2d1ceeca21d6e47453ff56771fcc345cf825f8bd2b3826500f605ed3f1b3a629e48762522264473f33b5aad6cb24eaf90635da22f21b106cee7acaec3cc14b43cc4ddd7b1f0c068c6320c37b1c40b3564555346f5e76e6a76251d190850c4ca644fbf00ae9f7ef4d81209fd46582b15fe3ad274ac207bab4f511da5e9fcfed2504bfbefc4037140210b741be0ed92641c632f274f80da85ec16e7899aa98123190e8ea81aaa09c82827c66c4ef78d5e87b7b913b6691a1782b50e193fe7a23b8b7c593501823db372d738e0fcc94f095160c2b7613903c4e8b39bf26bf97f93546f23305357777cbc67ef41a09993843343d9391cb878cc3833765e9baad2c96194dd83caeb7274d8428d3375f3ef004d49383dd8492b37bc1a28e735418fc3162eaa7adbb7ce3081686f56f2d295c4f53d8d360b9fae1659ea52500415d1a93a2fab9740e2c5a81720b47f6c16f3716af9bad3f4f7f4318f723cc0f992d2634ad2a5c9e9e2661d7d68a53a40fd52ffcc88216e2b27b39ac7192495a67fd1cb3a3edb7e794fd837528d81b3bc1ed36a878c68ded46bcb13b9d91f034cb7226a7501b887e36d355d4eabacb1f18d72793103397368cb2e1c9815b89b5a23f837436efbd07a0eb119cd600bc85950eb939eebb9da707a02b6bf1d9b964ed293c93a9224c3430e4aee30953e453ec1258ce579cd01499eb58ee11a8821e5064434239301233f4ac466682e0857bd9f40cebb02540f4a921ad09d050f1575d995f3e905c57219d099dd92b309cdf70168f6e624b70e258da33992eee199d768292633d7e38c66fc03ebdd46e9a9de6fac8fde2ef88c1fa00d3316799ecfea4bd345adb80df0c8e5b56a176d85381d6218409f0feef66ad9cf674e62b4ec526855a17598d3ad5ad448bd41a15548c8d7028c296c60aa04ba0b8fc77fe9656639e375b80cf0b5324db7f4eabdc09cb98346bdc116b97f0a8691aeafc6f7265a7ce176fe616c407e9e80cdaaa5259d0b5e4b5bc14e93a6e04d24a9d7146750eaca95ce240e8c34e940abb0d2bef3ba9e61d258914af7b26bd5a5abe2ad47b86a637505e29d7dbde0e947a2886b529df78e6fb05f9346e4870a7faad99988c74cf7dd8fbc3c1554c149d0c9a5e06f3f0925b0143ff538720158d623927aef08752468ede95963dd52f24c5f56678545bf7124191acfb18d6016ff312625fed9e74ccca432ef8ef9c21fba6883f313915c6296aa54615fd74bc552f0444414eedfd93b7e1c78dffef401a00f00e8d7c9e31c92a1bd11fb5e27d8ad7beae022e8a9aff13dc72e66a222bbb2398c2ebf00a45ccebb46d3dc877c246ac78ffb6d1475a2b9a4e44326fe4c2f15dd104fadc5e32aeec283fde3e6639de65d65a87aae8839867ab7628266c5e29d4ad9eaf06de6b775bbdd8c87b81951d19c1bd86b3f42d09b19f55063d51e2640039e52f221f9b8832ee32910254f7ed87f40fe00d4ad8d4a4da2dfe6fcefc23533a2f7a3cbab1b2addb7d80e183850dc6b6bbba7323687c301221d02a3fe7a1ee96a06d266c36290b9e457aabb05bf759a68f6d4f11c1d9b4ea04a9523dc20350b8d7c86230e2fe2712e983f121b624bb1985e808d58ac971d0ed7f93254f7b0f0a84252aeef57d3099f179992af3769237d46f1859f3ad87794524dcb77b6841006adf210bbda8addb0d27366930c9e3772f177370c5ec7cc6b8e12ab21becef169c05506fae9c9a0b233e939c3f2f8db1516c35591fc9fb1059cd5677a8e518c0f7772dffec6b4ade58a648533553c2588d489d311026ab65599ca700307362e54c68950055da76e02e2844e2598cbfc2dfbebb901f0d5bc7eb06877f1a5e449610b4c74edd7fd5add83932f4165eacc243f84afc35107af0ea878eda647d08c653f12cfec3709e678fa360531ad04f39d1d10771c7ee653de5b44dfa9af5d14675f8cca9572aa16e78f9bcf867bf007d6dc13cc64f93fc7527be4c7af58b6db34cbec6aa1f94a101714040ec2d634ac7bbf8a4eef5572e87e810e819ef147475ad560a863d3c4d750076215be59c58befe0bdf8e43877864fe0d2aa2943e37871673cf003121b70d3fd48f4301f455c19c8d2d5a6234ce7e37fd396828be9291c1740245a9776cc1444ac955df499d29382a166df4f7340cd4ce8e0ef1b4e6e81025bf1af9481bb5a6e1dd0240ba788820d6ae08f09eecfe2e271f50a3c4bc63b179275403e77dac8a074dd4722502de8a31f4aa0e3370678af582e11da7126d7909c6c9fae35bd1183825ba4a896e4bfc4f55859c226a8122a7746e126773cf0c6426df7c52328b33a4b06113278842be630ca670c3d8dba1d771203989edfd538531243a07203fc74196428b6ec304ec20edb75283cfc0f8634a23462b1fa14cd1983dedf39129441fd10d08e9a181e41ddba661dd637c7e13f82d39b52d9245faf34b438eae6b14fc9dcff3a958acc376af07706eb2aa88d0b706fe2c1138de7a1db599e7b9c3b0049e223536c45954682e4b495f9e25c3aa1672f75420165bbf0d2a82aba2350d5415ee05474452f660f70d880bfa7b4969ca0686e22fdb19bb9da4d79c873394d7bd51e4ddc92bf90c8de707a1b57e79b8d4637c33ac9687c0dcb3d050668ba33ecc2aa381abfb8e425a097646c8c7746fe1b37c069e73865970946d050c315b3a3ab9b643548f17db19c72d2e54076bab8f71221903733e000cf6402600ec95211c395a8a9b7343b67eb69d512eed074a9a501919b73c32880af14ade91f0f54723e2fa4a8dbe6cc332d7e15ac0a0f800439f8127309d0856d8384a6b8e31e1c146182f44fc8b8ef1a4b04ce17392434189bd8837ed3a7bc72a40e972f1de3e87b2ee14955521d39bc63ba25c736ce819c5eb1a4876867f209fe790b9ab0eb91c7dea197772c10300e6c20202911be35a33223f68ef3f8649a90418ac7d37877735ee1b27a8d20cf1a2f5d928cd9dc723ad32691356d4f2432fbd691dbcb8c0118aeabba3d1d10925949c1c8bf703d9582290ed4b0a905b410dd061b5ff334a69b4e727da237cf6760de39b5056de2e90f33f03db213567656c64f3a6d0dd83b34552afc0e8654a2869cab132091c21387d3d900a76e9a2aba6265ae6aaa3c6056f17568044e1a9e3d9e507ba15fde775c2307b5adf2686740cc54d68f472f0eb4838e3c6635084592e00649dede90752a3c5fcb3a916efac05098e2d5cb26a3d8b5a9a6adb6800e7b495c0ed87ab0fe5fae49ed7ab30fd4b24a21bb2ad04ba13e3c502590847fff2c8b6d613909536227dda7d14f4c2eb91e45ed04c7c535d6e723ed5e3e3b5f44bc09007f938c5307954c9dbe62726c9006d824ef73b5501dcaf04b720d097a96aad4fadd5fafeaaee845d018b8bcf7988d13308e56f05ab39fa332e61c7bb34343955e26cfa196a26c4c4652a13b9d66c08e5dc2893d9f0e10377cba4093626e4205f275ae555e56c0375c82e0d0fea12e537c234f511ac8b23a367412cfa7a40d0edfdcd3d5c3a6e09147237dbcc5836e318087b03a47f2bc313f1f46877775ab7128cd15e174dde46106b61769a3d353502a3a96a768d1f1085ea0d130c2882776bc253240d4a6e58330726c5b83e33358037303efea11b35b20a57ac911e7d35692e8a5d31cf837df3e84dbc3ba223cf8de12ddfca6ba5030f1f68d30ff2cb4103f13434c6de8a7ca4bd6a96d0324802531a56131e88f34ee2d5ae89b6a8559f3a4310319c0d7ec6ae924a810b3d3e744be39427556d0f526e5d43ef489bb6116ba1b18a027eaf7dcc33999737e7458b54f584be59421ff804c8990c7757336197e9550cf2d84ffcfc9c407cc8763c18936c97b26eee2265a3c2d12dbe6074d4ad05b13802027b1b9636bf80c478a5f134f38e3ed98a96a4534ebf6de5c92f38c0ebfaaba6b87450f4b1ebc91a8c0b89dcba8e01e0bec49a142444e99a192af166533e74b83547aa5161acb6f8226bf70aa93482462f91c1ae70bba963f282a8d73ec2febfc08ca3d7c68d33ce658cbd97cce95969b7d5ecd835ef15a8e9171b8b27ed1a82dfbe1be3a1ed7ff916936a17a3cd3b74e6ac143124a75a7221e18cf196694b82e5c637ace397dff14582c888378a0529b433897fa0f1fe9ec166f3e865fe28109bdb91a6d7feeba238481167ded83065da858225756e909efc27267f59169de484e206df9ea5391ddb5e2bfffa531ca193e690de4baa3f4cba307f4446605b2ccdb7f39beeb19c130edb02aa649e94d608b9fc65442a7d670d3274653d91c8beaf6a0aa67846c404733aef9a9edf50a0687aea7c1d711d8c3273881cb3edcb4782a4bc59b9a3de8a858cc824784325f3ca1d7dd81d6cf866a4593f711a541abffddbe768f471fbf89c310cd13b23f28a7b8475729bab76bc5b01acec0f000f13c171a50f3bd11d37d676798a9558bb0d8728afa919a84eea8a4507b48ac254c3177ecfd3736f13e2a54d63dfdee7ed6abf32ddb7ca82e371d0ed71da3ac5a14578b9b65bd4e307f0059f511a0fa687e84769a4fe1b95e8e35c293437960a6fb6ba1d324e2ec915eaf1c2ca0b7e8f0ec120fd68e583036c28a37988bce6c20abb7b69f93d09280021aa90794c75dc9889aec808888fec2d0eb13e0d7b3039dd6f34de927aecf72913b52589fd81098c07a57db8b0d150b80d961ca9f6c28af93bd3bd90e0e0f6592e4d7c2ebd6fe9d59638193cba02a0ce5b22c0b995978f8581ecff76b0921d2e4a5818233ae13375a1f0ddecb280346f48f5b957cc155507009781189980b6cb09c3cd877ed4820e6c29446b76b23f08196bbeb1ba8b3a3b232cadea8e204fdb3c550b0348649b2b0bba42cc1d460e4363e6ba575ad20f8c3164671a0e0bdeef3e529ee9e9ea5d35df69bc6a90a3e352fea68ca55fed8c64c7bb217b226b39c18c8f94f7d5c615df21dbc16663a6ba349a894fd0cb59e4402be9e95f450ccf51e2023eb0821d5e8d6191834b4f314b6a5ead2b927c107fb87a885afba2002df0bc8ab35f151caf771ae0e3949c9df6966ffb854ddbb3e34266c3bbe8cb391fa3dd8664c22e4ba50bff8af1ca252376b8bf8e0fbe1fa6106880fed2754908fc380f446ffd73d574f784f8a62945c1753f509ea3460874c1621ba14721536c7a54aa511a467a743e6c0b7ada9d8a3718526795fb06a292b7cdf469f0af2b72a4e0053b47b1ce840542d46e98dc7c6b3b0a9179f3af66c3eaa04be65406efad1bafd7abf4324b9e77bdae8eae2da3f4f461b292f8df726ee067036b56470ed66f126c3d92c5fc697377ab02d265bd589ac9b9cb9178f5569955217fb7318de2f92f34705ac1c93bfc561e8259c6286845ad2e1aeaad9c1398c8cf635cac5de9452d71d787f5c1c65dc70ff2532c1935945980105f9e0eb7ad4cf04d861a7dcbda0aa5f5aaad8ed525098727d7c9f8a18a6676357538859113564d08300fa6edb5bcd4f208f06b35b05e854e3303680124d3e5c0dd4cf68c56764ca3891b3268df4258e87dbdee67365a906d26eceb8ee22783b96ac1b4c31c0bce066723c8b36b3ad8e81e1b3ff76b2ffe346b99ed832dc0a10274dc7c82df314c31afb17ef7a80b87772988644a83bd7d2af7db2f93d649711f2111ffe818cd0d344ee3d0815947be1b11f68b358b4763cac4f283573e27bd6cb17b3241d61847332e0d58736d255a9f4077743d7890ddcf289638463b0432929f0ade77b98fd2dd3a86c0a4bbe51f115e322924262b02bd20886d2bd0c52517854370c0479b265b1eea57afd94491b0e00213920fac30397d0758efb3987e67ed1efb18ca45187c73c0de0108bce1f6b7bbb9f684159f774881408e66314cc886cbc5b60a49cf0dcda0bfa250cf1f31b026513b7314754a50e62febf43fc5a9b604dc42cbb52d2dcc249ee5010565697574e07d673b91f98cd8e0592cc2bc95bd6548be21e10d4392b5cf8f28a1afc7e0755c0faadde6da9f85c55841d36f41fce55b482548aaacf4b43a58d97077d7e0e4f8ec7933230b7aa2dee42e224a0604c3d999b23401be5ecc7662e01e4e09640d70e3f0807c5b81f589f10bb1938209d401121f2cb690aed910138ed007dd4bf08cadf1c6770fdef778b0d57956082e08f6515c4ad891484e08713a3b9d9f44bf387b28c05dce02fa7e1e4f7916bf91f1fb93d06b4e65f259f6bbfceb0342e31739e43d6d036d99e20f715f76c38ded4ed1e81c9827892ef4b793d1c1974a47da87372bcb156d23ff3cd44e5655d5c3f62c6f8349cad04c0e2abf51d0d50d69ef11de0be6c44d4c0f0253fd66dbf0154f7681c194a8a26eb9d87e57f1eb2002f00df44be07ce51b60f6a2808087823066c38dcc76853300e2f1205e60326273b8df02daa6c9a2e9bb004ad99a634dac3a7406ade683dc6fd902d352cafcd904f26267c53ea4513def6ec25665ad93a900e4e1efdeab57ecda00abba2932c24b1bd19816af74ac533dd2ce970422c82af12474defe41157c07b565d549f2b23c09c508ef29c5319f3a35d1f7d58056ddb369f2483861e4f3948db61a6fade710f26246810f8ba8a8cd44fec98a624516b5637028b3b65a6d36fd689bc33c85472eba45a4e396ae5651894a6427be41a6be4bd6a27592604abb3715d551e9cdccd8a085bff33c02bfd905659ca17aba92508b510032863f36e14857610a4748fdc7c4991cfe1c05519f6b733bfe437e3ba354ad8ad7f687e57a1528ddffe61b5d351e7f8e80de36a4ed57299040a5a961b0bc6607949b2b339d2a227bd35ef104ce2a433a2bc473dacf4ff71b9a73cc30894387486d8a9ba1736619ff7f8aac6793b67c4e52b06dcfe69154090f268e087cf9b42560bb749117e6cc3e10fbb4e69fbb685cead1390010a5b2b180f6d947adec3b972157b50fa3afea53f680134e494054d301e3cabeb9d9446a60c4ed072abf603bd0a593f40aa586906d31d0cb247d94a97667a59ef8a74b15b5e176539c7f0f16c07c1becd6ea345d9fce6609e2d3a96edd5fec0596a5862e9b49714876af0068040a7206fcefecf942e5ce7b78f411270fa66179319daa7cf106a9e522c643a6c889ddca589e884bac70f6daaff3b1cd7983c8b0ef59cfddb13f2817035e4261b9d47f562b4702e167103d5eea3c537f7c61dbc2c1f94cb721afb6c32ed1f366f1e8e267be1e728b23de53b76e679d864fe2ad779d774ebdd0df8bc71867f26a60890f20edfdd02872ad3423f1d44a0c8b002b8160c48d3522736e6aa0507ee520352570a75305fe0a2078bdf728f8c44e817f76965779ce775a971a1936a6c1fe13860a8adc31d683a83367880f2d7383290b381fe5f40477096d33ff187f3e21bb8e60420c778b581a90452198777d8a9747f5d1d47475b2ef727140b5987c69cf6869c00a7c2c764f38dad950a8b645fc093af6bb99739fc33c742c7daebac62ab93ba8849565d530de36ccf739c8d6c9e3aa7863d405395e0fcf707ae4fd3d81f89cd3b60a8d11009dd279e55f4b30f24b2f0eb872a511d34a152a5fb52dc3e2f3e8c7032ad3a39bc7d7db2d3874072b3bc459a3261a89912a86d91c339fdde1ff697bba31b51b59bae6774bcbda2eb4a5a8ce6506968659b7afd430c31ac37623f3a64cd5ea7a19a61440a7a28b4488172c5bc0ed71134e50390c207545cc182a6b4d402f41231ca6632f0038de7f827f223dd6284b65a9973b7b34a423e29023a99ffafd9a236c0082980c9b1a7127d9e227808e1a9823234cc16209cd037a25fe62ce4d8c442563ec5bdd37ca04710898fc6b9431f7100a1388f2a5a3b38b65d65a8c80c826340191dcc55c5ac14f7a786685b90e2e77e9135e375557a81f8b4da0fec6c6e148daa23eeb4350dedef6ff6bb93c97c4baf725a38f8a4ae747ad779ed27add62f05e681163d4c41c27da960c38dbd5ddbd6d1fb11983eed01f7ead29e6badf1a41c1807714066708913e3bcc218c1b822ec08469b408886e8eb8961190b9c46dfa3cc580e153047024350bfce31e6bde90a94a03f286424ec81167d95b3293b608a2e0fbc899efbcfee11ab938223cb6a01da30e12ffcc016f8e9ed5cc8b759c92005d28fb5283b0aeefa9a5c0df7229c83e4bd93e21530848cc3828c6813e7c09ba7be4212eb1652595f72df8841a43e42206e7862c5b958ba6e4f8978e25cd00abf92fc4941c6ec424e8ef7e7895a37bdfe29b38bcfb4d8e33e45303c6fa0c71b5cb0d515ef4046a463d0c427f9957ec99f85e8aed3d6a4f96dc5c9b24310922c66eaae49662493a5245a5707f19b32244335a30e3063087bc842e74b862f641c2b02cf3f7dda70be90592075c88ec879f08d3182feb074f82c6f631e50fffe4beba9f67442f8f4eb09476f9126eff9009648ce3e426a8f8bd4a50a376f67468db3a1318ad81d5b296362a750fc92810d0d6000d044f9decf659aa5cf2804aaf755a6637d078b653f6882ba7e76f15791bab23c0585a4fc9397ee9a46a2ce9c8e58279fbf7e76f762bf3e65f26d94d56247d9654ee1da331ad1befeee29845b53fa4d84fffbca9c387f087fa878e4cd52aa898e4682592e4859f71b1d2917d9da0d32f85e746ea3eac66d0cd9dc7508554161776278ab7352a5ae57ab53e1119dfba14750f881ac32e1dae0122da72c0a2c6f8dac1866461e4005828bd1fab3ec4e98da231dc1927d1f1259a72de08fe9ae229ac2106280c7b12ed46d572d3015d61267c1426db3f3adfa82ee12175d667058547b289f3c101a47f4bce2984b3ecb4bcf8e23d84923cc541a163f8850b608fe1abc4c8df84c9ad7ed73b7c274be61957fb6bb778335a3793cc5fb31f1dccbab81940c0076b53a00e0b5162cb3c08cd604cf702e0732ee4de68b64adb50d5f37cca71d0fb830a6e952e2ca37964d6a35f955aebaa94f3de21c31b8af36b0f0cee6c022c2548e73cac94b3bb23fea379ab390841632b739f5cc6325bc9bf2ee4aa151c4c457e4df5fe8eac8752e2fb9aae8b2d5f94cf40b0d499896645203c5c6d8d3255c4fab4964f4273ee42d2ad481ebdfc299ede076b08c0265123baa61605eec977dcf8443c276f101f27d7b05f81086433ed97bd0ba8456adbc26177d701d9f7cd4ff88776c39cf6402f1752b6914b8d0cf6ab235098bc7549fb57b6a9e79f97f187d2ed1d4361c5e370b4bd5192ede4f8ece21ba104762fd2fca0c1ef2b8085c57767af1a6f4ade0dd16544ee3a8326cc1b9454500453676512e5870901a1074d19843d7072e98c5372dc30a93c395fde764c5f2e923caccc24e631b86651f9fb3cac16d5788e483c30fd836a8909ce9aede27e810eb3db06ba05c05a778818effba43afd36df6ae5392175ca416fe2a44a911b2aa75757a860076f97c33aada5fee7c9578e99705857c42f8e055dc9e77950b85dbaace31c883f09ffa53b9482a38961b706ce329b834666af80275f62d3f72a2330d6c3488a86020cddf4ffca669db2776077ee6b411ffcbfa2c745887eb809ba0cc3e099bed22c6c1568c972a37eea492022d87fd904d7faf985a430304360f0f1582f25ecb75915e04afdf1d1814f54f367ec6ec7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
