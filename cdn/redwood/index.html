<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"121d9e65a024235a38400b7e4ddf7ebb1dbfd284601ca5d8e826e5231882bd3366ec04fc1541bb3d5322a46ec6e064b19ac2d507c70ae306c34d96c42ad2fcc2e7541d7c6f9643e2eae0fd7b9459c04814cd9d04bcdd551852e46c4914b35a9ba71cc350026d141c360062150dbf6d6645426547feb339cb7598544d7a80fb939e02f3d6424db1d7e2e279d1067a399fe04d44295093a927d830b71040febbb4dfd1761ec42bd500c8442bd22a91fed13a73851a4db68fd172923162bf60b3f044df0ce5686dc5b39b50a7b84bad63585f8a3decedb32ca8bb783a21fbad4a931d6748680e07f652aa838209ea12176cd860c601ad0f676bd16022c4acfe9401cf294bcb81933ec3df2af81b55ede6ad79c615856744aae98f534abcfc41d291d1b3060bff2b6347ac612f811b37dd0b1d235925bcf36f159b487fd31de096f56a3bb61e0444fb3400f45a74d36a9fb82c83cc86e7eb5a6e0b63bf2ae1d5ab2f5c35157cfa854e7fda4227010344b02f8a75da4170b074e9d68baae8fc30cbe9414b63f8a29dc74e2889331af93a523371a6c1c10320e9db550d64f4ed7712f17876b94956c5b3177cb581bb8bb4d1197de7066f7035523635d257cdc6222f9ce830acb87fb927108480d5686dacab4140a2970c45fbb6902a1bc7505c2fe255306220a2151f7a13ed1fbcbcddd29aaab2c0ac765787818557cbc620bc541f0928822b17c814dde8e94c3b9ba6d4cb7db8ba0778583892f72ebb32ccfe9ea921cee331dd695db4135bfe1764ebc5978fced901fd091ecd4aca9ec2ef19eb735e4ffbb92d262292c05b02fb2ea444b5bdfa650c85046dd482fb4eb85d0f92e42b08edb93f717066fe0d2fd3d1ed3154ccae0472761bd757f5a14623ff9534bc82c5491c8f0ef7a7933e287a61cbe5e1a0befb47eb5f54acd40fb6e26a15179f762254206beb8c3110013c9c6caab1f1e6e4a2adad9af9c23c15ae8c806a5d9ce864513c4c0aa6d02700705b04c9dda0d041210b3ee9ecdfa259f8776b94a44bd831b7204dd92222685a726cd0a1f69f54cbe31bb82199101ac6cc67f8fe85556a6bea63d0c4d3c29afded6c07e277aca8c43aa77c18802782457799cf2f0e7aabd86142e875528140ab9519b0c1bf7df68cc1762f59808cf34f5e6341022938307221ff6026e1a320151fbc298e564098c015168b2a8bb1f8dfdad105b601497547f5f18636e32249af86b61d9a83b91903f006fb9c1cea7ec50dbcbae6766ebd9f6b923530bf74d9ce08647fd06cc4e4830c4725528345651b738ae6de0ef365c9037beffdbb818429bf9540dd3246935e5347262213a8a191d462f116c3a6db3147c165389eab76d03d9d0b0bd03c1a03229ab7d86941757cf750180071c301190c26044ebbd5286cddb64cd9880305d3629f1ee89e5499ef610ecc8c2d3963193b2aa82d5f160402e5034e4fd703a9319182a82fe63554a25c949326f2a47d01c04202e1457afea9128fd140fba9e13a68040d5c7ad95acadf74cce74abfb2b479c8e716dbfd292b70301352e28c2c3b0a35d9432c0c7c56a263c78301fa15314581d5372dbc03ddf9656ff3e758bc82f1b89fa50b9183427cfc19fb8d2a134bdc71f5063663530e149d4aa399fa2d5a1ee2b350d570e72819ea35c1db13bf61a7785d56507f68f35fc59773350ca1a311a8757cc1fea406fb689fa6e6be7edd005c486d64e9ae6fddaf75cb0203127777cef81c9556d0280aa2527596696a8d4ba8459a086da7069f18a38cc8c9221ef920860c343402ca4268f35f76022bd86020fbbcdb05be4974788de40444d4290b2a66624559435e48341ea380edc47bd5e0cf9ebbb01dcc3dcd4c2b2270da46719afeb5ce0570a5542ca8e1848b241c427ad5aaadd33ad30c773f37c49f72e2bb98c7f3e68b504e9b10f007fdc75b551f55fc4a42fdb27e63b84c90b1277ea3238012d05eb7bcc188991a836a7cb6e19ddc84f09d22f3acb942e1fd8574ce94b4d23907d668f692a9d8b1f22ba13783cdf4d27479c527db2dded130dc66424a950916e35bd4064fe00ec5eadde5a52500621ffa8dee993780aed8b3faf3d57831d36c6416b1282c437f525b13d53a7920588edd06b8d61f79e0982348ed93122f170d1f4f7be5166760913a84ece5a80206308f52de591cfd6174f3d69f5bd5728faa01a85cafec107fea742318c1b976e652bf9963bd9ceba11bf5f3d36ca26c064b2844edc4ee52a59359e87339033f6f00947633a69d14de0b9e3cfa138a1b9a3000061b4fc2a5c72be11135de4e69ce03f525965ed20b9e29dd7173dfe525d18c9555a7e59f9aea3f2d1eb653be727dd70da5d1f14054d6b4e97202185ff77751a6fc39f9ce72b867e46830c50faf78850a90fd134f85b029f43287b8bc67f2e6a1cebdf00a380d5f014ad13a4728435f93fbb5da428f39dc8758cae3ed692592a6d9141e2cae9c2e2c68e6a7af021e823847581f021c343d6c2ec20af86b89cd097cfd1e42d96be11e23f3fe4c0943e7fa710c2233127bdb5599644c18e5d2c9084dc6505cfacd256ea6acc8ed7fb8f446d32c3440e26773396bdde48d7b975d41d745a758ac3fe9dc42a1c1c7d7a03f78c6cebfb5f2777372dd713f02ab8daa7ef6d5cfdf717efa939f8de96200f2ed24faff3181e2e3726d65c67886fe5cb580a48bd3e16beaee20b04f50c2c08f9ea465901119372c2ad662d658d3df7da2b519f0e924162c89acb194d12cbd99ddf220e0f88dab4d81d684d272b4ba503211ad502b2546c691ed5ad8579f1312a57005c030aee25c9c900ffd5f91c180477f0ec325249ff44c974c60c6f70bd30f63dbd06d4e82ceac0a9847fdb855ed55a68b729a02cfc7b7909d730f3132dff447added19b68804df894705273282afa5122d9a70dd2e984c0ae1aca5ed7ff72de64fb1109475f932dad516d1fa70a9e157616324e24baf1a58d1de240354f90ea497533eaa5837cdd2cf89ede895f6072d747b6e07d74ffbbaf68968c5713e1feaeb8da2ddd3935fbd5d5910fefb5a16af8df912834481868604dfdb2cfe77d5503df3e50823e691cbec83e35a07d0a7286a890d329e54a133ab7e466ea3a1f08c6e3ab7067a599ec9ed0d542f82558210f2a0f2470acaff5b1c5e365bd89a6ff641dd02202dedcca13c104b4d746e0be035ea89dcd3551bff86afd42a3cb3153d3f6d6f114c2dfdd3ffa27fd734703482054a2cfd53d727629ab077d95a81da2caba3b2163c53bd62d897ad80fc9cbfeb8657c6e4201a244b8bd3690da34f45a4e096803d48db8ad86c35e9a43146a2532cb2122b1a466466548bce085aead20429b011bf9acae45befef471af64234d1ec328e8d1e99bc8f295f911569dec70ab06fcb16a28a354b1bb56b69ddd527db5294a8b447ab40f1f930c46fd5f839091c5e2cb409de1d0d2190158422c4d06e24c69caa3d2c532e88e36675814361eff8f39baf58c3d50143688a24861351077d757fe3a13a571a76b4f5c8305c030bd1a99472ab14dd2e5371e729190b5e105ca39fe02d64c0a82229d5a14f4cdc9e51b492704eadb42016da047df5c617ff11e3c40681394bc9e6bfdf9564d8a5c2457e7d84858a8df5e3e2b12d7e354a085f4321619b798cebf66396d5f305404d050a8160610c945434586114ae0700f91ed0452b1728225a8694a0b7175e9cc08cde05867f3e14225b7f67448fad820f2f7268aac2239b199642ebdb1ceb113f4e16f8891e159f86abf970f0565f5f5ff2b30f70b05f0500670f496fc83bbde158e8571e2dc1b1272a8bf7c8ca39ccdb0e30f7e407b864788749e1fe9ecc8e63add34eb39a026c52346cfa7dc2c6929c5dba154a99d2dfad93041a75fc72d882a87db59b51defc980c59eb611cc35b2aa1d8cdc64925fb27f761f9d393761bb74175d75e4688b5c7aadce768b2a932e83b816e3b0e0d3e976f5996bf0dc6bf7cd4e2359d57427393aedc50f69fd05f0ddb2a7a51fef07236d032cc1f6e164724a301c01b1639d68922785dea7111610edf343812be90c0d1218b675584135f4f72fc1f0d351d565bbcfa79840e59ab3f68d630b535f20655dea65fbd59800f2019adc478e7c3dceee9552809c205f75230bc43f570dfd90021c08fa5ca41cb5c5757584c3e2153d1965d4ab7eb5a7af3481f2da604f592555187d4db36dafe5131b5ebfae115e7a45978ade7e9a7be42d84a4226cb1cf107410411a391e70354d1e40d8a60706080dc79c615b3646db4e35a9bdc70735ed4a46370f38d3d1ddd35eb00883f5b474554cfeaf62179065fa97fbfefaf769f2496d7d0cc996e24edbeb68f517ebc500e923648c8705048bdc6ce424e3b6eec98ff5cd0b0268455f8145728dace94b6d0b78e1bf4ad04cfa4f98c970e61dd550b566204e3dd6148803aa06716fe52b3b6e5850ff9c956170b19c0fbf499ec8cdfef21d6d45803965fa45a6fe37518d19484fe09671e6319fa7d8856c2b0a12768a3aca0122712eb70c80062c89155a36cc2158c10bc7b944e59bd0e2a549c5a2ed708e03d5144dbec142d904f6b29a797d8a73510b85c637986bb8f1bbdada59183bf510279aee82c08da552a11ea8f26f410d9226e5eaf1349e87cca4b54abcb4db8ce8fb341320e905a0fd8659ed28c43138a7a11b1b7894aa47336fac399efbeb406e60615a4b7072ea3c6eb683e8c2ade8642158498e8ecc72869c2a0f196c5a3183a46819245abd564909e4fce7489b77029e134f3bb26affc810aaa56b431c2734cd75b527c80140004f171007f015172ec97daff0b89da7e4187691a3fdecb8d2d5e11f885f90ea69a1765bd46d7f912c28fad18226db7ea4ead86dda3ea40d32920e169f3b0fdcc645ad8c2c860e4db36cd1895e4b287b1ff36de53de93522b08f6359b219c100b20c87f33f59950525f45c391450c3921e1121c3f4efe0f6fc1b724fddf3f59c79553d470b4fb2c4c7cfe31499cfcc4a0381c8eca37bce2e12118980fbfd9b0abe5077a94e6c6c10aff1c403f50982441c63fdd15c700b8228b8967d612d192d27d755b9ecf79aa5e8c0f014c238d34e6a5c801ed8eb53a2c4909fa3d1bd5857a2e4a05368244aa7773790afa541996fce21bc4553150913ea8e3a8695b1a21d264a1f845cbfab656f126786d3e3cd9aabc8ca26a138fc54c7f6516522cdb1b376e650e01d6275898e5615d7c5ee7975d5e71d5d03916385526fe4a39eeef7a1cf9d6a9ec339caa8a41e5c4045c2b46925eb00e88df55cbbde5186dee6c4ca1418e2fa8b75cf44eb934eb724d4cbec865c3f28f9566b071edf45c98e5d9b354985aba91489b094df40294669db60751a7457cd3a048d7b34db305b34e2b1917593d7e4317b2fa2feac3f18b6456a9a0be987ac18ba982737692b1170b58294cb97297cc5bcdbaceaf507537a63a54683b75a408e2f3a48190caaf695bcfe448acca0b0d5c84f5cd6723e41201add72c84946dec107e5b5a90402c8292da5d177e0047854ffb52a94d2c6fd14febf9be721d0eb9b4a52d49a402284b8b81eda13adce37f950dd15c087eb368e802d3158ff9c6c8362a93e1cf918e40b531f30dc47bc641922092c7b4a9f67991265f745a4104b0850a9b8ffebf597c3dc8273a7fd5f86b3e2b11c6ab0cb05735b008eca27b689e54df4f3e2fc3ae70a1f5950fc2ba49b912ad9cfd8d95affdc86f2579be83f2725f43537c74853771623803de10ab818285dfdb4d56a4222519e58686017f0e12c024d7d585d02d540cd3d4e6621ddf5ddb0d3ac65dafa55806d4dfa095b5e4a707911c784c32ba044e47fd571930d5892ee7e7ab49dc605ea28665dd3ccfeb59c993cb7d83a45dd7f498ceaba53c9861d5a691385295477b52fe73c15b2d52a951db0e0e034c515180df384d93f46ca98abe640070be6cab0860198b55eddce52412c8033d6e2b6aadc98fc776a62a3abe6081055cdbdfec45deef049573585127e7525346604a12eb06e5c5dee1e58476280b41a761b4b2a4a74f629c10f6a2e741ad51b6b42508b3442627dac1ea4ceee490d9700bf7fd31c459949bb580ec0c71a9ff46fead2988df8df1f447060f4899371e8fba32ba131b56332ce94f293dd32a277e90f9e27512af5cd45b3aca4dfd520ec68e51b83a33f4d127ab0c6b9d63d1914ee66b635f5350a175880cd49356bf8cb4e7cfa29934de0c59ad2b8370f805aff9589c3a0ece1c9e342f199d724d4308b31ef2ad1c229ea22b1cab8d39f3656007cdcc4a85e40a2ab105e36570b4ee78f30376aaa6b2a307f91bec1bf749fad10e3dd1f9c31889160788d53b3ba720fc75bc234cfe04b0cd9bb191a0ea1e08a888d8506b1a536ffef869f0159a4ec5a6d7d8357c2f20a34267edc9877cb078e7ffc900d073d57bcf4b51dac61484272d86d3876e0f2e438a40ebf5f607d71b2cd62aa2c397c9365bb034075a2870cd3e6799731dc1b39fee14dea8b2ced967d037fc7be10adb50e39fd566bbbe24843c20a9a6491198f21a46f53d151b4388fb725058486f67bf4c323311d3cbe3b6d90f766a566602cef12ff5c42dd287f12c30838e37cb2b1336997fe8cf9dc7fad527fb995b47e5ab5564689a2f34c25eebfb9474168bc0ed305f2a28cf1ac38a3906b6f95c452b3acf754acbaa6d2479f8ef8de3d1f0bdc625c86e23e3bbd49e50dc1b7fe148cac585d099580eae7761e86f118898f6dd44cc4cf31394ba04095e6e6f1297c4d60c141ca7096b8851b0c5ddb3409f49b9912bacb19e272291606c520c194d407ffa4173c645f8fcac51b2a961edbfe89631d88c550545ca3c2442b28aec94fa59db95c9e6f7eb9fb3714a9e565a01db2607d096457b8ac9af0002e427d1ae67d5eccd4ce702f9fc000f9740a8ab233b7cc20a8a447287439cf6594cb03b304b9979947688eaeb8f0e53aef1beb9ed678d19392381405e96115df58ff25cc11b92689cdf0c44e78929d57e1a8478a245ba51537db76a91437cf7417aa430d1b0ed92cb55b2df656b023ec4fed98bcc1e3c18f561fd0bf3a8625f724da38f3b702c72bbf872df62cbf8569db67eede7fddb2c9ffd9e788d2bede03d6fd7a54f9446325931dc0821341ec3ac9f6c0ccaebee965f720ff7a36f091d9f5495361e132cd1e93ea39e99c7205a4498cfc78180bee6dcdc1d5896a6a9612f9ccbb9d3441061a90d596df751b2450b5d5efdec9ed5faa1c6ea5a1c90ebfc61e9d7050e379020152f01856e36829773d49e87be5466574e8c64b614b8d102140f13397af4350ae66e10b014f02e1afd756fa9dbdd272e813d0d6b06b65a1e8db5b463f397e3001385c4c5f2b1f7c2a51cbcb34b6d6dd758380f0a3511f8b6ce48e85c298e9aff9b0e06660a77380f7fef3a3b67c83eaac50a1810cbe3d1da7ff65de0b66833f9f50d1b011e1826e7324a25b0559b5be0f4a78c77e22b0d0696a8bb24cbee5a1ed5bfa450df7c7486ca5b20b704fcac6a6387d16c7c21c17a818e84f2607b2f924e58b3163bfd37283495f58642fe58373bd802074acd780f51c829a873102884d7d270582caf9fde0f81a20c58a2ac8f8579e0c0672a599441c5908dc4e202b5859149e21367ff9cee8daa671d7e5cc661891ebf8a13290f9475362ac4c33fcce369c3c1804cad327d85174db7d4c778f5e1443882db7c66c18f45ccece11e005d494047effd265ae0792160bae0d1eb1f933a1670a7db80a2e1edb912707619469545b5f9078ce049a80a126a446a6815cb358e602997827ef2d8c1ede68c0cc2afd350b872914a0a7fc68b8f410733f971cfd9ef38910c2cebcda4892242006b19e8792310532d412e26573a1892469825d3bca86dbdb938ee51f300bd8166847cba89f10975e8a0bf9a206888a5a573b249d5e1cc32f041f7f294eefb016ba43c8781bb0c3504092a430febf2c296fd327b86573a74e722db8f78ad030df23788e84a69dfbcb51b44ad9292f6ffc0330d9dceb0f13662c9ed00d4dbac90314e4b0c8613a779a78497ad72ddcbd85b596bcfa10ed0c90c1b4042e558efa5124901882bbe62858efb4a78cacb94ef763d22531371e5b8a0db5cfc27ac15ff71daa2004c510c166a836ae29b5a78d75f9926915c3bb65700b671d68b0800943ee150cfd09190f32062faba3f0df7a790a761eb39a51574685df6fa0ed1c4007f8d044f1e2c1f6d0f7b5bb2e092f4f688b8c8f09b89e083deaf6012109f0ccfcd24a070953189d135d6d31b92396b7f0a5ff1dc72d8394aa32e199199ef549b360369721c39be394b8e94434a2b73cd3b8f5f1c1fb272bf90db3cb16370120c1017c9c38aa507a11d7f23fd985511a5eef904f9d040dfba1467f648334b01d5805d1f75a80247c25ef88c20f94d2cf9769d5cb9ca01305c04db5f66dbda92a2fe20d317435ba043a9e71d1ce76306f1a59f308e9064e39bfdbdea92d00abfb0c3ab2a8105900af50cbaf6d90cecb606cb0ef5f16c42aff626981cd02ed697ae3f1ae6ae9a5bbb339894bff7fee8cf1ea21011493ee1fc25d9e0ff955a900b665c9b1ee9c03113b26f5844f445b6f735b4d420be6075d56859ab7f35c1412bdc9d310c7923ca2c399068e8be3045020d054038d87ebaa73ca315a907d9de5e2e62f7feb3f93efc7cf83377e8558c3e30457fe5c8eb0c0e4ae1553bc5623bfb5458f06c40b8edde180030ba819607759a25ade8c19dc1ec374156d71831f464e71af1aef33913039944c30909f9a7ef4bcf045b8b1dbcae8a60c7794a74a28227382d961599b29fe87a08542aadee6f0bfcd36751d315d71f764c89adcddcd11e3b54e380b64231abf02845bec2834f142615d182bc3caabff494d9257b9f2e58c92311416ab3d2e4dca2ef30652071aba969dd8d0366535e41838cb83ba03eb12350868d9a7668fcebe2ccfebf85be112cdfe0052ceeccb29b975a499a88e78c7a355de586acee85d63f1896988895617d6cb27d5da1ddc5d1db5770c10d71076a0cd2b289f10c49b86105a0e392c9774acd0a0e709d7f67d114d87ae4e4330d973979ade8e4401f70a6b90b4127fe0a805f7fc6805cca79c823267904ffa0884e1cc4c68dbb4e0119efd76711762b1738b24e36c66dc710b1b90032fa99bd8ff2487b2efd0283e0e0232ebb3b65580d6fa0fa154bfd5604dee0ff000d2b6b4eeb6a310c20c80cf38590a500591b48024d60c9ce121e8d609dd0540206f161fd3cf132f1f9b3d294b730213b050acb1f21817796d749f7b772c6f1387a07bcc05b33a4bba7f5dfddfdad60605298fabe889f11abf820a9b97612c7f0d96b1f4fb92a7b2412783d2578909b3749833663a34958e1c700a83484c9c4eb060c0973a058704762b5a7b1fa740362797fcde1a50d5289018f68209e383a224c66a9842ed1eb8116edbd72abc1c63491ce7b5dd16ff7fac2cf4a1b4a7f498b51cdba22eb97c01aa604e11147c59edf0314efbc84f0439a85587a1ee5556793444e46990bd6b9d87df4d5b6dca35bb8573b8dca2ed6bfaedf8ac328fad6a27e69511f44a14cbf2f93c04adee2ff1b1279e1710060cf9995ccc4c3019699cc764e150ccaf886cffea2891f9c208cd7f97d8ccd8568a91704632692e7061f4c993e9dc60ed5fa28279ee783f27428f951642ca1a0575c240ceea7c706e66d0d5a1eccf23eda1ee9b32a1f6fb543b89967f91b985b1b621dc2e6dca42d9be14953ec947ea6d31a38e869cc81cab7225b895b048d0460fba9d86021645c58d4e83325949c3e1e3ed3c81066563f83f23d6c108d59c03a1f89be63f6e95fc73a2b873b1dfa944934d4859c05033de446cb26fef91936f3b5f3122abaadd003b106dc68ce4a4de65a936580e4bb4aed5f1ea749664ba1ab4429ff5d87682e45de5bc99b80c976bc23b060fa06cb178a75ec59c2eca33b60b2bccd699cba23961ec78288a1badd452b0c5a3af336c846e39a80caa4c21a17ab3fa231f3e595b7dbab59810fbbd00494dc0f245d387c746e246c8b44b2ec0edf455a63204e648130d12d5911181aa394704b47f3be11509f720e6961c7c885687b90ad2d2046cfcd3eca6c6d54071c269651fae897670910dc19a04ddb86acb8a3dac4c6b5d1e93ca9c76bba70c8d70dbea48f53776c7a87bb9c9c2416c0686b64ad4a959422f9d3bd7eb557d178fe5dd248bedc3af90214b489ab42ea30ed4dcb539146f1937253a99737d3240778622e654b3bf1904e8136e78d3ed215049aa140a8c8b7a633f82dc87a38994ed3ab34bc4c806431c9ee195406561b3137935dde51f18f3af97422631456029b975af40b1931cc6c0fccc5a65c66de2a735dde8666b48d97ff21ed6522217b8af8086a85cefaacc882d472b961be094e8bf933e8396de29b668a1b5e90291865085c2645645ee22e77596e143fbfac6a89224a8b1cb49519b4506d6063706299b16a57f3456c8608299c3d27c11601df75497d03165043fb6bb1f3c51172b53c83aa5e06a57e3210b0042758d1f814f25ada69046589f7f063e44a332eb1598dc7c2f3427c8af3980377f3b274b2567859ac41cb2a11691f5951a5d679b01d34f778703d4505240b920462dd135331be792ebe71ab0b70d0243c823ba62f6ece91df33a6ff008ce2ab7e612cab9cb677c47850822a265a10d783b64d354ce725a3dbd0355d821ae6fcd055e5bc577af22d3690965b3072d0153ecb4d1e2644ffbeb80441edf4c4a33c51a4a62de499c4c0c8e6fc50f8ce8a4a57434515e976383f72cf619e31030a6c647b35b3b58f87900560b762a7224de6fc9458249e30dba55c9b21c3a52ef6b9103e6e545d53dab29f5e5f3bb0be926b965b08c3d1a75f4c348cd6d8f47419fe41fe8b492362b41e1b05d48b239b1b8c5d666ffc4b72b0ff1803debccf6ff21d653267a40a0002b9ffa6e41f062ffd7abed7270081053587ea00dcc054c36fa53235ab618a59f5f4725270c293c40d15c92f978c8b5d64b24f2826f7845beff1ac1bc988ba2197053a7814272dd24dfed8b52e3db3ac991e6c56c9eef19ebab47f8f0de29b3afca1f200b6c3a6575bb4f1b4e9b6a92f62da5dba11f4c3c15237236d8b85ff081a4e3db8f0485508d78a8e2eeb1f295ba156f32bab783d8afa5228f5dc857561bf39f8a0f18f0884f8d4fb341bc13390da0f8e5dc318652a4c5624c96b0a7378c55377ee7f715ae87a54917b2fb21f28805ded6cdef9776a13501cdcf4cb7b6a49cbded0777304e996a6752c1dbc43a5e18798e4865c28cf1073507cd244acd8f94fa6443063b271f0c45a9f9b3a12cda47ef337c14a40c9d4c785c206ac50ea15b39dac34cf3be1faa14577e3c92c7548eac65c246800e9a44f5efb8e8d1eb15adaf7b83a8b70d9ea21cf47394e4b1a0cf1a3781bfd2bc208672e1116b9a276a1ff047925c333e552534e41727c3ea8610531639adb75a11c40b7f2909a9025473112bb4bda4697e54b6a224ae18d72334f53cd3d9d590c65a4d92ff7ffaad79d203bc4821d5f72e38412f6a129818745fd3926ee5ef1d6f824e2bbcd5f9dd313568fcd68f44907e4e45e906eab9c713f76a63238f822741f7a427afa8c09b301fedb375114821775c384eb657844a62566b47d9ecb71d17bdcf99e8d9274625cb70ea555a46e69c5a09fb6c2b5c77c703591e54b965d89a5025d2b4440907903f7407abdccf91214fdad8bb70551bddc92f6c49ef73ee5714996ed28c6caf85b2383533e847ad2194e508647a367227bdacaab5e5e8d06b103f2cc9ada5e5be1450ba1e73a14ee504f31a8cd18a6b3aed440986a8b81295b4eeae6eb1289428560bbc79d77fc1d24616b1ae19da98726d721ef18e3c7c64427c54d007cdde36b7654ec15d5c426c95992b517cdc0c7b58d3007fb36955a95409e9ab573304d7f7f0d5ad23468b4e6dfac07f90e4481701f1093f95dd3bd46ef5a41b2822d534d24f435803f047b29126a5688d8437478daddf0bc8c1149f70d215a85d5f8b2ec92aa5f8856f1eeb76967547e581daa8a86a17bc2cff244cbfcdbbc8bc7299d0001f211be1b2623e4b603afad6fd4d68d0b1a4d0dd8639cff8e50c5e06c0daa0c7a347c939ea70f13403ddbbca559ab56a1dc43f41bb70c0acad731d604f9ef13632bf82cba6d75d9a7473d249203ba496f58aae9f3288802c95bb75da90a7762f374a79836f51485a825c5a464b2aa4eb3b178491104145cd8ab29fd705f365ac12ff31c34a3c84fba3fe51cdcb319d6188daefe3777138ea3c79b41dd7ef6ac4cf18b0b3ed804b062284e46e6db0fee61ddbbbbdb1a060cc50ec782fec0b02eef66543c2d2635db0328d4929593bc640e1778562750328fd741fa98196fbe8d6f68887b2e60529e4cdcffe8f0070d5ea6c1b6a7e1b1788937de303ee126a15d1b15c38b5bcc0388bdaa0a1bd2c30801e8c324b4590c779b9f16ec9c415ed7234897ad62b37322dff74af8c67cd58443c31195b8fe182639c00849ac5029061c394a1830d854da63cd73d1ef6e8e96400ac228777c4c1508136cf35b3ec94895acc9456be7d3995786061d28e8fe3bf26159b56c51409ef663b394cda76ef87be5c9cd30961b75d3c40f580eec8b00a6adf87cea5777ebd8ec7cb8ddff74438d08d74da461f9419f3fb78c259c9aca10e5e0e09de5aa289d652e7b06793657aeadc075686a7ba5fb4edb031286071be76661e1f3f816a6d439f9d3d48fd5f913b692100d56bb5b07eb433b1b883b2de127ab20ca5f2d0f3188596b012f374d426f65471549880853073ff63a613b89b97fc253913f0c4d84b53e364616b76343da9f3ccb9b8bfc2a34365088f68b5e3f77a719d26c8e697167f181e49caac1fde60465a63ff57c66c7bacf118efd972eea36c7a2355fa1242e53413bc5917894fbf88e143410baa100b79b00b955a5d1b6f0529fd48ee008ba653ce3afd1b350df9cab8baa49001fa66c0dc66dc77fd54947ef865683278de5cf3deb6fff1062517c74df87abba93650c9ab9651b285565ccfdefa567c9b46b92626d33850c52012451dfad08e9e292d1450f96540f581d35da8071d501a5ba673d43268726385389dd35d6ce151dc551a2b6b0fef7303bc8ccf706bf7ef03916fad5ccaa322b501db6df331d1cb89ccad332ff61e4b23bf0ee11afb692f08ef5c5723d290ce2a0a70266e716bdab5c5bf95d341c58ed332ac3d7da244d45672bb10bad5ad4d5e95d27f8f00b044cf10fe7811aae6a6f36f5cbafcf0151dc9127d6e03eb7d350c7b7844f4d29f70b29a496621b7c020d2a530b5e2359355f1ecfb05becfa3c22d71cc7eb1280535d4859532efb16844e66f3de57989a8de818ce867cef8385a96f7eb3c58e6b072245201c24b35f1dd3f47d33c8f5c9d9099fca5a91b13d15c83d8ac3d1f73d812dd89b159e9b0e2c7af1bc42c8aed9ecab4ebdd7dd07be2ea0d02e9debb3bda9a02c85101870dc1460e55d856232cfcc88b802b65502b127804e64ef473ff701f0042f38c918dbc1be36e0ab07978e8155b5ec2385d40ab4f41f8229989a3501a024732a9ca9301d3f0501d693a6947561cae5eee1e3797127abffada4922a1771dd5e461943e1fb98cb9367cc123de66a18f6d46dc207f8a0b4fac4bb70cccf62a8037d95f90c888d1be9dc21de23b839230a9ce21fff6fe094567fb725da7f6ab27b0f74225f0a98b6ca5adb1d8f6132be8133ee3ecbd351122fc5a83ba674c687f582d4bd3b2550cfa293fce91e3de0f5b60987d0ca94050574eece4e680e81dc72b403616311fb6353724d7ff3700a82b9864442e9c5a936fd91840f0192e85aeba277fd3ddea4716dae587eae720dbd590c881025fde331466ea585307970cb568619486113389d9085e331ff7c8c86ba584d19d2f40cf2c133532856104920aa10c188597882cdff188de2fc5b4b435b3b5c06d888bd5b5e254e4e2eb4af8355f894f1acd7a583d73047e71d5a35c7bf5d1492a4521926bd42855acf1999531624a50471d3efff72d203ffd1f5dad3fbce0dad9db1e3f828b477109dd967ae202ec2a4862cff88467fd38c72f3e43677255df00c7c1a92e55bf23c8a9951c014362c714522ff8f59eceb9f368039e4c04f1b6a7b00bcb01670ebbaae9174929da484fa7c519fc92509f24cb8131f4f85ac0d9fe655106e5ad4089404451b72e02e91e4457a7747ba5d4f2f586fdf198ba1840382e9b7284b55651f2d58fce75c1ffb90177a69cba27adbd3fcd79d93d0c81a9acb6bba7ad611532514c08019e3b590cb8b13af30cc09a0610e2664a07be49bd77502d478c8574fc268b775f1f57144f08b649b0ddbe6ac07b6b59a8b221afb0535c8bc516071fe7c781847796c737b9df40029c39cf0bf964420566d210d050ca2d7f40978b772a7ab8212179f4f8f5ab723c1027f24c70219da3fbdaa9cff18ef872f291695e132302e043229dda9d49e9e99b33a11469f8b9fc85c4e6b58a812d7ad9e0b53564923ad1d6ee83cef41618d5790c37452cc8cb9b5471ee7e6397c1e8d6ca7838077e69bcfa1efa88b48a7d6c4bfa79f0b1583b28634176d45a318ef09c573b220d23000d4cd60b3290e5f36cccdb508c98fadb06f259d31b45a3a835a3a9e63d6ee34d97da801b4eb34d550fcec8ff40dba16d6bd9a58e4154dd07a512b84427fa9cc28a3e7178fca3d96241f3d958a57ebab8157d9ec95bd5daf4cf702192e6a781c9301c12faec50f311258830f04aa15a4da220fb6d12a3fac19a4a59312e4ebc68c0e4922832c3677c5defb183f08d62f4f06d0ca5383fa7417b2ec90b6e34bfcd548ba8a7819e772b9e856000555bde5ba978d85b8cfeceb1fc9f649b37c32f163ddcc10e2bd72d2e89613e183b5f0088ee441607a25a2abdb3c9b545ab293b3257337336ec3ce5f9f00a93cd91376b3d2366b1fc737078ad48fb16b4a5c1153fd8070072da01df1a11077107467948adf7b0afad9eb3f1bbc67854ed250c615e667f9d4152ce620ff5cb9db27e0ccb1ce900896b1d054a454f668845bcea7fbbc489d6a23f5ce99312ecb57cb361e5d29076dba1139df9905a286cf614168e45d6fbfac84c97050b576cd0dfde8a11ddc5c438cd6c285a5610b59cb60eefc5df621aef0d87af693e958baf2b4925966e53f21a6a31b712604796b0bf9aee1715cb14aeb87f34c1e040bfcbd110f9fee97b4db9e902704e04d3e6d584b1a62f2812969484ea38282b62d5e01e9b31ee6e40ae3c0f6751b49a3acbd8e96df583d31aea96a33705e325ad88bcf2134e4897906ad1c52b4d32079eb1c50ed74fa422af0a4fed929d6cf421c52c900506f478886e30bb811998f008ba107f6e8f8c08a745b5dd48d1e493394388e9b63158946fd89b031c3cdf26138a4465f99ab5b14d73af76eea42071cf4b7fc178bd0e096f35230187813e15b41f41ec4934f182f9099a182a7e8bfa75659d74be20ef2f3f2a5727bb79f4b2a74c1679863e9bcee09e57b415f48493ddd7b19f3b3f80a58435cd27e664f3a428c06e8ad92b3f40ea80c4e5adeeaa32ef2058053f389e45c763c81de66df09ff2b395ae9c5960134207e57a7e6b3ae27a0947f88782311355844fa3c81364707bd116f38d0518bb76a2de284be0a3ca9fbcc21cd7a5311600b5680c9ee5c4d60821aa35c9196bfbda25c99dfc51dde7d80c70c5436dc22994cde0129d0b7add1d36e85dae03f52137f7c9046e6100d52ffcaa600970e49486e0f806635658cd968a159b1698914725daf67b5a9b5c7059cb3906520a739bc5237c6a32dc6e16761f5b279e191279212e5f0de4e3cba7e2c172e596e19dc8b5345b31626d558cadb6427f0705e3d9e9158b61ac56c9def590f8b49d748fd19a75f65112f3c898cb2ff74ca6aecffd9656741bc071efa6cc4f27d3026130947b14ff1a49726037563cf321c4e3932dac15d89d4d6b19defac3dbe5151ae916d2e0818c404eca54e4047ae76aa6d05f1e47b7e7d9d654a58a6d3bd889723b890b2913aaf79db6684e7391d92c2e9483ce8d8b9dc389bdf44f4a55fd221e06ce7282cbf9c587cf2708db92632614738f18deb8f38c64323e6a21c4125c70f8628cbcad67832f976c241817e29db011139ec5daaf9d2c7e356f94574cf3f326ee3ef60803ca9e8da5dd0b95675e5be29b964422381d53656e163988712c81ec9a3e75f8e2c4f53931870050fe71cbe9fca37ba48d45836b9fb5227c0b0c12bc74d45149d232c233b31d6fe4bd95d09c969fd4094c7d84502809172b55579922a4b61e3834e3c748101a30725f83c694b0396bb35b099d344b5130c29ff01922826c0ef888b37b7f8895661f7f15b632e7cac8b772573d0fe2a0ee2af4cbc2442709675f8984d7dbf2ec69e681723a94095c61e3f68ca7e2e5bf2c2e4b279e99d103b6c0e3e00b024aad35cf54ae1fc5b799d1834f49358715793c99496773542c87be41328c023f8e92ecaa33c64a7088906275d553f8ea228633930f2a6437caf0ff5daf1d47c6579c98eea16ea13a3c161ed8e04313d0a6865e6015e4ef4a95abe758e8990c812ead9d5e56c1d903560ee025f9f304432c66ab6d04d7ad3736bd2708caffc1c963006fb8c8bbd8ea3af21eed334394a2e3b35d0c7194d6c78dbef0f2a99068b7a37180308d13fc65e45ffcfff7ee7d8b91b5f4a83a82b565a1767be28af0034c88eaf2276ee2709e6bd3dc8bd9d0c58139ffe20741d804432be529ea1eed982b4efdd5bbb3cc9eb4591b1f152408773082dbe043ffeebe8b4a63f3b72163b53229a45fbb8a847797d88b942f7acb696ef53c1c94e6c67bfc720cfc0767671cb4ed84a05135e4e1a549292b01b701ebb52270f5aafdd262332da1b70030528412bebee09770e6e27092d1bf99f5267430dc3b847df42f53612e1487c04affcd9fc9f9c4ed2dd0ecf1298bd5215d89216eff2502ac6b0659bb79d760603156f693e41f686e0a1cd7d3f7e524c97682676a7cc3ba0c7f4ef67b149283117f4374a83c7c17a18141e9b7e61afc8f186556fdc79654227af7ff9011b801ab63d9acd59a8e31fc7dcb8b4690264800cea2efd653fdc0799c46a4a131e97e909863b2299095dd48230c7231a3dac091bf4e6548e78692b6a63869c4735d43274bc0c4003135b80214d8dcb06cd2aaafd5c135f80d0b45b2fa4c641e54dadcbf973da1ef3a32ffd6492c64968f7259804d5441c57f39d86fa05e7a6b29a7de3ef6ef984ec2d57dacff772b6bc620ceaf4d24cfa39edb0cc3fb9d76d027fa0ca5d2444a5bfd4f5a0309ba7b7951ddf2b2876505531ebd33ef24964c23f63877de538cd18404370473ca9475b13bb68b0dd8258600290a08cfc173dd9e2d13925190ec08a8fc728120534777142f7e111e11aff18c5d9ca481370d636039f07cbd24d868a7d27487349b0b3d8a93a01f6699cf4e52abfcf6a2dcf5bfae66344bcd6782b9dc9ba60dd4c3243ac6badd3a3b76723bf528ce2d37e83fa989229f7aa7646c45da02e22527fe92c963b19ee4a4620433add59976f280906ec8a864943a9ccd4b29135897aafc6fe553e15cf5883ea7b9ec15febf07e9779cc7dcd0f5c5bce53b5389cd53fb77d8c5d5403db2ad4978a76c8877e199fd3aa71e2720714a086727bdaba7ad874ce1deb7352785ed9e1f3e115c7c6e407ce18645781655039022d8c5a0705973c1c7b53093490b2e0b8c00143c95fa9d9f6713cfd8b22acee179ff5944fada8d51b1bb775007b7512c7e86b75df6a754e1967ec463054e1b3b579f98374be188f4e8a2612570355f3a46d6821d28c18b7f013550e074e32f68ba0e42de597c1a846c02e62c5e1d32b1e665b5a367c53b1016c8bbcd78bf8f91b6e01a36ae3de981e6f7bf32d6c040687c543e3de979dfca66f028c859bc3d78f218c4d4fe93f206df7d4e3467a86bbd092bdf863efad29fd84dd6943ec171fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
