<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"11e10e197c2589d735f6e1b23629bc43c53fb87469ca83b8406523400ba4896e6dc0607fd466c288d03f4a514338591ac520cdf4801af7bf13655817d5c8b9be71faf5b2306b3d7d5bc307d209aad8b8587068f22ed0369322644d1cd5b82d2db0fc1362f6ca64a2c4020f3801d85d8449a0e2bb44d38fe385f45627ac6b9f08e48b2f29ce210b94c36c4586fbcdde43b3680e868d538ac2182323e13bae8c54eb6a48a7c408f1e431104705bf73496358f5660590c83e45512007cf335970a5fe03c6007c3484d07485ea31dea0704b096e85f55f1b1b72410ec48291e070a0ea11b73b747ea18247903977dc5aa38460083fa4ffa904fe699c70e72be559d3081db03a51e48628e6a66b7140930532cda1281b65e37beac7804a67659a9e6ac526e934863045e8772947d7782b8c8d9901102839ebf74003b9468c04982c9ab9f6379b42dd4f7107054353f2be9a90cbb16ff61e8356633d695385e70d745e716dd7ad566d10b6db3fb552d5654795da2149ffad4a6c9e9ffb2066af4f86cc534446f94e20dfebfb1ced46b5f59b55756dc97d2d3f9345a9843ce00910f285bca6a7d33117f550d868edd806507c446dc6dccefed2426b7a79a4cb04806753008e0f13ac8ceeaab7cf70b11e3c563d3d5207b17e6f682e75436d2088928c0ba007b33aff74a27543ad80989ed7dad397adf78d95737995089e8d984cce41a37f989c3825607f0980c46d3afe91f81f1dae885938233cb49b815546cd85a424a896b64d87ed9d33766f27d15c0817f15e24443cd8c9c0f1d07ea27b2cc783800a022af1ea34d9f43d500d732968a06f00d9fa022485d1d467540fc045f86a1230fab31df84dca8c4f578079502caa0239d208a57a848f9f0cbe0376537cbf9052b6366a60f56961ad14088e10f4cf04c7a2cfec6e949fc7233f65e5cf07c270f4b743add81c15012018e07f559aae2dfa4f3d6702890a161bbcea97eb9fb4e79edaf3a9b56bc44a1df7b84c25f8bd5f35e4022f38a7b56be132394c9685c20b350339e9f5675cf39e8db2038631a514c3a1e930b7a720458caa44563d0733fa258f0590fa2e4ad6bdf219492b7cf079d664bbc0e86c35c92d6dcae0dcffcc580670a2144eec98afa8a08545e9e9182c41c1f8e8d34ea5b3d13d889195b4c2c82c9ec6492cf091b9493ebfc2a6e81394a089f3630ca35f524bedd75ac4ac77610532dd5af72fb80a94098a68fae1887630a1cbd2380118df029dc2a37e4cb2477e85195f5e5a151663e95eabf17875f6e0ec06f0ade7a460403b777e9e35a127687ccd3f2ac4cfc1c4cf796a7ab9755d2bf3d1f6b1070a40af94c240fe256e38ab85058433285f17245ffbf6d31c3ea2120afe6f9d3662da0e57a091679db3baef62cb97b66cf5d514891222f1006a48bdb5925c5d798f4fe601d6849739d7b577f11d83692365209dc359e328c269bd6b9913c9d1d74d85ef82d38f75908e5aea9a002a78b3cb3bcc05f00789354b2ea737c33557fe37a31db2938d216e719f0b0455fc924d55457d059ee3e170f4795b62f722b1b5c970b687caac47b17844c54a196035495dcbb8bcb02bda804839b313e2084724b50000c83d1183377a4995c5867bafec98d97280a97ef8149eccc3f3f4a8f021b720890ec25e6080ad51c43080bc2029a2b53338e5c88330d4618031e218b3efbdff23707b9261f08aa651c6ad821934d82b001eeba21a7883d0d8354814b784d19277a570335db23135d7ce90aa41f888363750d1068c116ac403fc68e05d7936841f5dc53735b72d0ab686a2dc9bb28252e619da9e350ad25cce6d0f0d61c84ad7acae95182a4085e56ff92521bb031b99d18fcb0f51d28d0e91603b9ca138fbc8e43e2e6f50a57d78dc6faf9f67c120ab7f66fbb3d8f349ffa8cd3dcd659276f2fa53bc044b8550c501e5e7a3aff619601376bb123d9bae4514f986ec997b58c1b3219fefb3bfa3503f833437443eebcd4b64d009e7208c92f612e8674fd782d94903cdb42fb2f83ae9a3fef3c407ece5169fd94a7ef9051a0392aa5f09e6153f2bc41b4478d6cd01d20c221135685ea0b434dcd4d63a28dce915c7ad953f4f33805b3d019e08ca92f2a2a44c74d1a5c05c7df587d576619c5b4ff0270ecb31ae3179be08c83f0b7713b5c76c456da5783c007700281de6021baeeb1fe29ca94f9a45f33e1f932db1fbdd77b2a11e1af763a0dabfa6e443f1a13aa2680b45e4a8ae15e932535403f8d0f0a10cc1d21bd21224e2de8460c4461c53be31d3f08f204ecdf6d27bfe93099130052ff7400ba2bfae769ada1418a43b51df03c7b6c92c93477fe5e501091affb24347f75bdf6cbbe3d837677abc9d480cd80e3ce2b5a882f1d8290a4f5a175870ad2f2681d5a7011299f8a58158978b34388687889932dec7702c9996bebde1abf55b8d0937dd110abc7f500716e8bc7bba25472c0aba7ac0e221a9be84ef46f92f2a8fbe1b8d72655246f72de0481f1370627dd5050118f10e4ad3cffdf976de21ecb0328b13006e81fde86c19479acda913788cb7e0a9c97479a0610d1f5909471997c349f8d96dad8706f68adf89aa58a50a2766ebbf8977e36eadb691848aed9d96ec90e3b81d2fadade14eabc176f97d3e13a09236f519426ee14b9d510970f1cd06b9693b62b21e8d7a4ee2a59920fa06d6628ebb6a292eec2d8440e1afeeacc13930cae3691bd686e6b501532a966c217196208949a1cec2123c179aa1452f5967cb53c8bd945a09c74ab9898726c2f1e1fb8b396e3ae6618e0f09652536b24dc10f07c58ea45c1b446b968cb2012321d9b9201bf333cd89d581b1e89f3e3882dd7f414059f7c114e88bc3e5b33e2d11f2b629fb6f95b6861c8a538ad16ccef5418c1f1eb8f30218aef545a40b6d5afd02aadbf806a2473fad99e60a302dfa0d5ef2d59bda5c33d15c3aeee1b279e787ead104b9ac80f8da0e6e681efad93fdf479ba2519bb20185e1511d1485a133c180dbcf792dde768b6c775e42d89b2735723ad90a0d6777db6c9bddbf6c391fac08c01bf07ff577fa1e15ce0c8ed17e3bd5885993e826a696a2250a6346858dba69ac540833c7b612b4366fbb419b1b59d26584b081fc8ca2fda2db012df8ceade43fb832146ade5e884d5af0b3e04de4658848921f29f88cba2407c52c31f27ce2575a227d09632a19c430bbc0c05c6058458a2c547c190f89bb38144ea52b66d4d27bab7f402e9319452cfdcf9295c5fb8437600eed172b91ccff56acaadadc5841de64f9da3c4cb4330f28f98bd5f214c08e6eeb11966ba5b3bb8af46b16b2fa8af2e27b6ea99c578b74a64316ecb88a0436fcbbce3cc892efcfc5ffe2d8fe2b6057c3bf102eb7e1ed3b3209fc3b4f4832f75731d02decb9a6c09d237df9149134aeb834005b5ea043c699bb3ef8044d437d0bf2f42f779193b9a4b107b9099b63b1bbbc3e0aa8c95f678516df2099a5fb234bda5e668b0ae292dd28624f9d39a7a3b389f01e14769ddf95d6d678ba578d222cd71997362c57b4fe12115c373cd2c577dfb4b3af0dd6402361c9497eb34089f8e023f1f664b1942821fde2ebb46daa5c477f3db2eb24e0b6bc16a18a290a8f43d15eb78d33605389bb15338b906ee513b106ddb73953dd1cc2b8deda3ab7924149babd4838d5336da68e100e9d1a68e2e8a1448a627d2cca3bb8a95813d24aba6c745617c8d5c2fa618f9891c3deca26f3eea3c70b4849c683795234936a20acec482f64cb8fe782df95f232c6dabf4d270a4eb8665e04ca20022124f514f55d5ba793de9977c120c1bd3d9b65315acf155fee01c6a89afc629cccd444397bc8a919ccfdba3ec5c8756fda8617e552a4ef83a2098e86d2dbf4a01e9e5282998a09ddf3c2f063d0fd8ae8be8f18fd79dc40023bede911678e8ace03351e5a14fbe388a31491815d87ee8b3f6157fb9085ca9f84ad9be372c8784c4a1579d586b9bedbce740cb67b91c87343f94f35d2a70780d9ada3d0051cb20f580cf2e6ecb69eb3096c973d9c2915533e789676f89cf9ac58949e6b518bd20b90449565f18043b6c20d165fc63a97dc1eae59e4762808a48609d72ed9f97b945c34b6bc0be7ef6b2bdfe7bc86239beac81b0c150c6f227146a945bcca74dd8b3d0268fd48312bd9fc08b823b70bc764c41a8f3dbc2ee7b800b9d906740cab2426497422b94c71c9f4d46f5c8575221ebcd74e1a91e72d7015fde49e7149c270bd016e562f1483f8bb1f27d7d42591980ecf2b0525115d1950750018fb1a109767c19cac5cc9f37c24b5a800c29d7af4e1521081d681e97b9b935cefe5e846cb577d601a81690e6fbb776e88e79346efbf7fa53d045cd865df471fd996ccc23ae7656f4190d1d0df8a37a79670e417cabc26238f5ebdd60474f25d43af8e22ba35df848d6a5ce1bfece58c5f6424835bec8829cc9724d88f5d47f5d2f75793373ddb31f8ed533b458cbede5ff8e947a13737f6247fcbbba22c94c4b8e39d50c9871a162ce3363bfafa6035d39af53702674de861a5f78cc9251c8398744d830140616c9c4d45672ac32ddd545978483ce6b125d34aac4491a59b1349958fecf4cf0ad08ad363bda70fc8a992d07a4214404f32ff189165859faa3b29735f3d9e8ef92d7b4fca8fa879d2a3374dee0afcaf00a3f104395bbe31c25db51e67756d5677a71335ddec28bf837e4a9e723b97d04a51dc6502f50c7c4729a7cd8e05f16e12a39687192b735a04a18be47a3cccb3c563bbb72c18ac2e65b5d1122d53f3507d7174d1e55d50acfabc95525eeb4c6b701b69e477cac99bb19dd01ad0962eb1defec4a73e093eff7fbce39dc0b0b280a42cc48736aadc5a00fb9190763a7483849e8fdcc1bb5adbfe454800bcdb4319fa7c9d1389692c32064db86ffeb4b107da93310c6e0d03df977088b6d9304a3bd2d64da110e1d21101dfe3085bae1af919f258b25b5bfe4b5abf912d5452d7728c41d41b7f0d06db5ead8f439789f484ec56424ab64c60dc9b2ce479bbc7c1219f56a0973e35c39121d51685c2f3a09a21cb92b22e214e66f1dbe8f136d578f87964b4887aa3a5d248a3f058450fe89749a033bb987e8b49c5b7b94fcb43c068636d152f7c43720a5f0e9cb0f2efbb046ed55379875fd1e873db65cdd7f91b5f344d9ce74bfff7fc78cc643faa7eff156616ef91c7f6ca9043f332ecb02492baa8e516d0d7649903fe096d67bd8447e860d36a97e15bc514033b8f7e7608c9b78cd6cb05f4300a7dd23726740c644be6031ab30f63af6811ae4361cd0baeb629567226fb14a0292d35e22f830309e1e36d370590c3337a33214264b2fb27db55e709b627909103c697f093047145aa73cc3e8b7ea3632d83298b403d8b43bce2bf0858ea3b20141639ee8628d0b155309718c49c18f489e2bf27f3321d9559d62bbdaa72ffe56f10c10d23bd9b113a184640fdf935b11077fb7d1db529896cb97fcf75739642267e6fe38c2313b0d3898826770e2ec1bcef1201d788952d4d8f3498d6e5bc1cfd5e265c83ed95c13a8ba7769df8b198f81d970d17e7da55731c32febd644146596988276387511823ef98f4134b8714ae441d2594c5c9054fd52348a6d492f7bd77193a3b6725420e3845dd158e5901ad56811f24976a0ad4c027d4ac48d12b3067faafd966a128b75641fdc22374bd8137997777edb2e4228b00c43cb0d3a2d2021c90e6945ac325970b26fdedac733005eff8d37a84965c9cca2e7c843ca9294fabfd62b3cddcd8ee7c9ee48e645bc54cb398dc7f812ecf8be9e43e59918b1504094a0beb8554d4ae17c6dc9e4db976b085156df3be25673de86b6453a0821a1ea36f3e873c4a0158e24421444bb100864aea327abd1cfb7d1d25dbbb40ece25afe79e65023bf477239f4d4b2bff52e721f8487e99f1dacc5b62f50cab70ddb369f814fabdad4f97874bc4b21a952fe90e97c0eb5ad5a5297b79b4562a1a2f6ab723ac90b18d6c97b3d23db59b15afe499cbb12dccfe5f16c002a5d03d70d57a5ddf1a023b3fad8838215044b509303e3d3aa3541b117bcfda19f291dd657b251dd44075d64accdbe4c1f20b271c0b9cd8eef8dc20cd30cc117de577119f214eeef039e453c51ee45b85090374de72b9a78f0cea66f060af04ba012b6d3174728bd7cc03e3cbb18a53ffd7c9913bd8198dcd2207003d30757da0418974f84eeaf1abc44a07bf742a52eb3121b5d65889166098fa6bf63023b12ab5f22638d3d85332439bec69c217c3e929b7899803bf88b70d9d0e2449f9605bc73f4d8974941600c45f8e674af326a5f54f38fdbd919ab4a75925c1ce0743be509445ef4add867a7f3d23dd01d2c88f16f6f98fde8bf47999c9e040ad251291d8c2502d526f4cf13a80dcd9c8d5f68bf87bf08d2c368f0d3b47b2eac47ad95d0d710e1a25c545cb67dc1e3fce12f10b9fcc09c04630ec058ecb033daddb1aae6c7cdc74e4ca8c9d1584ddde490c427f5568b25075581c2c0ed24be07450dcc293cb4c1858fc0e21cf04ecf37e7125a24c2e367e1fc0a3d1b2ea5408250ff215e5ab8e9120b96dfacb97b241ad1cb20a73d28512e7e233e28a6d67ed1290b74c09d787127b9bcb0b8dbcf46493a36205405e69572a62e5cd0e49890629f68c741b2c98aa9c15d6f3fcbef25766c7aa457c3f8a975bdd4ea5e15b5d7dd27a5858be7b5c9cb482e0a4fc37f51404c9b5c1f7f1f34f9ae24c5f49198d13af2b468885d104478419a368ff7fdb480033527ae0b5dac9bf73729adec737d41a7edff7ba18152c083d8efd49663c57fd6b69fc0ac0090649d8095411040c538e0aa0be64f225d9308e9eb4b5413f710ddec5810c15774331a59408ab5523778192b9e26f5ab4c372ff17e116f91ec616db5aaed5c16a63a475ae40b3659ce82497e9d492a225ae9e34f77403dfaeb4cb8a03c876a18e448a3d74d9eed70b9153cfb47fc62d752a94a995f9419d1a747c637b1ca846837eb3a08fc99965f1570997fe41f0b4b79dd489f7c7dbff415a60f20024dd67093225406a8ef02e45b90b4072641963175db02c287ae3468212960a494599387410326d820e7678c42ca25d6b20c39fe1c4d9a08c9654ed93b5b8c193b2611d2e3d14f254d1db108e683f0b0bb583155d1cc268e53c5cdfdec8a9cf6a49cb49edc2e28422032460c7a77e884510ac15055388c1416a1de8b79790ae9d2fcf1ca1ad04d4c70ddc7133f3e4dae577a4e069a7e0222ecb450c2238c508f3e0ff15855ae06e1af61d903e67771ecf1c53793a3896e7e841f5e7e20cd58be9535fffad172f5e7aeb68767b08dd84ab263d15485e2ff9a573f69fe72befc931815c515e65b03de5c7cfb5c7d0295efaf96b47105ce9796693e7c766b7941d9594843ca8b980d671a4d63013858808a470a1a87331a4b39d4b585c1dbfaa38a8d2a2eeba257aaa80d6ae182cd7a7338e0d9437c6438b7518dbd91546aea6c544cfa101b40147bbf18b6bf9d32a518fc02828e5471965e2e93292eb10f8155b208312c32b357f9f14f1b72b0779e27cf3d8c151899ab4335d9d8672402504456cad06880a02a75d131bc2df727c0e5b22b74418857135f5079dec5f1a14b7c3ba6d21437b96787106af5c239743d598988911187fbe4c493ede2192ac061e8f4382c5262d929aa55f8d6a678000420d42364c5e0daaf8e17d2c928309f028c620f1aa1592f59c9204557a3c80810b1e8fababea1fcb990207e17c9b653af1dd2e68b211f10d19560062aebb759dc85aa04a88c6c780c5046efd1d401c3433d05f2375a754f9ef49e60caf211e4929ca57c6647005c76967004d1d22de7df4e70ff80d9b53064e8050aefcb4b2500e3a1dd799c377a41d117ee8462602b2e8ff24b8c5e89864bd7fa2551393e53c2ca91e23ed45efe11b5ce27b2252b5817ddb6f057ef13afcd669b34a1bd936a7a25cf4c8cfcbea1034dd8dbf1a0e7dee457cfd3b2614e10c880a81239ae891a63a9874d6a686af9be0a2e53ec3a17e4688d08a6a0707abb75ed714075e12d67c85233c99d767ef53328f4e8251e2a3075cc2a7b067ab2fc16ca187fe98a17cbfb0887fc221e5f7940d491a76bea0d1f84c75e7118586aa837e348889d0f7e0184939466a9f5c70033174f5c7c5bd9937a8972878fb9427df7b23e9e313705b1421b13f7be125d04706a5c8127e4a26fad051b4e0ab3b548cbc84cb50593e34b32d42a00aa5a8441bbf8779bf31c355fb89dbc1be00f364b0c86300c8e3d811e3aa1de76e437217cad94a6d979e929f30645a90c1b9bb101343618efacb01cccb5cc561c9d7ce4661cb1ff18cda649223f39fc102419c2453a57b060a99011985816853275bbfffa6f55fb149fa49bf2baac600c7d74b81b977b02dc0b953ea5ed732a1bd52102ea7933d9205814cf734f8765d6337f0993704c0f91ec8f2dcd54115fb8464fc6dfceb82a9466d497bfa9cbacf7493e1bfb10e7ac0e363966a31b014f920196aadd94b9494f3c60059be0db5aa78e6ed8831ae7eabf18c45ddcab924a06667258cc3e23d4baf02be5846131647bd9d581db65c6a0e10aa129ce47bc1b03746e6179bc94021b33905fcb81b3c55495ed420da005e18fc5a32085284fce579ba331ee91c33a1ca829999ee8d3f6d438c9e75747579687127fec10b9377fae985b94da84e8cbf6d7c50d51f08c8a9556a6e7d097ab2112cf0b35f0fd47b8e2807d56965db29acf3792f2cf8c1383003daffd90348d54cec5448a9f4381da95eb3eceb6277b58db62002114b858b414c563d61852d1a9d6a0f5cfcbe31600ca6f599b770d508138cf074a1a6dc55c2e65299a903b408332d23cd2b698c0b045e60558272df7acbe9bdb8add577c653b264b5e8d7ff9de49a4c78178080e926482dc6fbb10beae84fc180c347ce2ef623901bbf06a2749699f0d75cb6097e6f6fc0a98ed2c410d2cb889ec80dd8031867106f8244c3f625fdcd7bfccfa971596ed53dd32ebe50a1b31821c50fdc323d232a0c7986a93a27d8aeb497aedc84dc5753228ebba5fd0dadc7e670c2f8389745e25c17d8662ce86b63bd009cd07ed7ef99cd0046543af3625e99d00c99b666e3164e295cab11740229f22f3ef0ec66f4a1f72b5ed691d3f133e34fb318abd16ce49184ee0f88ae49146445bdf18eb33dd0f65a1067fce635831fd110408669467ef33b911287dff8b03ccba7d644b7616d44b66f6f03e0e839e4f2795efc30ccf824c9022b976955724aebc8dccd9c8612a3877ad297ecfa15a4d5886fcec34d5f5f955df121745263e078990b6d5b2ac4003306e9ae9a68a4000f4a5c80d99aa749495190cc60b8436c1ddb134165e7135ab3387975bddf6771ae90a37528cfd3ccb8a1435a0165d56cb0d073d78cd8b60829cd83ea28a258a3851ac21cdc22a9415c2e0e09f5ba8f3817e51358ce8a69baa0af4a5e60ec5b43c9efa439f3926e982aaebe5ab59b82dd040f022a9ca93d73f3e6cf694eb82af9200c0c992eecb0cbd2356bdcf3f52b0ad622bde2dfccfa10214a2b63b6a61d194dbcb73922ef38f4393e49c3526e129f8066d872d91238b396d2b5867610bfd1b81581327b241cec089e75c9546bca1032adb23ce0bf41bfaa274e9c5fca21d31f384d653b1567631217431a1bbaa513bc4b64501ea97c959b1f7502c361c55f7e8e8b5f276881737e1b81a33c41a1cfc58574fac06049cf0552a398b99e71262676b16a6572ead5abaa806f3034ea67178cbc4d720fbb2ee468298ad92658a42a45a47c8f8ba63cf1f59f6b200d292dc61be170fe7189ebdfe9d43a7aed3c51bbd024346c02ad87b293d17d433aed73580ee8b0fae6647de5569c1b207d8bc98e071a41dc78b328a510c9d409d16b0971c50c287f49f7ea943e1fb1467f57883542cf032717a0c1fef6c228a96e6f5718ca99aab54bd18c8f0e16e2ff232c0149c4dfa15f55ddde52ebfcc9ce91acad61ecc45e67a78a37b24c44867d0ff63c6be0b8256c1ffc2e367b422946cbfcaf4d7d43e3cfb092a875a51fa3d6de0d62393c0007cffd6a3aa7b51e85293a7ac03d6fb717d3527b41ba1b728af08d9582ed8e8ee4f32fb4b24774f40d7faeadb1756293057a29bf5df75455ea1b244c6b25144076603a445a5561877c2fa0f0186de2d7325407934f996d6d720edb512bfb6fec4ab7f97d02c222e14edbcc4befc1d62404ebd3faffc22f7f01da40faa763a06a77778d370ef14a309208efb52f3f6745a5f614b00038108c868215225da79b00b6301b2a14d075117e8514cb527152499badb5b5b12863858f2d1b9449788f5d6d929fac7acfccab5c02976523dd03cb30c70a055988df08d9ff3a802abaf577d93574b0516549b7d7c253cad05d26be7cb43913b30096f85f567bd5d1fddc7cd3e4f9a949b491743b17344590b2ee7d733a24e51279f9d96179baef0d7dd4611fe5f41043fc2ce3f988b7da465a32c267fab79d50f0bb3080acd547d1bccc1e97c0b02eacefa92e177ba9e7e124ffdbb5f717bb0f157768ff8ca16993be4ccc2c2c78a1a4796660091b4ee40a87a9f04ce80e000afe0c578b4080228c820643f9457bb251dfe1e6c638312e3d7208f8e702ec53296790e85faa2d595337781cdf5f27753797a9ed346f0c4ecf8c93479520b1e1d0b4e92dde1bdb35fb56d4f219c315264e13bcc9590f8fc0e85fea3bbd68dacc98393b03c203ac153574fe48bfef14313133ea10148246e2c8fbc289f4a59a2ce67e7fb51b447777cdc56d1017bbd78dfcdfc2fcaa3980fdae04eff9a75ed3e4a7143a615a835d47ade4a427c85bd38ad0092cf5abf46a1e0e4377719a0e80f8a3f8b7a31dcee0750c263f74dc042f3291b7db92f554fab997577b20896c248d56f164dc8e1ab148a898b68d30725768155772951505e98cd4b60cfa144683a70595ab66d39f6200fdcacb52c9a1017361265f49870d0ea8506a2d9fceebcdd445772c4a669045a0773cb8a22c0de3987f3b0addd348fef2114e9ec6d462ef865d783d2915d9d13bb6273b64cac50da5e102a933417794552aa30f89b5989a2119dc8658a04c67ea5643c665863456ca111524ab366733ee2014be01a0872bcf6371657845db754b413ae6316b4a941f8f40b24ae3eba472c3ecefd41178fab7b3ea0f9d398238ec653c3a9b5b3395f01e429df62bd5b1e405db38a795a2ef66510b270fb79c3bb50514c80b48e0e68da6b90e2aa3af072686ba4500ef6cb24dec9ca0cff8223f15fe22790e53d9fe66ad906bf28f4a0274a88557516dfaa53dd5c0baeacb314ae1924b30f3fa75e5a469a857eb1ff0c343c093e7f9e746ba7008e7e41532455b956ea118f0a2984b098223faaab3ff63fbaa3e30f94c580803a96b847b1616e85c8855b50b0674da5129a923ed169cb2898441bbe7a56298f79a1432445641706784b789a5c5bf16c8ffba6b32c92f8613fa8224b31601151c7e6c48b8c0ae4f2277aa37c7e8067303645fbd5f30eecffa761e90d71e2423a808e5849bf5f6e9a74bc6448767189b8c65b71781f45824121287555be40dfacc820e2f9ed1657f74c1422a9f8dd029504b8fa1ccec44f09bd78160e0661639cf914281cbdf81c8c3f4c66d4fcf0ae377718c86e21bf0fcb57620abde1dd723543fea4e1d4886c17a297da038a108682ab1b8aee56fe9c330f2d79066b78c65b0af2edff109b71064a5aea57bf0ee7b69d424ca9ab42848620ebd2e6595a4c0042067d269c5860d078554d5d10bbf8bb06a7cecdb39a78baa5b4cfc6c48941d164223f81ed7a6ab76d46e88a7bb67d7e1275194cfa825328aa0898426217e899cee6119d38903a98c371855a68bfde438dcd57f06a59faff9e62c60cd483183f2993b2c09b00443ea6ca4acb99f1e96a0b62b58e60dc44ecdf93b15e6a0a3944ddd6b7a739bc45a47677c3b894873848f9fa0f4f2e71f1f44f4d7e746c3541c07e487af551caec19c3f777ba7d89ab270472f2792520b96a3f14760af06719ef273e50c46e0db76eede6d1a04a3ca9873d28a8d1fae5537b732581e859d725a61246afbc5f69aef812d4862a6b944f6eeec8e5fb42de54baee439aee7cb9cd50c3689e2f4fde20f435c3f55f94c80fd2756ecef6f24c7fc9aa64a9c6c97cc493206a18930bf234a27148fb955f2a724c59d3e64c2bc5c831a4913030001eee2fb91059474125b74517814ad690d3b85e50e549ac17cde51b1302a867875071d36bba99c7bd56cd5c029ea0030105f301bd31d303fec569409ffe31cdc2b3dc532940afd70ece772441473f82437358d50b14a2f68776b0c9b5f485c225bab003568817ed04ab3713bad33f518e8c4b03c949cf503c2e72a4c8e2bb3683014bceaa64465192149e0e5339a0809f385da82bdc5f24a269be37045af1c1ab8a35c17bf8998544418f48890aff24d5530a6ff1e8c24c9a833659039e8cc8d8668860c21693344016654c496508d1b06f69386883d0e1ca1d4c56cba5ba6904946ab1d22f811bd524537e20e6eb92c76296ef922b02f0f1cd915cfacaf843d11e3c6c1abc58da33dcbce3560b8c558a41e4f35592bb34c022f96e4600a04664d7ec3c5df8dad2a125cbe513a4e31a55b2d2d189a7479fb31d92996af66059cb3c7ba044d8f9544830a65e73f574e08566b9dbdd525ae57b045413c5354cefc0a4bb039d80eac7e2dcfe8baecc93ac10168470d50f22b03e321bef710aa5c5b060fa3fdb0d0549f909ff1acd4893225472d1acf405af946046bcb246497a4dabe827f26c9d290b465699ac7d63e19fc9035bce893447f063b09f446c4f97cfbb04377c86f9c4251d4033c62acc944a4a8300396c9eb58ba15bb2261c7595a31fff84567c4f5361a3f0cf8459599eae0f89fedb665156b1cb841392f9d227676625806e92f8623b0783ed336e6572eb7373cb2aaef309e2f665b95a5bfb23dc7fbe5033eb86cbb8cf38d32783d0ef422132ba0b21689df042bec044194eb33ce88c98da45081540f3182a3f89b7bfac298001427f60e98a227aa75f1d43373cce782e1fe85b0a18399f0bb8eb2d8536b2ed2e120889d1c1930f76d522d1901b4e4b9527cfa082d05ead367813b84a0f6d3f1a9af7809eda5602664b1d925dd0de566677cb7cb7e95669c79cb6e0a547b9ba398c8ede4c940237f1e61423aad38534759bf9987d1902b4f8607efe703051522edbb344a09db91aad1863cccb60c0aa936ec62cb9b452a7065d65d37ab3e004c3269003c10155a21619acb38823621ceb43cefbe2223e264e4536dc2ebfe4f5e9397911b8b6f410a997c172dd643b0bf4c4bdd2f45416cbe7a920811c74c47be102ce0be2742313b5d0d266b2e9a528cbfe660f6a03ff9812e85be7bb02092da4fe531c3e495662be917af3cbc8f915545589e5b7a266962c9d0c59967115592f1a3e88dd771b584fa9aaefdaf4c2189b566fd097bdc7584c2703ecc64739e1b9f2e0d7823353272c5c24f0122beae2067d867d45d826d632d55524e375342c61ac023ecb01e3512edc67fa2058aaeb7c0d13a9bdd227ec76338796c1d351602cf779e35fd7821fba212db67cc510f8109adf765d802297afe8478e69960b76b3059df5e31ccac54658326160de9e04286af7ad0311e298812167a929005ce915a77065f14d2922f2f1de17f18a2328186af8b8d90e337afb200d2eab3299963b4a2fb2cc5997efe816177b1bf57f6f5a96bcebdcbc7758b7df7de40c27dcada4fa77c98a85f7587ee85ce0646b0a307d6560f2d5b3d7f66427e5b0fee3e8aaf9210cf262d3685b64a80765b0171d7ca331050a284b6a4bb9c72b8e4bc942628ca8d97bc9d052875d22756e29577fd4a5ea73a89318d3564adc54c78a626c0e8d39cd2a585bf5da7c259e6666c0a57bde3929acd3370baf8b04fae1f3d0af737b0321dbecb61ed16c378d56730da382d049e4d71b2330c8013f629d20ff693ac8e447d49e29673ca222ca00923bc1154bc19dc3555675d4c8d442d3f2c158cb655143bca7ad66602d4404c5abbbd6d5f9f10656e61a1da5ead85dcf1441a79b2c2259788df2ee779f73ac4c93132e354e3a2c687393f4552e92097b0a0c20d3838d3dab065880d97e7d3f52d7db8912df2e31ad12da6650d94d3f999e9edcb9b24996ba4b552d8231befdb189cbbb748b022973599e2006232edc7fbd26f521ac2b5e1bb8c27b53c7c41356d371adb7548c30264464d128568a3da16caacd68f4ff7c3e1485c3b3932a61071f6a68dd7663b8c0fbb27a1c9644a9ba8e3ac0843ee34497e1702fbb8f1f8c03a746bd5cb0cd4cf80e756890fdcf7c1df88598663866668801e36c9282d4e030d4c5a321a61759d3b28f9761c96a470309af15f90cb64b072ffe390702b92e15f55faff4b67a3bd957819a665e15b25668e50257430f1b6ef749b49b0fc24b6c8641f3feb872ae9a0884aa14e8e9d4a222803db52ecbbc9d6ee3ec5faa31efbf47fed05e139e0e08cdd2064aec732b32f7c6730804b14420d91cc02c3581562ad7911db62738813c14c1990db9d1e6677f1735cde235b76fe1582a8c5cb5eff4a7c5c8a28b98507ddfd55b4ed6b07ae3e69367ed4784a29dc3030349eed7129515f8782d549ec81ebd83e75a30559f3c754385299887e1caab9235cb83f6b815129cc6b6ef9ad0cf682bec6fdd5ebcd6dcc559487ef4d30e1969963752c3c5aa6a61807e7e953ca94167620a30b0606f5044bc39453b52dee76d614f42b4808f41f3d8c74117ec868780bd6419d95acc8b2cd2bec7a19fcf0b56603e9b950308bba285c1d260964fc564cf621dae3e45233a094f6c1af2d9fb57ba20e7dde4337a198dda533370adae1e782a18d0871f0ffaced9b594675e0c8d12d945c7e508c016c61ef23472771946834ae28e7347dec2bf369131d2db6074195788f96b9ceded68644c38d118187621cadec07fe7a5edf176a21cda9df04fd8ed7295a8fedb262338c16358f00e74fd09d9ef57566736a5da8c45566b44b2d9d9d25656ca63ab623bdb571eab4aa706f6a3c15617087cfaaee9f6a137e685f68fe367fbb18e2e8b89f7b40dc7be851dc58523e05032b97eebe74a1e74f3462860974bf277c9036b0e4c9e2859ded0e64de504e5df1634551f6f62b465276942aef970699d9dfe6c5ffdaa18435effbd935d744f2dd4289699eff453acd46acc7d9966b3f76f74681e045ad3410638f5f6f344935fba709db5049e6ab247415f5bf874789cd3cf62dd60591e8eb4a115f3d214e2c50722a1ec89ce72dfeb3c5d92dbe6fdc937adbff6cfe8f8b97b9aad4aa7f3215da19cbff04fcc64472dc231f6065718ee662627a7c34310922a17aba2fdb01e70b570fba1bf42d9b53d3e531452ec7f3f1f5940af29577b1490e43ec64c0f4746e12cf54a01fa624d080a560c0c9e251f9102d1fc4ebd0da3afcf9f5be8de79bad64a03a48d369ad4cf0abff9deb69b9d4c9ea110a6099cd2979ea927d9d521061811ee0ae21f82f3163ca5cfe541d8c5cf17c7af667dbeec786eaa3bb1342190af9cedc4d297e2b3587eeb45f654a7e07f69c19f713bff3037a5a0f22fb340c651ab5c480d105a3e78e53ed975ac7835c2ca536a2132633cf1cda700bb0208c04e06b93e881bdae090e47c29c5b2c718065ab9881d3e1651b8e1faaaf878909320500d316c47a0775444ba171aae2002a6e55ffbcbe5ceb5891b020c6a5d40d75f072e2e9617701a4358c70f1f6c5d702aa2d4b8d2c19c8cd56b1acd0e2046d2e230787a95878d2fbc8e06bde612dc7a82c4d93c7d3de236ea3fb655542343e046ae0c0f0143602303b6bb28a3afb6c099f295c4f781062955dabeb577b177d50bf0201b9e731b25bc4be2af658698d6b2b6ea2fa03c6a2125f2217f9592dcb0eef49be86416092d2b22cbcba248ba27988ec367e1db77605aadaecda1285573602a51deb04cedb618face3f30d1a39de71fb8006074c0cb17740ac1a12ec61990e580c31456c75bb9531ac28c5ec0eb9499ffcd9d498531a43942681c19b087439231d1e15dfda77c149ce8dfcbe39dca02d21ff126308d8e058f70114516b160921016bdc374204dac8076f871772524161d823f898006ad4354279190ec01b037cdc476ecfb6a940f0db21d82f75a2a1868cd920142b3dab159796b8d725687e73fac8a823b5ea1fb2c744dc9170dfc2c4a927a98957ac9bf26aa798ba973259fe9ff5ef1f18b42142acf9e0db62a9096ed548b7e983bf35e270971845b1db6bfa8661c3ea5a60b243a1afbfb5f8577c0781d69fc3c8c9705cfbae08ea70ce94985694c3666f818e2c7da30a000cdc97ea5cafb284c6ae12228100e3fe52e40b02850898a9b1a156cbcaa5c9f2f34a3ce058df005f823f96926f2e1b00f3bd907cfb4a4ff48c9e826ed908bb9a7e4460df2e8ce308cc255bb97d51e249473fd842e4316d8e189da69b44ee0acb0435b8d30d260d3500d90817a71a9c0c64ce77f04b2f6a1c8433d97edbd1f7153e3698b874b6cdd384efb807bea5eca032469106ffeb77e90b4ba37f0986860ab5f86b8acb50df5973abc6f2fc099b4487e49db617fe1058e1a001c96cff56fbff27327adccb5ed87e7fad019bf0ebdcd72d4f9fbf8d3cda6352c82787a72c4828ae432e1ce6369141e256774bef43e64be0c9737a3d58ff926cf35630396604461978ad7149473a4bec54c1fd18fece397b2ad0b926b4178ac9da33fcd01089fad11dd38a893771c546dd5547e42381a5ce42252d764026abf6621f438b2c4cf1fe87fdc9b2497b2cb56cc124efe5450e9aa32530d0cd67e3332ddbb7c4538fa4c68a0d61824ef2a466b20f276361263b6f657b8ef008fa251c1b9dd626757a06e1eecc1b4d66e966f07067dc7aa2659a7a078a0ad2c6ef7e0c7c96e4e99d76e02069f2257f763b03434a49cef0f047a4bffbd1ed696c095c1ab7a4c9e2008e95616e1e0cd367df2b68f4cce922b9f3e31dc3c9256a16da70899ecc3efce908a9b2dd3b4eae0b4ff6fad353a85901e42b5f7c137f2b132c536d5056b4889e9712e9d1416e2808ac18c3f906709ae397ec590537679e22aa18115981366fc1346a3c80d09e62e51791ad848932bc877dc3bd560573e099a8113398fdd03d0bd9328a75011c578f6e5d59208029fa0437fd2cd526a108c067daadadaf98c4cbbba5f056c7762a8b70c921f29d446b512ad540bcdbc1f0a8a0630c2650167995afb65d6875d1935107dd5298e5c3450f680a72349a04dabbab7a461c2ddbb5138e04773128ceb07bdc4a4942b61c777583bd1453b102cd7fdda8f9b20f3e405be607c64ea674a3f8f432be10f86d85afd510c9f82d299e4152d89c23337234bcb63f5622b2518520f85b8c2d71513fdfe0cf2e02756f7fd796d276b9150447a637f14dad892f3883203c7ba50fb97bf8af21d910d20a03beafe02d41d641ba289a5e6c69bec7a3e18a135deecae23b93321addcab4703f8a6da0425478ff8f6476f6cae9c8b9fc4edc2fe3919c3d0dcd3c3a24df408d243208ea2e8ac879b13af2a96a5daba8ee00746796c40fa84c290128aa80606cca354cb562542813d2e720c7bf8e408d085acc29952c341c799fca4ad895fbc025fa60c1077587c434a9fa3cc683a580e2b009427088ffba2c5d0104a0e52147e25b3ad35e5de6792735488debf5dca5abf1c310e7aaf95c7497300d320dae1687b59c07e238bda347a1db7e6d34fe4bf7413e25ffc369ba5f9710963dcd860f6768a080f493e9ae147595d068555539183393e8d43685ca3b7cd0e2221faa34ddcc3de121745c80d90993c874b3e31e2d5bfd92fdd5b39207321450bba1740d921fc4d9f2eae7426f114a8a5ee276b39458d4862b4896c49f85ffbfa750ebc663072b55440eda695067d14717848a5d26c2fbdb08c582e464ee4203d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
