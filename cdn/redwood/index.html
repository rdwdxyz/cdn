<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"17dd83fdba0da6883d833b68a78dd24254abeb676ec920420bf367df371f682838ae2cd22bb8eac69c852fe436eac5189a546ecac9aa521ec7c0a98d40c11811b8c6314e0ff9cec42d0655ef65ea3375d0602e0a1c7b4fbc3c5f98d9b3df77455d48ff5f01f38d9b2193c29c065638711ad756b2a0a300f04ff528ee26563f8350fb0b7c6d66969f6f0a91b122ff1abe99a80c4336e85226dff7a03eeac452d73becb181f7788455b58195ffefb0c495c7c28a0cc875910c87e2397cb563bbb4a5f075c9af303d28fb38d7ec9d118aa4cbc63742fdd266b46874190d0bfaf6496cf791ad98ad70eb322db0658a5dbf17a44bcdb933c890f0b4cc2586f0285f5597ae5a76f52b9cb8e0c0a64b5d52b4ec40b94e2694cfa71ff39aca10ffc7a4c6594caa10e5dd0f9824d4cc38fb3af09fd9b1766c3828e020d5db7cec2b8d97706aaefec658562191ec68129df477130850b23a3d746dfcdc185d35204972e4a704285a8f8bf792b4fd5891dd4a04610e567a5297dc8aae58e2abe6ac9825db5798ffcbc92bde1a238b011c835d83cd7ced24f77aa5147dd3b732a533741b6b413537f2153bb4d922fe6f4190567c9e1310154bdc8613673d5f0627f595177f1513f93bf6c776fd4a71e32d9afa5e2a0247f7f1f681068f24b433fcf2423f6531dbe141ae55223dae3e4ce1287cfe3f3a310994ce9383a30e5075ab3b07b16e57a5789a67d85e377e72e5b646935dbad20776dea97db07904486e834c0cf6902ef90ae18a0db9406f7f19c1c673f1e9d377ab35b2cc3ad1492f773fe14625189cc071a01a8e09dbf18139c7c20b1cbf935ddcea74ae02d440536f2c5c2402d72c8f4a8b8befb317ce6793bc7ddc9694bb787873445734dfc9a29c3d7bc065aeed63c3f962eb1126b3c9c7b4886c14499080511c5c399c146d96e14c1051967520c1686f66b4f445f52f8fc51e445fba2cc59a9654fb8756c6f3ee58ea992a2a58398372047f807447d75781b3c41ce7dd4b94cf1c4a03b7a7ff0a55d8137bafa1782f58f230edb7f5e880ea75a0ae7ada922535f8f4e23467598a2500dfc62ac6b2aa7b473e2fe3f4d221e07fbf75106b30c2f1be9f45642702fa68ec41004f4b079a645a92614fa686c73314b7472561ecdc3f44716a1291f6f6d5f01c7c5290a3b83b7cd1087efb0b11f111569cecaea46b9e0d5c9a8572022981e976d2c5a2f1477a3e3ea0f6eefd40ed79de363965d2874f9123e2ea5d45e5cf5ed660f537c0277fa3a7745d7ab0862ce07ba544cefa6f307b8ab265bc7be66a0394857d44e5336e15a5b8e75072665b8cc8dc5386d08484d0156a397b7b457437fdaa257f46658cc6858d759353aa28ba60a757d3812deb75afcef7aa9761b04452524b1a5aa77b27fef317470b27b03184039d471dbc48d876a2cb0c24f974683d4f5fa86cf1d2b01a3df09a586d6bd196224f9b2c1be44ccbccf9948907a9e4452330cadb5ef9116adbc1444d848587ee23c9304264a7a7f8da8e575a2781aab38813f6d4dc1e0dd038a43a9ab74e28079e0c1f73fbebbad0220a62fcf80471d2dc0ce61f21b7ca1ae80a7bf5816d456ae013cd7cd5efbc91d46a0edc2953a3db24426c5f75f8feec63eefbda8426d3c9748196f21d27f456f7cab70af4b257d472c057ddb357d814ad8d4619aa828b986e7f923467374f7bbd2541aac96ab849168aa6507e955d1994df9da5575f60e457c5f42c16a29be91715a7119190434f238415beb0913c4c3366ba3e042f12e7b5f383f4e5089d68d59625799b261a2b18dd9b5f23d1e0e72abd23562ded78eb02687d245d8f1c1c4af488675603a561a99a5ee79b3543a4529fcd21b5172ae255f151ffade1a9b73e20798c5b22c1ca72fe7d58b7ac420996ad9653c0790bc78b2f5fd0c06a69d68f8c59bcc6e7723cac4f5c4c886737d1e86af1f857e371a44cdace37d147995233318ce39fa3c64fff1213670f282be8924a7d3efd9a7e21a9d498854b5c5029f320d5c8dfa7b7468997e9979fdd380cfe099c14938dc0ff84f1123fdfe7af84716ea0c0da8d7c832ab690cce55040af98e5ff2313076c91dfe8d2adb91f08e2a98656e7bfae42aac03c0431605a53b1cea8ee3d254a6884edbba55bc0026bd83dc7add10543f5e2003f73a5e6492e49a4032b4f84b49f7850c774cfab922aab1918a1cd7f629d03f7ab160bc30029ce68f9fc8aeccb5373f1140a040f72fb52b43ef3f7568e9bef418cee02f7bd75e43f57dbfa46b1698bc2c2b489fe574b30a89f65a359c177c197f6893174bdff784d0fd87ebb87e4989cd8008b0f761f1b799655e472c41f0613042ad1745334f104b4f9d08e0764bd70a3bc6a5bfa81fa619282c9407979c0ef520e9d02d971c1cb9cee1bdd2a97c2ec4274cc853ee14dccb58cd6196d33e46edb35111eb0cdc9b258dd64cf1fec5c3d3e1c871139eb6ab30b6abce487f6b6fd6a0c027369bac053ce9e9b792638915e82848d38138fbc636ea846e5c37ca72d75fa5bd6d22d45761a06215bca22a6a8297235432a7941ffb2afcff4e05c47907a80baf0896d995d4e33cc86d2bff88b30e9213a3f0a543573641dc2cf89c352b52e6913a90e657baf0d85bbb4d6dd6185af5d379bd38be599f984ce48ad3ecda9459e54419bbaf98bcd78c09b1db2267a3fa4c2ad5b6e06c0b202a56a17e32ee98db3de29fd6aad867ea9e12617b62027c2b9e9c80c256418fe6f917bece02444d2d45fe3b6728400d8bcd9db8af6f3b2736ab5b0bfb6e9922d746ab343c5bd9be51e1198b6f7daddf9b2b5da0828135732b64ee05a0d74a3c9fa8a130ce109b96206d3c20dc2115d5f088ec419fda163bf02a0179e80361cb0617956dcb09e1eedb97f43ce586f3146dbf953f8c75ac06dbdfde5e22e8fa28d00512ad0963ec0e993f790164715a4df408824dd78694a062d2e9d72cd723b3a9deec38dc01b2342c057a77a23c4d999bfdb9aac50e4a5e9406cf6c64614e6387468f3f49331df304230705765648280e5e494e8221c15adfcc05c402b34b455dda8f99c29503dda4af105791401bd52e162750e32d7ac4486c15c5af070731027e2d7d62ae8ac2c53a88418354045fd1994a8b7f037f465c0deafd820836a6babf44f1960ff67400f58b34c991800506c7fa81dba3e636d0a3a68f2ae1f90037046594d3275b05a15dbf2ab2843b5d1e4b2b3780c547f243d6b66a1d1a0e7b5e2b925970bf1791020538b517d3ee871aebb246abe8929f31c50624410c8234ab238c9a232d7a1a8d9417d169341e2f6e224ced67f4e33efa2e2c345c616d05184a4d0c4eb89bd1f839f79b9322926fb56d07d4e34a165bc295b1fbb70c12e183da050bb460100795046c0bbc6c24831a28c807866216a16ac1f82bb706289233c21f77b2f01620bced053bcaba0bfd93cf686b9605758788e6522d7231caa7f57da2b807ca7c53eb85b3086223581fc5d64a57fa67b28dcf4aa16a538edeeac7a0fc798c05fc4d1924567735698e29030d4da6e5577cf5596dcbbdcee9efcb3b2b09e687d3465ec7e71096482d36e533b82327437bc1d40b8a0d6992eb849edd2b9a32afae4db3d3117ea18438025609faa429eda099031758bc791a3c56ce1463f96ac604ef391e800b08e56ee9e99d8a02062feae4b7d59b7463e9e462c74c820c4dafb675093e2fcea4d9ffd3e333daf0eecb4dbd5c9f304141cc02e3f0dc038b092390d76ce0f5f7a1c949a81ce4b061f8a26c2441bfaf795313af5bc376e37b4179d8b6f7c724e7ea0ffee625d32c661dbc26386fc89ad7d448c81f64fd386a48b9d45c96ee63e6a2f248d84e930c697c744966c417f7987595e1e530bba3fd94e5416cb160561e0122d0445800318723935c01d4064d2522711bda3fa62d158167997f381ce61dc3fe861c3243f2551febc2cee7c4a92c16ac991e479db01c218bccd1c0130a2fc85c9135617f3230547e89dabfbb215a288576fd0248b59f9137204049e85379085518547dc227f3e7d781ac21535c94f7e6f088137ea0f72d8574a79f3835ada77d129a4c0cb259d4f6849d5972ef4dad06d89f45f87c8904ee14f0120543f5879ddd8275c19b65f47c2c9271771ab18dee3965dcadd8664870693b3e6a8e47db6d9289e9f3d1c118f34b8e562e9418a6a000a417c60ccefb8fc79859ea4e298294b2d96f32997fe2c0ce28c9a3815efcd940486c1d0e7152862ad2aed0db9efcc17f5c10338b42d04b2cb13d46208de9260007d0b330e937ae98fd88cff379780e1d3db22fb6658bdcac63bf99145e15ecb70f7c6cabdf64f9f06b2483a8166d41f9f18b21efa2a5022dc401f2fe97d85f24fe7737a1295dc0a154c38070d266c4041aeec4c436f5dc3d49adb7e74b67e5cee397741536250c1c504ce2526cfe023325f6e43c451d9c12d0f00d7a69608a54b65aa4581d15d3d56b1b822051ed45b19afd4106787500f61b9b71b9106b03e20d70156f3cc0643f1c58de5c8228e2379f8bea342a868c88ae8b98d989e6e4f4bc16003c810a64a9010137858fcb09020a94ecd377257acc021e24ef0e460e37a5418d20d7f789e9c08e6bd10eaf52d20b8c866eb3bbf43bbf405edc1d14249875e5d253937f1652d063762ec4afaa5401b5a9b837e634de0fa08c46c66470aff089ce2e8dc17a3fc07bfb0386b7a5a2ebccfb49e0593ed88aa7baba0719f78d2b3b208dae18d251f452660761361e5fa42a95ca300781bd96accb1cb62d41faa4e6be957fa12bbebf655c2e7a8f41a64462d43bd3a8d7004f54cc01765ce843bbbff8f4ed1eb67e78378ac9e3ff1f9512b3b99fb4bf95150149cf7f793baf76111b3fac65f683eb14d4c959e10bd0d6e6119a023fcca3fa8f8ae0e9867a808bd9055a482b9384e72d06668eaa872e48785ed562ed38faf0e6c058782f1be76bf6e596bb1ad7d1b3d06fb047647f540dfd4b34879b8975317ace54190ee80c2e4f7af5a0bd25b2c25fb574686099b8c2564e79d756b5c6620b90caedcbc2a76083c6040d2025e9cb81a0bf032b2ccbd5c8c7b5a012a1171e60019d9b5d5a9b1efc318ccb79d32f9f2bc066de51aae0307b0cb743ef317085420b26188553271f0462c27f5718d3ec2a731f265e83f4ab766a827b722789d24da0b91bef833c5f157f4d407bf044663d53ffa5b48a65c2f7456ead0cd9f259c71bf8d705c19e4607c5117905e8ed4207b6edfb5c2afa09c951bf443828657fc2807ae5bdffd52ba1d9bc37e8ac071967041df7d4d846c1f060e9a628a441ab71c8dcb0746161262fdea5383cadd64cc82befa4e86ab93205d0fa0036e624a68b73c1cdf9ccf72af2698359a3ccab83d7aff12aaa9cdfd5ee6bd2aef910baebe0194ed7e84913de22b77f47a0cb5c24352eb07b10b44f98338b06285f6151c6437d326bbe4e81174e37d99f34673c33cd18d830456dfea7ae31e4e2895a32573b9efb552e5a5e17a08f94aa09d92bcad2a745ab9dd9c1dd7b5db2325e29b9c53db97dadef56d92cd9de60f2af1e22c18fe9974d3d72880a8d04eb536b603889f7170405f674ab2c15cafdda644d5513628d0de6b2939b68da9cd329bd9f58d36800d99d19c9ef4820b7bd6bc4df29717b0ebe57e6a324a3897508d951f22ab2c2963569877ba9bbc58a86a22e7567a59ff2d3fb78dc908061d8faf59b7dd5fd69e58d6db993f64882ed632aeda272b6a4b953aeebd16bcb90f86d327aaac29071b33ffb4794319c8aa251280de091c87479af21a0b93b4a1b987c0838484f566fc51168f200b6f893333aea387cf76cb565969f054774e5b5fa7fd9b5a45ac8ec2b6c88251e9ac3071598fed880abbe3acd36b4f79413908d1aa28bac5fa4fd70f4960c894c1665bf778892fdd4717aa5890fd25c1d3c6fe8fdeeaad6b7f0166dacb9a2fb9e1fad7eba23055f8aa3b581ec06e25575b4c75122094af815d9c18f787c7e916d20c845da8d36b113b3834296c707e6231f1a109c0f6e30ded861406b25971eb9e07813531278c686fc90dd1b8a8c91bce68fe04dfec9fc9405c045a969ab46e8e10d9d0707d009f65ab421d5ae02e9f6baf70cd886503d454fa17fe43256a59612db4c987a47d2bea91cf7aa9a316dfcd2cc1bcb512124ad3c2e34101c33a5d799e817671353d0f6226b87aea808e530d6979160ccef530931a73e3d6000255594945168d876aba3b72fab5e2df6b20ef3cba75cb3defc6dd054a948f9475410ed24a23ed9ed35bfd13ec7a0ee9d2037ac78e9a3545b9974541d2f48a9a112de12841d04d8f2bf5b610baa583339f0f0773f851993c68ace2704a2ccd7d72acd26e2d980ef7ff2362ad924c383ede931a4a23f861ed8ad1cbd6fa3ff66d5d684d255f8bcc28e84ba1ac03f5c12b8b88b8580fe4a7b655506ae69f802c6d9b29bb5b5126da979598fec58b1324121f508c8c0eed86f3ef39ab693efe77c3824a3a3d22908768f9029e461dda79bcc9c78e0bb6e72d293e670e45d26d32942f66ee853f161b86210aebac0af6a2719a802ed9f5e4092be4ed0ed5203b08b90cb86de42f1e9efedaf07ac46a6d7defeb29bb801c4d9740fdae3aedf915161ff51d7e42680fbf335ea04596e1b3c0f3b59bf4c85c6c7a55e95982827326905f075f1b72805377158129baafe25f4f7d66a3d484d044dc2e1e23df3ef5eb637b825c3e8a4b241b113140b6f952e97ad30eec8e069cb753f0a5ebcc8b0262ca224619eabfbff0b80bc675ab6d9ffb610e505c99e4e8fcc983f74b6653512975b466360caa67fbd7b7e60e26eec52bf90bb45f5d02977264b965a895e2e2aa5e609eae35aa8f5d6f25f5cf953d177b29dfcc22610fae4fecd05f0adde6e4370396755278cfb3dc034328f5c9b500c785f3bf49a88f418b748e44e4382784da231068ffd98fdbf294bd29dc305a4d9988558822165e48231778577501d8fc494efb7ef13401737eed468414d64d507fac230e1760e2563f2555eecc8775c8a9da0c77ec136b08beba37bee6ca23bd26ed2c21166ee791642d9bf122acfc0c0ebe63e6b2cba9cbe8f5836815340b03869e58252e6e4b8e687a287edf23dfb713b40c79a459bb4cb25fb67e7f229a49b61f01bd56fce49aa11c90e86813abd566fba46a8ca110efa1bda1790eadaa86f3b16e6bbfc691b3412e664140f5550f76a35971fc878876f7c4f064e5f2f20546a36f8d95342e17a36cb2e555918f6c2d88f52ba232fed02188f45fdb05be8e5631aefbcfbd63610e7b5573b1480769de6e11c9b7d523eba9b960845ae1444cf84dfff6aa08f6f956a8cd846008cc76f3c4e789da28ae6a78994fb4e7566441ef73e13296560e9d94904fec85d4f9a100233f334a9cbeddb3ea8a36b4d87ec430d234c8097bf5f6589890f9aa623f84d51f60a949b5509c83e0ebe73a74295f1b0568e0ef2574c7f01dc8c8d2515760e0fd12608fae017160eef23fd995d4b1d7e5f033708e7a1294208b100071717c7120718724b22f94104df8f03c1d59631e4bccc2c608b5061782538ca9d6f2741b4d8ea6200bdbf74cd092c023829dd6f7db0442bf71527d7623ab20b26664b185e762cd9e283e2efbf91343fb2ab8724db0756353fa6d9ad4481fa491e4fbf3915ef5a715c343c10aa40ff303bb96d2d5738a91415b9fc6d7767b64f4f5ce5149eaab1e1ac4e2e3f08879b25a43f7a6c9b2aa86bc3d336d9b97f67ad83b908bdd3b7e69e0a96fa8b79e993aac9b42d200d528878d7beaa619bd759ff3cd681e10e5b5eb34f62b74d8cae0329f5e6e0149e31b1466f577f005310297b29a348d06cb1891d0c0131c2d6d34cd348c56cfed8b1baa93e6be9181c4281063c9762d7a20e5ac8ea6e153757010ecff06c19b714099951da328257a27b541f2f9102453ceca86aab3a3cc8e51c9f294251dd09f9c1633a32438a0abbadbcc5f64d9cf59dd2e4be4d66e0df0f88cadc8db3c4fa21f16fe013b26ae6709dea49e3b6631b8c8450893d9be77cb02967a85ec9be33433c4489970b134841518399cd2250d4482c7ed02d1a865485b4cb32830c1fb9cf575b8362d8cdc1f9d8187ebbea509ece4163f4c53e2d977bffb7759e2e8557cd95d106c8b6dc3d9d6cbb37742ac2778ca8794e0e53ccfd2956676915c986634e2ed22fc3c8a117b7ce900e67c761c451c0d085258d561007d1f7ec9d11757f31ce93cb1bf61a339979d212d3ee9f0b7146ad90b8d28a8490540b27864230dd13f8d2fc3f525b8db1bc4c3e908822b7952ce6195f0e815c3bb26b7b94a3ec7b6c30f0f8670f9a3a381fa1a69f71b30e3cf049a7f3ccac90affb2cec57f89f7d538bbce3a31622b108cd93c1b133d304be99f3825229e8050d89d03abc0db003165af7b2a782c820b8dd1b95dd092f2b34efbf087394ae887e5c58449e28b66ebc2520c9c422aba08404ea17b367269cf50c77584be2d3292b703769995ebf4db94b5847327b0ada542faceb1a3c27e5a12cb5bd21f67c13d476430c8bc0a56028771bf89321f58da3377b45eb1d17e12a37f9cc81795be7501242ad14e89724bfdf3a3dcf407d69d4bcd742b842db5dd4dad3c29c37cc460722bb67e58fa3e4b69a5a0a9c9730558949886c7181f6670fe8a3c73a2d8104cad64ba1ff5a8f3bb15574666b75a41d4c6de37af6cfc7b5939a57766a59d0fb097d45d85f74222008d31fc43a16c48a6a27ce500bcf1c4b6f77197f638d59f2e0379a38bece7134842770996f34a0bda06b261091906c74d3b0af67c52e4feebe1937dcb58cba3cf6eb3bbbb5e2e8aeb9ffbde6d35fa546cbe74e86f80c4303f6ba75206b15b7204cd63631bd75f79a4491fe6cbc1513d6c44c88a9c91544640c5cb4e788131a80dd63fa97b4c4745640c458ced04391f03d7ac36e2543462a9c93af9ac93eb60c7a23b2a39805ba7b1d4eef8772ddf6f4307121573d7cfc9584baa0f1568471d6979667e0b9855b2ee7ba1b9bdfa5f76b3634789ebe9f43e447609dc25f82236a3f7e6603d820d02c91ea4782903d564670bb4c6ab73c84db29f6f523e6f7369e65446b1fe68eba98fbe36164bce4fa67cb2613226fcd4fd127ce899cbb866d38919ded48d542f4202e8261ec83d8027f7610c385911903577dfc2da1075280d5db9c0ff152fdd371dc4ca5a55f1f5b16b982666fbfb727e51eb2cac56270203f8f3a4ca9498dcfd87812516d9eb5c6bc0db0973776ad13414c329bd5d14e3fe15181eb3f01c1981d0ecedaba5b0feb3fc24a77cb795a824c631199d197be4196f1e6b1b15ab835d2e8551874a858987921ea56c18b6b2bf87620f9efdced048a0c39a88d5d6e4731e5c0c17fe360b1ab653fbf5ef898f587cd5eb8f89174cac3203abdf1171ea1d17e2705166ddc39062c1aa5544a768bada9ee51485360970566a720b4c0afa93030005d0c978d2516ecca30d322ae413619e3189e03439b6fa87ef2c8cb1b38b212bda7a95739918b6f9ea6f593ff478c47003670255f3a7cc98d50bc64d7c98a3b084d5a43fa3ac60c88e54ed00708ef80a049d854784d3b19e614d42485826a00637be669e6e17dc0687adc27a5de3546cbbbe863fe15d257d276dc29e6d55a095761e43bf21460c2590711d695101d43e1f6715c5aba16e7440138eb0d5a26454e36fee21ccbf9274391221572639ac6015b833909bc4ade8028f5f9a3d28e965de775e25bb51cc24c662e8be0b66a61583b35563645feea1683f845207ff58df1c76eb029c5eb1d6a6e694e028db260a5195160c2a7e485694d6395e589c10190831e75ac46eca2378e01b9fb329de8fe5dc1b0ec2e9ddb96edae5a209054bb22b8c6485dfa01b5383daa333053fb659f6062e38f41e26f816cb6b86096c0decd687df3e802eed13264439efdb2550d85d60336c633593e8ad97c237b3cc8f41838b9a33284d671e7ce34ba57f691339b8e34dc41b1ced71f3c136fbe167d87b193e662ecc5c9b3d8b81cca9bd555255d31660a382d3da56cd6062bb5083e3b8762ac9f82ba47c30ba6c0ceda8fd0ab1c0c0e1429b92775a854829f3e4f08fde491d084ca69c283e19be348ac994b3fdd9d16b1b3051da641499efb95bb3576413be1e886330c40eefa15c9a0feca978979f5812cbc8b43d64e746905c22cab757871a61e873699f8f4a166562f8b646725e96bacd5eeb4981d4df1127d2ed3e0940dbb7b807695265f87b58ab3dc89788f989c8ca44704570b832523f9dfea12648b9258926ae2302a8e9eefd8bad994a09f848b3388aad4d0e9da91057e177cdb0ceb5d9ad51bc3d3f698ead7431f0c8417c88223b2ff101339fec1544d189c38d5783dd55cfc3772153a0f4e0aea73c23530c7d17b678b8ab77a214cac3ac9a33897db1de60613e013ab1630400f057c9026690abe9faf2d71e91baf7063b81ef1b6c19387819a784b8270d6af4b97b0f3ed828a33e8415b36dd5335580cd9e4e7d1b200cc15c5697957357c21b65426b21d729e7d4e411a9e581249d9f72109439d9def9b740db32a4bb66d2cf47dde9ca41427744d966d8f62c9ec60e4dc25c04e9a8cb797636c7a3be3d5763dd3bca727eb1b69904c28aca955c65d6da646015d8b1e464f41fcdfcb934776d2c9b26cbe23fef51836254ba9dd95349aa85d5224c9ecffaaa4df6f3bf0ec53122ef93ab0cde51dfafca018ce043a647fdd51b9170aab0965abf0d8941c58c5febb2145f9ec8f82faf5b5590a065d000579f75af19a20297abc4d4b853b327b333ecd8ddab546ba046bd384a44ce3b3cbecd317cb383cd527c33376da38934198ab008b9370b92138ed5c9c1462b1cbfb7ef3c65180870bb3cf167d15c9f8e810e51d1227756214238559d31ee4744604c04e74f327e7021d0fcc1d9687b759f4115eb6088039e2a91066aebcfcaec2577491503c7cb6eec51a061dccca69f0b0b3fff8e8a646f5580ca1f1f9543a10fd39abbf3ac6f2a5db1b82d32b06e67af0c4309d5dc219d92b43b6f4254f56a7799bb651afd80439a5e94d37d7e521cc54ac43a3694b2aa11936ec887025ec0272288d2eb03a2b5299bc9983be3d4561924b5fee5b917c6c4dbb8b9acbd7584c9f0fa3bfd06dd4316c70ababa30590e786395d633516b5b7659a076b01f909c287fffa53269c0998d71d4fe5aeea4f044e165e17a74e10411eb262d60fd98b05e8fcd823d1be10a0fd018a379c81aaa888009cb5f9209027899adbbc3a27fe7f666a179756d03403cca205ca994b957264a9fe819bf541f0babe0857794bf0de5b283d20c3194d4cc0fadb47adf1543f0b079304929fab5f409e47c88cb63aba4e4860dadc211cfd2d28d2b54073c613a6f33864b9eeb6ec002e140e51fe65aaeda531f69d642bfdf41087f204832154863b6fad404a12d6cf03ac6986cc56d9f4aa640c7d6ccd7b0d610be9d3aadca824b035cee32000ec6914ee6dce4532b1d512770a99676acb02deda19d6d71b871b81437a022ac5ccf9811d8936d5b7c9113910917632b94880ad314ec10a8c0f3fe332c45908ec771bfcc5c6e19acf6870db7d5da26850b23dff253a6725547249610e77da957c9e9710343a00787f14532c54899a83dd53e1a97de76d69f6f87bf80bfc604b35fd10871f10926e253f68abea7e141e25e82438b06759184373b8603b66ae0354026d103bcde49e9c1cb0911bd5c88aa5fb37bd05a64aed48ee6c2235de3b0dc6602b91aa2509bbca1e7e122b00b8c50e77c66dac6edfc90fc2ed9fe1432deb2dd7f1b9d875bfd6530df474ad6299e68545094cc1d90404d1e94427c8374afdc0f0cd5a4baed10523c4795676e618420b3330d65666a41e8e74d0f486fd212e6cb1cff249ae4de82d1490aee9504a7a471afec814d1e7449314cc145061d33530d01dffb7ebffe7ecad3a2aca4b83ac4d53b2ac1e835d33c4f131158573b75be0f3bfff69f73a5de169b299d3cf22724de26e4155ecb7e7eb62f152c515f8b54e3ae0155ebda44609cfe7e7fa987c91093783db02f5d82209d6b95cd09197da6a7cc75264bb78d9fbe11285ecb264e9da2c958f6fee344afb0ea5f575fb16d085c44f011d16393de322ed6fd9a9520403165806be11ee1845e95cce10dcac252d91bb595791542362c269c2c50af568b372cc40e371bc0ac9544035580b11f37501bc3f6bdca1a1fdc87af1316a23f93446829f8a98039b37c93afd4fabc142c6b60d0705c76e3bb213eaf459bb647c5f23c8d4d28cbfdf6d3ee2f810bcad0a762bd98d68241e252bdce99af33de8d4f53aca4649cda955ae1d818cb583b75eea98a192ad746e909f6735120fb237ca77fd6d01d2509fde0be2a70601e04e14dfe09dbf75490aef88c67a4bdba821b14556193c8174950f52cadc9e16c76f05e8aebefbc5d815a45101f135388a833b073a7405fcb30353415c6143e9cbd014a6d57bc9eb2eda68bb399c819d2494fedd8b4116b31cafd731ca561af2621e9855c9399fdf54d48814e7483706f0f13276f03e10483da3b5d231930510bda095ab9e96fe2dc7341dee788048c2b4d34eac7c56cc2434d8c7a2a015f2656e4b5e9c340d7cc426be28246c4309b822160f290e0b7f2140c5980cd0e275bf61877f77753918d226448396f6f55f6dda3eacc4981b0ec15ead4ff4c301f5880b03b5ce87b7626b7e00adf776cdc788c81931bf5aa11e7d509d72c4c0f379387976d01db1bb6706608816086a7646e73ae8201b71e1db24183331f8a9756b595a63d040b4b75d0cf2f85d3a2ba44c22dd9127da8faf1bc4a69e17d3e551bf43f6020116a4ddfaf41d79cc3414e4a6ade55fe7a4b3fce0b13b9118f4be0fd1fc9e6447e11439c81ec148ea8d65180957873da884cb6230246b5fc1fa8e2525d39eec26bf45e793c2f516db8324899a4978ae002351bfae1d10181696d090ffeaf2e47e2709190f736c8b59b0e24e5a7244d4ec43578e54b05ba8b19b5f93d7c58ccb4902035b8a1fea2af01b108c7255ce3e8cd41de0175897d74cb4f842b119764bc1e23cc96876aaec6e41837d84441635364f2f937dc2f22b981a37986e3761c33114a70d63325f1f7e0c417e5258251550ffe433df4fc2be29f091c9d5dfcbd14de79b46a585bffd03a91e137acccc0fd39a3591b4aa6c9758388ecf9656f5d424cf4db42cf581fff7bad78f290ea5b0b6a888334e21601d6f7af2b1a8a6349c9fda8a425adcef12f1d9e1da5a5a9d156eb9119d88d96dff7069069e33022c7e58dd1f39fd09495f5da9559845603116b533e0f99e60c6f5032067c0dd85b9a0749dd22f303f5271b179368e9193f13c0face4b10348b6b2903b2ec5bcfbcc4aeb14a8aa2bc2dcfe47ffbe48da612d50ea0546a9d540546f4d565ee981a9380fae0319e4a6e1c1e595ca5dda0cd36ffbe82dd90210955261a2bd2d10b9e09cbeb9818d151a4a77799c42341a14ae10ca70646e3feced7ff44ac490c39ffada2cdd09ff7cddb73381e06ad539478edf0354181e9645560ee916d8f42612fef46686236e4640014b5c1baa52be6cc7804ec6e38008cf6a90a6aada431732f4d8564b5660358760c5d8b5d2106fb8390018a13ca3388e7520338a8f58391ba0e7e11e427d50d4f79b06499202a2184b0bed1f6f7bcdca069adbb1db766a91a87417baed36e43ed0a4001322154588ed2446af3cddbd18c4bb4dec0f23a8b863a55eec4446a6d318c6d12d7fa41763fe3172033ef0632ed1401ac311dac3f3f69d6da855f6430b185f5bbd8f6353b838ec2a83256956696bce25313d6702c2bea6abcd24a1476ac9c9b8f0d8874a67366d488d1323b34e9db499e4dd00caecc117c0dcb8b7c6c991a174220185edca7dd89a5046c01f255172fc95e62fbbecd2953229af6ce23af4b700524bdeb60fe75f3b4c36eab87e2fb31b61a2b6711a639e35f2a847a4aeba8b259946a9df64e7e03d28137b88eb47a33fbc30fa254796d70da79df041c1090366a4dfe35c39100506128a92c0547db3315c01d2cbb081fbabec9226fa64fd123a374c43daaa03683196b49a4aeee34833f2fa97df7db59cd2012251cd96bcdbfd951e72cd2fbda199a6f09380920e5eb937253b4a158c0185fc5466fb456b74c5555ed6ee1ba63e453d1d08282307f54e9d0889dc989af64aeb544502959fdf4e5e659db75a0f4bbda5b1d927e4cebc9ad7a693301a09af2872decdbca97b4eeaf66808210c325725c97ce5e3ee56ac1cb7b86e5a7ea5fcb6f3547d15476257e2900de57dea745423a27961ce0555c376d406a1d4637471e08ca7125fd748a8a97b544247ece1b85320f872a23e87403102b50afd8a0eed0be22b44c98348460bd60c3e5dae8701e902efe8dacca5d7cae811c0dc18bbb260ff5bbd868b93abca05a84030a04e28e77f3256c837b60d775a4b8caecff95e8fbc3c2ad183d77db263dbe44d3133111a03a0dfbce16c2d03379dc9fa44c66a0a0a530e386eff6774c6bfe6c4de80b313b3b0243ee11eb06d9a8675fc38bd72ef3e90a025334a83daad20c80580690f616f511a384e458cb1fd8980ae8b62173a291194a8dfd2b7e9b70ad9678389513f0729d6da20d911523ed8fef87c8367cb45a9cb354e9b1f175d8605a30588b1969e956ba6f00899fb9798a24d68a109c9063a6a289c3d4aabbc128fae3d07100a3f3bdf13d2f45702961fba3259b8d971ac0380b73891e130c04c92a1adea2d81042bf94a9a2daab479ab73150731e35e16210cb77265368abfd03dbb5e2fab0573bbd1ba42fbae980af96edc32446f735ca49d088cc6a4e291f882ee43b5d9e82fca514143dce4dbbc0802e63819371c14734061af0ac3b237c5be2f3e68f86711a06d32ddd8f557683cddd1fcbaea9de62fc97559ccb2b88e3a206e5b65a49524806759445165e31e4331201e3fa4d9819be2b0827e33ef1d8cacbfd0abed0ebdc111c665793c938abfe58a71c70bafc09a2ba67f1d4b2cade5dbed651613657a244b40b87ee3e53fc2ea9c67eb970e24f4587b1d5477d539636637b132a416ecf18b3db83270b61a3e6d5fb52010d0a82c4fa818e4fd05a20a8ab84d25d726e9e9a3cb60e849629cc5362a7fa1bfc233d93b5c80aab8a22de87fc9003474640e6166fb351fdd70655c0e21b6680e3ef2ed75dc8c6a4e5ee2dd8897fa85ae5f665fcffe5bf6a031a554926dcf20d9b1983c4369ea18ceb43dc4dc5d78244e43f1e4b19c38bc2fe5f4ca266955ed0fc81246850586cc7ca9f099456b9ae747297ccc06ed28594cb4852aa130dd8a91c27ba5a8588fe529fa841bf91fec2ac0fee13bfae5234014538dae261096796c0fdf8dd678a85742b5bd6c38e6e3a6e10f3fa5c24e98da8687699c602b961e2d52548bd52edfbae6c91ebf22d76dd27874a2c7024a3e815e0baabf344e3dd24595825ef755bd30c3b02d15505ead40bb105ee1dccf9bd464f230dee3a33423ea1423eec74aca1175f70b20c1f1a3750e648affeff17bfbc093b036d13eb6dd3bd5b5a6210db8f980e7b8ba2f48d05f06ae7ef28fd578386a541e2af264187a6a1eecd9a5ba51a3d05c1e8d976a39492fdfeb42a6c8f7c975ac1a01a2d27a30b2560444fe40c71c93b70ce4149334f0f27862cbb5bb19bdd47060297c6891c5c1d04fb27ffb46befe10e261fa1a17f8f0ae38db1dcf1bffbf52d36a1ee4703a3e9ff76adcc15369c834c3cb82d5cecb657e8d1ad2cf4051feda24e9226eeb83c4dc774b2f98e3e76f044c53a01c40ebda4f965d1b001b9e1aa873d17afd9ddabace62f6263cece439d159cb12a5d7d589d9116e4210b148430844ac74b7d555f5c1941cec2d1a1ef1e7079b659a5ebfa502257df7531f4d32f3774ea8c8fa61e07c97f405c46d0727a389946ed78da58b7b3d6450439a2badaddd390bc7feb1afcad6d8f79fde431ef59d1f702a4e0c662e3f5de293306cb1ba6e54169f09b9d5352c6881d5de7a74c337cdf00d500b14df9e42cb4130b0b5868c18c572e89f535061cb49e5c9f73eb462442ba2660f3809c0e65ae9d91678c1488ea9a8c186b5eb4436317fd2c9b2d045387f0c5948bfee5f02a495b00c0c0f01c304e8982f17ce50dca99bc9606bcdd4274276560d02c68450765bf606ae62fc28ca357a41bf2aa71c10c83f8d990e320af6a3a2fc286aaf590c704ccf7e28eebd558b939158512c69ce9c5494fbc1054a4e45941c87466a3f34415d17130a80504d85d7800be625275e79f83309c853a1949226e1ff34ef00aeeab2337f8d4fe3e3781e3d224e434edb728877831e66ce808fadfbc25d9be8152fd13ed93c707efcedc57dec699170bebc6f3b91ef5e06999bec58eac10ec193c8e9678a35fdd0ceeffe3a38bb132c0258b899e46648edb4707827e25832c36a85f3865cc0e8ea46c1ca493c0bc0bab52eeec256a26c362d4b08de9aa0538df0cd450ff1af1730895480f885ad54ba89325b64325ad21a61fbabea8c5d68a5aceb40e9514cacd51382f7873f0b2f0d3d5efa9c15744e94ae73d658a605f4b904c19cfc102059a8b47961e74db30f4dcce05f8707e6dd665458d488865d592580148e8ce901d9c5083bd1c1fc9e3695c4a06e60fe6aeb81f61ba3b1802827034fb6518c172b9525a40df816a36913ff8df402aedb93b3d3aefe2d52fbac95e5307631a75119ac89f68934c552af2768ea6b1619e19d3b6a2fd23ac3001971e1785169289acdae168ac84ad7cae906a4aa608517bec0c68a36f579624c7028925b11e6495af842e8526e7bd59299f36a4787cc05e85cbd1376e3e53646625ab8741ac44b11a16c4154cefacb5b5b7ff6bed34fd4057ed7b53033688e7ec11b60aff67ef0602732604588a4a93bc1db8164ffc287ca4ec5767e86192bdc3c5e6f73bc7cf03a4668238048b0c8d71a550742d1c3f39b9c109f9a71bc0c450cb86b01bad945966132898c46989f52f02d9f37f6902f270d3ee198c5475e668746a19ab192dded5c39769ff5cad717d404e7776c214da0304853c801fa3589515f8546bb52749cd3ad6defcc9d3fecd4104ad8e1cc8688417dddbe43f0297a2b8adb31f2b31b6300ada5bb79c267a6230cbf900a6e56914b14bbbbddaa32bae38dc2829dbe959a80c12985a985214d1a6c2de5df9f59a16be3e3c6e09e58b9e71313c84c0c6f6bc4c1c3fb4da7b14ade3fb79e8c608668dc107dc9e80b1ca8aabe9f4165757b69a36c69749e1afd3623f9e9922eea548a5769527ccc9a138ba516b06601567659d8ac27ff04d011e80f9479c7bfd5744ddc91ff5a54b4be9a7c713592c426ab9c64c04fdd3ad3133e67086e602d08868fb5a5ab9e29aace01ce434d4ae16c84c56328b37fcc8bb07054fe43620b8a0cb6d5244021bf9d91cbf32bf1032c0dfb6254ffd1606212c84c014158ac15411a0b2abe9a9bcbe94d7934ba58e1863d92edb933307c763cf39d0c4e9f4aabedd2768001c168dfec3dd4058755a1be18791f6225c7d460a8cade67247591f8bdeb0166a257128b7efe344f56f02f8281fd762e847c37bad6e56a6bd79dde7958e0d5ff6fc7b43199db828e474866ba603497a52348090f0c9cbeab8c7f8cb6d6d8896e4782b0a7e93473a2d00f4caf701a9bc389e5db6c7afa0c46ebc5acb9439535abf27f7768cd7c89fa6a27abf4bac8aae6b23aa84f04724a3d6862f7d6a56be6667fd00079b751448d8b488653825f2acf070c05e65518bf98c2a965bf8b6f694a77370c494d4866de7d94a248f3bd3a4884330156d710c174a4897cf5d330615badd3f835a7e314a07942670b0a4475fd7d5d3e9793f1fc645db8acd0e7ce3f38d00e12c7258349e5c9b234fffe689975149a0a482efb5f8b91f79f1804c9f2f7a945ff873e8a8b13481793bc61eed8f6cfc1e7a04adb972ab17741012e1e9df927ff288e344946a587b27901b399738c37e081bce680e787fda025ea4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
