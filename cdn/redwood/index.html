<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5dab7439eecc57676cfa630c0e7db36ecaee6707b71c168a208d164423a36ab4cde194f74aece1c21085f88d702c9fb933fd2224bcd1ec8749e9903cb11208e9567651c35bdc88b94caf50d9b870b18a477ec525ef5bf0f52fdb3b09e4edcd8d9a53491db30e06048d0e84b6b2537069b4c95895c8f5a5a53a7c84651bbc12db9f5fac90d27e23ca0c2e3bf2a1942536771a779dbb6449411c25ba45451bd6b06b337acf5b345fc088759b2f35621f426e4f5ff89a0409ffb90783d0fbf6b86914540fefb3c2f6eee4efd4542dd244a553364efc6613d1fe5f7a68daacb07045c9b09509633dec64dbca88a5fc549fbc51e9b904eb8a61c8f5ba73e9540fbfc2aca8d68001d7de285d9547f69033d3231122db221fb853eeb777f1b8cb9b93b03e8443732f2c7b0f124362cfa7b64f739d23b736e59c4bc9590d7032fe1f1ef85a7f1f52a1463615f5667017cf93812081245e0189adfd9ad441a95bf0912b9553217fcb9b1a0441cba7a3c7552b9747ff2ead6975c2437c4d70aa4d6e04e237354f030cc40104b0e392454ce9815fa9987e7957cf809a96a956c9cd75e7df87d8e9ebad7e868c1daedb32811f92028bc4db10b02d9815298a1567ab99b69972a6579cfc71e9cfbaeda38a3fa521bdfc8cb868deeb69a4e103368de6db188d2724f357bd925d1937a5442b44408430ee54a39d3357e0b893e9f85821c12624413dcab45a809be8bbc51511b950325d40ac39ef7644c75c0801ab2eddc38cd78cf51b38902f6081546fc6f5573545d6fa769458e022f005f2adba95b8e0d796c1bf100cacb8063d1431d33658730488ddaa225b0eb7c49878a59e4fcb9f58942476ed3b6760b04e47ebbef042eaf7521e89d7ae89ee8e4edd5b1043148ca951f5242d708a8a84b0143c12002501b42b0251f923a5f85021a3eaccdaf3953f123e8f7539e98fe490abcd1b4adc0dde02ddfe85effe247d7df998bbd9ab1790edcd2907246bd8770d4cfacfe20b44fb73d6c8d9e60ff1c65455924f97929e0f75391858f596e39ede97f795b984280307edb692615a4b596e159dcf2483b9f89c54ea4a953496378804757e0c59cb6f6828b84f582ec89b3240716125105861fc0fea80914f0b0ce024485c4902604b1739d0492fec586ee548f57a5232c6a1b108371ce58127c50ec45af7b3a4a5fb6126b9b6a8398cd12cc7fb987f8e6585602056931fe2549e63a689e66a466b94f860e187dffa59fa933f653275e188275d64529e1e571f1ff2a915be0d191a263e4bf71231da519681732a0176558cc9efe30a474f5c82ec82dff0794fa57e0100bf276d303b19c98734704350d85f4946b6bde026233f49289bf08331c71b56c46e8473c1ac8acb829ab076b676f66a05d4ddbfb44b06571d83acf39212466c4aa195f71316e01a292ada461cb446ae013a89fa39a7e06aac5d5483b4b1a58e84c6f805cbc9af224e2de99894ae202236cc08e4d852c973d423a1e925dc1c6b7a3452dc22fc06b5d637a80f6e442085412020fc88d79c209b8a2d793ec3a84facf173aebbfcbee682ccaf9a8a956b1420504b4cf5906816104697ddf62d253af4ee44b9edce4193f6b85e00f9f2a441bbef6fbdcd4c968d9c0a45761ba1c49e22555182bea4cc9d3239da516991d78acc4b28b15a4d82f28ed1348753cb508bc49e1148c9f00215fd2412429a7cd395d6cc2e8a52495ff2e49f1d9c7a40284eec837fa6f6e70e300e737ba7004277ad85174e9385487104ee89be16ab02ebd121c400f8172ff463b6ad6f8c89eb2599ba590eeb233a575edf72b0484ba084de3b34aa3e23a3d619643fbc6a9e852332b5b1df65853fa0f7335b8b9abd770a7e6fa654d4001a3564d54b9cb51a9d18a81afa290d246a4fc17ada443941cf7e1bec29842402415a8a729f1e45b10f52ebdfcb5dff5136d8fe2492f291003b4c0346b38c02b321e1d6d2486e8fd4aef2a8bef2a24d36fc0421892b3a8c75ac77edb6c7f4ac16bcb133125590caea29270b930d6c55ef3674f9dcde3123f3efd4573b5f445f9f89d27bcc1538c540a3660eaa5577e722cbe89a6d7d2fe8916bdad08e9b71b6ce96f9f1258dbd6d7218c73f68d854b66a0782a7bb3afecfce6888a534ca57020c622d8b0f6804fb73a399ddc3eedb3c156309662cfd7b7036994317d405a99888440774b40821736207ae181c0064b6e568294fbeeafaf23914216b4982c85619d4ab06ae8df0090b0ce3db23c0c187fabd9e429e41332c16c0ece13c7726442a930f837772c7b6cefe7c13cc242801486e43a9e91ac0261027fa6106ad34231f957fe324f92055acdded27a05f99af166650ce712465db36b991caf9e21f3990aff6fffbf02eb6b9f4a262d5d7a0e0783f1679e8ecd352a695a91b6fde1367d65af0efb6996b31fc69da0bffd4da6674bb622da090aeea71fa5c79bda284e5c31a725640a56b9e70f6a75acc570a81ece85e1ab9aa8d5a572f41bda609530a9b51d0d1cb6f882ea742bea9e5160f000a56bac041687b3695a340e78c9ad0692356204f6c26f6228f74cef0eba350bd6d4a9eca184783c4fafff89f0b998548cf59a8c6d4e1b97969875172d895f7628769ea64ec51c5637a9991b6c384e16cae3a936bf2bfb903ef1a0d95519ac30c3f758283b7f1cfb7bd129e8ecbf35ae3df3d1422add98193b07ddd311685ef1b5c0777d3c330b63c18bcee54dcb623df8c9e3092afa850f51a172e680aef6360ff5c09772142796cd28a85c60e8772ee2e1c21330f09d1276c534c0fe9ea3b84cbc2f5dae5127728b52c29d2f1d46f99ac50afd80dd09ff08d10cb9958fa6702d43ac54975668208a2e862a38acf5bebbedba070bd74571e99cf550ba47ee1fa6f696d33f1c1919e4296b01210a752892a0eccfd918041e00b1fe921780f9cb8324fb6a4b8b5fa80e351cda6aa058a39c54001d286b8549d20bbfc69b929f3cc90dc8607ad074e8fa541bdccf3a13f23447fd5747ca5db0f21f6edcfc408c361e6d079a396582f615682c46171b42d642c201c02016b45bbc88400fe3759efea8b3300e8714012c1ef708296e5f38202aec776d6b6085083acf0d4ae6b42f3b9a5a2cb2988686ccc9e3596e8464c779137aa9dc927231f77dda8e781ebb5e38dd969b6328442522148076718ab70ac8e2452f0e4fe1a0ca54e757205b97fbe84140905f94dce932b9204241142751b1d3a837459b68421e8fc9ba6f890e414ba723cbbbe5f44826484eaeeb74fe83c643bceceee73bcc3ddd7205181cf0b1fef5ca61a0612363c81dc3915c7ada33f839e003d123464d45d2508cfc020f5e5dd14769e64498bdba528926c4d296aff350908aa921c22f55fe9cd656d92387fe0f31b00ca40dba77a053aa310e420a8865c3405927b507bb6ab9f21f9077efe133d0c7addfafa2e92a55032de4806582b7abd6a80368b7de1de37318bc3efb39bef500df97470bdc5c740253269a20f98de96b813b4aabb9da9aa50a66585d1ab5b47463c97c68630a8d59502f7665410d6233ed9438273cf288ae67060ef2ad9c5e751830cc4b3593b45784ea3ea430986fc5acce03cc844fc282e54fd9e003216d928da6165d7fa555d287d6aaecc5422323c526b67db38e00e140d2fd0ca42e4e900d704e4f15d4280fb0ad086d7e354cc9a15ad5442b922787bae44f89f771c4307db33f3ee20a628c9d246b9149eaa0bb8e8ff329fe3899e7e4adbc9cd1cf3cd2177bc82553b2cae6a8c5d105526aa242ce7c40a051ef49142a07a6be3612351600843efea8c3e7f9edcf37590f07ed622755296423b6ff249eb506616e6e76c733576d752f32a3d398a813403ad7fd8ed9ce6a54106cf5bd8e801f4438383b222caee132d0e0332ffa8c12edcfe03013835fc66edd4ccad4bee9d6bf0f5de588f289f9be5cead633b6bda4c3e0d76a62c8f599896e5b5d7cfe8864943efdd99150eb500b6eefd592dbe31c92d7c0b3aefced0696cecb6ea1e66318c3ad58934e9fe1da96407ec8ec8b5cd0149e2c1dec30964aca4fea5964400a5d74da5835ec6db19454c2f53b8d39534a339a4c4a61e57b9e78542a4d9dcc0a387050b6695220330fddfe443eaf37b44dd12a8eb659542d627aa42e110923e3d3b420661b603d6fbfec26bc150d2ff5da1428bb7b41af356822d7fa1f47178ccd3b90133807b67a159c796bdbe38b507d1f0190bc7d690b6e5c30505d04c4d6cee6bb255057a95f79a26421789171792d422bfe2069d163cba2cf41e32bcdd4ac7f2079e0589274a43b22ecef7897e61e900fd851afaf93a57fc00dc2bf3092a9d1edfe48657a4a606efc3771430a87da8d827561b57ebb5c556897f20c7a71487a85f55645b52fb55c66ca68c36bd237fc77398faa4e7ce7cd5d49d7a8ceb4aa9f2582c2ab184d87c6e53d4d59340c45c0dba99774efac87a2475d4ab7e0759feb0f8ca594e1c4af6669e9ae4a325464319b26fee28771ed1c1433419fb023d19bd30be313c5f7dfe5cc9fb4f6f1e3e1fc96a566176cd84b03d7bc5ac22b46ab9e36561eea9c0e9be6976ed2827c4250e7767260bcee5eb29c206b97d90db099919cb9c16f276f53352ecd90236a4cfa8c4e7188ca615c434de00d580a7bce3825722ff542a87fc93a49d90eb9d3748d3a73e26691078bada14b8f9a7073d9cd911051f35159f77c760c56f21486e3f318ea93a2ab923e3b3f913f80e3b3befa7e80c910740759f7880f4505494b7062ae45d0284ab0e42d51739c96effa3ecd8339a14db22310674197a30dcb1ba3e1c020cd22d1a5a7199ac2c6e7e5c592ba4b4cb6a0a49de5d720958549242b76a55bd1d637de7914a997e246f5127146cde1fba168d73e8124b850bdbab42646d5b66b2ade67b70786868b4b39da92e365b245d2ca9d7f60c7c2e82572538b6d05cf4724d2d6459c669dd81cc4640c4808d26f7f411c11ff6aad6cc897ee92208a0fe19947b97d5caa9c54b1fc583b2f4edca3ddb48beb9997248a750932b7beb364a862515893d5db5b837f94b62c883a6ac2ceaaab54a0450ce3cd388e788c30f1d1b591ad42fcb9bd2625a8f502742250cc718149e4381616f55aa345e15e6e0779bc331cd6e1229156eb129173cb4ed3958b7280f825a59a16272b12a7306d5cec59be30dcba7af0d6aeddc5599d4bda527eff2ad2188cfaeca40846c25ef8316dc8f8f9e43357d305728a726ead64cdacea73ec55380d0cdd6e21784e1d29f26f044c5daf2cdaacd9b71be6ffe8a8206ec3e34fe86c95892d3a117d5eb9c906efa4a7c2c7fa33d810a62dd58969d539b2dbc374feb2c8f202339d4e744dc5f35a9b578c90cb1019a15ed9e66b8ef3d5256eb827b9529bf9b7c717fea33d4f81df259c269dea8fff4d1c35e93dacde846ae6e4132737887aeecd90be95d0f8c0e456aaee1feed3fae6fc616575997c5ea2dd012e4e73c5e9df68fff59efa611c27aa13381ea10bc65394ca30ce59f93c5f72d128333ed00f04c450ef5f6013478b205fb1e581fff5e0bb602cc2fb06d5530f969e5302d9f03b3448ae6ffbfa62cbeafe196dc86a0514702e9f5b99dd4880744abecf453c4dd08a0323671d3cd45100b1c589f57729e58698227fbb4bf3776bc9559f11755829f1baf652773c94e4b3da37f8da19997a7bc278413be0cc6e1d19a1431b7e3f197e3ac21b77a366edf19cacc84cacdf3ef66399eec654c259f8cac0ca1407d9232f70c12397c25d5807466ce82fd00d731c9e4555638caccd9b6cf45996e05a4dfc010ed8d597fa8156343c71abc6fe6b19fff2460f4d1ca731617b3a6dad4181d7654777cb3950a7d921ffb238ad1926097889cd525f3c85840ba17b9e990bde00c7ffe23015f5c7bd8b91ae56a5022efde25c70b4dd00f8d33fb721af6659a0d879ad9bbae3dd90ab37f9626b27ae1d35a194d08b409ff970bf27eaf9bcdf7467991062d00375c7ad7e8700be22e4ac5961be133858abd222936b473ff90a2974de0e09f0a1456bdf5680080e879ca22a35841a3eab577154a67dd63a8c051581f8e49529443adf818ac3ec39d38c4f32e84dd374ce777dc291c50e36c30d149d3fb78789beaf66c1cec5f010824e797c12286ea81a83c3882f1ad478bfe15a29eef5c6eee9c5c98d4436d883770cef73c2f920ec7b1a48021dc1134676f07776e417747a42663f174fb13faf6d444f308b07df670e444f4e7dbc9815984772d2ea48f0467a0098d594fb61964f1ed8d02ca6edf3721c888e5e3ac17a84a86f3f6d6be55342767091a4769db0e07e6b0da43de41a2a59dafb6e4c2eb0625b8136f091945f14c7c3180048e057c5dff41318419b62f805a008bec0f8df03dc61e5619730ce02f684d6ac9d5244982737964593139823b4c87ebef6bb3956f69ce0f748faf7e6713a592f3c8f1b26ce5e7dbf970e0b5b8d901a89567e3a91c8dcaa5e1b711fed693d8c13ee95ecb3b1f12c2ea8b2f0c03abc46e6af931f00e3c7010fa45f5a82a35332f90695f5ff925aa79e79cd8879bcf58fe2587af8c3fbe9de5f2c06400786a21842b89f493369de3986c249ce61ea40e3d2cfd2789f09fe2545cb3b58d5f61af33b396fc978d8c44cbf3744c9cd8395682ba88e56fb5c1d6d59a727c9761daa0fd845a9e31803d789c24de580a6d7b70195316841974ec16fee1152fe96385015eb26e3b971b62140c6fd7b8d8b580e902aff2acda56dc653287f62d116c0e1f94f95bcf7117ebfaa48762e4a39260f3e8282467d61a6f187d499bc4add300ecd27977c649a4e483010ea1fd188e45dc61a1c7133ce3533b8980d35c897ace689b04a7db9d88925e8e3f92630c73d6c0eecd3e482c17330c172a68dc26877091eeb036140a439f5c47fde7577831305f9b7191d4057170d716822f3a3dea3af02f1a1dc390dda8c2659ad80b9597fb268b203973c0de526adb12db9eef25273187dfccab3cf15c7ad4f29fa88af572447e2184eb97c197dee9008dc9759db6d0b6fd325678f661ec8fdc0bf4bd13df0b18d641958b9f84d83adeb8594b330d1c0881d37a0bec47bc8ed01aa127cf34d16e354c700606f64479b8cdab5e3be73d1996311d7202241742c0b011aaecc0ae4bad24b4a09213d9d6c0f56aa74ae5321b6907e2944baf9be49d3038e7cddc0f6007fa93c628237708602288929c58828f5ff123996096bf2b7b6062c9df8ff506737b175a103ebd232b894f4f292648c647c8e6b534a321d0cf6f9f4dd0f6a0eb336ca9a2ee2885b14735e503770318b3cdaa59b9145aac34cf267b859a0dc500c9e434e5eb068c3bc9f49a1a4037a65e073133980761c7a0687f7750df07957bf8473b72e43c9b5961b4e9abd15d3d07d593e1f5334a7287a3825afd1a463fb7754ebce714ac4e7aa738b39a0ae76b1bb0db901b0956240faa651b0da99b13d473bcd3d2d66e33bdddd97a2d9d0bb6aa0343e2917077a50d43498b3f52764676f9312e1c20cf04ac22fac0400bc08d9937e741140281d3ce8c8c0964999dac5485f22f51610c0622d969e0ba21b0f22731c75c80e3c741b1ea25c8b89a35219f001f44b96ed96e0624478e27c9bb441d41f346333b885dfd786d0bf6b11f9ea3e45b86a63eb58cd8985601a14f6ef0a4a00b178cc19d22dfa98b9c7fd3d62793bf937cb26ee26244164b33d3e07fcf971e1f9065c4c5c1816ca108be373fe3d71824f8589bc7ce21fd2e03293ef052ba68d35d2d21a3a06f5298bb3c6a85e418a4763caab2587191e9149a1e4f9db6349f15049d15df84db85e8ce68a579af12de771535e7d18683ab3aa203e3a40b54429d04247cf36c7599cc47f7e147866099ce5abc37f912afccc98ea012e0e8e26ce7ec5a5a1c2b1c4d421534ecd18120771d591685cffa80c935652261aa86e91b0f8eac5d7f38b753008f26c96669edca03589c5db868f894ded21cd9594bb22411c975e1da92dc2d7a3e57877374730c984d3e942574c8dc36e2a535d32bc9dda3c2c041b4418391f554d8f70d97cf1a02495b59d2560ea4cec5de7c5057ddd9d3d53ad26ce0d8004675088768f8806eac52def808087f855366b7119b3eb1cf7c2087faf6380d56bed5b42f0f92b3728df5d0819af5eb0a58b4bbdab287e566db3d97c0bd5ef6912274faa8ce1fdd258419bec8d29eef9210caaca857361b4aecd01046952aa8ea2222e4784a61e8b6b06d4d157f1fff90d10bf9d88b17d342495b5150d4e781645974dafe0a9adc80c48da07d534f4c5cc68d72381d35aee23a5df8cc3362b31da5b75c24a791b1be4b1d9fdf7d3dccfd974812c31ec0e4f85d2c3ea45626feb8af049ceb2a5b94cd8db745ef015990a974b4ad3991d15458e4aeac323ea95b5dc9c5432554135a8d79d3311ee0840e80eded16238753c68514e9fe26a218b80f1b33d113e12ec2f6285436a46cbdce04ea0388f3ded2a4c321ff26dba82d41c1168bdf89a56ce8bac3399421ed8526a8e98dfd7235e5ca1c6d1925615330dc6e77c040c5231e1435732ae36d35ac25a572fd6064ddec49dd63530a854210fcd04be4f35dfa6db2c25ae2e59821396cd0573fecc64c7d198365e52d429c58d883e4c0ef0760fc8d966dcf25597c6c54b6991ea780252030b1182a39546441d1e449079797855ec2003262f684e8466020c68092bca53558504b53ce8c9c39452b84d3aceb8acd5eaec56d1372fc8e591ce20adac59aea431e9e0565fab2a4c625bd053a2a479ac53bdaf7a8655f63ba16a84627502183e8feeb55f42eb99450c0bf4fedb671dc6e20b6c119e28500d2611753859e9fdb859abc01750737de6e008052283e4a3cbba34352ea3b61387a42322f5c8cfa8e4212289e40996384b351e701617a2f7ee6bd6d9cd7824e6f1e38bda11481fa30abfb0033a1382824661564bc36812445f9e6dfbb486b86d22f733b222f4d0763b3e2c5eac2125562638340b28ee9b5370606472c889380a2039a3592a02875ece8c324612595714cd483343223328a5a193706c73f64412f1885dcaac60596f6008bc548c9e8133785e1643120046fa75cb96c9b9e775b6146c4f7fb7aa788be2399fd6533de291d211b9bf6688e536fd89b94e865d8c543656dc904fdd5e32d60e77434bc2f1fff1e6d0ce3a649aea778c948fdb67535a8f7a094382a50ec7e373c22d5e93d2b616039a46933835c755bba2e88c38adae61e9026904c70d85d9467f15a5312015e3ba955befc1f80c5f05f230c9f015bcdef2d0da4be933813fafefaafdb32e33bfb95f1f0c4b2726e9cbf80a8e8ba6f8ee991147d4b8c014c317ba377519703152f0bd3be98b245dafe192e37d32ece624852144f1ee7dea68d80dace58e497eda3d7116abca9d1e4925f27ff447252174d12471108e9db6c4d2ffbd65f73fcacc47a3bad3255cf1612448d55447d308cffa7ba4342f2c5a3b8e85c0f2beeadef11d6c9f605e2c85d661e27e6a1a4fc28759a19ba85d802d7c9f9707bf50e63640a801289a8c7f2acb59b2152c5736f96d5df27ef76696453fa81060ebdbe4b25bcdc77bb4603c15b85572b7b2985f64a82c0b29b663fc874577e176c7e53182782724c460eb938eb1a707594330bf8b054b7a8d834e44f99df98ba9e5c99f048c9d23fd258db8492a4988b04b6b0e6fb18e38fc16b705815bcac93b4fbdef67a6f8d60fe439d751defd42d905acc348d285ec52e1d4ee701f98ac46663ee4bab4d19f90635b37dfa206e8d93c09f66807feb4b2f341cb3149068ea2ef876c0901d0a46cb74b80612234df5078234d2a8ee52347dee4152a8a191ce018bdbef1be9e92ccb1ff99c06fc35c125598ba54b20b7d2dbb6f0a6c489f7f51875987ba5c14bc845808e7f14f302362c46b1c11116523c7d46bfdb82915288e5de91453b5422938b0ce5bba8ba1599daaff67f745b2d5fc57b9caa81f028ddb02ea83fa3956fd556c7e1a4420aad81c127f689d4f2f11fbca10b39daa2bd832e2944e92f48f2a34323f920f23490a07866ffccb4899b7e7b0f55886c45062f0fafaae0e7aa7a2db6abb72ce5ee7b2cc001c18ea8c0649774f6ea0cd453d3f999f05456f55471c23598be7f325cfba463a0475ce584dac4b2ba755b149f3526d34149df1735f0b6206dcaf030c72a505570c082810249698823f0b9f0dda368103843592f6e6439df7aeb3d9a399c9e841bc345b1ac3bba094a15ffcbe592edf7b2fb4f0cf20e52eb9b227ce97a2e6385ef9bd90bbd41c983762e8e115105f917f200fd0a64032b6c833788966d136ad6396dfa8dcbbe1331a2fb7f56e89c3d8bb55228932914a4002a205ea3c88f6a25f45780db5d46d109f05b82e8c9770b17517ab8f3654b87148dceae3559c369f07896ea0b93fe329610fd7a690bfa901bbc054e70a3ba721a91616e21a6d800a08039a251c98512671cd53371f710890bcbaa7c93a7a85dbbc689c2557b2f7aa69d50b816a6c88109c9bed32fbb3ba1fd7ac1577299ee420c81f27cdbe059ead660eb84027e5da53111733fe9c8289390333d6d4037ce123ca7779b2f17d05866ca56f930b6b703d6898f59b2ea8119d7b2f355ba250f8e4393ebc26255bf49223f6010b038c030e92cc1b0f64decd48df0d1274ab70be0e573a57ff9ed5c2db21a618dab6c58b4cc505a18fe61174ba6dbb9e1572603605c420bc82aaf1029fda7d4b6acd2b22ef43db203ea63323aeed081fccddad259558eeea519a4a927e8b109877186327b34b23d2fc14c0df301c55f506029bb5b12b893c97d7dec11a639f4e56d6ff2773fa9030dca5dfd9308e1e83d5f1676b170530f855533bfbce65c3c02c0ea4c43726fae9d937f84783ad004deb2f6190cecf1e4764ecf94d5c25a9b40576c44f236194a34cf338e1f693832ced63588bbf5835b3e593833a2a163abff42d0c9e411dd0403299e038348f5f0a867f91042e9ebe369a278b029952d4da39fc5f7883069c895529b2395a4ea0ce86a61fc23b6149d868ef38c0aea55470732f256c2d93df434509db716e17ac2ecc45b2390e219db3f345dcedc85050587b59631f8bdfb1d57dc1deeb213451d7bd637f86c04433711b1990cb4f0545ff5cae770b53e4c313a2d0d03683144328f963188a6457a198266279d41f7fa7079ebd87f889e116a7557a3a0de056ffc76d254705fe638f8d600adc9053259e930b803f34faae0bcd14a0a7f6eb5faff9ad8d9fba1d86e096d7732d597af7a9f270ad055c6410f07066d065ccf670d288c91561c8c333c6d1c23ae3e36940de4411b4b7f68a47885a62bb255d3616e92cd8aff6fb23b1ea2e4540f86b4df1f794b6de465163ce553e2387157c3039f0044fabe99a46d1c756cb50cafa1767cbc3f8ce6750674e0828ec84c0414f4cec9f000bdb353fe9b425f453ac067027547905d9cfa65ce6d3fd37699604c2a42fc65dfc7243f6694cc4dbae7a79725c73a007e86a687a6d79b5029a59b5123a5d443cf3dae2f13d9f5e60312e48b6cc43ecdf9642836efa904fa87ffb9ee6e51e15a58fa93580a8fdde51f60a24fc04aa8d7caaedf543811911d93ba946cfdcaa8851e7e48936bd604bb9182fedf92cb0d42341a28ef2c87a7dce67f930cfd28eb1787837906f97e5cbd4d68122e38867478b02b042d475f43e6fb50d989220387769bade5c59f9f5d371a68505bb19719d7ff832037ad56002c5ba5b39a68436acce04654db0b76a985bd76b9ba818f8626538b443422aee4c75dee6cc88eca7f41948bad31790c30e4aaa84569b5d4ef5b673e3d71ae3fa2fecfed6c57323fd5f5a0c360525f5c991fdf9c744679bff8ff6c37756009d2746df86414455544cfe6749d355f1057171a5687cbad88a42b71bcba33fd4f61e65b204747b43e855af3744e7c11947180bbf5de1a76ee053e2564be48e8a3f08d5d06f42fcb89026aba8a4ed4b0f35f6ece93fdfdf81d2ba1ec1742cb5a2399fced8a2b9db39f21497c5b4d4741538a80c2c5248bd27959561fd8644be206bfb9b58db43a483a4f7941718fc5dac3cac0fc280c3def796b1fa8e7c8d1d60f436f89bc43562577265dfded68f139f25745a09ae1ca7c7b94643ca5b13b687d750ebf8b8462062b96892bbcad8935b8e9f71eef62b019b95d4447d1366a742176ee87c45be8bbe7ef84393a9eabd6d6b2402afbb207bb83aa98db23019166dca9a7b372393fe1d09f4c5964c95c9a191274f9cb9fad67e9f0ed4af488c1e9a664ec663d8ed6cb7787a6722a549deb3e14f8497763e99882933b2965012721500a66dc7e1c8c351db2d6544bc0ea58bdd6472f3325123438f61724a25137d9cef8d62428bbe4921c2fed15a89641248e70376aa422ecad8271b49b746b6e2980af121982a86c038055e9b4956d60f03a8b481021c5acffa5c7b800a188c7f24a7d16e0a444442b5b5ead78b896fbe751e6f68d28bc71d0d9f47b2b591cde5e7d537ce8a1259221d6c6f18fcf3e4150e7bfe3915b5316a2e480b201946ab0bdaac7cf87e44e06d18b17d3486fb5229261f0f74d44f74dc25fa243ccc599ef7ecc561b19833efe7f9ffdcb7f5fde080cae99340ddf7aa25df4f23174d3469b99d33c48a0d48f4d3af0d2c0227971fc65037235e7d8c7ab71887371562d65f1ab4bcb4ea06f05fb76a548f74faba5bd44aa4a8e26e6576f49dea32a81aac31f6bd671cfa1691c715314d1c6d0b40215690dab79d0ee4d93b276f47c69fa6e7010f000296a46ec5b43623d9ee5cb92c65d79f16beb494b8624bba822929189827c28d976f30abd5566a0cfade474214c6ad057f68aee7354df8a0eaa798da382fb6843af56358159c16b2edc51a32c61749c67cb10c255a36b1c2fa9a65c9dbc5a855c3026f2ababb1c985f71b4076c104bff5ee1a3dc65dbf211ad2a2e67e9843a55bd4b84cb76be67c66a20e9154f77d0b996f641803f987139d8be3528b9ea9cb67ecab9635cffd792d7ad560bb44827652dc3f3b09207a280c475bc2b97ae4997bf3e4accbf33563e360eedd367f761ede21029b9e5c8e03a604cd326262de58654ac929a91bece39d4cd49c583cf3991188d1f015355f7ac92e47cc60bada505358ec58646df03be9186359e735924693c02eb0187106ae5e8bc7de7f467d0d45cf4df55f96f81c9e555b27eb1ef6adee343500354f63f7e32cc8c879e2283687522575edbc73172f4725ef41f0e4085b0d73b8d85608e559d32bb7a31ab55a810064a4e2e7fe098e7d2aad145c2e9cb08ab036a4175332206ce94f84508ebde59e6c97bdc0c0c2ecb08024a5fef6700181549294f1edd49e3fe45c5fa293633d10ce7ce2e6c8f0f1f5281bd4684c073e6b1dce0c8e9575761cabe5221caefecfde9441493947453098397a024fd7fcd09d966e1010f6eee8ab6bfc5dbd7d9bee04aa278b1f45a5c1c2f032cf4cd4526266cd5c6b86f26ab70ecbaedd3e449e19965017bd34080fdb3fcb49b8e4417f42417738e8f42c41da34c691dd73d8d41851e45dc28d8315a7dd45105fb335d8d45a1654115d2cff1f72b5d5175eea4356bd25ca06dbbac750cba1bab46df84bd6ca22e96e22532776aa57b0c320b90307821a748a910455668a8f6608f0b6e3aedc3389025a4ffa6db7dfb9b7d2c41e0af41784f2055a122c9c1eecc54024742aef8d11a14f2a4761a0c193e60538a97496511389f85fcaa804ab54e06a12c74e8e9d012e3f8411cce4e6634ae20406c3c76352cdec561ea2e9f4ebce97cd2528505566ae73f3e2221da4263645105277e6251ed932b95c53669e1af3fd8a68766c85ce906796ffa509875dc954144e4f02ac49839a827985bc4b26a593c6201966e8236b875341ee430801bd056605419cc9f37b3a39a463e9b33e01dbbf65064da88b7817061caf750be2ba2ade6ab4d82e77a57a9a954da9e8c672b2f2bc6d846774a6b14ca464dca5265020a2c3d9109af4285b105b36538146c1ce296951a0316e54c6b10c15bc26dd19e82e012e90cec4f9a53e951b29063cb64aa2b9fe81d750096e2df376ebe5caa93bcf811df29795cd2bce323ed13a2eb6b52cdc35be3928d79cb881cfc5b84b28a55169d2dbb03f3fcde76b22659a84e90d413aaecaa5775761c692c594f8284becca15872e5e3722a6067a38918111248d0f3d07d8763179e329a9ac3911ec948a0f0cba0e4540cd0fb072b99923f83ddef533447240217b4103c9f78d96bb2b40c5df21727a9611fc0a24e37e94684d17c4c704891e660eca2604d14a8973ad00e3ec18cf55ca5742a6c40b1dafda0b3a38e45d54352eca9c63f091d7208b8d176ce785c5c63388cabddf85259fd0afaeadc4aa963e06d5c6454279da1784f6338172dd58e08107c198bf4fe6410989ced96dc992482785319da71dcd7d2238c318ce69d4573df196b0683445f12bcfcb21b3480783058fec35eaccdf1096724a253a4fbfce19ecc2260e86c9d415140d87d05e520b33b4fcdd4115b25e9a822b2a19f56a0189bca53b9a4c1ecfaef2014321785dbafa47bf0702cee887b4895bb1700881a1e19b432a883dad1023039d03ab109d11d5c65b709f03f3ffff2c250712d3d5f668e217c28c071577711955c9081554a0bea323d76e1755ba2e3b4e7017cebcc6e5435d1db1453286c030e92f1896616e01f24e9aba66b6125758fc56ddeef17e79e8de1160495caca70aea4fdd8ffa235c276337f5b392af78cc58440008f14c29cdcfcf98a1e2c3703b26ad892d70861a719e1c1a1c9f34ddb95e11856f385690a66c00d794fc8799d03d45ff22d755c08dcfb7be19e1bace7f39f9a66a49000144116257bf7f7859bc0a0760ea02fbad9ac60abc7d79eb0636f980ce06a26ade6846250564328889a3883b71be525bf33ebd9ec3af7cefa35420d8766c80bdabf94c16a50cf51ded2eb4c9c126de56d126a04c899af1c77e8c3bbc623c45a17dba580d2e158b73698e52dbf17c48be4fd2f5fc532bca66abea9424f531ac6db1086e671f6066e4875ed4a5ce5984fe8b4ab83fe70cf0f73809364c5ab67afc8a8cae2f57e9342189e50b275b3a65","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
