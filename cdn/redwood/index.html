<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b44f51c4d9d8bf3815c60c72b2dc61641df1bc1d2c160878a6657b66621a2ac64091e2c40c56f290a780312aaf5d9465e3768916bddcc3a57ef24656193446f1909807d72b609f750b3f3a4025dd7526f6b9f727641ebddf771deeb5af8ff67f11a9c8189bb413124779910f327453a444b1e915e34295f1ef3ada0e773c73df9282045723b9394eea23b01e68cf04196722d65c551aa49ba15acbe72528e9313b359102cb06f9c8e20ed980f53489fb18d4f18e2f73666fbf15ab4cd0066dff35cc126a1e1bac08d262f9ee7632b7faa8cbd2d31379ff06958efef55a47aa0fa0cdb6e91e920d43715af608f4c9730dd875540223db0e761339bfd30654e1017c56a7e233a9e4768d1800ed0d4170018a07c56b7fd93df2ce690ea6e1a5a8e9e01d0041f73148287e80ff5a3098a08f3c731f46ccfac82a692fc6b8509247692e6ac1de78553bf7c0070d04e227ca0d60a4805bdd10515c3afd99a5431650aebdaf02ac544f6906376326a9bedac48997fa10546707af42762609a5be52edcbe8489c4ccc9a28fa0eb21759f7f60c1a69ce9a26474860ef8887b27c21935b08bad0bebb79486ab0575e2afebc52a6eecfc59d01b27e8544e3c27b922d56f2016c3a6c9712fc4d5f54bd77105d921ba56934923682697f0af8c204f3a09ad5737b92e1b895300686f9aa79af3d81687532e952f80c36cf13bf90fe02a97cbcf23c5bafb681ce97600460d03f173e0082386a6545867b34070fe0236cb0fe69bd7ec4bae1d49720d3c385fe7a378877f8bb235c4e313e74edf0b223f1d386f87366fdb399ee24d0e65b3ed2105459ab6b4ea6832cc8cc75c54d9f7b63f57be17b14dac3496d865e2e19574de0123b4c1b14904f8e72e86ce4d46e23fe983900050aa6dc159af4759c0005027cb0e98e0e48cd421bff5466b763d75cab36a6a9da94d8dbb11d44338e2cdfd9c2b07095ca735521a3c3a4f6f69a9218f8bd04a9a699b8fc2c5c4e3536f9f028cc7c517fc930885cf3f0fc7d03da9e5a53a1327dbcc2f31286f5988e347eb48737549c9635a72f024bf4cbb4d09b4d4848bbbcf29a1a02067ec26c729f1a7c3300320b71c5b3e47d2f923bcb832cf03f6fd68576e0fd650e4db63a5fa4656b153761620cc3deee62b26e1a64998042d83b369bbf236bddcbbc9d2492891765a5ad0dc3b88309f1d4ff72152dac2a2eb3a53abe614114d6cf795ba866eacde9e3d3e045a6fe0db7a63678662426d5794f4d47c72e0acdd832acd7e7b1f7162af98deb0423b04f8ddea692cef2c1ff7eda59b1021c188b051486b17f0e63ac8d00f9dc0623105345e7a77df3a131163cd4d31daef31b7bebab635b2248e4884033a17826fba7fd7edd2dd5265d6cd913c06404fa0bc7e678e9a08db9bbcab0b42da1d2ad767223ad654548cea3ac2db6257197357ad32bcc74bcafc45830660f377c517db8b66430e98b87d08ae35d95427a727b7d9ec525cd1418904d7fd630733a1cda842fb74b501acee310877c36d5cff5e2a35f6c804206142ccf95d3e378ca608cfad7a080966205882780710e0b7b2ee40ffe19c7eb358900f57f44b1aed7faf53cd2b9816f8179c5270f6c4255877f99dd65d6a88e3de126d76df623137b13ce15b5b3978449dd36ecd236c63a2ba70f97dce276c1ad84bc2ed8c697ab1e6744d4895f46313e925ce581a1a7e99d5bff3c4bd2557d94295d3e7aca21abeb62e123a0907e8bea1bc616c873b90497c4cceeb79c17369887581187602c73bc786aeed989d407364ab24246af3bd9589f6f339d7529fbee4c839f6f0a2f305f5d504c9f0153d238c454826a91ca8e72cabc5d2ce9ab6f97e0a30a62993f777d3d34b8a50ee8c9984b230a052fd85501464d7fa4af41ad538cb656ae8175d68facc1af46ad3de0b84f5056e375d6cbcb9be029c3350893a40205da85933e25a8b8b61f230dfffda7a35c117bbe3f812a605e30567a772ae40afcb0eecd99ed690df58fa7544277cc2327a129fb2e81ca8dd22a01922e129d8b39c6ec0a6e28ced9f46a5d4a67f2ba614c44863879363a6634536709da11ae8bcea0069529e3687e2ee5fe74804a50313d4e2f2292c130e438c36676690760e3f835a2c231792e0423a2ab69aa7068f5effb3b5808f82969279db85ee85d7eb3de11d0c490cc81c6e4961fed7c62d70074506e5c6c6b93a628320905cfd6a3c048b9bfd93bde678cc05024109ec9d56735d829b2885935ba157d121df7dd89ccd1b887d8f2a5cdabc1e6e0235a7012e441dd0cab0151bddc0b36efde3d20378636bc0708c70808b9e44fe1f5f7af55f543bfeb7ea46f401e5ac29ada0ebfbcb3a7eeef55596a093218e391a337226be85112d754fac4cecde0bc718269ce7dd6dfd9216e2e2d3626ab1d438de44e48c99a087dee5a555365a46ae9f470eb56870f17eb7f431ef7a6504884ea70a23144b1abe1161e6af40b1e0812f02baabc1ffee8e9a9479f47b1c07a86c07dcaf795241bf9f831941b9676ccaa9f5d7f854334712aef318f3248cad060d3046009c86aa0a4e1e6144403fc4b44bf40e7ce7b28dbb8d2593778422df95755b4c000f39f2b006fa52b340c4457a0e05cf8e3df739253fa0f834a3e1aa59fa72d9d6871b9699d2519001033d0eec330ac3df8eaea678becb405d0b55d80c872d4f5752a7110946e1b1518b3e8c4251ebbfbb8890169287d6ccce01cfe242f152fd5bad24c655d05ef67835cfa3087247d4d3487f6283ecce9b20d8b8121443722a032891e3135f35327883452ccf8a80109f65737b0aa7e8d9bf365986e0022b333d46b6069b12688bca045a741494f8002ae1163453f91f8961e23c2bf1c6488cd20671f90f32d30bfbaf07b869acb4d0d6179c16a927c0f85e2d18fb9289a39aa312b103b70cce259fd8c1cce908840dea923134bec3f18f47ea0cbaeaee66d0f4689da855d8dafd2c03673b026baa213fe8078524feab5b198fb723513531a82c0d13395ee37c8f909a434849da091828ee98092044c35f1f63e3162f8fe0715cee729e082c308791e059ecb54c9513c757a6dc8c8d23654e6bd8dd36514c4a27eb1ac4a69ed7e27674f518e5fc708ec6e024a1cbb609d52a43751656b2b31db25427a7d6a72c72450e08f699b739a555e4eb9d3400c0d6c97547b522c49fc0380180e7c6cbd2936279420bb6183f683dc2843a0adb9b7849d96ec1ef82702b5f69cf14fc554587c89aec4b7697349d57bad690a7cbeb59f94d6fa6b123ed6dc3f1e0c5a7510c7de4e517856303bca58784b39690a42b3989ec34dd19209204d5697bc85d8a94ebb531b598036ae01d2f7c05a08e8ca097bc8427375df0638711a136c22fe78f8f15413bfb4015053dcfc61588b02098abcb79c076103f9b4ad29c29e35de63a9fda51de9d3d0150cf7fabaca0a7c5b7e0ac822718e2423e3874f86982de06f21cfe4ad0e86b0cecae76be5e97d322bb3bda2b56a0346fe4a3be8d4300c0e9965b76188f1bbcbe509351490a39a30e435e9ecaf2aa8b4707f50bd668849ea12c1a485cc832c5674e7a9985c8f45e61b7d2899e185334a8d0aa742d88d1b661e16aea501971fb27544bb6c200cbeca9eff670cee0e1ec6a2dbf9ccd114b76c90a7ed1d4fcb63069b99c69cb6ff44b668f7a33aa4d7d49eb08e1ef3a3afd16bcdd3269843cbdfc1ba212fff16388cc1af67ba3d64a6b5a9bde5a7f61e85020b138b53569ac260de92b23a3d33f3971475280bc0ae7cac3281a5d996f399e44269fa734847dbaaf3f301e7385325912e02aab12f31e91058f278a1554b1e05e778c2068ff58bc17d7787ee9d295eedf3b74249745911f623c41e35bd005fef193aae4e731a5ee0a25de7c2238d29ceab6f876f9c3db5cd428146b6a473674825e0625923610b5f15fa6ca62ed0e4e033abdd66f3fa3eb1a7825aaf960d47c93edfadd8df6435168c0b9834e4d8fa3a81a5a46fe5b243e11d1708846b5d3ed00c98e080852d1f1c3c30b327ddebee94eac5a9a5ab1421a93c1313cf806440fead5054e8eac6bd06529d719ef1fd7b254b35897fbd8dfa804edffc478371f4627f193bfa8602d6ee35386a3e982b3f0d03140d99a0ffd4196d054e406d448ec21587b16d76b170e90d9a10f432842d6c70852ada430b2ff4a8c691531e65587f31aa64abc03f938865fd0fc9eeda80d394987e4b32b0f93e585672332d90dbd9075d732b8c7f52355aa8d86ed30f84c2bfc3fd5564a6762865bc741aaacb34ba23774da8c11ee6cfa0f98e5b47d951830db4ee3657917aeddfac177aaaad6c214da7b0b51ad1dafc9a65383cf9054d40f07ac96b2a4ab7e9e28068facb92e65c66d1f568de419aaac39faecb117d59788e90f317cc494001ed39879bad59de6bd765883ae81e029d02e3519da0a9e0cd086bc2fe709fc18132934ff8ae69ef97d8eb75f328cf2f817f10a5f3b2281f9dc28d525a7da6a805b914c8521ac1767f54529a66be4e26f897ac6991b96a3d8b54cfdc604ab3fb31a11caaa6f73e0f8a94cf47438b2d62453436681baa18c0295b3de261b0047d1aa156ae0a95a6735fa6ab48b111ea31ff69a1c7cff532f925142f30b5386c2bfdf73369235dd85538b9d833e994fa97d73a838ad7c670725b5104a1aa7ed530bcb2169df99fe608f907de93ccc09edbaf4d0c4877fc250a9a14f7eb424ae3f97b5a2c14360d0b597d9a4934d0b37f23dedc4158be3854357b68a71a1156b672b9d533f56191925475834551d9cbcd0f17a7eff1ce358e4de486d625b84442a7f4a6d39c9c1305123d99a62b04fefcc08ae5a4589547defd40359b11b827c8ebcd6ba3b059dfe4a656d8199eae727deec94ba512cf595e613c1bf336c1739879b42e4a74f787ae7a35d75eba4da583fd1f0297168244c3d6ffa884f2b52e7a0b5fc6ad24c6d950ea4cc4cd200ab1b7a7d664ca9718fe8fccf0c1c24f0b21ce90001e9ef8702ef46bf7b64c86582804127684c1018967905605e2caf23e1ce1a67de060cf76bc6cb8902b3c4c8e891e3fa9cab309b3f158a76cc773c6eed3626ccd4935737f97057e8833ef25915da14bb57d46eb7de8d400ab17203136cab7cef8c722f1aea12de74a4f28135aa08e3a31cbde6b69f9b37c9d307a2b42c19c15f1ce1a75cf37795b4e0c0df43b0edd21da42405ef21cd09c4156465baec6a7d6a2f7537c3dd7db8a28df2a32e332dc129a92b925d31d834179e408d60257be0c77d2774ed035504517d4e8525e35116c5d52cec78c6483ffaeab27fc49fc95fc90b5e0701cc3a223bdfa3d09fa693235b6ffde922adc44f934027a42dab80171c36c0a3fb2b5e9ba69c15d26594febbedd05deeb6e7af6be268fe161d498731de6ef353c36c2d0e8503b9077e685a5a72bdec1b86841628d37aa5bc16834aaf3a3705ce319f6cb797654451f83d26a3897d939b8aa8b415e433390d20aa8f3b8366ecceae3cde293ef4c2a4111226adb521eed77909987ed9e5b37e5fffe9347374b91cfafc6c7bd7a3f6dc599fe1c5cd5931e55b8397e575f14e9a149505e14a7d576f21d0edbdbccbe3932fa54bc1c581ee8a8abd4f9ee2e72daeff4b147a6d3e14c9aaf04fc331ba996fe21dec7e64b33a29eb64687452922894cb8e2f90c3c39bb96ad4ea37aee074fe27a7b8f6babd6a4d36b8546f7de9972f6824bee03fe9c302bda446ea385a0d0e1bd5f0acfd628b9a87c8ca17d3e255713851dc5d99eceb2fdd5584ab5c7ce3caf234eb630f4c2410568dba2b0895c56f11c3d5fd65a24b9db258755258ed54196c3a4977b1f90cf68e5c2b33400049cbf0f440cfaa0571d7fcdf7b98cd8e62b957c59291d8b51868edc724a800a225a2df5b3b3b43467d2d259da80d7b93e41c09bb87440b69fcc27ba4a6350abe2e7d428fb5634382b6ef284e8df6fab78e10ae2b3dfcde7ac6be96b3facb0db351860ae9a52159826746c01de4c6f4a47c5fd2c202465105780e285f15c54f3d2aa0c102de682a4079505d5ee83d1385dd82fc105cd5db5228a036764e6d0d7bcabf80a87bbedde2f771ca863f5cd8a89a08a0d804758a6e5cf81a3f667ecf35d73fa7a112d13146bc85aa5fe237e7b024a1faf5c7221e777ab965cc922cdd7935ead4eb577d69661731359545abdfe798bcf58bc72e5028f75202f7768cd1cc9d702f381e07f2e1a6d8f3806c6820437bbf9a5cbf577d18354405bd2b95f05f00f6cf0233051aa0f1cc33af75ed46500160db667186c1fb73718b5b2e13112d1ee5110b2a682904a5b9df63bb406e07f13d11171149512b121d6b49d121c85f7ed28df0daa6d79605e348b4853ab638bdccd36a91bc4a95cd3e3e2cd62117dae59460e7d865d57aa8a12701824f4aa904c058ca6b401285c50a4fa75f8f195907aab1b9bd5448a81bd57b4c33ac3979bd1c1222417f505b0e0231c24769b79ec4953cea4e34210f6ea453919866cba259675eb1dcbe8df43704a1416ca088896607f989a8d7cf4c8418023cff194e073905414ae21ed8d96a0e4888890b61e342874117173675dc9508e6607d919e7b5652df501400c79d77a575e23e79aaeda1c4b3b68b98bb0f9df61456e286a4f5cf670deb1304075f9c30a902c0af9d161c55d2a24480e1619f28a35900c14ab54b50f236b1817a4b9b097fecca602d42e2b712328b588c9643d92864ca1b2fbe7b9dd6334268292619bef3e1178d01f4531eaab37d98003da97d00c53783d972e556dcc4dfc43033afd2ed874b15f0ca841881748204aa7376deaffda67fc218af6ca9698b828e156856474950f9d95fcc37b02a99891f26da9bb300ddd6dc96bf7ce790e46e4f734cb4d8d65852254148b3e8c32f0a7a33099d88efef813319340f071b2f254eac6cf29bb609b3ad5bad1e8eeedc1c7026d25ad93ca1d06f8954496215ab62736a2a5d52ca534cf49ac24aeb2a05ad86835233f7d55a5e2e5b9eb8593297fbef1505ce684c53fcd4fa37cd78b73f7f6bcac7f42b57139b653162a968138641fc9a2d55dd64db5a0aef6aa5ac16d42a4fa9d7c6d86dd5bbfcc59e467176c3645750c0c8d886650ad1f34cf84c8d5c45cab5f278bc0796cd3513411a39cf867fb3d2094d9eb36c17fb5af30ecd37f54d930628a0d462ac5c139a4a99689407a6aab27176515faf7309b1dde44b4c03b74729d3fadb00bdf8d4e6c0b22c7db6a2cfbdc9d0dfd988fbf5f2506f4cb43036335545cc06c92d9d12170491c438fea5fca71d0534e13bbf9b0a297b883cc9fc8fa5b27a661cea14c212160e5b1900a43da49de02126622868b170623ed58d0aafe1cf80e69b6ab3092057f844fc16df6aacd82cc1df931ecae3d3effa509340e22a4fd29828845475c0fe85d1c1bc42b4d8551e8cf72e0d67f238556e6d7805d3e6c724685f35fa3b31ceb32d94f28041b2e6f116dad58194afd2a44da64f4bb92106af9d31e4023884bd26b2c7a35b2948facb258968a5710eabd21eb803dba2721fac013d80f3f0bcb3bc7a02012e6ba9e8dedd03fd574850ff270e780dc954f7d62414a1d37ffd888b3bf0ef8670830381ca28fa24176fc78ecff6982dee3ec0ed419ed41fcc7276a068028973dc3ac990360aa0e88a0cbcf1adae6be1603550924e5a05d5d0f44fafc5f926f967afcbb44901fe7f360f651db1251173b03b55c326f944697accdc9b78b2f90e4be211260294e8a0fe02a378c4134589ffd2970df219bd4f9a5aea9b9194596dd4dc61032a1f46466c09abc0a4e5f5309f6f4a5f942df81aca102ee34d217d9d0257cd1fd9a12f665a197ad60bf26cf4a6cd6d24ddff7309be2886ccee45ae73a72bfba334b8ff68654fc6be1dc5ca963ba94c79ceed8e8ca5fd5d1deed09f09bd7bb24cbae3ab5ff554b62a12c8e4a25e23677efa2138fdd50b717462ae37495f3ea232749619ec9f569e526ce2c88f796b27ef78a8d91194ca9d5da8f0c86207cb4409ee608867839deb0af9866eb866458a125f5e188355875063c0c25b46b5941b8b7c2adfe5a52720c45d41f8a112388c1510371527186236dcbf0c1bde8583c065ca46477b2a0a297616eecf10fbec03310a4e76930ea4f815439186ac995a27af76bd60c7238a1885f6121cc03260c6c3f80202670b1fadea46ef7f6bcf40c5ee9c569819686922fbe8b4aa67a0dfc7875ab0249f21f1741dba3a281d4de366dc2e0314d28ea48f7a02a5f97bd2ac0b780052b2846536ab08c6a4e31613995811eeef585950c14b6f0f28ee1aa821ea8617ab2062a3fc6becc88199eac62ef2aa59b58af0a708adf1f70b987fd2f47c18241e4672d0e98d75ff7052440dc808c8602a52461b483d43908f0ff1943c0972b925015bf5bbc69289d8198e23e1bc039745175d609be2596aeb3b913f8d2d75efd083d47f06917dd523c6845763aade3b0aab693842404f327e0f4d4d90cb88a05f98de4cbb46588940561c23061c5957b5632c228dcf209d4df75f06d87ec2da6c7c84ca4ad2b3cbc86c3b8ea1751951b40ebda3ab5eb0ba48d29ef028bf74ae14fa33a9d161597e58833477a4013332d87db2135749fb8f0b84a5be37eb8fa32a2f79b93e9051faaf5bb49e1c4a2cb91de1d1d625980e010e3003100d38196c0250e97f7ab2584998a28429c5628aca066e8c73ed0288fe0f34f39dbd45a74200a0857568f2fdb5d68dd509e7c3e3f4d39705993e73709e9cf557d0f3b5e00df79464cce623cfb29beab60c3e386e300693ff644233736b3683597eb7998906dd09a5c4d532a0d80c0278c77a00a1581b26999035a6e698806fb108e4a484d5d1cbf64114bb2701a7fccf65095d3126725373144a8e89a74266de447ed8e675d5225f40c53f32c7f4262e15336c6b411ef2957f7a3055c4b849ee69e8838e999dbf9e6ba88498e21599ba9873db519de496b343194e4ad3aee3784e1d8649dc9a101c7147193018e94273f3ac14fb31d21a42ea1ae1d857c988251e8b2c42cbe99acf0cfdf33f3dd976ac1563ba11c98e52b79ac15be5cde2796d94674794f6ca83273fa76f4815a140b9bbf9609c6338f566137ec4b4df65a38dfbf17f2f369d8e5ca983d749a206330338505627972c3961c04e0c2d60035c08b4983c81a63e5e1771505ff16bd77d4aac6e719b6bd8dcea627cfaa63f4c6399086b00513a026d7756dff8a6d7bca06d017a4dfa29b22c2b00750e2d4081b8e9bc9311b30aad22e15558d9653cd064c140567e431ec53cd7bb8f3a256e6edf6e154b08da730cff0e784149be35e9860cd7e2df890394ad88b656e9ceb46cf225ecb1e2459be834090b8bf3e4f1d539ac95a274ed475b46c9e91faef505efe4f8355bf23df4a24ccdfae06f6b580f07b280e98b028ff711a56281828e2830b5e37e02615bd1007fc74f8567b235bdc02e03574d7908d1b5e475654ff14c0836c8823a408f429187cd0ed12f3a37ed3017e2be2720802a67b1b3f9b807a200d69291862f00ba6e4dc7bb7e0ba510841157fc5ee87ab8845d2e78ec56855cde060caa98f38c77113b7a57f2ac5db9b0913cfaadb96e44b40fb2d39e40c19f0e0485cecf367629ff6f2436bdab75e85c9139fb6d78b74a72ee184cf62fa99291e1661900c5da4e2580395caa55e48b249bad9f74e711e9f77f4192355e11e3b75fda9be44a85c0d5ca5f6ccd67e73c0ba8fc0889ef467b7a4031e4339ec0e47b31ddc96d74da52a585d432eb5140474f1dedc871d654a87ab5263a47cfd328cdf65b29594f77506a85c4d72389627743fb229b654faf31fcb02616b84d87613686b0e82e2dd8523f33fa3e8455a86762f9fe920dce0ce3f8ae18459999d70130bd36f2f31b00ab4aa0308eefed5817b8e7eb877e71d2f8f5c192d939c2e6ef9739c979dd4b94cda55cb1dd3358fa63d59c1071d24661ac6266d0b947070a2a3096bf9e3a01a0e979cb281e791eca70c88959f395457942c9f1fa617ac8c852f6d8b32ca238506a389c42350c73008f3617a852e372a16cb48bf671d12fa2b42594f058dbb85ac9ff9fa92a5ea84e4611e332a06de3be6cff4aceaccff759528213ecf9765c6174b2762e3319951dec0b572c33c9fbf9ea867b0e2b649997041346488b41eb075635fa588dd9f21aa77b1ab9a3edebc0ca762261fe0e22b93881a67fb92a53c597a0df57aff46f262b0e726417e1f53564bbf0a52f438063f57615eb767197da968590502cde4dba1f7f04c7e94555ab9cefde35e6587cd8ae9a58674d13a57674c63cc7d4224156e727907b8732adf6bbb56d55f200d9fc3288604226302291a3e33e4cd541103d2170450fabee49ed5ca58afcdfb299212868ba86036e019fbff11438321daad0458e430c39776d89b8306b277a3679acbd2d11f2c65405fc175ae18401bda0e30b3d810d03923a0a1ef7207380ab805b97d79b582d3c32c638c0d050ff97ff86277c0da16e2b7b42ba4c4119c2d8ff05cdbeab3821e9d786ea7a8af3dfda582991898dec43663c3dfbc3f8cd6ee2cbcd63ad134699ea062e81b8bd749e8aac92af2e8af4ffe3a820a1b77497c5ca18d060c6230f741e55e38ca53e29d07911201a6fefd34a255ad5d7d61b4867f52751055af234efbebcd0de02c1a030b4d83ff92a4f9e05fcf51a16975da60c98991d195d78d917d6d27e9a3b7bf7bfde4fc2520a5b0e4ef74a44d43323fc49980e93d9ebd43366460d57bbd8199707b6a21fcd325dae34a7ceaba198e7539fe82122b3d40d49542e000e087a95f5de4aa09673ff0b224fc2bd7b2601540344dc7e2260cb1a57ac0c074d52a79e9c733577fe6be866c4ca2688552220880b371725caf494360bcb76546befd3931851238451986a67c6ab9ec50085fe23e30ab51a39bcd8597e3428e3333f03388150084bc32d7cec02790ea1834178d68b7a801e8bbdacc8983868e61f912b4b83c0d50ba75ccacce1879e04d6220606662dafb06739e1eb552127f06a5ee8c96132413c6778b578dda1136a699d1271799a25ff95fb2fde08c4e73dff183751045f1106dd734988f28e5f3004a63e54230b6cc6469cc928ba0d053937725c818e3a5ef4bacba17329440db55340aa13609577a22c3e602dd1e7fae3c5e61b47c1077c3b5631344030c7349e383f255d5ab141b67dbae3b43073f61372485f8e198698c989e94240d7d777ded2d4987cf0597f5d387482dec42f34e94cbb67550aca19afe18ef698c7123a76fafdb2a0aaf7ec67ca77e38102b937484809d1993f60aa9a62c98f45ceb27762a3018f5eb1822a8dddb35ce7dbd4fe7e5ce8d1382edf0020ee0932d7dfddb9eadff9099b47ad3106c1ab9bd39ad97a87e179222d85d88aadd7f9c312c76f2f20aad306007a531a81b33468788fab51f5650f466ed82b9f4bc2330a8bbb55aba66ad0c7d10eef6616812854191498c7764303f27191ced682d120d6753204df2d5e633b629d0aa83c15e9ac6942076aa253766a311fa474409fde2e3c6ef2786d8e10a67a604f78b7ce11a59c8f9651e319ab15bbd45e366ea8491ca85fe70c998b3dfecec90b2a6be210b1c0b0ee0e284ec2f40298a6e60b034fd0f35c2b24b807f3878bcf7e0b29981ff7971ce07ae5944f1b15ae8298f05e5705b4774a8eb0736f74ca167fcb1eeb2a5f8a7dbfb53e72515c99b492133db9f2a7b2f75ea8cd251a5fcc60558b0ee0d3624bee5f44779245d925f6e2bd331de37f3db1b05c70fc7cb73ae9b6e7e5887ad68f6e88b141efba161341914fd33570646d171e57ed2f04232ea5e5c20d7def5232dad34862dea1a810f019999a55d76eb69c95fb6e7347efa868f0fb0e4a17cef571a01917d17ca0f80a1241947ad357fe802442b11e0b788e30c1ef1491e50df0b76718e987ddc83f8cef4172fb99dea32316f5f3263a3ad95f39e2e9e3a8f9d3c2eff8773bc2e0c3722b9f68e151a672dd2c8b5833d4cc597b82a2102272bf149ce803b0654920672405c84fc07af4401c7c79167e2f4b08bed73e58bfd7172fc56a7da6d625d9cd01f3bf498ffe6f088a1da5aa907bc6dcde0f41a2955fdc0d692c8c41c8f7c3eae87f25429361d20ca3ecc36724e1b98a635e294d7b26300cfe7b916c0c2f996208db3f451e571a5b75e9bba354e01559a30a21f86c2fca98dd622c77bb12191561357fdc8312e542661abbdf7e7ebb792eaf290f02b1d92e33a34e624018c012603603c7f5a4344d2911efbe8e74625045fa4671e2498d02ff714390b3af39ed07609ed73868f3aed630141eb8a4a5daca64d5ae428f79c09bcac86fc767aaaade7df1d2c1169e23c98a6f7018a9df2c1a5e2703c533905e2441101eb397408f29b92607994d807f4600a852a01c01bf9223b5fb1f324aead0b6c0573b531266015b6bc8ccd3910dd2a70694e1b0f270377f473cd422a2b9f7cb13687a850118b35425f98ae7f53dd3dff5b2b5d1c8bdbae03e5e5e1edba31498f65d9cab982707894e291f9037dbb0a57c916be0a4bbbbd7505a71025133002a10518f5295dc265d52ec791af71a0ccb4e7d2df296c689ff8a7ade1426e883d3d9878f17de3ac6949cffcc253508d7cb9a39ea91a0fc59a3aa276e106aaae2df969539bc867663b5b27ed558526bd270283b607638e74c07470993860e901f6063bdfa1adaba3f3669c5cba8134c8e6fe9112e47f7086b84bed205ab22106a1d95442a96b98227cffb37798a9a8f7318e0d64429fdc1465e4ecdba53cf418fdad9f07bbb11408c152c6dda3b2ec5d4655c178f2d33b721c99a6dc914866ea23e870302babcf63f2347a44c2f0fb5827cf904253fc195f596374389c13782df022d638667ed9c5cc16f0fc878791c94eba02a49f5ec001580e16f20b6022d075d0150ccc643cf411fde580c6c0600482eada07f69c90d73febfdeca2ea489afd34d5f668525cd8569ea3d2c51a7fbad31481c4553961c83920360da20c48afb80dadcfc857b5edd4f73a3e2531473384f49dc21da5460c65f9aee9f0ab3ced7c70714ca26f6f60ad7b0e40d18b9a037988d9bec8b089402b2d201825160931926d9bd733e53d710490450aebd8d93c732827a8174efe03f3cafdd670b2ec29f7f9cac56ea484cf3f94a9ebc96c362194d48827dd9f3aa9cbf3e8c1a9cc14d1c24ed2a4d5b27de35e448970bbad64c6ccfdd05207273aca43296727b4cd0f8ff62ee6fa7609a7b2553149e2cfc431fd8f83d7220ea4b166adbf16e47d55274e503f11b7bf24d6290880cb12fe594551754f35e25f83bc695597ba433dac88b83e8296c8ea9d336621de6e7579a90ac123aa48040c00e5b87c5e9ac1b9ada0e1e18eab8e532b847e98475bbefd6c6389caf3176b54fd277c6f36dcd10542f2154000b4474b70faba84f0a7010d477164fe9a52cd7a4e3a0706717ced0992b9c8370f01bbe4e15efa85447eefac8b71f56ae7053ccf82b3261923a32af53cf42e9b031eaa585702ce0e2c8f4fecf96b0a083dca93910a20cfa70119bbd33eabae7debdeef5a80666cbfeca2edee203ace6397acada1dd88786c5341c322c3eb3f9e024cece53b807fe7744266f0129314394820faa3ce227bf01e0aab00cf1f33535d1f860481a8389f05aaffe2c4976e2b5cc5938df2df96afbe2a030b5d16af939d39a2771882cf9a88493798366517f72237501305eaa76df76e6ec2fc0d9f3e3e1dc1ae80872b2b2aeaa01d53bb7945d519e2b3a09834cbec31ad76a373fd6afc7163b5ea2ba4cef0c5ffb8937570ba876bf8d17b1fae0a3b17ba50b127967198e83ec2dd5b3dfc137c4d2071d4755f32f8896a9569088a9c5dc2585b6c8c907d70971326871c25009a94385dda8f08fad35890120c2299a6d9d6b8dc5d07329ed4993ae950c6e64d5cee52730cd59f96767d81fbae18f48684799869bd09bb4082da6f6e5d9dc19183d57ef0a723754e0dfd7da82d4ee79088d432744da6fcdca8ebe185e9f6009216d0cd40a3aca2e58f356b2911e42ae9c19ed4c48e5c74fb54521c9027f291da8a30b5a09125aa46f46ac1808cbd3d3453d46eb7bfac48a45fd740b42dbdfd40c1bc6a9605234b678e5df7c36ddd29239587a6f677a9322a5e8e2112748a52e040a67cc4b242c9459c3fb12f00361e17c200564277a199e6e55c4fcf18a044106543e83e653f1144386851e82ed5290ace81de2974bb93e361a270be7b4e680ff98e59abc5527c87b8f90c559724306a52bd4c5fceb51b015b1fe4940e4d49c2be78e3da0ae388e70063745f11f99fea84647d5bb9976f704de1f00a16bd887a1c1405e08ac111ff512b4f34b68e6da8734e715978e3c8306bdc038f71ceab38dd60b8d5189e260dab245a2534f93dfcae87dd187add61ba6f3f8e0c7c39c7c439b6d6389cd734f362620336330020f134e3fdc691c190aa5635cd89503694b1b4bba35825953be876268353421a3f3fab10ce978b69b1348445c19bdb9b4dde516a013d80b45236fc092f0c09566944ea7f2cb1f7cd3837d981956d546e6abc2fd79eb971d76878eadd4665f4b95eab5b30006f406bbfb17ffdc1360110567079bf648b65d07a0c0c752f935277edd1c12359b95bdacb84017a78db4d9a03c0774a09d448c5aa3d6b4cf42a57b756d47a0083db3b9d0c53d88dc7605f697b9b1903f3621cb99889588f8a8dcd9043e138d7b2742ceb5774d70caf05f0bbd45b78ad170f37976215eeb4fbdd67d9c1a1dab2c28c556442b52b7260a566058b7f8acf0cd6debf66b52f02106ca33d841449501f0e2f9cd8873a9acd8522415f843f4ead66c3928762d07732077d6b268ef0b685684ae3ae4fec010e39244e518cf61d25d46a03f5310a97a38adbb87d3074ffcbd3b56753fd49c20b848e99f3ea7f6b64675862abb22bd3dda4c336eff1ac271a5915defbbdb3a7d5b8f25d135cf5c1f9c4e0dd5d1feb122e5531e78446fb0222da7d759a19c1205a4c0a060c9a7c53d08cbeebb0047ed6f42ca83c8dea111e6851a2a6d2a617a3de0cedeebc40f9304f12d8ab40f449d1603f113405fdf4a301da5c1e2e93a359335b1052db3ed0c6f67dde5f9699265759295d0b5565dda627319201e4d5f7f79ab9cd2784d4ab9b850625b1a7353e61dda8d14e18b681efae6e93077dd3836f13bfe1780da4aa074ede6fb15699f318df5f3c741cc6e930ce9889c0592cb22d6123d81fa2a602c4b209af66fe06be87fb34a093c9471a62354067433fa794cbf8c1fe5b8c2018cd204be588870e82a6721c372b43161d1a2204afb4ce9b5508045cba785e83a449ba961616c9173b284fd878cb03161eff5347d7e78b9d38749b61a5706db44033e3e3be165337babf40910959f1f3c2db7664247b7f5d8ea5842d221b88875f9385a8f61df20354ee61484cae96f7857107708c3ca9546a88686bf1aa7451893893c7e70632cbe36ee8d5ff6eab22c167c53c3206edaa651a90f00f84a54ebf0b6e6bd26b4699f39f8dc1ec21ceef18aa8730fc536faf600df35106e0d5a22e3b496b6469f702803ef1234e63e23468335517ac0b914c3828e010f28ffde085cfc4979b01627246850fdbc29564c784f2278c020c5088664b44765a2e5154c88a260e7ccc782bb682806fe195a6ee9b49db692db3f49e8dc6bbb9b2294c257d8e4121c3663889c29dfbbf089c632f35e74585a8edbc7e373b9c1e457b8b37785dd3474d17db1ece36fd649c13760f14edb42c53acebc86ea97862840f2f3f98250deef71dda1b5a4320d2fad29d44832c1f23ef0380a1b2e8a78f497759016ba12e806dc6f98abb1428ed32f5ab0764cb6fc24b24182c9e4b218a9b89bd48dad40bdcd98b598790621425711c1cd636d1347038dba2b1874a7823868bb2157e8de31ec49e15c196687b2283f8370c2e271f8d2596dff40d3ab09c20d776e40a0f4d5ca4c8a45d747bef08da5bc28e92d46c7cd6f648c6aee375970fbad3e3cbd591455551314064a8a4ee4c355d76e9b2ee1bc20902f0d1d94749425ba5a66f32c7fdae789d0127abffc053d2c3c58f57f277eea82fda984025446805d1741ad3cb5e8de303a0b8702a34f5ae58ae0b397c4edc01e7e9abc7753e19b6b9658823ac8aefa59aad058e8490c94af062e5f28bfb3ada72c64c816659df49f0fd7ea5d33c9fc1542f9391ee704e90927fd9a94405f3c383d6d9ec57097a99ecca9f0b5cb736417374912149080309822cb790681d5b9dcbe3ab661d4944d3d356c4b7cb7da01b8b9f64f63ebbac15c1861dd9ac4fc65f24e64e42d1a714d751d7ab2c2c4d55f4db3ce645a94bd6ffd9165ae4d6f96d6fb1953ecf3de829e192b54af97eb86d2a5c243f70ed768485582fd58d90cca50c48f588b9d16860c29647a386e51a028954cea70c9c9ad360334d51ce2a0c62b536417ab7356ae073462088f03ae0d08d11d9ad0c5b296f0b8306859e34052e3a93472bb51036b90bd1cd6e98f8804cf8277091b27d00f89df4a1b05335fd42543079ccbf2950c5004ad7f4d0f6892669b3f6898dff29096391c6723f7f392c90527d13ec271206829197987d236fb8cf79ff1b518ec00f687c5717e852a7341e25de02099756f8ba7a8d30d2059eebec0c5c3c2b9f2551b013d472a0275b3f5bdc8ba3cf58646f75afca79151db350b9926f81f2dc57f6284eea7077d03ef4c497a1504dc2143c067a67a931961c94625582b2b853bda2268619ab0984267c9be117b808a78f46beb07104a8349ad64aac94bd37ec42e398a8fcb76fd9319d5a895b36fa4dfef74b620888b584f8567906c09a41134b9af9c90e8a97f38dfdc2dd6075ee052b0f2a0325219e42d7b0564a5cf63c6658ccbdcf5bbec3bec3602f249c005df80bb9c6bde5baec0a7294f7c9ec0859b9a09a3f8376d8184270352e58224930553782005a42afd5ac5d025ad99920003d69ace6b44b9d90faf91ab95733f99cb5ade59f6b0e791264fc5cd1151a26de12a5d9288597c1e6361cc7ec4a3ffbba8b8cd592a25b82f30757825438862697492be70bd9ee37492516ce19948654b28ea01f9493807cd8794d5e5d0ae05fbbfd840418661ba4d427f706776221e49d6ced01dec0c4ef50f1cfa5eb8de4796b5a6988b73ff4f0ec0309af946b509452537449c8eed6364bcc9e08e94b4e364231bdae2956efff64ea1856378c6cf93cac0543f203d3d7dd7ecfec268d74ae0fe628d856f884b14815b1d5eda92589fd8f48871cd986bb94d5b9ab71e9b02496cf5b28f911a4a60f7bdf22b6defbb986e524cfb96835059f1e302d11ede22b7685716cc3a3ca1d847242a0c7ec0cf8a59e4e03b9b0ab773d17cd6fdf65a84e75d623f4aa5d974d67e98cf9aa8928a8017b8e0e61b42f01af716d252c17b843e5e3909018d341c96b141f55e1c3e9bf2d4d20b7f45cc5a63e1042ede174c72e9cd5c8bd02b553a11fce9cddb486c9d47c2852aabe3bd737a34dece1d04384ba96d69a84d2678b787dd4c65d546f0346940d4eaa69df16d08d07ff8ba5644b10756b8fb79e548e7a3f7d4c92deee71a9f12c5b9d22cc2f26dbddbeb3fd9da7f93228e8a73cf81fd004cda5df06e3a1ba1192c6f50a52ce37e6a4dfad66c2f60538bbc9ce8c1863439b303d6e7ec3f4a316dc22246daa11d2cc5ae13f29af66a1080f6671fa6b240748f6842ad977d5aa3d636cbb3d693d520af37e0391dec324af96e82d443188781fa280f169100ca826096cb5279da9860357458d6144a6df878dd772775020ea31b3f4b37d5846127eb4fde62037ecef05636088c652c1da3f7bfbf2c86133a223c069a834c43e65d08014589870d0a7bdebc34a42ec22d9efab9801aeb8ceea68a8ccb1e81c684387c9cc5243f5481d0e2787b90e4ed3de14f7d95699e22d0e6049d90e2cea1b9e65b8d45e6ada45086e66164e37d131d522ec96d94fd2b3de7342c03bfbefa3233aebfaa20585f7e1b9a0020d23a5d440d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
