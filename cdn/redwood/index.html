<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f9ffc42aaf307cc537d7567379f910cf8d1feba66052e354f4a81c54e4e02e8ff1d53640d1b479efd45840a6d5799f178f3767f95f53542e889ad4ee3da5c9eb0f2bb035e2ce89372bc296648157c5e77cb650fdc3e88b5eeb2be49c8a7510c2364acf74be3dce1fa347879b1efbd5f56d7283bff6da886c4b7b2f5747e111f625c98a46ca2d2cd2612ff7277eed6ce34c5093a7cc1f828cf4ccd9a4dab36b87df3b1e4012d43e65d552bf239f05074eee1f3320f49099a71227c09aadfb49c20affa2f73e4c77ce5d1858d96aaba4a073cf033abaac10bd6354c4de34f0e2df8f64055750b3767823ca30a8dda15465fd8c330652b55cdeda844e98bd375cc68b48a2f0551361c1d64d739a4da932915ac0ae1739f55ca471f298464348b2562b17f9a22e768a7d0ab5e642803b579140ca3dd7b2b9a70e62074a381ae5c3ad8b617de0b2d3e20af9e7e2ddf65d7c92534d3fbf1d61ac6d58e174bf2fb3768560c5b592a54e10432c9c194104f8323f583626e88c84308fbddcdc40acd920be4b213337b9504b411e06f2aa3afed2626e790c18b08a37302318c944215fea3c2c458086b1c94bbfa6dc4b8585ba1ad0de580953d7c260e7dff00242eb0e262efb009583c9ff678d149fcba70fc0355fe5b0b8cae5df3661d9a5dc244e264500c3fb6772d25171c25236fc9af749d0fa4c8be87866328c863a47b9bd322a4be4122dabcdd833485c59c5df65b42cf29b6e91e457e722d237fc9727b8cfc7d70bdb6e4d125718266e3411fd09a83fe2761ec9d0c8e8a744711475321361773be0be7aa1f0a692b4b8afd3d546f77ffcce75264ee1a033068b0401e7928470593a62d709eb02ea6e31e5200dfecd93de3ceb6443009a40cdfc10625bf0421ba21218ad38707349c6f8fd49cd60fb299c9f1ac06c80a452c45d1299bfba6ae93816c09ab1f97bf82694204db585289abfcffe2508c7b542a6dc4278c78c018cc12a58067a49104b0f00fec0dcd55a6dd82bf0c919eaf30309ae6d7accb8281f8db370026cf78d72b2490e4aaa186c0bed8eb3acf5768e47136de8feb3afa0433fc530852b3dc87efbbe997eb1ce525b5971681cd16d82152146d55db113207197f30350985d9def61ef1de06f85d55772d176a34846e71d5fdede32b842d93f52382f8475559cdc09484dacc108b02db99e058f6db960b21f9e1819277b8b16c2e636d42b795a935c1a517a094764f3767ddb23c46269d87457bba5962440a6f6fd5e1b053337b7656929a036ac87edf71e44211f9541548197b56a640d142e4867ab247fd8d1f2e455ad693d7bd4ae92b1cd541e1fcc843f6c31dffdf230d32bd43dfea67120e44d37a6acfe30a880d4c0fa05d7bfde56ed24dffc930f485f1010f7bb2055f507038927dfc69c5819a0ce74f695385c2dd5d02594279e8619b35bb9d16eab0c76ab1f5d7a494ce3594e95fd9c0507412ab0926cb6b5ef7485c98785afb571ada42ecb35827d15cc1c4369632ddff62e00b36c33274e526296a30e50a37a3a4c8e5d0424b351c23641ebb8ecd0260902ab1e453f4c2ed2a936d86aead062fb56ea52837b9f3947e78dacca30fa066eae57e2ba8caa10b755d2c16429c1d29ae16c6d19add198edbf8d22a24f68a796e6b5ae1ca0e7ad20ac67d263da11b8864ae1fdc0942d056ab361e5379e48a9679f7111f25263f167583724dc5bd6b1ea93e88a1680a8fa4a29a88e55ab20079816a160b8a2b0c647f891b4f9a493709269c081ac3208bd48357ac8db463172f8808b37491e239db5450f438af93470b35f78c055b14d0f41c256ed08d8f2a62ebba78218b06e23138dbae378320cad3c9a7f30f7f733a6cf72130a02e702b45e958d6d80642d31da7263db83b18882763ad5089c2f848838b5496e139e0c83ffb5a8a2604c5355f4b255cffc625a2bf72358e10d43f587b378dbd645cad6a302b8d8995a593b59c469ab8e8b4af85cfff2a490e63d6b31dac591ced6dadb0dca174ece2bc3fca471cbb67a56d453325530782c52e4005276eb5e8ab155e22c0297c18c0434200d575aaae7fcdbccf17c1faa39e8386b911c305f666a3d811103c57f83b3643a1a50bc72529087a39bd0d92d486b7a925c719841f0bbcb10a123d577ba6ec7fb1274fa95dccb777180e333506583c1370e37264697cc1e8cd9a162072778de1143f6c730ad29784e229efb02ddc922935b0d7a29e6563f578b5b003af8df3e2d653342d6518eae7df96e5a58ecc5fb1ace86cb80160be35f452852b15f5de5ff7a8d0330daf3c3b801a8354b2b81aca54394f5dfe7e0a8d5084200e0cedde830299546d804018c309e8dd756517c07ccaa12cefe4b66c9a7ad565a723dd3d586638371ec91c6fd599195f732e9ffac771642569ff60c4880645bdb1f70997d7fed088aa3cf611fc7ecd5355a7f5e6c66a1ea428d789f171d5b22754c6e1721dde51146c7f48665e4f07cb489bd30abaf45dca42ec497f2187931bcace1bd2478186f4f88c391175952b548a29cb39df2b058666e245bd27f2959c76e8fa9364c7226589cc4f774c65178d05f1b834bd0aaa747380cb75a1a49e0a8b73a9d7bac75e609acbbdc23fddee2137218486fa9d099bdb962c61aa850f4343b345fd36b83698b5d724c35595b18dce1a9dd3f6ff01b5f224b457419ebc08cefd255df835b204fbeeb9564f231b90d6c0a9752b648d29e8bc793cc84862ab7fd0b14a643ee6867e22e43cbd8f7a553c1530575ade6c563f5328501578ae513b1cb92fbe124f4d1a8b1df17279415cbca8bbeb0d5ba5a80dc583d63fd9f215fcfecef1fe6dfd0f87ecc3e162aac12ffa8371271f795e3581e88b3f6ac6ae652dc3bd4290b2a87aac1bf25cc5614916ce8fd248ff78fc4a4b0ae6bfe3a75620c31bfa759402e2c811f92d511f9a9ce19795f93e764a88e67019ec455df8827dccafe64ce8e6c0acaef229ec70c6d4c5471c68433690f4a7ed40103733e106ec84ea35853d509eb98c66c487566c5fcb93ae9eab1b98f643067623bbcb0531798b2cacc0d8b83c0d3b6250b15af0766c4ea5086f3775ca2deae30fe210bd6c549b3ec16234662de46def383f9126ba6a1f7035755b2c314d2acb9a0c79c41e34a158d9f58f763718fcf5d92ab174e527deae612c9472d54d5b50a446f4c3592fae160e3f0e4fa49b739dede0c2b2d3756ce6f808a165839c6286c58c8e9e5c4af7c354d53c67d7fb18f423afde1316cc8acb86f6d77ab9b4b1bc53a65620199584fd47e8286984921065beb21e233025bc2a0ff3259dc8fc24d2fb97e45afa914b932880f7e3a8f36f3924791022d10a2d567b4a21512b703d80f0827bd47395338aa021afab8b5f1a24ff54da987f660079c519d9e73f32a7acabfdbd5f47bcc5dbd5cc2bedb8f34eb48d513e662b93fe297bf977f831e40c9566bb26574a767349da67fc7511a80e087b8110e6266d258cad478275402519f9aee705dee96cf2182ddb2f2e71a596b8e4e91dc7671594c87f3ef8e9a8c3f322c8bbfa5d675d9b1821b9d0c9f64e377b6609499a7f29e4e4667b996e41f4e25be78885b91fe521209152357e175fc1c8f401da0b907219f49cb608c4fa3a0db2643e1cc9b90f2c14d488551f90d63eb699caeca24003c06936548cc04ac0686521304e41b22e1b4e0f7d7c95bc41780c92c996992ab1017159e259d57eab68d3b0d690a71c328e7a307e15b481e404a95157cca57a567aa88b0147ffc7fc94d3a973fe5a7970e3d0094a0f219045c93e42775921df9b0433497e384440398afb3447cd7476843361201e01e19754c43502600dac0ea33221ba3de677b5166f447117eb000a3a12fa183c9ca9174d80ff1524837b8282a88430d119086778376813d682a40848a2e3c476dba54a5641ec9cd1b967d1867b0315a63ff457f556b2ac26a140b45c39d1de105ac172949ab15904f74017bc9979593748b342ad7439812d1abf93793a70b149c9ed782209099add391e793030eb7ba297baab5acb512fc49334313ff3d55e14c130f519c6cf064e678acd5a311c15a4b7389dfbe57daa2c9365a0b9261e4651a231d28c265e7541997531bd659944567751a0842f8470ed207b70d8e79073bf2a0c3971c8d339bebe956d2b6031037d86ee3155f4cf8cee53f92ff31d6519d0e75a7419bd327d94928a696a78a99d6ca161edc60d2d89df4c01aa87383ab57291d93abcd64a80e27128c48973a71457ac7144994505cdd9e5418b3e3765af6a739d6b1f2a3c488c63bd0cc1ebb06ce7134088fd7cf2095f1a13873250f69513827d730141edecb0d50d611419115d865a6849fb3efce7240e9ea4eed2b8a6a11d7f342a74b2adde31cc8b9cbc60e3f6643252e566454e9f36a6338a7c3881f87a66bae012ab0e6c6784fdc98ada90d2ee59aa20327d7916b0e38dcb89a207861ceec330cc80a444462f73353bf14280c6d7a6364dbb12244ccc323eb937b93f4df42130f7ec3b6ef71ed9a0062ac3a25e771cd2eb6d035e9ce866f2e5112394753db4c46cf0d008d8bff9774a8a5e92759d95571b6c2b4ba65219c7872369f1c51e313438d59fb0917e6f7e2cc5edc28fa70116926f016640ec00061a16431863d6e233391839c228bc8698debe36f80011f7dbf34881d60c86c398d810006ffb9400a7de6a5fe024d070016740515a3ecbf40c8c31fd72a74c60cc95352f72ad4584fb494e7d82c8f7767ed86b2b5c1417400e2d8a490a561fa2d4ff5359715ac9426f99b4c3ae643f27f26ecf1c826dc91bba3d424f1fcba678d760a0fd3c8e465018e09063b9eb97acef3ccc9246ab7ec083a5c2f03446d967364d007905cf2a80585cfb09417e48c03b55967587beec338fda47eb45a42c1e041b5ae4c26d1ac9b8f70ae33bde65c46c6d7d508e45c943cb65e7f737ee63d3d48e260b06a3a0cfcb40fd28462f7d5894bf87e638a543c7e6f7643cd7eb356e4de8bcb1e77a7e01315a73f5356da09f8ede5c119a98cadb11e8f81cb4907269448e6e93c9afdbe1233c1f5996e4c847d6ebeb965983d0224fa80abed8093fdf61a82a2d3279a23cd65e5f0aeedea315b9a059ae5d1bb27a613db43a415e0575ce199535b350757760dd19c10df705818bac8610177cf22915594a2a66d7410e431c3871f733a5ed438acfab772295b44b987740a3a2e1538dcf0c760b57c36693dc36762fe750f2f8cc0805f6d2d2088cb4dda9c88b409282a5095002a4b66c22559a2b419ef5b038c15b5739da8334383af3ae18442ac434ec3b200ea16f694341695ce29ec63025bc49e434be5e487c42b43a785c22e76dd36db6ec057eac0f969923fb63da2757070888a28b3383d5de3b040a8dce23948f81f1917c5c2b863e19bdb0ad0e717756ce8a4f76efb57a30c32de4bf9471ca3fec33c8d17b6ecd86b5759188f5f2ab4cab79e79373191dbb7c3eed123c89062497748a477fcd761edb5896a7b8805d0502cb3ea76deec4745243d52eda63e81a38e28bf8a2e17885720c6124350e5663f64b23d3cc27245bb93a9ccb5a0fe2b0471b5531d003b0e4d40edd752380b9af5f592ba4632d8c145e83f9a9b8c15c688f07f622d4675b79db768cfc7fc1fcd60a6fdc64376b46304ed6d4b27716566d4484ede04d1d8449604c3614618fef60de10f5eb3740e20168a162d8a264c01e5f8973e0c64af3bdf9176d98d239551e1aa9181bc3d8a76c2f46e83e09064a2c85a0b82271fbfdfd987080f80937568fafb06531efe0f250c6ce025fbc10710aa4cfdc16ab559bd0c51adc76da4ff1ba75e5c2edc3121893e496ae2a79676a417ac9355c22f7299996b59c57ca6d1e05bfacab5bdc1241ef4e12c5466e0726159ca5f7334d75349357b1f430ed90edf1b6c47c8c1aa024722d10d837a0cdbf5da8e81ec7ffbc01b89520fa76b0f40c27330ef49e11480a027e5db31c4e5ee0cce359e29a472ffde72c3b828569e92fc4b26ac0c9bf50724cc46c1ab07249244a54ef1591ffbca23ae62318ba350fdbd1e9f8f465696d84e336864b5e5f21dce20cbf24b60f7f340d5f5d6f3dbbb7e77161819130137b434fbc20146d5cbd233836560b4715372e91be02a16d0112bde27894f8e9338996a7a119cb933e69134eff3fe5941429c48043d14bbd406dc361b54967af4369ae1d39d01f9984ed8d4315d01de0c3ab8002bf13ea950558af512a85d2a1d4e03e953bdb8961e31b3576a6d68385e27528979c861f916eb77d83b3e696f03f02284dbe28cc19157380bbdf8f095efcec02eee0b317256362bb4093fa000f2089f76cadda970048d411450684673e2fd64c30df472f8836c00a2cf21a9b8d8d2cd3ea6cd2c5601cf38c6f9592151e33851e6e27aaa6cb6f5e8186c4e162a4ebc3b18eed77bd21062555f8db74e60dbfc442a63fb60a374544bd7d4f006a67350b849de2bebdbd827d8b663354887580af14e921be74bf94c4056625ab9f8df0d30434229094eea9b1b5b3ba42c55d87af199717f74421baeef67bec67ccd395cce6e529ce6e071b850562c6c0de43c6552dc71e0538cf55d66ebc935a6b3dc23da9d37db74679edd966951c7520b34a118dd71a5fff8b06d475234de0a746f7bab1ebf0bf4811f56b324241347885644afa668924e1af321605327e7804fa510b4adb98e7688bc24fa6ab2562daabfc5fd72fd9c23ca0656fb0288f9092829c724799dcead7464d54b6f77118315c0854144e8ad3e47ae566722009dcc383c781196978da1e34a350c3b24a48f821f77aa5583a872a787d44b7a64faf85868de167d466ae88e2f52217a4b89cefd8916bee54e9b9950abd646b5aba9aff4cbbcd02b5cc16c1f1e885e427f74df368e828d5738974373e0d785dbe7350ee30c361c84c23c4f157a5ce6a199fbbe5e8e1e73dbd6d91b3aa7db7b25328a8c98d52f2ff24079fa5ac494fca57b28775bd404002c49abb695dd9213d2889f74f1a401b7502ed25e7931f069acc5b366264bb75dc7024e57bf69bd95935ae6998acd67f4996188a1891a44fdcbd9b0fd070d7e9f60d7f3a4bfc486b1761c34912681b4ee1c9d8d4854fb2b207b5043afe0d0c0bfc1e1d4842dccf4c074279c83f4ff75546e485ad563e0faf5a876af6260bae1576589418695e672c0b5601c59f953dfe5451862205c126abb2fe33b5f3a71f99df2bdff2a835c9a373a5aecf7c4651d7b09298b56a497b2be064f331c245af880669d779ec8a92f4705f2e39eea719dfdee946844ab3bb5a2470f072599e713e7757b24e5ed401205eed79b7cf30fde511317b2cf2894d8d54751d4e324b30f74e6ae4fb5de5cc8726e74f1d957c8b1bc737d91fe624f728d54071e947d29586e6fd2f91445133dd91dbf582b8258e0c42312b06e45df73ffc60cb8338eb90eebfb471003673bb58eb36c58530aeccda63eaa1075fc97bfe028b33880c883370d362dab79ece6b9cef2ef2ac6f85d18303d5641b25587ea6ff740f71d1a5e7cb35a32ee5478e1ec615708350c3252091333057f7881b5c604258e42c9acea7021aa28fc26dde206ce737e9aded9c90a0e47461efd121b4d91a1bd42f8afc9c25b4056370e94f9455d5f92a8c3330c61741f59c4ec2bb88fc91f2155c1747ab41ba5fa2252bb35126bc79edcc18d63663df9e6608b705ca4abb748f366b966a8c48be82f4696b93b30d351c14b46dd23b679dec5631c3679a79fa5db6c28dff8ab1b3b83449ce01462fcd792e9a7c26a4841e8b834df3d61826d316aa39c92d264106015d76f482f6aea42ad225c210aef0da835dc8ce5218920c22ddc69908e44e1c8586acc12d4110b55a99981c1a2f486a5eb72927492dc1c38b620931638c54a57a8a7af052ebd8c5967de3a5d608640f865d5071efd7946c5170d5d112fe04b90a76522a50b5042b29b6e64e13b89b87c216c83e78ed5dde89f75b6d12ec7330f512f5d4dffb7bef2bf707df31ae4b2a8099c5a66cb3165a7bd7d9ca3678215179e9763a8d39f756248c8e62a49fe4753de5d0d2ce6466599c3637602286c29bba379eb49424e2e14a27926a3f350d038b1e569160978de4182fdcb493b9dc35b0362a5a62bcbd81fc70d1e96fc2299439a87ca6a30bb3f65014fefa611a4f62199046512fe6efe79f0b1ad901d41bf5be556d891f88716475aba024f3bc0317000aec98b7c7ab00d7f7c94ba880e570cd7d6f2911531728c1617cc9603aca42b903842ef01b2c0b03167ab250c6af61888fab5e66314dd2e06e781e776d8b6bc3b98ca8ab2ef94d2a2d98caad74102288601d342fed07d642ccc4b7474ba4f35434333bee09ef1731e63665e1322e3198e19c59d8be1b18f64f634645ceec3a69d264a742596642e7cccf337be1b8e20f68b7c47c39cc7d4bb013905ede7bf9676b9691c2c2dd27a79f7cccbfea966b0fead013fe418b59ff2e648d56a24bb422ffc176a97e38b6a3320ddf4b8da71c0a304902101476f76b79f70fc42643dc3314e53b49bfce0935ed2d942ad75aae8976d8c3ff8213fb377d868610265722669560695898bd12a4a1ac606657fb619e97f7e03f6589717c59679f356a2a5746a16d109a689d275e68754ac2cc3212d2d58151d2679d3c7b6b4c57e1eeaa24b54105e4a357ae95ad3621046e88521cc95eff18c987a8b401c7553290516154d4f94e5aff18dd420c5682b21e9e31c12a83a1b78ffe924df4e200c20a24d089b3a8eb62ac02b30e3d8ad082798e2f3dc8208bcb5f50d7ecb1117864a41563933030b9fa3bf93ede91200bfab3e62f7029145d10765dc7459336dbfb4434f092903c9de084ca0613618e447e604ccce1a80514e93493e9cb476af9d9b7d7a01048c2e3873fec209288b7f69cbb0457bacb9eb1bf9051b72110a632b88e2c7223951e56ac9f63106a023bfd2ccf9d4dfeaa85863d6912375f5ea3cc3b4a0886971b1b46c7441d4cef31fe36cc88290ef1e32b884821250f35eee95d4c310dd496674a4491cf87f1699bba67c2bd52c38d84287a9d1e99a50bc41adbb726138c98363175de9341b9b15573d555aac076eb688cbb4373a501baf08baf20e4416abb97924a2571b28c450a5a144df6be5014a07ae6875d545c9ada13f8cf9326960b0bcb0688ce1609edd10733914c515ac02445a7c4d35486f615eb62c7bd73e263cd4991e6da88f6f620c15103b2227524c542ca82f44f1002e004ae73335cabd0e29f899eaf9c6c8f4eb27d57af8cf794b25c61e933939d580fc42e5da644b1936b175eafdcddd7e7d5704abe69fb9d5741fe9bed00a0794617b044d18723a14971f4fded6ae9cebe570f048dc7f94f8df845017be23753aceef041e022adb747a645cb39c108fbb258818d6084be3bedd65d01e1964788ced733efede4b06c9f4c26e5b4f4057539c506821030d3fe2a4218de32ee8d353c29e8b84b71554cbce1e76fbcd9e5603257f76e0d7add7479d46dd1648229cd4bc8c0c7d0afe12836598936a54f8dbd6f34eeeb4d6d0df2d3dc17cf9af3f3c0295c39106e0a4c9fc9a8976695fb263e91f1ca0ee79eac4444ed91b52416cfc339ced91ebafddd176d9156c40021f79365596541ee8584a78d050de16d7a5de4033c7c9313f10137eea50ab661ab9dba408b76e7f7a6ebb3afa6a4aaa194938090680606d790c9eaa90ca2ffed5e2fb3fe29e27902645165faf1aa7061a803e60691f1bd3082806ceb477517d4e2a14744b36ca6435271589eaf920e15ecbc393256c6cd911505b82cc50c3c3f00030288166c7560bac558e7647a770fb32b3274b34435f012081f0bfed913a6718bd1120628d40511d86ce955d93d3508eedaee8b96aba30a59d33d9c051ecab29c8872a20364a6ab2c396720e874466f7cc7d63ce5c398de7b67b065772adf4d8e123ba61604ca4dad8463b04f0c2bade28684136ad75976d004bf8870bf8f5a2e14e811fc5ec9dbf5eca0515d1f3870c4456e4ffe8a316d842357e8468bd7990c872a25047b8669a6123f023e7f44a37bb7c4117d7c3e2bd5ea9388932c05b54765563d2119bafb744cde1864ae54f117a3c920353f7b4587a0f0b3736db0126a36a657667316c14525cf1c2274a318f145fba9982e80ddaa246b9c36136df36c7afadfa58a74dbfa64565faccd0b95bed5c4e94ee27cdac5d7b80a209111596209b4441bb54da63d508d8bbf169530bbbeab34a0fb4d0942d4a0d1d849e8daa5aa5a5e68758abc606758c6076895ed11389ce979b6c26ca26e3c766a7fbe0b4fff05ffab97a709ac5680f7c7044c554a89e43876a9ef26c4e308f54ee1cbed8ad41fce68978e89620f08c3a068c480af6a4f31c664e03d03706a477a2ad630b38b413163d1dcb6fd42558e0b163c650768ffb78e8be83d7a75cb6bf0b81069952310c13dfa8b8f17fb10e27b7071129d6398441ada6435063bb249fc641cf9883405b17033838848f8769194e03ed66dc41580584a41ed9e8b266d96f72c19cdf1343413ca58c475598256628805857387ad126629a5925e6be2ae7e3e6a848a2c817238b7920ea02541189e5d8b9e18c33c0fb35d79db47c345425514d3c6b989190fbf52f501ea9ae2f79d6f355eebdab4a8cdc43946868407f2b9455e287dff46f0c7e92e9ebde9169bce883b37eccb5243994277283a8c8dc17a8a3fc38d9dfaa6c3daf97b1566023d7e2bd94e25f200e6c6ef9a3af1221455688c42a72d097863507a7c60106d8c81d6c0d3c01406290f6173f3bd3565afc263200df1219c2ba041a7a9ab90a0400fd75f61be7555f58e62ceae9d8ad79365d0ad9913ceb346253bd1f7544e865249d60a4d3ce5a9e71fca842ec52a1d4f8d6403f129ba92166714bc76450985cc905a36b0c7401a2bf041375743d8d58636c878340ab43dd56320ac657d74b77e371316b090c4ee4fe6159339742c4e7c19ef6851fe081b506b2b985d29369af9c0aedeeb21bfb0b7511817c7e1eb8bb5a9662aed5b3988b265b38504cf29d3c3e2d53e62929d44373594a4ed749ff25229b0b7781dd12ba48f5e96090df25d15d16ca7c757ec98ae4766e74f5e8af67b4acfe8ded34f519edd0ca0b3887913bc5d35e064a7da65ede47259761b1d18d6fabe6ddb331a813cffb9b9b592b9e3325fa9c2fa0324b45b8f6afe0f38c2b5d77fe3c59edaa8643eb0535e9052e7f1b0c1254f53e428c8dc9ee5fd1a7a30f08f9a3c5aeb3590c343b5ec7dfa3dc51025815852c7db3c9993a706b47f6b4c3708a20ca61b31f5018b2e41a374c50e9877dae571a60adbcba2db8fae3602a725350d2ad34f145afb49a94fa02433dd6b327baf1f5b33e5024dc1526bbe6fef54a121e7466120d9c22d7ab109e1777800b732429982027cb8b8a5d6200778c70eeeca9795387a866c39b30a846c49546123a3b5e994933a5a2a9bd794cb6091acc2dfa389eae75b252f58e85a7d201a360e2e95974bd407af2cc5a018a54772f976fc1b770606f9bf20a077eaa4c0b1f34f7288d05b5db2e5a01b63379c8b576e2aeb7596dc49ad25459fc3153e45ce823a702353a47051a07ab73ecf28bc1c630d526083f962edb3a40ed72677e00a8c0bd8bbc720ba7c451e46b37a00aa61acbf2a9974aee20cd2ee417d99aa1aee83dd86a0d4c3aafcd75194d96ffb0cac7f824990fdbe05106eb55f8b59ad99c5576783a271664bcda19ad3d24671f93040e1db204430de2e060561eba3fb49634c8246e8ccb1254e7450812c8218b8994849895dcf41cf8281411a63a0e0fe82f7a1fc66e8a235c2e065ed08e358358d437aa4534aaa13cd276319bd725a0a9afaeab96dfa002265e0b09bc3b3f4582df1b2da8ce1ebc81fd559c027825ec499d27f32dc010ce23afd8a21dce74dcd407c0db14c17ad990e21680d4861187f077510860999d8c55e10d118be0eb379e68acad79efbf433569cb63750e3a1ab0c5e8bda15cc1ce51c702514a32a720031e6e6c567488c9ed63381312663501796ae183b82329dad5ca1c97a7538a67bee870698dc0c29c419498135ff92138ae26e3a6ca47a09c3c3f101e62fb0c0dc3bb046e71a5d4a7b64e8bd02512866a9c461104b9720479f33ab30e530c94f639a5d6b5a996576844d263b77177d049be6d533d2ef834807e7b45c8234592bcd7bde1172d5d7b399cb72f79addf2285e5faeb24efec57b6fd881a0191e391a582f8cc0993b08b451801bb707dda75f5a765f98b331e83fda0c0692d0a9afbb34aa05c74f5be17e9376e87bb64b98bfbaaedb3a32c3fb436e602a5e684a0c3f7f26bfb7a29c7b836111d3dd36b15d0bb6bd3401f1b5a2bd4c91323e23fcf8a705e65f7eab0e2296b9b97664359bcaa07f82196bf13f2505ac16c6fd499cfcb34cf48118cf5231f32f5c82c320eee260311183546c2ed6751f288e579166a21f838ecbd1469730fc182132c0e3284a45c0c8d206847e30a4c5fc1961a03b2bbc2c7d93aca3c22d9e77aa65365d6dff94913d4d787f623501df19f46ee692fcb0d16bfe4ed519c5b6ccbda215e5953715849f399a5bef3a2b654ba9628ab2370f88d0fad7e84132f17d127516a1be13291190ccbdabc0b9c768e98983332077948e5e24ab270f9971f8eb070d4a5db682521e019e58b70714f134eabc78104b76d3445b6402ea66fb1b1eca4029ab7b8e2b11224cbcaba3021966689e5c77d6ea60cc067b7aa2989882c3246d0f08b4089b5a3509831f44c035a03bb411a47e36cd2f61e89f0405a4d6986be1614988b6725cace769e9e86cbc2ff355f71d0091e7c7e984151d2a594132231ddab94aa0414581e9a4b04154c4a0b66db1eeeb2fa44c4cb244488ead536bedcb297172b7f7cb39c32a60faea046d2a8b58a5a71b24b961d9ba2b62b52c0988ce673805365da6915d421aa91c49483e63b7daf3eeb0419f3bbfec5d6dc3023f926dce9c8b7a92aca1528c48ef2f00347ef1f52f9ab6514e3903d2cb484d2552b7782eb906378dc8794b6f52c14766f07244f93dc2a4a46c11c881c346ce87e91f066233ecb9e1282e9a471b83ad3e2be820e5f752f42c85d3d998b1195572e9ad99d4176e8395e1a9cfa2b8b22ea791d7127dee82708a9904270770c7bbb7807c781aef68ae283f17b32281f37b7e1d6dbd52626ae5d16c4a7bff18aa44e02de76f25db53d0b979d59c2da3987dc3bb046349f131202d04a8c7155b9d049fedbec1b49b214adedeb9ee5ab0e5fdecbf17d47eab539408397483cea03470cdc453ec9e44882de3b1a17575493328f91ce265098d256bfe5299565e4f71899f68ea5f87e59f49c19462986ae176ec6ce0c93c359c25a5f745fb55fd61bfba954731d53b32b6d7e726ff4dc0def8e10c477ad36a1afd004deeac6fc302e0d181ab84aac50e1b2c9e76a274d6c670f23c6d712b99a2033a47afd4b9360d92d7ad70c1fae9651eebeeab414a8e79179a2326d2c20ad06a42803a3b9aa2c8d60d8d7e2755aca7934e8f8f9aba7fba2efe46f2a76a182e755cf6bbe516cf4c3a61edbbae664383cf0fb621a1eb52b11f8064c0c19aab183215b5daa8a625a6b152e6a2ae3f393851db69a4061a786fdc1737a955e101edef8bad86b2c7af15f89c1a820685b5620490f07a1ccd44e75c991a52b9eb69b2ab9df81e272e203b6a08c60f9fe2fd70b4abb6b842ccc6a3317387b51535e4f39e0a605175a846d8ec6bb758669f475e5bdd217930ea0499d486cf3d3286656d9bcd553135c28a1c04135b95c158bdf82f9f584e2aaeb9e7c6598150cabef558e54e78d2f4455e07f10c4785f664aebee2eb21f410f94f869601fcb7aa9b0e5e6a2bd1bea58c3d86a6439d8114f679eef7cb915116fa1405d86daf8f2fcc38df2ac07880120c1a8204eee42d9e8087981e6a79c346eb0c8a009b622bb5af7e587e0256908e5aafa4cab0d913f5d39a470b57606a94ec3991d1377c5b373e07fc6e70ccf5da5f98e716bef021e0b4e92713cbb1eff376c555298340a4c0348d90cab9fa2f93dd2a08d516194f5f8c114cdaa09f063c76aef23b293316748e13eac39ae455b480d1608c734b62741d9300f9a395178931e7f5baea928fccff2985ab20745afd3e431dc390a6aeb132e531e3777f41268f30b40c9210c1fa1fed86fc683d0a3116ed2958cd2df52583df4f87bc5a06dbddfc5d735fd69e6b7e16d8449370f6cb9c6899402e6620f8fddc5952b05c9e483c671906b4ffc9eaad63d594d6c9a3dab39e507a3c5d62fe28aa5ef108e9df594a8ade5fe2ad9ca5c4e213a8c7df7336862dca159c29b52cfd38da73cd80b1a09fccb4d2ae8a9b3d01e26ffdbc8c6838be0b9075287128ebd38e8a295510bccd3d772bdcea0ef4a1f36c8e75e18a15352df3f49f60f1523be5086366a492bbdd7604a5b17b496bf9c8b0df8fe442da049e12d3ae09eed51fc1e85151e8cd5e156a44dab10888fcc277d0988f8e0f9efc551fceb8bd17c1cc496040990deb52a9fad661506136a91e8ae94b73c6edfdb0c7c3cbe3e2b1e8a71fec5bc536bc879d8cba8815a90c17a38b7094bd17bbfab13b61234b9ac02febb76fe318a267c867dd1b6118d3021722105cada1d363de4ae314778afbc8043ecb534c1aa300df7ce5b839fb584302dec25a6dea6a903404cf1f7d471b082f5b8785233e14db47be1a1540cf1e5d50b71fae82aca26ee350c668085f9318c8da37c59c0bd08388517ec9103619a615e680cf66b7e52bc3423d82306538db7c90b14231c04a9931ba9219620929524283f854d5d7bd89a678c249e9e05d899ae2fd2a765cdd1e6eb70cb4e8256b820ec6b281c3ac952908e1bca1f5786d7c40a6a0198c08c148e3f9ed0aef229c212cceacaac294d48f8a6ee6913c75979cf81b640676d2f4cacb94e544a61a41dd96277070b8a96d1accd12458ff99fc51cce96e6960b03b202f7061fcceef4b10c5fd1d035ae44ea8977c06bfe5984ee9dd562b4e014a6fb2dd047ea901afdf8614e0616c31cfb78cdd06291678d25c735c21205440093ea0452cc9b1ae869267689f93ceb98276079c6aca970ba8caca26ef0ed509d7f9b7b7880f7db7c6c52bcf1c604867ba4b5351a6d1dbec03e03e15fb25f926f677808019130740c51bbe48ac5df57ed08b9481580d6fa25934471fa56ef1d96e24ec030eacda46b67559274f8807c9c9ec920e124a7004272847232c792cca1665fb85b4fa3b7157878978ab40f34b7eeb04abb376f2fa8e475f3e7632dc321754949cd0294f090d43e3b54136ecb3b569a576cfa18f04e64dacd647be94dc726d122f6cb9d686c718c2cf1a51e6451acb9c483b0d959e0ee0f4f0b4a2f005c04a749308705d6bcc052d1960d3f8c5bc7fdf55c29bfa3442a2a7f46c628fa6cc89ff072dc76e646aaf46112891f265e83b9575f49f0e3bd5863fa4842b83cf88a882489e746dea775b8dea764f4c22c423d2e09c0ef1b40b4c48b01af1fc1031ba248e731e783c20da5f3702f43832d1fea9e9197720ae4232d82b050a2a7bb22f16ff9074822a47cdc20b5324bb9649966bfc5c6c5a4db40433e32c886c65dd946569321974558c0a7fa8cf5cd388ea3065b49b80f96fb120739429a765eaac683cb5d4e8ada1de0f6b22679b6b9f4ea8dc4e49c1c86453272c031a7d596101b7e0d7a21c7a9626fd1e170e08269e1e8c594fa8446282e0460333d0d03763441d990818f8b4e5d3a726eac5ebb054e460cd7f3bcf1b5862b2a5b30a6768c6d6bb4cf9908ea56a6cee5b74589e0643532909f5790b7c1fb29a1f8a67ba907f5b14d88232952c3d6d25797c83d1d472149828db9b177ece84b9b5332d0dcd46bad5663aae0ae0bc5e143be90b45783b4f8f6cb0c532a55e7ee47eb3136396279eb4ce69350440b14a1a5ce1218d234d2e293cafad15d58edc865447e3fd3fbb0cfd9a23214bcb3a903aa39a34bdeb97fc47b8d93d4f840a0a463bcca73b87030019b183eb55f24d078cad1e65e473c9e6da45de2ebbca4d1721ea5bd5491e064873fab582d7be2b4e3d7aeac15bc1842a22048c8a7b4a7d2a4665b5cae21bb1c9ec7816f0b3bf4fbbd5376d41ecb55ff49caac9573302090ddc6384b2aa5c408e12f8c795eb16a83779a63f7b6dc2df021582d0d848b956c3e7a806cc609f87d17e78e1dfd1545bcdeefca390ccf5c06902af02c634eba28a46931c4d24a7b4da1753ff06975d349e27eacd24979dd62b87e5f3a8c70fe6e97a9883c480cec9f98d918436923c2154dda47ecc3bcf0fb777a1013eef39914c167008c9bc3a15521ed2cc6feeb8f8c4cfb99d8061b0fa1dca7862c3de098c76b9c70142c81edd555cbc9d6dfcdab6945f07a931b29eedd19173b0cd59707dcc2c546f17a72ac678ecd6c30069ac535ea01a1839cbb2ae9e7f5f66606eddaaf45579f58b5aa288051100c6909dad0159dd2f0b6a75e84b73e1f28d631da3873029a105e36ee804028fc34581dac2b357f6ee60223e86aa8f6d1244434877378bb054a0cfba78e8cdfb3a649bbac50893ce1eca9a8f75eea1890aacc9aa9dd156ac143b49c7d5b210930970281e9a926979903683741048ebc9ffc7d562b54e9d06a7206fd5f9b6d024a995c868ba3461d8071e691de048a39e60238567f4b628ecd1d40395c5cd2e0a5c475de313e6fbcbcd678ad87374b1d99a8b26f54400a0ed237be8b3eb2d504a56e84a888961ee3b9d6f0f3c46e3b29a9217fbb37bc1e3a8f4d1cb4d34acba66d9917db32d5175212f7de7d958d9391b86973b0dc6f4e2c3be34dcee5fa4ce82a32fe435803536eabc97b84f9271fec8ffad9320e110e80c0404f9f900e4b054a349c12d670ebe1d6c031bcfd0595d514ce2cfa7e9cd0d9bb305e9bd5a460896859876a30f5fbbaa1a76ede5956d43aca28459088c08c9e8a438632f8a6b6ff00ded0f70db11ba6206ed11f189567b775faf3a6513ac52970c94386973863c7b6dc7f8579e21c9de40d75dd2af0add70538844f3815274b99c4fe4d783f429baf983b561b6e8533a0e909415d6b75a0a70252053d49bd6a729eea8d05b3a66b6c70ca2efca71476856f6703ae7c85af7e90d316cd84b4ed8eac3037f7ab8f4c81201e061b0c36b95ff5757e558e620aa92c07fcfd515563dab7fae092793608fe1a2d35a526cbc79fc7ad842e073a9223e15bb247d697cb7948fc06a12e9ff2f7d12c14aa821a386a8792ffc4154fef5bbb263c70e3eb61ed4c564903292197649e479e7016f6f3340965e9af3f41d716bcaf069f968e139b21936ffec069a65b38a518b02c0a07931d695c65423494682290d375e6ae7d9a6c77500f33eb2dfb6ca57cd261b0231e972ea22c0d172e03e547351f155d80487d8b71c2417cc9b2780e467849888ed4ec8cb401239da7bc92635042c32c07ad76a51d721872297939f1db5e4bef0eae413291625b4a542e06e6bc2b2e0f41ba4e4d93db23c9447703136dfca1957f3a0058697d90ff6bfdd6f852f3ee99baee7d6c538c153752aaa73caff7bccd70157df68a5f4c3a6031bab4632bf3d8db97f04ef6d0602b0fd9082d8224dca9e4fbe5d8a9125843e0253b7204b8a4c34da9add7cedb1e578b24b2ac2f10dffcc91347d130e8f20ebe534bfc8469d10c47a6795db494a106164781ba2da1246645e92c07844c29ace949255a11183c47c2a0936b0354d9e212cd1fcb04e6454f30b3c19842b68717651dbbf22527c996f0054d0a4fa90d198ee4e769a4c9cc95d1622d431cb1153da54133ef17f153b3aea1bd0c788f4deaaf159f66a9755ce31b75f2cb11fcae5a906ddd73d0789d00414a179cafdeb37dad64b317353fa075ea82e279725c4ff380e22b43df2084fe768959e05272b7f9978a6a3eb6dc09afa24fd4a1d4bba6c80ab193b08e22be701a8c0729c8c8c15b7713416dafa7238814e94cdddc00138501ca8d78c182a1e73672f383c98204","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
