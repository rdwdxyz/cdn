<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ebc4f2cf08c8c014958ecb3e223ddf656bd113eca8e9769cb830aa36225b021a76618e5ba2f4cb6f6c3b8c84d04e3583e135a9957cde9e6f2e6b9c486f746b32d9a3c42f278714671c2c6829025b0d1a09f69ec7fb7b0d0fb7c89097b79cafd7dfadc23bafa1ec1bffff7b9ff16702dd7e927be503a8405afd9c76ec8dcaf06dbf3506eeeb9351a15a79127af65b1652d6bc2263b386071c0e8b283f99a1f95cf10fc28969d2f80b8ef1852a16b0b1dd5eaeb7a97fa217ed0dddae1940285923a4a02ee823723e50421edf2c33883f5587733c9629ab9cc8135306efdfc864660731915f3758c7dc0dd526d7b44f9ea4b4c785957ef5f6b8c3afe3d07b067150f4695b7a8d5649cf57b5036c99db4b1d906180979789d3eb2f35f1912e9f08740b514be2c1a7a9a65d348be3ef4587d41efc014cf46987d7ed77d477bd7d3810d97fd9e68e6c34b7f394d8867ed767f717861efe7400935038c348b56e648c4f082d999bbbc5ce2d1995d54fe6aadac96d57ba5c7c6c1a3289e0367473b6546357657b525e8bee4106fe7ea9c6be26a48cfab97c1cbaff87289a8cd1782916fe2bfbdeeed161b2a86d4cfa13fc0bce341d253efd24f5419d97f2f6b83557a5cd97075c293163e76587fc591fcef2b7d4ba132d72411f1209bcad9fa515c74f239a5f23572c41f5a1fbefb751707b583f78a576ab9c0e334f8796f44db5e8c1521573e371d619332aaf0d8f99c32119dc2b485b78e7f918971dea66b157be575c4df1e713f9a4b6d07dd55a4636697f48286d8ada140e5d9699d7b690243f9ef1878ce4af9899bcd306cf8a8be3b3194f7eeb2d880a279107fa012c48451f1667a343a32ecb8bc40be6431a735ddb432cdabc3230549ccee89f2f54d40bffedc949d9ff5f32dc25f3133f62ab2d437e6d6e0b17a3c9fda96909867826953f9f4cc02b147131ce665d5ec1391e20d0944728c3201b962a2b868d786d8067e8f6d49fae655479f2e7053332a934ff6d3d814b923128237d5450b3e8461efaa9b848619b122e760e439bc00ceb74251f471f745adcd65e384333141c9342915c96daddea67274b96fe23e74ba63e1277192dc1cd4f6491b1fca175aaf4e3f2064a9da53671b3a8dcb4ed527b9d320f67d7e04d8642f1e924160a9a26c928f1e4d4d183754b1adb05bd2606d1a885e730a1066ea404e42491360074648b12f6d4e34fd10f1b5db827b51785a0704e03297bb86a041464e26bcaa6a4e92a19b0908ad7959ba341c8eb88db9d202146ff0c56f28fe46ca270f7a57f04266fb0d6b594b84c31c9dab24253038121346b47908d7339260d261007fa8d2cd5a3a1cecd823addf865d949551df1625cb736ac5138847ddc22a8b33ac7a0c0bf95def6103512d983f5bdf7d1f2c40ff965e3778152762d958b204e46338a83ffcf09dad24cb435b6bba7c08a48c385eb8dc427a2e30251620653eca4b2840b7059df18369d0c523596440780594ad8585c7b6f381096aeb14e0a5f3a6631423a24deb255e3ee828d60c1fc02f97b1200b50c0d1d17941a77d6f9ad9c051b955d61f856f74e432a859b976c9447259daadefebe23ff99475a69011e7b4c59f9d83533b9833177d1436c196966c0aa16f9b9129a01297a8f9d2d235997463b8a3cc0ecbc82cd25e10f30402c0a68e2c5f3c7ea0690f71ea94d7b7922b7d496687f39393af81259849d903249b51a2453910ed029846faa7269c5f73a9eb803879589e086428adc46dc1d6a144305a4c20048a2498e1204be18b20878a981a24ed2d05e36fbc0fdc32dbaf9d2055f115ee32262397da47398e46774c8bf578e11fe56637b93105b8b145276fa5bbf89bf97d0a2249aaf231fda481697cd8cc74b82a5cab486938e379b226fc300546ac071913278f6788117bcb027ab8cb95539a3228c381263f16f945c7bfbef56f14d0d4451e91098ac3ff4b9de4aa0427daf4eed3e5cb5c8f547d2bc75d298fea26128a62455da6e7154c5916e5756400da60ed16a7c55dcc646834ebee8c29eaccec3be88ee31291f310ff06459bbc665acfbd26163a7a9c1e624638a1a57e2cac43ce05f73d37f9ed113e0e7b4e76276bec7396e577e3df919cfe667543bb82cfd6e80ff97f6a341f660ceea5da0ce47b620ff6345fa7488a05381aec2476362b613728044e992d3c5a706d74554d9151369f029146c4a1354e5f5abc3cbebf389a99a17ab34ebdca44da8d03191782a81be2510443e776f9e16dcbc34c25b777cb82bb32afc469aa5538237188b0800772197fb59a379320f53c44cd4a6ad57da9760e1fd5fe930cbeabfdac779314efb518f5c755b8a24778e391dacdc56a3d3d32cc69ebac33f1bfbfd46e66beb477e52afce47a13323b1c545e9806e849f6de16d3babf26317b6209b7be093c7e2ed380eb5fe7ee8f2ac612897a3d163137e7cabb886838c88a1be5bb793b9876c5811c3e32c7d6b0ecc308ed3396882ebf83b55c448c53ce9851f4af965d020cfa9afa140cdea9f3317a89629dabb8827afc3bea4ca07f6364b656493ee6676c6b16b25e9716ad5255bede1299d19a15d875cd61a0bd8b28fb8ebcf8381c0d87712702fad98aae9143ffda10f73aa78dbd1ea2eb5ab3d04ca1dc135f7c4c60cd48baa34ed6076a83a3c84574c602a152fbe17d993dbfb63c0af5840f64fe1b72df78ad3e7c059dce308c99231cf4ded524d92c88d9525b95e2abf713c54aaca396217bffc9d76d0a3727884904238b3d4b70328b383a71b0376b2445a6da2dfd73db6cdc65b587e1cebc3dd2cf656a6bfc29966d1b0149a47eb1ccc9dff5535dceda7d29b0fe12b0a5fe40fbf5687fd629c5c806bd07e605d2c71551670821bf2acbd24d7a2adb5774f027c84b1b594015765ced560ebde2a09236e373a5a0fe165b2d6e6db484b86c9321fe668c605664a467faee0615ea414d805163733fd85859bbf73c29cc696eda4b1eddfdc10d88b1b915c6f0670540bfdec52bc4728a4de6790b8f0a0c8b2d04044dfd60c8343efcda0e55f79e3ec37d46020d7117d07a41cbff1b81fae2a3ee190948b8e170c2811dc856d27d402ab8b7a6a9ba9e63cbd766ace1c834cae055ee60e22bf576b14992bd43fff8af94d37cb950578181f932be37228cbf2c5826366a7eeec08604bf07f7d4e6e8b80a8eced3fc286383c5c425014a63392bc47ebb8d3d017e06d776ee3c1b73301bda2f56e8910331484912bc5d1bbc7ccf5b5e256871edd20f48ad0740cec979bdbecd0a3315217fd5b5e15ea496b12975cc672eea2ebc01b3bd43511d5d3e80e9afbe214889780f15f63a5bcccc2d385087fba49c79f7a44f8ef95f319686a38329ca4b0afdff51ddf18fc1b2d360cfb6d6c0f79d1abf5c216e9cd6ac34b7a3ca02f6edbabe00841f89816552d4f7245a2e316d2509fbbdfae70affaad3bc14b27fcae40b1be1030f321a2712397cd502a3a0fa738084273b05d83bcafdcef182635c5fa5924b94815865f03981123d3760b1c211746aa683a45d9c57b2830ba3d7c36deb2735d4cfab3882ccc09dd36363091d2d7a0f1e621becc33298b1374edc5beceece4be835bfd8dcf487f6469ffd38229059ec3abd77fb96fe6a3e78a6e7fb0ad6f477ecaddde1887c4bf80a0b91ff3af9f6c913207d0ad0f4823decd2169ad96525b1ecbc805dded11144d3a094cfd7b3cfd94cd723767d22fbe10efed16c6e829aece59bb6c5a6f44bb8359abf1f3daf72a268e2895d712a9563834ce8506d7354f139b2c331905dc81dec9f168003bcefb9932f234179e897fa49fe07f5085f90ad0a44c08e7459f113ec58c5c07d563a1222c73d17aeabc043ac3c96d5d375a74886ed3d3ff5040ea6458d808a3bd04e027641c0eecb6bea5a8b773763592346b7e73af0355cfc145dd6482ea11186678bf27568e0cdc8a45471860705dfbdfe2b16ea41d8827bb802316c32dc12e4520e2bb5ac597f22c6c427d110de5aa8a321f6ff13875b8370279f4af0c0b3049aa0a6fc89b82ef4b586579af242650c69ffdbbe1379455c8e0ddb7f928ece38c62c0ad592aa6c14f56d517c5fc6d9155a8db1a343f05704f3c3a5df1ea9b0f45758001c09b8cdb206afdca2fe4019f4fb31e94a9892d1a81dcd0264c88ed832c326175ebe941d96256cd01c2a65fb41a0491cbc16a6d05927a73274473c3f62bba8b3b3f863ee8c5814a2ef15ce0e5022358bf189a516947ed617f672f8131b2a27f8582c48fe4b310b1577e9153810e3e5af5f9b160f1caf3cabb7790111e1397047dd40b072de54b695d9e52333f0b5e477f61f13bb556460c1457dd7c172aa361f0beb5af0062850d3f1d7116f126abd3d6b95b2bcee4a37daf6c7634439bdb41e4487189e3dec6085d67ffda52a2d3549ac57c4eac1240ba4579366c23189fe0f0d160278e7bebcf81c49bc3568f0cfeb0742822421e63dad5743531dc94e3a3654a82bf07226856c41381ca30cd0b916984668671c3f4137d80d2feceacb9b7a46870fcc8e6dbb48fefcacc659a9ee91cabee018272e159ba8c8f8e6e6b0a59d62085224be701adc29ccba7d93dcc0335ec135ebdf52151c14a3404cca7e713fbe703ef9fa698cc19ad3673ed12226e121aa607fdd41e39fd3f8ccb65769d82daef3cce08807778b0959f5e87ec7b2f598dd12b6ee6d36aa7129f97ec8c247a29370b877e75c288aa487dc749bef20aa78b71b8620fb3769bd91ffed9cc4e49e493bc32f340218fc7668ce5f9362ff84e5f12b6bb8156a775c020ee0199c1160b29f14ee9056514ca07c9596d29b42b916618c3520bdd7b869234c56fb83cb2e460a0280a9bb6fd477f1c74322bd3b3ec677e99877e79a59f4c3744db3a6865bddc5f3af1728ea5a70bba8542badd75208d1d52ceabf545fabd2fc12031924c0d8934aff43f8f7d39303ad2b37cc854935896f2358f0c9587c4a86d4fd599ae0bf93e398ef5c48272d1b2b4f19f75108f7d7c1a903f30fd841dd8fcd5a7a63e6ecb1caa91c56c5f48034b5ac0597ae7d8b3a082961308d410712194f364fc00e55fee0e7bc8914b071bfdae5f4c1a113c61c7fee9d2ad662c20e00fd82bf9961769b16532079fa2d79a756ab44120c92ff09d5df46b464d5ed56ca324d211cb87406bfd05d1367a622169f5ae5901c12f1eb3c631e24e0d725d9d028253d1cc70ff24928b7ffe415b69b3d4f166807aa5cca9fd822066c0a9d122af9f9eb4247cbbe861e8f6c70985d73c89c8fe2906d432fa95632595b29d56b8b42a1fc10b61db962d31163c89398a519ccf387cd2d7c40599ed926676ecb3a904d71322a81f9ac520ade8d5ae45cc8aba01856867c7757b4a075de45f05925eb8f80928b0b3a7ff4300dbedb78765bf535ed1cb79296755864f45bf31555154f07893fa98eb6f5fc2fffe1b2642d2168c8c753afb78efa6ee20cf27c36764ab0e64c7858900467dc825c5c7e924f520920c07e2115dccbf1cfb3913bff05b1e2ebd343ba4a81e2d57e2f5eb39506c51ace6aaf0ec8e7e70b1e3f4a5386964c2689abee02f3d2c396429fc0ef20f9b32fcf265cfe3207e25424ef245cfd1acf003db1702ae3b1945bb5eb9ffa7681cac64956ed15247f537cb303e7ab49ec14b5a21eb50d49cab49bcddda2efc894067b53d75422595f236344bad0c5908a91e815303504b1794fe8bee8841ac0f77e105a5b4f9c79b2d4a559487a247983996ab4bbb460359de91af1f206bfa22ebd640542fe90b4c9fe1ff5a9f4aafd8a47243922041823c4a244f048cd7e8df726e5e7555238d9a7fbac2b5d335cd4c1fa4f242e254436a38d3573a2f2a6321c082df103c516bae6825d3925a8ede4013e1d4d24a7567ea4ebbbd7fb5b3b93d23fd0657d93219e289faa2fd2ccae9d9616610dae6a4495081ba9cf211e610302f645019ed071ba9ae5058929ba814617001937a331839c5e12cd05e279bfba6ea60f4cc411241eea3262679308ebed958bea364d51b19af62f73bd796cd088badb10aacc348d795f7378a238695fa2b249060906a64d5edcfa1efe030f808cae49a0fa5caddec2577f5fc9e413247a881ea9f99e37dd75a2ee7fa9335f9a34dd5837420aec1d50e07f4fe37131b4ae28540426a237c42b0ec8c853054125d3bc6964219a1bfefdcb7696d7454ccc111b5002c36c167132f3b718b1872a3182660fb80f4f71932939972db3df4e21b0dd5871aca49fa0b88e33fd6e0db83564fab80a3ad2ead0eb0570151775e5ab4675de3982f08e781d6efc9986324a2f6567bfeaa1072e6c52e7f1341a2f814c83c0f1f4d420a91b193d7395388f03397efed6222fde22bac0582ffb73522bc36c47e9ab2b753a5064ef82f9f264550dcd79ba0b45a80ffcf41eabf6508575b76186d5a04dbf47b9e79284670b28ea0382bb069bab25ac73e43f204c6d65de590a240999cf42c7901bfa73aef97ae2ee7321c7dd84e92805396f7998e7667d115e515a4bf8fb73bcd7e7393ed74e161af1c8874b3123fa2e8c4fd799a9dda2f0888f2cd641de4d2ce4e8427adffcfffe93c33f2dbfe2236012525ce62cbef1ee7f92e9174ad27d51110c23400467b7955997c75e4016d058eeba1e46bd3fc82442f592d214cce8ba751c722fc2b859bc0dd9d54dd05e1851bf0ec896ff1014f100b242c0aad7a9be410d7cd7b02a370ae376fc30f7c3a595dfab7df8270eb0d22d0b39a4651a2b2d93e75e133b024cca44bc9a66b3ed45c4507adbb8322759e184cda89bfb65999f1d62ffde97f5078f3c12d437ce350dc30db261b07a4b93d84c10720d0b510c5351ba92341e0eaadb8e4eed944667aaf973034d0bf1a81228b6a35e98c0ffc5b6c779218740c315125a177c7e6f2d7e5fe764cc9e515ebdade0c385a976e013713f497ce0f92fdbb1bca2ae5820ba7aea2aafdfaaa6db176c2f8e7fdbac1b65a09aaad1150e4b3977fe30eebdb6923fcede03059f07929e6ef7d77465861863e6e05c05a77ff16791ce853f2c650f084f29785e3df2f73d74f5febf5dff1f4a31bf6366deeecee57986d929b33ef031b832006b1906dda35505c7cde2ec1aa0f2dc5c5a1ed7843f934a74390d5d5ddc66d8518d478a244235fcd402ec6a13f2d6cbad38398f65f8ebb9c06d7f786cc10582f8f92ba4bbd58695090ad0628b35edefa82408ec8cd9caafb8fca79367f44d28ffa923261321c6eff307f7b9f1b5fc2f9162ed95ac82e25f7a77ba600d7a67ef1fc279deefa3de21bc574eecef4612e310f98a157c8fa65c4da9e496482e058081d086412b46a7c9840eca2fcfa58190fe85e29cb7fb8a1711af7b6fa4ef1ee124a5aba2f007cd26a48b14b6779816e6ec7c6edc21d2809125f5419f217ea2f1c533d7c9802f732b04e75485fe53f11aa7314ac42c8a0ac3cd2d7b6cff5064a7b3808aa032483a25f4373acddebc1beecdcee9430a2aebc3816f64d54ce3056ed4b609a5898f5e6d12d012b865a5725dfea45facac92ba2baeebb893d91804b111b112b4dfb1a64e4e1360349147327ecbd37a879bbef23b4bd4769e6c098228921904c3af1469d5baee78d1e627288cdfa9c4fc284a73a0a53337202ce7edf00e9153b2351d365a1b1221eb45abb9362dd88f34d0e550a8b27d242eaf31157e60f65c0f094d0455112a7cc4dd490b2b97555017990aa32347e4fdf742b798af9c68d5b9dbb6e90d65707ec8e4de5b895b32d8e6dab6cba962eec99141413b89dac518e1b8ee2b2d3e478e3dc7cc90857d424fa8fd720640ced1a5601225efb6f03f08b79b19a8ff626bf9faeb624a8c219e83a6991d4a45d4e4de0ecd175a6a492fa9df33394518efe21afed156af5910d07b6d88cb12ccec813216d460f92fec0abbf6a0acb07c79256d9e53f0e8280a4bdfbb028e236d38ba64f0f24c51f31e75bc97f9d0a175fa28652eb64bfb663f920f906c88eb4437c5a1c6249242595ceabc0be24aebf20abdc85e61b3060bed1c781a2124da3b85cb0663bd420d8ee735978b3621db3ccd6411bcd2998f9d73f9bed7406b437221df2ecd9b4b9d02bae9acc9bdc97a89017afd2068b0f6f0b6e39feeee26cd06ee8fd18a5677c115bea73f3f2b0c5fd969031467b0a5194b84a865e115e8d20c98297e0b4b58d538787c242fa405d5f893e5a81e39cb27f89f995e96601e1e0a023ee9277d16210756cc554047143ba12089b2665d2794f1422592dd52f175c195bc4878cc8d4aa5db53c17fa642e4419adfe48074a28ec311a645f3b4afeca56154a15720da31c2252d9a71f8c6be3c9e6c45d72260edc9468c9f5090772a431e492097df7eb895c47c73fb42237da921b918b5061c48ba1269ab03ac39d725edfb3c8217e110777d078c7e4b85a46af6367309c4c7e506c04bceb5b898e9d3af2eb117877bdf128dfeca5d746eac192317000cd85c9a0511dda65b23e920951f5f732e638bede1f19e5242942425de9e85d71f30f28dfd44e030029e4705ba6388ee2bbdde20790cc3b6798b819da7859cf5fc30f86d0102914e12cb2f79a799962344c03ea8d9d01648a267a92838e67b13fa55cbcde18067bc9dcd8ac73b00cff4b262128a81cbfd72fcdb1ee8cab66fcc274e2b70987cb410de6867bdddda6c6698fcebc1274c463305e2ae7ebeb6186a8d5f32084dba39ab1a5407f9f8bb023e9decbe87bba4140b4865b37fdfbeaf5240a8cfecdc906f06e20615db9f37f1aca719db13b42dc3c20dea58cb7d071080e3eb9791bbf19afad9ea843d97897399e1dfe47400e8deb4ad18a5a350853559cad6c1b7ff466e8207650c993585ea201a53f85a01675fa6f819c32a5911342cb06fa6ace751cb6cb653f44dcaae5f3e0d1e686be76367089b29eea795e3c283f472a51e85b347b8ab6204816119ab411601cb8d5e080cb3cd8e6f1742e4a148c3ad404f16230a168f1653304780195e0c5384c95db2fbea2bfe5b5bd75d5906e627044ad03dd9de2208f687075152fbec9d93c509e0afcca126896887c2b9ce567fde5e0c145e09286dfdc22de9987d1b524d79383b76a422a08559b96ca1c2f4d028c079ae88ab166f3b38d436cf0966fa4f065bbb3ae0638cd8ce598b677221ab071ab448c5d375de7c045bce5eeae9a435db96ee0d84a78166ac869acffa1dd1a2fb817fe8fc42cf51479f2bb877add209e0d5822ce31cdfaea7dc7e886cc078e46ec76cf9ebcce475ba20d9ad23ac9ff2eff3920bcfe697fa5f06b6de28efef19ac6393cfe76d62043bd3c7e27da172209a6b8fa10e4f6b95bfa5104cba152bb36bde17c62289e68b2853b9f218fcf25e92348d8316fa1a0832fc3e5c628806b463980e221e97ea0fec3597fac3e9340839c0d46bea230cbc328bfc87e549b87e82eca2f1ce54367207c2aab4ca796175ea31de21e462cc19e7b673846cc06fff6984b79668c43593dd2c309012944fb4039f46696caaba781fa583045fe0100fe80d4b4d0144fc8864abb423d8ef307e4ac815fd7e613dcceab98516b542ef6a86cf5c8de60aaa8ec870e86ca4b5a59cc2ca778d26415f0d1112507e73c55a7f0e571fdbc70818ab42d3be017d631ce6f79580e698644866f90e3bbdc0af7fa2d3e40a6697b00106ff820c0b5e9e541f71923e3a72999efa3b29dfda4892f04332da0e5d3a06c3273162e395344a61a479ad51619eb973c3506e05d7350ca40d81cc0536c6ddd57633aeb495480d134bd0613ba99beb8de8d6c782d620966d25e557b685935a7c6d0134fa23b9e4c5eac4e62cc4fbba0d07c603c7129f6df4ff19bfbc7874b88d4666132df5116e1a836509c6e5dda06577c446f2da59b8a74d92a2820170c6fe82433040038c9ef770b5fb2b611a88eeecb669322b0a59b53f7d23494057c18bd8790fb9624074190a3634f4534454260c18b9a1289832c5a808393d52428c8b5d5fbf3d4e93a92c2712e85f056607a8456a114df9bb0910e02538f49df2097b3944b3af1479be05b6cf28a99700ed5f88f4d49d23849a977180783715cd159b11016ebf609e13f3dbb7e1d2f4e28791f1dc9ed6eeec41843e0d40124f399a5305dbbce05f44adcfddb6fab0baa693762c33916c11116ef381b188991bc8828af1af843cd50d7894c9c763eff3fd1bbf4c642352b9e6012c3917d1d1fbbd1c3cccd3d8f012cb01131f5edea95b8e08e982e3687a8ca65fbc9c50e1aa863a9f8aecf26ec1dfae0b3ed457fc6861b6ec57111de41131eb12d440b36290b3d8b9d9b36970121852246d2d02df676d3925c54c80170a7dc69b06f996f04e6480deb626721ab186807bd15fa4b2a9f3ff410663fd9b342961e85aa7a0c099f54d4b1e50c5015fc51a0799185c30de224b12f7074871927351719e0a25308b2c4b4880ef5dbe013aa900bd32348b74ff73f687078b5340b024a2906c8858f7915acc5bbbd1a4ccaa51d24e03b18688c8fbaa9cfcbead128f613a02e9189bd9c05f44e1dbafceb8d840723816536254bc2b7e0933c3ab5efdf75b86e20a2bafaebe3c70bdbbabe066e7d92e8ef17f5c8d2ba1150bafa7c48ec5d164c61864a336314937c29f35f0f050bec05f49a9800da29fb5e7f07f40403cc78ec7d14081cc8dc4484afdedd851f1a325ef0709dc827699fe857fa854ce9b690eb397a2daa6afd771f36ce36c83b0173f73c992a875e459e2005c90493023a7e495637ec883829a4194b6cf6aee03b2d6f9a3b41b23cfe6ad6f270f3a63c9220861164eb4a41a4c7030debccfef41957e1836e6a3e20daeca310858331dd6160d2bdf99c1ee2d3d8dba1efff56b24234d971325e4e762a7c9091b3c3c2550ab266ac5d0e4cf98122e121ce45ec2c05bf26bcf81793b056ebb1defce86b753868f739711ccf881791c9de5712869be0cbc232aaeb58d7632031fe325306ce37c15a10f04be07f6ede31f7a537c990b0468aa937e69700654b4ec2d217462eb6f794828f48a2cf41ab7fa9bb9cb3ee5658ecd54487175605d8576a500154d03b536461fd2c50abac55c2b649add79cf55d3f645f8edfa411b61e0dfb7bd3dc12b67e6e828cbcb27bcbe5b89f3fa9f8fd5700b6a52f4af944306ccc5c46f4afc3429feb82d7527d15f4ef384c3790aed7b4f2d0af55872387349dae2e5fa23e24bcb5f3da3835c576cf8ebdfb0c70960ca5ae0ab0977fa2ed893c3efd5ecd1c4e6babaf65a5733f623c0513397aae371739d4f8fe6a9c236f82f8d4cd9bed5cb242847481712bdfd7a6704e0a568efdd0b75a5f6d9676c9f575a729ed3d38006c983c7b1689f72a264123762c53a1c7685cd92c2f78baacf40adc73ca37dbf9fc150cd8ea223ce4bc5081fa4c6e5b839fceea253246bc9d1d06225f891658b5eea4926d30b2dec6c966df7356c14c0cbe310148baf3e6cdf23c9664e2cfd54ec56940d5aacac6278b97fb7cb76494af04de27aaecaab0b1a10a0da54f5e8131b75f0d332a967707dc3f071d3b50b67a7e2369ccc29196c3e80180ad98f3a0db050aa288e83c85c5d4863e0b0d6f8f91bef01496f7ee4ff9b86427694ac52799ef154e96162c5e49e7e8ac0f8d804f6aac60f3d7fa4d395cc1fc1af040a6456d51e0dcb36883b27a02453733c692b2922fa170b63e5c9b37bc31fac5247f18e0d2b4ecb9549b59ce4bae74fa50e1100f0fc3f8f405722185fac9d3a2745010754c10cab97e22d91786c3fdcc347edb9d59f5edd80a5f66bc5d1a53f928cf88756472bcc630a9a3af6e1bf2aacf9a502fef0fd231cd3c2e6939f9203043d338c1433a18ec0e535bde45325b0928875707c3a387990384eb12e0cd57c441f69fa0fa1258a832b2d5345f3741ccf3d8f07458b75daacc4be1e63d4bc1f73a1e308808086c2c0d8244d5948479f766c759cec03ec4f3cdfb05e931db114842b13dba5e55c8134b44db97a8fecf6a307144aee927d492a323077268bba4fb94975cc1aafbede857d50c581f41399220b56a313a30464c721c6dc53a23b65c9a2b45e0a35923a1008e54db59feeefc86c4a8291254363d325930f9ed0f5079a04bae5c6e5061e5ac369d0bad0e8b91162d192e1bc80d5bfb0f6301b44efc14bd36887667213ec3c418c0191ea04b986be3eee3d08197116b7f6c280a8f20dc533c0af582daffff1458c60c1875d103d992dbacb6b4ec28e8b0cada80aa3574e002dd7b588a4e078c6bab27342b4ddfe0c22f080f3c255454e3ffc6c9201fbc19c2f68094494623d8c64106fd1142534c0810d13bd431339984118c32ca54aea938a54d9e0d76a1b708c97c77c3b73958adda8abdf112abada377ec6d8fed32976264357b369ca00f28cff3956390d979797ae701eeea4290ac1437ee6343977f61f40bafb0a512b444b506299d0b41f0f98b4d29707a1b03d2ba5f87df17e9266f1f503546c72db4529ac8fbf39eeab16e4ab73c449f32eab451e0c3151216280ae0ea95144b78a19da5629f5c8aa68d40178d15bcbf66ef2c9154ef0d3e9c5859c36ef9b1be501b73b049bc4adfcec55ddcec1808b6f8d175af7a0b6e020a7690677eaa9cf4b0f5fa0bf38a7a5ce57f7f96f696f30528558f3b83ac37c4258e8cefe4b0abf4744e485c7bcc3c2bfc2b3ee88ef2791e34cd68abfae031a2f1cd8bf80db0bf6b4e97bec752ae272a5036abc5d7f46605ee9f289f2aed496267c80e17f5da13c7e89187635d9b119e806116a5d39d90edef9b7443d80a4e60c7c78ea249bc5460bd320944a68dd1e82a3b66de71bbb05782970253153da9d5429b94ca1c508bffa0f03795daf3d0d8f303d197f439f409705d392a8d35358700cc40bdf79feec81a3da33e688e23e661e482ba1e56c373e94cac84996900be4dd70083d98091d0f2ebe173cf7e0a02b63678c7594ca94bed985b0f18134baadf9aad2c3f434ed5b630a1d2090c1d86ad20ddf964011e593872dc69eb8aa22ff519a5a184cf2a747089cf5f0352fb0572ffd478d6c412588a873318e378e324b80789f96391939a3ae0cfb9bab99a7e255e8e8eb8e0eb3b39fa83f552c7246bb3ecbd175b2a9291e98abef2d617c9483b1d423d4ebb58599dea43a5f0cac0e80819f7f652753990ebb61e4999bc222178220801a9ea25d58b41f80303932798933983809203b5aa062c18b5103e8dd5689c46a627b2a709b08da007b60f460a8cde40fead4ffd5a2fd64f7fd5093a951f1113a9f4ab6b497c27c5a4b4f83541e092f379b79a06b418ced08caec1d04e8ab909138acb7759aeedcd84817c002e46f782f80d10aca5953438f65a22300c6bb6ad6a00f7e3b94dad98856ee15b1739cfb301b291f70498ab550d044ec02e48fb0f86c08f8b2564165fd87672db1ed06b15232f868843144b2628ef793293beaa90595fcbd6c3efa6cdc82aa868ac076e6db859d63c1d5b77992cf7ca55fb5a146be294d1b0e6283e7a4eac43c9fcf5c198d333e08ef394ff415dea4772d7dba5d1bbc71ce6985c2dbca74acc6fb06f82ffe3979b5f86e0945489b0d86f159a4a949771a02f2e49241cfd6376e5a9054512c72553428126ee8653aa95b68a0d6f78c8b7401da6ca51f3cc9a313a1241d7db1eef8b91b104dba54727e082edefbfe7c17ddc4e88b148222742cb0d9d47e4c2a71ac6ec20d0610072f74b9cfed20fbcdb1396f6eb378e64b1c9d14c39702cddf4e71428c329c6caaae6e233d44d4c233f255815a2841bb6068d6a3e6c5d0770acda013f2e9659e8951c7811b1c85a076bbcb52d0192b6cb530f82166ad4f9ca48be9ffaddac5f793ef7c946b7d138731f79ae646bd4b9641fee9632e6d2f133c84941f305f0e5e0db32756d017aa4a00b65bc3366b433a201e9cef9cef163015f0128a20f62598a3168af94117c1d00ecdc8d6ab915443d73ee2a955ae4bd2af28b7e8387133f40385e18fe2fbcb30afcad37a4d867f5db89f4382bf5e3e4cfcc5167a7f6192b6a8d9d64803591d6cc4e5722db616830d9d52d1b55a80adcd0eeee6c1b2536388f127a2d117e386b7ca03aed4e5631802acab3c5338a289e4a0323885a269c63ab020de6c77228be2106aa8eb2fa946155f292c4ce39781010e9988d5e56f726b78eb90153265b6b757f08e7e0223934dea1c2743bc2bb1005995cd069d013c647210aec27bb7b6aa1af6fb813c03f17b4aaeb6cd639b6e4ad34a0ea549ae1dcc2fc55d5609541ba59032902b0c8e90f49a717b78f55d6c2bf27e085e0316896ca83d987fb2b934261b02be0066c4983cd9f6c201c91a266d1f47ea033d88f26f6ecc8b1900e3bbae9556f19f3aaa8981999b7883ff3580ecd27bbe34f7ba2445826830a9947b54fb1dce40226335695245855de4802350fbe321f26378b155f1583f0baed975f573dd06f188487a9019fb3963a47b735f377f5892aec8f2cb6a1dde84ea6ee14b70e0def965647a669308aa89b52e6ef979eb54603891b67a111ab4380b43649ee1e22eebf24bcd35c5ff8606878b73e3b1271b8d20dd50461d5825e2598d299f836156b9081787c207652481d1d9705d2ec984711465004d7d1cb37def441ab0b1aef59f50165405d4273d7c21dc8b4648f812c59ff9aae97d794a7565633295e375e6d985b9fb6a65556e075a01c90051cb8a49ad72ca48ca37c53c9309e77d241a6bf1908aa8468c0ff2478265fe9d1f8c1f16111af07688dd55ffa17ac7b7b5d4c5431f6f033ac9be98eeea9d1fd45068acb486437049659c70d0cb597a0036c635492942e13c1155c3b5fe4e24f9007a553763d2c9c417ee610e697bd85af83b57769ff9bb424f5fdfe4f0138f90f8e673ce6706cd4bfbd2d9692e33283fafdec726b2e4c647ff8eabb9504c5c8ff304161280fa8e660ab66010890314429fcfc1713537360dbf71afc7516013e104183a66748b9d1dc3410d3ed3e01822b251fbba7a62394bc256fd318416b7320ac82b40acffa338352c5f17c05a2960195b91a69185bd64d6adbe435bad9ff445b2a34d687b65f0425eacb7b2b89dd9f94bf045a089bf6e06867242191ae3918cc7db9c66a14c162e7eefa0735a91047cf87cadc6091f95631af20ad6f062a88e5564ae0b4ac913b43ea16ad94270cd302f85ea4dc7f834e7286043d2581c1a3e91d478f7a608ce2e1ee11b784cee4033a3c88e128bd5545b130ac58acfb63676fa64c5cb5bf010becf7ad88be00b5cd5629ce30a93f4883a33db5b2c01c07980a2de32f7a9639741610a1ba6c52ef6ee65698b04aed5e603fe561e7adb456d2e66a7165a757eedc8e3ae86faefd2e6fd5164524d29add5275fe71667cf10ff4db77ff9886b026236da1e7a0b0ea59165592ad00722f5364c0301a8e4c9f3c6e4f08e883b7349b89251d3940a71955dc993a5aace1cd9d8580c12b23930c989c855bc9d78b630eb421967c2b670776936e1dd104672019e33c4d1255b9cc339b74d993539d6871e92389df667873c6809a03ee73688019b4265b6d7a455d9a1f83ef4a4f17cca872311b7401a7b653ddc650878604217cd5fd7d1d2014a53d43621c9c05a95819bd116a463a3a4d806e3eb9d4c3f66ef6345bcb1cfe2da7073893350d4b901eebad442db0808b319bb709fd13af8eb97577f9375de28c5d5db1eed54f34eb9f08660aebb1af2800c48a11ddf54b8b2e314b3d97c1a537a45cf1e6d074c30f4ce978042ab3ba81eff7779fb182b914db714ccc84635408aea800a3b06f0c2da4204156f5dce308dc371b421ce9efa27daeb11917d710eeabf064e9b07ee06496374d3454b0be0a3605b28f780fb64b62827b1a8b85bc507bce3d21ff1925e21f88dd4e566f19bd026324150ad8e5c7cdc8bf9a01369133a8b02a06e74f8d5c0904badbf8db1a1043ba67f5bf12a68e6e6d208e6d24bf2e092398017bc9ff3e342b00bd7c182c8742868be28b7b1f0e93a3a709863d17d2cc4e9ad9b842d5ee8dfc00d98ebeabc2dc8d772256eced6dfb5988d62aa65dc539ab288cada5173cd2b959e4e3f5536bb64666d71e1f17b56da256a66686837fc09906614823c0477327a3d97ccc21074286c25247e19c58c1f25341ecc49613e16f1551982091f4cfc304558fb87b92f7d6d39e09542f092c2027e50a4bdd9b2253b14a120dfb833f40d4a1136127f0ba2663daf5f23a9a8b90526d166a0be8385c52bba55d42ea8bb34b57fad472d8ae2eda7637a01f81931db5b3316cd7e6181611a7f94f67701258ebd5996e795eafc0725e27ad45b572b3e412a5848fe95a0532495d68816da8c5a51d68b039bfb3a60e0b98fbcc28d4c4d436e0f36bb22080388918422d35ceca95293fb32848eb715a3935cdaafd5d160f325dc13d43e1cfa5ed9c7933391ba9f68611ba6277b517c40c06497a661993f93286a84ad0744516f84c524e7fe41ab50267c668a8d8ce64d367931bc00866bae3e4685731d0162005fbbfd5628206be61852332ded63a6e4fbd9e93d26eead44271db4536ec64648270cf163d439583077c60cf4ac5c68568d02f2eaad59206a513948179b278fe38c7d07a9c906a2314caa8702f21ba57258a4f49e5d579bfed75a767120f867ee4cdb6b03cfe01513e9780953199de9498d55c6b7f0a9fef55f6a28ec0ed4bb411d9c884d74b6e919ddf57d8c97f73fbc72f6177e7a452db6302362ec3e751d21e3a63f7b2bc36a6a5e0f4ccfdeb7c3cb4745a9d96a84012a52884cd2102c5f3297fccb7f85ae1e1806be2ff189d47185286a69f70840b6876f88058e0bc88a70808f6aa6b9e4da885295fbe72733c5930ec1f7b631df2610932d0e2cc6fb5278ce331817e5dbb1b6055bd2dacdddb795b56f2f1188038749b6a080dc1d8dc4f853e89fc69ea0e3df32d75fac68dba52356b09fe6a9e7dabdc20c310bb70622e0c05037557c6537f15f5695348da81dd37935c3e291eda09974bb368aefb4bf193af911067572d511bc424b99593566109594df4fd3feceae9f0ecba7ea8befd785fcd28cc893fea7143d72f2c23daba0ade34a2fdf65a467c8e8f8113115965ea5916158dc948669eac9c01158cca2342df9defc825f3b14adb09c65e9000e98411f25073975d2476241485ef7e9b7936058b04eb6ce2141c2cbe6ddf23e3342b76ba675de0b8485a2e9fa2c12f26fb178448357d099d5f54ef08f2974bc79e82e655c31b8505af3670976183c329c5835f270ed26f70708b173ab639163a1889d1e00b39c5c028a5ccc099dbd658b744629f23a5e6d250641b90520a32175580a4c3f666ee716edfe8236ec93e16d741310f0081e9de4dc1da02b54a469181a9fdf58a148f4ee92ca3fd4cb6dec70f3c619b07dd1b8b46ede359c986d26b1b06320afac88087f44bb0c82e44f06df0ba6f9a1d8ec516e4f0084d1586aebd04073297c9e5e0fccd6550dd2a1fb7e48998acebcf5d6f12bc69237153074c47cb2f7e94dad5b3d0d30eff7b7d7e1d44213f2a620aababdef6c6c59f93ffb4af9d54ce51d0c0d4d76db2a3528fcdb62c65f6ac35972905c9d69c81879b04c2919b39b4d4def8416a8ef9161da1e0f23df8bf4ad4e959e141b95b9fe2ccb6670b947ba8afd2f55f6f6b0942684bf6bd298f50726c9f79d41d8fbc861ed61688df71ae4efd1d42dc7fa5d66ae5e96635b7db8e8bde6a822d7b750242946db98de6c3e83fc935dade5916b29f792ce24663129174755b7a1ccfa0b4c2730fc95061de6413be45704c127ce4931158c8a06cffea4ae23939bc4e56110876e4999bf747783a8ba08c7dfd5a30bdf36ff827b1030a6a55075136e4dfd80375e276966cf220147e4a679d9511c64871c52357b8789e0b6ef049a7a1b2a9d14659c5fff760063b2efccb948495eeaff13949e77b9d9062c7e7f7a4abedec85efcb6ef41bace7e14cad2194fdc9ac8cdf5eeecb1b42f6d99f07378812ba4bc206ef330ae2b5988864bb162bca83a8fbe69f03ba70a2d6e695dcd2a1c8773519880f84b6f64c04d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
