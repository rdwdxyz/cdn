<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6ea0249ee25ce07b3a46ee9579bab06be6e4bb5aa988b55236e92a520da9e82b76878fec036f4b59be8cf50fa9098adaa1f3ef6089e0df4d32677ffec8ba9fe47d816cd8b1fd0b67f100124c154a967735ea37c39edbec2f42a9e7ccec042792411ff9741726b3866ab58ce064ef7edb7b0824ac8be12a0c1f5c2185e43cae2b8198058aa584b9f75434578cf03972cf2efabf5593819cbb0c9e239497ea28b5600d3345f4a913bc983d21dc8f63785f0cad022b14aa2b36e73a97f89d54c026dc84802b65cf877fd778efc985436e12c4d95b350495277b41dfaaf2a367355e5da098c6b8714c1e0a0502d956d9d508a4774c1a947faa33f1633a736a112ce333f758444c532fb87dc280dc3ce72680a5c62dac6ba9eb951bdf7c0dbc8d978a4852ff01cb0dfcdd507d5924223ea6cdfccb91df367f7ce2d6d552c73603da6998a2b3b20725db6e839ecc883bed02f9cb188b1511402fad60ee8087487cdd203c5a03fbce1e343e6013b02f472e52ca47d62f4119868e53a527c5965831288753e68d1db87d492fc37fcc660fd55c2331ac09b2c5d031e6e38760e6f6725ef0f06fa5fe3a23016c64039fd9012c147ea482f0118b7d62cb8eff43b4196f75a1531bb798c71899cf5b3c5278f08da266c5a7f0a7afb81b50e4c8d7470ca3651a9401eb11fde828679a258462a64433b1c4ed8cea59236778f776c8e0264d4c6fe4ebdabafa200571a5f7975d3d47ece6c64c1e1d6bff6d3405a70c394e61cb7e75b6a83aaa18bbbc004a749bd6458aad5ff7a8a9da10e6953be2a80cf396d8d76cbdebfd339c228e139ac71e02343cb81ed240457bf2d99f7fd704dcc68a39186f8aaa6841377a2368edf3f42b56ecce2d029ed0d6e1b470470d1646cf727376a4a8d8b881864018be6c5cc27e5c55cea132ae08169eae9e3d84079e598672efd6128c40f762410dd48ef6d5d4cb5d127ed27910f63dd903545cb00c71844b05f7e49a10b5aa67f01999cc06078beed7caf7fa4bc178722aeccb26b05188b74e57e235817f827c43c2e82bb07c081b53b0bd8b8df857469b5f5acb653a48ffe5443abcd89c9a587f9d00f5863c5d991d3f8ae4f344d5d9f79ca08fb3c82072b1e235cb74c781c39f66eb3e2b213aeadf70b2a3f3c85680b34ecc04d4e11960f1669c583f80f4f6e4c4b2673d10e8b30fa3b91622751a3a55a23c3999eba82800573e6dfb310670513cf10d7bcccdd0502b96172bd0f1c5b868f9dc8b94911ebcbbae7c182b82dd6d4b3d63167db54ccc12dd528506ffc7bbef27c74e90b8b5c26f66d77a9e74254a5125755278482185336f25f0767ae4d50f144702a16757c0a533ba0c866f2b3e7d515cb842ab257b761b642772442372d359f2332eec22517e20df4b8e02f8c80e88aa576801a9f3f0ce3d1326888ac1e9ab2faa37b0be444b7f9bc64a40cd15efa31275f7fb547552dcab13fc2dc9469cf8cb04b366222368ae28888bf10d4e23e47a44cc7c99288dea7edb66aa8eacdfab86bad8626afa1835fb889dbeee8c7df6c852b46c796927dbe7915c664c1399e4cb1ef3492a79a9243d5634c2a28b398b7e35d468fb35c6029b346db238ab732b2dad9279d369d599f83f810fa352d7369c273044853077feb79bf3b039d1ae760ff7646f800b084af40ef8ac771f9c8ab856240084c20e77a09eec0a56a25702e1365df4051a5c9fd93c09d975f6581c79e9f03e893eb7e2e5f52384a421f09c7978e7e18ec52447ff5bee06088420bddebb342416320b5decfcb663151c436ebeb474a2f29525575f8f37d20b47b9454be0e5853abc1f8018b959d0b4db3efa1706c13772626393ed233c7c4d1af7bf729906f7b46f69e27e327c48fdf169dda7231e681f8c8d19a10540c4dc263818adc933870f3ab21b027b5ed6a2e47f44c39b0c7a99e057251f722ae5b2417e41ae0e32bf372c1975c9ec87b301658cacdfd28d38f0ce98a3824c8f1d7d86eea5dca9d462ccce299b55a839cc145f4e4523dadf52d2a14f00e39b132305e8e4c16f3e47ef60932faa3165b7a5b3bbfa3bb345ef30f71136e201b160af8087038239ea235ac72a32b815d909b18ee7c3ea81cff53b6854b461414054bbc05c3bcd63df411d03ff04fe7417dbb832d0f350dbebd739c68a279415ea7c6c511f8ded376eafae368d72d734725e973dbb1cb895e1672e8332a2e24a4fff5c02ea2d97215aa638feb57c5a3a080d058e499f9e5b0009d0d19cbe0230755e9e498e63151c45c35255cb7b8e74209994a189df796a4728ca1a423356142b7599d873e1f18ee2003eb4d9fd5f4d7ea3f271753a53f6d042f89a351859df81eb38eb28c4ffb8486c1721821675687391ed7703f3be30d9f58f408b9ae093e6bdd57c503b317d9b556846b8dd4d982cc788e946572c3094d71f1b945a1bb1544ade43df5baf55aa85099f3473ec7af0667e6b60280d96128656ba11e2dc7e24ec289d0ed0faea7a2c3723db59c197d1f6f1e7fa5105f0e9c70174f82267e6e75b0af4327e4a83968cf54af053a1d92ede049522e46b62abebd6d2d98ffec4c8720f4f47d3f89c77c411a27330ec1515a890ffd9a1ea630a36305823271d020074f66cbc77108742fb87ae648509c60ea4f998c2bcae1c201351a0fb69eac3b1ca1a1adf0ccb59a136becb78267ad7f9f286d84424902a2d012b68ceee5b1a385663b8e9d81be4b4c3e78c57a042fff9fa298ec41861a38bba0d81070596a7380450712d6d20e7c6d8bb84972766de6ad0f8a4c5505b470c57a6e2c112c58d9a302558606e36f65e44a3d911d52af076f63b8f531e5cf9abaf1dc053f8121fdd44fd70d47363c0b4560c45cc0b109c82f8ebb2299ac397fb139a45e5fad123b9c3bf88683b69d064418ad893ae2fffa5680b31ce9b14428344f8ce43d02b887d8db0d4e962b4fd58f6db3b22780232fc0928c2c168259bd1b577aaca45789423adc3a56657ec67f19c6e77c7258e6aeb4c84d4d96830b501ae57f917dc4678a73f29baa346a67909059fe326a5e06691c0c204874624626dc0b2dabd3768ac9ee8746803ffb9679c882e357e2b5a502c2098f705f5057d5dd7b132ee7c899ffd8c6b731b2596b7762fdaf633d24d4c5178cdf53ebd9a591bcd491b148169bbceaa67baac8b0cdaa2068cc8b10043247b0926259a263930a354fd967448c05efd0b88c99110a4bcf227b59a4112463e4ffb1e05de70fb394aca2abd008ae48c40ee864bc9e95af11fc234bc792b51f9e70052fa6ffdf73e0cbdbe11ab68c990cf8e3040b7c2d79a0d6517d276a147c46f221e3117636bb7dc472a7ef49c86ad0ee386abb68d826b6bcd6a401675a87019c7fb7a6e95b71c465568c4fc761ed2be8462f864be1e391b6061d5f2146fcc423452a303827a54c4fb184d4f41e94cfe9e4de8f8b7ccddf1c822e0ea9ac37da6150d5b3501f8ba2f262f0e77cab6f4c08bdac9df732c0cd2acfc9784a7fc26c65d8284e4379a6bdec4dd7a22b53154265fbf762b1059e103f258735d4fecbc45d4ce75e6fc9f0386a3f0086c7ae758e77e030e307fb8231a0bb042291e59080a9c3d87412ef15a627a6fd927ee813a48755397e5a2298a18ca3127fb744db2b83a90971c7fdd8cabce7c8a9586c92f717ba1d19fb983d7121a94ce86d30f699f624b4c19d5133cdedab09bff9d450d323feceee039384a8cc2d9954ae1cf52161c58e69eee84662634f8ce15739cbcb32f1f605dec5fb839a661b3283da4a1a871da4730774bd92961b5534c94f0a331c935eb99be856dc9bc98fa897a585b977e2fc4beb8f837666f6436e91ae11818a19df20ee21ac0f999404e77ab668fd365739af13bf35644cc9b629f5d85392a84d103735e5820019b7d86cd9fbb30aa7ceec9add90640bcfd761d3185b0426a17d04b48c5db9ee8095fee23834a80cf8c5897115b044faa5572b1fcef6b18d32e11ccf47b0c19e558c1335f557ca1d3216a304817e6a3a62bdf4720306d0cc290892f5ab8c5283ccf62ae1eabb75c5c49e1d32d617593c1e9f190556a0d55c4f73b95f3f01581c93c6e5762fb33399df2aa4ed85d82a50c70a008bf8cc4853ea5fd092ad4533d7e706512d7ea31543183ac37a374d5393f2019200b88e60f1f8d0e526641c0c22f924a5a26034ca00cd59a94122be21428bc938288b23407fd9561dbc721c0bb585688068a5d2d7c14c029c862dcf0593965d93d219485a11dd99cdabd44d7fc7e4f3c583937373f35909e6f747b03c7b106f5ba7ebe8fa9ede3bde697ecaed89283bfa8bdfd19be3ac0efddb53eb21a98e5fb968ecb17d6094597db105f198ec2d050914588d10b657584b92663e28e68e2ae253c7249ade335c223200395daecf1dc675d2ac60a4f190cdadb2be16f41b940da98059da235313e65ba5cc4c968e5e0bea556b496e4960832f9d72c1171a353ca62ee54a524032700aa34aad6c265d02dd85b2b3d69c9afaffb1e3ca3ff1c4f66abaa1d6829e7fe69294a4b473891b7cf4c380173a0b39f2c0597a8f832d9a52d2d1ec80ed39f9ba6c99bbfa98650284eab100fc62beff1cb475ac41433ee6db14dba9958fb8453e46a9b261d4092166e50cca38e8c4e0decaa2a7e9cd10d087ffcd1145f6af4e6d31674e4ddc69d75e4adacdbc616d8c40acb488af793a1e5bf79535b4cb02ba1a75281e6e446cbd5e89985a9763fe8f54709be9c6f429d86c76a9aec81ec0588c45e1e2bb7bccfba8250a361f925d345b0ebcb736dfe98d70d9d32590c4dbff65b9ed40472c3d81f1d1a00c5201bf2a0cf7a66bee515b6de0e332dc710dc6a447d90aea33b4f89137c269de1be3cb2d0fd99368dd5f211f338fb38ca921df238d398a0d392b29623d9c8a3eb24ce0e25d9d465636c47c33a5a7090635cf7511b91258a0ca04a94cd1f72c118068d5b52ee3660a6466da754287a2728c0abc658884bd15967024ffb913042ba38bdafced21304622c294f0986a10adc34a9b482bec4c324a1e733e7ff3603ad6c7a78fcfdb3abd06b3b670a586d09ae0eafbfc63e619f1c258e18d7250a0985d235fe3236ddfd9958a07c4247a2ae4dc089147905137b7b7d472b3ce35fd8990885f5be95d26baa772253e9cfac3d6b787442eef50fdb56a57cc9ebe6dbb2cb6346b16c7b3f0aa13a47796efcaddacc40e3c33899c0c5ce077483ced651983e388cd1aa9e1dd0d7e080bf84095a3932cb6720952fcb18973aebb07826fcd6c372d35852a682bdefffd574cb8d9239eb5b93f48058dc818eca915d745af14a353b1d358b4564c4e80dbfe8bcb7cd3168a93e86b80997631f560c2ee9ba0d9228e615e2af02f98e6fcaf82eea661678a073516842fda23faf554e753befa50df46449afe9553a9b123887a15475ff7ae8fdbbb5a1a05bebe151892da0e9b682c8cfe047e71e0e62ebd9dcf01808fff5bafd3fdf3b96af2fd0fb187c798d2170793cb9a63c21acb444eb4bf842f50284596e08727db270e6e61a1960498b7db21d323653c19ce2e7c4c12087b3567a9642df7aa6d1a8b5c2a6a567f6b235c652eef3328e78d06a3b89bb667efe53b81de24f17390224f6c0f1ea877c58ea1ec43920771247cafd3049c8a3abf57e989a1fffcf0e0fd2103c5d3c8404f96e6d0973af1d1639969c5850348d4211b4fe28dee71d4120187b2df64c348d7cc8da5f14f88d6270612d92bc3e53f62ae34ef743b69f9203d841f4148f56e02393d6b4fb67b1dacd3819caa6f0d75d72797190658ce6e75c6894aa41386d5b85146014beeb517c2abea02e6278842548ec8f0dc28d61d31a4e48c5ae1e63577f403d7ec12024378c737a224946176fd46c595d40d535910e6e2c203f58ac103f695325f67ee1b05d0956dbb59279116b87e33b6cef871ae606e0aeacec8adf6c4e02f3796bdbf939b3249f281f25dba8cc56d77fb6b6c67424afaa998391dfa96d09de6a3bb99ad1584d7f7b88d5d00c06ddf2a711389cb488613229eb51ef1cf6c9a42fcdd29057e8e4ac911ba868ffc601cea79fe32e962cc51fb0a5250a72ea2e38fc45680ebe64379740a7e931b1a5d6b12c89d59176e6eb6564eb723a8bed8ee010aeb1c0a514e857d76e4d139e4827496cd4992aad0df6b9c2a6ec6cb16408ac4404c7a8768e6cd98dbcef67da2f4f648ca9cd792f82b73ccececc6a1568923bab3e4d45e3fb43e622410b23eaa84a126857fb9863b1d099f39859f5d514114b4fc7f567244830010dd1d5d141ef2815deaa2a3ef90aa08bc350c9f4cd9b487abead04cd778395dcb094d78f7cd4678eadb5cf8559c5f97accc58443c9ae33b38b55745354c0b7724c4990c3cc94234e694a392ba992d5adb402324d146d35d31d4c64523dd881cbcbc4c7515402fadba33adb051187f2b0c132d525d2c5cc8d21df36677416e1c83a5814d6caf43122e8f6e8a9dab5cd7497c5d601442f0392bc71694b582b958cd28af27893bda52fc8a39142621284bdb019cd1807b0867fd73c5b47968ba3b65ca69c96420fd000dbae8aff7003c4dcd9d3c46fd09ddae3edca56681b28411e087f72615b45f31b8e9bd973d39b44fe0c1595ec9db658324030cda0c3addd98352ffabbc5d61d109af605b42300b2d7291bbb6ca71c7fcdd0728c72a4ee945a9c2e9a11bf760c959a055a401f01f2a4276937ce8e53d806542668a17bbb59c34f736ad60b47a6a7a26281b0f2c9ecd5acce16bb14911901e5a605af72aa95fea79e3b847bda295355ea1f985e49862a991bead0bac26e5dc37da5d39c69ecc26efd9c606949fd303462a523e517d0f7dc44f5b3d66797b20dd45178e1fe522da859afcd9997aa802f95d6282805b8b99ee236d436d64bc1bb1ecc5bc97e795f21b773dd790b6bf2e57af0cb9101f386bdf300f7d1b45d14c9a51f3a78ccc585b2f994f2db3a46ef12c0a72c02e0c0bda0890d681e0bf0460826b631b3ca0c5ea2bb7d4d073bb8d1aed5d0a223a3d4ca286792ddd624f9c426fcf2a02712fe277b8de7adc7d0a6f336dd9fbbef6bd59112340671007cb1930b7f6f11103b88d7a4dbf4a32a9f5bb550746b2f713cf111990bce75cf8199a6fa9accd1d840a31d237a782143d34b32e3deb5ae0b3eeec6effd2ddfa91cb54f66ef932c6666a96f3fb448e51e9280a9d423dfb14102d8aa976fe57f8a141df8866e84f0fd497c53ced571c473eeef5e381583fb8c11c841326f7aa057535bfd75ebb8f8086ddbf0afa682aa6b5218f964c607ba79a204ca78c8f6b4d8287819b9bea845f60c787e2915fb27db288a4225956ef64b5b4fe544b72f03ebe42b6c99e333b63d8c5c53d408a23b239e2204ada2549b1f87b1b5f334f70ba6cfe302d611b8c05c97434e52d2994a8a6bdbd2ea290da27cc95c31ca87783f84b21e9b7ad490a4ed6d2e2483941d21b4504b722e5e328f4816f40ea60cb424b72199cb0fce20a497992973be631c3c38de1387f7690a8c879b9b0611b43f52025c6b5aacc8c79d4b3a4fa98dafdf0648208bccb249259bc8855a5903f7b0fb75f1f192dc7f0ad8bb760ed2576809dc0b21c2051c0212fa73189e5b5087ce484ed679b79d7a1ae2a8a166ba64dba90a7b8116f2a896810ddf2b99947a811762b563e7db59bae82c97f5df6e00051b22e079d2c7f6f5c9bae539d0ddb3288e93379da9a3b2bb61b3e0fb22634619040d8aef09debb71d7c374e7f48b3c2071ca597d6a480211a2add652f35b4c4e988421347dab6c0b885d27ff9c27598d53be150e401e2ae6eed4d946bb4bc34268047a7ae9b9a1f8e6a6ed22ffcecd11cf2240e2405d68cb26084e2c78fe7f84612018dc98e64b8809a24e51365e3c21576648b47085fc4a896071503702ae6214c4f2f8d2e0c3c50cbeb0ea12546a20c5024dbd05780b32ab2b02722154f29fd295fe9a84452d40caa58e36001143035039219e932051101a008db559202a229e89b0f8dcc11ccffc0502e501a2e3e999c3e30135d1f46e1081bacda426365f7ab5e9cecbb79cc410591eadaa5e49b1e4389dbc8cc117e026860a87440553c942080154d9430e3923eb429e9347662ca6c3448b5d75ed26519782c711385add5d715faaed01d917d9fcd611180fa4df2ab66ff8371d00d45a208429cd92348e95ec75fac4f5808078741bab82a78191653f58119e77d605f1c485afdda7b59fe3f4a47f68e676bce4a9c04639f60b3db53471892c83af881844caeffd279996a31632cc12215e956ce11a4e1b5da4dbefaf8f44b874b5307f3689c918b706c677d2904042e7a5b573ceaf25c0a5a317e8437b676b00a0974b1818df8e7aa4f87fb96318e5c963bed15bcd98e3f6ccc4dae9e9be87500321364da49d6668d540c7cf18cc0ed9934a6e2347f41b08ed51fdb633b05f1467cf068fc3039f56295e8bbf89666bee10edbf7bc8418646fc8806998f6ef20ef65a922e5e13bc5adb647d331ed3925665e64f4828eb63dbe2dd589af410eed758e657229312e810489c487c2f8878e3830965894ec3c60e67e68dc0751bb0bdf9d62c11770339b31f14d3db0e0adf4445b05e76c4e482cf4c9b1ecbc01efbf86f162dbadd63550be5d5592c8bf7a201c03452962bb4cf69f0585f21d00ecc9a1565719fff3cec13c07db5a1480086465bcb12d3346a37545b75f2590b1bec3410c868c659f0b8f75c1eed096d765a0fef13d99884360867dc19d51375386120ebd9889834bf5768705a75361bbb94b87aa448af97db1e30e88a54b6517813fb4b5c717277775860ce943e553ea8c1570d9f5dc5aca90aee503afb3cf9e5264d5d9938395b35730fdea09c8faebfeada8ee535f95c4eb107d4e8c4c07c8ad569dc22aa1f70cf235651b80bed348fc75fa10a8343edddf4d693fa3414d8d87e99b5d24d1eba56eec14821369fa2c65fbaf14862dcd1511603bb969797edea8f6f7bc3f3e1059e885e668da228bc5e5b7d33bdf7b897f8bd1177613b8c93278847a21d329eb33d9672ad2112ba2d18e515892faa71f16d46bd7a0738585d63987042da6d0f86af242b1ccf98528d51e9b18e716045c4495f2ffb93ac0ba4b9eb4f4b7630af640b6bb7cfbb816e510aa4c57bf3f994ae57e4961f7185d9c17b85521b62c0df9b9a54f5107eeec275fab5cfcc25a2afce451379e542c00b4dfc805b00b94ca4e0b1bd08ffd14380e1b9d69ae676e748e7c16fd602617936259e6cfbf9f8bf5245a8289815f2963703a377463a02d9327e635b7919f6303ddc5d1dcd2524f4abf94de50c67a19ddf465dedd3afd10ce9e2392f0436f6c9d3e5ac2b2b2f115c7c072963653b77cf297512bd38e2de05bfac7b6345bae8e161697926470b5438f848d677842502d3bd3777c32ab3a8c08ee90e0cca20e2914737cbbca4ad77d803e9ef089b5d47de6842457ab20375f1670947cbcee021ce9ce568c8fdf986fee73a1f4a95c2739f7baff105da2378b9ebeca243ee64b89c2ecfe3f1acbebb089f853bd8805beb1db7e95ea9210d032f30de2c0c504a646ca7ba6f0423a6a533d246a007a9c5e3d8c5ff92487dc18bd7837b01401b4a16f50781ea660ce0e2836de1f0c802ed6e576c519b6e76e1b5103d7f97ec8d87c610933f18b6dbc97c70865e3d3dfd23d3949491db2c7e8b86ad70f9aac368de3a20d71e8be61cd89fc80daf976b5cd8969544cc0d67a279373dcc9825f74b8ae8ef1d50e10b67b59e811fb411bf4263deef789fc8f3d4651beac299ceece5aa050e19c3ead265a2141703d311c652c607598511a87ae06c15f2e262dbd971e5701089be33056b455b66e9ec415d63ffbc79d81000744d774168190326412834cb3a4797876ca48f5213c3eaddb6808cba3b544e29bec255a1ec518aa3ee32e58ab4d8ea3038fb17ca1323cfec0f193b1828825f32c7cba1dd2081ccc2923ddc61777e3def34480375db05d0b7781af58cacceee23ca5bc1396ab241e0ca004700c5e267b371f3358f8ca58b3ac1320effb451c6e7aa3f3daf386118a7b241078c08ee82988fc7408ff7b78a1ad9cc9559b84a96c69536ee69491d66780f0edef86015bcf85e8b79d6a23f2cdbedc3f633baae9ca6e8a8500db33a7853c9bdec15cc66a926e97a3085be9256410bc4daeed5d620abb78f835468d83fd1f74d41aec4777febaa621cd336ee183846e4121268ccb164b67c7203645d5b30c9bb63085fab1c59404209ec46bd367a17e1dd7359540d8ccdf38237ead25fb944f7ddee3b7ad413b6ec51d342a331087c10d2943e5bb5ba45107b6055149d8e2dfd8d2a09791d3210c54dbe8c7ec2d9531df3d46fcc084496099ad22e4826621e9fea3a9ec1df40323079234857b28d4221a2d1a57cae039ea5e82804be42b1eb308c3a1fa056333b991339fe2d8521375a88191b564cda571347a8134f129edb56b6e63b9f889008c831e193c3d527d5594273cdc7fb9b0e768e062411a8ee0af758c21e22e143fc1d8ec0b0643e3c6912c81fc3ffe5ff72178a118a610d3f0d79c5697033feac6729ecf529153dfa6790c9b75ef8432665f8f779e3c10fe0e6d7ea535386de8a29fddffc6fb8d107022bc178d5031c07b9a108d59840fec06b42c907b07cac2290c27cd5f2dcb0651288f802dd3f43788d27220e7586502b6619ccbd95daccaa202d739989d7e1161880208e37632e568e8599dfe21cbce014cdda2d1a94d257b89cadb152204d7d38c99a074d942d04e78e290ef64c7fd7ae620c2365df2ae217c7a3cf944ae424b0eeebfa05f42684fac635dddf9a591bf7309809a9bb86b8e3294167d7665e064a2f33c55d68ca54aa6959cd6bf1eb1eb3bd262fcebd894e368fca1e124eb494400535baee7a3ebfa3514b0631a063b8fec524599a061909387b8a66c9a3352e2dc7e57af4fb0aacc49c57def81f94b354f37e68b9c9009645efc7f54a62d54afc153babf01035b432d8eef46a1b5c1a139967d076cb7f5373e7732d34194cf1153716ff1e3e35f8e061e6c802fb4dbe763653e0fa92aff192fa5788d7d4b3a25605c628587155b6540256eda0914d403e506a6e0ff6daefaf07f8b840f8aa3f9653b783ef5ae0a6c2519bb88bca3d27eeef0bfdf0817e74ba9dff4d836dae9632922602d5c98c3103e8eec0d70e5d2f9db55f69c8c8d56c8a251c594c04426cec24bdeeaa0f52f85af9c2d806e8445e812daf084f7435deb6c808aa5ce436379c5f03faf5ae046990460a716795830603aa74f49b0d98249a15474bebb5fc9ea8edb7d6ad5da911980665308f5ef99028c8e418243fc4a4a3fc61c22473ed44cb53ce6706fe6b56d25f63fa0878da1b2ab65353fc2b30dcb524a284bd5dff57d1f26ccbb4a92fe6047c4cb3a36115ddacbdea93bdbf4747289cda788884d78435ad1f78e20f8dc90c310d3e6ef84572e4cf2dc56c237615d86ab9af0396e9e6404b54e40d7489417f35360aa6204370d21859c0f6a0eabd4b22751be1439266c9a52e3e9887b78f17dfcbec75cccea8710bdb89ac44c7d56a93a56414194a5d0cb6eada330b55564a624e900adcc039080f74eccd348988577bfa01af03f4894acc50be603ecbe4b2000bff187373c04be5ad7520a69d46ad0963a4bccc43b8b5f9f02b0c712c33638fbc03b7c0ff98b6b965a7a745edee9f78e53ad91f292ee03892141d63b1afdae6f0a5ce62ee55d082ef6212721072af8eceb59d0307f885ee2af7defeb6c8471eae89511d5f7dec464767c98769c182911fbceda92a8465ef6cac42bbf900faaa1c3bf04931a98e0ed6f1637120532de71b876cf28a61d92d3550f595c311891b5cbcb21495b57f9a6594d545c4b94c6237f3645a7eba618360d20b6fe2ce0677aafc0438a7a18ce2ba1be70543e8806b101f3b1d721748b296109d167eba523d2d4e1cf2b4f480536560952b55ac4100205ea6138a94fab12ec5a873123ac308ba354e95398a7215cc479dc762f8f6e3cfa6d89bede0f931e7710d76378468ad5163d8b85e0bf1b594178a92d272e5044e75d855736060292d6b2b732d9b2978415962ac1d08348975ad88ddefb19dae002a1342666bfdf10a62bc737c2d16594ba0d8463e427a195183bbc76ee4d9739d7b7e95ed368e2406d26cc4ff87aad1e7f8223a667523e847dcdd255432ae7843655f5dca53303c225881dae1fd432329b029cd02bfcccdcc9372b0c254fc0cc5db3206a5bc8b3ef52a8f5b04e2a581a9758dfbdef1738d2464fcc6be3c4ad780547772727c20ceb757913edc47bf7c359eb110f473f2c03825579c7abbe2b2aa38ef7b724eb5f0b6cb1903aebd6329a1986117a11c2e4900b3663c801385864a7b62e9dc4fa247612c17ff78c2d08dded2a9fed9c617b598edca67bbfc31a9149f863b4c44f5060c5f568a5f25e3d5dffd72a20a709c5d07b4770652e7bbc84282449cfb0a78f5e9088a7e54cf5d9b8e39d06b053a00ff4c12f0ab456639bdd66b7ce32e587222c1548dd5b0f781aab088082302aa20624835f5f2be695a16bf624dec50f818af77a19a75ac7135909a642031fe208cc298fb8ebef137e84d2ee1b31230f70c397f48ef899b163f9cf352a41192c32494fb61987bb604a2b5a25b582bf90d24993d6f8ba6dcc2e8969ce3e8dab7a1b8e99093e2f069aab61f6aedc9b0f0268a9ca8da55fa0298298cb601c2222e1a3778b119eb7926a3880d693cce758221ceb0e409f1a11f404f00f153247de4a2d108230fb27e69e6d6b578fe4cd0d410ba901fe5e077d8e9164b1dd57781463efd2578247cdee255d222e610ec193b256407d42118072665af5e505b87dd2c94c7b35bd0ecc7ac6b873ae068f896ef235da46d2efdd01007de886805e94eec778a560ab5b32c79dec58129acfd032f7f779f7494d337346a17a96d9b75e7e410adaed5e5738cdce937fd88e4541539374c54f703f0ab9f185aa7c6ea48b19641f2d2043d4907ca96a23d66b56c34a26e0f187f47d6fdeec04cc3c2cf9f5c8618555fa1ecdbc56102e938d8dcb37332d50adac7d830502ae8b8ae9e01155320452e4cf5ba715233b5d0e5febcb30192c38f1dd8b613b9d6d2122c6aaca16b599ab62c3db28c532a728cf852a40e947e78418ec9e957980651537e437aa0379e5379e389f05fb65ebf644dcec4683d95271d8b96059b48ba6051cfbbbf0423be490aba5ac8a5500842aa57f9503f1379cd99ae345ad8d9552facfb933d95e91168a146fd4d3bd521e8b380ac3542d08de606f8b0a51ff9d6bc26032a5ab920a7e4374eaf2d1fda3186073f51cf6841887c262bab2561f0327cfa310b4e696a922b941e2405248e6ecdc21142e42fa7a335b9c7ccae72c7f5c50cab1aa3848a45664997b5a17fc49241c1ff6268a4a0dc5e9d5d93668cd8978a1d0fcd328c4be9bae2e81eb26ed89ebaeb68b21f0e2cb8e2ad464baa46321473d3bf2a594e7632a59eaaa25307f08d9a9169fe634f45ca25f4a6de754fe3943e47b97f5e5d1c84fa3667f07ea565bc403428a20838a658a789937d286e5548b282293828127a1f322958ff3403286a1211ce0f91ccf52aeb191f145ffb288f45eea33ee6ac23784ad3c2238133d2b6edf41e9e8f6c3f76c6500786cfabfa2641d092221c849be71125922197ec8c1104a3c7b262f25d2b69b59f4211915d855d4e334d30ad063d4a148415f5627370c2abdc7ba1d14819aeb6a750c3c4c9c2b33f5fa5180808dc5ac4e428916af0e8e8ba527848dd92b5f4ef927614d0fb52bebd9614c5ea3efb0c7839bbce25630d975122e72289c1602420cb2d8c8309856b6e57d69e710001c8e5146ba05d7feb8e69c33b88e13cd13da4a515eba823d024d75ee48aff3a612f711e94fc07a7a3155b211e1f9965262d6adf35e4abe50805b6dd10115ef8b33d093788ad9cc96836718a5fd1053ae8239764c5e028eec103cd35870b7c9639419766f20f07c7be51c6ef48d66e022427ca0036162a733e9e7a615c8bae2d219e3e8bdc0037f08742bb691b7e9016b67e3d3fd9fa54d300a31f56b2faf6cace2a0696fc05f8dd4475dcc901240e6fb189c5f96a0518a4f13a370705626f5f43d04d683a82f78bd69c7a3a8f05e303b9a7e1a63a09eaa95f13b46c0940859a916550041182e8399739771e2c4f30a2f80831816fa279883a63389d3348b242ea84148f422655b89771abf6989138029036961cfc3dd48d9a3027c73311267cefa05a4372616c6f343ae2d55dcb75ae0061d3673afef1e4d3180a5acf201478ce331caebe9c307d6aec93904a59e659827696815fda14d36e6898dead5a145ca3ea61c04f21a802c778be2dd8b12b806f673ba95c4f67529399ca2f366f43ca6ad0e860d794bb657c10da40b8baaa4eb39f84395ddd4f47d65047a3dedb28ab8b11b6835b43e6ab7246586078a848fe78aaf3c8a780b51a9e94c351f0c503c764e49ef2e72fbf920b5e3fb16ab559ac2bc0ea7d6d85a9b001ceb241fcffd5ff98392901f5a109e72a9524979d62e6130cd3457e4fa9769d2524caf4dc362315b9896f070381063f0d4e175aeb08a05176f04f9fbee44155a1ca1cd354fb9dddc20c6df9e96d4384254fc5b6ac9b8675049710d079123c09e33cab3b5054908d8b160c2a5870027037689221e30aae4bb620700a0ed2d4228c1606eabd8b50afc352343a144fa33d7e503043a01b482eb60033a7ade82033f96a9dd79298843c9a9f468c62bbb9c46adbd918b6531c2a78c340b161069ea6714c35c50a1188ac4fb77b1e4ce4a1643c4f65254e1264221773433116f855f361b43b3e138f392b0771c92f24eb9316a9493836eb280b2a54cd873fef2df91caa72997a61ec562f96eb38b8f8adfceb13e534a89ecec8bc044da3eeb5c48aaad6c7e380d900e7d850d00c9971cde08992286a6aed333dbd41e15178b92c743240756101d7bb9c454ad4ac85cd31ce2634e995089bc8f4007576f4b4e72d91315744d181d73f9755540b68396f1741adb97d7557e6ca16eec0207898f8fd93775f98d8937ba833e5d625292470b2c4e7421fbadf108470b8319c1a0847e24b9fc06c57c1c0fc8b9d9a8b1f12f56805c6f2be46f0efe458480b929411ec262953442f8716460bf0c5d28c0607efecb9e1a046d6e1901ac53772f5900a3c0e47c46b384a11a8b41e42003d9a1cb5177e6023a9b3700c96b12ed6d2743a8493d23a45f955b9faf03e18499fab97127c96b1209ce987f2ad4a527ff867eaef0ad3ab367599df1421e5529863e4dddb92d7365dcd7bbd2f17f326ccd888dd452a8ab333b0844a4dfe59d040108ca709619dfef891c9cacc06fed1791ce9a439e94cc3eef885638675e5aa16307c43142bc1dc26176225320605d1f760adb66078b6685cce6efc9a0c4ea7b1e70616feab425cebc839cb2836cfe07b6d46aaf5a8e01f2effb71f71b29354e28890d96cff986c12eff8b93c24649878b6f728f9d4f9985edb043644bd97904dd5ce110087736229463acad77010af7fe31c932aeec7ffd9e5e660dc55008ab1359c66e8c25aa1232febf6592a498268f3019db23ae9c2f0666833e3f5b6562ede450ea014b2f27f3b45f9cbbc3acc7ee64bd67f83035c38e3ef24ff0e18e689940c2a5171c4cb2ac001a46863e9787f3a5e1248111c32c988c6a5b1fd9111a3d09bf01f813be5bae3809c99e3bf849357cbf5a961476448c4eaa3ebad25320f406eea1e6485b8c887931991a926cb724cf94a80718ba834a1dbfb79d9918aa5f9fc89e637fba95869c99caad1e71ca0a8681b0d404f9c558702f22a40193d5eacd72d7e31e01d2f4974421970a1f01bd3fb30d438488431059b97f493f449b31f7513a9f570d163ffb501c78dabae90c2d7e31a4ca1d68c131ded0e5619ca28bb5707392b0e9f1704a1931bf385ee5a1f2a967ce7f2c19b9d6ca15984f5f9855a34dc1041a5637111e21c3639dad762ea4bad5c0b190ffbc87460f833ef387af9ef1f1cb67c4095eb73cdcd519a26e5c86bcd58a96a2267e5a69f1247f40d8f4c24753a27c0546380bf7f6be63a229d3f720f6e5ab40ff9147cf5c322ef2d77f2ee3606c2d8f6adb87e7c540aa62b82fd27a5447ea5664803bc87e6ee8189b4c1df8e7b717e6d356d0294ea63a7cb4df8583a81410c4da12167462ad5de957f9e6ee4ad96dfa17b16ad1f8fe0ec50e397a40b06153e334551f89f4748c8144706ddf28c7b6c2066de537629676ea381eef3e436b4addbd2092b61dda2dd7b8a9fed8fa5ce98366063a70c3c27675bb80b8529814b2d11c6cf98f28cb7977ef67e90212851b501aa1429ecb9e16f9a3b63d28dea24796c694ab1c6f5abef187aa14a8037defc56efc54c6ce109e0018dff5ad511b2b4a3c621f42aa27864b97fd39a0118a59da5215c080fe6e2a17cc6fb75349ad88c5b675dee7063eb1a0b935ef26288b7e4bd13cb798c384b0bd19467147310e9839917eb19ebdfd2cb5033d8e1176328387259bf099e93a5cb1d945eac48712dab316f30857afa609b7737b2fc52d12bcb6240b724f6a50c4096fde5170baec15e595520f46070c728fc2087ae7dc12286b98cc80658f3bbe3596c4811ec491201f0c838d921cd3a2c25d5e49cc84175a1521382c44042259078c3c81a634557b8fb84e17fd235560b755482573d665bb8c558c84933f945fed2317039853b86b633c1267ef93f03337c11a7ef8ff8cde57a40fdf95ea711c57acd8957a6828fc3437ef312ed04c34fb242e7d045b5b9c84bf8e6446dc0d3c4f79d037b128d9a6b8cb250233bf99f9e49d4e18eb3069f6b0ea0619d36d7e7c53e7badf0412365a196e57ad65f20d40bd24c6e2026a23ee61eb6780f9c506d94fd477314a0006474b3dc3e1538dae0442d7da8519393e9b29b8e4c0b89a9892d886b7132542c1dd31cd4d17238d7f253e409f6c334f4bd3397c4690016d7566f7488e1bd972d8ccf1916b32fff196e556b7a178f3dab26cf63968bf080baa5bf14ccea66e2180ff231078f694c9d8cac433b819aa1b914a08d3ab056da10c003a61808e25abae76e4b798e27d50c45409f1c5f53cc70b7f8737a0f68bb3b815c316669dfcaf7cbb0a54b1d074fc9700290a82db5eadcf333fba020a158b8b402173aa33fda4745d6673ff20f94dd26cac766a346eacce57bb2a1b8888f7e9bab3d3f370384caa5b395fcc01a67caf9e04116d7e11aa077a996ee4d38f842135e3525670137541d4ad0c589be8b0a279cd2616601d8603ced32c72ed3efb411afca11a98005b0047ec7a006a715fb7ec696ffc2832b6cd7e2896de06a75e74631f6c76df09c2e6acbf006a1382bd4124c0f3214916ad1a0b0317d8de370f29efbb063f77c07d2f312f9f47667d5338844f97bdf2f2e8326006eaabc48ccc2d22d2d24b1dc3c2307adb1c25605fe5b04f22fcd4164d6bafa33ff6e24db5b34132be30bdc934a777f9bef9400a71d5599b4a20a412ab6a354131ff77b38f4f4befdca9890152d0468fa4c18509672a3699b0629464eaca759b96d99b1f027b894c90c6cf0f1b5c40da314156f70e646d0951a537b5c4335a676642125524383146afb68060462ed87c270004eb83c99a35fd374a74c8c9b4ed855e95cb905e1b7ecd4bcb6d6d78eef60ecbd8bc921d40db26c22e6a89c29b0472510fa40ba96d8aaadbfe7fbd0227fc8dd8b08a6ac7d1f25cc55549f9f65f405341350c7a6a47924f00570d61b31a1e322391770c6188fa8ef871ba836ee5120f78c8b93895cb92aa779b496a2c38d5a249691efe440de1994bf0ef38fad04831bd1e1370c979a1dfb61c67700ac0f37580e3e95680aacac4f740d9c0c0733354bba11f9af43d73f2b1a7fcf0da4eb49bb666f4c95c92f68d6ad32757af28e3fc3bf70c347c855e9a7aef668f2a889805e8f36d605efc820a79bf7ecc6cb63097515e985edd3092918df02769c9db8da5f9af24d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
