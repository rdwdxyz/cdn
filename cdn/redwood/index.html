<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"290ce5ac7591b4f1888cb47f272cbd253280678610eb140bbbe2e26bf949f4d993e46eada4fb7a9b68d20347e89b781c319a9158c23ab5b794ec787f89c366edb61144cee509e3e9293f053d4e4b4d5e7222bcace4dfddcf2e56fd8af91ea79f5a4d0983f5243bd70167bb24951592c9845b7dec1e09914bdd8db7577f13bc6e415ee5c467e971e3f778255dd83256af2add62fb1907e1c7791400968464749ffaa5aabfd20034f70b88240b16ab923a48714422d3fcd0c91192ac92c8478c2980b2de14167174e59732fdd6381735972346c6ae5848380603e863ec0ed37c98a61be187458ad83b3b92e19b4c36b508a295e9ae3e8b1ce76f184c7c1bca46c2c991155ae3d897cce880dd938ac98a56b4e0b02d0a3d7e04ddf51a66e3ccb1b80e4d923aa6df85f861cb54d3cc9fa81e6a7f4ee86d75fe55cb1845c21a414b35f22ca48f12c70f6c2f590343c62b8b5f575266187e1d493c87cce255c68e2539e889072d5347ec478e79efcffa9243505d3d44c90e9d8d347d94a4714dc73ab4422102fcbe82ac323819ffe31f7f97c485585d63d3cf28a7dac4396a19ca08e5fb4b0bbcc5a6290c1bbf2e9a842947cd177f352ee02eeb9636e188727f051c7baf6b7750c03719bf74f8913e6f1b6abff38630278884c91342810e1cbae9178b991c10f7fde6a9be59aca2812dc30f69910b812e04817730b35e62ce008e47cac47c841562955c3b6ccfd493907061a4137839981f007068bdccdf0d18115ec1bcc2963f25a8421424fb667e65c2605ce4df0df2eccf66357650350218a8d3f59fd2769b8169d3996141ec77bdae68742ec60d86349b4c6ad64443a38904f34e2ed63385db0b628900d2b512a16c12665fb01e379dbd2f864dc79fffb0ceb5c70c4eafdfb9a8a33430b69e28791c548ce13cf7c0530e5f735d2a5f5d36967d8fdb3d6f0ead29968f6c3d009ac1a5b359644f2055e3ed845e40a7211c262d3ecaa7b4f500b7eec540b4ba9fcf32a68d9d0ab9f1e4a5c7aeac355e5aa4926171c9e8bdee83f445353a20fe6556fc3bcb05f22f8db4d37f45e6e5361f60bda2b7cc7339313d826f6a375faae094edb1e3afb0c5eb408cb83367864b09822ffd4d3a4097eb0e58bbc3596c2c1d80c02425dd30b0bbbe47c9581cf92c0c65605d1d305fa4fd71106322f2b4052c728cdf4549c8e56f3f24a6da92d2453434cc1f157d35c8d6de77c65b912f29b342cfa8b83b8726cc5ad8a95e0f09cdca9f03916e51a89612d9135c5ac1380a74a101b65ddbf2c83a49b57b3413f053ff5c5a39c2132010b9dcca5dcfb6b18431ba223b0971bd4b10bc4575c331bb0d13a34bd7d2ee7712063b28679353193f26b1aae4c35f41b4312d3a3ca492c06afe267fd95c4ae7bb1e7a0e87ed5725ae8e5282c3033afc2eacfc8669b8c3acf709241de9f253f2de067a3633c2a609c52ea469b144d62fa5631832bd860b51c74db3f10c5f68e462972fec57711815353d1cb1ba5e64119bb119a19a1d589aa3bb94dc97a7466a6a30c68b6ee1258b9945ff7095fbac76e25febfe993ff91930054db10cc79ee15a0ddcdd61053b2486489c7cf770889c91e2e83a6d8e3eb2db66f1a2ca592d7b7f44228e97b57e634f861e393e6cbdaa84504cbe095cbd0d846719f4757cb4be00a5371c9553579c9b376a5e20161054e95d1b82cf3edd508a7b279b0ca9293442361f48c740507a328394e88f913ffd7c45a84f62a8d0b5eab4623d59396b906158348248394ba535cda9d2a33bef97750a473f217f4fb6a9d1f59e1fbd42dd838926352baf0cdfc301c73e61bbaa9a25b351f10083d24dce4822783253cd299e5f9b2c213224b71c8b94bf0e174f9c02129c1b9c417bc4fe9317cfc74eddd15a15dca11684712efcc49f3539b6ffe74b0ab8c3db82964bf9de89332a04bba66c7d41d5f41c8ad7c7c8eef0ba3b4e5a94af70e49f69e6fecc7b34d2ee6d3a0986f1ddc1a15e608a07f8e7494f82553e0a779f34e24a7828aa3d9fd1cddc3da62698c72d6ba2da9b018d00d20fe24b03401a3260ea43c195441432917fa40a3db1991356344489ede82c3ca1c431d98176b4b914f71e016ef10b6e68b9f3dc06e901b7a69c87dac88c11f27a546fead89c1d27454ca3ad815bb5b5b6acf95aacdc481172f0c3e535e9ca0e388d75b1561f60029e59b3f0f13824c6ec0a39c224d23dde264dd70befeb0eff8bf1cd291b0f53ba9643c95a1ecbdb40e9e723e4053db2e56342b10a9a46109e2f77f5629c10fa0ac4368f08465c5b7a15b2bcd4b819bfc67be47d4789341235c4aa1fad470610a01c37df9534897a23eed42a1846f84d94e2db3febd3c943e878fe6fe782e5c7311316450bb8c91b492be34a21358c315189cc75a3d0522f3d714849a6ac5d0856b81c0c0a381f7cdf144b9c0666322ad0f46b922681f9ec94fe7747d4a0535602c99d0a08bd942fb29a0053f339a4b4240cabba6154ce5d1498defeb8f772d05dd2091b9f7154d1872d1e8b35f31a58f0baff1efd8f780180fc39892cfefa0fb86dca07be1eccadc0b559f293b3deac76fa9daab74a318ea16d6ba2965398175d9c10228c2c172474d8111876fe4060cb60f7e2618cde5ae7d6758a1fd51322fbb956543cecf3d0cedf9418df52c52637233b724d704a1f0ed5df5b0eb36ad700a51fe1eb74190c0e466ccaefd78d8d3a127e9d50723ca4563f6d5ed41990d249c6929945fb639931e1142024bbfba0a6582d200d5d594a7d12e377cefea36d5b129e85e1090553480f370d72b2ada32024aa0d069e8b8a173a2a40b4ae38d1a881fdb3f9a0de710337692c948ed77ce1aa215950c52f0b112c12d59c533fd776f13c911ddfbba6a8d8367cfa97c4d2403aba22e3e0cff77ded0635ff7cbd26b0b516b61da5adb0a2f268382e361a7e9b1516d5ecaf2a0d3b3fe931adb82b4ebdc78f55e58756ad8dfe2e2aa5af4b8b057b78033a7342bb162815df7eb6b7b3387b70bee90041bd52d8904104303c4f8b0671440d2b869c5118928b3cac7dfeb2ccc15299b0b256f2701f28a8bcef1073c1e78d0a64fa9045c1df6a4e50fa3ddd84c0c9d668320a999b627c2e61b1847b4add7207c90dfe8fff733fb250829b01375b6265ccba629eda024a9d7e4d661af470c4ffc718a943d5892e977ddd1d902eaaa86569327d5a8427c926a7499b903134402ed63bc41b9165c981fb7a73ee24fdc69c955befb0d1263dfe8462a227435e5efb8361ae057748e83f3ba9481f75bb9b37b59c14b345c9d09fdd76b68756d618db578d594b06a3615550dc1b920b7a78bcc7028230bb00658b10dc43e9132810a8d8208e2639d66a0adcac5d1ccbf6cd3a80176ee59df46fe16c449073f4718363ab193bb8ce7138b9ce492942af1c99bc198212d4dc3559964301a18a93602424fa5a04253f7238d7766530d5e426b05125fe4f705049ae27b6f2543c0012e89e5fc286e9445804917a373d718229c55fa44f093a96caf1ccfaa57632570d4c70e265d2f6cc4c7156b1f6e6a673bea297ebef6a52847b45a909661ba84ae2b67b3659c332521e82a880a92f1a8aa1dfd46367647ac28f437442cf8cc85ae6422d5c70320ec7ffe9b714bf550432a09d7f047a780419e5e2cd96ee4d04856a9af75505bf348b78f92d1a74740d16aca34b67c1d5d268e39a77fc7a7d03287030499bd15bbb689bd6458f489d4261aca7065dcdeebb59dba7c45053e368eafa03d9c413e27ea0e66726d3334a4971d1b50e5944679533f274dd06900fd3da52ee3d005f0da7eb76f81722339dda4453245a294ed6842d7df7e75f0940176f21880fa7a85fa617e6bf3c06cc23b00236c1690f01f153f312242ac5f22c003358b89a21a895bf7b5525611efeeec7a0ea8c0898208d6e46a0a0a8579e040250d247a89c3ac1eefdfb7c1644cfbfed5ed02c1dac136a3a505a0f257df2087692216bec2e1dc2e0caf5b56478cb7b53d69327881474260d0d133e996b3b2f8e929b69ff72234f77cff068fe3a8e8c4ee138cec943a90ec77e95de01cf992721757599e5ab886f328483c1a7c70cbe015182bd4474bcb395d41d105056a9ef52388377d93d9ba57b1829ae0ab25e375906c264ff2d856a7ffee5e337b7d165521a0d45efcdfba8a655258aeca56b212a10e0f517e58d5fe00a631da3f62847fe9fc9f07186f313369f4034b7c84d855f95f5e1221181bf68bb7362989c9d80d47401aa99eca692d4b6c0811264ab1c0ff34b52e88f15a2c6e6535708a48158c8bde6e593c0d2e01f8c5a04417f76b1dde65e3aba8f44a70af7af9dc4a390d993b4da41202b12de6967ca15f8d3245946999e18f06a73fec40a7276ff4d8940fa664b048e23140cbd316c0a35131d8e5e521917cab740be2e2f6c5ab9db72ea368e5ad84b869c43f5e0c66fc1a48c38f78f34cb9914c9090b63e02f0b529b3e0db802507643298a436bdc1a65bf5032d717456651e531355293792515a0fe1749851f5d8294379d15cc667447c90ec32552e3cf4d6bce10ff00af64cd6dc386a51f877ee83c7aa6b3a1f1628c8d7150ca955dc3db6ad2c0987ce7b198f3a140d4d8b2e6edf1adf7b5b4cf7edbab12b14b387ef69e9d22a857074396b4850e832c32f2a6a121c1b9e93d62fd2883d912fec6ef136e77723cd68bf423f080b7ec14b4d3554f9693f52fd42062031ec7c7f665ef449d9ccc5ceefaa4816cb9ac41db900c16fedc91db62c67b31a0804f20be29c9b6756f69842d66c72c5656a54735ab557f212ce09112bc1f6c49d23170b90be9c1ed25014a1f936aa82206d5270cfc31cd154a861b42f48c5bb873a926717d107b0a8ae89b2faa7fd6f2477af3ee3e9f41754cf4f5f566ab1f3903a0ff17b3e67d63b22d222b6154d7ccd77defde7276b32f9659bc750551e5a22582046bd452b12527e6ba202babe80a510764c0c3fe2c00170ca68bfd50484b50072e10c5f29f94d0bf9f314050837ad56dabae8b262c210cd0c7d5ce61fc5b4a6e3549ecc74652a24d8bc3dfe3943c302735874a6637fb7aaa83dcb57b974371a37dabd7c7377f997e9618003001dafa92db19bdcca23461af71dc47c0c0ccae266c188d940f59d5ed83cfd337121ac3ab6faa6016df70766bbe8d57c7782ebc1eaff7e60175e4ebaabca9c23e66167e3d4e0a13af7eebf6b51210513730123615900d22062eee9a8f52f330b8c1fbf66c222b1a99b22e41630defe28838018c3de2ba5ba238d20c6f401fa6196df149fdb62a3e8426e4e99fbfdc55bcb7470bd876cf73805749c4dcca82e4a8c8e92693bb5168fcf48420103d2b086fd09ae37d8fd25a9d595eef92370189488daa60efb82ab9419d70e066bf32305fc5acf17ed8140f215c57e5857289f7b98f995fad2953a80aa204904f7bc09ea370072bfd654ec2dd3573e151edf2e678104f54dfdf0813dc0802f4292cb90b4e5e760d67e4a08544ff9f74f8b7d36623314b0e412742b75fa3a0442a282e9c4ee5d034f509dbb802a1d95798a0338ea7975335d79fb0b817a4a76136088e514d89e233b0560d3af444a6b6ae6c30074bf284d579394931327f5d1d846286deee067c0a815a816546b29ebed2f096def468e4a374aad1a3173900cc820dd12b0b97e1c4b161eeed481ac611f8104fc00d7884d9f35c0b6be212f6d7c756d5f42c570bdf3445cf362d5e41e234b6f87f5b324980ace5197b33840fb3f28dad98eaafba4ca423a81568d882dcb3324d01f35c1b8d4bb37760bb06f73db12159b49ef22cc43b7b79721a3abae9c39a9d0ac11ca76cec75f791c26ae3452b6a77fb81edb97686d8942a16ed15f07ed73bb9fc0cab83a9415a2db3836b484b2874813538f01044a4df101a040c9a1d5cad7a014f017b72167d85f9f9ab344fd4006fe05e8d25ceb9f2d170764f783da0178c0bcb336280e635254032faab5f69355fce874d1f3623d51727e8009c153d44b471179667374b86053d3f185753fce66e1d2ea45445dbf4cb01fb4cae6ad53e7ce60ee739668ced1c038577f40b03e54188accfbdb6ac1df51b0a984ffb99545d4499a3a3f38a08cf6cb21fa0e9d0b4ed3417e7b5b6ff7aaad3c3ce9ca70f45fc5ca8b94a9f1082966916746d299c61547fb2435d22c9e82abfc137243f52cf202db4c67815ba181148b1575e837563457193071e12763e68e17cfbe002d06b009678b591ee26fb05c771b3a857e15f42391293955d1e4742075280ce3d3fc4b84414ca2c74fd74799b6a7a26182fad47d9f36de9e25e15aaf0339986ee4d4b7695bc4f24471327080ab0da3a84db5c1d24a419a762d0afe3f15e37270c96ecb27c8485cfc4dd3914ebf61b1e603e0af684158b297971dbbec47a4682f27082c0a62bedf0d7c87e5855b91f6f9449ca80401b16c4820538bf81083519755947daf0437ec49fa232f533a2c88c7cb9d6f05f60ac1ec75cc61592605139748ab2aeb6f3926676df856b9454513d044c1b8343d7df92cadfa166f5af08866c6f1327b583f60d2d7bf8f60ea9b122a8387cf5e013df4eafb5b10d7780cd46e936c7a51e91640caa0613104f99e5fc703925c5cf4f9eba40b957c14bca15f0e6c1ea9d49e0148cff15b98ca3985144a05042902176e4af437b8cfaa695bb5ca812f00e18b20c522ab97e1b87ad2087831ed75d679f786f2bdd1b35fff7cc0426ff9e27c626edcbab58bb266ee7ae6b8831a05b1d40d64ecc44e39db12109c06b496020de1d053299cba352034057d8223ca18dcd06563711372754f646c47fefb308e561a413fd8c7bd018744621791793bb424a8a69b23a62ce6b0f1952b7dba4405bab4e5b35bd2b7615df85c429ad57dd6d352e4bc09b7f085777d88ac77a169bbd229813e1ec3b9797ed15ec2b2b5dcbcfedf00c5bcfc9a7f64af25e303750e6a67dacc04f86e601e83a18f43cd4c65f11bfb1060148c4eefd4c1c933631bff973a8db83b0b7fd2ed6a20b4ab7512b258986d57aabba9e7112549a9a04e6c585208b3809bf478bec8628d84d8e233fe3a5da5e8159a2bc00f0aea2cfb6c1185d3828ebc307dfcd3d020a1ff3b93278dc096e35c91ee3244fb5048b8913694fe2863de274754d896d3d40e6a1f9a4cf049359a2e5fcb6cf0afdab3b6a9a400d393a2bccb809b3efc6ba19c21ee013a53dd98f735072c2c88511f714582638527612d12180838da0e0618b833ccbed18f3a0ca940da88ef93c40c3826b047793766d8da0a031083b62191ae5429184d4832d639731523488cbcf9364f58d1dcb9ddddf8cc3189bd4c2c1111544b182f8f51ff67101de9ed8c260835b17f08104c25ad5f4b9184129784ca7ef93945549b9e30640aa82f2813bc9fe03137e275436111dc016a1af8eee3193af500fe1de5bc5e542a8dfd5e4195b7841a7840df20b01c5f16fef9d4760c9521b39c7df220a499a6d4a7238ae853085ed72173347f5ab2c81193f07996fe71a4dcafae97f6b3a4e8267460de3ff7049fb4dfe8e7fd5019cedf16e73754938819f954ff6e6d2b07d72945f4af2876d23168602a93489dff534780bdef26962cdfe2bfd1b2950e55cd24921a7576e66c12a5031f5fbb62f289a2329ddb129fb08d8f396600641fdb26cebb50f33b1b4ea82616e4f087682deaad759da097cb70cf5640253294a4aa28f2b7c6232b7665ea995ac0e0da85c6f154a2836ee7dea5342e25e428e74fe778a7e8dca7a041faab17ed53bf9cb1274c1ec1a6c6134251a5172ddabd2bcd0fb4555ec2dd4153734ee1b986cc45650f46b06e1536614276b645c257c1090062b6d8c4b083b6d1296cc8dd377ef326ea105199c072bb52d27afca2ef76adbf7f0513a1094802391661ff6887931f74e1848510f66d4e2c580fe81db96cd49eced7e6f960b230fe108ea151ea445a98c00daed0d4a04d3aa6827dd3ec168a1c2cdc0dc1c0023b722055fdf1cd4987ecd6961ce568be48f1f609e8f63db21ebd677564d5817b0e0e6bdf5a5b76e124bfd72fff8a27ed9872c1dc22f6c22ddfc3e1291ab28d4050eae7e1a8fa4e2f45e7b2d778d5c9c82151cbaa3717eed30036f188ee1bae32a27be4fe56025f9b0b29ffbb0d1368ec566d374fabfdfa59213f1490c0726b8e3d3b5e738c93e8d0a0ca63236f43d8dd42e665545890b79856d1a5752c3a51ac5f13f2a2f137d15d722e8f61d250c92a7f18d04b757d9eda0840ad42e2e1e9a83120188594e17e4d2e708eff15467672740559d5f83de558fe386aa5dd42235672a1198243dec1fc5b9fa72adfa7f14dff1a54f6210b29672aa9cb22a5f4e31265062fe2d69b59e0c7dd471be7bd74c8ac920c0c1cd684229d6f946b416271960e136897baca8ba23d55bce2d5352aa52d0f712275bf68bf52e58bbb84534724f008e3d53ff523079f62c3ad6a71586069965eabbdcab0710cfdca2d7b3e71df5f781b08c1842e3693eb966d98fc7d8924b7026b6db9a3c5c169471108660ecfe81a3e8b0ad0d646f7d46900aae93215256201b7e7c6e7d9940bd07633497d3156191d69a34e6488be87db9698705e974a960033659690b87960e905f3d010a399684e69f8d1a037f1cc705b29f986de194baad5bc004860e490c5ced3621e270369ff67cd045c7e5ac6dcc0ad4c3cd3bd55cc0fdfb12a465fab6d9abc82d9594c1b208609eba78bb3e817413b05902a6d457d7d7e32635d86a972fa3982256c9d171f32c69608a111d7bd9d18cca059557f7979d230488dd92b3a9ff2aaf3fa33fa7ce77795f0900faac4d74c77a0ed0bf79a20896041c454e5dd2999a2e7c5d57b791a72fb04320b81b28281946c7a4a1eb6d7f5a0ff5c84d883bfa90b421aed0442cb6e4e7242c86fa2deae42fb4c7eddfa1f9eb8eb0f981ecdd05517167da3d6822ae727305f92f27d771b6798f9cb6bb7a0f3e781e3d579471b30b4a6eeb5560accb41934ed89748d59f819f7a70ac2ba518af982431a024ad1b46d8e37bc63163c466207fb6f98fb8928f84299cc1c47888943035f92db7f0728219852901ac8f13661375dd2af44b05fe49048d3dfb15b5087458b0fa0948069fe2a962f2bf2bab88a5925ad11757f7cca2795bf2efd35d5e2a1c84a063d521b6b8b986346bb4d0590c8c7478cbd7592cf389eabc4e36522eb844bb81c1a9b3291e2fc9f5c66248e6eaf08a13076e50c1ee61537c50c25193ea821074679783b3576c1ec12a9d5cc6b07f3c354a903fbfd6470ca2a73bcee391206e45581e87b4d96952899f9ff1c3c3c48726e262a884925c97f310a5bb44b599354431fc4d9aa07863dcb4c08c0a0f8be66330ba0f4855fd50bc84569fb154ddd31afce5703cde8cf991e2c56042a91c91c5e390eacda903be4afefeabfa5075607abdd64a65f7b894c73f3e1533110dcac456b47edd2cce7aa4da0a8eccc855cbdf68e43affd0a7eea0ff67fc32b99fc03b9aafe497d9ca097b9d19b455f0857057761140c3c29dfb65335eb26d0ed1f87ab2be029bb79ff147aa7eb5178c23b08a4d19d8e3596c78b3e5046203b787a73dacda6316b87b1b17de25eaa2b2afde4baf7ad4847a8bec3134794b53644e65325b9198ec161cc94b43caa25afe140ff8d43d5054a3f6ac1c782156e761fa6e7dcee2be27e3ad009a7ee7d4ef69c3d4ed0022ea22d3a94705344d86d7e025cc7274019e7d97ed603179cea366bd488d0c22115753e8a6e4255c7bb7c40a626b2b0cc26a42c6d3c5dc2f24ce936bc55431e69440dc28ca7941eae5b7fbccb1876c89c9f908386665a7d43cb6c0f5c0bacaf70036c2687213cd604315d533e2e8b377c9d75b674715f270ab87a2096289beae1f98155e6eb31aa9ad6ac163ed02213b93a41577349460beac6eead1f0d60fa8f3be21d94177d08d1b372163d39dfd5eeceb889b114b7d30562e27af404f7d2d7062d5324af8772e5f061bbac4372a2e22357c545dee7ef2ab3bbb41a56fa4dc3874477344ba9b1dda60e20ce849a50af1835bf79927b31109b6bcc4c5ee217b7a2f3fc5987e7e31f79bdaa929385282b792a82f42c2f5d574e9b8484252ad0db9342363bb3c1ea4d9fa228b9b3ba67b3a1be817bbec02c858b27423d4e2e2ffe19481067bf36a93fc230ee02a95c348d1aa7389707ec6b59e710dc091fdd4af3656c9e242d6748bb1ce4a78e455d85080e7001f34a2237ac05660d6fd67d4e851bf274639103d4e21ff12375e314ce9182d7ea5876b40263d8a7647c363adc7490a01020b7d590e1caee14ca150238e4cc5f06980a89e8fa70814ff15667a26b24ed65f4cf344e17678f21344cabe6f0308de892b44ca98ce48c962a780b23f385298d20d2dad694a29c2b648ee2fa0b392b208c00f51a55a1d0142fc630e43002dbd2dfb9a8ce974900e2f579ce89851aecc8cd62247090746cbff40c484e297c5eb4dae310f1ee043c7970b3d79ecc032803c73d7398bc02f95b236c57cb8c591b03db449b58629f7a286f1e264b9f8cf30f338e44178560ba1f8cae9d9ea6f1a7480b3b649c15a8e28467e09a7922918c23842aa71c94c9305819dbbde3d54a1e2afa7a41565f01ac8eef13432a126ecbac084e792fcffcc8d9fc0b9c4bafe9f1d0d49eff4aa4c86f22100b22cdd36e8e862fa634958ab95ce7a4545cfbaf047693440e2891ac4194fb3a81bef38d90090d709d4ee87a40b024763a67433cf2b3e95cb368920a95fd47d5259b0b45e102a6d67ea6492aa2aab0c8b0cb5cda7921bf50905ea0132833e2a0af92758975bb754f754b84d462117f8c7e987bd7da82872c51ca8a45e50129b305c541a974a4fa14f3552109ce9cd57ce9a8f7d4f18c6d41678deb1b2408b4244442ebb98c0e602f95afcb52c2bfd5aea3005c713d12944e6ca47aee08d7492f8b16348677084819545ce07a5f1c98a8a1ca279c2d1adfd58d1648ddf0dfbe35fda68ddb77ccd4e5cd1c7e28a27eb12c946132e60892cead46b69d64baf80beac817845a793167a738beb51d10bb8552fb51649cba1bd7e2326b9c5b3e5128db87240b965835dc79fb23c6a67d43a398e1a0e916c1bf1ebe71cc014883b3237d5aabfcb46992c4eca9dbbf236fcfb1bd5d9c2cc46f5364393564f343a7f30abfa2da33f9dfb74dd2f09c6fbc387454b975aef84019dd41211f9f1a563dc2348aa1baf8fb9e6635c73c2c01808dbc8023829c321cd76e8d753e3cf1ea9abc02c19f0b0d81ef80d85c7ea615be2ec6eac062066192a685456e01a4ef30e5c9bf1a40ae71e0180adb2c4ae09a3eb3f4a60d1de687c3c6be803c52f6d3f598c194dccbf9e17ebeeaaecdc3fff8f7592051a5754a97ee7ca09e986c10e6d801be00b4f90177c54bbbbfaabc2b38ea57e7195a8fe70195dd8ccd1e2c24a1eedc3cc51f59f3d552ecf7193f1ce578b1d582e886cbe8c57ab751b3ccd5f58bc0f3902edf052159488f96a717208b4ba08aa68d48fb2bbcf62341fe3b14afbccc541528fc62db6ae1fd93019c5cd1a00a40c895fbd6678330debee4979754c68be712de7dc69f04fdd767e5889aa863fd9a4f7deed3239f52aee77f5d2e3e82078b0d844eddbb7a2dcfaca19ab9211847541eca0a95fa0552f29c9cd565b9ba10c0d0423ab25b63edbe7039d36f7e2375c810ad858e7fbd9e9be7e4ac02d142c516ff797aab8811fe83da6740d4956a685c9b1f474810be95d7689c321574f8328cac76e3370f8bf30daddd30241aab703f6929a79ed09ceb54ffe4982435b60cbdc63d4d5a350010804131d3151531fc90dba44ca2e606e1ff0eb1c0a789111678d5a8e1aa3e06791a64bd49c8c780ac8cc49257f092796495fc51e8393700b38d649e632f6f29f3d0ffbf7c92781bdbf84386d80b9ec581e934122d648dc53a326f943b12c799aa69055b65e8d40129a620a55748e4df87058266d1cab6019b04533d5b1c93f376bd6d5ee17ce1ffd9c6623814032da9a066188e1840e7ece66853af90b85b5f1295dc25e1296020d8e2aa49b0633f49324c983742e7cc6902fb271b1c4a1560724a6960e3695e67ab3526c843084ec1e0dddb96bfc49df0d54c01c2a5278ad655033f62fc97034400b779eb6c493ee6ffcd5e6310398d87ce75e6ab2fb505a5e522e1f181683bac31d5770cf82a8996927d2246d61d4e4d0998a5111a4668ecf2fff246639510b2a2163b4b90e9a4493e3a999bfdc0d8172e2086f5837a143046b8b866831fcf7f8f6624c43096636b9614ceecae0933a29e38d411cb89165d2202e7a5968cf6ba2decfd3f5b39c9db4bbd57fc5d1048bce386c410d07f60ac0258936b0769afa8680af34840e8166d7b77b540dbf94372595e0505affc02dd97b114a6f2077b7c59c13a22a57c38dbb5dc919f34d1b51d4b3e52d181eeb3e7a00e4d7050bc2721115894fb7766fca4240c55490e36dbf9e1e20a30cf83d351b2cf21548faf76f5a14f24c18668fb0a9302b3cdcaed68a3a5bb04ec63d9abf2ed92318a6ba047c2df624facb22b743acb626c3f72b260cce30e8a7b1e9b26ded70255445e992d99f5a112f4df0e8e3e44e7ea8bac2e138960b17db85bb9bf8f62a223ff928c62824d8eea9881a709a25b479210fce2eda4f5d4f27f9eb7f862997ceb030d81a26c5d39357201cee2fc5ae187eaac739d1276db39ab3e24a5a2cb1a5c5b9b991c548197b814487a4e17b0fc851a5f13366a9569652cbad2deb9093d63166717feaaf130ffa531eeb5f2e0d1664befea221ad9a53a362fb5ccc8e395596da9900013187bd7c0a414eb462e2f06bed064099674ef3d834511929a77f3b3636458de501e38412e7c062614f0451d1c32649c1c1df4e4393cd1fe7fb73e56668c7b8032cd863cabe478373c1726b210d7c3b36602eec06a7eb17ca93b5c128b65249541d64abe967bf476258437dd19b282999af1403ef20cb46434d3fecbcfa82f3cc3d23275882193027e81bab45c118ec337e0762153434997bd26757d87083a3f68ef57cc021a343a84c3a1c52c8282c0e81fbf6a342e6949044ef0ddf5050b0457faa82c34fdd0eb66342a1574b7cf430aa65626bb71e8b04e287ab751fc2cfee4eca0ee561fe35b4820715def5a459936a7973b4c74991c2c9fb735fd2a82cca1383d14bbf4761b30508f4430ba968792d9fa53a4f9b9789b8555865ea10a1a2e6286f667c75c73bd10936ddfda1d57a585e7f0a9a700738f1f56a9a631e0d97f5076333ca4e26586b4df27dec2bf76f1a38c52909c01e17a3e7b0bda5d0355897d922b2dcf6a1f2f71e1014efc79a3bf8cfce8d09dc213a518984cc0ab9e307e866f1c3a09f2846bd3915193ffbf8dc7b30f378c5c2f592c5a0b2f7d41bb85520faa19f8362a11e6a5b2aea44d2a6c43c9f4076d2dd62c2a2dd78ca65befcb4d3b3353c03fab2d62101bd1da5a1e64ad70354b3e722161f6f026b149ab86eaf9e24d29e371e70a79bfdd4e7ad68f120fa2476d9ea29d928708ca1582014b9f00b020b50e910e1f345d135facc25d5e73316878c92fd19e839b85272223e240935857545e6aaf5c2b8e77a4610def5e88974a5eb6aa3e4c14b55af886542119302d36613cf767ce6c88ebffee815579f895d69793d1b47c00ec741f6e6a8e9a728b36fda4a3c66faa06a28ff47e081cb90b775d91e7aaa90d11649b7b08d9e0b5afb4c9b09992b7d6484a4e1bb80acad9bc30b618e4d61a090e82387217bf11afac4a656fedb73f1befae28c810e90df1c0f12eb33c7f5f44901c69a9f029dcdc297d81b85eac068828c4256df02503fd3e8c66f1706bf413c5d24d88fdce29c1fcd4878a9aa64be4b386f1e5fdd2089aac0003b0c676efb289e113d174ffe3b0bc62a34570c894233ff8436ec5541506796e69e39ea9ea6651baa4cd6dbfbd3cb7bfd9002aa0d936ea2bda9d408d598e7e69853f9b5cd4c46032f7049f90f2a8f7ad00f91d57f49624723dc5a149939589a5027fbb6836b7e5b7898f67422075a5bb30e214f9d764ea04b5caf83c973cfde775d41e9d2af7aed05bbca6ecc94addfd1388e08101b3b5bd671fab9404145757059674da54ded27c2af54a1aeef7d25e5f6bac14f5e5ac0e0d92a85bdfda39210fa800422af230af1086df30444bd4b3b0a7171a051f2344674a7c7bae3c448d6b98d6b865f2d82e50c60035f4a7d261d1f968c30e1d19e1bacda321cb39c7faa6737befed1ba5bc0e011e37f22d7dcdfbb1c00d5501d7fc64c7ccc38a5391b9bd93bf41f485c142d262c5b5248ca666948310f72cf154e6d9352c585fc3f9e5c51a08666ea1ae1f0a2edf2a78cc23ea072b8fddb628efc3150411901e077a9534844c94e8aa9b4ac3f99753c2cd6d482925ddad16599c0e1d33ed3186e5ea0680419667f8ff803ab9fabca4e0947247d21203dcc98dbc0271efa2e3f087d86470e7bfe4d08c20f0a5dc7c95a091f2e0125519168d8b87661dadf3b727055fc2f57a8b618279c010bf7b75561d359fa30f3bc278d7310e5b194da836e442339e386565280ff39aa0ca14039b20f998ee1d0cffc6089a0d688dc3011f81ae0d848004b4d624621d25af9018b3174732bc71167381df5985e7201145ead4918fccb294c213e37d3767156811ac2972d2d8e264c6f3fd273cb35887f66a82cac167dc158d286e703b153fe55f9c2875656ac378577cb8f0acb01ed539c82354be3dc40006bc1b57b7e59764fc49b5ed62122a68911ab6d1c9299f59510dc707118f637a7eab216cb18ceec6f89b843805d90c8f95c4f2d87e5ce8a3bc9c4f9560213e649a03abad32129d908d6b7e0546c2bb422da631484892b8610b0b2f8e3b85265193644f8507bbc0646294116300e4608187de65e27d2c6bfa71f9dcfb3693eb8fe5b34fb716338aa70c3db3ce3188ac2a4e50268aa0bf41df303c2c741d7aef9f92d336163f13e420735ba553db33ff5f52a98bd15cb17a7521b58c04bb0032552edc1dc2af54aacca7c21cb474bb7b4e711b5c94f82fc272da6d6114aae12a8618ae5a6a62bed8b4aecc53d631b458b494454663c1b8d5e9add94a289e18a5b636e65bc80943b7dbf64beaee8e165fcd3cf85a43d2e6b9a16b2bd2a2ec2d24346297640f285277cfbcdcaa71ed58dfacb9f9b77efffeb9ddee0cb0fcda66800ef8c0e5370ce80f446fac23b19cf654d21f86f60b846446df96eb18e603c331f7e205f3528311a6979d54299b040bbf498d789bbee8a7d6750481acc6df97700e32cd14a53772b1f26f0f3a01669b205fbc92d539fbd72524fb82818a5aa0a1917d68361580d657c5884212d6084809cbcb7bb1accf2cfe7638d45866194af86c1580dc16fbf52cb36d06b35009406c8ed14e3d3c024f10743de80f381e8c871c8d94ba5d8b0b22b25339594779d7b2649a92232cc0f5c1706ab7ac065735694217def83eef7c9f65332e7c7643f30b77c78db2f417593876fcb3fe558066cb85cade322b4840f868badaa3d388290d881c4347989767e906811cf41a051d8cdbc85354eb2c3ec18318f5ecabfa6650f55e53d6241e565b89044e8ece8f2830675a36687319cc94e677804d0743f541d2830778ae1c4c155c1c4842afa40505ca1c816d87c787259320844021d78ad18118e52e4841cbfce8fc19c5492c0644a1ee3fc2f084a10fa45105307d422e309b45d34c31447ed7c09531b8c764464cf8a0cbd16998062a447e227bd2570cd870910a8ce5a67a2fd303fa27027505fe32cb4a651e8e5a50e9829c0d9af8405a166298af03055615c253f213289f08f89dca3689da4729c80ab5318a73686db2a4cfcae52358538ae77033689a2e952f1425ff7c3fc395969f95e093b3acdf18d6364d065f2170887dd08a01f9f5e54ddb00924af42f3aa2cf8596c1d19df04c0473ea89332799f839745c735d4cad1cf523135d33f5a2da9ff2c12ec83970c593961f45631e1f63a490e13bd73f23522d037b515d3470294625d8922facc19ca9713d94ce5e3fa615f2aeb470374e7b10e07858af8f6b770be4930dd06af3b3a63a4165618f888f152e9f7aa9a080df8ec30f26567aafd2c8c9289050ca4778231ba6175cdc5232169a83598830453786e65aac200a63fef36dfee2256be739c6db28bdf10e5859f9fe4d43e246753cf327d561addd421c23f8ccccf47cf387c1ddd9f5b01f3dd02e00917535c9b929262ec9c1b8c02ae725d271b5de19803e312a6a05188b1d5ac095e390a619a27bf68767982cea0264cec1cc3aa3975f1175c7c591dd6a1c0f907ae3eb99ba200866ea1e3ef7cf45b352e52af1c4eef03c451f7fb05b820484cb9f2b8ad2513fc44e3e69a6dd8899b6f3d43a555a874a81555f614524d5842b7abbc3033ce1002014c6e347e3e11ef368522d8aa122fa710a7ecd092fcfa737b9538d5f2e08dbaf2f9b36db657a39570ef812e3011e92fddb4c52002b4a1ccfdd54e4dd4ac47d2caf9e4d37e60556a5a8ca1e6fd3163c74112da4617c6db31f68c74e9319667dbb4af31c8f82308449c058d6c7f28c14c4434e02662e191d3c731a38fdc713245ec0096760927d830c189ca8e3d4b6e53471117a9600e8bcf894b153acf5ad8d42775e56599af8e5fd6ddee2e6cbd10059d8fbc69ce5851beacc31e81b5a21e2608a665dd1957f23c560da80a511137daacaf2a79a876cc67856abc33fb79e1840752fbb8ef550846dad67925a9046331ee54301b2fc60f9f331c37db813a3545b92511dee7ef91ca2d0a4b6e5357ccc4e7e6e3617ef9609bc70fefe042e4f7844bab58ed4a93f9f3c38da113538bf9db087b50c90a7def7c26d2780058c0108db6459e1a54e2b8d31f72b097499f53fcc7076b13312ed78f7ea3efcd2dc99c6c86d2ddd8a516af57a65035d205eed90a01e9941ad2850d97fecdf102d806b90e999dd91d83e021f0cc195435f25636e02aa0283efea674f75005615d25cc7ec1e52b52a47d1aaa17dfb735668453a027267e9fc7f2b0d0d65b7dd1e606666bf68f4629b90e5c9c08612fb8840425d87fc3172cf23b909ccda90b127d3d93a358cd6786440dd5027907e8bddb920d9da3e51a36cc91fca41d3b62ca5d7110f86c21714377a9ba698f68d189af5a26e32507bdff59d22a5afec4e2b522cbf5c883de19ed8dcec3e5c8c97cd813c45f182b1b95be9ff1ce865febdcfd93e9a9f66f9cb8146c213e6d8f73829cc3b0bee663c89f2d320ce741ba03012b8ebb0a59eab6a58db045daec576ac506f0c7d069d4114a5243543d23408b384c04a09f2654c448236262d8feab5833869a65d6d89acb12f59a9b0932fa1e0c570f3253779b2a53fe871818b3dace28177853d812fc6df8664df1e9fd660c21bc6279864c017b0cd8417f1954243d04694ac6c83d37cc8f789dc3966b212c7bced4464c757416e8a1a01c1d76c91f1bcaab2a7f1a2bbe7a6a233996c4f4e2b9b869b8e7873656fd01d606863a123ede2f79759de5eab32a01c9894d7e0da2082f2a05b3846a064b435472959dfb23431851b633356d464e97d932a7dea8430c8e77fe50dda59a5f747c8b565106603c363249ea5a299c5bbd0fcbafcbb242135449f500faf941c379c9a7a70e4827aac0c457f4693a014491c19d6c18ca4172f0f88c958503b162a5bcb8647861c60935a997d902739c564f01977e2e48164920510d5fdbe9f1c04eb3af7c68ec02a5bc7b0f977587f392ec1b61f9065ecefac29dc39497aab0a9ca30be3a5decbb5cc08dba256dad242c8ee39405f98c91718dec39f079f95c8053efead0b55b899e92416085be1f2e2d5cd02273837e54e123655a178460dae9ccc32e8d7c99f3e5e85430a043b0bd802ff03d079312bed1ad465451042f54a8587715a984982d942166b138ea4a0c768813775bc119073893404a012f2157ce4365f6d4427c94e377104f668c2bb359c240f2002b5c28a6eaf7b9c81a0b7243d3ad4af24f6de8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
