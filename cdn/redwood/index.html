<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b2c3fb5212b38a99336bea53bd9db0a1ce8f7c05d1fa2239fdbcdff8963582e0f9bc69cab0a1389e522b7ce3be80c8c835c6e99345e0750db18ad154a37c118c50a2dabb8141c1f69b8dcc3475932a5e804e3f43c0b9d8aeec1bae934fff760b8b791c1fef40fe77b95f5979a7ef657f99bbfbace90534f6268a7c9d9d9c4fb301327577f29ce31ed98e1fc9a87f4afb1a67734cd98aa10720d87143778b3ae44de6ccb293c5ecf25fd8baad32f12d876bda6ac842eefa086627daa0cb7647671eb1d37e8d63edfb04bf0e1c9ab005a9397199a794a2dc2df6382ad9395bc32e473bb62a8a0a98059dfbdcc42e26251a17b75142b209821fb572a239df3e19d340baafca0be98510580e580e37fda2e5fec9defed4cbd62ff4759ae44553ebc3f1d06a262d274bc93acb5f23c9823600ff0ef534a6b5fa69fb945af6ee6e145385fab83227c41d35818f7c35779dcb55947823b382db4bc2dc4b8f00c7fb4385aa99d7d913b54327c28d9125e642c1a79d6cf083bd6e9ab3635cba4fefee409590595b346142f5eafbb0ad282f0d681eeccbbacee61a7b6fa1d8cd9c3ebe99b4f62e7833d13981ae481c7ccec1884e62efe02ea7db42af4e67e1ba76ad8b90a695e6b3885a90a558b25d27aebe425f3b557a635e046634df0c88c6f953064810d0f5c856d92174fab278ee01f48ba4bd1e4d3f03b4d509b1466e380dcac4a65d47f96a8e74cff86c225e0c60c2ba3b45af392ee30ac2c1e13d70b848983726b60fc6185dd8fb47bfe97ee392cbe8de68d49495deff7e385e985fc14e238ed423885d12fda898516a7ca56d6ef59790e9ddd8bbf8eebfe1f5d046205de885494390309c67cb189c34dd51d9adb88834041c14bde8eae2db6caf874f3137df33baec38cbacec1f2b32ed9dd3ee3347dd55747e06ff3ac30e4458b6f3150a0d4e9df5c3ee529f9f4d7a60211fabb5cb944278f949fa7861387666b4abafea4cc6375441b436a90bc526eb663744f96ddf0105651257338974ee3d73b68dea4822dc0f8063331c0f2785cdeb07361a0d2b38bce4b09de1e0fc93d9c1afdc07fc62feef5b3b5bf8d0d4d504c0a41ae17ac45a1162a9861e78a60726878b1144a1d23417bb7a7eec28464fb3bee1e667fbfc363adb242674795070634a0398ba63e063ba3ddea376d26d9d3c7617ccd0a6de0d71749d00da9ae606cd4f49240857bd0a851af6cb9dac7afed4b0aa5e77d983fad07ed468398565c01877ad3372a96063afb67d32653482faca8d9468bbda050c269b56665b392f034bca81f9818582c2d81123c75f659365f9bc2471ec18315e22f3ba1423bb7ad4e00c2fdbb0fcb4f7221ec7f2f33fd4f40175df45dfc1b4e285f7aa4bde9efdfef32ae30250df6829f9995bf5dcd8d36ba85e96387aa8a5439f7451865eb178d50de53b7637bfe0eb9610cd02955761c6600472ce718ae7809a825d0d70cca7f0a4fa8494318e742d530a81349aac847bbfb34aed8c33c53822bd5d4644e57357323b90e788d4db4e3335dcb9941761153737820088077f7bf4a24741ebfa82a883f2724d5f91daaaf3bb40ac5c1c5e0fd4a8082a4806f4697f19d56dc952b9ef0fb15f32315103c48c7221935f6b8bd8fc0de19afffb76318a2037e175b5f3c384c9c8c35b4ecd108d165f3965a6cc3d2f360d39eae0e010f8252550d12782d227943ba512e80acd2d790dc21a417094dbf42c106333d5e1e9c608ecdb4be73c535a80bec0ce20b5aa63353a9bb463380eaaf1265478025f6c3bbebe29f6c88cb5cdccda22a200482266ed0c84900a1d487ab3a532014e5a35f3eb73ffa7757eb9a2832134bdd7a1b951733554d03f9603e2b5685aee6f164d1e8234db6ddaacdcb75ae159611d278fc4389fbd2644adef6b3f80971f47866f453fbd3b04d61f55d02a99afdd43377c7ef5178dd82b196bfe01300d1cbd2d4a84e04c92b09e1bd0776e4f52442f34ebba0d5764cb5ab103ee73837dba32ba08261bdd5901439c0e150148b6fa433d51981d7b0088d4bc37006a8431493f79b686dcc85b772af94975e6e0b718779b3e41fa4a2d35cded313b0189d76f8c1ebbeac5022da5a6bf49f313da63211a0e51bc7d5d325be166c0a9eddd34dfa9501574b8569c84cb00df661952ac84d72644875f4805aba53fdc1e041cbd571ddd970718aea0bb51782a3d68d5a42798a776107500014e0df7a43306cd35a65ecf15ba58f2a945dee66ce7c06fe8ed3dfd75615b0ef0464f3cb407af24817319d70592fa2071cdce6d0277dadfefa04e9f1e3706870637f5a9b90d8dbccb67eb1ee8fddc18b18a8793838a0410c8f0059cf0bed4c09764ce2aaf18cba2a96400e419cb987cf737abb02ec15b8aa4ead058d8ec7f2894026951b115d1f8850fa195cf1b482a1cb533e2ef3d7f6d69430b3f3a5cfde060de0eec65d1ceb13fa41a04c03d0e4c56d56b314d4135e28debf504d6b9339556bf1d1b03178373f44b5d4dd68f2cd628d45efb79802fd12fc786352cbaed407ce2141c9ebd77f0ec83247a5d0e73934cadd87cbdb5a1c7dccef58a546eadc86ec5ecde8b1ce8b06dbabb86e3dfd7584da0c5201714f88490b920ccde6ade061c689483d94155ce59693cfb5e542b16bb6571a9848c7c9fcaa58b220455bd2cc839d3e4acd0f305b27b2efc21c2df8b9f2452063267e5377bd6dbbb1a9d96f35de28cd63151c0930a6cbaf34898eb16edb9f9a45caeb1712ce43fc40bcd27b2236074f8cee4d37ef7eec7e6e8a82fae255c79e97b66a5fe45a54ad348bc908e0d3dc07e93a69d87836568774f8372f2fb7bc1194c67ab694b9097ead47a2590a7bdb5997d1e66ccbd99a09640fa11c69d4e6aa3302af4d71fbf30cbf445b2eb3ab08ed97866ff098e48a08bd19f3766c03cb749a86320b0013467e021fd02da05e0125efac45072512639fd7cbb644a7ceb96dd7e570ef559bd8c96eba9881aa07e16b06f4c084cf176a0d34dd0333eb3ac4776b5378e3b08536248f29f31bf97177b351e4d38db77c88bf4c1d852fde7a55f15abacbdf63625d0bed2a3e86f752f390326baa654a7578aa6ccaed8fc4ec5b7a6a0fb5d7bb12af316fc157ffb0e3efb2b14f2b078a2e80630f9c5cec41da07954cef6cb65124270cfcbd13dee59cc2780758911be3bd5224a8e204b4bd59b4b2f8e2335bd5362de2b9d3e0e425a78d46b4f6dfc95ef2b7d2759dc789801c2fbb3aed1fbbbca1f578fde7c71b320006b8f3f58c5372b0a4be5b24598af765845ea81538def1c01eb35bdb71b7e5d697b7483edd2626c5a2bf4f565720f682dbcbdb9981aa474a4956f7774c0d8a3a48b077b0bb7b2f85bf7f30f1b62512032871d26bfc1e9625410602f1f9e6f56e8d312cff8830a30f49d040bd0b0686e75b6e33802a3746c776de362e15773b33d856cdd308f92a2f0743bf010a7be09f0551f0cd8f1298efe9624ab1f2dede827d8d60c2dbdd05b5c18a1dc09798035e356d93a90129cce7716bdc4997a0c532567e0d0b9f828ab530d84d779c226f0abedb671563d29408b23d71bb27e9a1a5567b5b3dbcda41c01e4a163dfdbebf9b1d2aad1a7b22a2f65180cf6b43a9218a8c046d7da3273019a5343dbfb1582ac9615c3d07a21ca4ebe0d7d87312fbd4b7082e252fdf28e6886ae13ca9a6ef2abba0965db38756ce26ea536a423370b96cf818afd72286236fae94cab7786d6c48ab1603b41e08af1422872c261373e8e1f1d04fd883424c5f4a98dfece6efd4b3236fb428d2faaaed6a8503b5cdb253920f9f251a272349cb86d5600aeceec0a9915d5bf92def237846518805ec8b6a28ad2306633d7a2df40f39a4b7b7886bc73aae378488f473bb8de06c65dbcc6f2d54889b8290022527f07358567057918ff57208f2933c1a2c1ff08ca2d95c6aa91704e8142deeeaf2356b377175a38582d0824102dd656524bfeef3be97aa227701a8cb9c416ba1805dbc43d9a9a66f70fabcc284956877c162c24680918ba7ac3da0dc3ae6bc976e5e80e3c06eef613aff9bfa16996426c3940e92c3869735739b860528b9c5386f192dc991cdcfa70520aac8e5f273d293e27858c1b54fd9c4ba210e448b312b20d768fefe2be3323408cf57a768810f3464cc4fcc6a3471240cef7d8621803043ed4c742df21b97fcd56369f76ad4ba7affe9eabebbc64122f110f937bd8cbf2133c7b674b655b200dd25b8ee481315097a976b871ef90014d16b92e0d368a905cedf5047a3a61ec5739648ded09bb115ca2a12401db404b6863eafb8da7df84735eaaaf6bae9894168f470b6392b539890b8f28f906573936c9f89ed6c93f897fb9d236a5692663bc98093dfef1bc486977e71671975d6a3e8c725d792277fa9b4bd3a116d93fe8918b42f0362d13c12dbb2cee6eb43a2a9b1c1ae1f34a036729a2c40a0ca1b2e4fa985329ec15541b2d24dc189a85c7a359d4ad2bc638afc0537aa5873ad3466cd2d9c0fad60c16bd3aced93293dababda0f1e71df9ecb0d9a0d5a85310aa5fb683e5d2f1dcfb81d29774f9121657131e8b6622c67747096e277dd954913cf19611143b45d6e151d440e96adea3a8e1d2d8f292dc5f3044782a6af51d6f52ecea4390351b0240073e0ba754c1d903eb3b4ebc5f214242273b7dd363bddb71478786bd85ac95c8e9f9b073cff81eaefef8c4e59d4bf33e72ef8421e984005cfb73efd21f98fe697c4f6d25d0f2dfeade7c49a9273689669f356b14011ced1614af91736a082fb9b6addaf7f30ddfbefc2c4bc6616b4f7cccc0fca74b0e695b5cd414c81151bfa2997128135ee634463c38f836f43b8f3b220fbdc07ee13ab5d33972958536550dcc0551b364a0e02a61593482b2a6823642df53248bba1cf4eadbc55ab515570fd3f4c0341cd7ce68e5b2a9e684baecc9dddc3ff8cce376c4053ddd8a1157eb8bab65a11400b3d7c38dfda16d915ba3e2148e26ab3ab40c5e62a12427be1e9bdc5b3b2c74287cb7f1f0e683d242ddb442cac6f131f0ce5320a829df0f4b16662b992837f4c18ddad6759ea4f8d3d570035fc9f4e6b62286f41953d30a97eb74a4508d9dace1f026bdf0ec7e126edc0f3345226a2407e00cdbce0e161bc0bb2db6d160a32da7b1748ea6fb74a9ae2884fdedee899c7007497916cd2cedd0091bf229665b879cdba7daf6538b0e96b2f5d324dfdd6ac3ed02636a3d41986ef27991113de8de73b7f6c43cb83a93ca52d17238103671ce0b5599b02fa3eb33b08936f0dbc7d2f27f332d4f38c837276427b9a70dbcc343ff07e4f30612ced53b571f0a4fffce2694c417922a5f2c85cfb1ea9a0b7ffed11a48d6e14478b7e81603ce3e7b3d1fe5ac0bc7a976bfd8d7a87acea800314404f3a72237b46d3ee3054f23ab9531cc26b956f3845103bdd46d6ac1c21bdfd6191e15b940b61e36a9785be6e2237b72695e1a6aa135a4e2cf0365889714e583f3ba76c69d57c96d62954d21bb416a97c5f55d57a479bd018563e63da1605ebe9de377b89fc2c949e2eebe0d743022e9302c2a97b5343369e1beb50f187461e69be6ebf35891b627dd319a555961892c5696a220cbe808bddab556ce826e4f6d7e694880568766238256590d29ee3228b317fd4ff7833106ea5be42a523b21990e3200f586a5c0236e80d9ae1284eec8d657720600de514f18d15c3d8701e97312beca99aacf7eee9512d4bb2622a2c58a095f2d1804b826c6a15908dc9fd1327922f50bf9826c44cc46bd2c6a7854787d0834ba787a2a1673d5f0320e39d03423620c90bf17488b15a927db1e7d2f6bc8a18e38adb023462e3780cf075316288446f1d6cefdb113765595f9d0ee92d731131ee8f7437bcca4d27ee0507c6f3a43a3f0afeaed40859fc646199cda40879eaa2328d9e1931b947cad70567ab24419405b924e20dc87fda80b72ddd8bd3a88ec9015af6d5dcb253d825593e59874a7618f3c9da7119fb010e708dd14ed214d7218e58c204f278144f285e1617cf0cb576223cff011f2f1c26ce6b3430a40a59859ebba4b5caaf832fc60ef951cc0517291d256e97541b94bcc8603d67e6b0eb32b789c0549163a9226a2cdc227f05dda619bd23776625ec3a69ac5902c2585eb07dd0e9c7e3cfb1c43ca9816e7e0b804d1c55260a3ab7200f6a90a58f8a75ac59bfca44cf231a2f20e1430bc9d6803898fee754fd9c9e1790b6881eec062e237f4f8064e7ff5df0783ce796f27027a8ae939b35e0433efd8dc9b225730860be47598e57f362f019fe2e649dfd744d4850d803516f7a05ad3cdc05f19b8fdd4d12d0ea18cd5bca0ef5fc18ca49c80355389f8e28b8af355c53da4e0af98f28ab56d0b7cdec383c1bce2ffa6c408fd8e3148e4d13a6c173c8ce3962379eee298ba020acbfecb5cf55b108362f75d12244a2416c90dfa60dd0b6835798c63189119c4382b267ff417c7ad1bd6e3e3dbddaa22211a82cd3c8b9f4315a0bb1b66be12a80b8efcf88ea1c27501438f130ee822b9422f5ff7d5ba7c4d2591fc5ab33f65a3d85ac0c2953f04b2d040c5ffcc8b90bf23f1dde154376c05c1ad0a80207655fb4db3da3825a964c5523ac5044cf2627455c576553ab66515787bf0e60074f639bbec4eedc3bfc13da06d42bdbd3eb4500f6ad94f2188e86a7245b09fef69f060017424a5224ea2f60c218045819207b1a03794f80657bb39766c5af8e2381e50e42e4748ff4d7231863a198ac85d36c27bd5544dcc934bbb73e75bb359819a5002d63babcc296fba35a3c96c6d88071b860666573c57d46c0a419fa3e60b9fc4b418d7e303c37906d77b706d55d0ba9d0e899b6e8a6dce25823dd5e214af7a60069fb4f467e8bb43821445ea08e42a46a4f8a270f056c7b1e3aed9773ee7f0648f008d9c754c0d81bf631a6d4c7eed83f3de45bcbb3ee7853d440715e3d14132fff877a2c43cfbc3a53f54a3a06949194f9d6ed65269c0f9aa46a2247a9ca0f53b6004af3b5f3e9ccaf254b5848fbcc685987a35b16caa97c0fdbefb02e5697056359a4b7b79f88562b05e087beb51469c361620e0769a3a4b3a53b578ab311405ad7a9ba5ba079707db1d167d33fa271dc72d9235541c35866c265bcf183ae77d8339f98425d1b12bc5d1531a5fa4fc003d2ee1ae382c2e23b02a397bdd51395d21a323ebc7c1610e4927044d1893c5064f666fc38642e749ff6c3586fe9b4bddc9f670eae7dd8739dc3dbdd1e417bc6cd0d35ad0336fc65cec451dc395a29308e55d5aba1bf0fd61191e0c64cfb3b13f3c774cd400cb103624987b3d1c364a536fb3a559177506289214ffacfbc672f300b4063ea84b28d9e4a0b3c2545e40869ecc19f1981eec56032cfbe3dc063e5ec85e216cac27fa13514942bd994f57bfb4e1f97fd8e1a46a7f90d447d4cb370c9639213c4e3244c2dafda708dae6889990932cda23b42d2e075c795a8acc89fccd97b0d1416d0259afa25f1ba0df12d6358ba2feda10977a0b7f92f5ab9eb0d4608764d9177e8c0da2f401b96fdef9cd502ac1fd519397b518d932eb16feac03f4d4540c846ea4c4771af27f506e7af64853ec2e14886a85ab2f96576719ff502078a590d14d4486553b2f39053312026b833675e87a2403421bd2a43d44686a1fd38b4aa403c6133b5ae4b1c9f00fea1026ff736cb305886be340de9e7aabdb91d2e06046898536256ec6e4835a839256503cdc65f527f779c1336733177591b8295da1fdb8b5de59aefb9c52df38b995fdc8737363d81f0a5d330012f401c16b7634914f6e149a850524031b170f5a016ada15afede3faa5189c0b20b4ba55ab5001aa5840865f85be7ddfdfdac9e2c45f652bf3a1778dcec23554347c633155172ae468f516959936a0db6c83cf94217e46a6a1af52dcfe3953ffd2317c57b52be825f7216cb02327964728a07e366ddbbeea0552c58826db9dd8dc10b2252726055d8e3685c09816e53f3fd96e808de0fbf212f0c23419f1a915e98a732e049bdc0669f93b4c18ace3402e9b3ed09fcac91b9178265ded6ce26c017540c419dbe5811607202b77dca6763a30e81b9903a3f3880bb3e250d07b2362c237611e009f9f8ee36e009b17715daefb76bf40b107baa608052a235784379072b4527891c97f23d566bef40faf2f9c527bf19bee951f932fe41f8b0182ed6345a7f875224d3594e33f871fea935f85bd8813e16dbcde207d9f52dbe6b8f206a862bfb01cef042e3ad5e6958fde98793ea0d458fc5cb10baf9469d9ff9085a08a49de52e18d527c484e0175ea9bcc59ef446fefe1026c10749cbbe93ab1f427d74e425037f3dd0b1d3024c112a0b60530f0061fa749b8ffc4de0ca33a7eacaecbdd1f662e49040be6520373749c2e02d98dc4d445805a066af216888111a0569235a66a8828e361e4832ccde3223c73e56f0f7ed53fb4b7cf560616483895e0bf366f02a55bd838975d19a3bba068c3426d2e2485daccd2d709756586f81848fbf9a0f38ab0151bd114eb746ba00516ab10ec8e858f7ec6c92788cbe050ccc45f76833d938225ad04f8b0047958748c0c0c36be2c340a716f7251a94e461f028353f84fe408e1de10799d890d6b6c1b47c97426581b08196703a0c4ee50d502f647dddf5224f5394eec449dfb8db652e39ed1e0d190f7cfa1b41fc89753c53ce4653e51b048a526960427b035ad0474272b2c98cb4fa649bba0aa9f17935977910ff3409d4af1cbcb450707d4e790bdfcb253cd6faeb1250d0c0872bfbc63716301ccfeaf72bb16d2489640426e70ec462a7a62a1465059610baab4365b750126f48b329670e736aaf7aa4f33ed6c52c5a18504ed44474dcc74f92a28f7c190f506ff037b84f7352d99aab76ada7455e828cab357c17ff3d3c33b12227b34f547bffd5babcf70c770b2d7c8b91d6efa15c5ba4436694cd8761cb3ffd3a66c4ca0338604dea158ae6f14fbd1b66e8bb8f089f9bae677513d64b5e1a12b684fc24c0f72f07ebccedbbf001ecd44f884db2c8bc1aa60806ef79a17b9c1ec35f7806e4bc6aab7d07e7dcac11f1e4c13052a57249942aa7b7abe9eaff90109c92bbd7657b611b7b1c244b294b4885d2fc218f33c6c4609e2966cdbb8d2ca19327d0638b5fe82e64fa558bd6fb180fc667c6efec5652707cdef9a98ac66dc6472fdf32e449669622160ca3969fba46a9dfaca0e1dfaef32b1537d6360560b0a965352dcca8ca96fc628fa7c399302aec3f4eeec7c94d51b5dbaab5f698a6cd1761e94ae5411e7731d2880ee2c8d770f7b0d28a6ccab6c27592c4a618fee7d4f82fcffae922c2cb1d3e88b2712d49eb74ab3f44962382a2c77c7c254c7d3f869b47a490777d3d01361a7c1a00d2bb8de891fb0703584bacd9089a9357e10c094241e06f5f187af43916b96627fa8c3e82151d62dc374c57a9f22b8f5c72ef1ecf95a9abb800b4e063520340877b4011805b01cf23d49a049e81c7be16e1a86a58422a1d1de586a77f8f77a066b8e3b99cbb5f201b50636228c04cedc0d212ad419855a2e95f0eb5bb2c4eb3786ce55a6f33bf6b6a5752228002117fa1f2640982a87e287466394ccc1ae9e03ed98900145549b2656d5e3094713617a45876ba7a1cb7cca00c4a3f8ec464c644d23a2ffdcadd2ea7289c226da976c9857e5b93ef3c5d1e13b95c89203d91268835ad7d0ae75e99d3dd10ee2b263a2e934afbdaee4f75c03b35eef5109cf974ebd7518908f0c6cfb6702ca2de48e521f5bc9421c3726c5b297362e0fae2932f22054fa6ec277e645da73cb7a03d3aa46e8c50a6f995daf6a5fd4de4466b6f870f8277599383e3fb50507ef563900ff1f0b3967e27e1aafc9966edcacd1719649f667cb10316d4e617aa44707d98f2807520af5dd345c05d5094a38b99b7208ba942fb4ebc88c35ff41d939011cb82e8f31b8c6ed265e11cde6fff579bd65530c7dd71b3c9a3f023e307c7c35aa49cb8a5eda6fa6e9ff932fa722dfbe890cc6147fe0a530de33f62dd85a14af770be4d1f2868b0903658733374ae1be9ac0efae5a52b54a4d3acb2b031a6387b9704c03be923fb572a2e6be37ea1ad6b06bb11ffc69e294995fb2bcca522d37cc20abc9612e5bc78b391a12975ebe7d51d01e05e3ffcc1d986bc18fcb0c3f9f984f4a2a083e8d714908d7ce802e27b399c362a799d78d6d248580c7b0dcbd30a3de46a358c3fd490b935a4d0c1ffb252bd0c3398947f45804337ed55dc46315fa72397ee4447f46f78af40d7c09f8bcea0dba99e28a4c176099c65b2a294acbe8e0f4cf30147a948d2ba4b54a690aa5ad77da65423b67b29514ede8fe9b4f9bd4bcee30d3e1d5e5f4019f5d43ca8139826d823e8eedf1ea40d4890ff4bd5c9ccad7cc759c960b49af460a288b9711d86226170600e2c55d2dcceb981c7e4ddeb244e19639a4283fd9c7968516b0a1199fa494bb6a12215659ba70f16de065705b5b3299a9418e2b0a1bba4f7946e3df66364742cf8286658ec94a54550b9fb973607caa2ea2bb96a183c38b5b866f7c6a57528f6071cafce7fc562a77b72437fecc0a3a986d7654b426e680fe5669200baeeac5366766010ffe4e23924a835251ab735b363664c66b6bc5e5e363328a0c483621224d2aa8f978fc54afdaaae784ebef976f07b9b87572140746b56fe494eb619f394b799d89465d648d75367b7f3a6c54bf0b1b6d76065f1371d3a4319c005d04bf6f48a27d12f9730e6457e3eb361b6bfa67d4a4f6c13ff54c31f40f534f1cabbd6da3bcac8d215441d04d60f85d8f8fd92a3aad92762a880d7ad9f22f0f1fec48a37cb70db330f14e5e35d1aee3541ec63991f78689c9e409ad3807855cdabecfd469bcb25b39c3711080c879cd2142d63ce880bdea6862db9dc7bbcf308b4d52f72a30d43eebff02107f6cb937747a959a8b6a574f5b2c4cd62ec3fa7efcf6c1d63221a631749f62eee1211d3a6f2842802f8f59fce39ae3cb4a5e63c98c4506ee93ab43f30f5f0e98a7fe219b2005331414dc61b7fa85663529caad82da2dbbaecc8d8685a2e3df09295f23cca52330a77d01c7ce42c5666f696966060cbdbfc70a48e7ce2ee909867861f3cd03b92a2b28390047398e78921a8cb64c75214898bb0389fd31edbb25d173d9436f21afd7c7d0b1efed6d2e5554e1a91c22b85acf84c6f9e191dbb65f4fa5e03f0a5807924b56d10861495fdcc4e88d21bce58aadfa037af6b5c8f0795476e66db48b680d688a126303ecc2af556a559de91e909eb47e607a519205f5dc9b6bbadb04d90e654fe9aa179e8f15445fd8d5dbc1991d63128293328d6b12422f06f07a94ca636277fda7fa1690ba03655393491bc9c82321c9966cbef80fc95c38edc2fbf2f5f0835244f91e0cf8ecca9a487ca9a7c9a91f6ddd0e78bf09753725bf531287d69588f54ae488cb674f34c5cd362bd560cd099072911aa0fd453a13e691b02e5ff4abde0bd4c275fefa8a0a659a597a0200d726429a429c36d85fdd88db467725a3a27d62a7cc022909ae84121478cde118584cd308ff0c27394df0073843d6cd16ca70f952588ff823a076f7ba006f15d335aa256ea73d584ddf3001573288453b5ce301344ece99c0f7482ba8300f7af7e2fef775a2d8f9b19fd419ad766972dc81f0f7392e3cb04485fb539f893a6c2a1c20a7434891c45f075269c3a3d3efdc03b9590c903bb941dbb25b6d2949ff98dd82b455a11ced6b0ccc3a5f82554f4b09d7b07b7ea4dddb85334536545d9687a241678fb4dbfe6c78fcccc1140011c5498c7141a4fa08cdd1fcaf98547764f151684837c4e28e0fffb78762b8586523776261713babcdb039e705e5375f90174c5e827a680529b28358e044bf3865aeb025796b292d91601e764a9ec0a14fce1ccff66ed0230dab274c14bc4a27f55100da3731f74611125e242a2630f34983996b01bd37a3ccc56c8c61168b99e879563da6c20f071673f42d0d5928788e8d9d22a661438a093d18795334c7bdf2228dda6eb5b07f4b66b858ff401dfc8754b0699352e4494e250aad28090526db5f25e6a9a31d1982fd566a3ccdc9890dcdd1ca92b4f0ec66b2c1b0b58face8b92ddaf15a343eb3d7752bd8151404c9c4035159a96e340cd72d9361a0bc3e925d1a9e1fad0e96ed9f983db8eb8310f51ea3af5ac6eff3439148635406abbbf89c1f9f8c610d4008c413510c7a9b38d4c60f466cdd1890663ffc6f7e192ff1664de79a7409caa3e7319b029b268d9ccfb34bc9cb8966a3fa804cd7759e46f4234f193801e54ca292de9bc605cf5776e58ae54af8e4e1a9bbb883ffbecbcbbb3456d85683a79a6f79154fb0596c71f23f264036cf30425979bcdc1679608770e0dfac336b58ae77815e35064b2ae9977747203babb84232b165594e2e68d7d6a33e690a8250c2663b23939a2ab46354c9d706d09f01e570c4ea30aaabb724ccdd7932004563347d941abefd10f56698852f8d4ba33a54eb0fc956393650180ec9a565a41b067fb0cbcd8f61f08edd0f142e96e694d70a90f212c518190963e588a7c4ea3bcae44cb340b9fcea086aa3009e029cfced732cec10e36193dddeab97d359225aa81cd665f5b3400d2e120f3a179e4e75f96dcaeb7b5ff12e5b7bb07f69ebcc2a9cf7d31f61fe6d4d59c50fceff8d08631ef1260a34c4abbb404fbe6ac5379f50830efe44f389aafd2d5838aca6e2537503f13fb201dbdf706606213168c3087144c67878392ea0cd11b31db9c1b0c825868acf1e43d3834adcb7e0eccd1bbd28ed9c58c98e4ad46cb5d5efdefe70b858d2e5f545b60d94624760942fdc59a6c2947c90d972d22866c5aba28d8879370c3544fc9737ed6c9cdc1a3357da9a463da3158dcfef822c2c1589b2ca891c305afbaa1b73601372c2ad7f07c66fc971c3cf2736bda5a8984dcffd1581c8d6f854440b761722a7debcb63351a21049f0c9470e429b1aab585e9789d12a9f3a7550ab0918fefe00d1afd797a8a4a655637f4a749d672ef89c917c6621490853a0077646b5bcb37d939cf91a9393eb1827758cc01ab81b788b0181ed0939182625f718eb0b44599f19ebdc9bdeb2042a1d12f08ea4c4dd923a9fd5c23bf70ab973a74540fc6361a47a5a2bb60d1692b5e6784cd9b0985c5b343d115eb04e1876be8a967ccc58db517a15a201078e2b21d384f34ff97465337b3c5252ab627e78c7babf4d1d0316aef2135c88e3f6108d4a8b2b9e86b49edefbd9d55769bd9c8cbbae20b4497eee5db863d4d8e8dc9de2e75428519c0af126c6e6af397cb25bea5b364913d1ca0265c410c9dac41ed88467d86996799907ce3fa0ebe454260bcc08b5132de8940b37937837bcdc51d03a25f0e8a7cb991b2fa0b84d7be061aa1deb7ad8a9843a76813deddf217ba2c63de122cc58e35e135f54e7d7423d01e04c76e81f6689b651a0217c2d94152182c439ec770a6cba02933536a391f304a81066097f5846337af06d5065261ca607bd12175219cf94f49a483940f05dda9aaf6e6c5ab040c454f0ebeed5750749cf7127bdeb903764b8baa7a8952f2fa4d9161622108dd523a51cbd2849a806beb8ecb5f5de48f271edb0f6029c51834c52f4a90f1c03c657f704c6996242a9673bdd48c2b1a8cf6bec21579ceebb05eca52a03153d09cc406622b17794c19165972fb1bea24999f9abe328960fa62157d75b6baa97c92d271e5e47b9b99afc5f014a9107bb8cf137ccae241a3bf08fd89d888139c8a8d71d6b39d9439ffd2b024e7bf7353691c03ae8068d9e13b90aa85ac389f860e4e6180ca6ca39f9c9c65e6f849f778effb1806aaaf3ce4a68ef54ea5d501946d150c17082a300d0533e2952f3ecf606de38ef8494778f7612be04c7afb1abac0cdc85c3adb3aa61b4f9f13fd9e2204055ae30a07003362370e7ef09abc339f75659dd0160e6d169deff7f54c23c3ec49f1adf3060d95e51ca85cec59c9683b6cdb22d55a44af6a48f3b69c0deb392badc8fbdbf253588caa3009d35f51fe2176852a729ec0b155248ed449d60ac17d82dde97a674a3d7f0a697a3b5d3c7be026be128e2b39e09003054cd24f6b774a9ee9aa5d161604e5482f64db6871ebd4f4de2370d7f84f4d3ab4c4027b4a07b6841eda01868dc0d9255d2dfd92d7cb846473a937500bddbe1cae0fa0fce30f68af2924226e8d7588a4cffd67eb98e45f0d4d4283d853a9081bc65728c6b960f2ab0f5c55b665a0913de4d609c9981679b0ddeb7392bac40f364816de85bd6edcb9a81070ff24abc9b5911d68fb79fa449c8e12d840080843ca8d4dc56095cee70265e47c3aa5d9f1bd91562d5d6c7b430680d10eaf7f18501e602a6d7520f3cfe812d8db58fb91482a75afa8016ae7f6468dfff6ad0b04789906e4122f5f80bdb6c48aa9fad5e172149a8627dc66d40ed217f7cd0e261634fa3003b3c6e6a17204c1c3ec3f84777807767506a0cc1841b36e4c9a58a8fb34e0dc169bdbf23f817f4fec302920792d0f5cfa86d66f1a95a69c7171fc7ab6d8e1df41db2915f7f9016c11b1a64ffe0a0c3881dd75e9c257f6020ae32a71fdfe84a79c0deb4848af7ff36231490355eb0784b3ea1410286de672bf52b68a6ffc2f2349a2691c42f8cc61799c81e44769c9dc41d3554326bcb107e8e9bb39de0bb4ec56a24baacf98be9846b7d49426ac1cc31b26f2e90aa4d71ad58748d577a16140201ab5342ea5a4cbea0c5169c354e59110c093eb4f03ea001c9fc15dceefb57807b703d7997af08da5e587a65eccb1b3726bdd4dd1ed853797b7442bc85c592f38f2e5972431ebfc47f96051a402793f11f2d5b2f4d0038aa0be146b375d7f1afd0a871d5a278752cef5f1d195c5f9ab19854e05b2d32e98189167db719a0e860ed4d5aa63b64147b77ed325d071e49965bba8cd3b988a36f7c90c4ed33ef6f61cab5bcdb8c95d03fac0cbe489f2ff0117e2a57126ff3e5331898e66fc60e22aeb05753e23c9649a8ed0d15f7d9be29186d5ad6e955968664c8202f8c850882fd68f4cbf1546d111b3d9c80c5fa9c7f51e6256a05d26bdb3f20365cedc0b2399ac4abb52a7c6487cb84e72cc9dc452425811e9fb3f1d817c573d2eaa1e6ee00eabeeaf67186e27481074fb0907d40dba0a2bef771ca3e0923a1cd7b1e3fad123dbdd72b3ad80d8315cc163ec4f32093720d776d62f459d9753253f806da459b3a300d3e6e795475ed2452a767fc9cc02e37438083cd16cec07823bf81b0a71ac62697c7da282860e2653671190f19913047e04f72f82686451cdc023cb77392ae145b74acb2073a10a33a1fffdfdb29b989b2d773d40c90ad355822c8c0c091a870426a80bcf7089981af582dd52faf4842b63a6409bd4079ddebc491b90c60ec0d3f047c6d44b762a0d1371c3196646a3be56142910b046a688a32ba5f23556c41057f661226aed42a8fe12e2a3a8b42c9740a54e5f9be60932a911852c58c5bf8e82770f713968f523397bf302d4d2065d80319d03b8d7271722e40c0b9ba8a6446e90fea57d49cd7c0bf937a7d8c526ba27f4a7889431c43502b131cd42794a9623102cd065bdb1eb6c09e0ba900e65716a02623838bbc07b5fb04ef9eb4463be2dfe3928a4f240b2eb25d249facc9764e1aed2777cd79b9cca8388e496987a72754867178007660a85b093dc79366b2b9f1dafd9585f3df0d55aa017b5bf1f8bba990b1ee9b9e7932bf1496800b45f426118f2b378080b44a50422c31c46840c4a1ae953769febb90dd91d63e1ff83ca32a87e5bfaf90ff456f359f4965421d4c5d03cc7aef56f7c270a3924b7a185d83e1a7f286eac9cb5be4f323c3d48454aa82a2fc2c5967cf59774b1c858a7921b63833c4ad93f7e08c7db938f7a335923078e9cf7379c120d45941b5ff44b0ce297255a1e95da99982a2fcdd87e4330af198b3407783ebc6018c7b5fc29eccd54781f7311a75ff66e9f26ade4c001b1eb2724035f58e38b480e13a981b785e5adfd54cddf4088fb3792767631c61b7071afb5193db1a653adf3acaaf82ac09bcbeb8df7bb8843f53577a625b28d9ab20b995e4f891399e633d572ff2950d67775d4d12a4ea7d8887f29dc897cd7aae63911bd79d286779f9e22cf4d426a50f4454c4521026ee3958026b6cd63d27a64f67ebebaefd1c35eb85aec3d4b00041765c6646393f7b4ed8fa296cc977b992dcb83b8610f6be8e21323ca5dd35ed9d8388768d4c50d1be3091e2fa4a0cca33441bffd136a8a86df5666d2554706c151846296957d2e17b05886143447b1bfc1e26a15ab019000b153e32dd4bb3d7cd2d8f9746952379d9448e7cff14e1cf53835a106742627b30d7899d5d76308120662a795b0a8352a48ba9e9b06bafa1ef5d37e9507369eb353962049812f16a15092f8c87201d86b0c7fbace0f2dc8e58b6ee07a7a25929e1145b996728d56fdd8fede445e52c21b68bfc923d8ffaede96f908c849812b9038046396ca1ff76933e148f9898d443c544913928e019a6abe9719f03d7dc72743ffcd529ad70bb85a2804608eaf7fc4c7c4cff3b08d7d40f481fa9beccc5765e94707b395445d1e50452767ed2e6ed0e5fa15245073c758c00de7c0579b831574167366404d06a4057c8b0b4d7a8d8c0db200559d5b801f9ffb7bc1914f3b9d0e0ab6c83605d67576168242ca85287c2cfc2708069a3097584615295e0e4b2b999dce3df0330678a634141c73684c10b3efa60f532a1584e0e576e1ab4b0a772c85f0190239ac9d69e55f9c6625bb65090d5f3a03683207575ba5e2cb8f4c9e6f47912bca0e33e62e9060acd61bb020e8baf436d0691478a6621f33db9075e439148c8c1fe5fc4f891edcee90bed09daa0b0b9a037ad2981f39c4c4f22ccb4ecbb418d98cb5dc4569c6fe34eb95858f41d234c0be16e712afab015060ef4f391070f659594770229b59721a9a76c92eb672c09f83178959b7493625fc5129d02248917dff086762f69b466e96a9a49874364a4ded8430aafd32ca40e8dfc2413245071454f320466788522059cc62f129c3351a2a99ceb742d722a6759d40f3107b63e27d4ada9bd43cdb126c45d219e2a7216c959e3ea12eaa9f67ccba42880f5c8bce998d2952a80558791dbee90cef2071465c8fe532de8c186fbb8536e3d6b64f9d9b8f3b5961e1ce4be6e79351115c5b7a2d25039567b48338534f37264c2b44bedf7b794e535f8f3454a93a7a72770a5e15c3329a79f87c0d181d3b9b6bd6b47e24e454535efa09e3ad9c2c8d37f971661f824db69932728ec0486df1b050d559b9a3be19e6907d26a3b8eb066ad6e1155de1a4624411f42619410aafa1bb8b9a0ad5da745df88435922bea3799a6024abe683b8b3b3e662c1ea2bd32d04ebb4ddaf8905651767d356ee4dac888eee8f71f456eddfb1033bc00a5e73a42384279a0beeb94aa896a7d40cf6afb2db79bed07e982091c3e508e44285828f991d6a9a0ae06fbc7f733c1979bcaccd9d8a3af8f510f07fecb3ad768270f011c680c7210ceaf0c4ed6f48050b345a7aaf0df530f87d19d8fd2242d40b44b9fb860c6dfe088f9987da3379e4043ad3a5cddacc15da75bbea81a7519eb9589d878c88529d5de1c1025c763e66eb7b432738605863f4764a52bed4d403827c82365f395ac8bf8eaf8e7c8a928814ef04f1ae91835ee987cd24ffa61b5290992d37666520862e39a2c9fc499e27c424ac359adac096819944e968f78dac43f4da4218b36de78a8f9b029b31154cd4969cd900c9664c4d619f3ceda48b95f1856854a5c9ceb4b469faba90d10a2bc68612a53f900062ccf570a350ab1cd6cb79198637a5edea91d0ca06610815cbe2ae9048333eae907b2673fc0181f74204388c6f756029c0649042921e63dafee5e18b9c364894f249f08d5f46c48f8e98690f3c9daa9df9d20d6a9fff88e023251926","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
