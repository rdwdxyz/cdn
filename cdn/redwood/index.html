<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e108ff416d70bd924f41b7275d4f09afc10465bba87c3421c0f5273382115ea5106c9e5f1532ec25c5f1123b13148fcc01388cc92490e30a263f15c6e11748aea108820967408c399435c1b140c901a548e28455a61874370088098dd9db737a110f7f6b40af32989da5878f39beb60a9f53d562da9dd62820778c84b3d6062972ff00d6eff2f3552d631624ed3ff7fec94b5b3564a041d4c5b9a90e22b4ec8063977acbc9d2da33ff2580bc7068b4b5e149700c6297bad06c3911bc796496b306235c478ac86942abf890435d39f45621c98406d07694fcc6f5727622360b53f5a7fd40de355651396d1790677d821256e2c809f19db2e2c620ca2ff6fb53591da43bd324583ef80c5ef64f9f0c264df70b3ea67e5bdac9f4ba45301be0346d848582a71484eba5918a6f5299cad6040dd5873ae4d6f3e344dfff10a7d7d7cfc22318b0faae833f97faf902447c959926966e4bef3d1bbdd7b4d4f3e66ab0672c9b5ade49e4ec6f692cb0aeb10b4a30a7f87cf742eb8922fb97edc757240ce0b0bac082cadbbaed67c33ebea5254fc820af0103cc4f5e83c8b94213aeb5f091038f38fc758cd22ec5d6e7511c4bde14aba1c2c8dd27d9de817f30637c194809383a70ddf30bd339af360d13858170fb303df686807cec99a15f24d23373608ad04b8260061aa83598ab94f2a87fd0685159f4a19a7717c78adb4975a3a73e8665012b5b3418d7971e0b1e2a2e9611b1379ac98d3df6afd9a93392c0d917ab7679284e4e5062b0e3bd0e18096af7ff9e5fce86ea7e6ef2ed6dad16a06213e01e9027ce7a662e9931b96099481e4634098e760678cc8bf1c6ca27afa8592759a72f208244e7fddfe64d84c3d7a2b10d1d5c9ea324bb670a589c0817478642fdb191895d0cea495985a180004aa4b3ddbe636c65ec6a4fc4c8163512ded86039023a4ff6b7b5fcb9fa2467962f27fd3913fc08b6a896741fc5b7b91007e2a8e04b9f0ccbcc9ad9c6931839dbff300691650a266868c9fceb7ba75bda15bc1a19a58eb50b04428515dbffc56393bc7d7e47d9f135f9da8908a7400a503ac5c744315fd43aec40d5cdd323ef2e61ce461ad5b6e5cce44928a69e3638c6c30489a959439f71b993286996e4a3bfab17f782b4b3f7e5ae81c97214ca3fd4d44d6e23926c83fc4682cd8ab185fe343875fbaaa1d788e30bbe0799463de3964dafdce15ce5f22f9bdf2d1e26e4bb1f088f3a7a22c4d8ab3fa7dd433a22f1cdaf1dcab357e5f2efd5db98086d44a002109ce108b666982285ece1be0be563edfd695b51de6ff0f00b2ff79730b010cd4eff6c94c42a35756164963493e747afa91e5ced0ae6ef2f198016c32f14af90fa7a8c380ca478556c4a5924545d750354f4c43e1beb87a24e169bc141cc34b4d0f081ee39bf070d032b973d6c61433f2752b72f03e2566bf5edbb726863c383c87566f7b822c7ac1ab355b831196156550e3e5af8a6b455c46854adab2848d7e3323b6e7a9fc4f9bc47093badc040e4e1c4711da5569f0ab88925252374e410c685e337538f531e60b7f5f6388adee845f29151ef4521cb727782a026fca29b740082fc19ed2cac4ebfe463e9bbef6407e152f2efb98a33c79275071bc389fd83d4f7e73e644845186b46cd97e9753b977869ec99e8f71473bc096a59727a6e11abba767ec8941b09ab9815f48dd091a954667a94b48f5c673ba9907efa4ab578169814b9ea2e872d1e774fa397d38f2a6a805c5551964ddee1db0c0edf4a7e75cefaa30ad68504780949c9b47929b15c1b65707264df0621d9de5b2d7ebe39c5adde60c00f0ba36c6c3ae956a8ab11ddb07474743f71f28b45ab32810f10c614e00b39f0d69b8e440ed2b9ca1c2b70460ab3407bbe43ee8ea8b6eb99db8bd6340d46f370dd1114ae64bb965cb9e6fcb73a912f2f01a4beda492f3f04108c5b2402c30dc6f35b7dcc5e7475aaa6468705ab663d7bc0f0e3f24cb8728b343973d5907719e862bbb669ba6b42e2b42e3e38bb7de62ddd72a033601ece7daacb11d18072b2fddfce93fa46335a0f2d71a497fdc1d57d95613f16b42ea26f2735208a2113f3dcc942bb017b106024e91a34a9e5a5ed79764cd905bdb0abf35d69f3d0e307cc5828ee0d0ad809c5915763d154d1c35e66dca74214f13aaf0af6fc0e24e2b1d0bb22c552ff457a3c9e26bb9b7bec1564e4da358314b35c925dc945126952aef043ff5d42f38e6174cc6ef8c496f5a4415cac808a95fe11f6be95c3f3168d527b119178c0512e5b85da200b835c5e496656ac9d724beec20e6386f3df2a4070a72c58211f563f4bce02447c8541058592bb88495316ffd339b4bfb4557d665b05153dea2e8515106945e75859436214a73bf63842378af3be1a92ae1c5e762160601ac0c483167b07a1892131f68eaf02bed50274320642f65e9cb6403942999f1e54108b91f57f8bcdf7a24d799a8f2435d3dd067a70e79c5194f83c74745975580ef8fc9999426981fbce0eded41f8d740bed219f745c148ef38c7ba55f18d38d4e659ebe11dc2e615490acec55b209ad74512a8db09e58484c3269e015565e25433d3335b2096cdc33a7eab0c08cc716709b72d35a6672569571933195d7b61cff439c40cb09b8691db1a17ea0f829be79bc33a05eaa105806ae5771e45a54bcf837ce7555237297b598f6932959ed45a338694f3e01a0f9d9d62cd4f23335f906336cedcf647cc8f08b415c796713decc6f4590710597c3c77b7ad11037082a861df458d0e49e9b0179f6e4f642d6e058ace782a32c3a79744396ccc2305e992bd054d4b462cb7ae1a827354802202aa228805f5aaa736a74d3910e017152771976dac295a85833805ac2bbbe1db32998603f24c272360c3421481c77a915bb37ba760167e810ac164d88508fde8702720c7ddd647c7a1704ac8bb31018673327ac67a8eea1e488aa23f471fbd1a2bc87f1779c23d8ee77e5042d21f870c045a24438be8c498a5ba4e9fab78d04c4afe686c794ab80bf9f236110fb506b6a63d1ae7f55525b4326c9e5f40affa8982a385bc2e4cb8b406fb9df25dd4212827aca07c98d79b13c6056819fb5b621258ce37e51190eff5d70128a84ce0baeca8a67aef0cfc63690da013b3e4011c194e1e782ecf8f0ec31bbb73a0f858ad1b7b5d90592e5b16349fa9ad8626fc2241bab9d2e35d0835cb696956d5ecd4011e0b11c4214fcb36a848019efffbe2f4e7f02793744743a03c78bdf8f9f3db344094207a9223d995f15e4dcced53f28a703af157eb546c209d29a52a0bc8e40470d80e2cd2560e8177e4ba9afa2acfa661582629a62d61cb47d9d1b987edbb769fbdb89c7aa6b10f63b6012c0a864d281f8482ff39a743f5e1af4eca790edb90b195018dd366b73ef18a5a1a187af68d6922520b319f38cbb9904ef78a8a69ca3bfdd8914db6e330d0f9ac4c82c3703975a2152bc379d25df3ff15fb9f64ca63f3213e71dd6d51516cb1adadf81949a84505942476d9a445ea1624204aaf6f770fb9589c0a93ef799340077372fbf822db8da7ba77c2d09cedf0212c9c9fc0b62f5098b0bd1b83ed1a777d2bd8f2401db368a2092b3caf7d1b9f579aa289566d94561b0e7023b6c07300a7603ecb2a75cca0b7b13dd5b0741513d18195d2e8dc1776e0abeb234d4f2f19980a0787a74e1ccaa8b76197de48752c4ab82808e040ae4f9738fb92da350f22160c789d96291510a641e6a2e11b17faa0460436686ba7fc668db29f5e1dd8c7e575ce0400533061f9f8f24ed9300142548861914aba3cadc9d49ce0d00cf3f0ba5cd9fc9106115987734237695e090b8aa36e72a4f89fd585a9ce4e13176801a075e8ccc6eaaa7cdf9c1a9241e2876d9649cd64558638a548ddecd8708458e39bf5f6b1260dafcc8de3b8908cf19dc9b6c90af944894396bb85eb9a2b0e824face9adcd1c4b6ebb725932b46e0dc479c6ca909c1ab43e6bf92c808910d2f39b0715405dd6fc6fae59655013bd7874fcc2c8ef45494940800d56929192cbd4caa63d3725ad0789c3b29e07fd43a20156067ed72201d29bd637d01764cea6744a65ff05682e90885ead00c9581a80b17a4b939ddc4f5b0d71b0c70a41a17d67d33ec86d1b05007761eac47c4b868f2ebd442aa066b2fa09f0d288798e949b1d6c64127f3abc714ec40074b3c87165e3f37640ffe47609ec58cc7bd870b36ceba3c1a44ad49540f119371943aee47fa67fec753ae3d3224e4617d7602df4fa0753b3cc2e5c5f7b0a181b7cfd283dfb5d0f68aab9cd31599a0d993ae8b4760f9986e9324cdcebf7d08f6702eb4d38f9cd59f5e0b93d3910823c8d01ae43dc46380a513372005f0e748da8deb93b65d1b9aa276cb2ddd33560065b721e78726b9ef84a265acd648225f21ec96fcdbc27a52e0f2e53e4ec30f11d530de06263885365bfcda2cf7f32346876c41199340813e038438d3a1742204f408cd189f3602a5a8093086f546dbadd10deb16a8fb81d59cd52d98c3e9044314cb7825f1201f5b5a484be173604c8e58bdec2d06bb2d6b81fa2d5a84c1877f5dd385d54d54a6ba4648e1f6d9d9b872580f67dd38430d34a8a5232c3c2f163c17705b385f63af360c6d9c275e672f1776ce3c6d5c674b3b1ab53528f5a640e1289d55606addb6eb9ac50aae181ff507eb6453526ba9e8acc106de249456344095011838f6d4079fc243b648fed4556b3a48b8e6c1c50ab96c51b5868e0d5e294cebdae27d3cbbe347887ea9c0f24bfe5d6a535d9f721722f50580a3adc2e5626eb22d644154fc8350b29638fbb7c50037f4047419222ab4a4104b1242abeeaee18d541b984b407f294d122d68a62c4247e790b9b94542269f70daba7880777da4630732726a028fcf1bcdd03dd8360b79ca9ff24c4135425bf885c61bc55def808181da96eafd9b938da9f06948b34e3303d3285787e761370a8f37fb4c48e39d1ba7a6d6999c5687a2092c511d9160a8d5aa261353f386f6f24b1401eeffb22211545ecb1adc9d4ed83955e25252b28a6f918c1f1e6b958014b865a3a3829b1e7d12b6c3a193ccecc18ca915e6f00aef68669079b0465b42f774d85bd59a5831cc57e90e9838b144cc5819a13b38ee27bb88e95e03580bb1cfdfc7be4d0f47f5d928c9ebd5cf42024aa08860adb43c19a6d63bc0f645470bca777d8a60bc81270918665a0c673b5287b5f0a1e24ba28d413bbb6ff5a7d907fedaf2d8b2bc345ef200e194e8f2a631fae79f56ac2e0f5d0903688136946b58170562332b3a9dfe9b2da959df8c1bdcc017764173d9b493e87253cc55773db288cc4d643022d13f2176a883ec9d2764823dd0ed2e3763093bf11a6e7121f2b1613048970c2293cf03aed3389ea1a45a6529ec336e02a6638933fdd7c0f19d3dc79a6a9577849e4e3acba5108a5070c6b13bab874f05e66888657e4f66e63b7fedba8b030f3d7649644a4cb7b205b9d7b5260ecbf06bf924952cf6f7bde46abaa16421d4ec9de6f3942b0edaa981aadbf7dcc7f7254f541e63bb939a1db3025fee1dff4ae3810668507769849e8ff4b0ac47014b4b6230760cd4ba566f5c965f37d02ef19bfb1984239c2e76601b41d07863aa8f304bf0e86c9368f1929e9aa817dc878c2a00912e3dd4e8b43556e05bce3746077b8cdadce16112f1c59f32c6c3fd6cc2b3e4a2cc0835d41da78884c40578cde22bcc9c1c17b6b421cdb6a608fdd95cdcd33282c7b9ca46a682321150deed3a13edf3c86ce870e18774dd05941784057b8d7299caed53868b10e4eafb4e7d277558348905d5926de65c24ea9dbe2bf8ab4bf906f6d1597ff1cf89bb9ec4e73d94fa4bd740cc17d3d12ce904fb077a847e4d9f871ada822357b194704e71af28a057e70dbcd595ed97ee02b59139fd4e72ac33b94fa2c4f7321517f3b65c6143693cdce5a08b88d7d1815bbd8ac588fcbc0f0daddb83fd6360ee963c3187273ee227b29856ad766793204ca53aef684a58bcddf933c2433bad75ab3d0c35c5ae67a9629355c3f7893654ffb912768488745dd6016ce45e6eeb2596ec1bef437dce801b23b63739e79d30c2282f8d397e4d52b85ab244a763c5529c72fee151fde0b311021ea2dd05d18c8bca8eadc42d26a07fdbc0e560b940e591348783a2e78e60413a9f387cd4ab92b44116cdf4c3f1092ffcb6c72be38fdfa034133cf4b8a46850dd58c9d47d72ea590327a499a243a4a8dc4ed13f1126dd51ab5e02199e0e4990e9bdfd6201b95362c734371c38de6c0deab34d8dce5bb5fbe02867bd9fefc285480d8380da0f045f0932ad885815b7f5a823a74c8bb5be941170a60b66683712e72298ecf295a2d2c4fef4a70c68e5eab560b025362ad417b1303520715d28ff8a621610beb7a8208d3e6f5bae30afce31b3a568118878c1bfd273019268a533aacd3455732c99754adbfd366963c0b7e5da3797da841650b385c2321ec0af677aea43c37a0f38a936cf8e199f03e180b62152be203f131766d65a6aad4a88f20b888989bed4436c6378c1c09e03bd90de3adb3f84efb698b5b7ff057d0fd00248667c0adcd836053cef0ad46fbe3d6033656025c2e07668713e01e17fc7856266102cdd7f63c825cbaa6f207327d17fece5aaf06f4ac7a43c509de6195db3614f14753928f97c64b67a692c3974486ddf76ff15348c304367a4e19a1b8cbecc7f3b506e88b72cae061a1b87b2f8ab59d76dcb4472151c5517b9bd644b5a0ba3ad0e4d27d818b07da5d64fddd2157f80c4b958f186b2652bc0ac88d170a1aa9de150179bbf28b914d0ddc3b69f6affcf8355fae453dbf3b353d4d09f370513bdccdcb8d0d52abbeb808cecf7c4008112bbf2326ac3ddbf9024e053306d09f4eba01a1f611cacf9270226ba4c24ad8888f17acae9a1a982255dae3f99b96097f7af72a1e5355f88e5b688a64a19a5d84f16b1cfb7918564f64576b4be7be156d3b0b2c7a5db9cb5e812b9be80fafcd3fc86bb96c1791e962e39bf76cd83342d9920179cdb0d6742aee67294673d21672b6f72be48f4c0b8135f244fd3d4a28388e7b67ab7825c360c98fccde0ca742890d49cc5bb4204a0ff00c8f9cc26d3d77aa23fcb4df57d24173d8268f93c93fa9d392d401cd6e33ba30e40564b7b79b76e2f9e67c7629d0a49be7d826a2c9c632eb02a43912636a9a6ab9d808e4a1b6b3581580428e2d6cd88ad61442938497a01319fbab4753c97d98643c335e127d203cec1f4aa874e18e11faa15c587b16773508c789134161c748d630c4b4ac4f691587f0805ace249c1b28fc56d9a2d063a1b271ae9d41c966ddb4e5438ad041cf3a317f5202df29aa3d3d79866444f84adc34a8eb721305d3a7ec7063360cf4b1ac262aadd5e1dbc20b150d21a9721a5a009c7f7ab995a46bb83549b639db2b2f855ed7e495dae06c6496cccb3890a92164c8ee8adf9924482774936562e61f5de40359a5dd907f325832a6ef4cacd89e01255d2d0002d3819df2f9b9405acb784155d41ccb6b6a33d0978a86afc507356f83a43b1a7d559cd2c48dcc471016e052bbb778d5d33a5f03f3c203f7aac7e07851b0417912f4616b32be96a0ee11609398339affc7259be3ddd692306e53a8fae6eeae7212858c25a8507eb68cf20e5e5c5d59e9db5d6c9029909414f2700922c4b0259d17f53b589e9c10de105e53046fdf87ee56f3183c09ccc375fda07451bb21c286fd26f54a5c8676ca591874d74bb4760e02f34d99c33efc9764000dbe40b059047d424b8078282f514f1dc377f881f26ae116e81fc2e6a90bb8d3d78d7db09862bc3c1f797d47d4e26b90bfb64afb9fd97cd86b3a312c1367492f18bd3d3fed74fc2eaa6e0afb40d7db5ea777c8d7bcb3ca37d8f00ab50739604ac54e8c63fd93c46e5a623567202e549dfaa7c1adb81a7728b99f846bd273abc6730bcd46e59ec3718c1f89ef5cdb56d5801c14e1500c710e3b99fe783dc4507269459f9351589959665a0ad1d01bb91483184a4212444cf4d79ab5e22698e23e54977f670c1c4a2d3fba325c5db37d9f895b6b1a7d0b1c00f1622daa2704d857de11daaab44cd1d648cc8e9ff277e4ac253cf09590fc297d18c86232be9c840ad2ac16831b8c90ad0a1dca4b91e9d2849590e76592c43ec105bd3204a8dc5caf3b53c8e1700b941ff9ed62c1487556d98ad264718c125aabeff5288e72c690ee3dd4d2ee2186f22174c36c940316d12a26a74dbd2145142b3343b0d6242cfc6430229380813b2f59e776a500f95394fe075c07a5df38d8c5441258a52a7aad7f8ff74dc8af2670bf631a1fc6f96e0b9b3f4290fe85ab3eb030f6deb90b637331936605e05a1e529d366d2b79a4d4af103ca02f11affa127f1cbd0d825ebab04044c8b7d85f396d32f1276a9d82ddf76da144297d5f464b2df0379451e112a46ee9b9717120b7eb40f0430f5edcb0f3d38ea04c0e5eb170b822637f7d5df431903876885fd88d568df9c83936a5c3b335e63dbeff736a0866b22fae59715073239368dc8d00ac6865cb734108b70c5170efc89751084623bd4b6385e8f6304a55a9967d5bd7a707d3ff8a0bdee5e7b4670707784eecb87478a9a73d8f44abbb98d426427fcf26fdfea4eaacc8db5ee5f4457cc6e31c4a712af58318b9a67954e7389f98c80a331fd45bb858c9ec7ff1286d21ac915af814000089dfec448ec58b93bb1c49f61d899cbb11726f989fd99535df6e44c6de3e8bdc2c1bda033dd8c5eacef14dc07c5be930cd4d8130c9a98a6f3bdca4023f9511588610f32692238a0117537f6c408961f5ddef5563d2fd0d98d1ba63fc169fdde5c29e61d20a2fe522103bbbf03fa889e95a40cfb0d6997660d51b49f4070a8221ad9b57244cad539a176f6a01723b816fb7f36eca60943430ed2e31a486c9412e532f84908c8f5f567c26ce5e5edf85b9afb68dbb8e531705e2dad85f737d666a74c1d4028ea86b35dc2a788473c11e4a4a0359f2c678fe04112fb25a453ca452b6f0a07c8a2c04aac729f223b8931dd273b0fc93de886af3be9799ca49492de11e5ca129de2f1a16a93fd8cc528cc47d2842d70412e754eb867004b36fa085875a069e98184abc0cd7cc5c4bff7f917cc618e0856368c8c3799e3c3ff6f0d310e6160b86854767e0b58cc48150343fca3b97d2d444ed77fe7ed1e3db923bc4d797bdf19c566d2deb4a400a53cae788bda5bcfd82c224f32aeec64d92840540cf64ccd7ac527d42efca5dbf6d061136236423acfc7e3c7e255c8d0e970ee2a41ed0ca9ff800fc9876a7fbaf0901353c54c183e0d033d4e8f5ae7a669a99f29e770da39471a1155fb29adc664f7421f2735b60474f60d503d18619ac9d3dceab2fcc5227d21bec3080e4d0f56ddb16124f70dfb35d136cef0c587118ee2ffadebc2655e31c62087f928ef1bbfefc9ab3cfa1bf10b67fe1c5968349f6e52797b39b9882549ffbef84e99d3fcb88284fab59a0088a754b3888c6efb4bb3756fd0f825a5f52a8d4778078f2a588e95063209625484a472c291aefdcb1243926441c3089d99f9aec3373119d9efd42e501831d93f03cccd22dea41834f470a5666538f075af89e9d5f03586b7543a9a4b8a356c2f53fdb9ab02668c9230df35f25b61f75a707a152a0986e109a910b43e81639c8239a52f80ab588a82fa4c4115c38cc204cdb968060333b669dbaabcb2a84e062e64532fa4f70bfdc6decad5c1c19c6320b071e03601d5efb618c1417dc5b426ecef09df6e5d6309f7dde1c148436734bbef4c7a9cc8feacfa903a733336950ac433d198e51cae301d19000e1501158eaf837bad7ecfcff09acb45a3f78496d31a20946277e13f2fb929bc29ac441e0a014172b0d42ef3f5bdb84fbca07525a88b5d4fce160fe74e32ec42d55172c599efc53394b25e78afc8e5d9efb93daee9c6c843461a5e7f0c1a7999304ca3d71689535cd0385e3e2a10d5ecde08df2e9d4f329af45aa2994c306dba835b3f8fd14365e56f35969e2e27106984d513a553bc7e75cbc0fb2a4eee9d73f263b1becd336630a273501d5bc5a7923f5930723276e6f5de8f5f3d5d29216eb01a79ec45a841916660244f5c6814a7c06ec70cbe6cc885d950b40f5ee00620284676c9040564271c6c63dc8b07100350b8761f32f5261539e305e8d1367546df130ee92f7861026cc5636c437869b414141b5903a16aaf4d8d17854a79112bcb94d8ec9867093141fc8bcfb253b621c66a5cd574d27ee26348783336b52f52f9ec6ba9cfc37346f2a96ace2853288389a39f30a51eabc2ebbc6b4e7b6da035566898833d2c75e13e18a61edebe0bdee2db7b7625cb7b82cb546e5a9cef94f1ca39143aae729f4c13ae14683d59816d8ca4dd91a14b8b8f63dba2e06824cb60fc9ba10c61121fd1706f4fedff89af241c1ee249be46244a095ad10bb97759783f55e0fc6daaed4d056470b6877e8863b256bd51365191726e0f2835670600e98ca84314e9a0c8a669b2bfcad3bd1f51837b33da17e42b59230c84827d7e6860586194f959840a12e2cb64c1519730143f4dbff1532a0ec9d0073eec2133c1eeae5bd134da30e1b63a64c438923d588fccdf45d1cd83c6ba6124b9d8c1ba53692396000471b566f2fb2c9edf983a02692c2ceba77ae494ebd4bc065cd115e7fa75f831c7d1de9991b3a0902199548b128858bcc8dea6447f5a0c9adc725634e3719041338dff3b22ade57f7a8c756a0213505c808339c2d417a39e00929212403bd911d3ba86cea6648e2cf15c13aa665516c3a503f35c6f3139db826d610570da30594e521f8c654994414853b96f107b5aa887437e3124d5947f3a8bf04a5d10f3f4c78164413b96d9bc9a109c91dafe5c2e8c1a8d874fe1549900a86b6d1a99102600aaa35e43f7651adb6ad281da112466aead3fcc771a8811996865e4947254ae964c16539ae8abe9516d884d82250d3b13b712098f70c887cb99ec381b1398d265ba465535f0e73f80f5f117f7317d31c8716bb14da7700299c36a5e6309ab67f7f0ecc265707a96e06d95ac38f164ea9077b503973f2fb971a0fa2f0577319d65535eb3d1cbcbcabc48af54129d127c3afa1672deeaaebaeb4f001488e8e1e7d7891ddeacbdf2765446c792e714dd456c6e48297c7e368ebc18c0afdb1427b46cddc92d908d7b927070d17f0c397dd3b975a905436cd0ee66c644b536f8b3e95768a64e84d8bdd5387692c451ea9518f17b28c4989cb73bd19ab262f182c7eb5585b52ced79d0c784eef985efa50045feb9635611a7821f415afe830702ba1cc79c6bd858813f50b77cc37577d0a5b18269accc81bae0228367f9e119a24d5bb5f9fdc326bbc32e037b5ac5a9203f219182d792afb66bd612c5ff6613b4061e9195f3d1b996cb63f0c92bbfdc3a136d68960e849ce73b3bf343ad54a4c98e8451ad4e2701dcbe51edba2e83433ae993da22b54e5988fa0e28061014f6541779a30384a4d41f136f30c7d20dc9f87d7fc6c2d57cd5a6e9f3fd00ed521df42ad6d44fd3b58a82b4fcc9f476a98b53d06920b26441938a51bd21a3ed7b4f568b28a166cc87ad5c9fd6da0ff8a9d75cad4346eeaedfcaad32735fb7860d5103c8508b3d0cc2366c8ec4ebaf1f547277f982847703099d34955885dcf014706bc77501b5e6c4afde61beb19a07d3318c1afac66c043cfc7af129a8a92894d3b321441fef0901f2e73c196474906b1a3226653297596d7bf3abc5938e086858cb69bb37c609059c5d18a0212a432c6fee0fa86125defaf8b30831d5aaccb7c843c365e2aafdcc2580f67148548cee91db57c02df86fcaa367da04895f4eeae1c7f196e4acbac927c104c6e7e0f69e6e7627e735459e5bcbbd8c4114e22dbb14ff58e058ca3ece33a512ae9c05d50c9da6cca238bffee22b402770481cda26d0b880d5da70e39c8be54e5e1796687695489f2629e6ad12c2abd5490e0549701c34e338c23b7cc6193b571efab90220fff371251eb19147d3cd1a5d6382091d0d193a75969b0be790cf4ff148175deca5c250c44d2a19a4992251b6475a7c2115cbca4c913291d516e615635b0950a2db961117c90e79e2b1780dae7f0632842ffd02608057ebf385e718c873ebd57ebdcffe8363531b0ee94cddf9f997c4f7d193bd54bed9210d5f81c02fa08585b3b5c33f6462d96c3bf284d40e21fcb8fa9b41078b81bf09cfb2472f6da65a0df590f65a761e7dbf3b2cfa368c3a1ee29425d00716017edd0957af4351871ed4b9e9771f906d299abad0286b862f5f2e2d1ccdb2d1390819f120c18062998bc53dd568b477d9a08fa4fd54ac761ea23e235a1ecc2e6178decdf414c69a9b3f10e8ad7d2f7bca36a892e81dca3535dbb002daed6bc84fa0ee7a33bb7a24358dab4e44319bda86bfe7a5dc12e168bcc92a8f401201c50c6adbbfb87132d2d1aa2c4cce27ed90da1900857a4464369e785778b7434d9388c83450a6acbba620064102f7911c376f6e822f292cd635b2eac57fcd1222afadd8500a14f9b6a890dea1e3b322f3b3a1eb78e529d3c93543a8abbe04adb1699d108f31ec540e67c9e8902294c82868588f82be5848eed028ba32d42563907f28b4319c17d8937f58f88fff960af96fdb7c51c8334d3c614110dc9afd48b7aebf848b211dda50bcf37f79fa2cf37419c8878f835a11efa91d5a06f62f78b80ee176758a97ecabbc93805f4d41983b22579bb871793183c09efc3fe7ca8385396da4f2b8db7d857e8b0cfe631bac6807e568c1386f1f931e8762993d96ae33a4fb930713b12ee9bbce389575cd56752a80a75de1b2192a153e1fee6ced063373526cf54c3e1fb6595e5b730c15948f8d478a9ecdc5f712335540f973f464fa103821cf14c655d8317298a819c15da6ff840d4a4f0101c4e1cce82b84bf92c8fe0dac6b495fb0790b5e15be2e667033c3a59e86e629acfdfe9f374e30091f855e6ed785accea8ddff58a91dc7aea4c72c621209fa16e463fd640e5e9b04a6a307fbbabc20106c85647e198984602d99475fca1518201542f9038aff740cfe8674e292f61b96afeeb7a6c4f3fd0ab73ee67198ebd2fd203c0d884f05c320be33b01ec9ad758b08266490d294fd9ef09aa2db5bcbb65ded80230b21e6b096b794bbc1058bdf270f334dea52bf19e40bed7aac7594db35cfd3c29d907c4c47a462d31f22fad3764592594012851527580f99317d93dc6869d429f13df62b3159872cea12cd8e7a493a1a65fb077a750faf9a5c250110e057d66173681ab5181a55e6519697d1279422ec06c2c35336bc25b35fa033d41a6ce33422a802c05ce2e42cbe6946bade335700c9ddbcd8ef5eb1229fff524b4819b3ed5e33bd0a5ca0769f7e97d1976748ceaebbeb63ec0af81b7e21b3eb421335c0cf2a3fe9ff3b160cad5ab6cdc5508211c3e4ed8cf0ef5f1b94b85f0a6e086a6c878e54067453e7047638bd9cd5dab32b4ce7dafa71d219f2669c75ece0c1dfd37b3ab490e6c00ce86869941721aaf915a802075bdd073ccdbeb63bb2739f954e08631e848552a9aa7821dad276cbd495b43a2e79e33134e869b238d7afc74ce69e1cc2df20201845c36ccdfec395e1a39a1dde3647e25e77adf603254ceb21f74b2f749580d4c183a81bd64fedbea54c3224499e2599df46282df045cfc49e30192322c1cfb17e4ff8ebb13003e8b282141494d4035183539776ab7c23bdc2c2c544f262fa3539d055b13f319928094d989320a90db834a3c58953cc637ffeee65c76dc20435536548fdaaab37320d5950bec63060fc52bb63f7184bdfc5f30055d836c5843e984011cf1938ac13b2fb907002a40e2aca578bb112bd71b3cbe3a9bea5f77fb145e3b2abc773c93a5b2b2f73387e21dadb26666b20b39ca3cdda98426699afedb53cc949ca5c7d27975ea899ad346046326db8b389a2ad09ae1dd1bfbc25d201e30b7fa5ee871c35432b9ceb055b9e426bf33c5a8133c1ed18389df197af775ed2bdc4d815943ca74ff7bb2c2e669984e00ef4818eb33337688969e9300c7b2f8043e94072d2cc86d0317236862c5ebf2fcb86bde10d9cbaa60873897574ac0265834a9c67dcb3b42560c7967038860f669127fb089824f526db5bda20270841a7e95c16aeea74766e6beff5329a65bd0e69ef9f4e5a961a18d216a2ee9a50dc89f302ef6aa21e4d62261dc41cba39c45184108b635e8ce95a696e7aec8529472470ef086b9325f926ca7ed6b856a7ff07c150be7202884452a60b15614536e089a784dc93e9664107a229ead1f46e07c7473c9c530447b0d93a8077b56a088031e801b4d22a7a554dc88a8f697ea861062d9fa346416a2b3347b5888187224759706117698945f62f4eb64364ec77a830028220cabef5db1d3378be57183bf27e249e49b60392d78d34a7095de903ba02c46d0649c345deb631343ed94cab3aeb22137ee0335c0a4dc28d5aebdcd885fccb7d07697edae7407fd01c1108491438ea57517fd608b745c2898345d14222d79941b93ffc411d9b9d793536960b7ffb025f57dd2f4e1352d8862686928a9d68640126655a6063fcc40cb6d9420998df995da89bc75b73ef5ccc4acbae67b6b02200fbd9d288fabf535a9655dee560de4c7870135aa5d4c77d30a00a9cb46bd1546e1ea5a74e11bf2e1082e213baf04c18d57410684d305f8d32c73d4e622e91615abe92cdcd55a4fcbb49fe608e85ef94b12c2406b823dcaf8258676b734cc9241f6f7eb235247e45b3658c8cdcebe1a6b5a13d1de564b8af75494b4ceac482760df36e317f078563daaccceb8c49436996ea24107b670d904132753ed6b41cd0e73e7d4bdf1213544aa4511a3d06dd7d64a6f91312e28a6f8630e318ac419fcf9258cf15c8304c31633c81a15869123a63f02ac761b359b2e6bc5e4e04cf76db6c5558deb36112e5534b55483de7925d0a213899630a33c711017a494682e9c2094bd8906ad7450366eecf8d6b52f0ad02954a442ab959a3d27acbf73b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
