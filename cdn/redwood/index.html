<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83c53abd39b4d7baeebb4770068ea2c0c9388b566dc9b2da54efb17f448d4d3d5eaf5724724e471f3b4e13594d41d04448a0084075e0d384421e10c21a4ef3747beedb50859019c6bf5c48d26bd7b0867efdc61ce44412c5b90b1d31f537c6bc4a120795178c7c1a1e23a090fc7ea1eee32bfc487d4e43c0800d1a557028c209573d8d7c4f77da70d9f314df00d09d55882077c0d57198b3df6c22afdebb533783b27981a48f04bdc0324d85f2ed46b24c2492621eeb5234354b42fc1c669145b4da3443de04a0e7ced785d659333fe35e4106d82511384f9bd758ec768aa053bf08e670dd2c446e1ffc8897cd19bf0b63067efd87290932206d822ca3883354990ab50e63fc693edae4b26438cab08016a906a51d248375ede517de0d4f2c545068b7f2ab694e0e749fb6f0c253540959fadd84acb3f05983e2a7e12dba5acb02ca8f4989d4f0d2ad93b630f7683f7e1c97cea3ddb32105d677819b272c8f4c9e0cca8365cedbe6cce3539650b2831cd26ef966a47474fa7ded282388cc2f315485a30354238af1d620d1756f64a1765ba64a41579eb2475cb490b74a321e05e9253a3d79b714adb2235a9b512edebc4ec5554f5f8e595389b825443dbaccc2914e08ed02bf3206ebbcdbee3696eeeebbf61908d0b86c6ee0f0b9d73673a3bc52119fe2627484719a091a0198cfccabc8b600ad2eadedc24531f82669017af5d172f936c988a33772f013190e4cbb685a93633cfc42d2f3d430c7bb6ac869bb3c8fd6a420433ead4ac12e7ba610c7cc85518806db25f23c56469ffaac923858023dbe67f87ece506e273ddc09123b9cf0627023993090cb55d274b87963b2726bd24d143c85739ddd180f4bb79d1e448f7aece9c769cb1c0a3dbf3c0199c8fc09dda7a8c09100bf0b14d3eef1abbe23465f3d67ba469a6e7cbf853e6766638c32d3f174c80165489710d831ac95210dda31d38641d645031a2c2ec68565d6335d327ce37ee989c73d348f5e8712e5b15103ac9b01d6240e4a3c34898709310991ab113c70919b10d579a0af89893b3e569c3640c27c48e0722ee46037ee9f44b49a3b08bd73287ba12aa379c62f1382147582e1f35526f5f04a072f9305ee0a45c13b4171b3f2c9c8cbfed96817cb74264b289ad85d4b76d1b774dc936aa9a47cee135d3e3da3496b79f70beaafdaa5cf4f6f2d3faf691e2726032832fdc80310014ce6041e3dc9f6d18e26ed1709095820f69eaac3fecf97f7a5d9a6b83ab896d5291afa6fb2af5b950284ddec3e614c76d0f1c6abcd450fcef3f2aede6305f8b317de212b4bf9421ec4e444f5505669f1d1be487e1a9760bd88626bbeac885cce3444dd48812586b335f74265d08130d66fd37ca5ae72e3282c9a93082898f837ff72d1147f01603b7f9972bafdddc7c92662597eb3e3ecf6b4e231f49ca05fc0766d9983d523c759a7927f699ae31551d8f95f19f85c03a6876205ad91adf341a33a1ad26f0d50bbeb3485ee51dee3b396b2900c03318904eedb46c817a635f068511cc0946fba39d01333c1a0e2377b876a4244449fc3c25a9602f82e4c429ff8bd9f35f5338b40e466b545eaea3802ff119ec3cb5c14f87a78bc06366ed342d7ab981710a4e6f347664349a3d104ae7f2a3bd3559aaad0e4be0ba4c1f26a63e9e55f04cb37f1afefdfa126bc1d11d4c0f18d0fcc5e1af6c875b3c0342c44abd9d20e234e01ada6729f7cc2fdbaacb1227c99c2d9ffd7fc28d9ceab8a61688469ccc954983f8b84e1d1aa1b80107b95009cc044cb82a1aca1b12099396a482344bed81e4ac24a5ef8d8d01031ab29ac2e503076df13cbbd55e723a3c92d8f61ee468ac59fa308b96cafaf79d36391112844c5b986916fcf04962db8dfd4acc9bde8cca0be534bc4e9ca38412e67abde097a8b6f09f515e0a892890a804b956a5bffaf3747ae1e1a560fd3f3fec3ac8c3451bf1d6370ab40a4c39e96fb3694781208481c17688e99f519650b8c97d890bb74995160edd73f9291ef1bb2e8671a520efea73967028ff636ea29409d28f4bd942d515b1254c079c93ec3f57d78c001f68c8a166034552c892bfdefa9d4dc6d5ceb2360aed3118945e772273219206c70ea72bc5ed8575996ce8137e6b38f53a3338d72d04d255ccf0d04849ca7e822ee4e318da46734e106aee5ccece673f034b9e33e588f82c436f87ada4de8e58d24ef6bda8839dd6a8184453a5fc00ecbc0008b2644494db41c44a5b611e29041d7be22cbb0a6896018b0247d498549da7a4cce8dbba45f2b9a36acc21c7ecd7591a5f5836734fd8810d8b14c892612fbee769d378b7916ba7aa986d4a1baee01f5833fe2a0304805269506194a6c6ea7b4034c4d1e079098c2cc3c333fc8b5ff704495fadd5fb3a7c9e27ae9f5eb7504ec796a8f84a934c13a6324cf4dce488613e8598899730050893c678ca8e00a13a73fa89288b3094d6a84a3d7aab14c74228d673e7cdab967ce2de4cb96525110894c471222523ea4ad5461326ab6a0d90ab4f64b83614aeadbab5c3a40b2064346938ba96976ba399cbcede6dd3df18d0e6a823b83e2f8d8fffa188fbf02d8b9d5cd0b668d734b04e1d8f0a97e81b0ef833b4dc8d4418a411b9e4f21834ce84eb085ae8f5201a30952062f8852a5ef07bda7ca4861d06f9bc70a84966a295c68d2b51a8b1e4b3fb7506f1016eea9fc0d52b6cbfb12563079202f5ac9d80ec698efa57794f81f058dba9007e6602f32264fb0094d5f77d3490f9e6b2de65d6e924528ec6f9c04b71df848de5337a57a0881eae7ad08f4f289a1e25872ce1cd3543250ffa559643a993030a3af3fd03007687a0228a3f914478accef8781eeaf45ed0f67ded8a71e2a07403f4684f1dce0bdaa4fcf20c3fec50727afa76e13bfa46e2c62516fb830c5e827ceb727c090d7934b689d5b0340289db84b9b7a8c6e16aa7058a4de47ac3e4c8b96f44852ce15a1f00cbb1d0ea07c2fd6ce7af3e5ec04a327eb569ae72f72407395d4fa6a61dfe239000767ff8db1aa8350af11e18ed1425aff4f61d9854499b296caaabf46dc74ddf750c35fa894d091b3b59c33a14da5d558f9de7679fa78f97062be5b7bbe2f65c895ad873c7aa8b70820525d667921792bef29e8b33a12badd73bcd1a780d6172aead8de9f0dcb9c5ffcf0c70a44bb98e7f9c15bcb08452ca6a34c6866565a93ec081e2f57e2e44f8c179c8536534aa424d94524489dd9bd327c0fccd708361e3f1a05221cfa2904e127a65d3b2cfb29b62d1d7992b7a12fbce9a01e56adaabded1f2e1f3aac5a78b847224395c2571461ec39d795a8a6e06b59f8791f1846f3eef21b987e67a3a55e7ef35b30b6837c992a473bb341d88b2055f8c45cc43703fed6639e6029f3643ea657173ca7e5ed30fbc3580b613608147144a60dafee70b6215923c8270a8ea89b7b03cbe95ddcf81f8222088dd85f03ed03b29a4758a6a29970f9883b764a957da934125bbf81f951d0aba5563381c5b4d3ea1f98dc0a39f774603e9cc0876391c350ae966b566b6cbe55860c742cf8f59a6330491a4c3ed020bf00558bbe0430fef254714dee7b05c5ba4fb64d908f4f1039fc7ab6aa537bf54676cbc152bdde325483a0323971a6ba85d2826f65272825632291933cf3de9136563e178e557a305892edcaeb0f6756a12c7602f00c277d50cceb88c68d157ef4946123705dd2f41fd50bf5b2d1dd2deade2926da55774addaf2d7f58b62800390b8fc6f96c13bc4238a6c02cdd73ef840672ab6826eafb21da913923e2e19831fc2e8ff67f5572ed944db17df69fca94c9abc17368ec6e7f61859be65b366850ae66491f434364293894a8e6b7045e1c3c9ac642f6b2e243a3f50de68aa5c468bf99f33eef3a47cfe3f3ac75a9d4589a046e292176be548da0c6741771a6d9abf86f229cc6c05e213725c8f924c195afc292934cfb16cf044303000c2a02f36cf4630e04e3c01561234f85af2ad0878bbba557ab75e620b93c78ecca288aa6b6f7a2d70696a4c9e0326ee04595afc70c7d812cf1aa111a14c4a5d9c3265ae6473c49f69475156097d095014773d7adb3985bd9736014e655bda537bcc4b8892b33c4f626a34061239c591ca50acb045afbfa7e7c9c75ccd739d90b328f26fadda4b26aecc08f65ffe71555e2ceff1a795391a6dded5e9a096404344af74570b8bd53f377619b44890122edf94356d34493802545ef767b883f9d77c5f4ce7616cd0d3cebcbe70d070529089e2782c3963f6b8fccfc670269a89a07978654d656311a181ab768534166c3762295a6eff2742b24b291eb22f455b1a0b438d8ae6ba9b6f3fa4ac752bae6a1e521ee54f570724001a7eb6c89f7516891360e656d26ccb34f4608b0ad3078f50900034128194b37243dea4634ae8bb4628c675672f3cd593eea675928d82da1390dcfcf4f9385e9706e70ddbdbb7fa938e06328861a26d6b27329cd1478a01e450a15276c0d98fff276b939167dde4b619f5014990029dfe9ed6c816eade4bc59866914c263282f94d3123f852336619e9649157577eda83a955cde58ea36fc94ac89ea88070775d44390acf36bcc1e57332fc1d800f8d14218f17c2fc11ab7f09e3f435e2f7a862d6dad6e5af33641437ab59f646611741e8fd5730266a9630ad6cfbb0ce856564333ceef6a08e27bdf38b9698b0fd927262e79b99099647af004094bbeeadb289e35c2062fc7bc9dd5c436dad428b0425c1ec63bbb44c83f972f0944768b84cebbb4c554caca2f3c5a37cdc72a7b2e1c91a1d26fe588c024ea042c1ecad8a234013feba8531fa734a51f9534caf9b00dd3475eb6c2c8652a511019173472e32920cde4da2ed4957370e85d2c3ef3fd40403be0913fc49f8166bdeed1b0d38dde822fe324a05ccc6ce814acc8e686f620b9e34a4de1d2370d87f4aff544d479bdc1e9bffc90fe5fe2dd490874f38c812f97f68dbf16fcb6149e641400b054a7f9e6f22dab5cb841292d202d657d7d03451582b36b4bed1e62daec35efe4b871c7d93751561f8b3b4ef103ddfc74963cccf62e749705ec6490e0de7fed73ca56b439bb0d5203098bf89a6e7e71487ec81a70b403288a26be689445ccc3dc6b9d9aff0f461ad427482e74732e0206bc535d0c695c109a1074ce362871d5cbb7f6ad6c83fd08fb68327d2b96ebfdd3c2815e1c251dca2a80742f8d7b2cbe67ba339629e765b882c2f2a5fb713e0d5ec218c69783e68feab509e0083ea319fa7459acb4f8842a60f2bda18fa993e4c1f341f013f91d439de8ba2a566409dcf5a9354a4f27653483da48e834e9aac7750adefb5376f93f454ac8a8db2aee7cb84e56ab65dcdc16df49f4a6532b0051e0bcd80ced8017514123ad1f80d28f7dd611e50c7c3edf9e7c2a37226ee9c8e85cbfe5acf7da49b27d9039eedb5ee39441e87c797f314b240e2d4e1cd71029835f9a3046b63c27b268dd5e0a18fa3ed526c7111789fce93b53b0106426cb26d6e9fb6574040dcb402351da0ed23a0edb98ae2d07202e800dae72daa83ddd3de25ed917a25c211b4a19f6ac5ae7e6097788f69645632365c7adc13a72525a99d75a153b29d031be5dad7284054dcebf3aa7176485e1da4d67a85a247df404bc82e722db7e12a2927bb71b29777b541c8416e52a6ab37d57ae7fade4f0050867af283769db42b54003692694da26426b5b6effe1c4cac1c890ac9d06dfa38ebfc36f57612cb2f60674cc7cb91e1875a6b2a5ba957cec95338ba9df5ddb401322c92c1fff73d24df10f5507dc21cf5b657481decc512186f1faf08093dd32c715bd1dc2aff8ce74fcc2bda0c0218432e0d671b6e374893878179d92663a603a64f8e7608b1a70c380027fddf6f19aa7455945cc3af55438e402e249e93ed4b3a9533de0011718891a56b066aa14f5261119c666ff2f445975a9587c16b46ccc727564898c229f7e058bb3a45edba23e88859753033154f63026734489bfeeed02ec45a3d6417b6b8eded778f04399ce10fd78833fe1f2d9104d185e938a7cc25c3c76b80535597130bbdb41557e47fbc98a4e56884bc8e697b96ca4a1e7ca8a04310a06d5a2e19db3c7cf9824dad1a09cb7f081c77dc0df59f3fdf88be63b3f78f5b4ae4256ef4e0396c40ecf621dc86d3e9c9848938d5c2919cb75c1cd315885fae4be44c5c58051cc7470ac2d2a0c123e41fd1d8ebb1ac0658fa39349cfe45b225ae091c11c7f85ec6d375db7d9c54ece14dc10936ba6539a264d394abae4b9a189c6503cb7a61d216fbfc1773bc4acf9ee68d70c1714c5b4fb5666623947a67f6e6ab741257eee529514d1a2194b4ec0b9d784512cd47d34d73e88e5c9f207d4bc41f0dcfadb769a4db11737767aa3b3de0ca97c4b0fa34e73ba4a0aab0bacdbe5b0476cba8566385a4002d390073ee7940d95c132b75c2507c44f79298e1e1e7d1784e5ea3293a1d54590a2bf718868456f884d7c6c444d549b3afb37d0b32b12e3d93ab96e5b9e31dc74bb637a124c0f59d64b50fa12a7508c1c1fb39c55aa0d6d598b17cffceb36f7639a3583830a0ab23c92ca93187c11cdfcd1474ea5261b79c04e5cb1acd3c30d0622732685be9b64e59607257429960e1debfe8806d2547ea5b30beff1f456399694f5ee9b6104d37d70a3d3ec22b044dd00f84a144e7efa2b5be353e820b2fec742cd7a1b76798fa5839fa03b6e4f11b94a5551361cff29427cb32c4ec7efb0946c954658e16bcd656e10179fc4f47ec1882493ddf4f5adb8dea8f07e3f451d2620d9a498f93d530ee61417f15967dda4301c46ad9435862825559e0aa054a43c9eae8882a40d7fae7b0f7b2912dda260a51a338542a62a812267e703f6a3ed0110f580e6585d717092734b09e0342075c3ef8b59926af66016f412ff090fd2ca11706253ae1ef17ecd1a025402b052f43b40f86c1a382a6a4a2ca7608eb888855633e510ccb22c73d15e1536a1b0da0697f0147a726d75da584dd4b03e4418e8300310134a2486a77eda61f538b951457ac4b121834d37048c452f92a3ac9d431d5bbd4f8cff78ae465e8fcb609a897447fc218d794e72a077619b29be042a337f3d74bc511227e94e022f312de90f66005510ca5ff0d1f0491d26e93f820cdecf3183a488f50dddbb3a2024891e78d4644f26b9c03505eec4f480d67405b49c7deb2a5605c9639c6959865b169a86783f75b3fbf989bd2a4f7f1c0cfbb23353cafbbb2f12c85955e186dddc0648e8cb0442d737698a3b7c1bafe5d1be9dadb910a8b3eddf0be54ac228cbf5651cc5480615f52942446edff782c67027afe53cd23a97fc3ab5c1c917d740fdd73bad899a412eb3ff63f8e6d7bc37e8aee3de7fd3d63ea40a5bf904f9d7304f34e6e6abca255054f8510519f0c810bd959cec95334331a209ffd72c2bac9ccb005088ff4a5e5b744dc553f6ef1dc1d5a43337d697d35634b3c4ed293d7436190dd98c7d61caf2ab9258355be6ca18635042e47b4aa5ade314702a62a9d84fa9ca2699d5081fab69922244979588e40d03ed786f592a16b3ef50bd0dc3742b39d203eb5f159eeadfddd094fd82ad90fefbb66378ab44573fc4cd5fa891cb87ab2bda4efb65ab6819a6487d90285b0c37270bee1845e67399fb8853f20cd2fedf91dbf13594039d13691f9f18ece28094d7299f1348cd38d20fdf34880a5862d611e15ea99e444c3c2221c32f6b838fd3c5547a01a3cbd40ae28b3a33a95b4fc4a5d9e2316767cd168af76b16e6fe78eb5c225cbf125fb9fbe19ec09522d2f4e216a13d1cf438d7df4f4e5bc767aa175a1564c94ab982a003deb9e9f9edef5f5ad564cecf968c945eb61ca7d8970b859eaa39517f3e04d470ff583007e49f5cbc01c8061019f2a7b833d33a55c145f2d3870cd04c4b794cffcf376992c71c1853a0937c96f5fcbcef40a8f6f9585e5e42d42a4118e573728f13c51953d87db1a71d04965d81a7afcfe9604a68030c8ed352c177d7d88658fb1ce5558a148588af6a224cb452d02a9261b2111d5729a9f113f080bdfe6074ebb8d43e1b8f2db9440f24953c0aa2e50f89c73a1a6f6935f486e2259958a97c57702a61c380672e026171dfbc553ca8e201e65748b37701fcbbe9b6c59fe97f9eefffb7e319561b7a9cd165a412f077711826110cf95d44567c17dd8a3c6d3ee874aaa1c680e75f545d80da6dc599fab9614917188ed6c11bc5c842251abd855d5ff7e88d042c86df5e36cefa5b954497b03615238e00f8a2a75816647c8056bfe2e5f9d923c99206a657b932691c119681774d49c62915049e00048cc44e318703a6297fe04c9adc1ad0462b032fbf9e064bc5d95e8d465d614a8ae70a65c3ecd57666824c0f044f00f407879d04c065e9d1767da02d0051247c04df0602182dc7331d9917d76a4071d741a24d7a307dbbc0ea023a28cc7ddaebfd5cc23f19dd5bd4dcf8a6e658f47588bdfc09d6caaef7a1cb50a36e8d2c6db80b88f312f95824fe00e7d78507e35fbe25e14e71712db46670f4abac947bfed320551254e645c757ee34c35087f48ea522e903dcce6882149a5741251c0d0fe63a0fea687b40ce64e56b61197d41512dd3bd0ab25751c5f9b5f77a78e68113c391d4feb597ca6e7d86319198f3b16629f39e9c691cfc7767a2fcfb4e8fbd400024b5d89a6caa06fd645fb9895b043829144a5dfa603ccaca111d8bc5fc46dac0614d8daebdf8d9b2ee68ffe5881d1693c3b4f96bd4d4c65587c3c0169ce56a2d6cd16075cf879fa19a67c4a4478a1fa454f47caf157e79b867554cd1ae459bb38909b86ab96def4dc23d88da5efc689b6206b7b8a6f69975835b6254a5c7f05784d5b2e554e97cb45d2c9139f022a33f781edcedc5efadd8e5ad81d40abc4d850c2c8112853185a25a128400301c78adaecc47a899a4d78610f233fa4d1319762c9bd8a9fafbed71fcbab1782de74e5f4463e652c1fb1e55618e0a5111bec789112fa2b277d5cfd996cdb11b920337642b63e07830815863ca1c00bdba9ff6ffb24f0919d28f724d43de658a66cee7b92020c0d6517841ec0a09392dc2d098a1029434de9934b4ae5e9a802dad81ae38ed2d452ce445059b440d3a87bb544c050220b7fcd20b3af1d6e16b1ea9e988ba26579b281d62588f06e834357cdea106e4e00b1d95ceb3d4d5751fddd5043678ab04f7c64d1779653ae994e275bb0a874d7479da7c4a98cef9450df27e5a4ed2b394ab0da1e2d3eb69271a821bbf154545995b02b3f69f997645c640749679eea798eef04c8ac4cd2c1eba18687d00d941b74e367d0d33522a6b97b68f5501f7e797a34c88e3a1b3b1ac3a1445347ed46b4f75b547b26dc0dc4442ab5a8952bb22f1c838981fe211d9d000e4409d2c68aa2f09079d3a413ebdbedc31322f43d02f2953efd72ef6992c5ff8d81f3bcca3dbb8cfc268ebfd283e5f4f7405b54a0604f80bf9d472ab9e1eae820b7b881f64a9da894b49ad5491da327db5cc41ec84352a44942a5a5ac2a4d5240373c0e8e21037ee976e70a6b0b4f1a46d2a5d3e8982cc17c9c5b46dcee713f925435d731b2dece58f1785c85bdbe20d855fd21c1fd3bf6782cc578488931451aab604fd9d8046be3f9d66bcdf886f488b4c5ae38540cf87e4c546770d3f3f5da10025d91ec0fa0b9da5a5012d8550f5019cae49de7d72a5471b795cfd6c4c2e64b7ec1059709e6b419a50ce93cc19028f4087b0f0af43994e8772ef0776db8fa8e259cb1a6f22aaf3b26f0851939afeb414bde5aca98b75e2cedc56e34d1329604c878820ec71e4f710636619c223a4e4c1bf96504ad301763c673baf7d5d6536aaa009c702d2c51c174fdb98ab59ee2ff467cd8fcfd6bdae7095f111d77a3f2006f80782623861d69ca5ba8b8905b2f6a4a69a0353fe38fce4235c4d5a9a9848ee13782d1e4a9f3975492e4756627f3e3c8e757681cbb5dc13b64af55b0a27c64247bc67501d377714b644fb3e36501d05ba0b09d2b88e01c72d632dccec978db755df65e34cc6bfab5c558b581ae849eb50bb1ccb3cd415525fc0b821f10dc09e300ed93370c94b9a939a7f96f0a7063535c3e155d8a23c448ac6acef61a13006a0d7113e014876593f4b6584adf9cf2ed43069dd77c73e0bfb1d8d8c79ef5c0007c85ca7288d968056788b48824c63a937b404eb18688b7220fecffda91838d043c834db17bf1daa14bd4ecb10ce7a2ce7eb7fb1443aa3bc3c0a60644bba6692286d1e7e79de41ee2cfc20f1a3dd4a8a01b64b920dac6e411c1555fe694ba0b3dfeabe13b82cd6fb9e791e4f298598ebfd24cbccd355eff03e4aecdd3996ab9d902dab469c364a7a001cdea1c4278e31bed1968acf63fd2637cfc60003a443854347358be6ebf85be30c8618d038ffa2a1fec51bfe80ff8d5abb46e83068ccbe8cde149f46e3405e67076365f6bc45066ef67de37f29778a88d842b2680e23bc967c7553abdd59505221db8c54ff6bc9b74abcbdd85390f4f92565d1cc93c2606964515ae25902760100ecd93341e4b8ae033e813334dded7de157b4f0ce733f7186a5fbdae15be01fbd2419c669f4e792cca246d9c719d406311428a8407e1ba1da91c5378a77fa4156acfafa0b93214a365bb78b653c8920713037e93c2571373089b7246b5f15ba6d7741655d5df63d7515144c0a8c23312b7941f7d650321f1826a3255e7edef5de55c6eff1ded56589505eb93a10ed1531d33faf8ba531e34a8c8a2b184794c995740a5532f443f016c2aaa711610aca5bc8b66e2826e67029f1172b75a995ccde72fb8f93c86597c7645b27267721ca2928200a6f890438a4e0501c5989a8a64aef51b18ab26e952eab526191b84475b4903e7d7d592f787823ed1bf8a4a7428a11e1d697111ff501a0890c84f886c1346f7f65058b9b33ae70f54524f3fb782ade22496621a719a28bd6b5d0185981c8feb1d721ca884adde1865472a7dc0df7b4b3dd32fe326e2d424f4e5e131c5ef0a953289208aa9494f7ce8d1efe0e673c65b74191e5ce9fbd09a57d43be927df5c4bcf7edf18a11995a62cfdfc6cf23340a52ccff306beaed3a08aa84f3b36c2b631ff906ce776ee9027f23ebd1e1bd1994d16fc81219a4093b029a9d2a19ca17d73b8e05cd0c1877c1f93b320ac38524f700ee98cfcb15a4aac09f5df16e8f42d88b8c4915bcc36ab8bfac6d37c404b370a05d7b2bce61bf1aa2398b84ca4bd82fc583b2bc9968ebb9144ca56ae24723a3d440d745f393affab2a8b91dc693a14d0274421a210a0b9011ece021a1e75b123af515b81c1883b761fa3bd3e20ce2f6befe9b89a89f10ab197289f7522dce7fcafa7cd88da1d9a97777f681760209d4dda8cde518249ee89f27947e5b5f64f42ea94f4b1524f9762c7e3832f689ac43fea8b7bcc613752eefa1ddb646f08a192e91b31d0b4f30977baabcfc9b334ac19c1a881a6834c3115605791594d6598e943b75bef7b63d5a796800a4b17aa1d82c3fb458cc66b80ddb6a6244b5b1bd0ab35c5c4f4a5c4545174e1625c7b3689826ece864918f7b231c94c293672d0af095378cb7542ad366d91c6a3a7a4f90849cb13698a8781dc37e67f94baa2b4f7168d4d9971d663d5d2f3067932d8dd91827fe1049d6d83613da053c8e5e8622ca49d1f5de1548af84be23e961d6cf6a934342c11f98451bb64a8f3ccdb19faf92bb6b6b53ade3f013452506a7cf196f8642dec09a6e3774f04893ec3c312af5af38acc233bf2cbf3a45b9673f60218a4e6631abf4fd64074cb07a72c7dd068f37eff0ec2007f48ece455a10a09402e91f71ff9e80925afa9f37fc518b5c4c9ce1426a63df0b436c0accf185ae4460d77cfa516500fd29ce4d8ebe318dda32968f591b29b0c4ad4317e55e085015eba37480f75f595dac01bf879f41770a59992a5b9a7fea12f6b172e252ee532278fc058241cc173578cddbb2907dcf113d461a0471e7d8bab28f260a1073515742eb6e0c421b0870d2a67ab196cc2091d2dd441329231f0adc8c08809e42df4454a7098d55fa1ca9799925638a2edeb4fc65465645911e4154dd55ce69599509fdb0fbdd9fff798784df7121aa097a525fcac5ff41ff02e1be0158c4d86d1c24a4174fc1fc922cdcc5eea3d10325dafaaea7df53ac69882e5b606d37b0b0f721d88e013bd1b926cfdd6b8aaff181b3865d31e46c0c8155578cfbb8799c62350bc3c40bc548cbc57be3ad852e9068beea0e022736cb33585a7668dfb96420e8f10e19302f6c7fa8d2c098f234ab5a7afd9b4b9469f08526c7bcacccfb775382722b50807b967b30eb8c5bb714dbe65db7a6fc7ab0c23550f89eadb3d3064814d1ab000b1952c7e9a5c8d4fa9c1644e2788e272ee65bd82f726c392115e80bbbc8f943534f7d79c68f5041d936094520c05ee9d5123a447e5031c648e3ece4cc3c123a73f00000a1465fc724b6d5fc5be1d92f1e942c5c8c7049e66d7d64dd65da68b51f34acba053f409a5d5d03f34ce3e5762aac5ffc9c07a733752106e32d76ac534332e25b441c68d4d9590e1bac7fdad8ab8c38af7fae877f0dcaba5f08829015a51f6cec4605eaaf53bbe528bbc7d64aff3f777998071833fd56ef7cdada1d02f514fe4f3898abfd42d1a859a44b446fbc08c4e2800f17e49419855f394ba64d0fe17a7be9ed8eaada7859d1a07bf08f9d3a106d98a22a2fd2495df41898b85761690562143a08ad8672d5f0e988b46e98d9bc5c5f98145446a3903026b0cb41c49e908b6f75ececee80e371266d47c5e9d2387e905418016143439776c8f48122cc927ea2ca3a42633f1342ec6af16734b2d819a245b34df3b82a397ed36eeae61817cedbbe617e5d3881eeb15db259b4212f24e83afeda84820048252f38c41bcb95b941e530c398d66c5db8096712fba497c89b9b9f1fb1906a14756b1b0bdaa155c43c288cecbf93e3e4bdaa3c058da43d2a7fc2c25cf23a4ec1109227bc7b533f91e0a6ca9d2a53182609d37f7ae88ca0596fce3bdc42cdd2c3ce6b6e63fd084b50a6a60ffedcaec6a8bea9885e6ebfc1d74cd84445b1966ae39ef8675631d90b26367cbcdf75a8159bbbfb25338f3707b6b2ea7f829a740215020dfc1bd6c842d71cf635c18e630c5f73aaca767664e6432fadebfe5f29b313dff33ffdff3c0a29264663b242524793a13e78d5d4e67a01b37db82618b977fe60a0735a19af1158e46f6c49ce237478682bb92d0c0c92b0b2c4c5112d0e939ebf60f8e569ac2d4c77b6503aac897012f96863d5e941bcd0b5477d69f37e09df43821a732b44677c8352629166f5f8530ba8f79461e830396510d155c69548b6a8fc27a77cf6210b75bf6c17cbadd834a8bb7d3edfc09230ad68519f7da41fe7ac7a55de52cf68a8eaf519ed9a95e657c1ea8d3d14dfd99ba083f0b3c78d9bfb0e81e0bb2496d5e0346d0e0446d79d35a2197fa5cc3929ab76b6e5086e60bed1ba872e8b5ad2b23d4f3e3492bc9bb292ff0f17821380d6df700b828a2a88197ce78c9bad315d94662990cd19c9fc70ca0abe5b4cde6b809c53b12bcf701f30c9d779edb034967808a5e63daa25e1a10715d3693edd10906795493c9dc75ef769947b623b72050694c9e4eabaacaaa9b90cadb0d3e8ea78699e7b38387a319eec937597c9834a80b58dfa81300a177a550ad8a878c645a6f5fea171dda560e5572d73445dda89fbf822b13e9251883fc18e69a6509e43f615509ac931016af2866d058f25dae180fea985f077856fecb4018753d34aa3c8f6b9eba45b64212b9d4fb99b7cc874e30df9b1ac3d51c2d7f3209a21436cb8fc5eecaa30a7829598d5f7d13b2f9c4dbb395910e06c8b91249759635f90e0cd63afad4cfa19e935823b5cce00edb682cfc6def714184f1bd90d9a484339867c512495b3727cc43b0d6568431ef37dcbdc6b7801c1c8f570e5f376971acfbafbf497936eec4fc39e6fbdd04009124a654a59fc1a036a36f144390282cb224b75acee3fec34526d92d922accf2cc170eee85238103535d5c21370ffe2ba6af26997814475392dd0478b3692e093c8a5c998bbd1d3cd2bd3f7af6ae017cb553cd4a97f7e2c2eae9c52d6620894af73d521882a9175e39215bf4e0920a1f618da19de60b94f8ebece452374d4a34310c688e5c0499da3b114d6043bcb09979d52e2b06aa35120de5aca605dfc350b3e305bd9005c193b1ff13d7910f7b45ead7a2227f653751f5fa21aa48ed48cb0e6b70ca8ecf0906ebcec9899835f12ef03b1089647fce6c090b7601852daa8c91ea5d04635e56bc84d3475325e9868ab48d030566f3005278d0e5954174b94f15695724ba1df82210c1428e637e4beb0852a827b4d84b568a6a3ccc631d2807474063c028d050ce4eb8c0df4fee300dec2b6b1cedc7a98960a40d525b61efecd735ca6121f28414c2661dc518946ec19642c511f643ebaf5d7f32124304d9ba68f84eaebb69821187fa7e36dd7fcadadb62785bf649dcd08de0a7004ae49b133db1b133de34e45022f1e5a63a38b8bcd83407b0f42df0d448a2183b59c7fa8df88c6ac83e30bff97b3984581cb62843ad04e80219ab479712add54be0ef2fab0e59a4a0a1c9faf810369c85df96f4dd6cb7741239731366ebc25bfb70e575a8e519e8afe2c816a046d6492fc70bcb4e5cdb1ee5ea96ec85a41b0da02e3bf71327caf1923ac6205e7bf6d19a03523532c9205e09221145b7c1de28240ffed7f144feafa278ce0e4b88e788c15555e099f5f35dd49a4f207729a5b3ffd115ecb6781a1cf2ef7c712ef38c0cf819a09871530a2b03b9fd92007349247f0e1a886fe659eab315e4fae13888d9b7ba359b518dc88eb98df2bb83f3ff88eea920c03849002b2071658f32a3f9619a1596c2178175616dfa9a49afd8a0ad8e50616065f7bbae9564b3c1509a6756f429b36249514cec28e0454c229c452f1abde1b80e0f70d0f969947324acb28428e990098820bfc248d5413e395ad328c3b2099ab7989c918e5bc6079362461f973c1cd01fa003139cb424e7c07262e8491466993e3f076f86ae75ff5c0675466902d4db9deef78f0195f0b6a49c39ab012ec4c834387634128f811b84bfa018957ea82c3bc6a22734ed1744f44f3c6c4f4711c030fe02c0894557598662b1ce0364c5465c92f8a0104b8c6af4d048ead71e900326182fbb8d61432a2fff6ac09ca442c0f2e7fe74335b54ed7899d3b5d5cd4fde743f6c613a7af55bcd4085749960148fa33d244040b122be87812ee02017ffac12ca1bbb5bbe5f00c860824d1e3de3bf14aeb24b585b7ceb49e0871674744d32cd682f2958195a1f658cc91374bd97a55935bde3a65b5a7e76a88a9585ebeb2fa676394f8a91393fff665b730fe2e74352fce19679d7354498248e94859e9257b63224661b4eb5cf7e76259f326a33abe2dc64f0392f9301264df50a6a848cd8de34315740a2399870a0a56c5f03166549d283c62fab242209d3aa3cc9c257536f4350525ceb318fb630f2ca0671e24880a1e2ce1c6af76bec125acf481dbb553aa29deedc0b171cca6cb33364cc78d1e084c7eb6372be33566f32203c76658fd377443e0bd4c632cdf7c353c65c541516b35f4d887310e88d1c2371d8d7fe8ae5d9956f55fd44a104bd7353d1825db6be9f0b1e3d3680c752094840fe63d862415fe32e22c75157a82a88725a3ba1fb491ac576036471ba647e3d1c041abe12b2eafa59b4c7dfe4e02fb75f0f2061ac0a5fff627eb70977dd89af963a41f079428963c08af9461c6c7fde3695ecc257bd5b4fe37afc2ee586aee99d3ee0a89850e532f0fc7554751a94a64abfc5210ed7b0d25359dd9c54db27e93cb1f23e78c08020627fb9155c970bc0d14315f1804d7630aa6363bcee293ea9befd20e57aa497f8835ed752834aaa2f56ca82aa1fd3f5105088217090b9655b95e01258bfa6ac7d5c530b6d7a689fc6decb5eb3df2537229633829f452a3fd58a9caa63911bcf6efad3674ec1997413b0d44246c3317a02c7dc0bf643f01f4a163f3ae61b24cf2d62f6f4c9c3f4c3fe5e3088ae656a12f56c92354d049df3cda9ec6172f700204e6ee221ddb7eedc8a7e6887517bde742d1a4945ba015618e9a97ae8631903a19e9840fd417fd794f4d77e3770a43afaabde2017a105d475b4baefcdd90e0669153c1556e995578d2246826f7def3853c9ce63aa9d04e40e6457523c0925f3f13f18e9126b7bf54ce5d7cc45cf9e9a0d36416497a4e692798c1c8cff1de50f08025622526c97ca064bfeac8ebb2e8c5b49fb5273e472296b23b9189c111c037917e1a874bac32a83826e85f54d96f642a0eb64875b98cae6074e246b54761117797a0a1a0fd26354c5b62d1d7a8c580a34f889346cfa1ca4b40e2d9564586cfa2ec8119414a1b2290bf5b9a510a801de5b00e5e28d67c211cded8e154e41523bba2de926581538c83cd439b1a839939f7f3b492ad000f890486a249767f08a8989b1ac72df97a6cb7ec2dd244c8e620375b499be42acf66ba2537fb6e0c3ed12696fa28d8dc1400452e235f9a7e49f31e4da6624a22672fe494d4bcd5f36be4740a4aad17df306534178001059d13940d6c99611a70f79491fd995759802249b82cddedc9bfbc2a85cacff34473f446dbf751dff12e4a19718a8bbdf3453789bd7d318ead3c525b567e702afe7d9ba083be49d7c12ce29311c8fedec62b9a184f7fdf8dbafafa49788a47c603e0fc9d66a78623a690a30890c39bf2805f51cccf86e08d67052294e0c6338a7e85caa18cac34ee1328b4c65b9f9f544122b11bfac12dd614b939080dd68f8415e4a55cdca9ac8b62bab1679e8bc07a7b4fc18d67b2f0a5e5a4dc03ea09c40cfa63fa322d913d8f95d74f81766d665df736be413beb1f6143c6cff08f1fa5b518f7c9ed8d60ded901d58205db266c41b292cb03f8931169a9d0e517dff1640ac2b43f0e37efc9c500b7f61affab1a8d514dfa5009e369612101048ff25520602e6f01e1985b9b203d0f73052ee460567cb4c5822d896a107be51d34ea6f4e04453d943f2bb662ff54263b4878a74f96b03f1ca7ef7a55e1b9c600e7d4fc55ba133d7bb36a371e81d3481697171b6470978b52fcac9f2b2b0ad42312687ade9c42440fc50d18eb64eae9584fd30d2885b4e70ce7e574b822f035d916fdc010067a40d133e1e03f1a7c50fcaeac6f031958413a640dbbf2e0d2209c2148bcdff68c1307bcde3e21c38ea10a636dd83b79db1b3ba20b6e5d4051aa2e16d9bab378e87766d5d2f26c78cdf8c477214d708f722d5ca1068e770484e87b00d1ffedc2d1031810f9812dd283eccfe79844e2fc7c22677277c559d8ada43575ed7e972e4cca9098178c2dfaf8e9dc13c896cfb3789897f22d5372897e5f7d60dde126dab7a3cdeb196e03b0eee153d3598878cf06873381428e6e7aa07852772441430a497a3594a2d0ad15440cb089a71095b5465526f0825337d0743ab57ec5c20f4c15ae0ff3cd1e774ca53b816cacecf8b74f4a7e78974c8aa1f8ab28a7a064ee0eae89d228e6a56d6f0be13e8dc8d434c70b1d5d82ecd1644f270e543ed006636caf4e3d8e83dadfc32e449c011bea618daaaf5529fd55b7a576423c1b1cbd3ef10dcbe29766d1f4ecc6052be0bf69ef87764ab2510414d2ef5bbfc214e919e48391c37bcfecb9f5d5fc8187fe525b95f2e685d773c9f015697ed0066edd2a83c2d635666504947981ba16bfdd7819b74806cf2c0cb63f8421c29ba089c31f459b2c8f5f340854298b4be66f35e478b81c97a029504a2994318133870d7b6230081a1d6f147e094ab33ec016d37300bed8912275295408b2ecf56b43c53fdf289529cf26653a3f499751877da542e8233f6ec61af58b2c0d91d1657171ad295153852558683389f7375e738fe1de7d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
