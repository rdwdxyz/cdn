<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c450b8ab5f072a15dc47da58676bf976c53b1e78f18fc857b6acc4de14864256d81dc4a2cc9be6c753264567eb3f7428706f3f4313064f1b253942371295551a3f76c395cfacbe2378dcfcc7e5c48f7078c2e83a69263fa81a683bfc609a973914fadd80f74ed0b9f192088909c869187eba5bc03cacbb0648763aebe5515c95b98c68c85e58532cc58088c0403fee3b1e2bac227de0aa41746beccc8d6e9bf245a67087d51e69af88050fd0767bfe4a13cd6a5a0b5740a7c404e3bb2d7015dfd29d3b7b3049ecbda6f137ba8a66fe1c6101fd99c55e60f53250d8b1d641c6bcbfbc91e3d6753e0707a45b444dcf380d7c549187684480ebba022699cc9553ff178e2222b1771b8d3f664042ec41329243e0b215038b72be01ba74a1bcdb40dd48adb08f95dfc6bba49119de11694c440c379a541468379c66999e820a4a8dbea649a11941a8fcec46fc2a7ed27e2576db2847605eaac3de6c8b416a79f3bb1d6691eda442bbc4822088caaee7dc3109195956a6e6849c6191c0df6598caca20df87f510bd379b81f515a75ba90638930474fb1fd65705bba562809c69b62cd8c556a7c183a00b2fb09677017431d56dd98287598365caeb26b2d7762c6580476dee52b5e27d3ae9488856c921db3f4c8ac6956b6a9fa1b6e17f9af1dbb318a4216f25f3d74e134696b5161d9f46b00a9a44cbdb613bc0bf9661c26e96dd9dd9377e9bcece1d1d54f1d692db7ea768dd921545dcc3c981acecdf25ded0779217f78dc35d2e206720cd437efba3aa2562c43a50c6a2aa8e811c9b48dae1f9ed30c4274791c1b57a2c7c3bed936a38fbaa625756ce6cbf714cd5b4a211fe0c1259e2775256dc263b59cd2f5f12018070d17852221e9b874afad995eb1c811ebb25238a6c67d92e8ae5811efe60c22e249adeb3c1f77bdcbe782e2576fa13fc43c3f37d0944d1c20830bb68b0b58fa629ef1c0d9a15c0b27931e89ab478b6ba66e545502d7925c4f9d92eb3a2a21a601bf0b80644ed254dd6f09d2eb73eda16fc2f95eaba4153f2a6ec3cf34c98fdbe682ca318fd9c8997ee4158bb63b0e871c973646b12ff1ed2234dcf82fbbc09085e48407b6683aca450e9ca0879a01a79cb6a40d0918b74f22e7b1021bfee1d95c560182c198f6cf4c237db4725629f544c635eef88372fb371e6379febf80886da31064418de029a449d1afba6fee4a7964984aec78fc52b5ba10041e692b2313d2b08a208d03c6d959b51599d560bfa457d69bdbfb778229b42beda421960e57c98f31366f06bc447451fcb7e267052a0fce75a476f0309dcd61a7d23b1c63191a90f50dfd1aa39eb2638477387630d27b975dfc4dacbae3dffa7af8e1c83b0a61f39fcca9854a696fe87ac788a01a4aabd7c1e81a25e4ee22301e2b3db288cf71a29fde59db1b3c78bdd6767bb5ef63d7c00700fa85e69ae407eea619e94365c765fcf6a3b9dede3a9eebd621d1a17c40ecdf9076612b809b5ce9df27d3af0c2b2f15df8a05c3cea2805c672de608286f4f2f4a484654d85733296e624bdd0fb5388c17878d1227fad870e83a6c320f7eed2837a225cbf7854d80a5caf84706f384f0b1121ae7c3e81b26f17dfcf3743f18191e9dd97622c79c924db64db41ada4d20876fc9b0e4a5b17ce4ceab1a398ffbe488a321590edcc14e7d28ec31590c1c7d50904985361b979d6362377c9ecd6aed7d6f286db185ab1e38baaa37bfca0aa954be829a31758aef300ce54f9760eb2cf5691d02011414aa699abbe6008dbdf3851dfcdc40918cdd6d7eb26d9cd485c41f1631108db21c449536083064fffabf62c626d0777bd0efd3e8ec9970309b34a911d446bec29e9fb0337bef2124c137a20e187b65075012a197532a3a42a91a2bce2d316f5f10b38e191775bb9f9df9f2d21cd404e1bfe762fe962733df558b42ee79378e3fab2036f8754b2429bdf16fff49c978ae32c6be029ac6b3a7f717e387068724b5680a5ecb9aa947a93592d0ba6b19cf12403447c9585015527607ea99b834668f548cbc99c48b9b4c8a5abbaa438cd48fb6bc976d84416082edd5bdc81488f622cf3a061e394d001ad70a7e253a4f78e5afd31fd481eb85da8995f47be3f4d3646c82d8def4edc19613b368c19753cbbc76cb28e65f18288c179b90e29fc953da699513721826ffefa0f37ba484e9331dfb5d1a3979fb01669322644dcfafa1f3f064230f86ee0610608b0dce1254f9bf7b5d6896bc89064860e566777dab5075fbee868048c4664bdef1edfd82050e597a5604e68937d0e170a602e0f2f21121a89e8fef250c7c32bb8c6aa2419c2b1746936d251e358f3f6d5506f56c9b7a10f539ae280876a2e33dc4265e1d93763866cb344b5b05b1a244a3dda9a0c441bd91a8013f7bfc98200e11e1f990388a925ca827dc6d0f4baad7cc9617801f88d20136433351cf630dcaf3356677345508b3f91660c98f2250df4c2b9a1a2e17053463011a8d2f57a85cdb50b2e7fb64b9626b54d7f646b612efd56bea9d2f4489d1b002539dbd1c1d9daca16ecce123fe5b3f56625b73c0c52e9d62547431a584f5109b7aae46ae5494719b4264c0cae4a0c811aef68014d3d4a5a48e681207c7d96358e861802920f3f2fbe4cf41f08c72407f700d853c9635160ef59b578f5b67b8d83e290985cd391664d116d4b2c0ba2100a4466ef44cb8ad4e345a473f2229338b6c8a8504478ff9bb3f8f83351b6d46c754d82aa328d8fb12369e7560375a03ac558569cc4525e8ead86aa749fdf32239dba0e5ca2443726bf6b7691331e59e88ef6c0c7ca836b775d0d2f5525eca3f0f8765c8f6a1ebcd2e82248c72649e77dd3d706f96cb00f63aa4f2d0f5e1da28eb701a28d44f13d679da900ec098ec3f1a3ab385c22a7068a085dbc96166a15a1cf21b488b7f4e8a9b07e893dd52de36dc9e09940615a955711669f4ccbb45548eb98d50842b7cfcf56cff81a81d3a444e10993a445b3a4bb36387a26c1bc896f9e9ed36e599c286619d44bf15e275ae14056ee3a2338fcd9239ad39d8ca9df2c3fd2be17b8c473c059d9c230b642352c6a30b1df81c44ddfc80a0ba6506b1f20186d7700f2d4098fbbd2b38a44d8e5af123e63314017ba2061acc9b8e3fb05dad638e28d2f5b2e2619a43a787fc0ba106cc6a912d4d9fa9057c5401ba624c964eeb91a24ca38e2e2fbaf2808258282db2da124806a665c5ddbd7088dcb281d99d0e839869976a0c34d6a6b1f342223827e063f49c9ef0cce1d859d7a88b1dc66b21425699150ebf23b4cd9173ce2c6fb5297befb2b745fdac489c4540a708438a19f595423716bac64b5cfd975aa0c12dded44b8bb7f493fa61e9d8b0d79cc359c46fc1ebe2ef88a95b9d50789711dfa0dfdb91fc89eab6496cdca5182447c87a21e8b56dd1d387c2d82ca8a904fd347489313977ddee993aef67151d1ce537dd59ca283aae17c3eb9536320462a5b20d174a6bb70bed82a65dd705699cc02bab70a141c2919f7099faca2b2398e2b7ec5ce0f913ba6669365bd8fcaa43b30e39196102c3aa21d92db6196686125c6352337cdacaf5fbb9ffefdeddc3d91cb0629b5ff8f43474f2029a072c682fb4d6e5d86c7a4eb5509cd2b1e4e22b23237aea7daae3828f96f3914c7f7e62c3b73e6ed2a94b3d8930167dad054d746cfe0772afa8679a51ec01cd3ccde4ad85e41ffbb577e21991bdc9052976acf97ffd46cbbed470f4a75556ba6a8e07169346f745c1c1f2dab2b46a14f7e6200b8274be0ff821f5354ed208b18772217ea1995767260e1c16f134cf2582d8145f38afa07d402ea5d1490341a5f6ba58cb44e8523dbf90556e89648c939967249e9b7f57bff3de9355f2c5f6e74d31754e50804493bf803d7e3b99fe6b7f87ca31139fa063e493ab1f7d22ceef5447436e861039bd83fa936bde2ef3d438171113f77a4e245c0644000420e0b216200a409989824df35bd15a991cafe3a95b04aaa57f5b9f534293b2476f036969fc6ceb6c7020aa32f9ca91fad7c25ae126d78e1df43b45e2071824c5c43fd13339ea1465c6910554a5b5e89913c29c929e113466f35cb54cead75548d50a2bd1385336963d6fbb8e9229f991318c2637df5f94f8aaa01b05a7e41062e5bec34b25984c730c5b25cbad4106f34d81a4c09f6217561922e9f8b75c7ffa919bbc516077ab055b653d73d3f500c761838c4ab55d5b2097f51b2cce22993b48785ff84be4c15c2750497a28d25fe4df6ae2cf405e10b0aa63a2d410e5d77d767ef523c8529b14cc0c6a22def4ac63e4c96fac02843797fa04c4b89fdd91f3038a065908e46bf4dff61e33ea17858029dd37f32d6f3aa2aae9e05dd4a0cc8518c511b73389a6b8c4a42da92033dda036bc4c73718d992b7bc2265d744df2e0dbd6fcb1cd8afbade7def1ac53c63324d0b2eeb8e2ae19f29a6849781787959dc4ba926f9627a1337c3787770b448730f24e913d84636b166dbed03952fd3544784826a528bf0e3a76d955e0821a505928650941b03702696e05d3735db4b0baa27d61f6c219b8b95129441b3f706d17d64fc0baa95a0e27fa9775e74d2ef6d84fc310855e6305e0077fa3a9be084995790c2cd9eb2c958678c2aab0fcfba297e1e202264e647e10732e02c5a3de7c82ecdb1c4a274ddcc7489f81a5f636208cd480cb7930116b6b473a7c1e91dc221710d1da871bbae88e1bc2b36840ddf4a457deb4164c341d7362d30149283f8b9819baa0950531da07bd287ec07db6b1cc96c40a68e255510c7cfb5f9bd21cf187f686e0fd656bfae67582c7643f769412d806bcab959e5c23a09bf48ba0136d6c6a8ebb65bb0d403bb975f8155d3191fb082d859d98b5f3377e539ac30d901f2bc7e2f8b2fcb8d1615da474bdb67b6ac9bdce3b54eda9373baef2a6162c652f3d5f8d54ffa5b06a9857b6ce841d0052579f664f34564a62509a6c54048c4bc921360f9ff900406d4056a565b76a8218f2d7537c6123e1470e2fbbdef0af4f31688d28b482c0cb9927f86bba0e34b759651fffd6f0da8eb4e7d0534e6613b16251b1b94079ea7238f108375b31d1c90b0457b5c8ace83e17b585f0da8067c0c89fecca0ea90280c267245c4116c3470b7df9f66f1502d22eb17f9e09d326a9dd8b39090bf3ca156d58e1a4435e9a67905ff37d2504e97f25a7e0e574b0527cb7718fab76cfd621031c10ada403abae263e3514fe75ac4c139d99a312603e3b23315b10033ace77ee04d98f38a7263026fc41272a1e419551f93987a989bc10d07fa056278efd2893e83fe76e8f5b6026e0dde760cdec0cf631e60f49de39f92c78f8c3279f3e4abc0946d1e380c40e317c605a3e9b43c86c1d05189142f7c8e0001ad7c7e1046de0d53405321f11f9b13d34b476071ec8b28062644e5c4f6dc7861af9c77cc366213e830a5ad7c22a4857938cbfa4b2396235b1dceb7938a9f593ce7d753693e33ca1b30fd98920ab30b9069e4df33dfb6d4395ace91d0af9284fba91ffa09014d74a2018c48b729c2c9c1f0ae3d485e03a10bedccdcbba420c6aea5ddbff06e92a7516cbf0deca68b2b0d260ef779515810f7222cebf82c7220c0f7cbc61f35035f631f7fac99bcea9bf341151c447e36ed3948d1835d50739976a02b9c3e8300f1a277d7befbc66074ee14895f6fcc9f10d36bcd28232fe181d20f84a180dafce98df71df2ef45a7812949cf170968abfabdc7b2787bf8c246c622b853a64c5a774bdacb0b9d21be4c88df73f3be3bfab4a7b1b262a2e6f2e3845d802c434d88b98c83e31b8089d1014be70d4a2471cff3d1ca653913ead4bcb258d389e5acd437c5716bb8bd8b8c5ca9bf3e94a17acfaef23198914edf56fa6ec7a7d4c755ad14750a5776d1b4cd3cdc403cee14afd6c8157b73b8fa1fae3d334c3392a212e760460d2fa07b0a4412a0708a9c07ab2e6668102d2a3b0ed83606b13bf5c64a04cd07943556d92abb2957c3029290555d05009a05fe032800478207cf7b28523997dcdceed4556d397d8f20584ad527027c02ec2497d51ad8b02d3d8153ac365703f654c5856ec24c505eed30cd3cd36fdbef6c4ba854c9020cf696ad6fa0b0bf940eef811594e7723a64127f1ba19bc1d62284c30e1b8a8825046c113052c2e5a60d79b95670e95a7f097efb9b1dca91510ac161a737a6779a6bc9abb13237018898a5f91f84d6d1c110993423b9274a8f0e3709f4637114b43cfb1ea00f4a670aa651b917b17968fc52ac1380c78874fc097c66b6030359c1769eae134b66bfa49cb13243723fd78370110e950b8c227e2e9b3be646d62aab1f0326674a609200e82a2edf24b8f417559a9882336438262915ccf9a539b92ccd9833a19f514df95986d2fb43ef14e64b30e1231b9203e99554b504d504d2d81d5a3b6308aed0ca7fd41881a63189d08bfe8c9d1d72959c4909eab0572538a07e9c60b74d8428cca9f1082596fbb0ea65109c94e983244f4c076a981d70ad743442098f0738978c63cb989c2c369e3949cc606300c5e2bb21b26d701c7cbda796ae1507ab9193b54f92332239f0a4c85cd8ed0ad1d7b180524eab3df7f1da6e47bb9714b7dc8b471ac07d50387d6233e93fd18e48616e6cd21fe74a6dd4196135bb12014d8f3e26f8576f5c996504a636690415f089ee2aee10e8fc70fa0d076ce4cf118dd4c42b81f5713cde2371eb5ac4f1826392dd08d74195c6df89463a0d14b910bc6973a4cbbf23d7f3ce1134c27974a53dd50b74a30713996b2df6f3cac723d3f776aaa2a2d43e03d04b2c48e44144b77dc766f21b8cb4f0d001a60ff98ffd82f5ac0419b62c806f9b605ca245d50c366171a9e6e1534be0cee5e96b6be71838404edb8f957c12d795276735bf78c6f8a0c977e7da0e514210d476524a8ef4ab8c38611d27838f430684cbae9bb8660431f064928607bb80a8786ecb6cfd32300f658656127d34657750edbd47365e9c9e198a225916f2240958c8af40f8675ec609a71fc044ab3c4c91e06cfc86d5bba84fd452bf87e8acbe5a5242682191fa34568803a91cd33f33b231bdf419ae60b7f0ae0e65a9c3506b47cf4b18a0e80b1915bcd15ddeb7f4f046e31bd2225ff8076867bfe5eb6e5ee8494fb327d0379777b2810ad118e2c0493463e5970acd33471c0778f0bebb21ec04422a600e6e938fdd13a043af9d5ba22d99707fcc04f83cbb5fdeeb4ac5faa7878295b979907fa4c0cd8d6da52a3d45e7c7920dba70a427a4fbefd0addb797c516f549ffeb1e08911925234581ee81148552c8844be30fe629ee90ee437da0b582ab6224331382a5b0805eeed7fc5aa0ab5ad027347d8f17875074ce1728e5e6d18c5ca8d2c1c90b25a4c664da7234dac5497eb690710d1e13fcd2e03b61f9fa19f9f92e464da10b758f98492072f24cea0305cf097c6bdba89efc3944fd63b823ac894f2f6004c5381edc1ad52a526166b0918cb2315a9ac92c47ddd4749cd33616114088d7d8781be0638c3de17278f06ea9eff012b8191f7728277e89f8f42f27ad66deb39a0a9ba2567d0cbba2af869a12ac437f85ea709178d1da7a3baef64d45022245c1fc969ca353a2bce601a85d4884c0b75812b93031fd5150e3f907faf530fbb47e931e86fccccf90717bfb0a4504a8594f59b95c0b568edfd4f0ece16e91c1bd9d31590ada250273710c3f8f0b1a926eccc305f5c7a1db014e0866269503dc1eb56b7acc71360c8fddf88d27ec877f7449c7636ec9c242085758cc678e45ca83f99625bde4533a16c9bc078a9eca6f032132d2777c0debecbd2b9d24d0fe34a779bbb0c6312931e4e7790e3365616227a6c5813008df1708dc97938262f9d7cfb179966edac3369088cccedae064fad96a0304043053871977bc17ed474c52be173dd9f6a53fa398e1f2add932322e3e6e7f7dd437b7e1a9abab15bcbbac6f03956a2d5399361d5cfde757b14574a07da00e40a45fba6b952fef78faf8a1286fe054578680b08034c976bd44e960ffb80373b813facf1aca000e849b58cd81333cb552ede7596b4fd6fec68e4e299c3aab21c287ac35e5ebc6fceb4b221bb035f403f732dbbda9ca9d7c5597e8d7cdf93ba4b086f0633eb9cb826c8a30e4be54bb23a62d597ce34254f3e73ba50aa3dd1c43e88bf59510965261d93838af87bceaeaf5f65cc9d4b387a0abc17fd510006b35e40d7b559c24cab84e9a34a733fb1d11aab7ba6d6062ecdd0bfda6ab8cee26ef539882b8940973651e2f94f8e9cf3a4ff95d31d265d7d516767551df6849853b221958536872f99a662f555782c204b1cf2b50bc5094946496ba09f3f713288213ada927e070904dc6aba671e2ba22a0e728052e4e501d36cd714994f1bd934a675e35cdbeb5d42cd55550c3747ef1eb28ec5b5c3beb4c2d9444c77846c9f5153e67ebc28a4c438902b58e26ccaad560616263cb9e6682c4fc5f11e4f0184d6651c0ce0ae280a9bca0abc834a533c64529dc1ca505037bc3fed62561c1b12bde61a19680e9420b384821d7e0f3279d2b371c6edd1dad29147174fe03d1b6560b78fa177c16ee7f715d4799a1c292e4dabde3f6d46bf17fcb9b24ea96050ac6bd7eca4a0799e712df437f5427e284b9ff1ca63ccf72a69f25903ff9e64747d38131e096c1517d03fffcc5e7cc75a8bd9afbb175a44f8e485ca1a348397a3233be5ff8db48a072a7ad410d9aa202cbe4edc5d39148e744387087aa2aac00f36ec3f7bab9c36d18207ef2e0f7252cc08eea4a1721164befcf24541b1df0d589f4d80cde4b6689ad9f5d1237672827fddecca588655256fbb31059363b8be6be6003bb199ef980d7d41b49c3622c5203af2b5f67ff821e5b676c33792ed4fa79c5e45b974cbb27357aacf4b142fd4b3389c1d74850a316f23ebc26101e0ffffd7fdf1803b28a42aa66dc1f3a64505298fedd81bd2bfc928e5ce4826ea7c3d9e4ae88f1afdbf97a4efc46427cd8dac051129d7d74d5a8bcf1518fd45190711a2d478df3063cc498eee3de07ad057807bb35edb1c7af0ec45c9e433f89b5628bb8b68334b8ea296f3f7d8af8af65564d8d5bed5e5adf84cf675f5b8ab4da66fbcf71b1fd24dd033268e402ae419835e1da32432f5c3bf2f83f782bce69b51d5dbe521595752493f7fffeb604ddb0dbd010109d28bf67d2b33512bb09cd753e72082139bf8c505f71e75cfe747b72cd7d75d800b6a37d83ce39c5ef21ddeb4dd70df2d9fe2165aa2df9e69eb571d347465da98864facc44ead14a885262a5701c755320faf378e803f4c3c1d47ff516a4d95337c8a0f23d382edda0b237b530148679fa9e4db6be1c4526cfa52672cab7f7c5b4f0e15ab4a7d732c7f585009a262325cb11839073a87824285f097178a5febaaa59747d022d055cc9a9a901a53d38f67b70079020b107637ba60434c6eaba1413df43564fef721e769ca4e85d3d045236ce8c120222ece414965ab6e1a6f5c4cda84fb5057c589d9813053819312de89b8160509e09259c2adc234b15416f6504597f8e07885d675343841d8d4821b31f4e601f217d6d2f13d3a5344c42984c07262aac4a0c13a53d3bbac1760ee02fae79e70a4832d2627bba9b0ee2c9614445f94f0de38aad901a96c4c9563463e270fefbb19bfa65c7a1c6c03464077cfb67da308af9657cbe0425e79a774f4e0a331437aca26a745851e6c7e050b9ff4a6554a19799a11a4a0bd4db6175fc16c0d2cc2c95bbbd53b238d039ab15eb4e6ca670827db9ce7491e892b14b8ea8e994940d551eb7defff28cd0f28ae27e96146e2a7e2c9770cc879425cb99a64dfe9f747762c9b30bc17162cd86e58291393e8f85a8e41d45f5ae916f864f63d553c30e4835f72d7dfccec8f878357a066cf6c2c00d5e9db00f29bb4db9a2bb7711cae443306db22156630080146bcd53fd63175bea8e718b96a9527cebae47b6512fc6692184efd0f5cd235decc2fb5aee1bb56be8c24b9a1de5cb204703c65ab29056badd7906f72e77182b4514d443a3266bd3701a22c219f0350941f59cc9cd776562114399588568a8f928245fba8b7098c51d70a03ac6c014c9b459f21b7790b5b13736690f6fe97654ee02d7d502c66c2ec70ceaecb4086e8d3a1d17fec3f853b7026c1d04026861b9b7a991c5c43cd23e350bb7882b260e773ae8d10302d8d79e8f5d57a18aad6d9524adddabbbd4038f238514cadd1cf3704c8bdf5761331ae83f8f0e86f2fe5bd72145f1e5b9eda069cfa8fded8d33bf7d7d4dae42bd68d947efd32e7737f17ce02dcf609d59ef239eeabf73aef96dcaad05b7264c017acd0a1f0751399f3589e9922ccf3a2f82f678f69588606210ba3a7da695f7cf357163ddfcfb1807f95fb6fef71ff1412d5ad73f9d75903e4ded23cf8d4a140c7ade03f82d5386f50d60bbfb3076c056a9ecfa7398afbea4e877efc3ca55a872ea963cd7901d27cf7d69aa08324ec68673780013956e062de8f6b052be026847b7d23e375e80e13c54ea0a793af801f43a0ca820a4e2450c1b8788b53c6d6c171a94c75d8134b53ef8a8340dbd6f837236c364a17bb7e33e95b65b07076832281e0a12717464c8829b478ef1cc1ccdb96b94a158c585fae824b4ee6c180b364c3791e73691e8aa145b072e87f9c9cc24b82c11cb4ca10f86881b6a2d0f2b5f45f300524fe655b95281921091378855b3404f92e0807c3f9d83421d30c64a848ffcaa19100a1d83d47dab3c31c222a9549250ebee837bbbbc1f365b82f60f4f4697d665b514440d73c88b209e03bb84facc4083c6e29b496eab892c6037e2a1e87fef46b368002a71003dd0b97029a96a8f20d34b7d4cd71741fd2d672e887f76593ebb1b915892c06cf12525f36043aa185f86e55d1b049f9e69061832ad9338b5e6c061752480c3444781033f61eb95fe04dfc0454e4fd5818959747f24663147d16ffd580f9ea585dcc98efeb1b6c49b5d91f25ac01bc429f4e655b59f18ae376275f17c0f91a720d8aa80304603a87d44bb8619b2d70af740f8f7fdcb78061727e39049a5db88b13213779ac016ab563a57c096419f534144aff8e6322b92ddda598b736db98e36cbbdd0f614661101e98d04a618cbd9a66d9ec0f9378d6578462a63562f852bc7e0118e9a0011ab5936ad82834609c5e4cba60735c17c66f01e48ddc19ff38fcc8dcd4c4e0cda0a1459ff3e4fc3251f79a5905dfc5803aad0c41da7d4cb9fad2044dc918d8bb39444330df4cc5f4e232a4a509242e0bf2fef56b1f7da43eef2753b5a8793f95f05cf582dc5315ef9b01ae7fe7765c1535eec4aa9513fc2da0fd7117bb85e13d30c8b24af5042e8a7ade87cf9164aa0f4d92377eace8dbc0fb5f96599219cd2cf6f5b482dd5d76b1337d9bd5711e87f22993b0cca615a1a616039b7c1e2aa92cad4002695051eab7047f3178681b6d20922488e332db69a653143e1149f98162ff9327d8c8923fc33f6c41761e9b14eda00dc2afd48219ac8687525413f56204f5dbffcaef76efcf41f24dc826dd6ae017fc824d5a6da314dbff0f7299df6b458ff20a3248e3d672f2d6390e28b70cedb566c564a1713be36c21420e6bd2e03820b5a2f1d3f3e9866cb3084479f9eb27b6b5c76d2432c3d7fd23ff0f129ae5245115db392297510bcd78c89ff06519595285214a70b5e4a6b6efea97f76de60db75f6bb05da7d7b674e06702dc4b10a4f675e680ae7bd48046e0fcbcfc1e560267937e2d7f030506f35f548513f404fafb5398fcc30c522570c4de78c2b8f906282087edf018469fca90561bdea02a39b1e5ccaaedabfe3056dda1323a7152b1d6e8ef00ab095d5303422855d9fffbad5c64312ea0038aaea8f0fc1d80c184159e1ebaf7789b04ed781fcf251d26e9ad962f0b581f1aaa6b2c0fc972ae9526095d69a25121d70b44c02d1ebfc9ec2f9a6b7f5c8489602cd3d24afc6b83e413d28835d0e7127e14139e00e20476504656baec063d5c65af101d57a1edfc2524039dfee97d869a9a95dfa7bd6359aed448f75d13993f1e4e70e6de7638d82c9370e9c8cd8f3da7226515f95efe60d78d669d8c8a535860dcbe80f1d2bf3897fd8fa9dd53f908caf1e457a94f6791d19eb2644ab1b3d4c838a5a7e0982204d5b64d0a7edd27c1e91eee0976b3ecababdff131d876447b1810caf5a1fd4e665a2aba9f41312aa6b347ad7e36b6e9d357111d70530d7056e46a7b129483f63408dbdc5099413e87210edc9cc37746278f59a0637f40a1060132bfd3d749a156cbca208edfdcb92a47f0024523ed62d1dc1384d3e2a05896f58104263e6fe86c02301d4ff0948979df368c4d2c93763cf5869506fa7dc2bddc7b831d37ed8c522766bc725fd711587d7e886bb8c07e03dd519623348e2184866fecbe727c26cb3a0127fc10e29aafeb1f617f34032c8b786a6702d63ee33020b1126bff5dc74debd1d58322b792e958fc7c0e54d75834d36d09871934f6583652da0d4e4cabc688049e8127bbfeb9015ee489edaac8c691a5a5f309733d90618105d34903ea46a43122255a4ea04d63fbf45baf88f6d694ddb07c83c67ba87faba7de4ade8b21a6a496a8b2e8e39c0da66d155f31a68dcc3a67182bb321506d0b9d1eeb1c08e0a3b1ff3ffe877e81c2a05236810aac1150ddaa8c0f56727263e4c5ed41b809269056fa8aee6bbc99298d90872542b6febeac4a60041fa477519b0b8cd38eaf4679edb913e5d5c0a2e2b0b450b75aa98b4a6ac4dd1d35a23f35f93a3254694bf3a0960827b45aafb541420a666a64eb3e3941cc46f53bdbbb7b5c5be0ff51924cdd63a89f5c80b91b63a71d8602346a91083ea7477f5a3afb84490dd3fd5f951873c04a6cd1275b4d30f105c9db42066bf9a97e6479ece062a684d66675623c716d5233150d63a7f736b244d1d6301880706a7e087a6adafa7387efd0f3601e79373c8c1c65f7dba1e6a2ea1e04c0720e50a8c184e3b951ddbf7bab7d214d94c43acdc4d295d129a547c7c435c4ded2d5a10f9eeacd79566e42b092312b12569e78e7e52d711220417d27e5f7cb754c533eb914c862248272f7bc916a0c91cbc3f66d0867ff2ec11a4c632ac2fe45e4f1cadbbe35e381ccf5ff8334dac1f92b3067dd0dddcfed03b97d7fc1e11e4f64844da2cb7a93ceda886a656c3820ebc63814f44f4809571e39b2c7a59c84acd5f65b48d59f0d7d21352d0c77b2b8bf9e89aa494323b442d75b8d362f405e9ce921ccf16fe9f850ff84f8e62e5a5c4565d67ee7d1c540fb8fd3799fc3b860c89fb24520c7a7728686b2255306dd70a9e5749cfb3e60ec37df567631a0b30dfc9958cdf7df5dd415fc6a2c79ea39ca5a307b18928e9d9238045b92759c54b477897b54dbcd8edb0fd5ebb1da215fd04e0f3737e99b97720be8b6ca02c14f2451851db07eedf579483486a793e655bc98182b59c7a19a251489836f19a5880255efdd86837ca5ec9d2ac1732eb0d0eaf91f9562a1432fa6090aed6012d2ab99a27c1d1f6b3c475f5424513b3931583485c85c2c60661e3114a7a8e7aead679446df61eececabb39308e04122ca700fc15c686b992914a4d891e860170d847366b24c3efbb9c4fb1a1dbba47e20dbe9fa5f4fa140dff15c54208685cf6d33ea66c32cac05d0e43305077bca4dc0fcbdff78fce2c62359675be31bf4ab6c151cc059ccd726b31369229b314330f79e6c7b9fa3b3cc3487ece5e7c61ff1c4b3fcdf536ac71fa72ed3b247bdc806c2ab2ec620d3de4737adce1c8cd0ca95c0c3d0f0ff41f5b03ccbb06bd71bc5f55baf7e24ae02cbe2f57e2efab6140634302bced79c3aeca5b02fa2e2b0d733b7d73307add5f0eb0f28fce6dab141ffe523b5df7ad82328a2af5c13caa4e7e6558321dfad5d295a5b33230357396c7e26aaffb7c136f1f27094b3e7607fbdebe2c22f03dbdd46c14e6f19e79238308212100c82a67d7f816eb3b4184fdf8c20898d49c80e67b6b74ce7ae25830d07d8d9199cc24e8c620cb89ada3334cd65ebb3940174c002178ad30a83d20d285a244c08ad7cbb5e23ef05bea6ede7f606b2e516466b493b1873330f5ffbdf2659202bb851f7d0029c86d719db7284568f6fe43f3a629df91653bb351d0c126d0e977e96bfbd1b3801c0197dfbf7cd1431234101cf5338d8f818b05187a218c6a41db863b46107fedeed1a1c3f57d39e39fcad32bd3ffe412c64da015d335b54498eebd3ff1957d7f6c04c1dedf5f944adfef94bb2a02cb9da7cb3f83a08f1f7331b735a22a33d2869c145adfd1500876b2ec887db6c3f0e4b8fbf9c992ddc0a4f43ff28800151672652706d1f6ac12c832495364a880e072db20d674b3a975fd67a97b93f0b60ce1f5030014224cae410f3530fddbbc9599098350f8b055d47b806e937807b751fe0d1ee89fc9ddc56130a13ac5923a45f0b6d39b48e8192b532680209b2baab21d82d3dfeea04017d4b447e77ec73f49e14c971ec81096631242752cfee8a32ebe24a4e66d3b72d7cb7296a2ab8488e3b9697cac1689aae7fb9cea680c32242be609e3bc6ae7cf31f1ba8884d69b4e7ef25d82d52107e73fb0525929ad6d7073b4c2c156bc31dc80322c83c37c1038e4d348e935cf04b0bca1b29dfb53d1b3b08cb631ca1d0d8ad395cb10f4ee28bc9922f70732b99d9fd9e99be4c4f7b40b36c84d4bb994b37fda1820736d02f9036ffbd63990db7cc5d28fe5c91f32f068be7c202514072bb1c3249d2e172c9be0c7fe113fb48c0ec5cefe0680093a366050201abcdbd4b813732a8e179941f03ad453613531c037c37d7e5c4694d66c50b22aa2dd71541154302dbf91606f9d300beebec35d6de3804db1416b07043339779ce1df4d055d48841bc174aa74891c7edb82c3bf74a1ac1f8ef34872e0cc31f1dc9fe9886bd8de2cbd5a86bbfb6f18fbfce6695b746bfd7fbd06ca94d4e6df2c6d35fda3fa1b21db861462084a1089771a41460fa653c9cb515262b8e2e11e4b698f6c31d547136f2fd107857e81975fc35b72cc159a8dfa42f8a5df12c0722191ce5df6d877a098596a280fa8b56e3694010aad33b334d73b57931e91ecadf4da00f41bf8ec0721792d9789af4611d01b28f58646d61679a750d2944d1b72eddb09ad8ee5454b79d2d4cdef52fe095c1569de157b83c3f82b557de8a0e605ce12117b7dcc204c7e0f85349f18164671197d0e7ce81e048fc7cf07beb2d16d9788646fb3547341d651040fbdbc961eeedab3193888eb3b50542c163e61460007b8148dc0cc8d8fdb31c7be581b118e3aa14772570edd1e4d2fa4b6b0c8f383af3ab8505442b4b77c1cf0f2e385aef0aecf878f111e88b70e7e84cb9b6f6988069eb17d67f784e079882fe3449163505f8189fc91171924fd3217d7615b8277b228481b80d52a1fa18a885b2742ed9cb2309de02159c8eb0ef526fac0ca767344e405bab41122b600e137bd41d15ecd4827f58c0048123d7605a9fec2e14e15f3ce3c2620804504a0dd1fd3be1d8f50c62d813b0d41108f0a9caabd9e6cd812bfd6ccdd8cb2f1cd8326dc80e217c9c975a8bce49426dec38bb0ed2765e1eef19b01a239c3ca1aba4b7790ce6716f378d1652cbc8022d1da311e1de2ef0f348adef3c8eff3ed9540ef6e0448094d7c02c1addf3431505cda6631eaca68c8ce0de2b3026cf9fd5487f2ade76f495f3229aff61dd219440a788b260e4626377b32535c8a94ea120052964e9f586b1c860f6b5eaa907c810ce90990e228aa967ab47e2c8b822e1a717c47892c6ed608c015f5cb0c6158820d10e0c93559b5c26130cd2f2281b8aab6047b36d05f0aa54eaee52321c8c43ede650881e4a146fa09ab99c88f91cfed165c383fec486275aef0308fa5b3a461f917cbb58eca88ad4de7c0f0a0247bf05db8d1be706c80c9d36261bc614dc8eb208f6b95188bf5eb2f95b26729e437d7ef50d75af053d7a3a9218813af7061eecda1ad1af19e36ba93998f2cb0a7730267156e0db41d562d4b724cb142533248359faf1655fcb818df1294a56584ef2efdc7d0fe8fc61770e29bb8286957ead40f6a32cbbdc37a880bf3038dd4bb60aa402eda3486eb2edded2bed51dc3602ecec97f376cfe6c98630d6990dd2939caabde092252a6a629023f526d41d2abf4a427eff01ddf58e60fd4716656ca90391e6fe71779a69cd5521f01930feb85acbe14b5dcd6259057efb298486411a8bc6cc7e17322d4ef6344c89542f0523b0920710899e6802459c44ed82f223dc0fe74691910fe26aa066fa049f0ecd158a124e0bd2a71ffbc5e219d9aa49ec2b9647ee39cc9fb5a7943633f3895817890c805d416eb192a40961d3e7a30dbe1376e0b3ba937f940bfe8f869b72f49688f3a6f8969eef675f687fadaa2ccd62a3507c4675c67f6777cac8037f1b40e27d3e83772c146f78606562e80064747bdba7df94e4228fda02b82490aa679fe186ea18dfee4c971599cbce4e1111d793c94a23ac0a3c9a68b81cd8c5a15818112b690c9f63de695d1f5b788c6fa4b3542d6b8635650e757fe17d8b21422a6da5d234273aacaf4a277da3e1a9a809b83546956def594321f5bdf73b52e5143217b3c6ef97fe20f125e6291526fe2b74d811490da5b2f4919704f9d480e95f3fe28175927946804ffd8e139245a1b1524acae95a7aa3d35f55e84ed4baedb055b0e7146523f095096a9d398fff2f07aab7e80e5b32f2a030a7edee55d265d0372e0563f7ae3e44fa01108e0c04b1ff358bfd9014c97c929905ea57a0731a8b0e92101351900a8bcf8de5745689662c8c0e8d54856f069c841b9b8026a1a678e652e6d3a951efbfd2eb627bbf9f57a71c2eb35cd07c88af962e3a9f6c0ce17179fc873f9284528723d5b301f4ed366716e12f1bde558021906cfda2829d204b49605f0093e74db898b157c830a720cfb48c80059e3cdcb8687ec8d67f6702937e9bb41ff801204562a7ca13602804254860337c740f1c21fe23d209d023b674d4630604848e0af60102d11ddbac0510b2af781a1ea21b767a6bce582b1b0822b962163389bf30d5876f9d52efb82fd03dbba0b936e1cbe07f156c95e7959f10a1cda6d9619b7963277cfae4e8c8483327e6b9f0eaa439c9638b693c47acd843eab7b716d7eae272735be654f831781f8cd5d846ab33f8662c547a5b3315c17ff8cdd51cc53343ffb1df44d374b34d0eddc579446a206b2aa738777798141707e5ead132093d30aec131baeabc93f05f7ac1861d0d7a634d51592e32a9c2c98a127f029451891777350804861b023bb913dcdd04f4c5a5b7bd48f90c63b39027941b99dee711913157a5f7fa26458e72f54df5a2e7f4bd73d211aaf2adee7f6115afbedfd9f4988c65fd67ea9fb6d1837a6adbefda7814fba51cf8ce13de3ab17838ab3a6bfe95f0e38229a310b81e51c06b710e00ca03cf351df2b182d42575aeb4cd9c53fafb1989c73eac17a002bb0eb80d782b28dba2271d9bc9b72af9c199b8a979af751abc7b44f4b568865ba15b7a4c7e79aed81dafc75b41de2e4a7616fded1781de55649f6a1b959a6d6defb5ab492a818e786a20a73d2a8d3874aeb1ba400bb998e4b08c4bbc1654eae71af6169e62869aedb6001228c18dc630f0878729e2acbf6d7afaff1c647b24ac9edf07497e21c7f50b1e2ad3ef1422c303ab33c6786a80b4e466a961ccf50122dbcd6eb31377e2193bf135db349218c8e242a68aa5bc74a9b1678443d9832b88d2b88d1b4567c811b183e4c8f7b72cbe59fe2240c7ded46a91405516851b0cf4386da846321aee5fee580d63c18d35b4470f499509d50f3986405d5ab80ae6a5324925352f519ce0680c4f32441726b34bcd193c0301973ed2b3c78c23d53256e58c03446345d7f281c225173ebc4ceb7bf3dbd1f062a40b39be82338e4545d9626a13b3c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
