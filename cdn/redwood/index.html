<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5e302f2da733378428064960bdba67815e8fddf14f7bf27d34adc7f73e343ab187cd154369301da51dd96201d3b3a09832165c431683d8dd34115ccc494f94ec978e2dd87f39c892b2d6c4752f2420469b51d3afa6efdab7d918f54b05494210614cdec5a7834609f210b076e37f8690f574b354889c771472088369826d2f1762bbc0038b13c87c53cf0272dac87d6d57af28dc26d0f57e973467c4cc55a8f4b2a9be757cd9aa32dc0c4b8cd05a8b94ba07b17171a61ae584ecda909e902de05be2bef56e55f3ab060cf6904beb34b4513572298bebb1aa59ceef20c45771284adbc07e4d05c982992961cd88fb18d5b8289237ea906cfce1985a0bee8615394614589dd84abcc45f9d942a11dc2ec9e8ee890c718b9837cc693c19a09b4114c3edc3951848bd49a710668ee21986da781f24131e59c45fa08c1666f59b5519e7b010080370233ce93f9677c0a5a1d23376723017e9c9760f4bfb7eb3f7d4177a9663577713b937e435589e2519ac3f0a62b50ad50ee96993301877198d14a71bc167a1a6cda870be0832d633214cdb14fcc6545dd2315000295121053dace506e704e5354eba6c67a3faa5b942cd7f38a19256a225adb1b9fc16667729f218000b4fefb17103eb146bfe55053189e97710bff07c472ba2560df80c0b139adcc8b968def462786677053d213cc272f4ddae83db715460f37ca821471306eac6553086ca28482d96ebad98d440aec5191c6a1af86752879c720a306db3ec00cbd8988791eda6a49ef542515a4b233fc1751d045005e7bbe9afe96b0534434121a239027fac52a9eb9d1cd7822d0d96f841055b7499124d0a136631acca88e0248598f2d218fb79047480ff50dfbd084f420d3f99e6e8c840e089efc0b22296ef65108abc9213091a226d1b27fa58644a8bdb79889a0a06f175c96b13b94e1539485435818ad069104a7c0acabdb306b0993a869a3c14d703ac15a393f8e4cf4940b0b17ad85216fd34285ad3491e77bea42b157643124008467149e775a27a070618b43b5d81b9e1de9f01210f57999fd15b5c25ced58f9acb8f26037a7a28f728c47ba9b8cd04bef9810ae3527fed0dcddca118ef4f76977e8fff250d0a20aee7d629e80ef666e2fb806186a50dcee38d09dffbc4693e7d32506cf901d8286a9426ebd77d640514f6afac8aa6dae4f085a2d5da24d7f9facdbcbdf76df8f907fc44e9452115673b2db150ed5398301863b4082088313c9f5b12e8140ec859905cdddc2b66e009f5e986288bf9bf82e2d68b373a4b779bf424871894881319cbc9a966fbf2ac531c34cb2bf3ec6c319fdadefafc7b3a878355954a39ec78734e4a00fadfaf430d0853315b1bc169cc257cee4a3451887777fcc12c808ff168a05427d3ada7edd0259c2020355f56cddc9c1b6f07a9ba9264f2f76f473df0c3a5f4a6c2725ba759a9341114981576631b613f5b244fc535daad2bd3fd7236ae980096b83987ea800740d2cd469ce6e8b613a87bab2932a099ce2c92aa8d94356fcc27ed7b7bc38409b42c2f0edc29c91ae1da57f47ee85bbdcd555e0ca7d6745f1a09a721af507978412c97959456a3ea1b2aff0407c30e998818b18bc5030da6ec786d40754c3bf83e3d5fc6302b3aecbf58b2130300da368058c85d073ee0c914f7036d604d54a299dfc1448cc3abef6e3a78182491af00ba1f2fb81ac1dbf29f3e2f83cd4007e8938216825c69d280b74a971cf2edf2bc75d1b196d22c9af3bc72afdf8abe2d66814448dcb5722117bed76d27e48ea51f1d067ead544939197ce20539c8ec77d3e53115a03c25078b110cfa0efdc9026eb216909d73126f9027cea4ba9866c7a4815dc43eaf1c7954957e1b5eb48cbd01ed997ef3c2f6977a405ae28884382b8dce3b8c62893b708875b50a6b06c6ba872c2f168bd29402c612ebf455b04fcd7f8e155fe3e6895ee318faba1c0e2fc66845568d873a514f96cc19f27515cca0d654fd68efe3dc629f27be2651c8d94a2d273b417887d68e68d25b0303b9129dba74daad054d7fc89dd4d3a5ab574b8995091dd0d77af922e5148f4eef8134dec6e1d64ce4bc9098af506bdbeaec7068154d95562087bd798540c9a39af924f6d420abc1c22b657110d5e768bf188b7695610b1e92a1e6dd7ed985287f05e5676ca7523dba433e48896a49918a31205d66cf7a4cd57c73f28e0ab22f42c87b65987a26c03cab0952cef1dd98f481e54800efb4c27b0f4083e5d4880c668b043963124e157b1762753713c2c1c27cb8be1d677c95e7f2a49f3c384873cb12ae96deb6d623210ff7b9baadf6f749170fee8c62a2fe378994a3d543a7e9a60124581d6dc3b2e328aca12a3abee57641cb75791fdc4e69b26617007cd2f1d6884d033b3e24a67419241cbfb491ed2b0834cc6050e280119e5a4347bb8e485d0a5f5a9453614707d89fa1d4023ac51ba6a88879c190bde9080a97369430184e0c09028cf6c4f8d367bcadf5882df4c225b484e0937516f879203ab2e562a2dff0cf4a72fdfa973371620b0cf81cdb1d8807584ff42e3af4f59f510070e486ec2bba0b0f0af3484bfee56808c7cc6b40f9eaf76b3408be62d7eecfc1df255c58c413f65aa88cda2f2f41dbfe49d4131876f2babc4300b2a1ad4e5657a3cec014ad0ee36471f1d5e38e96451ec53d0dd06fcb03b665ff7d03267af88538aed1b954726f697d9283e8e85938d68cc71ae270a78a9dc58509d2311e54a926ecc4efd5d44050fb834f6208ba79625cffa6ae4bf706eaa63aa2898320d9d9bd109cd75c756bc62b0e7f33661e0800e4edeccfb29baee9fff536fb66bb68daef0c078c90726d4487a9b7a515e5467cd7b93469975b5242c5e6ab15eedd853e9036b367499e05b013696ba17a5ab27e2dee84e0d17cea757f3b30cd8c533d39fd19f8d2b9f27f0b91bad99b3beae1509fb8d3fbe6d0cbc50eabc1870c17a5063a612cda26fcfc7b4d92e980eaf0b06404fb2b51a638b5e0eedf9c6a2367ed9abaf829d61482bec5861985a4b42357944c8ae624e07755db8f7d4ddfbae4730f4c232b71dfd3e454107cc317ea24aa764c818154211e01fa484d41f6f21462fe4a35f3cbeed3717c08733911e2f393c4b75c1a0ead2e4cdc564935c7ef6d4f84dc82084bb523b6a232f11379fba913cb282ebe516789ac728b32239af13c5b59d66561d03d3e6d0c764d41b0252e76e9104ab3594d4b99dab28d3665c9f79acbf023bce3524d4f4f4678e99074f52365fba579c8347ca2e153e9504071b2d8dc3964513e81b39b54bf5dbf42e4453ab3f225192f3a1fd98bf6a0a0d1363f71e74ae4d35c0a77d0efc80683a4d1299f8fc0bf9362538856764aadd71cf4c5c6d8116dc6c0bc5ada8868524825229c69ade5ecfeb4497bd06dd48634d38b712e0853c73104160a59b4521bf2ae0ca7bb16331e1e89e2db31ee71cb8d8094ab7916797ca583831a21ac666e5bc439f526b2a6f1dda4f8ebde57cfa24c5a68a6ec55b68f79da830aacb0b22b2b07eb5984aa2991f41dfe48cf975248b0f43bcf9607c83c944ec9ac65376c19e0c4b3c4177784ee77c44093f97469e7adaeeca47a9c0fd3e9faa4cea490fadd4a5836b6986f2b84dc11a80006f691c85ae4a18a846eefc1cb2caab0319d343009fe7881f745ca447edeab0cf17cd58ab4079a1a284e8376f66018d1bb4ab4e6964244cd65a85a490dc79a2ddf00b5b432f51e9a163a0b5061854cb3d26f878d884fb8046a7a393ffb6377b821910fa3c6d76120059710c6c6e7578f99b9489d4c94896ad9e2bc93d6e7400d50435634c2fcd61dcb4ec45ca57003939b108e84d85507fc0f8897b165e097a6fe75139c9ad1a0f5224b71ca0860ed58e13f2bbd141d012c3fc4ab80d3cfe394a9a95b44ac71160b30e13023961b6efc6042331bfee7422d915caf1b72825fc231699556299464f9280fde78598b0f01f31f7a1f0223d7d134414586fd9af2baf7bdf1aafd783abcef277d19dec9f2b18b26ed61b758a59fb4faea66dad12afc28f4d24a2bffbbeb430d29bed6f675640a0a31710a1e2396a3c001577355010bff12b506c8e9e8c731b921daa80081776d03611c8f06bbaf88221b24464d207c34982a09ce24bb92fdf4baf955fad91c2f877245c6575523c45ff248475276494d607d11c28271745fea1796ef6f6fd203d0be4acd014120bb22340004b54b14b343ed5734fa714a311b71fd3125432cd940372f73427ed0f9d8ac5124378252ec344ba52ce96870010e0c0139d5c53783d1a05b7ea32078095c075c24fbde1c7d0a0c1ac4bf497a2301722d514dae305438ba2bff2f1122ef38df9e2d14a4e809f7087e1fc3368d8affd51ca4af863a932506041404b2d956d3070dc1c83f83274865b171c2cc80abd09e38a04f3ef95abb24b575f6eab06245a2258be68438424a14a87dc45c5aae977ae190076ec61f7894a89146c7c21f82ea5c899f0f7034c6860c68a673664570062ba5bdc8cb6a79a58a3a78c2588a1353aee7329cb4bc0637d06089436b4b80a655a672f5304cc7fd50ed08f8b709764ab6bc3506df0c73bb12dd0654d72a399d9b0ca7bad74ba92dbb202783517e394cdc3431cf62cacdab99690daf0af1a7155ae4fbe2a14d7026dd036b6a4a52b11ff3552010eb950cff1fd38c23d87e67770a79300fa5a04aad0bb1f7de6e93ee9dc33809e9a34b5593d4f0dfd7777fdcf2dce9c769195fb35378829c6f1f52f615979427a2aff76d19259b08cc3983e4b2ade03d6487cfe76be8f821b562c337ba03779ec4a256c8241928113fd30ee3d43c06a0adf3c2eb7d5b2a5c64c0fb8348180c2437c07008220070cb982bc981ea70e8bed5f0e8cbe380806ff732f6f3680b8951e91325f268bf6fcc8f5ae7253afcaa916b6559aefe10f38a73b9355d933d13274a096ee777ee710f92aa5fecee4e74f681c10267cb258aa7b213af84e407d712e10c428b817dcab7f78f8845d7428a396cdfcd0c7389e9f965d97bd3db8a621e4aef487fb0bbde635befedce49b3781ef80a49ced8197031c5944e9ed2507aeaafac8f7cd80ed9933749a043128f3209c8baebc741216a20f0bb9aadbac279453405455c7fafdb3425461789382cd4044e0fbd087c7c3d7262beb12441daa6a2bbae3752dd8afb88e80f5352212c4fb5bcefc3ad27101b3962ee150201d363b6c8f9114bc9960a9e6a0965b821ad4720c0ccae27f48b668725a8db2d229e3c95383858111492ade3423aa656145911739fe3a942a89e1457c99e64dd862a6367a3d09c8ba76f46472d3b5ec3db3a253cd8465bf1c8aacb2d70b9b215acd9b248a19e5b80e692a71ddde860ca494064c1d76e5482ca07f2180dce92a20d46cf7e5664bfeb60d5ab61dd62d66ca5fa20dd27245e8ff0848cd67483a8c413119a5bd23397e5f6eedf7ee8ed01f42cbeb2358b669e4e4aa17f2e8e6e4798df21d55ac4a7e6e4e521710deb2d185a8bd081dcdded6cdfaeed37d88970917f246ffe33a5249b3cb7243905a0dce749bbbcd8e2e33038850c23cdcfd5a47c8d84189a704cfc218a4f7704c288d135e4bc7fe730f8a432ca75966e6e0826985000b9a25dfdfacad766f3dfb4533466d065e1d4c6488f61101add9148b2cc0cc5ba7e1f63b27b4b2bc3dd7892b8c574c83c2ff8a31888c55d25cbf0dbc221a911b32e125d1b6e7f1684e963d20effa1f6783f4fa61dc89e4eff2c6ff86c58c0daf140bae46006f6c59c85c19ef4b579c6104006630d13f725022734ef04a8487e3ea17f95dfbd3c7fbb7cd0b4447522e71e3c1a37aa608d8635ebca0c76a6c6e09a797ef4b45d47f50897ac94c01b87cac03195ff1d62ae9bf9480a5c89bdb80488ff4ac5b78e75f3cf14734bec5094cdb94d4dfd11c0eb9faf72c11432a0751d066d7e02a9582dbb4e59316c6bcd3e01588d75d96847192a0b95e77288eb386eeb038123dff9c9eb799a5d5d710d925e55f244997176607ae4b202e7035fcbb11a6f3174d776a6f2c3ef7be80d682eeb043881b70d1b57006ee7c859bca72f56686bfd422f74426d665488377563704d0476f65a79f7c9a3b02e56e64dae089322ca4812d55bc1038696f916339c342f227bca150af263c9f12cbe001138cf3569cfcabddef8a1432c39927edd012b0477cab975b0065166e2677eb60578ce115860dc0360e86621d4abc0e9ae7ead686651de43fefed7cac0e5f7bc95211593c9848a7c5ce3a636f082b0716723d9ad9310094b448b37db4f6fcebc2c99d663fae87fb3e6a0113447c9dd22a461b6322a3e340d32ba7eb80c3b329725b97d3b397ce83d7d41455dffed28927dfae934a739ce879190c74e21d5c93a95e176e00e8e46d5c28c7b3b93a185a6f8b2380060a7427dd4443f4902112e46782cdc09590a4dec50424287c84cabcf36de5d1a7fdf14b2fb18642a32de8bf44b83b188f04d4fb93215b070799b7b04cfe010b7f34159b5358710044198e26e26a01c8c65750b7e51017a1f62ec81d647c9e22100db4da2dfee93f30617c56fd50e24c2e3a327c59ff1bf6cb83457b0dc9ee8383f64b7fd41cfa3e31cafdbba5036792f5956fda386b150a26481bbc3b413dbf8aa7bc0f7be7dcad0a982466cbcb33b8f75efc4895a54efe173312e7f7f2a3697f3ee37a9c84442424503ff96d1a353142094e2ca0bf8f6e929dcda1afbd40c11dbe2eaa35600fdffe57121e46dbb5ebf10ba5f0e9a5373074f8dcae46f3adda6b1b91235581ef10a04b0554da87369d1e447b35d33c905c26b4ae8572e25c7a8361c4acb53e90a7d05dccac7ddad62082bef350bac97b5b2f51e8f1888fa93f2f6c886a7161ce9cdc0063445bb1f7e23efdcd8b72524d761e90e7c4ed22f3196ace1619e7f1b965510875a7231063a3d7d5d291fff19d95ff480e970932770763656dfb99f340687c9bcd4438de1370f39960382713cadc07c333b665b2f7baf7641560844c1b6870c37bf4e13372797f61ce7fb6a16d41c6ae87e558ca8c2a53f1766a20e35a55bf07e1a470c31206a3895e9d22991f028eff3df6f7c2b3229315cba2687f74965bcdaa5f7da04fece708b6e36b622e32e0140901ff92e57ef429c53983f38889d31aa77eaacf6a21c387e47d7bf3f75e405f86c4506eb5ed16f87fabbcd49f53fbc59a7d129cac09bc2ef8d92b585f5caaf8aff3870f2a5544aebd7ff6c7c814450e6f427e1594d2b6b560f40155a11317e84431b0f7527477acfbf15bf3f6405d0478ec5225e999d02cf5aa7328aa35a6bd3bb83774a6bdc2b41b1da4ad771ce9c4e72ab6eb5691c3d0e8ccca4c7bddfbd5c651c0a564f88828e3a00b377692ead471a211575c00ac960df8ea8d6a9fafc7ea662bbcd89c23cfd850c9d71db98610fb84a78fda395aafd3a816747fff1f0d0ddc90ecd586694416b1ee3e1bb8a0957499894020043c78d1bb117272d0eb2c441de4b1606f0476bfb5a584aa47b19a2e7dfa604becd47a8a32e9fee7a0b86200c94cc9d93d84c48bb23f77329ac73b557742d7e36415c73a7f86f1aaa3d544f7647ecfa6438b39e86bd2d13c6ce4b77471937af1ff3dceefd9d48781fc35f0b793a1983cc132efc78774b142af7e78e8c86d0d27775791e61f0c6df44e2c7a0e6f4a4f51d3db1671b02662013417b8b1fdf88e4bb440442928ddfd6a17831db3b10820eccee72c4e288e6020c8c32d9ef65205e7d52781a5e756c4ccb5b2b6f5bfd0a75473c503bea60def093b226af2663db29159c043fe2339cfb7041e8e1084c2f0433a9b490790fc53b529afcee7690e2b9b9ae4853fa8642a7e25272ce7d1f2a6030ced8cd5d76b435f46364a9f96dbda46beda1947cefbae9fe9941b32474c2c955b1b6071d0927cd3889766de5cc78bd452c62b90acf527847aaa77cb5e531a90d9d74eab6e6e1b144ab103bb104435f364a4bfd96ff81dcc887bfabf6f5d5040c2a25b96e227d0505c30c53624eda42f87587d16bcff450fbc04820e6316e4fa042b0095f693ea4800dc72522cc5eddc0e39e3da6901df79f859219e4b947e9f6492f9e609e049b6a3ab3c182a7d8cbf2f2c80bb2374151cdfefcbf07e0a9b2856c885cac8bead7f2bdd41575b100872eea481fac99e672e42fc15c66254c6f94f6167689132c57353bfda726ed64cfcbd764e760f5275e87575a7d948d954480724b4a5a7855b302b00c401294b10f31d77aba9f1cbbc8d3e0781b51cd223e38478c96d524038017b1ba1b3e7dc42d36df09e6f2631e09726c17a53e487dbab620b5ba654d7be4498b13704a683436ea710a9b5c9a4e3cb3cfddde5764584597e5bc449f94f6b411fcf48b662c18a99600ffb873dd5268db4ff2280190551e28e1573201d8508eff113340a7b85801f0f5e4257950cb18e2b750eebf34e658369598af75f5c7e829f5ac139bb27f4edd093532f26b92d4df74b016bee12d197425d3eddecee9e7695dc827fae03de47b0ff7f570b476ce099681be442d62c6ffeec64cc10d985271b0ad7f395f00791df40daa93cfc45b69cc9ca596aab83715ee5917bd87d73a4d9fef38ac6fab92ab930fa942dc5ae2b28209fcfe66d5978888578f7113a8a2402d9125001cb60620ad7ed5909a4f812af14ac5ac88a60049a7b3033b47f79888f773267fdb39d033a8a7e723839e4228ce8f2a2710839899a32b7f871520084d7ae66833e7be8a6d3af0a8595ed639c57f5fe413d02998b2196b654ac5b260e13ca2e766485812f1b2095e6e264b88166d93cf75f5ed4afdb17fe7b8384b344555a3043ce3eb103e50729430d6a518f856f199aeb8e56fd13c001b1a4e69a5e3d3c4e0c3a4dc47d81a8eeba124908baf21443d184ad31e423de24d26747892204923d3d08be4b0e5a802ab6cc68d1799a4610f15646664e5f9283c1ef7765f82c88a6dab0cbad6aec947533927fdbf1bcc5995532c5bee7b1da1430456015e106f80feea66cf1693df4fca1f31811cb255acd368295913e0a7af354b7ab1fec5c2c50a7dfc4930286c978727eac1a0b601d426a14b87e21b99357f93e2d49ddc017281985096587ac28f97bf504bbca24e6327530c9060c4898eb388e9bcf837a13d1448a9cb25d739121edd9df2f32d38b2d4eb87bc093cdf0d245bc5496b302bd588b1e2f8c97fb8885fd594fe21fefe17c01c22d37638f44f5d8ff03bc7cff991099be9315a73c7b85b9a3c49de71283b2761bd8912a739a44ee27388727222e6b49ef033c4eb5855d2269b09c1d2faf5d349d60e819f50914b35829da7caa1c72b78547a12100ca077a3e84c2ad143820370fff21c40a96da2ffbe62ead3e835bc90e5121fa1c176ff2b23925b7d53d5ae43cc588e50c393c82f282f5efe46997f2d6292e650e67c5f690110d7e7218cc1b5248bc50d658efd5fbd33c2f61fedef912ede0bfc6f249ebeb11ba27a607c6310a8e579804d54ffd6fdc3a665cebf3e15b11240d069d24da53228bb8b59c40a77ef4962c79376ce68d06301c6e49ba4884505f4c62f89e4fa82d4c51af7e1e9450300d940b18946780c95ae7952f0d5298204ef9c16339da6b63abfdd59e15e78d229bdb19c018a6e1694f6762987c0f252d9b6564105f80b06abfb74d935abe85b44c2079b492534602b0cb8b3e528924dc51f377a84ddb2158e6ad82746ae84e85fd2617675af42261e5d7b4721c4e926430c0a0ef5e6ffb681dbc4ba4001a4b1c1c8a7f72d06c24d70d29da12bb791d28ce2274d9a2b6a90142bca0375edd3e41a812cb9733b3cbd16bba957623ecf8e38ac116ed4d162b73f6776c8392d90906199e11ec40aa92a0fe41b337b87be6649c2c39ddacdb1ae54208447b6fa4886ec31ac7487f2bc9eea30c232227cdb0f94c7a41c55738e0585fdf437ae1f659e46230807d52e91b88e26e402a051f449faade0a5d149561732902b280127af85d63f8f06b889d3231066307be54355bf5d151ba761ee0846de16f849af5b85d72904c96c4b925253e747437c6df94e70eb381b709e4c26cd9944a05fd9eea8374fa34a2255c0403fe6e3c472f50e629e367a6d92916f01b8f542b0f8ca60579c3a86ea15cd3b549c2fb63d0e7c3144200a765a9be56b4817c3f312dacee56f7f6043dd97eeb01b652da7b522b85a0ec85defd177a4f7d2848b55e6e46f28d6c462e1482ab14cf48bd978032c5d5cba2fc9a2abd024d00eced039861fd2d6f27ea5a72c7405e22a6872fe49461905e13091f35e0bd957adaaa6b9afdb85350cb766c275ca8445d2577db6c84fe1ec9345b4bac0753d9374577bd0a90e52f2d49eea4437549a1d7b39345b781a076d12697b502825c03f7abcd6583d1abdce11b61bae6066882358c724d87c1b7714b16b00bd7859dc6f67410219ef00d954888688fc197b2ba9f2496c4c69927d6714f88515767c85f1cc3f1d3b7e67f3d75e5e0b6769b4b9091e85378dae93de35330fb03151b111e225fad94ae09d0e8d9f1e935e3b753c577aa7d3e7352e486a9c7de1795a1f8fd51a3de6d655452f44c25a9df0ade96df4ca9cc73dab1ef1584b5b553d7e56bdc576e2048aadbca6b860930ca19457b733c68757a6dbaa77a0e3ecbbcd123fd04f1ea1d05b9b4d75f0ac4186b34034a9dfde7e12b4cc5807694f6c3f19858ce2c68c615be897c121d1709387a882cca075cf65eb06f811ecef824ca8d2470b4642e12ee84818faa30653f4805b0a9e0bee6b33a8b16df796437157fb87fefa15195c69a74ddca69c838eda212a389a2cf68077ca1e67d710cd6e204317f5f9c311253676b2e833e38f678ee83e6665dc07c0f2f1c8b9edc5e436c973b13ae004a17f68dde366e831a37525a0f038df436f407e4dab768f386d88f3aa89e87ba772dab84afe10072cf28a50c298f532b6a55eac85977ed5bc85393db06c013ccdb56d9330e407f07d6dcfd2bd54f2f54763fb915726b7562f361681da41257ea186fe3efe147080a64c7ea9fdb66b519de0a3bca303bf7e2d741171b38378afc25912b799aca2d152545c6f7d1c4b411cf13fd234ae9761d2029f159287cccfec31f68b02eb42633f47d189ee387b70d27636e95d5e0f67fd7e27873130f3927843934d1e38f4186a26fdc2948a47294f221798c2f27e4f7c248b5de1b9588e00c96d18f04faf380e096cf61a043a452a64e3110f7ed642fc4d13f8740e4d1825dd44f01e0f2f59fdb49a542429d40189b9e5ba589373c723cf30efff93481065231a8bc8ebd6deade049f365fac6c12b49631eeb4713b7334881925d2adf5c674fca2e0b1146c8e1f4d35f89ecfb97b3f557da475569e9ec874c42179021144d3007863e193f9cd56d6f8f495858637f0993ac6a2918c5a57e333a8c9f754edef89763f21ea5e07baf89e0ef2ac8ab7d6c61c5358a473d4012ead81b72add35d2a927dcfe4ff519b8ae226ad387931dc64f43d577518f435e2c0cd1c5bd31a3ce9cfb80c5dade927e017f64cde3ac141e8ee0d6c56feaf0517caa841462355d5dafd7263af63d454ab8fed745f37ab82afb73cb37531a7ab604743fd6aa8627acb849a0baa8fb7c0274eee34248cd998e3fbe9ad9cc09b20a5c5553381a28496139804fea7acd1525a0a87cf892921b1b3052588922531466b732731f47bbcf478feb2613d9890f207740e8c44c10cbad0b84eaaa9de8662b6e6429ddf131723c29711f2d9c1608a854c139cc2daadcf61b37f7b7c4e9f125b00f7ed0962b6c02cf7b1c5991d0f9d2b2f163ae591a5357e6f510076c69b6933d288a3165e941d213350b1538ac9ded4b34581130e98552b09946dd222ffd50260a01089718b579b8f9b67843d1276d8a53d7fe30ff7ea4a293c4a49eee32004513484da993b22d88934550254a70b90f617f3c47bc643ca8d4dff79b4aa2c114c984ae7bbd60bc6122abf7ba616703473ad4e1037cd0b8b0787c556c2b0ca5df9dc624d4bc1d3e505ae4e27581eb8760c03991b9cc004eb4a4397078bac8e9cb77f1226d97fb6770a29c0fcd90d94f2c9a22ca1be87b80f1235cb075c100950d9bb435170c58b9d5b9f159d01535612aa04a49a64cfdc85a25503cba904a51f99639b855857936eaf914821649fdececc354257d62d76ceb04a1709ae08fd4196bbd5a1caadb3263c3ead60158e0d0a225876bfb51154ecfe39e0839ebeefced5efb0f465a5b52f9a341b4803dc217dfb85b41f6907580deec93700b63d1364119cdcd49bacac2c4615b2cb10a2cec24ba84dccbb7f45a995002b10435c8fd106820c836f68d7eb04ec38c080fcbf1d8782d85b9e740654475d4699e771e6fe735acc76849964090bfd168adb48614bf2595362283680ef28e86f9d634a39d1f8a8f5dd4f4a510336a51ee40707dec8d3265be8830973d069bc8a119b4d84081ecccb3f86dec2c1cd39de73c11a72493038ec1610440215d22d01ae460b393452ff4a5918d1e81230e95e03a9af6f3e1cfc2d6eba0fe6f4b26deed78869ae3defacd78bd707893d5adc4ae2585c35b30410552cd7223d98747159d76b84a65d4ec93984497de5b9e4600319a55b5601851ad5e91ae347817972f0dd87b60a80b50b265ef1d2a67a774e16001ea195582788c99a6093752b5b2e854698afd83e238f7ff4cd22f903f6629b1595762d6726994f7c8b9faab3ceca866d39c081be8117eda74fd2260e683428b763d1e41a8c59f4756102fa6dce2d5da7530c0d57e40e899eacf1678ee25f88ffd4870cb4c53efe33cb23cb203aff160a55f4da9dd87bb6d6007cee570887752ccf458c62c0a1cc6096b14049bcc72853e8a3b223f3960d9d8b35a1c06a800d3750ef568303bc1b65cb267eef32139e9d9d29a7529c19cde993bcffed16723132429f551dde106b0d860592a431400941a9c5ac6e1e702625294e4416a82288b15686914effea93b7e734b764ecc7f818eec4faa51f7512e4b3e611cb1e769c5d4f9fe16a36d6ca0e805020098ca6e717a720a3b89161c1b0d588431a9c3d66505bf414e3f49145e0cd56ef39fcd480879c67fcfc9cd8b2a5a31b96e75ab01fea4f56ee2ce1c332a43b5d731e1ce8573cfce91fd198f24c9ebabe1abf2601cd427cac8970be00ebabb57d2e5c39f5c320c9bdf8be3ac5d07b087238cdec406499d827359790211502ffbaa7878264abb9f99ad385ba00922d0405556c0fbd75c2855ee20269819437e5a7cbb30999dc571e9b88554bae0d5cc5896e287fcf7a65257bd6800ab35b9e73c121c2e16c21fe9b3e3ce972bf0e408d8f171ff8f557f7f1b32dbc968b13a8fff80f1492c7c47f7a9b095ac8d64ae2109a866acdb218b052999718995fe0b4324a4af3360aec669c62fd8b907bdfc5f1ec3ae688872fb4bbc0c9fb2a0203bb690f0a9a76555840995312ae98c6c73b26830c28b3568038c47d9fc4a9c8771a8ec5e352f913e8866ddc941bfa7140db0f9e7e0bdcfce526d880d91b913557e4e175f701932a0d88cbe3a34167b38e7496d14d63f17d4c904aec1d93945671cbd62fe3e8bbf416a92bc7139550b1e137118781ac25acb6fe9dbeff5e2ea4efd603652a6e43bebd4aa486b97884257beb8fb0ec53cd55830443882f01cad7fd39ee801d480dcac4a566f8365a5d91c2c18c62ac9fb504f482a164d29400371abb32ca0129f7e26b7b35c320211b9aca8bcae93c3a42eb82bd16e78be428034664f2a09a973d342ed774e835485594f3103b1f40a53bcd42d2ce288e0fb8b86ebe5ee836fc47701a049e1e1c34105d581f467e453c37a430432b1bc95a50b908d314599ea1783a0d09107a9c9cb2cdf182a2e7929c7dd62875facfe090b17cfae0257737f25b60c7843741e963ce79f502dd569e5bbf21c7463c83aba53921787cef954524f3d74a1cd7d331b843a43d371b678f5320c9bd7e016b74ea58ffdcb3fd7f14a1f24f1fe7ef8658776d3f0a34d594e8d3de00d74b9f794d063fcf45a76be1bdf8131953acdf53433613470c868cc660143613a5f077b1036d31704082e78c145ec42ad24ce349803394a951ff31b1f05b4fbd8b5730f3e407ec9e53e8f00a187de7090656b6d6884f5c9fa5f23fa446ae0865e0662e907562a43a98e15e07f69c9e17c679d6ed1de7ee24b0fdc79bd9e74efbc1f50ccfb6dcc2757cb09f07493d622b50c06d996b411fe69a5d1be4b5d04f490069697348df40779a0ac5c33adf2c898a732b090c327beaaf3bb4e24a71e7d1cf352a59f6c0bfb4bdcaf6407473e8873bac300cefd0ff3037555e1f3775aa09c1cfad36a4b8a48709e75dc3046f57f1be8aad083d88668a9e997f808947234a72b5df58202d118fa81be6b29ed1bce6fedba9928b2c2809a6505d82ef05c8514969239aca9c6ffaa0b0b0d6617a0c3b227069dbaabce4a242a0eca463ef43df3a0be8f52867eb052ed83d0f881c6214c3998ae159da8f26f694c782f89315624eeef4663574ede7491bb7589e6b51a522949f5e985aa25cf8d9aac4d7b71073eca5162caadbd4faa446c738277aeac5e9564358dcac7dcfdbc4f0cfd1e30641b38f546d5c814a17a995add586a001091badc2f410769f27ad636da0633d5af5ffa427cb43eafa3c968ed904539d466477436f872d224e6edbcc1798d066747b243c8b301f1036281ed133871c34e4fcae288535bfe13005513fe3e490011315f5fc280f6f9920eb1c41d4ce86056da6236ff3a89bd881d3e6ec7501cda26ed972b793233184991636b2692cd9fa802987ae47bf0a4512714a8460abc4ba40ba1f5d66923ad747e11a6e738acc6740dd39bc99263ef44caf9ee75a2cedaee1ccd037a09abf1bb256d921151eb30959ce987624c1ece13c3a89856482995d817b27022e2ca0f49a82a528c4dad8c00d19910272f725937ec3b277992f98ff979bafbd02f850b2ac27fa66eed893eed031e6d424565ccea54f3413c6c776ebe73808cd9cfd1b9e46592cd24cea882b2307b04315b9864678362857f5cd678628bf136a21057a45dc38a8952dde05cd9554d5a336fb3eb9f9b99e849154bfdda75530c93d947deb17f591214c8e984214795e95988c84aef5ffd9bc11f65501d701f46724838f72144557b36d6c08bab79af9d886c3d7d97bca48c57b146f690531788c034db224f93f9218c05a1423a6882349da3e0e8542f725809f145c4aa667da2146b0c5f872282abbb6983b84fb37484da56cc2e51739ab30c0111a3c4aa5f559ca9ba08b620b8b087d5bebdc2f4031608d06682d7f9759121316cca27254b87d49a1dd2e46cecf0b4284a9c0217aa64f515fa4bd844db726477c00457457c7c4901465c323c7a0cd181ba1f3f4b526211939954bbf098291f6dd3327f29cbb49c8849f59291677038ab518a624f4574a7e8cfff5d8e938689c2dd1ef208ff9a64c2315d7cf7151389615abb721556848cadfcd7a41109ac8ae8e3386fa5c54c9fbe530e5b6925205020342fbfac6d41054def89af736bf1deccd44efcf4d8cff8baace43de84269cd739fee05b09a642800badfb25db8c7657ed498034650c89aa7a4b96bab41dfef7fc960940413c90478519a74ebbe51969b6f9c7917e0a5a38d0edb01b3eeb07ef1aa39e6e67168ba1e526560b15a898f2e13c1f941fff0e7867532858d40500941648511cfd2a49127aa3c2056a6d7199b08274df98231e3afedcb867e56ed7a1587bc7f5c0f03d52481b3e6217172fee96f0b459c5ebcc31086c9aeb9af515e5002fd62d7171fb7b668edae43e4159d857317558bedfe75a6849a0b6e4bb85ed8de00917855797b7612756c8fed98734710f9cc2e65f6a09312e8c78941d29b55972d2e74aa47cc65a22c6b0bcfba47ffbd1a9b22bc41652864ee73bd4f8f83a4934a32cb1e5fbc7c934d545dbd0df8c36edc9a0d645b5fbd669132b13a6712612f01ab7246bae29e26bfae03f13469c318ae0d0fb2af901aeb5e534e6c064c532ec50bb1e012b7cf840831217a9aacede504e7de0e8cb29db21670abdd3d2584ade53e821fd2da58b89582a30b0ff09271d2a75860ad15b7194b409ea1761caed978758a9701de5eedaf1dd8650eb4e94af0f37eb3fa14e4f4b26868390e8396c6797430f674bb9a04df750b1dad2862c53303c545ad98791fda7e00e18022d39e296069ffd51227f624f6ee7dcee79fe6cc04c1a0be6958aa3e2125cf7126a955633240560d56d85fa02f6144788e4e699846046ed882e7e40073379e66846cb1c9af7126b7ea26ffc64ead4ad8cb49d72b3e20df598ae4323842cdddff64e6c31529cc0498ab915f9304474bbe2eab86b50adfd0ce85ed523b71779ab7c9e911c59e6186a6d2d4b3a2d53586576eb0fda0ec8ca3e3275041cf5fd5c27c7c0ed574a24fd4a1333d8241fad4c0f854bcea05c0d4cfbc8ed753f3db28700fa19e982e54611a4db417bfc050486b031ad191ea62fb01da7f8abb30557dc0a398c0f36aa49c2acf2682b7077622d979be45b165d48ed4f02f2d2d61201b8c218e1d8c0a1a6444df966f72f33df9c8cfc3eca9b5bbfc386b29775077a7e0016a0b12f9ae2c694eacb68b7e935aaf3f63676f52ba3475388871e6d6adc3fc40dd180214d4f70d781bc8ae49610eda29908991290a505573848249c1ea17536169e07e1460342d0acd4665c7f998d3c855b2bd7596d27fe3319905b6c2b2e55b3ed92f0f4340873fde6ca33c9d52e497ec2d50fa51bed54d1507033244d703d2aeeb6634c36a5719b377ec95adc76805fa5d80f119d118d83a9e0cedaa62dbf6da4aed089dfa06d0d24a863b84f050dcac2c71f12c13c9240e159cfce33cf5fd0c3f0189aa6f8c62d08b9bb4bf3351a608413986962cbe6cc679174179344e7c2eab41fd37fd805a6ba75f2342caa4686d449eeec60a430c63252243ff9e5126251df919a3f29be6260203704d97ef21a2d86163638c286e7dd3c85ea8c2fea00ec5c53212f5ab3b86bc833cc4fb2bf28c30a51bd77d89c8390e463f15232462452a6f868e584cc4f1e98a22342b039cfabd79020090a68a9697b51012ccb44c61f3468ae8cd13673db697f1b48c2f12df986513a5aa6290619675764a8a3760b46ff5164bbb619e9015c2f5d4dcba1d6141d372139c5791d29fd451f020bf11805b26331aea927e3f31ba8732f112138161e650008895558f09fb493d7ae27a17534229de0ddb5d75d97234fc73b5e0998a86a7d72d0143bc6deca5eb18290b2503c876aede16f0c1a638ac4a8aa6ad9f981cd8d2881280f2389c7fb9345242ea59d0a382e336337df41c0a74659667464144ef4e61aca78632e688a6ea5dc06e286afce9071b42e0bff7672c1190046d73f0d34283d12fae493d6ee1487109e5fbf5e14d74fb34d5daeebecc4142bce4e66d935b0451faad47675950013542589abcb69a2bb9c262d4f46defe14d9df2ab47d4c05db75455cf67ab305941f25ab4c0c73f87b86266e0646b31481a1f3d258885584d0dccb04502cb7b60fc9827b1bcacfff499fc8bcc4b1f38c4d44d1138c4e538e45e93d90327773c333e0ff22a0a557522456df41e979d77815a0ad2f171cd71d7aaf866076128ad1be4fa2802d89cef259a83c640b3b606d7210a1aa5058a57023a05267ffa90f77c42d620287a82d8f00c117527bedbe6b6c73081ba67564ca757700b863f5dc325be3752b74455d6ee04a4dfcc7257a3993a0d0f85ef8ec08f76db979b4e1aef4602a6474ceefa3e2662c356423b8cdb51871ff204093c782828845ec2fdbce64330ad0b192904415034b1658043c16918237765d8e3d2fca759a2c7de7b3c6b3d9483d5b97406b89851b231eb8aa8b789ed4898773025af4c251e2041d511ec5de97cd0a33b07d80290f6b92c63b0d6c063f33f3d532fb0831485a711da8bec9d9622881fef45119d9ae7abb2f78cde937482cf20bac971d5359f1aaa2df398eab5598c831a4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
