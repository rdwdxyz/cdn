<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"388780f95efa49974bf4fc69384b2846e5a23c6322e0e123aeb0ecd78261c8d13599ab41eb40cbf51efa8b8ab920ca3c0cb516d2da7db25a49562f7a89050af06c226996f7ede4448e4af11fa95d0da061ad26c9e7b84603fd7e69627b2c5b03289322fa7118853de0439f7cbcb5c3f07eb1f31c4e2d95cc439b4a27c0cf22264f3625dcd1f89f5c4448aa2e89b944485eadc1e5fece5ed53e0a55934eec4b876cb0c4fae7e4405898222c85e53247b5526085d67041ee0a89c9051d113ac415f6013e676c6ce0459c05e58c8e26b28fd2af4f29cd488c6d9639a0b34413df7c57f0ace877e86390cdbb397797c425151f30739c848304bf2f3e78eb0bbf474bc1f8f50bb9c47457769053c8a84d714cab74fa3d5a09bb93bd4707dbb2792ac7a09d3c87dbf437762bf8e49ebb45d70c8fecde968154892c4d2ba8dfcafefbfed5fa6862f1c57a6775dc84dd522f054ee08ebf49a33470a7f7053b06c656ef88a9fc62ff9d093ac59711c968993c712a29f9aea90d31770de2a0d392cd7b858177532587e33d926b5e233ff9bfaff0ad62c420f9457c0785a71c2d68818cc741a9066a934d3ecf8ad790f341b4fbd9d4ba0425213acf84b6563feffc8f18c6261808117594bc426ffb2cce3fd1d66ddccc2767f4d79ae6413d870defe6bc4d98152ae12f6ccf03ab7385c1b280cca502347bc6da4b86550c771c92b1888d83ce554e0563c7634cc74170e513b6d3a8f395632f970a7494ee718c31b6489a7f99b6e510f50840bf053fa0dadf20825b16331d9304395559dac92a4b47dc1e86d94448637e079bc0882b8ddcc951a5e2ffe8e3ece8e55a6cf342d6ec1c345b96c945fa0136bac77328afc8e73ac8c4ba8c070ac6db7dfd523481078b8c601f91b778476bc90977a4efaf57c51e5b71b648427579ca2812e5c04bebc549976477e6383edf5f6abf7ce217046b32f7aa3237a262c93676807ff7129b6c537297410768f426382699e4ff5d1e2dfdaa12a46e4275c0aff4dc7e4bbb93d67b9f2ef7c1fe35831192e028ae07c53e36f106716949b4f60d235b047abacc7dea0d6652b913488aed9ca39defa22f953d2d811abad9ccf5c96c4f68bea464df1af60e182ef2ed190a281d7d35bd3037bdeb2b7d4c4d87f07b55ba56089d974ee7124a898ef48bb514865094c5050660b22a5d97350914248d9250b9fd00ff18ef861a8131b1b4bd9c0ca30b1d4b002e19437171816a4c3718d34958292680b5a8328f432a366a8b6fbfc8f36c124c44e4c3bdd4e987db1520f44e7e5f1321185f5f78a03481504614698bf66c7b507932623733969fe96009e5507b950d7114524f4809f3ba1287dd2c7446d883134d09eac7345014e3372025e66d6e93ec81cfcfbebde3e2b91d592bf469345ab17923da43a522e6e6c5280fd53fe8866d6d11118a1f85932433c1c5fe965567557e3d5b31c5fb0afb9040351b5a7318a4fa06de7bce34290cc13849d40c165e6ceab1efc6cb71b67589cc69bfbe060257c692d8a73663eee61c94729df4197f204c57b2cce9f4e851f13e87a37fbb2bd47888738bb7ec20dbc25de7e3dee8245c0b93097e451b65d21bca27f08315a454363ea4acbb619e0ca76d6b6e6c867ae2c2b559dd7240dd2b045be5f769400ea9b6662d541516be64a61b820b30cc3f4cfe983a9ca5b765de530839296314406a38b481728333361d11155a1d33473d1cf8937c9b50d809a7d9fab33219126b04760187258c1ab94ee3153fbdfe86763c886018e054fd07dcdfc7b9f0b27c1a7a8016dcc3e45fe968975328003395ff5bf216df607f95fa49fb437bf80082d5255f0b976022c1b3bc22b97b5346aebb3e741f1c5225728bc863ad8dfb4e3f3eb102eb0f177dc77fbc69b3ac65e9ba00ef152c92f70533fc642434742d264d72b84b6fe3d86cbd8adf4baa61b0f75d230d174dee57056fc474bc92cf570b238dd86f66f1bb1d408328ecd493de7848905bf99967b5d652091efd8733c20c0c17a34cd9ca5295bb475ddf5bc151026e6008311606e1b2b4af40c428b981f09d7e62f00fc69b4d85575ba449f210d70a269c3f887ca138bb5703f7bad1a60129222d55ea22b2e2d0ad3a7ca001dc24c6536b6715cce1d67c7a43989af616eb9cf36441f42b8571f9b9de110208dba135ae25cc0bcdc99b2e5106ee09e8c7fa638933d0f194e9b4761dfe337b4313c97ee27f8127248d0e191097fdbea5675dc2e7f82dcf42484e4655ca13acae9105f863225baf7337c8e4dcdbea937a2ec4264d6a4452e2d790c650d625b84aa1f612f41156fc6b2c647a5545b9d2aa0f0a5392258772002f2b2f154b5da95ec8e0b6a5fb82db563c5f10ade0c1e541120b583f241457cdcb07f22d8a4c1ae573d835154853c89144392a5527c50eb37fc2fad8a6622d9953a1e27a0b0307ab933166159a0eac2e73e9e035da740de925ba18a6402a12ea50553a2f7135caa79322754426884799fba4a18f505a9ad7c2bb0ed94b784d44e4ece712ba4c90c3ec3c117c226beec62a09f22e6db4d5dd40f8ac94957bf992bc43a58c6c5bb5e6f49cddb46d9229109572c4192ab11be4d1499c5ed673fa58154df3948ebc9696424b8e4791f076e4cba544e0c7fbe873da9a4cb1ef579041bfe77edc88c6e003c9d1de1c5fdc69d8227cac279fca7e104860b4ca80cb5fc27b197e3c73a92ec04ee9f20613e7a90833df291a3e9df2af1b38ed2f8020f3bdef609fe23c64143509081cb83dc561bb5f49e7fef2fae2c6192dca596cf7e9aa170fd31f05dee880e23fff10055eafbed08fd365cbfa7f51bce81da41e531a46517dd2a98068d661d523e253151df833a4ee178ab2911719b614dcd5b54e68a36354a70f11fb596bc9bff42d3537dbdb62454674a0b5d41c75b1536c5d94837ff9744a732e345bec8419ab724014aef551d4749b58a86c2c43e5331e73468305e81a141ccf9cadabef868687202edb7d998266fb38c1dcbd50ecf5121b4bd6f61bc2c2b01aea6a62451bbb82caa839b085f5ea49e4457b51664998772a2913ee50750ede3841d0489038cbd68d95725d2905e16591582c34f1155d9de381e6d019471c0419759e01ac6e70501a653709eae3d9e2d6da8fade6f27e0b713de7d711b0d247bd0af14038e601d7f4476b58a2e9fa933368944a029aaac7ff0784d7c36f6a9874cb6b0786ec7856ea6e132e3ae4bee8e9182ade267d98c5d47d2e82c915cae79775019b34184b6f322380247693ddf9b33bab0d717a9622846b151ef76f5d07d39c5b853c0fd7eb9e29f0298596e226f5c87bc8ac82f7ba0ae4ff03b62c20dabcf799d9d571f214321d875f3876c81d662bfde3efc4c01b2d70946ebd8e34c2cd963094df479a4bb37ec999468b990ea1e4bfe2a47a2e6e3eb309d92a001e4dbef363f4627e1a2c98585b593a1a80cba6523a9a09b74395325b78f2c1c5a8319274888ea178b206433a8849960e34d45bfe9d8cb10ad05db9b14fe5de81fc5fe3d66f2671d6abbeaae6cfb9b324dad74470b005029b4c28290f7bd699af50281175890ec29816ec4f5b8c23231f390cb2bc16cc8984365b3d68c87d5f29a057b0fac2c0debf360f874c2636d5529c10768c001be75e630895adea8356b5943c1669445bcba503cf3c2e147a1dda86964107753f41245d79f4875bec90d58637056ccbcd1fcc6aa3ee0f33f72135359f2c7db350f6236b0944ecbb81cf6b0136d8d4fe62521ea1b82cc232babe6776c0274c3750d4600290d3c0bc5daf8595d87413f214892e14dd52ae2ec821d43ed19a61e597488412f5b1cc9c6acc30b3c5610be305ca01bf52e3bdcf97a4ef85ff38fe906cc4b132854f1f276fc77956c43fea7722ba563f0dfe60c35eb6bf7e3cdf752bb8f138f8af2cd4bda565dc0626c8d9ed45983899846e802b4658259789daba1a1e3acf1e7c68fe1429306055f5ccda04247f9f6175baf2613df68598273f640494d25f2759ae4df1bf7db91fd8adf4d6c60cf81473e9d9baac568f8dc0df57c49168e11254001f19bc145b13994451d9967e65e5d0f648ddc727e1a26423f8ac5e6e7cc53b27aa996b4decf479788fa2a0fe84999f177b94e56bc3a49b40622dad5cd75d0ec36d724d790d8431ab4e4ee3601056057ba5f3f0b7a70a4c51b48e1ad06d871d3fe07ce23c2ed915de5a89ae7a7fcfcaa0b4cd9ee860c62dc8b91b581246b530e5e4f030161c79d15845db5884536db38c3500c3a52e984d12e20c46c68daed3c53cd30df7c46dfbf507d197b67c317074b91a638b99292ef9632d58e63b7a9b07f5689d8b646fe6bfe9def9e0e2b1104262413cbafc48eecce13059252c97ba49f63ba69f43955bee6f5f760c088c253c83fdfe4a2d9b646fc5516d4e904a92ad09859221d4b530a3beda714f26c21bea1420fa55df9f5b29c1a4583454f3fb39704cb703d90f4d1c3c8e2aa3862730c9a61bac7e5f01daf5aa64e788be53850a72ffbd0a41ab73c4df1b8b0bb4647fa00058376a3cae93087e1344387c8b7bc73d6c373f7838cb1d18cf052794eea7aaa2e33c0607239c8baac64073f58a98a743c8755ea190421617b05ecdfd52d2f379fad17277ecb498b57f52319bb3404f7ab0e47fc7fe244a315546eb81af463ded4830153542e9ab67eaf7379a2f1c761adb1f094020385048ec2b9fb141f0ee25da2e3ecf95b6bf1d58eb2ba2e72c6d6eddbe75b6e064d43aac87adb9881f1f72523f5bf749deedf013c339c5413b6d4d43326f13f0a2cdc2c1e28c1188d959562419f2a10b17ab8607e68ff2d7d2753e02f1f14a7c40c977ddc7d09a8003db35e90251e3d3f617e891947bc70634704735f9ac77ef9dd9287bdf0a61c3d299ddc8f7e168630212574691f488ff078dc0782c2ba06da3772c7bad8ab3fba8b1440e2d107225e77a3b643ae7bf4d49b263668c50bdf3fbb6f64e4bd4df7bf50f7a804f895d4cc1c21989227a01c8c1c1b7aad1a15282e9bfeab918430d6d52ff65bbe81b40b5bb8846c5cbbbd4d61c791ec31f2089fffddfc0d5fcf31789fc24263f0d91c08bcadf104e006e812452ca1d941924878122f4514fe19e4bf7d0b1b3d8b39c7810cc874ff8da78a5da25bc51f8d889a911d7d3b9b8302e79856702a5a833e951d80c4caa606edcc455d12e88a83567af58044d9ea038524533bc8d80380f4225e8cd4633ae7f3a3c58d4c8c1adab2f26433dc880439a5cbbbf95cf7f885e4c963b4bfc7d06e099c8f5614a345de2a218add4aca199febb680ba70fa810ec4cc8f92e473a7f56961f8e2dba1869706244433e4328cb46c66869726e9f8f6ab059b2037d85ad9046e3dd8325a314053b48189023be7c7a559c6b31f395a9e63b4f8d0e31a64883d64372301b4266ac224a74642abedcc1b7b9e64af7ed67d65efe64fb12ba11d5f75b1f870a7774e0cef14063031e16c23653295aff6b276542d5ae6e7b7d37b5bb56ae0fe68791d7854157644209470f005db7641fe66a752c9e3cb94e83258611e9fcaae84d7603bfae585901fe6b5f5f98b8bcb0dd4b591f5a23d36f0dc2b9e7bf299f7bb9176420ce662201440253f30460e0291f5648d0145c7abda5b831c66d9a850c99b56df35ed70547d8cb707de00b36c5d6527428c946c8d1418866d71d86f15d3954b3f516fa7719371971ef60cf620784430fcf438b6884d1d7ec4e545904fb28c3d96f972724199555b0d6976f6b52c7720c135f4ef2064a1a8c1169ac83d8b50cafcc757f2b106024f527e56c0c5889836fdda960de28b94bfaa85ac6342b68feee0372d43c8c0484fdfc9f320c807fe72ce39842e8d67a11a335432f2132b81ef7e3b19ae7d1eb10de30893d3318bedbb327985e6d6792d782888e65d9da9e24952df8c084eeebf74289de2ca5e1483e790c2368c9c8fc09d8d8b3dd7ae468a9493fcaf87b7e04d7633057bef7daa91d03815c9b95b23f359b132e6fd3ae0e2f9e0f5781bff4da49b52ff00c42397917ad18aa7a98e4bc6ba29491c986971aff93a5db73ccc6fde920e9a6b8e734490afeb27d59b6de4780c080df168c4ccf95bfd1e1a23f66b8d9137d1d0e72b26b018d279e9eb6311c030a7310fd82c38ec033a0c194a797b3f0e8cc89e2d9ab936ca7a9128abf87a85d29a401df7678454777121812063cb5e18ac7197460dd36affeb34a9a96033a127fbbcda8dfb92d86fad421f4bb8f4eca4b1a7062742d50ca252303bcdb10f60eee683617eb025801768a2c7e4a739655d80ee8684015016ccbb91b5504ff1e25721dbbbe19535ab097ed6a9a8edf9d6f391a2255d45781e57a34abe84bcbba4ce79c584ed0716db666665f4404bf84d422f86353c5bcc25a49955e4f879748fb68588954a143f0462447eed53d9046c24bc31b4e343e5db1e693691b5b10799479eb5195042ab18f28cea917b99cc410f468e73101663a900a21139220115cf43fcbddb4d8b069ea504a66353e5e5d258641db836d5cdbda888b1602fc0f0c7e03297ff995ecb8973e656a6eafbaca8eb5236a03b63bc11ec7a93125018dacb0ebc3a11b7dd3f9dc1ed105ad162fab894f0c5375c67f3a93faa499b64342e806c7df0d23813f5c52e0c75b399c9eaaaa22ee858aed36d30881e06f42db774fbe5680b0dddab3e256fc3220ae2c8f03fde88461e92ae54e80d1972324e8ff001b6b9f054c0be14eed5046f99ce349d01cda26a2a7cda7caaee0c12769eaba26364aced0a5a5d0d511ccf3a9ee08a5d12a4c6a73c254bb10f0a48c8127228067c68cb00103fe4fd178244175080ce08253c11424a107803127250e11ecbb8099ad38c5fe709d45e4f1087e9834ffdd78b484912765474de6b16c9ad782e0ad92a2ee0a28103ad2a446caea20d3ada091eee5e6050d34b10ddd879a3453b3c2a892d243e1f23ca58fda4b3ba80d4b71839c5a830617340ec8eb50f41e77929039cfe6e234b2d0d0ded8eed25cb5cecc7548105998e6dd6aeef3536364ddf5746d873b6fd66eaf3e6217d026dcb8b450bc806ff8c2cd8e08d4ad8fd9dc856d94bfaa18701d6794d66fe4aa4548eb794f4fe360d88ecd56ea58b70bc1217d50fabdebcf7993ef2c8dbb133545885eb1966548f70c2f04314de6183ed3eff4db7bd7c3dcfda7e2dd53694254066e0308110c0e7baaff9b1af211188d32b47c2538741e6476d59085b845397d75959f567d5d7154aa234b19efa09e2c74dafeb71d8eb6cec723de26027e653a1baec4bf2a013fa5f89aeb040c96a73282e36f07af9ccbf4a795cb2070a7705b141b6ae0a4a8763a35ce4d3a662ddc83d1888150d898db09b3779bf39bb85672b7c5dcde80a716ef9df132c9ae6f2be68edb1c060778d90ee455a90739632f76b774b2b694f798ae95787b872df172e61fe5733c59295ef48e362836b151f2b4d1a70735b2dedc67cb30d94f22db4dbf8785c15e8cb5df30060ff47ae0d724460692797922049d22a558a0066fdc872cdd550e03fd0d87f72256029222658935c7335c0af5e206f475bf7db3a04d664eba44b788933300940e27a4cec9ff8c912cdcefc16d95cfa43061b7f507d1183fdcb789c78804071a2c3d1187ff6d23aa6942d47e0debfafa44482732c4cb2be0e5fd6429bbc6091ea1978959b06f29601344d431968f09c09a3c884912cbf3cad1f2c959a481fd8bacf292dba2eedb2862de4f1acda819560e77ab2b7329cfbb0c8e6f08306d4ea7b9b9d4e2faaf89c99c0a286fdfbe88a97c3fe57474601fcd18c7a23685b397b512ea41fcb00de6e85361081f662dc69440645aa7f8f69cb615524d663e806502144e1d7839eb9ae150f0758b9f9442bb073b83a663af03b70470b2f2b881740ac820d38c7cae641661dd7fee692952405594292ea780bc17537cd75c636ee1b7504d936b6e21f82ccf56a42e9084f5b8e2ffc658ad2769280760f38e2f5ec472cda54f78e5e40e80821e60888fad26a0cb8b20ba000fd49e33d9d8969cd57d5327bcba5a7ab00d03310fb3f0c6844d64edfc5c2caac007d80606748a1e92ea7aeb8c5e36995034c5b80c2ae9ccd582280102e96e3626e3f967ff0dbd599b48799cc22f3f7ce26dca24e7aa0a9d1fe717b4d2e571fea953e1572982c0988d70a7f9c8e3d791c0aef559e47de55a88c24b5123c071365f6472338f9440f94507d82d53470ff1a8512f035a6eefc24857f55f15edab6b91fcaa53a9d0ce6a0feaedc9b34ad4f04aadda363d59d3439c0d05e5c16f1b935116f340580d2c68a970b039b5606e6e9b7581a62fb1bf0f67de9586a94a6d55f794958e8522fec315a89b4a0528631189f6c6557472bbf1dcc2d72a7c8d291c77c6560c30a51b9710ea5d71df43a082054a7483e685c74d809981fe027fd048b75249453a7eb33479b68a4f8e7ef5b6479050b5f7290ddccf342b991e99156c7144c92bafea7b8b7e4f592f3a5702f60d49a0e8e43c249e047c87a3c7bcfba669bc0cfe87a1444204396bc4b7642f38445ceed656e5d47d55396271c208d8475f040225b5606c718812326fa1f6bee29043c2368d43d5de79391c88f453bb9fe1cb1d4971011b1bfd1ea8de56036aeb723df0e5b4aa589cf188203bd5b9b74eb60e6636748cafc9ec7882d1e02bd816c0893a440b7e06365147bac4f1405ae158b88c14212332002cbcaaabbca6f59c3ab7d9ef381367ecedac4e1cdceec8ab97bd93136e2783141adfbe07d36a27ca792f297aa9689ce0940135fdcc21eebc4ae3c9ee1534c4719e51b4026fbbf1bbc5248aba0b0736d21e24ec61caee12d919f99d70e4ce1190840063224e7471f089744180ec8a1fc06e40fe94a797973d3263392e022107454e2123f5d957fe813e7abac7b39b752770698c639bb4bcec28ec1d892551d52678a367a51d7ee2d9fe238d3467b3e1a2d4b48d8db20980d89ffd244141d1620cf2555febab3ba6e11b8fe25a102774c753e15ba6e50728b19884941fa94016f734f2d3ac067470831db5cbc0c1e3d822839193a3ce0de6628ba4b6228ad81c00cb7b8d5ac4f57e68729f84e2813f3d49fe4e64027e7a86502054967af4a84783468061155dd82b8c93ef4c3f21b6ccdd81056d600b54a2e52601bfa1d688fe026ebc2f18e76b79d27674162f8e7f2db9d1a5bdebf6183953b9cfb4a64331684e28a6c2dbdb984fb738f1b69e8d80a9d6fb24f7ab41d2c2db4da269cc4137506b32ef6a818a108cb31108e4b2810b4abd8d523998957f2672ad4830ad020f286be1509af4fe1a77d50c7355dd66c9d2174475ef19264d5e539ffde1b19c267c2699fef20520d13cfb3f434fbf21c5dd0debe912d1fa4ab2c36a8b3b43c0ee314c492246fa6f371a494e3e5d06e51b7c55b05caa5b6772f002964547d4a308363d24b9215f7d61c697c5060264356f21ff742e03c3acffafda071b01a7c979942b950601a810268e66dacc2e7e5c2611d2c038587ee8e2f50b698432cf5b7b3ef7b694ff7c06fffdfb0cd59a7b1ee31df285e578e3514ea9d72f17e23d67e987b312ffa8671df9a4dd2cb21c5f0bd7fa89f1bdf1922ab202162fad8e7b36c0d95994669dfc8b728ed7c2a31e591248e785d077e2c4997fdb83b8f7ea9b1cac88d40dbafc2c20dbfbca91c592fe4816a5f585421312556117af86957f1dae5996f2bed189ccbc339d3e93e54ba2dd04ee00b2571fc3d0b47db93a91479e9c74104e92ccaa2bbe50f6a4e5733a6ee9eca2fef2f4a9b54fec129a60ad59be7234c0de35c3111cb7fd6b4444e8cc1648559a56e06922623c115834ee0b05503858b0ff4ff1ac27aa8269408404d9d5fb6277435392b59a2f87edf325a24d970087642111a0f26476cd297e48d88d36fa0d9dcd2d62a57e41dbf902957dcf5da7508a82df278bcd5692f9cdba88975c5a741bf060270db2a20ff67128401083e8f2f70c85216404d88070c3f3b2bd6ebea5d8ded47392d3501839bb688f09c9e648c20ed02bf0a7778bcf1390643c5af4e86f47f215760ce2ac5ee3b81dfd530bac22b77e31768b373bc4b1c6608ec5141c38662c100b50b51f80ed4a16ce4c94661daa367e6d690ed4595f68ad1040246f03e1e1b992cd7581f5c765ae6740cb7c78325452d2d687fa3905a01efab2f08d5b193d120ec21c8da68ad005b0a6eb7b5df5c4a4ada1076ef8aca0f24e602df1429df849f78246b5716e452b2d054883a43dad8338654fd2ccb05930f7aaccfb11bc735cdfe9b8d473a53f4b8085fddb8bff576904bdecda186a139411384d279ccde6ce82c7b617963946908a9a42e2e85fb2bbc69a77d8045cfdd48cf62ea82a13e555fae90372f18ac28eeb9f44924f9711d2a926e29e1e09cb971be188919a2d8798e63e232fb5da63c8bdf53dead293f8f47bdb437ed7f5960605fa32bb6303751fb1bae70a2de4e43658b389bf0c27948c81456cda7103cac18bc026548d3efefff2d6a5d681fccbabb76dea41e55be8e06e8515a33440ab77b996715f6cbd9ed1a16f6300b2abe557e3dbcd7d34f761f2fe5747979a2372b53c5ec7baab76c5317c5d49f4119f3b948e26ae12204121aafac3275427780b03e31e48929f35b4f7eaae5712f90b74a4fad387fe3017e822c20c5d974f8555fadb394abb221d8da60ff79d12cab512f429e84c479871f741154e084fe0367f163956de617ff9b31d6f3ef471e4a990ac831acde36eddb4ffc73c5184763be8fb242f6645191ac3c9ac6d7219c5f31ae20eb681ac2ea3430984b75137472eb974f9d4f5fb516082030e3e109f7d371b14cc65615d4d697014e930549f1255c09d278adddcd1723b3d0d68469360c1ee77688f168020a532b8cf7a3e33d081a308e6236d2abb71b266363d461c366c9007bf5a61ade507b8d1549335e87b72411675306bd51b1b860c10d43b124d991c1b3977ed13f7152a527d875165745f992297ed8b1f1b0d13d0cc52d747a202b77c04f82837e73f93dc6b2a680c73b6470edd1b720ae53af7e30410c364e7e03eac2de1628a0bf084a3daefb879fe531c962c260176b76655db132b3c8b00e1b2a83a60a8871a9268196aac4b84e0d5cc090457107c285b0282f64cd7d5fefc917adaf786d23bd2f843c2eaf1527f8d3a525257cd4296bfc88f134569079fc6b7dac5ed6cacb2d7cc6f64f8e5c88ab1d43b7d417daecf215490ad117006b91976c053f6a13e104dd1a864e3ffde627f9c8da95075c70d5806d3af2d6c54d93e54dd3d2a9ff271b62d8af17c9bd7610dbcd7c722b5307108109eb0235e5153bf9bc5e2ae524005c61235876875087d45189cb3be45dea5ca6843697b647cf97a99771c4c04adff33209bea806dfb5f7d9d4d69e4f0a1e7dc2d895c8b340c56aaaf12249c347ed4c9828ba992bdebeaa6cff507fe077f1a3c2dbea482fe8e000c9167a959558fcf30da3942d8673e0162c42c1048d97f3e8230759537cbb508b357bb57814c387c7004a1af1ab29157afc6435f1835569f38ea31dabde1c4475123931c074523f4866aedc2a2afe2f1cc83fbba8e1affce8c93459e3b3a24aa5c338ab555bf7424dc6d7df91371f66ec0d630b1704e6c5238df0f8183693bc69a4905405c415a808a8fdaeca44037f795bc4cf0eea0bcdfd4234ed19595062418d2a8a3f6955b8eb5ecd56f3bea979a5292b8a68667e29f20d81ab1e6c2b791536f1fede94b94dd922338e1a06e0bbce2ced30f40ed4bccd6d85a66b2710a3c71072cbfd18b915ce6e5152306239ac3ac53687ecc7a6dff031af89db92bbbc2c8d24d6697b06cca2957f2db7b2e33971c176e2d80e82dd1d9d3f744bf5505590b572f209024c8ed9cfb1dd92914cf6f55234e5b0863841a78496fca6f791f89e6a6a8c1d3269ca92e6f9d0cd0da21f0d45761a4160f00662dcc4832137b72ebbe3d220b21288eba0bab3e97afdaf88a4ff9aa197d7ffd977029e1e9727c50d2359d5524c95176d41d921dc55cf661c1361831b6d677418663af57a916a8f1bde182497f93e664e09b6e81ac58a96eaa12db6575f118d9b4fef54a800c5ac5644445b63de85e93feeb06588181a86f272384bbcd1487a8c5682ab82d5502017ad6cc0595dfbabf326bf5df34155fc1d7c2a2716f32bae597c297f51b176e9c6eef4720e015043a8de2112cdd27abf384d72e4651f706b4c5f6568b5e83d89b223bc2c141f99a32fd3a136991146aeeeaf5ed2a7077403bcf3d24eb5cd624a0615cd60d3860bb13c95bc3a73622fbd55f8283133fdadf62c77a902dfe018e4f87b08696bce795b70597d67c2bc00747a85de4e32c4edde9e70c1eda67146da3c9286261e540c1b6e8a13e6409983cae826922fc0ccb8bfb22ae1129d296e4f79bdb96127461ef97e0b4cc82d34528a2902090930c4e379d48b3d8abb88ee0fa0ae8dbb61a629cb3459c4f7f389ca36456292fec318ebf4e86a6cb71a309b484f67d87af909608fa6a221ad483e64bfe3fe8c7496336758b8ab54d1b00a57b4b54a08ae260f39c01a1bf9ef14e504ba5100536a3772a009efd0281339c1afff7887fe751777e51ee4aef76872c8024efdbc7bd02f14ce9cdf9b6c03c89ebda8b5f1a00a3ff4f2e255c41ed3a46b1e56c05a1184f5df2eb17c1c92d752fae2c3d7c83361793a7100ed14d494145f8b5019a1a6575e569dbf4f809a16f388b4ff26f1b8ce230e9bce7c46ead310bf26e6683e081580108bfec0d3a2ea322bff2097ae08589a352e933ae896f98bbe0ee5739c5383bf09071cb1117dc24677822c49e2b6e16f56c42e53466cd03c8c48f4ad5fc16c219878cc8a455ecead47a678b963fc016ec5e31ceb26b5ca3c4f8dab466f33dbd6a7e382bcf87e8b5772b9d2f7d5875ec8a8ea41de9ede01e2073717d10ceaa00b56219203b3aaa83f32c86bd23dab47d1dd42f75fc49df1572a5be78f1d4c20397635d96ce8544f7e2d03f58ae4b178dfe282ee100191cd66a5c1026844e67fd5d4b9b0e96b72baa6085885e6bcd623dcbda07eb092b5e244843d1253c36d1797c9fa8397141dd02c9338c1435d4fb525c53bdc302a58c4eaa8d18e07f3e634ac896eb6b9e8a3fc7a46f036a8aadcc9f4e759717f3759fe4e19d542527760a84c265727d8013ae2064c9bcee8f3afbd3d8e557d33450dc79ae408169c04fd584f617fef11bba2c219fcff26b567da761c22d0753c42c31c916da08ffc3028711607c7437f785334fce6ef267c9277907550263173d3a419cb8689346b008b62ee46ec10758ffa66945caadd6b0c77463b9fc5c52a75c467d5cf656632cf1a45e96701d1050452ea0102b5c42262d48dd975b306a179eb26378c40248d42a64341789a9dfccf1e5dc6e50b330371908afa5756c3563fba9ca082556bec539c759c6c5025f2fb377c265673d3924d6ab9b44b0d4ce5ee4ae210a8c5acf3b15c1da88a027391e29085ba946aa55b87938093fee8d3c9c08bb4e9cde0e172d1382df4a5d89c925be0666a618d101dbbc90c48d604b22b75e723ff5a026194db23bc96ecf5c2e4173376ef6c5cb18bdd63f7153ca3628747c9f8206a00e3e368ab4b034d4305d1ce03d57d17ebf2fa030b3de0c5c86bdc587aafe3b0ad34497b034f0a6b8882cbfe3598d2ce42c00a9342136c2d02488f7dfaa886c36e713f5224b2a6286c7fad4c17f29324a01e06369cacd53685db7cc7be332b99b253bc07da0a251aaa93864ad9b7ab7cb5cf428c183e671a5400f300d1b3b554f5c80e063d3f14a934c05c62606184aa647884de377bef3b7b8d456796af3904983addb77aed5e4844bf4aac8261c074ce0f0b4850c8ce432cd733bc879d4c62e54653dc257d7c816443a34dcdee905f26ad0d2608decb7baa59196a55441dffaa10e779a161798f8be77eb8889d9adffa523850078a8e5080890d802abdd60c275d18d416d8c88ea97d91f1672f07692afd75022a416a55c795155165e73ba5d50ba163fe47e928278d5fe907cb9dabce630a3181114de50d06a997eae6f00504de9246411126fcc95ec56f612bb57fd837137ab74d427ce2452f23711016555c9597316bd478cbe6871169fd0ff8bd654a64cdd7035fd65e88cf8fc9fab320419a42af5ecd96557797f4ed746f314c9e6a8b7f1fc97171e79d2839afec1b3537f4e5c5509e99fde776792bc2826b5fbfb6228385644ee1d9922764d26975ea036bcd784150c26e2fe697a44740fec4decfe08e94312dd65ac79efd67c2485692c15e0b3e17c0e10a9a4cdfa1ec1bae70b0b7443772f46c3860c0ff1e0a6bb7b36c4ddff8791a54a6b6be362020a771cee789fa153fbf95b9e4086f72ed3d5649d61cafb2f7ee95580932bd91f0b740a4cc17d1b04db7a7aff5452321eb208f3fb3fb5623abc793e5a71933b8bb43a73efceea9b7d4b94d78c8cd3e7b8b48cdb10ce55199eeb5c35911b19af947808548c9e53344f602cd151de5c3885d67f69e3e5089dbb754780cb9290996becfa8c9970e0e75376d6982af65a6ec2450fc00273b491653644b9234f157d5b342798d0bc9e5d0a0abfcb3acc391775126952932ebf181e96bfbadc6732ae6ddd27c93387baeb8171509dfcbd21ce8557d3a928177f73dc9535d87de99415704d50d34fb213562b0be196cadb41e99401ac55d773fd12a12a536a7b5d0b40fa69edc4ebd0c1c8e3be8bbb2a99c873cce734fc5e9ce68a9f67229e8b14b4b6260d6da18de48137ae06742bb87afbcfc60705d31a9e5c4ae0e3f86a144024389a1df521e0f8161c783c49dee3b4f2baea0477abc2f1175340dc455b44020743dbbf4dd16bf6a603d306ffb4b6e2491e9107c89d9e261d26afdf5b11bcce0b723670b530007019cc1117c5c7315bed3a7e657c185b6d40c510e167021af906ee6ea5918edd99e057896d03dc62ad57a32bd8fb74ef189a5e3abe53eca4079d9f1cb5dc1e55215ff24656fd28dea2b83c9999aacb9c689771e365a1581b72308160e710deb1cf7167ba8955d1271d13648a1da44028320d9f2f82e194872a3b7ba43860f4f97a5bfbf3e87e7c564fec5003b1766c558ab00e0b38b250043aea324eafc86fb911a56a6f8a4c584b6c2d0378e158c0049d666774b7c7480194b0a3410131ead40e4b89188b75663e5af606f02526dc0e2a3d08eb02c146cfeb9c938e3ebfeb6453f16f64d4492ea80b3fb830f13cc445c33fe0cddfec07b46883b7cbddd7df3b55385d3524138990a957b053cc2cf4d99089703e592ab350a105ee2a1fb68e7f51e300eb3ab253140928a6e86b5fbce4222a42e4ebd2d8e4b7354280cb9f753ba67af57ee6c9ab1b66b84dba5ff80fa88349f0a358fb0051320a927da8247d1ce6242a549afc47c18e9efb206c054128b8be6a3e1d61fe3b19cd5cad5dc6e648b24cab6d69bbbdbfccecf3593bc960f2503e2b7facad41d3e54b03d6f00b1085189db0bdcb65978b4378d2fcb1a2353e3ae26991183a2a434ab4977f60dac08c8f9494da4000224508f8ff4d1f1db386f7f8404cc02992b3510cf3076a45243a37a1ba73a02ceb83aeef072e06ea61240259f9258b302aba3c0bc3790873fa8e9d6482396a6d7d3307f48a47b0d21d268b88f8c14859b2b942847a20ed07134378eb696b298866491b5d96cd35ca0a00fac31316626d8cf62b95037e4e9c6d1d21407701babc181b8afe50600b965ee5a702bb553ea6bd1ca31d2a63f3d0b09f4fa0fa002627c9163a0a561457bc4e84ef1a4f10e5405354b9f584412d106ff93db382bedd3593f2dbbb6d819bd4ce2e6f3e77903d3f8930ef9e87c7e3063edfb8778c68743e864fc044441c370d322b4115b5be3663ad9d09871f905d3725ce0eac2067701a5889dac8a337d4569ac7f02e1ade500c223c8699f9efcbd803fb7b5a844c81af1594b2881192e59fa95c519ee673df08f568da92a1adda7c86ecedf87a11bcea46def83fc39ba940916ae11eadb1790a14189ad541bc6920c64fa3b64a99df6a5a26f39070c35dcff5e6f8411f545ee41a1e8fdbbed8987404567abf380cb49dac2136a72da2c8725181070304c942ad6e9593d921b9144e6d155f1eea5d60826f299012c9d56610f681278dbdb02179962106861a9ac53dd4e404544e10b6b851cf779788aa442eb3b2afe1ef0cb9160abcca020be109232a9638330ee04782b7242be70cd16be8c689d976af568f6a54a911e1076bb4b8ba3a5de00a55c1ffa3f5a3a199b1a83a6d6e7bb99169315af773e7b199b406225790363df61a10eba0e67fe2e76518c72f38d1348c451050527430570a159f2cec798063d1ed4704510202428bcc2accdfd67398fb325e8de53c95ccc3d885301e85904cd9bbb59b2eac3fcfcd04cb44334f843442332352207852b35b0ac1827da36eb79077815a7852437c1e5d1d757480909e181bf878b297e00ffe629659ac6c6a9a48bb07176efa2d22886cb40a3e10f174504097a4abb8ec70311bef82ce328dc47090ca02f248b6a2bc30710a1e289092483f55e1a53cfef104ab969049d8d899756b82f6d5f302e52ffc31cb04f5c31eb8e02297a4ff06db887ce6425a08e53fbee539d93c433b799e46d2b906c5dfbf547f5031112e547ca80304f86893de378fc66328de383f220a651ac21e1d0bde235fafd9112681503e50d90910668c53ac76822fdd8f0a146b9ee83225ec2745094e00467eb8250ec619224602941309660cb9b092656f958266bdbf10bce5ad6e09ab22621a431b99f6a07e0a9eb85deb1aa019fdd407abf05376517e1c084c0f1871b470d5ae381ccd7d78e6fd0ca6767ecd10dd140c7a4997afbb5ce2f97d80799565ef335e3a195b8afcbef129aeefce4ce36bccfef396d9d4ac6e12c23cb9a21d1fa67da1b6df9493398ecde9ede69ffa8200fbff3dc73584d1659c3f998008378bd59d840773c36d83ab686a23dfb9ac4f9eca4980a05ed4f9a5591b76c04e46b01f98f54e0d3436ebd74b0bf66d4987a468a4fe65d5675e55bab60302c7ffbfd9e8a06fcccc5fc3971625db7514c1f4709e75afd9d8e1a6edb26c67d2be95614f817c28f804213fb088add289e5f37aa878ed19b1f526a6de299d5a2e5e81614c0c18c0a9f0f41cb24442fd736f4f563a4644813b22a7cbd1beb6bfee270d0c99cc739cce45a233d2547dd30e355a9f10c780f1cad32bb4abec92ca155d6aa1da8776e76cee83cfc16da219edc3171be5827217195a5396fa50f4741ff2445c7c860ac7b1cbb58801dc36e8de7436be4ec6d9784e3e27ce8d6875bcb2075325583d71467a1b88a46c39552bd7ee2c90bc999e5d33b1d318625c30c1a8068efe4c85cbf15e81ebc42ef238854396385f9c5f2790cb54c0e88cb6bd94098d91af9cd2a86c7ac91c6aa275971e91d735fd815695eb075887f041e00763e47f6e488f7dcbfbc898eab9514fd7565a33eb778d03e9798eb669fb13628f97c20792631dfd9db3f3e6d4488f481d6653afaffd3bb8f5ec0e09bb1df1a77a6596c981f07df3c5b1b149c6d81d77c986753cd58e0b812dddb66628f661d6ce4930c104bb32e3bf3ac497e591e5a3e43f6f169aa6ef251481104f7ee8099fd8d25cb4ca339c5357424525d6361cce055f334b848d2381b06408e14f650cd4f259437186c156be465719360a61afebcabdd3dd7e5755ec0482de48f91ca9bbe25381544b25c42dd3d8d13d5f4ff0be64dc2c3992f194394f95c20cc1c030b1182cc2a6b1e75603db7cd612f524705746d91b7aacf852f96e6ee6dcefa65b6c00821c09f7321796436cbbe72ad55c31cf740f4e08669e7966d9d12b2f83304070d261a6c1385b9cace4a2065555ee150d63c10f965c48ac3fa12f86833e00bfa742e54d0d28309d9cba666beeb3f1fd3795138201e79ef61186a0f8c502eabd1bcd55c072420f1ab955b9628276ed65fb4b1efb06ef18d9f59685f98656c7189fb468d3b9e2f0eca1c5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
