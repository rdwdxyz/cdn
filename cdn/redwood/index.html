<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a0be7098b5072143900dfb0457770922f51d066f15b7a8e3150850ab1b5b2acc0fe467545c5236a8d6dcc49930c6688358d6dba697726653f37db5a014f43efb561b88293499ce3f120e79c0288fdf73da82f022dd5333a8e30268ee467395caf45e68acdef69663d5fdab5165dfd1d19d92282df3d653c0d3e980538f38fda626f7e07c5739258237f4d3b7c3f96dfda0ce2e85c934754325b18609acc482ec270d8607274ef9133d6cd7a2ee4dc8e93da9dfc65756ce0267a02afca3abac199a290c3ce30fc651b3dc86fe566841939033f676c8d3386b591e97e5a9a1cc7e751a97230c5e7e632d6ba408dacd5583d6f0d2f4ec1f84ef8895969880025b359eb45754af9c349250e445bf918a219dbf770cf4d33ac16581e482deec65cf92df3f6577f4de668decb7a033bc93f07c4c8e76f3b896fda07c32daa1cfff4d0411162cd198a18fbad08827bce4f512e9a70b104f1189e29c55229dfce86078914623293d739726b8ebd8bce7dbec0f54662c615fb879ba75cb3fe15809e64c200c8ad44af42028bc70b23db547474758da8f3277d5025f245220ee15ac5186575c5037ca17a1dbb6cdd472d697f0dfc376234f68f6ec73741872674d38e38029b55664417f6b609274cfd423925f486b4963d7d044f9b147ebc453750caa8263543daf67f323fca20dfa46fef780307146a9ee5537600438892bdd361242923996fc83bd964fff66ee622ba9ce1067e54a747809a9e871e25a4b7151c38a169dfab46b6caee720346769ba3d850bfef06db9c97b830ddc3b0affdcac1fa9aea814344f8a30d2cd43a1d107139272d4abd0b83edbbd51e7c884a30a293bd31b05f374358b930331958fb944b128ddfd0cc1dd9daabe60423af1b3ea6d6bdd6b8871defb5e7fdf7ed41cf1575739b9a3aa21dc99aec0d4f551aedd2378596095af45098345e8b8bdf8ee9102be957bc88b4bb18070dccb91a7d9b3467915dbef453b2d00f30ebe67ad2d6516896d4236102e3a1f029aebdf8c66aaabfcd8e4b6548c813845ec183da4978230e5a594c5f6d64a4e64396858b32516e8b7bb33ea5cda90feecd59573f8a32de63a785879520a3a8e352dcb64b89d85b5717aaee09747c64e119644c1dc164b4b2932a8d78571182e69ab7e4843981301a32d054b36150b3c7d18982c61d171e0ff8bf58f6e4a3694b861cb1cfa67abfb535843e5fd2d1fae358c39878f7d9f248f471fd6ffec273de89bdd0fb65fe6c015504469733b6198c95a92c15cfd6158124a48452d60ce3c2264a48fa1e5b5aee73dc76fbd1ac07d4c899b5fa3c117e4104a1edb6c152aa041c7571609622874d3bd54d7355961064aed4742b4f6fabe8b263f6f2294b54d24040c2e5fbe9f489274a25ee87348e757e6e15ce27224d738561c194481fe5d098dfc3a62afb4790909f9b9456d7238ccf21105ed470a352a436fd6fc5537c4afd0594993f478335eea83db44d242840607eeb545d8d6e728174d470c2499ee274cb5e784661896c26c158eee0b1ab119441e546184653097b41b4791c9962972af8a542d8750ca95387db403f2ac13b99e53d740b89cbae5bb8177513c67cbf90d953a69ea3043a34c22a91d714ca2209d9119866a3afa11cbe61b786ad2510d10c08cacaf5f24a7e44f12b106ea746c4d04269119116da71521dfbdc8120ed53d86905db550d60446510b73857e73eaeb0ec4915145940fc1def6e6ee725d93da001ad4c848db21813fa0259e2de4ba45fb4d688079a20f7c74c99ae2942ead4021fe20e10604fc00b3e1b158cca75dccee8cdf0d7b105b7351700d19cfcbd827053d8d3e3122f08f6664e86087302bc68456fe8aa68f5e3f56e109db87683dccb23d43d69ae12f10a8376f1899244cc57aa9cf8e26961b82c2cd4a65164bd43b81da3750183a1ad2d4d21224673e65f818d5e812ef1a9df9144e2faaf8bda0726767c6c56ce92ae51c28e4d7f32d9a9c43dc6dfcb5d4d6d712249859c1d7951c7f3c51225defb72d9d73f0b5cbb32853e52d818544b7e568425b42bbfb6e0b1f2bd2d560be8d84e9e943c3b8674765d7a85f3a558a890266a8a6cdaa4d596d5f2413419088356bde4106937150c9a17a2b13372d6d87a4870d7ba96fb5cd1a50d8780109310e3255ba739b60dc91abbb9de3da0cdd455a39901f4c3d057d96ebf3ca1a60541bf0f163829438bed43b74150c8189c3d12e9f0e7612d78f89ec96a65c33e1d698de2c8ec31acf82895eed2373d29ce7f7647ba685361e1183ea61b8f129828854312b33b3f5aea52e635a289b0e61159db21a198b85c461eaa6ae94c5c8f1225e42c99087cae979957e0dc4eda2c1fc8155cc2b58222e299cacafec950aea08ab3b52756e574c758b5dad87566babbadf8f79b48a8125254f7ad69ba7191729d466fcdbb206b082f081ae00ab8d93c2d7f009858c87a9de6092df6a1ca7358e328963ded36cc8dba5d1414fbf3f361e4df83c450afc84592be680edae9882dc99118e8166bba37b4ade65592c7443ed9c482d5b3e6b81efcd763ed9d553845923138e3f5de3f496bead4229f9e9b105b6fc5c01d999bcefd6c30e1cd7008812272e0d277abf0f6e648577551e2c752dee69395e8c5e56af1ac7b2e0d35987dda7edb274de12dea54df9817617523d29852c8c9b0f6dd0f2d028a9d8b8d538cee67e1c66b0aba4c21e063d2697d160d423988af559667db399d201b90a5e743b551a2e05bae21b0defbdf0226e45fd152efe2e4d9771ce69e476b4eaf3c81adff718954eb01fa141636491a34d9ff458999076b43a0c3ae98bf6ab2e92aed132741b548b7091f262c31121bf0efaf7c063222f690d107bd5807e1e510e8913cd3ad3966fa65ed2b8ac3dcbf31d708b179716693846c5a053864ea89d766fc30154c0add15aae895750687bad1cbad20af941c8e7f0b320a839be107ae301bb2e15f2c5191b0b99ffccb2e215a4a45609c02b7c2073c2d25fc9f36c2122c2ceb244efa92ac4d48c7cf71ef0ab211560454220c936e9b0ac2d9fbf4100e49c1bf2936911ffa3281cca87448ae6634121761594f358b74f68d393d3efe3e72ff923553620d70ed2684c123d8f47a83bf34443cfafb3486d0f49e2703267e9f6c698d4216eb49bdd84ae70d182db18adaf362971ede8e8af805328ce85d2d3025f08dde88a5f547a7103afd6ae24644f2ae69b0d321641bee02dfae490a3354b79efefc1932242c5376e1c9afcfa161a16d83e9cc530a72935273c7ad2e112057a82a3aaece81373fc51ceac5b8e5a397de5ec544dee2a9ea5fcb4a65cbf6405ea32d2f4793030de40bff2b3a7d181605e182b0dcfa02bf599d02f463cae450b546643c5a37f9438eb4ee6b34ad30c516e69800ebfb3b1020b0ac2e318534e1720b4a04c2220f02ac44234d3295539e42ff07954c1cc0cc4b5c8ba535cbc1d157afafd5ef4afd261063d07bc6809647bf611f07b927b9c153c92bb9cd1058b28da01371fe7b12faaae9117e6f279b56f465a2a1dbfd443e86d632a82377cfdb912a9a4d13054d3e4cbc627514ded29e9022ad9017644d8197592262fa37e7d50f4562885d9a6375e6166069a165a475e26d34a26accc33c47d39dc6a3cca44b99524977527ff81fbe8273dcd3c9f3aa2d8f65797c266a4578740bc03239e8cc542bf18b528eb4b586eaf15dee1bcde40909eb02f5e1ace7994419dda049aa78441569bbff412f5e2e88f28ce3b78f5f36cfc1452400ec7c7b9c1925a283b6004b13b843052096f687febd9e071dc4048c7c9a8a2bbc871143cb04eaddfe04f9ee8b40678e3f5bc2432b6b09fe21cce371601b751d645052257d8ea334850d6ed034bb4999bbdfdb4a53bf4c730c1b0d584ce0e6b90c10f9f0d1b15263dd292123d98b0fea86a735683396d5b86667b3bef790167424dd2398ad3b6eb3ddc3b288da6cb5481e2d21cfbcc61777b1c9b7e05b90c4ffc9caa5ea7e668475043ef0a6df35ccc283f2c6faba9d28aaed33e8b14e9976a5d31ff1bc24f27f2c69e0a1cfa6491b0eb2f244d6a196ef318b85ae5680582ee0d5a653668a88b6ecb4302c38e8d0011945af8e23356c78fb10cc0871f2d776a1a2542a36cb46ae0a0b50f4d6d4a5d1c7407447416e711d0c78d16b230b1e68e4d6f4e98e19145a69c31183046b4493fa34138e1a4c47157821e8c5ca0d7e2f61ffd73ddfa62a8380f0c74a46993531daa81829a5b85334117d5f7b6dad9b44a6d1cc1882c2c8314365ccd3504e6fccdf673c7e216a9ad2cecfb9c8ed150441beee15e94c126097d450ab01884aebddb1f2408b387982d2279b2c057ad07c0bf19fe242b96f811765c3b9d91b70def5348d948e286ad945670b98fc1b35bba21736f447e2252e4a171260191ae0c0d4b00d03e9cf048e61bcbd23503cff3cfbbb1fb3d393438be77db066528b8a74e59ee874789931ca5d4dbfcabfaa3712858e83f8acdac75fbb429b36717ca002591e6ec56a2a3bb25bfd5d7004d4aa4ada362213affd72dafbe42c6e678939127d921853d26ef67b766412cd8b67de48cbacd7aaf87e4e90fd672c4806130a84f13351fb07fb52a8c50144ef93e21711a15ee3e84f99418f7869a79cd1695959ca1a4105ef6dfe41acb39860fddf1521c9f137961a389145839273533ed3edf0374d5361535c85676d00bf55aa41833388cd0219e59486af8dfdf6fd8c969c99e71d12c0f84475b0c701f6b8512c2b4990b8b3c8edc2b646691b4efa96a15835febc4dd7a595f791d6b26e7ce1842a7927f3a5ce5ca1e1d3dd6463f4f93f03356af56bf1e0c6eacf5148a2868370bd2d71d614cf0c595538c023f3c2e25f818c45d0f732cf7895daa50c1b1e9c836ecb96e70176bb41d8717d58809cfc42494798e5b499b0eaaa4d5029ca6bc36b30c4548e0011c6c2f1fe9304c77887ff99491517d9539b6c859c42181a2f399bdae647bea35e4efb222a2d05308afabbaa5e124247e9bdcfec0d2b202e345f38912e2f9cff220226bbaef0f9d9b6810e279efdfa93f5bdd94980acfdf1dee4b9c49aff93205577d8fe6035b91f4b84fb8a6b7be32527d83b4583371d6c3555176649a3531b19a2583fc7619fe2b12be8c922525cb2a0ea058fd60febab29124121e082c09ed5b349f92a965aafb169bc910ef4ae5add71a4711c5e440e3bb50555f64af2002ca9dbb31e59c644d371a81aca1bb756d9567c6fe02ab4b85a8305f1f2ddb552828418ea61b057d007d1bf4a76cf9e81b2490aaacf64157fbdfc357936edd7c35b337b811b0d5c3e46ae80334b74190c811124d86fa68f8efe6a4140aea0119d3b3cb7b3eecb8d5d0d12fe01e420a645352ffa15bb175c022b20274c9035e98e157b8d375b7752d7732880a0242328cbff29c49a1a38fa48c206adb0430f6130ee5b51dca975521914c1b78be28fef6b9c33223c8f485a1329bd8272177d1b29acc36f91239b88afc02a0b91fe3160aa859d6708366db919db4d088d6843fd3743ae0bd4ce6768b069afef0f0fa5e078730b7b9fdb5d84668cf100d3e7ca536948583c5584eb89e885776d0f77cb3a0ce6c1be4d03ca10c8ed6f36cb0c896baf6f73149de5cf73933d1bca2ce12cca8ffa8ad3d2bbe3f4fbd3429c07475e904be301c1a246e551e3a1e788bbdee90dccea2a57e9f972bec62ea0dd2a3aed13f2e897786ca2884324dbae42c06b3cec106a1f87cfd6013231eecd99320de645b1f6930d99bf2324bdaab36a7423f2f4bf287e8dd848b3adda88789c0a763ee23a9b17043868ae3e0591aa837c74711bf468b55e60d432f0c674c315d9800500dfb775529b6d07df83c2091a06aea8f512aa3158f54f39c012a17ad6a0abb72e65af8fb8edf199aeb875cb251b5322978ac2c24cd2c6c2579ceff41b24671acaf748c4a08ae1f83159da17eedf77dffae7f4f42b1f87cd2aed801249842b6fa0ebd321f15198aee53b012174d354acf49fce731835efb50e29dd778d2dfa07e4f9204297e142352d0a618cd19109c2a2755059e6121413e5cb2a6f2e968c7b8352ac40135888d84803891067f67c76553c7dc75dadde8189f22e0ea814d50cc8e4a6c9ff79ff739e0c9dffdf3840c23c65b7a828b74ecdfbe0067318629fcc169f3ab7d68df5557a667a83e72313579e9f0b140562e1d439ac4853c19ce6d1bd86014aa75d2cf6db1c0f04e8d952988b31560f668f04fd48088c9fb1ead56b58a1c48eb2dbd2bf7bca4c6d202a9f20cacd578cea02af6085eb88398dc4a1f8f78e7b1b49a0f2e8f74e0729895e312b4b859f9c6191aab86af3bbde78da80b547d712a5a63e4f5f33df5aecdfd45f017da5281e7bf517d1ce05925b3cdf28c408c0c6b0a89874ad01838a3883d832261602d5df45e4cac6b1558ede728f8836298783057aa4a0ba28b57dc4c70b6bf69aa5f28576e68abf2f660d3f2fa253754e305dd2b5e55effb86957ea21c504ca4dd54f8c6ac7eaa40e35c69b5f8281506aa443a319bfd9db099ff8e56df8c5d725a30c1def0677e764ad0a8f9efe78b1ecb0b948ec5fcdbe66bd69294c8b82b00bddf7568e1dcea127cfc2e45c57acbaa38d8de42cb1fd12cbbf7d9a47b06d282570f1474fe468d01ae62e815250438e7d1dfb49678d4690fc8051b88587ba1e524f499c0d54f859c35e6ad242d516922855eb3bed6902a08e709207f12ba49975cc47abf8f086addeff3432fd53e5f796179810803e3b29983c9bedd0aeecb19171856dbfc2a1037c3d8af21c5035313f1bfd725701be60c48b4dbe88fc67890cd7831f074cbc58ac2badf54edf8e1d2e14bbbb8dbc3968b101365512341308e40123540aa4ab2a44ce8bd95329190c6e78099624d0a9635ddef180de445277a805b874fa69fa707a56894e47b9a5611f71cf95505a2cb220f1779dc59aeb83c2ca42a198bdb37a407db8023e7ea1e57880cc94850475f2e04dfcf6d48fca7975efdd14712d1037e9d9a9852fa5bfde7dd31f77126d1dcb30f6620d3f9d3f857d385463552a5bc0440c3280da79053e1b5989b44907eb70d519b8b8d8cdbdcce40bda969b738d23143a7e21675f75e8807f952b182e09a34cd20b6987764ac02526081e3f8c1320a0fedbccd4dd022e90e78e82944688f8228fb2e15a8ce4e1ef68de526a3ffaf8fef1ef46425a7b939ca05cb761fc94d68835e117c262a8dacb3523f2dd29105cee96700900bf85a97bce9a0ba51f81ae6d52996519aa904b8ff735a0dfd76ba7061d50ca376908b2ed609571e6fe5ec2ce273d04d283d6514bd1359b857a70863a4e6a51a00d7d6e45463affe407ed0347d582406ff6c97440976ada3ea10cab6c579e2d69d2800f87f12bbf607ba0d37f57aa7939c7aa2d3e796f0a6ec3ff6ccad16b6f3cd7b67ea95358ac92286109074cba06724c2b89c0b9a4f54a782223b5b433a7577f4733f30c4ea6dc483f856d65115b62a127db0fd9230ed91fbb7c377849e65e38f50263e61b21491f08d290e34e1b702e5013f4b1965a83cce6cc7e89267839c6069739bd9f2cae94ff476d04dfa60a3b4a960702cc2c7cdd553115b04c7480e3397e7797685ea98b4bc676dfa695740f7a2484431a19375b6b001a78fc6322df589516c84d2669015350d17b9359928a9da6319e0cde5e084ebad884c0f65275a2f5d04d2c05a5ed6b56d341101255be1cd89f60463e9b23767e915819160df472f735510895103b142c57eeb58f0db22ccef3549d79dba0ae38532174947bb211276e192ccc198385d0034b1c937826c6f4a79c938842f92d16a7be6a4055e290c1a3cb47832246c802764070e1750420fd8d696125a8aa41a64f937db3819f45fd2bdbcc90c472577325b530454e52a2c3ee62cf47865da0c384a9ccf064906432ab65d1c9730bcf331a76f658d544df8bd61435ac57c3f3393ce8cec789c95eec58a4af9c4ca85e9555937e85387451abcf1b542e51fb337ad8631c05b3b6a77fb31501bcefc0d51f1f34f0dad5ebed8c9d46922ce318349f4a63ac93933ef9b4bfc1184b4651e587ef6c83fdb78373f641c76b66a0ca5f63b0cabffb77010b0cc0c4789026830e95c1a0a964945acc8763223f9eb7eeadd95058382572e4769edd80d7c76a7eda65fc1c3afb0f61f22dd458feb73b6fcec5c6159a82af4de29bccfccc8a58395cc9570c09ac5e20bf7c64300275a08c7ff2aabdb220009468136a05d978296b875d78f57bc27b98ad5447fe5d102a2b30f356858fa33eec8792f564262a3588d74204206e8c47663c4a9ebf97e51fbfcff4dac5924db6ef5740c3efe4564ae67b9b40997c3e7549ca4b603a1eaeb97efda51dc6a6330f1d41b5b9b99de7d2e0861d639d78109cecbb222cd9ff8ec5246dba466bbcdaa6b41038f95b614453f289f7cd2004384d189e3d5b4380321979a9e04778043739155cfaaa6c3e04f173bafd4b6a74a050445467737f0f57d2739e1abb0e802fb04f42ca47f780bc10eb3b93472244f35abaecdf67d3b6711673590c25883945342ad3217381db4ac97463255c416b75b91ad56534b33a09f3bbda5370b776ee945009768e45fe972f161219410dce4b3051660e9689500d8b0dfbc9ac4d075061f8f67a8c197be0655bf2a3f87fa62fc8061c1dbdc450441288235b71ac9c40a01786427e36e0e00fb80962d15f5deef8c982e12a4a91d0b50bbdff4bff559bf528a8ee76e2304febda39760a97ed2375c0a206df87ccdc99036c2c62f366aa6569f011d6abae338a138c1a8b82333fca6ddf4c082da74c7f12c14cae8168d44f5e79c01793f22ea5d5892348a40481d9e215aaff858c22632f4fcdb530758a3373dc859258050b59c2c8ff9317d6c1171d0aede89f286dab6f6890ba311bf3f002076215f3fa2c781314e0e53160c931d2781ef11c31b7d9b69b60b64bddc486c958b532a7c3189957ad7e558b7bba8a9596959fbb6a9ccb6d02e0e464ce9ecc5b2c7a2f10fe1b9bc00c8cf200aeffaec01e5f4d24780335e1db181fe8f38e076bc0c59cdd05e9c2da608ef224c9adac1a055093f0a6bda5b9d09147e55e209b9a765647bc8cd00b2cf6040912c72995a946e27bb82b6dd7acc5211be9c5631bf901f6159dc467231d47947b77a328fc1ec45eaa409bada590d0a7d894467b0a60f1628be8ca155c9f39d63127b594dcda1d1d0458a92a651186512767aa94b4b27cccb7432365ffd6cf9240afb6a97eb8986dc9a94aa80571f3695078206f7ecfa78d8d0b18120e0323600537beebf67ff068a55f9e9177cecc49638a417b09617951062c60906b8f54717d8f25898575ff94d27fb29fd4325f793a6ff39ac1368cb08f6d54677e2523ee37a9ac5983979ce7f93686ed0665def6c9172d6db8f746792508c7661b748690ccf860b8d15c6f757cc249ce6d65120e8864527cab22582b761782f6a504df40ae3cb2dca02da02e85d58a53525608fa72483711acb9abda579ba4f842cbc36b51d73390142d949abe2a4316838025787fe42c4647a626f0ef13c234ce10c6758240b58d71f2e7a308132eb91212ceaeb333f960de261be74745bd80c91c793ef935e980419bba91252cc26eebef22f596edc1378bf1a6054693b0d3f1085986463af7a226eca14c2ec1ff31a06fc87d3094be90f17b0d65fc45e4ea49f66a5f899695fd2c02b053c776898f705290a3dc3133583660dcd75d45a92dd07cd76d4a7b421f9f55a2bdab5413e4a61f0b7859002116fb9544a9697a0019510b224ec3dc1dabf35203b7e9ab5c44b3e352df8669bf3ed0b745b8c7973cf4cff91abd6117854225282595cd4244bab9ae8879765e6209d3f20c44bf1fb411229e8deb3a98de10d19782a91dab041fec19fbaead0b2da2b13ca948404769787ab0beefe8c16a24a69e4ddf4a3998ab5df264b10c82d2ea916b39b75fc9a52878dabc5e0185716076ddfc5dce47c02adf98ac2db5a301deb0ce09e06f3093c8b4dffeff48d10d3f5a4b20d8837f85562e68624cc91a642a54467989971a9b6051c6744d13ce3bda71d717974ea215196b30595fef6c9c5ac76c14bed2aa64679629a23259a5bcf9e5cb96b3bf47b4b7bb153f1214377b3e24fa95d68b5f9f547afbd06a3abf66bb3a58191ca51adfcbd5476bdce0a4320e38d9a2680f787e4ca32d4c6c9258bcec9de833a751e285a463e63bdc2993daf2a713e4b27078ce541fc0b3757ade83595d5e9f158f6d632d6362d043fbb0a0f7ab98f22dba20d4949061224d29380d145ef8be006a7b82be9e0580ba47efe4a9d4eacb3f61b7e3ecfc0d88f51c876f141233d039bf13a660ece58175e1012dfd200fe94a658d4e8753c45a99e400e48596ce738d9d139d078bc37d3a714aa10629dd1f8da79a7ff9e0861abdb1b9dd4df2ebc51c80e6c5cd352a3a32ae3405849861d942f9a791ad36296b4533a9b5c93d71f93f5472eb366adfe9d0938c0c59b2b5eec9da1b4c9be710c66a8ab037bcaf2730b279198a6d7c4df590a242e4e1db721fbbc2516ef30cbbad523ce764f145aea6f71fd3e27b7abed9329e5d7460a1519f51f9c2347ddf8d8dd0b9c006ee2eb7e8f3c3ad6abe7e5bba5606601097c5227132d8225137cfc94e623c6e6fab5a850187e30089bf25e84dd25297621db78d5c07a182ab6ce41c762c0b7f7af71a49b833fe9fd7062ffd1a1cf24a674942a5c679f2ad77dcd1c5ea6603d706f5d3de30f0a4c2496319afc01c4f3cb9c5a75109064a7c67663d3897f2da22d534569e0b67643dba93c06db98018360794687559e47c6ec9d3d1e9ae6cafb539570e5728d7857758e4fd0ffcbe779dde96da39bfb40f14a519abdcc6c6422f53e0b7f32802b07f4cccb250e34dec71eb534d5abc02e959d762ad3bda5b675b91296a920323b19e6768c8f5d18d5368d052f1e6dda19885fa21ae6005c344338bb6ff9acf0cad71f2c39bc49cde7c1bf8af794c927c6a96a782b3a4904fd9ecf6a39b532b80d986d822006cf931f66098a007b30da85883fb0775f8f1adc574195f7d6123bdcffe06c9eda39d6cd157bacae56c1c88362bf9f03e12b6166eba56736b1c8dc8ebd55861c93bfe1b9df6c40dc5e532776753d1feb0f69dfc2b31f044658d6c6851350af59bd25882b60d1b2d70853554055f9f0a64dcc8fece94f3bcfff57f2ca35c510c4094e132ae50b22ff0e75d5d17240d730b3674e0c8d0e16d972ab80271fd1cdab579c819a9f03cb415a41d7767598a9818b39c536b6127f397413aed39b4a9b83ddfdbbfb04b01edb4b4a24709dd2622f8fabc83aed64e0e318b39746d5434b249fd5b1f18c970a768afffdc15b78cac64077604b42a36aba52d070e3cfa209a6c682c242e81c650a7e5d0d515612b6873dd8d90c556a22f25aed5167d2a1f35b24f924b6febd6e6c02fc8febbb41be6cdb794d9dba1dbe9d3f0cd904f687253d80ff959df06ba125eb9807e62739cc0794f37f4010efe2bff83d7bfe95573835793fbe859d6e134628b933c1a2733543b0bbc46d29c70ca323c139ccab7ea87635f0b59636d3ebab36ece8727f17e7aa484605a2e52bf079ee3973baf84d0cb7b8979f6415a9f03118a306e2651e8ebb1149649c2e4ed25a80091bdfde0e6e89040666cd36ee508fa8ea7d7be4dee0a151f886393e0661b830e8cf0ddc64e9ae9fd30ad8365d0a8731e7a3fb77350593f534036bacf220c5e88fc37ecc946e1b90b2a98038db442eeaef58d1861ea6e18c4926850551a7ec32e592f3269d6222fc1fb2f2735346343fee9dd609ac025706ee0d2f9386b7b2a9c8d99f572484b54aa8a789a805aeb4de959336cf23a0485405051991b1a9812cfca4da50237874c3d5d0c65fcd4fb94e5b1ef84ab983ef98f49de2955c1a589e3f7a3669d62e771248d479556f3614ecd233ee2634729c65ff1dad2ddaabd7dc568f44f7ee42591bbcc937a1a6834c525b8e8966ed02d73da0517757bce1f0a4a5dafa6025034dc7fb3a47367e566ef8ac77c70e4f016d585be4434fe0047630b2ed9d6c81c922a8a29559b6affad81409fccd56ec66380553d5946e6da471c7e18730bcc6e35b264edb572209afdafb20e894382d1a5c1fe8b0d67cfb2e2770a401b270f6e27353ff010ef4f99dd40e65b88240cce78b27bb2f91dd5973fc8d18f50f396ced1ff2ae557d0389507591d80e4d6a4ce4bdfcc8d78d5a7088ddbfba625e9fae010054486f7439e5577f6dd8bdb86ebe45677823d95416d733b88e14335af233df9b7ae2edf587f06a94ed278341f3c9f1bcfdd9f859db4b5c48072ecbf080764cb79d5063ae498cb7ffd89c4e30f1b15c25dd59cf47c55fe874251ca3b2111d6d7f01f3cdc754d814c30f709f6fd7050f939a83621b5dbfebc038d224bedaa90aec53eb35b0049e1e3c1c1a26dbe6481311aeb5c3b2d272e27dc7946157f0dc18a8979a2f5218bbfa1826359d6ff2bf27b9967ea7fb431de856a8a542f4978a9fe18ff75d61951f0efb777483865c6240c9d955665fb621ca9897638d8f5f6fd83deb79a91cae468a7e2236eea2e4e73d6afcffe1cbbefca630bd778c4d7bdbb326234ce5fc6cf90714a3327edf6c64d56f6c74d49535b6ff0990dbfcb333ffc5cff96639c58cf4db492a0e77d1eca06395cbba2ef7bad1bb0685269b20f5f57b669f0115488cc9332c55c5861f1a634554dfad9149cb91238d8ea8973a28d73a0b056768f695b5fd0d3315d787cb918ec046fdd5c3587816d38f0df9cb6403f5da71c001ae564f4962da53d6af0ab69541dbdf4bc45e76855e41859c4edba123b3639bbd8cd5df64dc4b357c43babfcb9373ee43fd25d5025eeeb94e2299ec0eb572ff73c24b6829159073a2d61206d84702b73a123b6e1243c3fb09b700cc8ad0ee02d0862c8e3845513704eb8b7500a6524c4d10761e2eb7a30c046b8db8685210899b22826715c5d03de0d011b75d41363b0fbe849cbde9b321b7f9c1f15852fd39cb192b94e3e94c1962f06fecf694e2ceec4deaf086226c8f414f9234888336cb64a40add4f13c11fce0e03a9e53d62eef2a0149645ecc1c4bbc30804fff41cc3271a79a1ac9ad69d014a3dd16fe029013dc0b98350d7b6669545b13697b0e0ef79f3b065c701dc16ef1048831d1bd6b32c8d47328be15ff3684421c97badfdb704a586a20fa8fc55d138b4512c4921ab3013af85342d37cc2b362a2400c6d5c54d244a34b4da6b3ff098dbb52cc4ddd0fe2df1edcaee7ac0ccdba74f24ce621e4fdbf0d325337937596669bab8bfbf9c6ce685174bfd8c59c6f8d258d119e152ab86a683b0c6a2c706cc6833b2f27b328debd030d9ca472ffeadc60b1de2862fc958a7e01be59d4ac3fdcf86753a1f5bdd71719282190faf5214220bf9b2cc922b362e28e015e89b718c889b6200834604b405cb2968369cba55e3045c98aa3da5689866649ded87c21959e752faea4025f94cb59cdc68a6ada67457bc073b7482f48816ed8ba7a1a1df5a70498aa911adbba8bea5fe135079679b5e0b07fc40d813d4599db27d90ab7909563b2d476ba866388793cf7c1c132938242a63b9012a4a5da641cdf88e00203e3c005c686d324304391353db35dde09d3444edf376490abbe3d280d0fe371c14517769014937dbe35bc54de27857b77d43ad5a8e8089dd776673ea272a272932bfeaf04e53717f5a49d76b13629fe48efbc28777ac2c732756e097e9376432a4bf5a74adea06c3406b50c761ceaeeba9f30c9c42b64717a806285d1b86646db9cff6aaa2534e1d4e13cf009099a6e709593809ba1e322bf3869037fddced4aab739c50a76196b5a3d454781156db04e27ba1303b0babca2fca64741a7c2399ea5b35d148ed279f97d388af87f4c3fade62d04b4a20d2542ef718df3be605e19c0811b0df068637bf0ddd961d6fb6a30617b7746fc2e7d5144a754cf9a738b3997b687ba6f380d52e6acd537d084600d14f6094541ae8c3df1cc5a718a9f32c3fb7ffd92a628b470342af7615f8168a6b33877b61b13a129bba14843bc2d3fdcafc4b0be887f59b54bbac26233665e620acbe2c3ca08245533cfbea25d4f3590c05188be95379e3c8cf06c72c2a97ea739290319b018c51492d00e463a3b3b4d51e8fbf14ea3e569ca72ece6563eb41a3f52d71d9e7c7d4571ed66054db1714986f83b6bb8af1bb8664f10f2454f6e85e75bc0fec7e93db4731d8b39be65cfb2506edb721cadfcc18bb6ca07a8ab57187f8e6d9cbec3cee0236431ab3b4f869757067c7c9b6b2dcdc86f017dadf086f2d8b6e620e07921502c33fa9a5f244d345a104d5a8210d382f036694620b03eb0c0d2a695a4c9de956f89e12814ea9ff844a02649344f6e4f28dd616a664f02404e202f21a37c418fa033f364d015d5306ad6db123a39d638bbf7a02daaaf209d9ab3c19178a3783c49d93f857204c1adecd326efb69179187b5adb2b3f9e5a4c6fd9eec337d35ba9023efba6f5cdb36a9e58a35c93ac9af3224fbf4c97f8aeea227422a8ab5ce2d550e98cc438c798d66e08fbf3be548ab255249cfaf26b72e85305918e4f31bbfa1da3f26ca1e31beabba62f36a0d736e427552f38ea6525ed2fc247a661fcf78217da7a3d9e6c5a7ebbb911312ba3b5c8f060588b78edd5bf327fa91c2d4178df3694f4402ef52fe6c46902e6d1ca151db0b019783e768083b05aa2a4123ee0b9e7e83cfaed4b7384c096fac7fa314a2a5d4868735507836f8a3ef5538b6e6af28136635f298617e88b4383626bd729fe284b984302d47def85c3f40f4e11eb8036d2c243594a560401f8b243f597c0ed4df10950779d973190a48811e6982ca61354078411753640832e805a1ca644a55f69e80860d499ce2587feb76c6f984e0bfb8f00338044bc34baa4854f04f78f3969f7ae1e3987bd9b48e62c669a2e4313890eddf7087e5c352315428553794114d537cb4f011317fa1955b596b0653f9228dc364154fdb683d94cbb9c8c86ea2158406778d8895cc3fc12a984f4804f3af1aaa8895546b0d34aa392982573abf78fa95a27045cbbac5ba9f1bced3ef99bbb2cc23dabeaa0e99519ce2c6aae8534c38370338d5cb15ff1b6730a140e391c24e40e6d99b7597bfcc03762b1e2dcf9aba2cf7b4b64b340fb84064326149ae2fd5eb1989123c5127137b1bf8b2306bb58a36631a296cc9986a7799e6f1c0f29ec50f3ed8a3908c0c00a3f0c91944d0a6540016cddd76c33d34a2e3c5fdbf9017c3ade61c8404a010df4a6332831dc564eadb0094e13ac55142e79671c77bccd332edfdec212f1517f368b056f5ffbfe83cf0f3499f1c2efad43d9dbfb38ce09f81813eb180b93b4f5129a53966b8675430d08ba7a1b879d4034920ba8330459d497e34747e941947b1aa7b208abb6f1d2baee745676d8d6c3fe6037e589fa304b7d21836b3bff9738efb1af8b66a13bfed08be3c1c60be22ec6073fcc5c64bd21f2dc9012b533022256332ff4e82c8100ef11a836c02f3af74f5f42621512b60a92137254fc6e91a63f9fcadd8d6cd34d30230f6b72df03884857d6e69e8f95ab4f84a9cc024c716ec0fb21815062b6a3d6e29fa81a709cdc23b02bf3c56a372be5410ace1cb37f87de3b3185d341ddf1a22809b00c0ee818b74b6233d28671f14737931ad7925526eb6e5d9f23033d0554ba1cd979927324a7a00ccdfaa3682f7ca61403a6e3bcd4ea6fa9214c613aaeb8c7212c7b554d56b798aeade3d0efe3532f18e4d3dcf1b8acfef6646e3fd28ca0be409907fe5b0be0ddb1bb0f5ec515bbe55a0b9a892711f479ea5b59d0ef862bf2264ba662a4c7e3d138220f957b0491c8c3b888b5581dce9d9dc56cef5d019ff2a9f9b7fe56fd7f584bde39c502e250cfbe3019a9b55be3d9cf0b887beabbd25d65802a4fc5794bfd9a269caccf805e6724bf3d86bedaa728b75b64490f93cc3a82aff35d01d78e9249d57d9780c1fb783ec76e04e3d0c40f011bef4c4a9f04eba3adb3e2a3a3aac29743c1155affd461a117b3d390e26a92d46caa966b4ef6dcbde9eda2e7eab2ad1d12cb148eeac12c04b65f5a45ac3258413813798b486ed948e5d4868c99238395ca3a8bad02e1d2270c93e8588deb1783c75d8679b8e0dd20b5ed9b2e7b06abc4b4f6710be183490d9cc87e6f464f73e7201994cb21d8447afd1239c541398543fd3e4992ea5a0efc016eac5ca069b929d257c46db645c53baa967a7c6000d4bc3b3b97bf4710f4a19f856ef91ccefaf6f4d106a64330d6dad15fd23d0089ef0d8397ca5e175123481f938a2d040ebbd3b5c343b41b8f873983931c3003f515b5fa31536998794bc49520872aa36052a655c705ab8860b3b2dd68f26ce02321f04c5817edddc5756bd07bddbba9d70d2ca42fb7ad946e4a27686ad5fd3f5003376e517729084540074b9354666045e2ecab278b13b57d0b9da8735af6dc036e4f8e87ef8f35bd37cac9ec846e4752762ed43017d85c94a641b6ba5461d310026c461593cb572a5ebafd1675bfc404379cc2e2403269b942eee96d3d696024e615270690f0dd8b89e074bd82e4eb327e09f383aaa58eea5377259555cb2fb92e730b761c8b5d2d738d565d82cc597a0245ffddddbc8c84dec639c35795646242785464d5097812baf2cf24e491a3b495a78f5ae9589b6a7d9961cc2d11aaccb7933c3e244288a9790ec9bf6cfb5dda82b3f36adcfcace502aa350da0a87b83dcafa5f74d0a595be02d9685b310bd36c328521fc4d9eb0a36e70b90302e212e719eba6cde2612c8ca7d2f1a685f0e2967ca3d5416d42dbcf4d60a9e6786eed11d974f3c4aa541a3a4c78886d2dff5070a41c8d7acb9728a84aedd722153b05303c23ec8729bce76d51c622dfd06f76191b6f377e0aec485c7413a05db0ccf881819d2569c2ca5c244e11dd2a5168cfa5acc879b83dd8c71aac12336528f766019376a505e93054754e17de9b436f9c22b60bfc909726c880cf8aeafb042f77809f020320076cdd520c78727e2e621a4c17796d9f4b64add01abcc6ca01bd82f1856971495f75fcb602145512bc1035da58869fc2f889bed72c918c014053a4ad1c4a51c5d04588bcd8850c326237135c75942e6c053eafe806657307e98ba50e3df79ff07e8f8dd18ba97f88656fda2f01c610156bf191134a8df2958ec924992717e5b83b87149a0d7ebfd5711cadfaa0f720d21f2b7f88e27f77c234df31a91e1dd367c68dd5733b0eae0a3d2bc57f5c3ccb5fa05f2a066e52eb1e5997d9a4c2434a761f1e084ea2a8b3de133301a6536ff18757d586f47f24ae4047bb341ef97966565153e8bcd02916c86ee840db2aaab66d5cfd560eb8a4fe7dc3ae8de471b6ac098b55e04119f8146da20095ea58d7b24cad7b884af78978557b5a2732d7024f66c0a225039c43e0c78a7b47b4bd21b904dec874679549b6f0a70fada251ae37849dc3421b5f67933595feab2c0a0a9247ef2fe4a02ee5ad4651e94f26a24b1f6010c52ba09e4d543bd12410c6cdfe017c0683f269565e6b6265a310a4e9b01c7cea7ed374d915e77e31503fbeb6209ab6f680da7fb10ec9fbe77494eda71a8d852f575b8b63fbe360b98dc1de7c6a53ed0858e881958a814fe1041af5edf2a6c56d663b0481b8c5d6efeb946db4f6ca31ce31e52d1aa9c872beb22df3219e38e56f70cd8debc5e0fae7d8f3f3947d844a8d6027db977b32fb14e644bef0510edebf53329f88173488e47cfb9fad2b52629291076dab3a5cc2e1c76811ca08804975b3a2df938be7dda482b5679a949d470156f338cced1085465a330c717b77e1cee71f90fb67cc890f31f79317e808d059458a7572a33efffc3eed139a8f5ae0ebf8c4c48ddf5a3db72ce21f18e0ea62d4225fb1722ebb0cef4de2655d0aac978972734e38432873f8ede6826b9729faadbcb25619f57b969111aaf6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
