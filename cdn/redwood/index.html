<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3e0b2bd58575c00ba390aa4133000ebaa635fb7ff9c83c6617b2f7018d81e9f0d084f27c30e7ba2783f6935cb41a15ca88cb3a3a5da1122bda9ad07367ee013b6c5caa816962c79a7118d5ac5774dac66ce2477c59bc086fbd71ae54e95b52c42c0a3e96978f612d07f6313acbaa4a2fcd7e1e4bf2c2487b233b95938a415d2691f5002b49f094eddff05d4dbe9b16cbd6ecbe8f9a8d2380323211f502ca3a06b5539bc5c6588095e897ccefcd22fbe96b52dc662aa8421704e3e9c98b82f1a9fdb753e83d784c2992d162c526b695cc44c0f4c2381b76695b09168033891584cf3c779df1ec27dc9762996603b67370fffce449afd10bdfb04ed3d8a04ec5aed6625156173f22a91d6011eff7ea995640245038ee13db1ad75c0c3cb149d305267d1ed963cec50bbc0a177f60450b19dab00a4db3984321dfea7b444b11760949b283d5e3a6d2df70f2f08e36ad303aa3878d3290d5a73900a51fb3a8463c0d0cc9c6b1277075106f4feab0412574f85ddda89b67948fdd5ea356dd1ae6bd5c6793c0eeb54924deaf183799db678a2aa8570ef56560d09f6a478311d8d4522e5832d5c089310a53d853cabd9e449d6e126e4f17b53d5ab8f917ebf199133552bdc77ba32a47f1a495eac3e7697eed37cee55039a60d359d3f9df0556546ccfc75f10c9a3f4797d3b9944b6ee5fb42a01346cc80f6573ec30db5527471aa9731b5a7d9682c3c6c4801d7ae30305fcf46b9bad55c6c0cb9e20606b161d5ee170c6ffac0d3870f339b3c7253b32e0d71c2d6cbb99d9b8e08ed7b8d1d973651ea1174ac8c22d3fbfdc1ee24d548d3c076b3b0572c4129d38a99d6350079e4764e409fc581ce3e9d162876a99ad84205df0131fec5ebbaf5c6ca96a7a29c9cf0f96f774748c44162c2cbfcb626f8fc0a44531df3c0dd36e38533702761a3210d18928d092846af83851e7c322dad27c48c7a83af0836583268bd1ae49ae1afcb2ce16fef25601f8a596907349568d7f919cf5463cd6a62b7161d72e5ae0dbd5ba4f1a1d3b6cc2482526466dbe1658324eda4ff2ca056a525fe4d46c4ec6d8bc940a0677b7ba884b9e3bd1e79cfd1342f103b498595fe20863af62802e63b3d47e2778a7b2c9b1c0be820d65a31e153988b24604cd984a5189a6d74b6bb7363e794a002d2bc6f4ae37fc8914fdac59c3a1bba2b2472b428c8076db9786cf8530eabe60f6fb6785e980e1beab7fb0b32cef0e8b4ac9b1311ed160cf711caec1b98811a9cfdce0f2e18a3a16c80219934ae1d9773310219d1d2eaf21bab714a32c265e8a8c20193c1113334031b5e20b98c230d3b02cf8fb7598414f9e02e52843fe25b4f39cd60f06e6321caa60b3ab3c171e5983b04014d6839d0af7e1d8a3657c614763259fe955292879d52aecca381314064780e6fdf7a8316ded15ddc07888de4ac8a8e4f8667e7de7a09d0f4759d1fe64def71f2c69c99ec9e754b80599188198d3cb8aba65d572874100753422265352a01db097805ea63953f7c1ffd8136ccd9fd9e5447a5c55ee1dc40fbdcdb52008019fe59e192c2e5eed241d7c110f938b58ed4986173e72398ad8981b9b42de1dad060b80e836f0931a878e73fad51d61fa59374aa2a106873a5fb909fb8910f13dbc3925007c6f9e5da55e62a13f4f5e234088c2735ca34af2cb526ad2dbc2208f9e2e547b19463060537dcf07599d090ac240e78b64fcc8b065ecb2a5384501432be534f0d67f02721ef474c730f68b3326bd6d9c55d364a380ee2a792fa5758543a4ff517f79bc16d832ed455100966aeed86dea26ba65884f9e4464ba54103da302bbe875b10e01530374378a1a0eea2d530ed89cc92d68e6bae268c176c3db0463e4e0b35e0544ff4e2fab6285a9ed6e05418757bd6fc68cdde696febf8d9272fdfc3ad6ab1bad13b1d78cda956a78119c832c9491a85ac99194bb0b7f270d73314db0d556db4c024f7d9ac7749e10a328c3527a6806c39df7aeb43f41ddca30302a3a64952915b6849b9899f2030c5a972bc2bcfc38d99efe543d642f037612539fd2c66609ffb29fc84bcbb70ef3ffc7da2eddff78a8a7044fd4a63f222aaf9940bd1a01527675bfb545bf01488e8df3739f6e0429edf1c094de62b77db57654d71d1b418df8b75ac2659b11e3f0eba96f4f6c6159f08ca6c204bfa4965ee7f1a2878eb9abf1139c6a1347bf0b9281838e045a7e50c342814add35d7805b7ecc4917036bcbbc4e7b9445b749fdb3aec1d822fd769818cc31a52ae576a9a2fd7e9b52736f83f9287be96d2a15f2a7715d2574911b3b843a2b874b29781f4a5bbe2f8e18440db07b4f2a6f967fb4a4f92060f7e5c46715e4907c790a96b6b949fa54cb386b473cab467721e7399ad62e159c1d8d910eb8f4af5e6a06bd11adb92164551d18fcceb88079f2ee9cbc182c1b605e799adb8c9030333969cb2a4801a52c0fa0d37f081850dcce7469c530bc75c2d0651ed61b0a6445920968e265d4b694f78ee84ad1f07ce41fae3b117ae0a6e3b7bf7360ae85629a49e35f0ae0c83b646b1b6b1c33ea6577c1914e4d288870bae327ab8de1f7a105b764715bee1956775d3508dc833a3f29c14580b0965b9eb0da6edc10ac7e523038abccca2b7a368172fca2946a9a25dd2c1f764208ab0cee9961cac05eb8fe38be6d4357cbc657a4f08d921e31f3bc961c43456f71872e08c5161b15fb889254c98720093d64ea8e2c8e21ee3d13f87b4fd52c20b21f5450b4dad282160a1bf557f573f78a74b4cbef4d03a9f5d40b03eb3ac7574681e55f85e9b0519c268007e3590b0f19debdf2b7e8f891e4bb1bffe6b78bb7368b8f1562e5edf55b24949c1451a4647728afd8847e37e2270f81a4968c306e3696951f8089e6143cee5a7c6bf213d221eb913b1e02184e28e57d432096c3a190f2da52b9a3962726be7f11ab9f5486255229dc560b2576ba9a92095c9ec2b7a84083e9bd5e322b57a9fca448ab906c19f90ae67ac3da010368177d576dd76dd21c56abee9aa122324a039b41f32de6287939f573cb087a865be760d4c02a6c23e7990aa6d1edc74845080ec198afda79a200aadfbb2c3b0125d297d5b1941a957288fd47fc67164d102ec175d6ff6862afd0873f71b884a065f8a493fe78fff4fa231173f98738a4d49f516497f112dea0aef7de34b32b23eed323014ee1b0a7f48943da0f45fdba232eb48ef8bdfa2907f9454b242ff90609e79ca1a9bc232ed0e36e8be189701b8f4f9b1538a977f85f52efec4e7aa337670ce6778e7af2d99323c301d0949fe2d76042aece2935cde9f11d0a7d5f5a4b6b788327eef8736ba597575e460ecd5b9b70708c4e4044e71b6b348b04314db88c30c2c71fe5f71cb7e9cd653779be6ea254603d52ef9fa3d4413ea073fea14c833804dc6e0687698f52f0a2eddb8cdc4769211c2f91f0ee1ed82f40fc904d8cbe79692175b652914a8fd79f6fa9da2f608bb249478fa61b8f7eece57da2967ad6756afecb344983063e6fd2c6b550593a109c4fd5e587def1f241fbfb67874e8c945d7ae6a109df04bd6380b7aa6f4d6e67c9852aa5ec43655584bf29f6ba368eef664197838ff4add1b7d1ded36c9e47ddddd9aab91247fc598bfaf03254d2dd7c9fd1940a466b7f67abf3aa37a411d4c3f3ddace361b1434ab0cedb89fcbad3f9c53a6b16256bcb25b3e8383c4321baecf8de6bc71de645b8fb22cf997db826999880720ce3e71d8734d6c66e91613356c5f4611e1ea862095c20379c83e02ad7b6cd5f1488e62ffd22911567e8b5d097399195aac628ba04a28ea14c34cabb0d5907519d372d6f820e2ec5179be10d582bfa34c13bee3af0f9f0fffd82ab626b58bb90ec8d8cf520225a64351f049ce6d82559ed1817a1b751efd02243672f3e1b56d1d9a1fb18f3fb71a50bd632746fc7dd37533bdfb49980a561db8d570ed0a2c140726d321e6550b9d7115099ab98debaa68aa20dd0b2b9b0e345e1611ea6f45fa1253f0452500ccbb22b3cff4576a75cc678690186d4e3ec97a0a85e193533ec445c0051ff9b47e05b7c765af0ca5c2430976563d7bdb5bf695a1294aa128d02b3762eb4eaeb672b4b3b3f990254421862da2fc9838d19852e0cf377db9185cc297c1d3cc23ce30795756651898809fabb2a4b81fe3165f89ccb2ece21f1cf82de76b9b35075be1c55e8b15996d9f10de85c41cbc70a7a78e4652a3a71a8dd3fa97f2c9b50cafa4b439153a1bc59f198c6137156d614cbb9a52af46cc1cd6c4fe11d08d6a59429ebf767c6dda9da5213565d2b1fccbe99acbd11ad775f689d70e5bfbddc84e513be02f0a31804aad1d98b5d72ba772f1d7483964f50d906272dc8a50ae746256f61ca94e91ffa885e7da80bea3d9d9e6a4928b40646209bdb2ae5ecf2f7570d85060f9b9e60fa030d28ddbb31649a6e882632b934ad968c3ad8cbc7d90f9ce0def8a47c0d4edde987e75d872cc22264c3ac15fb2961f5c299afb6dcc0ee261308ea8894c1c3ca27cd5f7d0b7fc147a877de6c31ecb6f539bbdcd18f3cbaceffadc3432e6e1515edb3008778ce17f77a7d1138675d097296363beb743b571c04bcc7dc63680f28dc2db4c97f2bb5c096965790baaed37694af89ef93338beee57ee73cb7ccb8120589d3394aeedb4aba4c185e943da2832f6108d3ba738bc4d53c35e0174f7113fc8aa7539dc6bc9be0578c04d597d62ca3543729b4f07584a496f0d540de08923d9ce5b39bf686b0e1837452081379706f9015e92623278cf46743a328e5fb6277950a93f6fdedec8bd912b9065836ca9c724fefe4628831c9d51b590388f11ca5dcd203bc91d4d5aaf9d3248f130760a08f24d8a90b027202901d4fedfe6a3c33a4e40feed1b5a601f28a92c622925df1997202318c7a89ae207bea56c03f21911d484829fd4a9224b0c9a107bce16241a34c78cfa2255e9bfdd9835e91173842dbd62944545d2c557d2e11b5a8e7c7953d214816c7a9cfe5228b11414608477be1e487528d9bbb793accba786f0b1ab198fa7008a8ffe0a7e4006e000e9058bdea8c2f8ab6949d6eb5df2ed18b6820fdcc7f5549e5ec98148543994481af3567f6af016d1c075edada3d4b9b77b8de56ea1973ffc1d53cbc9c5546b124d2d10a2564bfd5b1bacd0ff9e33846bdee37c7db509df6b65848b095756f3da8e2a5db9cbf22b4f0ed9f208a378af6ea8d699ca81af593da42fb85a3b4e6687e6da7c39200aa1c0607bf98567b74e56a70cada2547c7ceaf5888e7de11d6f21014ee72dde88840722a860ab5064c3fa7761bc5ef0ec8a0266a253875b29b34778ecf1337b96893135c21723d6037617441ab5889691a8adda49484c1a5b32a89728d2b085fb624dd2d1b71b24c074f789163ba5b071e8384972ea2c4fda8d9eab0d836f39b60fae0ad25563c9408d3941876dd897003314038205e2a08e9efd0cc94b584543b2ec94e189b6c14ff109c9712bf7babfeb36b13f32decec947b7293f417b56a216a586f9abdeaf21ea39c61c88d57af9ec260409662f65d3c49674806245e8f81c458adfba48e24c6bcd3b8fff9902860e10505fb490fe7a62a2a6177ccde841a6e9962a3681565bbe87ee67450853dbae2beff2712c4e860bea5c7ca40576a0e13bb19236652f7c411e9c98077edb8cbe672cc6af0280663bf8b786c64dad9ffe7ace278b2aa365110955e27c7f7c996fc78b76d958a39a198f03da1ce94ce9de73c37aae0230f5c6cbf41aa26281c256466242d6b96dd7825d81eefd3fc2d6dc7acba07be62bdb7f3d176e8a3cc2b3cba828790dca04f7ffcf530f6844bbc666ef0d7cc0ad529db45b8585438d3b2ba7e196c0807e9da3e02886cc7fea538ff732c0a4a3dd2a7bf226e1b5eb86e0a2d65ccfdd705490278d0755b3773e3b1189b63d1d4cbc0b2c755856840546a4aa8a5218013a14e2565b0cdcaa05d28a175e33e3aab8e4bdee0ed9c445daa8ffb830f3d6b206610e49359da03965e7bbdb0fbcae7ed740b750a0c3a787b327b48e8af4f14fb5488783bf67ea83b137417d05e931bcb26220d2618272b929d7ce8d2bd41a46772d0dc17d4f8bd02114d70f39f9d467e684250524c38fa4ffa0139c1479184e0d6ef83e77c2cf7df3a086f5986f608c7bbff605e09638983d7fde547fbc3b116daf3811f098b648a7c7155b2445c604efc8b76d4be36a8f15199f04beaa89f783ef045c12984d0aead001f43e78bffcb1c7b3b693aecbb79485247a21863792440aba74eedd7ebe829b09b4466b0e8d22e774dcee029b82c322336c51d1ae1c4159decc6a4370b8c5afd81cdceb40b13130a82351a4bb2c44322f8144e5de8b11c12dc929d444cbd524157c848b84bb6f4ae4c6a962fb5acc09930a64acf1813c2b5876616e2ee8940a4907cb0a12c770acb9359ae49c05767dbb0b2bba52a722f04bfd64b589f46432f528f7e98a33f974165e328cd037a58dc4ec132d1ba42fdb6f51234f5f9af90d32e109f1cd3afb178db84c6598edbe7f711dc0e49e413366b3433cd5adf1feab58b8dc63dd3918dc77db14926cf3d634d49d86ccfe791f3d70b5a9b4797edd198cc5781572a116c42de3fed772f31d52fa82490657eb7aea7fb4af5b7271dfb695f2738493306897c43d09deb063d08835f683ad5511a940444f3bc5e293d917ba83d0b30cf058c7e60b8dd4ff11eaf1788be96036bbd4389fc5c397fc77711030e0660151ac4db1f4b8ee13d32136b79b87335633c05e2eb862fc6d40f3ae9b5ea5de23462e3c869dc8e3ea077f66edd30697f37b86c1ca4a90e381a2606ad91f3e48ef3266981e7d084c4a14f70c76aed417f3d68c2fbb75f9ab1ce96c276ad7d793fddbb1726d92aa1732620c59eea2decfd18bfab738bcbf9be893ac986aec2cc7de2badeb12357b292bd45d60f27f18a9416c531932630c07bc855d623d175503303377312b1213b4905a48e293c6170fd93fd4173998cee310d8d7b33ce2b4c0e4bc6e6283766f3735420586e4b4f1e9dad4af7f352b2df909522311aed97d954e76f611d007ee48b15b4f97f0c5763caf102f5cacc97483c10416e5b70bfcd3f1c3c380fe5c17616970923dfe52feb46758e09c31a8340afd410a9b7c50a1c09fadb458fae701231ab19373d631625de7a4fb31e7bcbfce03615bcfbbcd65705d568b6200ca1c134bc5571361c0993732ece1913d99a8e1490a098260f9ef892859476be602920c3409ca76b5eb2e87dee893eea05c36c6624a831ba8a047796406b128f24c2cb18b89e9e5cc0ef9ccb0150d84e56fcb8c72273514dc89f5dfcc4edda8e01784ab7e6891ab12479130e42ea90936fa5d8166c4f8444e290f5fd5f6948a0444089318018f33f21f029191ce7f983a54f5984e125a9ac7be96d3fedc5681bc70a83bd7ae931e3aa85ffd01b3f3c5f91b4841be2cd67f94f921598e0b752cd9b2d699b76737a1da0f3a1238d8cc0fb20aff899d29f667a88e184a9c0248d9c45ed1f92e79e3c0b2a2ec66cc8c7a73acc931537ffff043060a4160b498cbdc4d18d458db90ab0d46b41e47ea86f8d14f93e1ddb1c7042bfa4c1bdb586374895a8ba3b01a750bbd75be93b2990cda4106f6072676a96345cecc6d8a1bb1ff3be38c0223bd6e424b3cd04ac22b401a9da339e12e37c831882a2ed0b0f11f9736ebb205435f5017ad3e3c47d3c789b99f35917b372fa5bcae82a842c17480ce3d5d505ce7ecedf9b571662d83b295e948af8380722d6dacf6b4b75ece4a56b8cdd6bbf44d78ad4114688448bfefe26d5d10d8861f4069280ff8fddd785c4c0bcb10d46c318b55c59498a8f1dc0e9ca1694f8d187c5d7766a4f467143e0ab3f547c8ebdccb9d5d7eefc2634f2208c771765528243451751a78dbc1ff9f190d94ce2bcd398f582138aa10d1ff40858eaabfefc98bd9dd77cfa703c1e617060cfcc3b18acc57740f98f4ebfd8dac8e2dd0b48390206f0b1aeafab42b6c67d7e8a9c1868f50eda61e94af8ac21e2a9ddc7e1f7d9fbface0f3e377f4d29f49e8a7af371e4bffd720fc1f409dc390a533c1c0855e5cb9e2b6608ffbc90e26714fc3e887332a69ca23de5c70cccb5a65c391c0a73bef975d7c99a38a7ebdea25bbab86038b6b1391509c123f55c33bcf54e4c2aef10809ecc5bc2d7018a06758fceb17871e9a89a7adb2e6b54b6680836790824d39af406ffc0d5e5e9960ce54618ccd54256b8dd2ef9f494912aad05626a5cf6f6544d5e87fb1106ae7d4e1adcd5e227a9fe267e24f16ad3ad643a72a0b28818f17930005c314f6852114cff5ad4ee64715ade39d437eca3922968a1ed848b5cada868401007ce893256f6ecc17cec4e4a4cd051f53ca7eaf117bfa52468749a816a9e0aa745cbb097b9ba35286b7df0fc4453d58ebc5428e25ffeb62851ec010ec2c9f6df3c2bc0dba86b4b9c0e15e101926d36233d86048fadda1910415a2ca289eafee71d0707cb720213b1e62afa86818a6bc6001403fdf5d443daf0cb299f927e3057803212f8105520fd61034e6470cd216f476da784b01291d05a36d6819d7ac843ed842616c9e4a45e98469c1630087060348e478924ec12346b46b54448c58602903f8daad50094b0fc3b9138241579e8f9ef430af2af4b731c9bd8f55d09fc4a76e152e4565eb1a34071fe1297fcb43b3b5b39e5ab88b516207600fe7f862d7e926fef1b9313996fbf1c7469509cb7bfe43fa2de935332d832b797a28c0652fba9479090d6188face059f85e08960caad7941530a2442f67d2c2d7e28be2286af4b5118701e2689c148912a3a5c06032e1fc9cbf45ee221a58349dd5578855bc5ca4780a79194c0362ca1c702de2b3247371172371903fb09a73572e276c05e74729f0e815a8344803a619f93fa43737f78d18dd3e582c923b8bb4890cd035e1ef8f3fb5c539ce8ca42418833232447796d7de6a34489af2ed2901ce3b273a5fae4f32bc0d8a51e51f7fd5f51d87400d8073906abbfa11e62d8d21df5ef0f59d1f1db08929efd1242b29a6ec31e0f2862a7a462cc0ee5abbb26e129dfe2b4048ce59ba78ceee705b225436a6aa452d6b73f01a2fa783949bfdcdc57d2669d0aa3908e9cd2e0bb101e042d7a8be485269b85a74ace9dddfc899da55fbe350ae8a9f691bfdb2fc5d5f318d20ccba527b2261d9feff1de2f025fecf95e533b8224e351f9823c436beb56c07832b0370710a63d3d50b046b5c3b596c2239350f8ebff42ce41211f41ae2dc68b9e019c87b77a383f7823dea339c131e7b03cecd65200f9726048ecf3a032a92f2e411f6f6835b7c53e429967d2e5908653bac2ad9cf8d82172acfcc243157599ab3a9d4c47f9b00f00ab4c8d879e19ff952293799d77272e298e9f7aad4bc3ca8b37f57423b0ab4bd95a5064fc0987fbbf8065cd491ac8b30f3e4071a18236e5ec991583f69eac68cf8592efce0bd445dfc4284adca977682397ebfabacaf897588fc7f653294b5d38a8d899b3bb268d59b197d66835023747826272e9f6952111a2878500a7d4dd05474903fb14f7f5f26cac24d2a786afd34452e738f8ae8ad181ca7ec1d4c2d25521deaa3889ca90079e08fab6dcfa74644526999291f62bb86c5c1f6f0b600001c73326f8e0367d9a51e59aa0d68f37b629b492d9439c9d6a5c22614e1d937e1df7e1d71733c44fcecd1fd025db2b496b28550664fbe3a725957536c67093fbac7d6cd666b006ac83312fbae83a8cbb8573f4f508971c2ffb8c64fc69a73101c27f2200e6430955700cbf71fa21fd4adbd0bd56175ebe38942bddd61883093bb9174da4882cd44df267da45a7de3f73ddf462830db4762d9a0e706072a34d869752927214b0da4d5f253ae820175e0f7dfda1399e218497e5c58d44411ed3a7befd5e4213f5e25079a45c0a71bbf33aa59538a2500ab6baf95927f345afcef8aa42103c95026af54ac3dabad6d981dfab8c2280cd551e64e5e423ac56009aa9c0e9170cfc4f4baef9699a723af8bbdea56d2f8facbf4eb7b1052123e6818cc7650d19d6e0d82b7ae6d6c0f3cedef7ff678ffdc3ae1fbcf0282a1f5fff73c24f555fd0205ff1d866c245bf38be99d060964ec14dcc554ed259c66bec8da3fda7a22333fad75ec1969759fef3f949993f08b3e42752271c1d1936fc47389a482cac3cd2e86eef60b030eca264cab75d9059c4ea7f746bab5e434bd05e69e9defeda3e313d4efc7eb7888c4049398104d9685ce8469fd9cd9cafa6545eb122dcaee036e819419de1375a4e4323e0a1d49f2ef7794fd9357374c107369aba30ed29ebe934c2d5c51e0675116de44a0d711dbdcf1af57d266a7cb24de824477377abd6108c13187cd8c9b1f81a8d60e86ca6a652f7d6fb42ffbb2338c4ab9576d8e7067ce06fee92c8e252456ef12b127efc3b8c326e272765d3635fbdafb340cca74b762f835bff7128f8577702d9975d2dd13b499a7212cda2c081e3a533b6890858b6fe9f9a647fe427d0a669028e4415ca7f626c86d65f759097746b9d13cbd02b7db34f54e4e47a607faac7c93cce6c16f91ebf94a6767e80fe8b90892fecaa804f5321135f0d95a9685f87273de499eae9a1127d003c2a1a6dfed76fd44168934387dafcfd249e396d1f37469614b1429b361214a3ace16439df16a713e61f166878c243e42b51dcab8f7b9ae382e1faf1829629eee943c0c2e5014256c45d8a214b9f126229abec5bb79449958be64a70c37616d16fd3abeb2fee4145bf5af3ee0b323605b965eef306a6d31b9d66287d69d2cf6df2d8e87d62a443d1be0c51c28fb6906d2139898f188c1af1f794ec49f97c4a3c21d4af7157c1c8506e33d6bd0e8aab91a3088619bc3a391b863017c6e575a62060a701b4e013b0fe252d232034380383aeca69ea9a760d36aee6c19c1aff9399e3620167c99bb1d8de9bc7f562515925ccceee9696471a852d1833d4a36b3940f2ec88cc3fd2ff3f4deb8e755a04ad4f5ede310008cd5d7b641aec0829416b90fe3519af144bbb0a9f0a84bf490520017e8e7cf59f9e91355ef1c31ff327b124bd1a6c5d76f82f7ff43a72245a8ce9c607913aaf2929c0a3d9e49904270f905e7303f81c069798d93438554231d8331782b44f1d4966574733b62dcd9f2d86c8ec81032349471104806c1c66e9890bca80ee33749bb7d2ce9ab345e4663be7fca4373da651c452fe3fd2cfbc55a4bec90a2c1c13770bbdd904596992ed88a688b3c23823094a64c3906010fe95f559eec648d9d3351519a55f8c8e0531534f00fbe333f2c0b90c78d5bc0561c9dd213e182039019bb2fdb2d406421f0ced789245be53f46073695064d589df0f7d8ee73be80efb9651f8abadb04baeb95869ea4145dbc0bc2d4ac8fff0849802ccb842670d6bdb09ba575740f2a183ea4bd50355e4bf1775e261e94f2ecbb5a641b4ec4302833db996a586a44c41448ffd803d6300c4c3e04aace7dacea9dec8f395511e2ee6453452503bd9202aa1bdfb5ae7e5001397cf192dfd5182e453072ca0615520cea520db7635041fb290a9765d3b0a8f8647255f70ae8d226e01bfbb0cc45a603d83eda2f693c96fcf2f391fcfdcd0a66170d29b0107b65cdf8115493128a189a5e8b1f4ac6bebf1d13e94c879fa373cd855072a6e308ec134e12348f4b12f5a9332003552e27025c975f5f67b4cc9e99dc2b10c143c31e9834a958375ebc6ca8ea6879c9e1220c5b3b72cd4e047e594f3c4ec959eafe991afacf45977f95a1ba76e135059fd3401f7a32a3d5c1b886f45de0762a90000c72bdc0a7131c8b171ff87b563d14273eb018f3a3728113deb61ee34eb3f5fc8bfb1fb048e929547d9974edaa741462cb9b01399616c9a4e45bc51d28d9152e2de69528f69f0090ff7e2e851dafdca88524776d4b3b1f8b742639cc1b11cebf80e6ee3cf97c8036bb3d98444866a7fea9f4e6f15f0852b0d09d98f2bb406c9838728e6a3d47e4188b9b66d91cc3b7aa4890e5411a218966e3924c14e8250042ad4875ae3832addc88958dc0355b411f89e29af9f35dd7ab9576a625c9fbd31dc1b3e3ab59e5b1e089f2aae0a0ff6873e86b40b470ecaeab737aaa467f1ac78164df836e4b8c0015a95b35591394651f74cfef43213a11c2724086b5bf28afcfe98131f8848b0eaeb88eb034c0fc4aae1059d6643c4f90b8ff462eb8a85ebc32bd65f634f9acfaa2e301c0a36fe0aff6a900862779ae2553774816554a40ce9d07fa6ab8e8ad40dd38a879ec97cf849bd3f2c19729804de30e8ecb99346ea7eaf843a9a00aca20c41dd4e33136bc3f2c5e90d616ef6331843c39fe0226487781876ee557709ceb7367f0805883fa45dd75190f4be854ccbf382eeeb60047e19e07d907df1c7a43c246aef598268b25654ce384c000700bd0cfabdd2105cb0c6aa2dea9b767f9645062c0a294948d986216ef54a90b57af2754a43951341af2e0ade0a908fdfd668d82a33a67d651e13e84037e9a2ad77f0f8935dfd32f90370d6c53215d9fc6969c0da725531c63e02b90b6d5feff43b01b58d99721993f3af8f2b49cf0885a497100f7e93517b77464c9b55cc30b14374571f71bcc9fadbaa022fce5420ce3564e6b972eec3f06a138727849911c315e5be9ef34c80a62651bff978130018d10bff45afa89e36977f1764e34f5524d407a8a7b2cba65c9e979bf4a8f2a71073a7a4e3603bceeaa7bad8c0ecbd3796f955b3d007372016a354124f3d49a28d441e57e64462362a17821261147096d1cca1daefc0f91ff66daa3e260f58cf932e104b28022dd7b872dc97ee2fdb20ebd220df05dee7119dd647f00899e2f4b0c026f7c54878ce53443897850b3bd45508e08e7520588acb831e4a5213ae9a4eb88f3ec5d01764e8736043ae76a72693b4ba3832a50c77cbd185ce9b28f30d9c1d7c44d0e9760b56ca383a68148286033a9f598ad23355ce72ebb91e49717b858542cd1c55270ca1632f79888a2df2f9dc5562c981fe6b3673fd8bb01c56ea5b12338fc566d7646809f892bf6db05b2ef011b607bf797390c895fe971580735764be0ccf108cf7f9db90ad6992d72604728bb7b12b5b8412e4165fa05df744954196f2f5164984616e1ec30c9b7b49b012d1cfe7fcc4ebcae61135f1af0fb2505da8c733e14092b742729454f86d33973085248a5ef2df3b83d95a37f46ce3d8b6e4aefbc34d64a8165a0871b095b49bd243815a61c2aa218a1af3b0bb607dd3e6e54772384bc04349a664799245f4fa137f10f4465262c46b3349b559c1d717a0fc5577afd65cdbdf1e978209e7dd3fdccf8e184ead2c2fe66b8075e4b9c64ed0f583f3863d723cac7dcbafec3c49bc0f7138556d70d68550f56a92696a8780f1cc520c4dcaa55ff61a9cae074b4c11800b174e5eb7fe56321d6b17e93455f2dbf9249a3eb6d67740daf7d34fd97936d31b7f7c0a0afa290312cfabed29a795bc38966c815a0888a3f71a8f33cf89902bf73cee6a6fbc7712fd11dbf4e6ead42ed8f0cae8354592136e7d864d47ac154001fb42f73f375928270733f75966ebd67b5e8c0cf6cde29fbce29f2702cde84ce55802f76ce5fb59b19373a179b549540a934d7819ea63a6a638574c6e4b73d760a8f0e15867a0b073b1b20ce0ca343f44642901097ccd926cb6d445ec6be5e6d832e1071864519f99babe12a3d0d6dd7ff60b2a7ac338079718d172e5c18db706d048364deceb51fcc0fb1d8e33d8c9d46710fadc4bb6ac35ae58acc7abdcbfd652c1d18f541e8f6f30c1a9f5d6bba168ba55732d8d014b786a254baddaf22c7f4d684f369f06c94d3ae6237f154c7a7cc743091f5a599c76541e55f57f9f17a5fdfa4b76bdb28b3baccf74e0137dc3db14484e5810397075ffd8000004c407045a6d00b068ff67280f269ef0a207266e500574f999bb7b1c748f3190dc8795d962c52d35efcfa8f149ff4895a4472a8e4c240d7a24cd74a5cf8b2fa38023afb661f481371ca6a479f728ceb99612e51845997f054516c2daf29bdc33a7286f9624191005e26ca100e0b1d609035950aa393eca0049af42c79aa197a784c4bc6f624a8a4c2e09020782303e660b73f07598485b4282b823f47361454c17a19d8a8f1d99237ee59049ead939951b22e72214e445aec241bdeee8801fcb02c048d242b43e72574b890774b0208a280f59129525905d8de86540dfe3ceebc91210080e0f8839e5b60855ce34c974a234e6695bae9b71b23b2e3e9c7bae4f5a0b5a93e627e4c01b36426b3ba35ff101faa4e8d9c6c4e76378416e9c2407f1b869eab8e23103f1902eb6c8697dac6896d46985f94e49cd953d9c4778afbe7c06cd86eeded63b61fe6c8172386e7a4ad72a56b34eac6bc29935805dd5f227b15dec8cb5786098efec0b6f65e540f180185f19e1b8fdeca44928c338d24c3a9325863430c3a2a4d4d0c5cbd5a0445853a7c068c2a9c1fa84e5bc87d56a60f412a62e3738bc3829480f738154805f023ea19b5f74f6f7583b90ddd405f8dbb3f1f184883d047f3af964b53af435fd22cb2d9fc7226746214b37316f4f767bddf5166db9925496baf2f094b0f05c3c78ed20c7e7546971b303bdda29ae62467a9d2f8ce8b2cb28d89e6f5255c25920b6314616db6a3063604209fb48aec5372458b2ea7d0ef6d2c8c9cc716029ae99aa8a02f896b69866edd231da3922e5e3c2c81f3b6d296b82232106de6ea01b847085c8323747f5f81d25c9f6fc7b4203b08aa2866ea409c58a8e919fe6f95a3d8102ea3806c6afd9cd499bc185bf89e437deccf9ac60266095f6cb0b59ef6c8cca1148163442111f88bb1cb03655fe2ae63b13308cb3a4cd3e0718ac6c7d5e72f99ef75cd256019af2e76099cd452192a0a5dac8e97dce4e46c8428e40a357e695f6f1cd4a0a9e954c63a0e3e645247a4a965781711dc7187396db21b3e2b72eb8d50a9159ce0e8c81422597ae51d317e23e4240e1104562087c0e4b899caf17cbc6e1176088f33eaac13ce6582d21f9a925026d0702975fbe8ad35229b2d469b1e0ebaad2c50e45de378959f5659cf662f776aed636e8ac87754531f688cc316209e6f0d8506046089f0c8146d61f77e4491cf9b9b7c4703701430e253369ba0bbbfe53e03dc16af2e73abde017f512d9da6266e54e0ea0368950becfe3b6acf4c13f79e9b0be92d8fa8e9199540b1e5996a1fc0bfadc11f987ead428872da9d4231b1d29fe2679bbf13ae3d9ae23ff6426c30da6c892689da06f334102c62de32ba527596e1c0e234d3a41b541186ea5ca0e4af6264ee77ec715fbf5b6bafea6dc98715c7b1281ac54bc1515483bcff1fd5afde296755102189db7dd81e7f98487022c42d208d59b18e090f89d7c000c65c6013bd16d64a3c11e54af1aadef983d0a1a52123863d957b48e29a38226e1fd5362eeefe941b4aa79578d54ab0e9edb65b14fa32a7c22d60d4d429aad2759381c1eaf5aea4016d040ea7eda4036583dabb45a98bdcbec471f95f06640f18f2c19970899d017e79f6ad2ef95a245e990a2914ec5b0c61ee93901c8c9b728ae085428e9f861ded7ea8574738542c9b7635a7d3cdb09873bd6cbdfa369c8282c949bb25e33c609a7a714c56bd26c5f83ed7a02a65874949546ff3f278fe07bda68a2778f89601d7a9a51102fa15aa20b9c3e38fd09fa558f644f39b169e0b7c07bdb01ffddd2d4085309be8b6d92ecd099aff51b4ba3cbe6e10579d4a4010be9e604cbbd87578c1cdbb542c3a66a673804996c2acecb9ad58364783bc9e875a36d085ba5556c5aff5826a812f2cb356ddec6bcac2a04fca3b08e1983b1a6535dee2ca4963d8ab2ad2eac645e7f6b814d81390fdd65597138854a6726bbc319c5b15e58565b95008afb2a563a2650a182fe3265aac5bde8af0f3467d0df70c8e2d924c283f858c7b4a6027aa6708e7d9d77bf8b7f6af08beb529866084551d4698d5f2cbd0287246f0cb9b24a294bf40175c5c52721f8f2b7b36aaeeb5c84ca5c163140dd3f9323e5b1d9f423abc5061b5409cf1221edf4a4eda6a2af3c0f5f1c791e1290bc4950bc153591fa2d008ea8c76e0c462e597079dbbcf46b1d599ca952caeb6db7846b36a26bde7cc702e7fd5d7b88d23a533d87bd88539d4d78ecb85c2f03a367c2ed557675943fa0f7cae1c5c338c73ec570565f88557bf4ed6e8f83c438b8ab441870906305fb4db440e022a2e74140dcedd4427bdffb1cb16eb6655688b113245d1cb9a35e71f6d37befcc25d8627d170f006547db7d2f9b44ba65fda878ed5c0de26b05c66625e3c7e7a76f4287baa1831490bf2cb1463dd98bd6d34215218f981fdaa79c7ddcc792b918ca859b9fbeb322204cd3e03542763587da0270a640cdc32ab40e8919f5c3c232ec22639efaf3400e93851906d8317a7b1ddf95aac9ce504a3aa6b564168bc2c854f7e16eac200ffec757a01a7923744862cc1d8f9a463e65e2d6e4e8dccfbcdaaa5f4e6df1d9ed72a82cd1c2af3b2a1d75b8a4c7f9c4328c381a062231ab8e2781d7300ff81c782960832c5960a2d57d1994ca07ed080cf585ee3b9b6331c44f911a75349c4a253f0f87bd59bc0a3618bfa224127d5775b91011d282597907c5ca6d8e5481d3a3712918bfb063063ca1e5cedb753820d273310304d96288dcfe85b8b7d3fdac243197961c53f1e060fb0dfad610002a1d913400b92090a11bcc9863b663c21e3ab5873d32001c3c0c6fdaf0526e800598cbb480134a0272ba1b68f9f1427e0b2b98425f394103ac03d15241e5f30185b129cb46f0823a09c10bf9cf1d7efe458afbb52819384b9a7bbfafe61fc5162ef7cabe5d411b769efd40643626fdb1ab53093eeb8ee5f497a6a8b49d603624ca520001b678f56008027fe40d5cd0d213c01437045907252bc0aaee8df0cf39f53afeb1e26f481c058360e0bcf7580a906372f8b9a39e90309750b73b6500b7bd1c1bc79fccecc94123340eddf0906e7af1166f54569013725b8a95642d9a87bf937f1a319736d88d3164901adcef7925bacadd934188ab88f10a77ff3d4e8a64cad236bebf1b746e82fed24583b1e71010a9a29d7992ae9c887b05a71ba1d0d1bbe685703fac244459b0d65210e665db324d2fd6ba8b67a7d10860f0e0404b689b896748bd438ce75f8e27247a2a26dedd20bb04445f9ac93ca19d44511dba268ce081b27c713193f5672162453d657443524370d8895cd78bdeab505dfc7af726614013b16708b9a38c523d1dcb12b4e06fc0cdc4508686fac9074ebc7df59c331d40de80d4d24e2900739ae22f68091d2e289bb5cbb95db29eb4ce146cbc40639132fd6f6d52de75aa1d7209326ddccf5cbeedcb9e28728fbe6a0b59eeda8d6a1a59d32d8f491876e5507c661ea4fc60da7a5ade7c070f79b098494fbd38c207b3c8cef0b799b7ea978d7287113442f1aa471b0e9b9178f6ccd92d991d44dfbfc80e00ae0f1f323d42144f443ba26a34e9d2420a625ab80b1a5a15b49be2a48c7781432062f53c92a3ab6188d9663be162230dc80cf12afcd5a79781f3613eeac628b8a0aa5ff3f67efe10c4bba58d361ef8ac2d714bee61c5a02bb519b51092ac2a085f5b75fda8ea4add9dc695e21dc6bbfdb8ceadec479da349e3a4e769a6667428b2b038dee309f88c3d54f225944236de5f56b72b2562f4359d9b2f585a2b25b20749718da7f0962dd553ed684f7702a8a81bcc91e76378c1f4cb3bcf0036576e20aaaa5b914177c26fb0dfbc35352b9d38e944faa0a03db0175e0b0929c058811bd9ca9afb351b122f53f08daf277dcea05529e42cabdfdac65994ca4105dc3413f16f3895f02309364b28cbfc57826299e96d09ae83af276df45180ddcc3ff6503418dff9611187a1a3d9609d1309b6c81f00126cf3714c19d9c4bb5ce7eb667cd11dac7f5900cfb083","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
